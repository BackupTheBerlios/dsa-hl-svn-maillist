From blakharaz at mail.berlios.de  Fri Nov  6 00:40:24 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 6 Nov 2009 00:40:24 +0100
Subject: [Dsa-hl-svn] r4958 - in rl/trunk: . engine engine/ai engine/common
	engine/core engine/rules engine/script engine/startup engine/ui
Message-ID: <200911052340.nA5NeOCd029859@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-06 00:40:10 +0100 (Fri, 06 Nov 2009)
New Revision: 4958

Modified:
   rl/trunk/
   rl/trunk/engine/
   rl/trunk/engine/ai/
   rl/trunk/engine/common/
   rl/trunk/engine/core/
   rl/trunk/engine/rules/
   rl/trunk/engine/script/
   rl/trunk/engine/startup/
   rl/trunk/engine/ui/
Log:



Property changes on: rl/trunk
___________________________________________________________________
Name: svn:ignore
   - logs
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
configure
dependencies
*.in
*.cfg
*.conf
configure
*.log
depcomp
config.guess
config.sub
ltmain.sh
rl.conf
Makefile
test
mkinstalldirs
config.status
rastullah.cfg
libtool
autom4te.cache
missing
*.m4
install-sh
_dependencies
depsources
doc
compile
.cproject
.dep.inc

   + logs
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
configure
dependencies
*.in
*.cfg
*.conf
configure
*.log
depcomp
config.guess
config.sub
ltmain.sh
rl.conf
Makefile
test
mkinstalldirs
config.status
rastullah.cfg
libtool
autom4te.cache
missing
*.m4
install-sh
_dependencies
depsources
doc
compile
.cproject
.dep.inc

CMakeFiles

cmake_install.cmake

CMakeCache.txt



Property changes on: rl/trunk/engine
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log

CMakeFiles

cmake_install.cmake



Property changes on: rl/trunk/engine/ai
___________________________________________________________________
Name: svn:ignore
   - Makefile.in
Makefile
obj
lib

   + Makefile.in
Makefile
obj
lib

CMakeFiles

libRlAi.so*

cmake_install.cmake



Property changes on: rl/trunk/engine/common
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log

libRlCommon.so*

CMakeFiles

cmake_install.cmake



Property changes on: rl/trunk/engine/core
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlCore.so*

CMakeFiles

cmake_install.cmake



Property changes on: rl/trunk/engine/rules
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlRules.so*

CMakeFiles

cmake_install.cmake



Property changes on: rl/trunk/engine/script
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlScript.so*

RlExportsRUBY_wrap.*

CMakeFiles

cmake_install.cmake



Property changes on: rl/trunk/engine/startup
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

rastullah

CMakeFiles

cmake_install.cmake



Property changes on: rl/trunk/engine/ui
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

libRlUi.so*

CMakeFiles

cmake_install.cmake




From blakharaz at mail.berlios.de  Fri Nov  6 00:40:47 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 6 Nov 2009 00:40:47 +0100
Subject: [Dsa-hl-svn] r4959 - rl/trunk
Message-ID: <200911052340.nA5NelLh030270@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-06 00:40:44 +0100 (Fri, 06 Nov 2009)
New Revision: 4959

Modified:
   rl/trunk/.project
Log:


Modified: rl/trunk/.project
===================================================================
--- rl/trunk/.project	2009-11-05 23:40:10 UTC (rev 4958)
+++ rl/trunk/.project	2009-11-05 23:40:44 UTC (rev 4959)
@@ -31,7 +31,7 @@
 				</dictionary>
 				<dictionary>
 					<key>org.eclipse.cdt.make.core.build.location</key>
-					<value>/home/blakharaz/rastullah/current</value>
+					<value>/RL/engine</value>
 				</dictionary>
 				<dictionary>
 					<key>org.eclipse.cdt.make.core.build.target.auto</key>



From blakharaz at mail.berlios.de  Sat Nov  7 20:37:09 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 20:37:09 +0100
Subject: [Dsa-hl-svn] r4960 - in dependencies: . tinyxml tinyxml/docs
Message-ID: <200911071937.nA7Jb9St002918@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 20:36:41 +0100 (Sat, 07 Nov 2009)
New Revision: 4960

Added:
   dependencies/tinyxml/
   dependencies/tinyxml/Makefile
   dependencies/tinyxml/changes.txt
   dependencies/tinyxml/docs/
   dependencies/tinyxml/docs/annotated.html
   dependencies/tinyxml/docs/classTiXmlAttribute-members.html
   dependencies/tinyxml/docs/classTiXmlAttribute.html
   dependencies/tinyxml/docs/classTiXmlAttribute.png
   dependencies/tinyxml/docs/classTiXmlBase-members.html
   dependencies/tinyxml/docs/classTiXmlBase.html
   dependencies/tinyxml/docs/classTiXmlBase.png
   dependencies/tinyxml/docs/classTiXmlComment-members.html
   dependencies/tinyxml/docs/classTiXmlComment.html
   dependencies/tinyxml/docs/classTiXmlComment.png
   dependencies/tinyxml/docs/classTiXmlDeclaration-members.html
   dependencies/tinyxml/docs/classTiXmlDeclaration.html
   dependencies/tinyxml/docs/classTiXmlDeclaration.png
   dependencies/tinyxml/docs/classTiXmlDocument-members.html
   dependencies/tinyxml/docs/classTiXmlDocument.html
   dependencies/tinyxml/docs/classTiXmlDocument.png
   dependencies/tinyxml/docs/classTiXmlElement-members.html
   dependencies/tinyxml/docs/classTiXmlElement.html
   dependencies/tinyxml/docs/classTiXmlElement.png
   dependencies/tinyxml/docs/classTiXmlHandle-members.html
   dependencies/tinyxml/docs/classTiXmlHandle.html
   dependencies/tinyxml/docs/classTiXmlNode-members.html
   dependencies/tinyxml/docs/classTiXmlNode.html
   dependencies/tinyxml/docs/classTiXmlNode.png
   dependencies/tinyxml/docs/classTiXmlPrinter-members.html
   dependencies/tinyxml/docs/classTiXmlPrinter.html
   dependencies/tinyxml/docs/classTiXmlPrinter.png
   dependencies/tinyxml/docs/classTiXmlText-members.html
   dependencies/tinyxml/docs/classTiXmlText.html
   dependencies/tinyxml/docs/classTiXmlText.png
   dependencies/tinyxml/docs/classTiXmlUnknown-members.html
   dependencies/tinyxml/docs/classTiXmlUnknown.html
   dependencies/tinyxml/docs/classTiXmlUnknown.png
   dependencies/tinyxml/docs/classTiXmlVisitor-members.html
   dependencies/tinyxml/docs/classTiXmlVisitor.html
   dependencies/tinyxml/docs/classTiXmlVisitor.png
   dependencies/tinyxml/docs/deprecated.html
   dependencies/tinyxml/docs/doxygen.css
   dependencies/tinyxml/docs/doxygen.png
   dependencies/tinyxml/docs/files.html
   dependencies/tinyxml/docs/functions.html
   dependencies/tinyxml/docs/functions_enum.html
   dependencies/tinyxml/docs/functions_func.html
   dependencies/tinyxml/docs/functions_rela.html
   dependencies/tinyxml/docs/functions_vars.html
   dependencies/tinyxml/docs/hierarchy.html
   dependencies/tinyxml/docs/index.html
   dependencies/tinyxml/docs/pages.html
   dependencies/tinyxml/docs/tab_b.gif
   dependencies/tinyxml/docs/tab_l.gif
   dependencies/tinyxml/docs/tab_r.gif
   dependencies/tinyxml/docs/tabs.css
   dependencies/tinyxml/docs/tinystr_8h-source.html
   dependencies/tinyxml/docs/tinyxml_8h-source.html
   dependencies/tinyxml/docs/tutorial0.html
   dependencies/tinyxml/echo.dsp
   dependencies/tinyxml/readme.txt
   dependencies/tinyxml/tinyXmlTest.dsp
   dependencies/tinyxml/tinyXmlTest.vcproj
   dependencies/tinyxml/tinyXmlTestSTL.dsp
   dependencies/tinyxml/tinyXmlTestSTL.vcproj
   dependencies/tinyxml/tinystr.cpp
   dependencies/tinyxml/tinystr.h
   dependencies/tinyxml/tinyxml.cpp
   dependencies/tinyxml/tinyxml.dsw
   dependencies/tinyxml/tinyxml.h
   dependencies/tinyxml/tinyxml.sln
   dependencies/tinyxml/tinyxmlSTL.dsp
   dependencies/tinyxml/tinyxmlSTL.vcproj
   dependencies/tinyxml/tinyxml_lib.dsp
   dependencies/tinyxml/tinyxml_lib.vcproj
   dependencies/tinyxml/tinyxmlerror.cpp
   dependencies/tinyxml/tinyxmlparser.cpp
   dependencies/tinyxml/utf8test.gif
   dependencies/tinyxml/utf8test.xml
   dependencies/tinyxml/utf8testverify.xml
   dependencies/tinyxml/xmltest.cpp
Log:
Added tinyxml 2.5.3 to dependencies


Property changes on: dependencies/tinyxml
___________________________________________________________________
Name: svn:ignore
   + *.a

xmltest

Debug

.cproject

.project


Added: dependencies/tinyxml/Makefile
===================================================================
--- dependencies/tinyxml/Makefile	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/Makefile	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,140 @@
+#****************************************************************************
+#
+# Makefile for TinyXml test.
+# Lee Thomason
+# www.grinninglizard.com
+#
+# This is a GNU make (gmake) makefile
+#****************************************************************************
+
+# DEBUG can be set to YES to include debugging info, or NO otherwise
+DEBUG          := NO
+
+# PROFILE can be set to YES to include profiling info, or NO otherwise
+PROFILE        := YES
+
+# TINYXML_USE_STL can be used to turn on STL support. NO, then STL
+# will not be used. YES will include the STL files.
+TINYXML_USE_STL := YES
+
+#****************************************************************************
+
+CC     := gcc
+CXX    := g++
+LD     := g++
+AR     := ar rc
+RANLIB := ranlib
+
+DEBUG_CFLAGS     := -Wall -Wno-format -g -DDEBUG -fPIC
+RELEASE_CFLAGS   := -Wall -Wno-unknown-pragmas -Wno-format -O3 -fPIC
+
+LIBS		 :=
+
+DEBUG_CXXFLAGS   := ${DEBUG_CFLAGS} 
+RELEASE_CXXFLAGS := ${RELEASE_CFLAGS}
+
+DEBUG_LDFLAGS    := -g
+RELEASE_LDFLAGS  :=
+
+ifeq (YES, ${DEBUG})
+   CFLAGS       := ${DEBUG_CFLAGS}
+   CXXFLAGS     := ${DEBUG_CXXFLAGS}
+   LDFLAGS      := ${DEBUG_LDFLAGS}
+else
+   CFLAGS       := ${RELEASE_CFLAGS}
+   CXXFLAGS     := ${RELEASE_CXXFLAGS}
+   LDFLAGS      := ${RELEASE_LDFLAGS}
+endif
+
+ifeq (YES, ${PROFILE})
+   CFLAGS   := ${CFLAGS} -pg -O3
+   CXXFLAGS := ${CXXFLAGS} -pg -O3
+   LDFLAGS  := ${LDFLAGS} -pg
+endif
+
+#****************************************************************************
+# Preprocessor directives
+#****************************************************************************
+
+ifeq (YES, ${TINYXML_USE_STL})
+  DEFS := -DTIXML_USE_STL
+else
+  DEFS :=
+endif
+
+#****************************************************************************
+# Include paths
+#****************************************************************************
+
+#INCS := -I/usr/include/g++-2 -I/usr/local/include
+INCS :=
+
+
+#****************************************************************************
+# Makefile code common to all platforms
+#****************************************************************************
+
+CFLAGS   := ${CFLAGS}   ${DEFS}
+CXXFLAGS := ${CXXFLAGS} ${DEFS}
+
+#****************************************************************************
+# Targets of the build
+#****************************************************************************
+
+OUTPUT := xmltest
+
+all: ${OUTPUT}
+
+
+#****************************************************************************
+# Source files
+#****************************************************************************
+
+SRCS := tinyxml.cpp tinyxmlparser.cpp xmltest.cpp tinyxmlerror.cpp tinystr.cpp
+
+# Add on the sources for libraries
+SRCS := ${SRCS}
+
+OBJS := $(addsuffix .o,$(basename ${SRCS}))
+LIBOFILES := tinyxml.o tinyxmlparser.o tinyxmlerror.o
+
+#****************************************************************************
+# Output
+#****************************************************************************
+
+${OUTPUT}: ${OBJS}
+	${LD} -o $@ ${LDFLAGS} ${OBJS} ${LIBS} ${EXTRA_LIBS}
+
+#****************************************************************************
+# common rules
+#****************************************************************************
+
+# Rules for compiling source files to object files
+%.o : %.cpp
+	${CXX} -c ${CXXFLAGS} ${INCS} $< -o $@
+
+%.o : %.c
+	${CC} -c ${CFLAGS} ${INCS} $< -o $@
+
+dist:
+	bash makedistlinux
+
+clean:
+	-rm -f core ${OBJS} ${OUTPUT}
+
+depend:
+	#makedepend ${INCS} ${SRCS}
+
+lib: libtinyxml.a
+
+libtinyxml.a: ${LIBOFILES} 
+	-rm -f $@
+	${AR} $@ ${LIBOFILES}
+	
+
+
+tinyxml.o: tinyxml.h tinystr.h
+tinystr.o: tinystr.h
+tinyxmlparser.o: tinyxml.h tinystr.h
+xmltest.o: tinyxml.h tinystr.h
+tinyxmlerror.o: tinyxml.h tinystr.h

Added: dependencies/tinyxml/changes.txt
===================================================================
--- dependencies/tinyxml/changes.txt	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/changes.txt	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,269 @@
+Changes in version 1.0.1:
+- Fixed comment tags which were outputing as '<?--' instead of 
+  the correct '<!--'.
+- Implemented the Next and Prev methods of the TiXmlAttribute class.
+- Renamed 'LastAttribtute' to 'LastAttribute'
+- Fixed bad pointer to 'isspace' that could occur while parsing text.
+- Errors finding beginning and end of tags no longer throw it into an
+  infinite loop. (Hopefully.)
+
+Changes in version 1.0.2
+- Minor documentation fixes.
+
+Changes in version 1.0.3
+- After nodes are added to a document, they return a pointer
+  to the new node instead of a bool for success.
+- Elements can be constructed with a value, which is the
+  element name. Every element must have a value or it will be
+  invalid, but the code changes to enforce this are not fully
+  in place.
+
+Changes in version 1.1.0
+- Added the	TiXmlAttributeSet class to pull the attributes into
+  a seperate container.
+- Moved the doubly liked list out of XmlBase. Now XmlBase only
+  requires the Print() function and defines some utility functions.
+- Moved errors into a seperate file. (With the idea of internationalization
+  to the other latin-1 languages.)
+- Added the "NodeType"
+- Fixed white space parsing in text to conform with the standard. 
+  Basically, all white space becomes just one space.
+- Added the TiXmlDeclaration class to read xml declarations.
+
+Changes in version 1.2.0
+- Removed the factory. The factory was not really in the spirit 
+  of small and simple, confused the code, and was of limited value.
+- Added FirstChildElement and NextSiblingElement, because they
+  are such common functions.
+- Re-wrote the example to test and demonstrate more functionality.
+
+Changes in version 1.2.1
+- Fixed a bug where comments couldn't be inside elements.
+- Loading now clears out existing XML rather than appending.
+- Added the "Clear" method on a node to delete all its children.
+
+Changes in version 1.2.2
+- Fixed TiXmlAttribute::Previous actually returning "next." Thanks
+  to Rickard Troedsson for the bug fix.
+
+Changes in version 1.2.3
+- Added the TIXML prefix to the error strings to resolve conflicts
+  with #defines in OS headers. Thanks to Steve Lhomme.
+- Fixed a delete buf that should be a delete [] buf. 
+  Thanks to Ephi Sinowitz.
+
+Changes in version 1.2.4
+- ReplaceChild() was almost guarenteed to fail. Should be fixed,
+  thanks to Joe Smith. Joe also pointed out that the Print() functions
+  should take stream references: I agree, and would like to overload
+  the Print() method to take either format, but I don't want to do 
+  this in a dot release.
+- Some compilers seem to need an extra <ctype.h> include. Thanks
+  to Steve Lhomme for that.
+
+Changes in version 2.0.0 BETA
+- Made the ToXXX() casts safe if 'this' is null. 
+  When "LoadFile" is called with a filename, the value will correctly get set.
+  Thanks to Brian Yoder.
+- Fixed bug where isalpha() and isalnum() would get called with a negative value for 
+  high ascii numbers. Thanks to Alesky Aksenov.
+- Fixed some errors codes that were not getting set.
+- Made methods "const" that were not.
+- Added a switch to enable or disable the ignoring of white space. ( TiXmlDocument::SetIgnoreWhiteSpace() )
+- Greater standardization and code re-use in the parser.
+- Added a stream out operator.
+- Added a stream in operator.
+- Entity support, of predefined entites. &#x entities are untouched by input or output.
+- Improved text out formatting.
+- Fixed ReplaceChild bug, thanks to Tao Chen.
+
+Changes in version 2.0.1
+- Fixed hanging on loading a 0 length file. Thanks to Jeff Scozzafava.
+- Fixed crashing on InsertBeforeChild and InsertAfterChild. Also possibility of bad links being
+  created by same function. Thanks to Frank De prins.
+- Added missing licence text. Thanks to Lars Willemsens.
+- Added <ctype.h> include, at the suggestion of Steve Walters.
+
+Changes in version 2.1.0
+- Yves Berquin brings us the STL switch. The forum on SourceForge, and various emails to
+  me, have long debated all out STL vs. no STL at all. And now you can have it both ways.
+  TinyXml will compile either way.
+
+Changes in version 2.1.1
+- Compilation warnings.
+
+Changes in version 2.1.2
+- Uneeded code is not compiled in the STL case.
+- Changed headers so that STL can be turned on or off in tinyxml.h
+
+Changes in version 2.1.3
+- Fixed non-const reference in API; now uses a pointer.
+- Copy constructor of TiXmlString not checking for assignment to self.
+- Nimrod Cohen found a truly evil bug in the STL implementation that occurs
+  when a string is converted to a c_str and then assigned to self. Search for
+  STL_STRING_BUG for a full description. I'm asserting this is a Microsoft STL
+  bug, since &string and string.c_str() should never be the same. Nevertheless,
+  the code works around it.
+- Urivan Saaib pointed out a compiler conflict, where the C headers define
+  the isblank macro, which was wiping out the TiXmlString::isblank() method.
+  The method was unused and has been removed.
+
+Changes in version 2.1.4
+- Reworked the entity code. Entities were not correctly surving round trip input and output.
+  Will now automatically create entities for high ascii in output.
+
+Changes in version 2.1.5
+- Bug fix by kylotan : infinite loop on some input (tinyxmlparser.cpp rev 1.27)
+- Contributed by Ivica Aracic (bytelord) : 1 new VC++ project to compile versions as static libraries (tinyxml_lib.dsp), 
+  and an example usage in xmltest.dsp
+  (Patch request ID 678605)
+- A suggestion by Ronald Fenner Jr (dormlock) to add #include <istream> and <ostream> for Apple's Project Builder 
+  (Patch request ID 697642)
+- A patch from ohommes that allows to parse correctly dots in element names and attribute names
+  (Patch request 602600 and kylotan 701728)
+- A patch from  hermitgeek ( James ) and wasteland for improper error reporting
+- Reviewed by Lee, with the following changes:
+	- Got sick of fighting the STL/non-STL thing in the windows build. Broke
+	  them out as seperate projects.
+	- I have too long not included the dsw. Added.
+	- TinyXmlText had a protected Print. Odd.
+	- Made LinkEndChild public, with docs and appropriate warnings.
+	- Updated the docs.
+
+2.2.0
+- Fixed an uninitialized pointer in the TiXmlAttributes
+- Fixed STL compilation problem in MinGW (and gcc 3?) - thanks Brian Yoder for finding this one
+- Fixed a syntax error in TiXmlDeclaration - thanks Brian Yoder
+- Fletcher Dunn proposed and submitted new error handling that tracked the row and column. Lee
+  modified it to not have performance impact.
+- General cleanup suggestions from Fletcher Dunn.
+- In error handling, general errors will no longer clear the error state of specific ones.
+- Fix error in documentation : comments starting with "<?--" instead of "<!--" (thanks ion_pulse)
+- Added the TiXmlHandle. An easy, safe way to browse XML DOMs with less code.
+- Added QueryAttribute calls which have better error messaging. (Proposed by Fletcher Dunn)
+- Nodes and attributes can now print themselves to strings. (Yves suggestion)
+- Fixed bug where entities with one character would confuse parser. (Thanks Roman)
+
+2.2.1
+- Additional testing (no more bugs found to be fixed in this release)
+- Significant performance improvement to the cursor code.
+
+2.3.0
+- User Data are now defined in TiXmlBase instead of TiXmlNode
+- Character Entities are now UCS-2
+- Character Entities can be decimal or hexadecimal
+- UTF-8 conversion.
+- Fixed many, many bugs.
+
+2.3.1
+- Fixed bug in handling nulls embedded in the input.
+- Make UTF-8 parser tolerant of bad text encoding.
+- Added encoding detection. 
+- Many fixes and input from John-Philip Leonard Johansson (JP) and Ellers, 
+  including UTF-8 feedback, bug reports, and patches. Thanks!
+- Added version # constants - a suggestion from JP and Ellers.
+- [ 979180 ] Missing ; in entity reference, fix from Rob Laveaux.
+- Copy constructors and assignment have been a long time coming. Thanks to
+  Fokke and JP.
+
+2.3.2
+- Made the IsAlpha and IsAlphaNum much more tolerant of non-UTF-8 encodings. Thanks
+  Volker Boerchers for finding the issue.
+- Ran the program though the magnificent Valgrind - http://valgrind.kde.org - to check
+  for memory errors. Fixed some minor issues.
+
+2.3.3
+- Fixed crash when test program was run from incorrect directory.
+- Fixed bug 1070717 - empty document not returned correctly - thanks Katsuhisa Yuasa.
+- Bug 1079301 resolved - deprecated stdlib calls. Thanks Adrian Boeing.
+- Bug 1035218 fixed - documentation errors. Xunji Luo
+- Other bug fixes have accumulated and been fixed on the way as well; my apologies to
+  authors not credited!
+- Big fix / addition is to correctly return const values. TinyXml could basically
+  remove const in a method like this: TiXmlElement* Foo() const, where the returned element
+  was a pointer to internal data. That is now: const TiXmlElement* Foo() const and
+  TiXmlElement* Foo().
+
+2.3.4
+- Fixed additional const errors, thanks Kent Gibson.
+- Correctly re-enable warnings after tinyxml header. Thanks Cory Nelson.
+- Variety of type cleanup and warning fixes. Thanks Warren Stevens.
+- Cleaned up unneeded constructor calls in TinyString - thanks to Geoff Carlton and
+  the discussion group on sourceforge.
+
+2.4.0
+- Improved string class, thanks Tyge Lovset (whose name gets mangled in English - sorry)
+- Type cast compiler warning, thanks Rob van den Bogaard
+- Added GetText() convenience function. Thanks Ilya Parniuk & Andrew Ellers for input.
+- Many thanks to marlonism for finding an infinite loop in bad xml.
+- A patch to cleanup warnings from Robert Gebis.
+- Added ValueStr() to get the value of a node as a string.
+- TiXmlText can now parse and output as CDATA
+- Additional string improvement from James (z2895)
+- Removed extraneous 'const', thanks David Aldrich
+- First pass at switching to the "safe" stdlib functions. Many people have suggested and
+  pushed on this, but Warren Stevens put together the first proposal.
+- TinyXml now will do EOL normalization before parsing, consistent with the W3C XML spec.
+- Documents loaded with the UTF-8 BOM will now save with the UTF-8 BOM. Good suggestion 
+  from 'instructor_'
+- Ellers submitted his very popular tutorials, which have been added to the distribution.
+
+2.4.1
+- Fixed CDATA output formatting
+- Fixed memory allocators in TinyString to work with overloaded new/delete
+
+2.4.2
+- solosnake pointed out that TIXML_LOG causes problems on an XBOX. The definition in the header
+  was superflous and was moved inside of DEBUG_PARSING
+
+2.4.3
+- Fixed a test bug that caused a crash in 'xmltest'. TinyXML was fine, but it isn't good
+  to ship with a broken test suite.
+- Started converting some functions to not cast between std::string and const char* 
+  quite as often.
+- Added FILE* versions of the document loads - good suggestion from Wade Brainerd
+- Empty documents might not always return the errors they should. [1398915] Thanks to igor v.
+- Added some asserts for multiply adding a node, regardng bug [1391937] suggested by Paco Arjonilla.
+
+2.4.4
+- Bug find thanks to andre-gross found a memory leak that occured when a document failed to load.
+- Bug find (and good analysis) by VirtualJim who found a case where attribute parsing 
+  should be throwing an error and wasn't.
+- Steve Hyatt suggested the QueryValueAttribute method, which is now implemented.
+- DavidA identified a chunk of dead code.
+- Andrew Baxter sent in some compiler warnings that were good clean up points.
+
+2.5
+- Added the Visit() API. Many thanks to both Andrew Ellerton and John-Philip for all their
+  work, code, suggestion, and just general pushing that it should be done.
+- Removed existing streaming code and use TiXmlPrinter instead.
+- [ tinyxml-Bugs-1527079 ] Compile error in tinystr.cpp fixed, thanks to Paul Suggs
+- [ tinyxml-Bugs-1522890 ] SaveFile has no error checks fixed, thanks to Ivan Dobrokotov
+- Ivan Dobrokotov also reported redundant memory allocation in the Attribute() method, which
+  upon investigation was a mess. The attribute should now be fixed for both const char* and 
+  std::string, and the return types match the input parameters.
+- Feature [ 1511105 ] Make TiXmlComment constructor accept a string / char*, implemented.
+  Thanks to Karl Itschen for the feedback.
+- [ 1480108 ] Stream parsing fails when CDATA contains tags was found by Tobias Grimm, who also
+  submitted a test case and patch. A significant bug in CDATA streaming (operator>>) has now
+  been fixed.
+
+2.5.2
+- Lieven, and others, pointed out a missing const-cast that upset the Open Watcom compiler.
+  Should now be fixed.
+- ErrorRow and ErrorCol should have been const, and weren't. Fixed thanks to Dmitry Polutov.
+
+2.5.3
+- zloe_zlo identified a missing string specialization for QueryValueAttribute() [ 1695429 ]. Worked
+  on this bug, but not sure how to fix it in a safe, cross-compiler way.
+- increased warning level to 4 and turned on detect 64 bit portability issues for VC2005.
+  May address [ 1677737 ] VS2005: /Wp64 warnings
+- grosheck identified several problems with the Document copy. Many thanks for [ 1660367 ]
+- Nice catch, and suggested fix, be Gilad Novik on the Printer dropping entities.
+  "[ 1600650 ] Bug when printing xml text" is now fixed.
+- A subtle fix from Nicos Gollan in the tinystring initializer: 
+  [ 1581449 ] Fix initialiser of TiXmlString::nullrep_
+- Great catch, although there isn't a submitter for the bug. [ 1475201 ] TinyXML parses entities in comments. 
+  Comments should not, in fact, parse entities. Fixed the code path and added tests.
+- We were not catching all the returns from ftell. Thanks to Bernard for catching that.
+  

Added: dependencies/tinyxml/docs/annotated.html
===================================================================
--- dependencies/tinyxml/docs/annotated.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/annotated.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,39 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Class List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li id="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TinyXml Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td class="indexvalue">An attribute is a name-value pair </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td class="indexvalue"><a class="el" href="classTiXmlBase.html">TiXmlBase</a> is a base class for every class in TinyXml </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td class="indexvalue">An XML comment </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td class="indexvalue">In correct XML the declaration is the first entry in the file </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td class="indexvalue">Always the top level node </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td class="indexvalue">The element is a container class </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td class="indexvalue">A <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td class="indexvalue">The parent class for everything in the Document Object Model </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td class="indexvalue">Print to memory functionality </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td class="indexvalue">XML text </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td class="indexvalue">Any tag that tinyXml doesn't recognize is saved as an unknown </td></tr>
+  <tr><td class="indexkey"><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td class="indexvalue">If you call the Accept() method, it requires being passed a <a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> class to handle callbacks </td></tr>
+</table>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlAttribute-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlAttribute-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlAttribute-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,54 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlAttribute Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#2880ddef53fc7522c99535273954d230">DoubleValue</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#a1a20ad59dc7e89a0ab265396360d50f">IntValue</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#298a57287d305904ba6bd96ae6f78d3d">Name</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#1c78e92e223a40843f644ba48ef69f67">Next</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#c87b2a8489906a5d7aa2875f20be3513">QueryDoubleValue</a>(double *_value) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#d6c93088ee21af41a107931223339344">QueryIntValue</a>(int *_value) const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#0316da31373496c4368ad549bf711394">SetDoubleValue</a>(double _value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#7e065df640116a62ea4f4b7da5449cc8">SetIntValue</a>(int _value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#b7fa3d21ff8d7c5764cf9af15b667a99">SetName</a>(const char *_name)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#b296ff0c9a8c701055cd257a8a976e57">SetName</a>(const std::string &amp;_name)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#2dae44178f668b3cb48101be4f2236a0">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#b43f67a0cc3ec1d80e62606500f0925f">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>()</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#052213522caac3979960e0714063861d">TiXmlAttribute</a>(const std::string &amp;_name, const std::string &amp;_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a>(const char *_name, const char *_value)</td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#0f874490eac8ca00ee0070765d0e97e3">Value</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlAttribute.html#87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a>() const </td><td><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlAttribute.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlAttribute.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlAttribute.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,181 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlAttribute Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlAttribute Class Reference</h1><!-- doxytag: class="TiXmlAttribute" --><!-- doxytag: inherits="TiXmlBase" -->An attribute is a name-value pair.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlAttribute:
+<p><center><img src="classTiXmlAttribute.png" usemap="#TiXmlAttribute_map" border="0" alt=""></center>
+<map name="TiXmlAttribute_map">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,90,24">
+</map>
+<a href="classTiXmlAttribute-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9cfa3c8179873fd485d83003b114f8e1"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="9cfa3c8179873fd485d83003b114f8e1" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty attribute. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="052213522caac3979960e0714063861d"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="052213522caac3979960e0714063861d" args="(const std::string &amp;_name, const std::string &amp;_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#052213522caac3979960e0714063861d">TiXmlAttribute</a> (const std::string &amp;_name, const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::string constructor. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="759d0b76fb8fcf765ecab243bc14f05e"></a><!-- doxytag: member="TiXmlAttribute::TiXmlAttribute" ref="759d0b76fb8fcf765ecab243bc14f05e" args="(const char *_name, const char *_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a> (const char *_name, const char *_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an attribute with a name and value. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="298a57287d305904ba6bd96ae6f78d3d"></a><!-- doxytag: member="TiXmlAttribute::Name" ref="298a57287d305904ba6bd96ae6f78d3d" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#298a57287d305904ba6bd96ae6f78d3d">Name</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of this attribute. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f874490eac8ca00ee0070765d0e97e3"></a><!-- doxytag: member="TiXmlAttribute::Value" ref="0f874490eac8ca00ee0070765d0e97e3" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#0f874490eac8ca00ee0070765d0e97e3">Value</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87705c3ccf9ee9417beb4f7cbacd4d33"></a><!-- doxytag: member="TiXmlAttribute::ValueStr" ref="87705c3ccf9ee9417beb4f7cbacd4d33" args="() const " -->
+const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1a20ad59dc7e89a0ab265396360d50f"></a><!-- doxytag: member="TiXmlAttribute::IntValue" ref="a1a20ad59dc7e89a0ab265396360d50f" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#a1a20ad59dc7e89a0ab265396360d50f">IntValue</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute, converted to an integer. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2880ddef53fc7522c99535273954d230"></a><!-- doxytag: member="TiXmlAttribute::DoubleValue" ref="2880ddef53fc7522c99535273954d230" args="() const " -->
+double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#2880ddef53fc7522c99535273954d230">DoubleValue</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of this attribute, converted to a double. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#d6c93088ee21af41a107931223339344">QueryIntValue</a> (int *_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryIntValue examines the value string.  <a href="#d6c93088ee21af41a107931223339344"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c87b2a8489906a5d7aa2875f20be3513"></a><!-- doxytag: member="TiXmlAttribute::QueryDoubleValue" ref="c87b2a8489906a5d7aa2875f20be3513" args="(double *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#c87b2a8489906a5d7aa2875f20be3513">QueryDoubleValue</a> (double *_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryDoubleValue examines the value string. See <a class="el" href="classTiXmlAttribute.html#d6c93088ee21af41a107931223339344">QueryIntValue()</a>. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7fa3d21ff8d7c5764cf9af15b667a99"></a><!-- doxytag: member="TiXmlAttribute::SetName" ref="b7fa3d21ff8d7c5764cf9af15b667a99" args="(const char *_name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#b7fa3d21ff8d7c5764cf9af15b667a99">SetName</a> (const char *_name)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of this attribute. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2dae44178f668b3cb48101be4f2236a0"></a><!-- doxytag: member="TiXmlAttribute::SetValue" ref="2dae44178f668b3cb48101be4f2236a0" args="(const char *_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#2dae44178f668b3cb48101be4f2236a0">SetValue</a> (const char *_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e065df640116a62ea4f4b7da5449cc8"></a><!-- doxytag: member="TiXmlAttribute::SetIntValue" ref="7e065df640116a62ea4f4b7da5449cc8" args="(int _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#7e065df640116a62ea4f4b7da5449cc8">SetIntValue</a> (int _value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value from an integer. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0316da31373496c4368ad549bf711394"></a><!-- doxytag: member="TiXmlAttribute::SetDoubleValue" ref="0316da31373496c4368ad549bf711394" args="(double _value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#0316da31373496c4368ad549bf711394">SetDoubleValue</a> (double _value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value from a double. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b296ff0c9a8c701055cd257a8a976e57"></a><!-- doxytag: member="TiXmlAttribute::SetName" ref="b296ff0c9a8c701055cd257a8a976e57" args="(const std::string &amp;_name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#b296ff0c9a8c701055cd257a8a976e57">SetName</a> (const std::string &amp;_name)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b43f67a0cc3ec1d80e62606500f0925f"></a><!-- doxytag: member="TiXmlAttribute::SetValue" ref="b43f67a0cc3ec1d80e62606500f0925f" args="(const std::string &amp;_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#b43f67a0cc3ec1d80e62606500f0925f">SetValue</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c78e92e223a40843f644ba48ef69f67"></a><!-- doxytag: member="TiXmlAttribute::Next" ref="1c78e92e223a40843f644ba48ef69f67" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#1c78e92e223a40843f644ba48ef69f67">Next</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next sibling attribute in the DOM. Returns null at end. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ebbfe333fe76cd834bd6cbcca3130cf"></a><!-- doxytag: member="TiXmlAttribute::Previous" ref="6ebbfe333fe76cd834bd6cbcca3130cf" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the previous sibling attribute in the DOM. Returns null at beginning. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">Print</a> (FILE *cfile, int depth) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#cc04956c1d5c4c31fe74f7a7528d109a"></a><br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+An attribute is a name-value pair. 
+<p>
+Elements have an arbitrary number of attributes, each with a unique name.<p>
+<dl compact><dt><b>Note:</b></dt><dd>The attributes are not TiXmlNodes, since they are not part of the tinyXML document object model. There are other suggested ways to look at this problem. </dd></dl>
+
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="cc04956c1d5c4c31fe74f7a7528d109a"></a><!-- doxytag: member="TiXmlAttribute::Print" ref="cc04956c1d5c4c31fe74f7a7528d109a" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlAttribute::Print           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [inline, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. 
+<p>
+) Either or both cfile and str can be null.<p>
+This is a formatted print, and will insert tabs and newlines.<p>
+(For an unformatted stream, use the &lt;&lt; operator.) 
+<p>
+Implements <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.
+</div>
+</div><p>
+<a class="anchor" name="d6c93088ee21af41a107931223339344"></a><!-- doxytag: member="TiXmlAttribute::QueryIntValue" ref="d6c93088ee21af41a107931223339344" args="(int *_value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlAttribute::QueryIntValue           </td>
+          <td>(</td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>_value</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+QueryIntValue examines the value string. 
+<p>
+It is an alternative to the <a class="el" href="classTiXmlAttribute.html#a1a20ad59dc7e89a0ab265396360d50f">IntValue()</a> method with richer error checking. If the value is an integer, it is stored in 'value' and the call returns TIXML_SUCCESS. If it is not an integer, it returns TIXML_WRONG_TYPE.<p>
+A specialized but useful call. Note that for success it returns 0, which is the opposite of almost all other TinyXml calls. 
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlAttribute.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlAttribute.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlBase-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlBase-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlBase-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,36 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlBase Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlBase.html">TiXmlBase</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">Print</a>(FILE *cfile, int depth) const =0</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlBase.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlBase.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlBase.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,230 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlBase Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlBase Class Reference</h1><!-- doxytag: class="TiXmlBase" --><a class="el" href="classTiXmlBase.html">TiXmlBase</a> is a base class for every class in TinyXml.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlBase:
+<p><center><img src="classTiXmlBase.png" usemap="#TiXmlBase_map" border="0" alt=""></center>
+<map name="TiXmlBase_map">
+<area href="classTiXmlAttribute.html" alt="TiXmlAttribute" shape="rect" coords="0,56,108,80">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="295,56,403,80">
+<area href="classTiXmlComment.html" alt="TiXmlComment" shape="rect" coords="0,112,108,136">
+<area href="classTiXmlDeclaration.html" alt="TiXmlDeclaration" shape="rect" coords="118,112,226,136">
+<area href="classTiXmlDocument.html" alt="TiXmlDocument" shape="rect" coords="236,112,344,136">
+<area href="classTiXmlElement.html" alt="TiXmlElement" shape="rect" coords="354,112,462,136">
+<area href="classTiXmlText.html" alt="TiXmlText" shape="rect" coords="472,112,580,136">
+<area href="classTiXmlUnknown.html" alt="TiXmlUnknown" shape="rect" coords="590,112,698,136">
+</map>
+<a href="classTiXmlBase-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">Print</a> (FILE *cfile, int depth) const =0</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#0de56b3f2ef14c65091a3b916437b512"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the position, in the original source file, of this node or attribute.  <a href="#024bceb070188df92c2a8d8852dd0853"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b54bfb9b70fe6dd276e7b279cab7f003"></a><!-- doxytag: member="TiXmlBase::Column" ref="b54bfb9b70fe6dd276e7b279cab7f003" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See <a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row()</a>. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6b3e0f790930d4970ec30764e937b5d"></a><!-- doxytag: member="TiXmlBase::SetUserData" ref="c6b3e0f790930d4970ec30764e937b5d" args="(void *user)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a> (void *user)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a pointer to arbitrary user data. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6559a530ca6763fc301a14d77ed28c17"></a><!-- doxytag: member="TiXmlBase::GetUserData" ref="6559a530ca6763fc301a14d77ed28c17" args="()" -->
+void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to arbitrary user data. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0120210e4680ef2088601753ce0ede4"></a><!-- doxytag: member="TiXmlBase::GetUserData" ref="d0120210e4680ef2088601753ce0ede4" args="() const " -->
+const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to arbitrary user data. <br></td></tr>
+<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a> (bool condense)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The world does not agree on whether white space should be kept or not.  <a href="#0f799ec645bfb8d8a969e83478f379c1"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4b1472531c647a25b1840a87ae42438"></a><!-- doxytag: member="TiXmlBase::IsWhiteSpaceCondensed" ref="d4b1472531c647a25b1840a87ae42438" args="()" -->
+static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current white space setting. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a> (const TIXML_STRING &amp;str, TIXML_STRING *out)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands entities in a string.  <a href="#6bd8c315c1acb09e34107b8736505948"></a><br></td></tr>
+<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b242c01590191f644569fa89a080d97c"></a><!-- doxytag: member="TiXmlBase::userData" ref="b242c01590191f644569fa89a080d97c" args="" -->
+void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Field containing a generic user pointer. <br></td></tr>
+<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="218872a0d985ae30e78c55adc4bdb196"></a><!-- doxytag: member="TiXmlBase::TiXmlNode" ref="218872a0d985ae30e78c55adc4bdb196" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#218872a0d985ae30e78c55adc4bdb196">TiXmlNode</a></td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlBase::TiXmlElement" ref="b6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#b6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="173617f6dfe902cf484ce5552b950475"></a><!-- doxytag: member="TiXmlBase::TiXmlDocument" ref="173617f6dfe902cf484ce5552b950475" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlBase.html#173617f6dfe902cf484ce5552b950475">TiXmlDocument</a></td></tr>
+
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+<a class="el" href="classTiXmlBase.html">TiXmlBase</a> is a base class for every class in TinyXml. 
+<p>
+It does little except to establish that TinyXml classes can be printed and provide some utility functions.<p>
+In XML, the document and elements can contain other elements and other types of nodes.<p>
+<div class="fragment"><pre class="fragment">	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	</pre></div> 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="6bd8c315c1acb09e34107b8736505948"></a><!-- doxytag: member="TiXmlBase::EncodeString" ref="6bd8c315c1acb09e34107b8736505948" args="(const TIXML_STRING &amp;str, TIXML_STRING *out)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">static void TiXmlBase::EncodeString           </td>
+          <td>(</td>
+          <td class="paramtype">const TIXML_STRING &amp;&nbsp;</td>
+          <td class="paramname"> <em>str</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TIXML_STRING *&nbsp;</td>
+          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"><code> [static]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Expands entities in a string. 
+<p>
+Note this should not contian the tag's '&lt;', '&gt;', etc, or they will be transformed into entities! 
+</div>
+</div><p>
+<a class="anchor" name="0de56b3f2ef14c65091a3b916437b512"></a><!-- doxytag: member="TiXmlBase::Print" ref="0de56b3f2ef14c65091a3b916437b512" args="(FILE *cfile, int depth) const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlBase::Print           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. 
+<p>
+) Either or both cfile and str can be null.<p>
+This is a formatted print, and will insert tabs and newlines.<p>
+(For an unformatted stream, use the &lt;&lt; operator.) 
+<p>
+Implemented in <a class="el" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>, <a class="el" href="classTiXmlElement.html#fbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#bf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>.
+</div>
+</div><p>
+<a class="anchor" name="024bceb070188df92c2a8d8852dd0853"></a><!-- doxytag: member="TiXmlBase::Row" ref="024bceb070188df92c2a8d8852dd0853" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlBase::Row           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return the position, in the original source file, of this node or attribute. 
+<p>
+The row and column are 1-based. (That is the first row and first column is 1,1). If the returns values are 0 or less, then the parser does not have a row and column value.<p>
+Generally, the row and column value will be set when the TiXmlDocument::Load(), <a class="el" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">TiXmlDocument::LoadFile()</a>, or any TiXmlNode::Parse() is called. It will NOT be set when the DOM was created from operator&gt;&gt;.<p>
+The values reflect the initial load. Once the DOM is modified programmatically (by adding or changing nodes and attributes) the new values will NOT update to reflect changes in the document.<p>
+There is a minor performance cost to computing the row and column. Computation can be disabled if <a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument::SetTabSize()</a> is called with 0 as the value.<p>
+<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument::SetTabSize()</a> </dd></dl>
+
+</div>
+</div><p>
+<a class="anchor" name="0f799ec645bfb8d8a969e83478f379c1"></a><!-- doxytag: member="TiXmlBase::SetCondenseWhiteSpace" ref="0f799ec645bfb8d8a969e83478f379c1" args="(bool condense)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">static void TiXmlBase::SetCondenseWhiteSpace           </td>
+          <td>(</td>
+          <td class="paramtype">bool&nbsp;</td>
+          <td class="paramname"> <em>condense</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline, static]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+The world does not agree on whether white space should be kept or not. 
+<p>
+In order to make everyone happy, these global, static functions are provided to set whether or not TinyXml will condense all white space into a single space or not. The default is to condense. Note changing this value is not thread safe. 
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlBase.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlBase.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlComment-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlComment-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlComment-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,100 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlComment Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlComment.html">TiXmlComment</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#f3ac1b99fbbe9ea4fb6e14146156e43e">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#0d6662bdc52488b9e12b3c7a0453d028">Clone</a>() const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#6b316527aaa8da0370cd68c22a5a0f5f">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#aa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>()</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a>(const char *_value)</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a>() const </td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlComment.html#cc7c7e07e13c23f17797d642981511df">ToComment</a>()</td><td><a class="el" href="classTiXmlComment.html">TiXmlComment</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlComment.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlComment.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlComment.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,108 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlComment Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlComment Class Reference</h1><!-- doxytag: class="TiXmlComment" --><!-- doxytag: inherits="TiXmlNode" -->An XML comment.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlComment:
+<p><center><img src="classTiXmlComment.png" usemap="#TiXmlComment_map" border="0" alt=""></center>
+<map name="TiXmlComment_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,94,80">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,94,24">
+</map>
+<a href="classTiXmlComment-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa3252031d3e8bd3a2bf51a1c61201b7"></a><!-- doxytag: member="TiXmlComment::TiXmlComment" ref="aa3252031d3e8bd3a2bf51a1c61201b7" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#aa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an empty comment. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="37e7802ef17bc03ebe5ae79bf0713d47"></a><!-- doxytag: member="TiXmlComment::TiXmlComment" ref="37e7802ef17bc03ebe5ae79bf0713d47" args="(const char *_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a> (const char *_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a comment from text. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d6662bdc52488b9e12b3c7a0453d028"></a><!-- doxytag: member="TiXmlComment::Clone" ref="0d6662bdc52488b9e12b3c7a0453d028" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#0d6662bdc52488b9e12b3c7a0453d028">Clone</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of this Comment. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#6b316527aaa8da0370cd68c22a5a0f5f">Print</a> (FILE *cfile, int depth) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#6b316527aaa8da0370cd68c22a5a0f5f"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00fb4215c20a2399ea05ac9b9e7e68a0"></a><!-- doxytag: member="TiXmlComment::ToComment" ref="00fb4215c20a2399ea05ac9b9e7e68a0" args="() const " -->
+virtual const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc7c7e07e13c23f17797d642981511df"></a><!-- doxytag: member="TiXmlComment::ToComment" ref="cc7c7e07e13c23f17797d642981511df" args="()" -->
+virtual <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#cc7c7e07e13c23f17797d642981511df">ToComment</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3ac1b99fbbe9ea4fb6e14146156e43e"></a><!-- doxytag: member="TiXmlComment::Accept" ref="f3ac1b99fbbe9ea4fb6e14146156e43e" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlComment.html#f3ac1b99fbbe9ea4fb6e14146156e43e">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+An XML comment. 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="6b316527aaa8da0370cd68c22a5a0f5f"></a><!-- doxytag: member="TiXmlComment::Print" ref="6b316527aaa8da0370cd68c22a5a0f5f" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlComment::Print           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. 
+<p>
+) Either or both cfile and str can be null.<p>
+This is a formatted print, and will insert tabs and newlines.<p>
+(For an unformatted stream, use the &lt;&lt; operator.) 
+<p>
+Implements <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlComment.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlComment.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlDeclaration-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlDeclaration-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlDeclaration-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,104 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlDeclaration Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#22315a535983b86535cdba3458669e3e">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#7cf459186040141cda7a180a6585ce2e">Clone</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#5d974231f9e9a2f0542f15f3a46cdb76">Encoding</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#bf6303db4bd05b5be554036817ff1cb4">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#9ff06afc033d7ef730ec7c6825b97ad9">Standalone</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#a0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a>()</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#cd5556007c3c72209465081de39d9836">TiXmlDeclaration</a>(const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a>(const char *_version, const char *_encoding, const char *_standalone)</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#6bd3d1daddcaeb9543c24bfd090969ce">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDeclaration.html#02ee557b1a4545c3219ed377c103ec76">Version</a>() const </td><td><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlDeclaration.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlDeclaration.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlDeclaration.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,129 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlDeclaration Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlDeclaration Class Reference</h1><!-- doxytag: class="TiXmlDeclaration" --><!-- doxytag: inherits="TiXmlNode" -->In correct XML the declaration is the first entry in the file.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlDeclaration:
+<p><center><img src="classTiXmlDeclaration.png" usemap="#TiXmlDeclaration_map" border="0" alt=""></center>
+<map name="TiXmlDeclaration_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,108,80">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,108,24">
+</map>
+<a href="classTiXmlDeclaration-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0484d059bea0ea1acb47c9094382d79"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="a0484d059bea0ea1acb47c9094382d79" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#a0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty declaration. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd5556007c3c72209465081de39d9836"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="cd5556007c3c72209465081de39d9836" args="(const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#cd5556007c3c72209465081de39d9836">TiXmlDeclaration</a> (const std::string &amp;_version, const std::string &amp;_encoding, const std::string &amp;_standalone)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b618d1c30c25e4b7a71f31a595ee298"></a><!-- doxytag: member="TiXmlDeclaration::TiXmlDeclaration" ref="3b618d1c30c25e4b7a71f31a595ee298" args="(const char *_version, const char *_encoding, const char *_standalone)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a> (const char *_version, const char *_encoding, const char *_standalone)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02ee557b1a4545c3219ed377c103ec76"></a><!-- doxytag: member="TiXmlDeclaration::Version" ref="02ee557b1a4545c3219ed377c103ec76" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#02ee557b1a4545c3219ed377c103ec76">Version</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version. Will return an empty string if none was found. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d974231f9e9a2f0542f15f3a46cdb76"></a><!-- doxytag: member="TiXmlDeclaration::Encoding" ref="5d974231f9e9a2f0542f15f3a46cdb76" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#5d974231f9e9a2f0542f15f3a46cdb76">Encoding</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encoding. Will return an empty string if none was found. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ff06afc033d7ef730ec7c6825b97ad9"></a><!-- doxytag: member="TiXmlDeclaration::Standalone" ref="9ff06afc033d7ef730ec7c6825b97ad9" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#9ff06afc033d7ef730ec7c6825b97ad9">Standalone</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a standalone document? <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7cf459186040141cda7a180a6585ce2e"></a><!-- doxytag: member="TiXmlDeclaration::Clone" ref="7cf459186040141cda7a180a6585ce2e" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#7cf459186040141cda7a180a6585ce2e">Clone</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this Declaration and returns it. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#bf6303db4bd05b5be554036817ff1cb4">Print</a> (FILE *cfile, int depth) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#bf6303db4bd05b5be554036817ff1cb4"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e085d3fefd1dbf5ccdbff729931a967"></a><!-- doxytag: member="TiXmlDeclaration::ToDeclaration" ref="1e085d3fefd1dbf5ccdbff729931a967" args="() const " -->
+virtual const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6bd3d1daddcaeb9543c24bfd090969ce"></a><!-- doxytag: member="TiXmlDeclaration::ToDeclaration" ref="6bd3d1daddcaeb9543c24bfd090969ce" args="()" -->
+virtual <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#6bd3d1daddcaeb9543c24bfd090969ce">ToDeclaration</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="22315a535983b86535cdba3458669e3e"></a><!-- doxytag: member="TiXmlDeclaration::Accept" ref="22315a535983b86535cdba3458669e3e" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDeclaration.html#22315a535983b86535cdba3458669e3e">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+In correct XML the declaration is the first entry in the file. 
+<p>
+<div class="fragment"><pre class="fragment">		&lt;?xml version="1.0" standalone="yes"?&gt;
+	</pre></div><p>
+TinyXml will happily read or write files without a declaration, however. There are 3 possible attributes to the declaration: version, encoding, and standalone.<p>
+Note: In this version of the code, the attributes are handled as special cases, not generic attributes, simply because there can only be at most 3 and they are always the same. 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="bf6303db4bd05b5be554036817ff1cb4"></a><!-- doxytag: member="TiXmlDeclaration::Print" ref="bf6303db4bd05b5be554036817ff1cb4" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlDeclaration::Print           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [inline, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. 
+<p>
+) Either or both cfile and str can be null.<p>
+This is a formatted print, and will insert tabs and newlines.<p>
+(For an unformatted stream, use the &lt;&lt; operator.) 
+<p>
+Implements <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlDeclaration.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlDeclaration.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlDocument-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlDocument-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlDocument-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,119 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlDocument Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a545aae325d9752ad64120bc4ecf939a">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#c66b8c28db86363315712a3574e87c35">ClearError</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#4968661cab4a1f44a23329c6f8db1907">Clone</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [protected, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#6dfc01a6e5d58e56acd537dfd3bdeb29">Error</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">ErrorCol</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#f96fc2f3f9ec6422782bfe916c9e778f">ErrorId</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">ErrorRow</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>(TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#879cdf5e981b8b2d2ef82f2546dd28fb">LoadFile</a>(const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#41f6fe7200864d1dca663d230caf8db6">LoadFile</a>(FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#18ae6ed34fed7991ebc220862dfac884">LoadFile</a>(const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#17ebabe36926ef398e78dec0d0ad0378">Parse</a>(const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#f08389ec70ee9b2de7f800e206a18510">Print</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#8701fda1fa31b25abbc9c0df42da10e8">Print</a>(FILE *cfile, int depth=0) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#d09d17927f908f40efb406af2fb873be">RootElement</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#e869f5ebf7fc54c4a1d737fb4689fd44">SaveFile</a>(const char *filename) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#cf1672b4538c6d1d441f9f108aea2bf4">SaveFile</a>(FILE *) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#3d4fae0463f3f03679ba0b7cf6f2df52">SaveFile</a>(const std::string &amp;filename) const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a>(int _tabsize)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#e4508b452d0c3061db085f3db27b8396">TiXmlDocument</a>(const char *documentName)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a>(const std::string &amp;documentName)</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a>() const </td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlDocument.html#1025d942a1f328fd742d545e37efdd42">ToDocument</a>()</td><td><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlDocument.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlDocument.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlDocument.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,430 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlDocument Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlDocument Class Reference</h1><!-- doxytag: class="TiXmlDocument" --><!-- doxytag: inherits="TiXmlNode" -->Always the top level node.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlDocument:
+<p><center><img src="classTiXmlDocument.png" usemap="#TiXmlDocument_map" border="0" alt=""></center>
+<map name="TiXmlDocument_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,99,80">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,99,24">
+</map>
+<a href="classTiXmlDocument-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9f5e84335708fde98400230f9f12659c"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="9f5e84335708fde98400230f9f12659c" args="()" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#9f5e84335708fde98400230f9f12659c">TiXmlDocument</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty document, that has no name. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4508b452d0c3061db085f3db27b8396"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="e4508b452d0c3061db085f3db27b8396" args="(const char *documentName)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#e4508b452d0c3061db085f3db27b8396">TiXmlDocument</a> (const char *documentName)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a document with a name. The name of the document is also the filename of the xml. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c6e58fb99bfa76cc613f16840022225"></a><!-- doxytag: member="TiXmlDocument::TiXmlDocument" ref="2c6e58fb99bfa76cc613f16840022225" args="(const std::string &amp;documentName)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a> (const std::string &amp;documentName)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">LoadFile</a> (TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the current document value.  <a href="#4c852a889c02cf251117fd1d9fe1845f"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21c0aeb0d0a720169ad4ac89523ebe93"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="21c0aeb0d0a720169ad4ac89523ebe93" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the current document value. Returns true if successful. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="879cdf5e981b8b2d2ef82f2546dd28fb"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="879cdf5e981b8b2d2ef82f2546dd28fb" args="(const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#879cdf5e981b8b2d2ef82f2546dd28fb">LoadFile</a> (const char *filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the given filename. Returns true if successful. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e869f5ebf7fc54c4a1d737fb4689fd44"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="e869f5ebf7fc54c4a1d737fb4689fd44" args="(const char *filename) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#e869f5ebf7fc54c4a1d737fb4689fd44">SaveFile</a> (const char *filename) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the given filename. Returns true if successful. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#41f6fe7200864d1dca663d230caf8db6">LoadFile</a> (FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a file using the given FILE*.  <a href="#41f6fe7200864d1dca663d230caf8db6"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf1672b4538c6d1d441f9f108aea2bf4"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="cf1672b4538c6d1d441f9f108aea2bf4" args="(FILE *) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#cf1672b4538c6d1d441f9f108aea2bf4">SaveFile</a> (FILE *) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a file using the given FILE*. Returns true if successful. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#18ae6ed34fed7991ebc220862dfac884">LoadFile</a> (const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d4fae0463f3f03679ba0b7cf6f2df52"></a><!-- doxytag: member="TiXmlDocument::SaveFile" ref="3d4fae0463f3f03679ba0b7cf6f2df52" args="(const std::string &amp;filename) const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#3d4fae0463f3f03679ba0b7cf6f2df52">SaveFile</a> (const std::string &amp;filename) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; STL std::string version. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#17ebabe36926ef398e78dec0d0ad0378">Parse</a> (const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the given null terminated block of xml data.  <a href="#17ebabe36926ef398e78dec0d0ad0378"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#d09d17927f908f40efb406af2fb873be">RootElement</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the root element -- the only top level element -- of the document.  <a href="#d09d17927f908f40efb406af2fb873be"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#6dfc01a6e5d58e56acd537dfd3bdeb29">Error</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If an error occurs, Error will be set to true.  <a href="#6dfc01a6e5d58e56acd537dfd3bdeb29"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d0f689f6e09ea494ea547be8d79c25e"></a><!-- doxytag: member="TiXmlDocument::ErrorDesc" ref="9d0f689f6e09ea494ea547be8d79c25e" args="() const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains a textual (english) description of the error if one occurs. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#f96fc2f3f9ec6422782bfe916c9e778f">ErrorId</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generally, you probably want the error string ( <a class="el" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc()</a> ).  <a href="#f96fc2f3f9ec6422782bfe916c9e778f"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">ErrorRow</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the location (if known) of the error.  <a href="#f30efc75e804aa2e92fb8be3a8cb676e"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a90bc630ee5203c6109ca5fad3323649"></a><!-- doxytag: member="TiXmlDocument::ErrorCol" ref="a90bc630ee5203c6109ca5fad3323649" args="() const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">ErrorCol</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The column where the error occured. See <a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">ErrorRow()</a>. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a> (int _tabsize)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">SetTabSize()</a> allows the error reporting functions (<a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">ErrorCol()</a>) to report the correct values for row and column.  <a href="#51dac56316f89b35bdb7d0d433ba988e"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#c66b8c28db86363315712a3574e87c35">ClearError</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you have handled the error, it can be reset with this call.  <a href="#c66b8c28db86363315712a3574e87c35"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f08389ec70ee9b2de7f800e206a18510"></a><!-- doxytag: member="TiXmlDocument::Print" ref="f08389ec70ee9b2de7f800e206a18510" args="() const " -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#f08389ec70ee9b2de7f800e206a18510">Print</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the document to standard out using formatted printing ("pretty print"). <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8701fda1fa31b25abbc9c0df42da10e8"></a><!-- doxytag: member="TiXmlDocument::Print" ref="8701fda1fa31b25abbc9c0df42da10e8" args="(FILE *cfile, int depth=0) const " -->
+virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#8701fda1fa31b25abbc9c0df42da10e8">Print</a> (FILE *cfile, int depth=0) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print this Document to a FILE stream. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1dc977bde3e4fe85a8eb9d88a35ef5a4"></a><!-- doxytag: member="TiXmlDocument::ToDocument" ref="1dc977bde3e4fe85a8eb9d88a35ef5a4" args="() const " -->
+virtual const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1025d942a1f328fd742d545e37efdd42"></a><!-- doxytag: member="TiXmlDocument::ToDocument" ref="1025d942a1f328fd742d545e37efdd42" args="()" -->
+virtual <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#1025d942a1f328fd742d545e37efdd42">ToDocument</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a545aae325d9752ad64120bc4ecf939a"></a><!-- doxytag: member="TiXmlDocument::Accept" ref="a545aae325d9752ad64120bc4ecf939a" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#a545aae325d9752ad64120bc4ecf939a">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br></td></tr>
+<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlDocument.html#4968661cab4a1f44a23329c6f8db1907">Clone</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exact duplicate of this node and return it.  <a href="#4968661cab4a1f44a23329c6f8db1907"></a><br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+Always the top level node. 
+<p>
+A document binds together all the XML pieces. It can be saved, loaded, and printed to the screen. The 'value' of a document node is the xml file name. 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="c66b8c28db86363315712a3574e87c35"></a><!-- doxytag: member="TiXmlDocument::ClearError" ref="c66b8c28db86363315712a3574e87c35" args="()" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::ClearError           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+If you have handled the error, it can be reset with this call. 
+<p>
+The error state is automatically cleared if you Parse a new XML block. 
+</div>
+</div><p>
+<a class="anchor" name="4968661cab4a1f44a23329c6f8db1907"></a><!-- doxytag: member="TiXmlDocument::Clone" ref="4968661cab4a1f44a23329c6f8db1907" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlDocument::Clone           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [protected, virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Create an exact duplicate of this node and return it. 
+<p>
+The memory must be deleted by the caller. 
+<p>
+Implements <a class="el" href="classTiXmlNode.html#4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a>.
+</div>
+</div><p>
+<a class="anchor" name="6dfc01a6e5d58e56acd537dfd3bdeb29"></a><!-- doxytag: member="TiXmlDocument::Error" ref="6dfc01a6e5d58e56acd537dfd3bdeb29" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::Error           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+If an error occurs, Error will be set to true. 
+<p>
+Also,<ul>
+<li>The <a class="el" href="classTiXmlDocument.html#f96fc2f3f9ec6422782bfe916c9e778f">ErrorId()</a> will contain the integer identifier of the error (not generally useful)</li><li>The <a class="el" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc()</a> method will return the name of the error. (very useful)</li><li>The <a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">ErrorCol()</a> will return the location of the error (if known) </li></ul>
+
+</div>
+</div><p>
+<a class="anchor" name="f96fc2f3f9ec6422782bfe916c9e778f"></a><!-- doxytag: member="TiXmlDocument::ErrorId" ref="f96fc2f3f9ec6422782bfe916c9e778f" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlDocument::ErrorId           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Generally, you probably want the error string ( <a class="el" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc()</a> ). 
+<p>
+But if you prefer the ErrorId, this function will fetch it. 
+</div>
+</div><p>
+<a class="anchor" name="f30efc75e804aa2e92fb8be3a8cb676e"></a><!-- doxytag: member="TiXmlDocument::ErrorRow" ref="f30efc75e804aa2e92fb8be3a8cb676e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlDocument::ErrorRow           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Returns the location (if known) of the error. 
+<p>
+The first column is column 1, and the first row is row 1. A value of 0 means the row and column wasn't applicable (memory errors, for example, have no row/column) or the parser lost the error. (An error in the error reporting, in that case.)<p>
+<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a>, <a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>, <a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a> </dd></dl>
+
+</div>
+</div><p>
+<a class="anchor" name="18ae6ed34fed7991ebc220862dfac884"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="18ae6ed34fed7991ebc220862dfac884" args="(const std::string &amp;filename, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile           </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>filename</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+<dl compact><dt><b>Parameters: </b></dt><dd>
+<table border="0" cellspacing="2" cellpadding="0">
+<tr><td valign="top"><em>encoding</em>&nbsp;</td><td>
+STL std::string version. </td></tr>
+</table>
+</dl>
+</div>
+</div><p>
+<a class="anchor" name="41f6fe7200864d1dca663d230caf8db6"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="41f6fe7200864d1dca663d230caf8db6" args="(FILE *, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname">, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Load a file using the given FILE*. 
+<p>
+Returns true if successful. Note that this method doesn't stream - the entire object pointed at by the FILE* will be interpreted as an XML file. TinyXML doesn't stream in XML from the current file location. Streaming may be added in the future. 
+</div>
+</div><p>
+<a class="anchor" name="4c852a889c02cf251117fd1d9fe1845f"></a><!-- doxytag: member="TiXmlDocument::LoadFile" ref="4c852a889c02cf251117fd1d9fe1845f" args="(TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">bool TiXmlDocument::LoadFile           </td>
+          <td>(</td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Load a file using the current document value. 
+<p>
+Returns true if successful. Will delete any existing document data before loading. 
+</div>
+</div><p>
+<a class="anchor" name="17ebabe36926ef398e78dec0d0ad0378"></a><!-- doxytag: member="TiXmlDocument::Parse" ref="17ebabe36926ef398e78dec0d0ad0378" args="(const char *p, TiXmlParsingData *data=0, TiXmlEncoding encoding=TIXML_DEFAULT_ENCODING)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual const char* TiXmlDocument::Parse           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>p</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlParsingData *&nbsp;</td>
+          <td class="paramname"> <em>data</em> = <code>0</code>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">TiXmlEncoding&nbsp;</td>
+          <td class="paramname"> <em>encoding</em> = <code>TIXML_DEFAULT_ENCODING</code></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Parse the given null terminated block of xml data. 
+<p>
+Passing in an encoding to this method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml to use that encoding, regardless of what TinyXml might otherwise try to detect. 
+<p>
+Implements <a class="el" href="classTiXmlBase.html">TiXmlBase</a>.
+</div>
+</div><p>
+<a class="anchor" name="d09d17927f908f40efb406af2fb873be"></a><!-- doxytag: member="TiXmlDocument::RootElement" ref="d09d17927f908f40efb406af2fb873be" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlDocument::RootElement           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Get the root element -- the only top level element -- of the document. 
+<p>
+In well formed XML, there should only be one. TinyXml is tolerant of multiple elements at the document level. 
+</div>
+</div><p>
+<a class="anchor" name="51dac56316f89b35bdb7d0d433ba988e"></a><!-- doxytag: member="TiXmlDocument::SetTabSize" ref="51dac56316f89b35bdb7d0d433ba988e" args="(int _tabsize)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlDocument::SetTabSize           </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>_tabsize</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+<a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">SetTabSize()</a> allows the error reporting functions (<a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">ErrorRow()</a> and <a class="el" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">ErrorCol()</a>) to report the correct values for row and column. 
+<p>
+It does not change the output or input in any way.<p>
+By calling this method, with a tab size greater than 0, the row and column of each node and attribute is stored when the file is loaded. Very useful for tracking the DOM back in to the source file.<p>
+The tab size is required for calculating the location of nodes. If not set, the default of 4 is used. The tabsize is set per document. Setting the tabsize to 0 disables row/column tracking.<p>
+Note that row and column tracking is not supported when using operator&gt;&gt;.<p>
+The tab size needs to be enabled before the parse or load. Correct usage: <div class="fragment"><pre class="fragment">		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		</pre></div><p>
+<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>, <a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a> </dd></dl>
+
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlDocument.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlDocument.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlElement-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlElement-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlElement-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,116 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlElement Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlElement.html">TiXmlElement</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#71a81b2afb0d42be1543d1c404dee6f5">Accept</a>(TiXmlVisitor *visitor) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>(const char *name) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#0ed8348fdc56b72a6b4900ce5bac1849">Attribute</a>(const char *name, int *i) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#eaff99d4f0ea5b34f7aee202aad457ba">Attribute</a>(const char *name, double *d) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a464535ea1994db337cb6a8ce4b588b5">Clone</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">GetText</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#86191b49f9177be132b85b14655f1381">LastAttribute</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#fbf52736e70fc91ec9d760721d6f4fd2">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a>(const char *name, double *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#a04d3af11601ef5a5f88295203a843be">QueryFloatAttribute</a>(const char *name, float *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a>(const char *name, int *_value) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#e3b9a03b0a56663a40801c7256683576">QueryValueAttribute</a>(const std::string &amp;name, T *outValue) const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#56979767deca794376b1dfa69a525b2a">RemoveAttribute</a>(const char *name)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#1afa6aea716511326a608e4c05df4f3a">RemoveAttribute</a>(const std::string &amp;name)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#bf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a>(const char *name, const char *_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#80ed65b1d194c71c6c9986ae42337d7d">SetAttribute</a>(const std::string &amp;name, const std::string &amp;_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#ce6f4be75e373726d4774073d666d1a7">SetAttribute</a>(const char *name, int value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#0d1dd975d75496778177e35abfe0ec0b">SetDoubleAttribute</a>(const char *name, double value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>(const char *in_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#c5b8d0e25fa23fd9acbb6d146082901c">ToElement</a>() const </td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlElement.html#9def86337ea7a755eb41cac980f60c7a">ToElement</a>()</td><td><a class="el" href="classTiXmlElement.html">TiXmlElement</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlElement.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlElement.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlElement.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,420 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlElement Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlElement Class Reference</h1><!-- doxytag: class="TiXmlElement" --><!-- doxytag: inherits="TiXmlNode" -->The element is a container class.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlElement:
+<p><center><img src="classTiXmlElement.png" usemap="#TiXmlElement_map" border="0" alt=""></center>
+<map name="TiXmlElement_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,87,80">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,87,24">
+</map>
+<a href="classTiXmlElement-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01bc3ab372d35da08efcbbe65ad90c60"></a><!-- doxytag: member="TiXmlElement::TiXmlElement" ref="01bc3ab372d35da08efcbbe65ad90c60" args="(const char *in_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a> (const char *in_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="40fc2e3c1a955e2f78e1a32350d180e7"></a><!-- doxytag: member="TiXmlElement::TiXmlElement" ref="40fc2e3c1a955e2f78e1a32350d180e7" args="(const std::string &amp;_value)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::string constructor. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e419a442a9701a62b0c3d8fd1cbdd12d"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="e419a442a9701a62b0c3d8fd1cbdd12d" args="(const char *name) const " -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a> (const char *name) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute()</a> returns the value for the attribute of that name, or null if none exists. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#0ed8348fdc56b72a6b4900ce5bac1849">Attribute</a> (const char *name, int *i) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute()</a> returns the value for the attribute of that name, or null if none exists.  <a href="#0ed8348fdc56b72a6b4900ce5bac1849"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#eaff99d4f0ea5b34f7aee202aad457ba">Attribute</a> (const char *name, double *d) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an attribute name, <a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute()</a> returns the value for the attribute of that name, or null if none exists.  <a href="#eaff99d4f0ea5b34f7aee202aad457ba"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a> (const char *name, int *_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryIntAttribute examines the attribute - it is an alternative to the <a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute()</a> method with richer error checking.  <a href="#ea0bfe471380f281c5945770ddbf52b9"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="898d7730ecc341f0bffc7a9dadbf1ce7"></a><!-- doxytag: member="TiXmlElement::QueryDoubleAttribute" ref="898d7730ecc341f0bffc7a9dadbf1ce7" args="(const char *name, double *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a> (const char *name, double *_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryDoubleAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute()</a>. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a04d3af11601ef5a5f88295203a843be"></a><!-- doxytag: member="TiXmlElement::QueryFloatAttribute" ref="a04d3af11601ef5a5f88295203a843be" args="(const char *name, float *_value) const " -->
+int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a04d3af11601ef5a5f88295203a843be">QueryFloatAttribute</a> (const char *name, float *_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">QueryFloatAttribute examines the attribute - see <a class="el" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute()</a>. <br></td></tr>
+<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
+<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#e3b9a03b0a56663a40801c7256683576">QueryValueAttribute</a> (const std::string &amp;name, T *outValue) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template form of the attribute query which will try to read the attribute into the specified type.  <a href="#e3b9a03b0a56663a40801c7256683576"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#bf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a> (const char *name, const char *_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#bf0b3bd7f0e4c746a89ec6e7f101fc32"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="80ed65b1d194c71c6c9986ae42337d7d"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="80ed65b1d194c71c6c9986ae42337d7d" args="(const std::string &amp;name, const std::string &amp;_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#80ed65b1d194c71c6c9986ae42337d7d">SetAttribute</a> (const std::string &amp;name, const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#ce6f4be75e373726d4774073d666d1a7">SetAttribute</a> (const char *name, int value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#ce6f4be75e373726d4774073d666d1a7"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#0d1dd975d75496778177e35abfe0ec0b">SetDoubleAttribute</a> (const char *name, double value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an attribute of name to a given value.  <a href="#0d1dd975d75496778177e35abfe0ec0b"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="56979767deca794376b1dfa69a525b2a"></a><!-- doxytag: member="TiXmlElement::RemoveAttribute" ref="56979767deca794376b1dfa69a525b2a" args="(const char *name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#56979767deca794376b1dfa69a525b2a">RemoveAttribute</a> (const char *name)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an attribute with the given name. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1afa6aea716511326a608e4c05df4f3a"></a><!-- doxytag: member="TiXmlElement::RemoveAttribute" ref="1afa6aea716511326a608e4c05df4f3a" args="(const std::string &amp;name)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#1afa6aea716511326a608e4c05df4f3a">RemoveAttribute</a> (const std::string &amp;name)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="516054c9073647d6cb29b6abe9fa0592"></a><!-- doxytag: member="TiXmlElement::FirstAttribute" ref="516054c9073647d6cb29b6abe9fa0592" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first attribute in this element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86191b49f9177be132b85b14655f1381"></a><!-- doxytag: member="TiXmlElement::LastAttribute" ref="86191b49f9177be132b85b14655f1381" args="() const " -->
+const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#86191b49f9177be132b85b14655f1381">LastAttribute</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the last attribute in this element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">GetText</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function for easy access to the text inside an element.  <a href="#f3282294986cdb216646ea1f67af2c87"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a464535ea1994db337cb6a8ce4b588b5"></a><!-- doxytag: member="TiXmlElement::Clone" ref="a464535ea1994db337cb6a8ce4b588b5" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#a464535ea1994db337cb6a8ce4b588b5">Clone</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new Element and returns it - the returned element is a copy. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#fbf52736e70fc91ec9d760721d6f4fd2">Print</a> (FILE *cfile, int depth) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#fbf52736e70fc91ec9d760721d6f4fd2"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c5b8d0e25fa23fd9acbb6d146082901c"></a><!-- doxytag: member="TiXmlElement::ToElement" ref="c5b8d0e25fa23fd9acbb6d146082901c" args="() const " -->
+virtual const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#c5b8d0e25fa23fd9acbb6d146082901c">ToElement</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9def86337ea7a755eb41cac980f60c7a"></a><!-- doxytag: member="TiXmlElement::ToElement" ref="9def86337ea7a755eb41cac980f60c7a" args="()" -->
+virtual <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#9def86337ea7a755eb41cac980f60c7a">ToElement</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="71a81b2afb0d42be1543d1c404dee6f5"></a><!-- doxytag: member="TiXmlElement::Accept" ref="71a81b2afb0d42be1543d1c404dee6f5" args="(TiXmlVisitor *visitor) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlElement.html#71a81b2afb0d42be1543d1c404dee6f5">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+The element is a container class. 
+<p>
+It has a value, the element name, and can contain other elements, text, comments, and unknowns. Elements also contain an arbitrary number of attributes. 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="eaff99d4f0ea5b34f7aee202aad457ba"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="eaff99d4f0ea5b34f7aee202aad457ba" args="(const char *name, double *d) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::Attribute           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">double *&nbsp;</td>
+          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Given an attribute name, <a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute()</a> returns the value for the attribute of that name, or null if none exists. 
+<p>
+If the attribute exists and can be converted to an double, the double value will be put in the return 'd', if 'd' is non-null. 
+</div>
+</div><p>
+<a class="anchor" name="0ed8348fdc56b72a6b4900ce5bac1849"></a><!-- doxytag: member="TiXmlElement::Attribute" ref="0ed8348fdc56b72a6b4900ce5bac1849" args="(const char *name, int *i) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::Attribute           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Given an attribute name, <a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute()</a> returns the value for the attribute of that name, or null if none exists. 
+<p>
+If the attribute exists and can be converted to an integer, the integer value will be put in the return 'i', if 'i' is non-null. 
+</div>
+</div><p>
+<a class="anchor" name="f3282294986cdb216646ea1f67af2c87"></a><!-- doxytag: member="TiXmlElement::GetText" ref="f3282294986cdb216646ea1f67af2c87" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlElement::GetText           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Convenience function for easy access to the text inside an element. 
+<p>
+Although easy and concise, <a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">GetText()</a> is limited compared to getting the <a class="el" href="classTiXmlText.html">TiXmlText</a> child and accessing it directly.<p>
+If the first child of 'this' is a <a class="el" href="classTiXmlText.html">TiXmlText</a>, the <a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">GetText()</a> returns the character string of the Text node, else null is returned.<p>
+This is a convenient method for getting the text of simple contained text: <div class="fragment"><pre class="fragment">		&lt;foo&gt;This is text&lt;/foo&gt;
+		const char* str = fooElement-&gt;GetText();
+		</pre></div><p>
+'str' will be a pointer to "This is text".<p>
+Note that this function can be misleading. If the element foo was created from this XML: <div class="fragment"><pre class="fragment">		&lt;foo&gt;&lt;b&gt;This is text&lt;/b&gt;&lt;/foo&gt; 
+		</pre></div><p>
+then the value of str would be null. The first child node isn't a text node, it is another element. From this XML: <div class="fragment"><pre class="fragment">		&lt;foo&gt;This is &lt;b&gt;text&lt;/b&gt;&lt;/foo&gt; 
+		</pre></div> <a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">GetText()</a> will return "This is ".<p>
+WARNING: <a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">GetText()</a> accesses a child node - don't become confused with the similarly named <a class="el" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">TiXmlHandle::Text()</a> and <a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">TiXmlNode::ToText()</a> which are safe type casts on the referenced node. 
+</div>
+</div><p>
+<a class="anchor" name="fbf52736e70fc91ec9d760721d6f4fd2"></a><!-- doxytag: member="TiXmlElement::Print" ref="fbf52736e70fc91ec9d760721d6f4fd2" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlElement::Print           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. 
+<p>
+) Either or both cfile and str can be null.<p>
+This is a formatted print, and will insert tabs and newlines.<p>
+(For an unformatted stream, use the &lt;&lt; operator.) 
+<p>
+Implements <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.
+</div>
+</div><p>
+<a class="anchor" name="ea0bfe471380f281c5945770ddbf52b9"></a><!-- doxytag: member="TiXmlElement::QueryIntAttribute" ref="ea0bfe471380f281c5945770ddbf52b9" args="(const char *name, int *_value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlElement::QueryIntAttribute           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+QueryIntAttribute examines the attribute - it is an alternative to the <a class="el" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute()</a> method with richer error checking. 
+<p>
+If the attribute is an integer, it is stored in 'value' and the call returns TIXML_SUCCESS. If it is not an integer, it returns TIXML_WRONG_TYPE. If the attribute does not exist, then TIXML_NO_ATTRIBUTE is returned. 
+</div>
+</div><p>
+<a class="anchor" name="e3b9a03b0a56663a40801c7256683576"></a><!-- doxytag: member="TiXmlElement::QueryValueAttribute" ref="e3b9a03b0a56663a40801c7256683576" args="(const std::string &amp;name, T *outValue) const " -->
+<div class="memitem">
+<div class="memproto">
+<div class="memtemplate">
+template&lt;typename T&gt; </div>
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlElement::QueryValueAttribute           </td>
+          <td>(</td>
+          <td class="paramtype">const std::string &amp;&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">T *&nbsp;</td>
+          <td class="paramname"> <em>outValue</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Template form of the attribute query which will try to read the attribute into the specified type. 
+<p>
+Very easy, very powerful, but be careful to make sure to call this with the correct type.<p>
+NOTE: This method doesn't work correctly for 'string' types.<p>
+<dl compact><dt><b>Returns:</b></dt><dd>TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE </dd></dl>
+
+</div>
+</div><p>
+<a class="anchor" name="ce6f4be75e373726d4774073d666d1a7"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="ce6f4be75e373726d4774073d666d1a7" args="(const char *name, int value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Sets an attribute of name to a given value. 
+<p>
+The attribute will be created if it does not exist, or changed if it does. 
+</div>
+</div><p>
+<a class="anchor" name="bf0b3bd7f0e4c746a89ec6e7f101fc32"></a><!-- doxytag: member="TiXmlElement::SetAttribute" ref="bf0b3bd7f0e4c746a89ec6e7f101fc32" args="(const char *name, const char *_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetAttribute           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Sets an attribute of name to a given value. 
+<p>
+The attribute will be created if it does not exist, or changed if it does. 
+</div>
+</div><p>
+<a class="anchor" name="0d1dd975d75496778177e35abfe0ec0b"></a><!-- doxytag: member="TiXmlElement::SetDoubleAttribute" ref="0d1dd975d75496778177e35abfe0ec0b" args="(const char *name, double value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlElement::SetDoubleAttribute           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>name</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">double&nbsp;</td>
+          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Sets an attribute of name to a given value. 
+<p>
+The attribute will be created if it does not exist, or changed if it does. 
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlElement.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlElement.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlHandle-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlHandle-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlHandle-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,44 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlHandle Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#072492b4be1acdb0db2d03cd8f71ccc4">Child</a>(const char *value, int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#f9cf6a7d08a5da94a8924425ad0cd5ac">Child</a>(int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#979a3f850984a176ee884e394c7eed2d">ChildElement</a>(const char *value, int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#8786475b9d1f1518492e3a46704c7ef0">ChildElement</a>(int index) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#cb5fe8388a526289ea65e817a51e05e7">Element</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#cdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#8c61f64ae9365d89c264f289085541f8">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#f0aea751320f5e430fac6f8fff3b8dd4">FirstChildElement</a>(const char *value) const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#b44b723a8dc9af72838a303c079d0376">Node</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">Text</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#ba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a>(TiXmlNode *_node)</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a>(const TiXmlHandle &amp;ref)</td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#bc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#f678e5088e83be67baf76f699756f2c3">ToNode</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">ToText</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlHandle.html#49675b74357ba2aae124657a9a1ef465">Unknown</a>() const </td><td><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlHandle.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlHandle.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlHandle.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,419 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlHandle Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlHandle Class Reference</h1><!-- doxytag: class="TiXmlHandle" -->A <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<a href="classTiXmlHandle-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba18fd7bdefb942ecdea4bf4b8e29ec8"></a><!-- doxytag: member="TiXmlHandle::TiXmlHandle" ref="ba18fd7bdefb942ecdea4bf4b8e29ec8" args="(TiXmlNode *_node)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#ba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *_node)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a handle from any node (at any depth of the tree.) This can be a null pointer. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="236d7855e1e56ccc7b980630c48c7fd7"></a><!-- doxytag: member="TiXmlHandle::TiXmlHandle" ref="236d7855e1e56ccc7b980630c48c7fd7" args="(const TiXmlHandle &amp;ref)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a> (const <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> &amp;ref)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cdb1faaf88a700b40ca2c8d9aee21139"></a><!-- doxytag: member="TiXmlHandle::FirstChild" ref="cdb1faaf88a700b40ca2c8d9aee21139" args="() const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#cdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c61f64ae9365d89c264f289085541f8"></a><!-- doxytag: member="TiXmlHandle::FirstChild" ref="8c61f64ae9365d89c264f289085541f8" args="(const char *value) const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#8c61f64ae9365d89c264f289085541f8">FirstChild</a> (const char *value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child node with the given name. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="24d1112e995e937e4dddb202d4113d4a"></a><!-- doxytag: member="TiXmlHandle::FirstChildElement" ref="24d1112e995e937e4dddb202d4113d4a" args="() const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0aea751320f5e430fac6f8fff3b8dd4"></a><!-- doxytag: member="TiXmlHandle::FirstChildElement" ref="f0aea751320f5e430fac6f8fff3b8dd4" args="(const char *value) const " -->
+<a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#f0aea751320f5e430fac6f8fff3b8dd4">FirstChildElement</a> (const char *value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the first child element with the given name. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#072492b4be1acdb0db2d03cd8f71ccc4">Child</a> (const char *value, int index) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child with the given name.  <a href="#072492b4be1acdb0db2d03cd8f71ccc4"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#f9cf6a7d08a5da94a8924425ad0cd5ac">Child</a> (int index) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child.  <a href="#f9cf6a7d08a5da94a8924425ad0cd5ac"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#979a3f850984a176ee884e394c7eed2d">ChildElement</a> (const char *value, int index) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child element with the given name.  <a href="#979a3f850984a176ee884e394c7eed2d"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#8786475b9d1f1518492e3a46704c7ef0">ChildElement</a> (int index) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a handle to the "index" child element.  <a href="#8786475b9d1f1518492e3a46704c7ef0"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#f678e5088e83be67baf76f699756f2c3">ToNode</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlNode.html">TiXmlNode</a>.  <a href="#f678e5088e83be67baf76f699756f2c3"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#bc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlElement.html">TiXmlElement</a>.  <a href="#bc6e7ed383a5fe1e52b0c0004b457b9e"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">ToText</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlText.html">TiXmlText</a>.  <a href="#4ac53a652296203a5b5e13854d923586"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">ToUnknown</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle as a <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>.  <a href="#1381c17507a130767b1e23afc93b3674"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#b44b723a8dc9af72838a303c079d0376">Node</a> () const </td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#cb5fe8388a526289ea65e817a51e05e7">Element</a> () const </td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">Text</a> () const </td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlHandle.html#49675b74357ba2aae124657a9a1ef465">Unknown</a> () const </td></tr>
+
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+A <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> is a class that wraps a node pointer with null checks; this is an incredibly useful thing. 
+<p>
+Note that <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> is not part of the TinyXml DOM structure. It is a separate utility class.<p>
+Take an example: <div class="fragment"><pre class="fragment">	&lt;Document&gt;
+		&lt;Element attributeA = "valueA"&gt;
+			&lt;Child attributeB = "value1" /&gt;
+			&lt;Child attributeB = "value2" /&gt;
+		&lt;/Element&gt;
+	&lt;Document&gt;
+	</pre></div><p>
+Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very easy to write a *lot* of code that looks like:<p>
+<div class="fragment"><pre class="fragment">	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root-&gt;FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element-&gt;FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child-&gt;NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	</pre></div><p>
+And that doesn't even cover "else" cases. <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> addresses the verbosity of such code. A <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> checks for null pointers so it is perfectly safe and correct to use:<p>
+<div class="fragment"><pre class="fragment">	TiXmlHandle docHandle( &amp;document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	</pre></div><p>
+Which is MUCH more concise and useful.<p>
+It is also safe to copy handles - internally they are nothing more than node pointers. <div class="fragment"><pre class="fragment">	TiXmlHandle handleCopy = handle;
+	</pre></div><p>
+What they should not be used for is iteration:<p>
+<div class="fragment"><pre class="fragment">	int i=0; 
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	</pre></div><p>
+It seems reasonable, but it is in fact two embedded while loops. The Child method is a linear walk to find the element, so this code would iterate much more than it needs to. Instead, prefer:<p>
+<div class="fragment"><pre class="fragment">	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child-&gt;NextSiblingElement() )
+	{
+		// do something
+	}
+	</pre></div> 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="f9cf6a7d08a5da94a8924425ad0cd5ac"></a><!-- doxytag: member="TiXmlHandle::Child" ref="f9cf6a7d08a5da94a8924425ad0cd5ac" args="(int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::Child           </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return a handle to the "index" child. 
+<p>
+The first child is 0, the second 1, etc. 
+</div>
+</div><p>
+<a class="anchor" name="072492b4be1acdb0db2d03cd8f71ccc4"></a><!-- doxytag: member="TiXmlHandle::Child" ref="072492b4be1acdb0db2d03cd8f71ccc4" args="(const char *value, int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::Child           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return a handle to the "index" child with the given name. 
+<p>
+The first child is 0, the second 1, etc. 
+</div>
+</div><p>
+<a class="anchor" name="8786475b9d1f1518492e3a46704c7ef0"></a><!-- doxytag: member="TiXmlHandle::ChildElement" ref="8786475b9d1f1518492e3a46704c7ef0" args="(int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::ChildElement           </td>
+          <td>(</td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return a handle to the "index" child element. 
+<p>
+The first child element is 0, the second 1, etc. Note that only TiXmlElements are indexed: other types are not counted. 
+</div>
+</div><p>
+<a class="anchor" name="979a3f850984a176ee884e394c7eed2d"></a><!-- doxytag: member="TiXmlHandle::ChildElement" ref="979a3f850984a176ee884e394c7eed2d" args="(const char *value, int index) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> TiXmlHandle::ChildElement           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return a handle to the "index" child element with the given name. 
+<p>
+The first child element is 0, the second 1, etc. Note that only TiXmlElements are indexed: other types are not counted. 
+</div>
+</div><p>
+<a class="anchor" name="cb5fe8388a526289ea65e817a51e05e7"></a><!-- doxytag: member="TiXmlHandle::Element" ref="cb5fe8388a526289ea65e817a51e05e7" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlHandle::Element           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>use ToElement. Return the handle as a <a class="el" href="classTiXmlElement.html">TiXmlElement</a>. This may return null. </dd></dl>
+
+</div>
+</div><p>
+<a class="anchor" name="b44b723a8dc9af72838a303c079d0376"></a><!-- doxytag: member="TiXmlHandle::Node" ref="b44b723a8dc9af72838a303c079d0376" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlHandle::Node           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>use ToNode. Return the handle as a <a class="el" href="classTiXmlNode.html">TiXmlNode</a>. This may return null. </dd></dl>
+
+</div>
+</div><p>
+<a class="anchor" name="9fc739c8a18d160006f82572fc143d13"></a><!-- doxytag: member="TiXmlHandle::Text" ref="9fc739c8a18d160006f82572fc143d13" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlText.html">TiXmlText</a>* TiXmlHandle::Text           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">ToText()</a> Return the handle as a <a class="el" href="classTiXmlText.html">TiXmlText</a>. This may return null. </dd></dl>
+
+</div>
+</div><p>
+<a class="anchor" name="bc6e7ed383a5fe1e52b0c0004b457b9e"></a><!-- doxytag: member="TiXmlHandle::ToElement" ref="bc6e7ed383a5fe1e52b0c0004b457b9e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlHandle::ToElement           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return the handle as a <a class="el" href="classTiXmlElement.html">TiXmlElement</a>. 
+<p>
+This may return null. 
+</div>
+</div><p>
+<a class="anchor" name="f678e5088e83be67baf76f699756f2c3"></a><!-- doxytag: member="TiXmlHandle::ToNode" ref="f678e5088e83be67baf76f699756f2c3" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlHandle::ToNode           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return the handle as a <a class="el" href="classTiXmlNode.html">TiXmlNode</a>. 
+<p>
+This may return null. 
+</div>
+</div><p>
+<a class="anchor" name="4ac53a652296203a5b5e13854d923586"></a><!-- doxytag: member="TiXmlHandle::ToText" ref="4ac53a652296203a5b5e13854d923586" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlText.html">TiXmlText</a>* TiXmlHandle::ToText           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return the handle as a <a class="el" href="classTiXmlText.html">TiXmlText</a>. 
+<p>
+This may return null. 
+</div>
+</div><p>
+<a class="anchor" name="1381c17507a130767b1e23afc93b3674"></a><!-- doxytag: member="TiXmlHandle::ToUnknown" ref="1381c17507a130767b1e23afc93b3674" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>* TiXmlHandle::ToUnknown           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return the handle as a <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>. 
+<p>
+This may return null. 
+</div>
+</div><p>
+<a class="anchor" name="49675b74357ba2aae124657a9a1ef465"></a><!-- doxytag: member="TiXmlHandle::Unknown" ref="49675b74357ba2aae124657a9a1ef465" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>* TiXmlHandle::Unknown           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>use <a class="el" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">ToUnknown()</a> Return the handle as a <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>. This may return null. </dd></dl>
+
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlNode-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlNode-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlNode-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,98 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlNode Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlNode.html">TiXmlNode</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">Accept</a>(TiXmlVisitor *visitor) const =0</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#4508cc3a2d7a98e96a54cc09c37a78a4">Clone</a>() const =0</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">Print</a>(FILE *cfile, int depth) const =0</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [pure virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlNode.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlNode.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlNode.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,780 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlNode Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlNode Class Reference</h1><!-- doxytag: class="TiXmlNode" --><!-- doxytag: inherits="TiXmlBase" -->The parent class for everything in the Document Object Model.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlNode:
+<p><center><img src="classTiXmlNode.png" usemap="#TiXmlNode_map" border="0" alt=""></center>
+<map name="TiXmlNode_map">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="295,0,403,24">
+<area href="classTiXmlComment.html" alt="TiXmlComment" shape="rect" coords="0,112,108,136">
+<area href="classTiXmlDeclaration.html" alt="TiXmlDeclaration" shape="rect" coords="118,112,226,136">
+<area href="classTiXmlDocument.html" alt="TiXmlDocument" shape="rect" coords="236,112,344,136">
+<area href="classTiXmlElement.html" alt="TiXmlElement" shape="rect" coords="354,112,462,136">
+<area href="classTiXmlText.html" alt="TiXmlText" shape="rect" coords="472,112,580,136">
+<area href="classTiXmlUnknown.html" alt="TiXmlUnknown" shape="rect" coords="590,112,698,136">
+</map>
+<a href="classTiXmlNode-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The types of XML nodes supported by TinyXml.  <a href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">More...</a><br></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The meaning of 'value' changes for the specific type of <a class="el" href="classTiXmlNode.html">TiXmlNode</a>.  <a href="#77943eb90d12c2892b1337a9f5918b41"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value()</a> as a std::string.  <a href="#6d9e505619d39bf50bfd9609c9169ea5"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a> (const char *_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the value of the node.  <a href="#2a38329ca5d3f28f98ce932b8299ae90"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2598d5f448042c1abbeae4503dd45ff2"></a><!-- doxytag: member="TiXmlNode::SetValue" ref="2598d5f448042c1abbeae4503dd45ff2" args="(const std::string &amp;_value)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="708e7f953df61d4d2d12f73171550a4b"></a><!-- doxytag: member="TiXmlNode::Clear" ref="708e7f953df61d4d2d12f73171550a4b" args="()" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete all the children of this node. Does not affect 'this'. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b643043132ffd794f8602685d34a982e"></a><!-- doxytag: member="TiXmlNode::Parent" ref="b643043132ffd794f8602685d34a982e" args="()" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One step up the DOM. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="44c8eee26bbe2d1b2762038df9dde2f0"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="44c8eee26bbe2d1b2762038df9dde2f0" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node. Will be null if there are no children. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a> (const char *value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node with the matching 'value'.  <a href="#1f05828d023150706eeb16d6fb3f6355"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc8bf32be6419ec453a731868de19554"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="bc8bf32be6419ec453a731868de19554" args="(const char *_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a> (const char *_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first child of this node with the matching 'value'. Will be null if none found. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6432d2b2495f6caf9cb4278df706a031"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="6432d2b2495f6caf9cb4278df706a031" args="()" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last child of this node. Will be null if there are no children. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bad5bf1059c48127b958711ef89e8e5d"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="bad5bf1059c48127b958711ef89e8e5d" args="(const char *_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a> (const char *_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last child of this node matching 'value'. Will be null if there are no children. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="07f6200a5956c723c5b52d70f29c46f6"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="07f6200a5956c723c5b52d70f29c46f6" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a> (const std::string &amp;_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10d2669ccb5e29e02fcb0e4408685ef6"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="10d2669ccb5e29e02fcb0e4408685ef6" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="256d0cdbfcfeccae83f3a1c9747a8b63"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="256d0cdbfcfeccae83f3a1c9747a8b63" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a> (const std::string &amp;_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="69772c9202f70553f940b15c06b07be3"></a><!-- doxytag: member="TiXmlNode::LastChild" ref="69772c9202f70553f940b15c06b07be3" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a> (const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alternate way to walk the children of a node.  <a href="#8621196ba3705fa226bef4a761cc51b6"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dfaef35a076b9343adc1420757376c39"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="dfaef35a076b9343adc1420757376c39" args="(const char *value, const TiXmlNode *previous) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a> (const char *value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This flavor of IterateChildren searches for children with a particular 'value'. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1cbaaf8e82c09ad763d52616d75724df"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="1cbaaf8e82c09ad763d52616d75724df" args="(const std::string &amp;_value, const TiXmlNode *previous) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a> (const std::string &amp;_value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16e9ad53e2f5445b14bf325c90aa862c"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="16e9ad53e2f5445b14bf325c90aa862c" args="(const std::string &amp;_value, const TiXmlNode *previous)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a> (const std::string &amp;_value, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *previous)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a> (const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#d7d4630e1a2a916edda16be22448a8ba"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *addThis)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#5d29442ae46de6d0168429156197bfc6"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *beforeThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#0c146fa2fff0157b681594102f48cbc7"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *afterThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;addThis)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new node related to this.  <a href="#d9b75e54ec19301c8b4d5ff583d0b3d5"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *replaceThis, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;withThis)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a child of this node.  <a href="#0c49e739a17b9938050c22cd89617fbd"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e19d8510efc90596552f4feeac9a8fbf"></a><!-- doxytag: member="TiXmlNode::RemoveChild" ref="e19d8510efc90596552f4feeac9a8fbf" args="(TiXmlNode *removeThis)" -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a> (<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *removeThis)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a child of this node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2cd892768726270e511b2ab32de4d10"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="c2cd892768726270e511b2ab32de4d10" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5bdd49327eec1e609b7d22af706b8316"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="5bdd49327eec1e609b7d22af706b8316" args="(const char *) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a> (const char *) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="658276f57d35d5d4256d1dc1a2c398ab"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="658276f57d35d5d4256d1dc1a2c398ab" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a> (const std::string &amp;_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc8a0434c7f401d4a3b6dee77c1a5912"></a><!-- doxytag: member="TiXmlNode::PreviousSibling" ref="cc8a0434c7f401d4a3b6dee77c1a5912" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b94d2f7fa7ab25a5a8e8d4340c449c9"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="1b94d2f7fa7ab25a5a8e8d4340c449c9" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a> (const std::string &amp;_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1757c1f4d01e8c9596ffdbd561c76aea"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="1757c1f4d01e8c9596ffdbd561c76aea" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f854baeba384f5fe9859f5aee03b548e"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="f854baeba384f5fe9859f5aee03b548e" args="() const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e61c0b89a77e36a0e8c60490003cb46"></a><!-- doxytag: member="TiXmlNode::NextSibling" ref="2e61c0b89a77e36a0e8c60490003cb46" args="(const char *) const " -->
+const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a> (const char *) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Navigate to a sibling node with the given 'value'. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements.  <a href="#73acf929d49d10bd0e5fb3d31b0372d1"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a> (const char *) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements.  <a href="#071ba77fd7ab79402fa84b7e9b8607b3"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7572d0af9d1e696ee3f05d8bb5ebb463"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="7572d0af9d1e696ee3f05d8bb5ebb463" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a> (const std::string &amp;_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="506958e34406729a4e4c5326ea39d081"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="506958e34406729a4e4c5326ea39d081" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4fb652f6bd79ae0d5ce7d0f7d3c0fba"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="f4fb652f6bd79ae0d5ce7d0f7d3c0fba" args="() const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ccda2c6b45c25bb5a6f9c3407a644e61"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="ccda2c6b45c25bb5a6f9c3407a644e61" args="(const char *_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a> (const char *_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to get through elements. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="327ad4bbd90073c5dfc931b07314f5f7"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="327ad4bbd90073c5dfc931b07314f5f7" args="(const std::string &amp;_value) const " -->
+const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a> (const std::string &amp;_value) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f1d7291880534c1e5cdeb392d8c1f45"></a><!-- doxytag: member="TiXmlNode::FirstChildElement" ref="7f1d7291880534c1e5cdeb392d8c1f45" args="(const std::string &amp;_value)" -->
+<a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a> (const std::string &amp;_value)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL std::string form. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the type (as an enumerated value, above) of this node.  <a href="#57b99d5c97d67a42b9752f5210a1ba5e"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the Document this node lives in.  <a href="#80e397fa973cf5323e33b07154b024f3"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eed21ad30630ef6e7faf096127edc9f3"></a><!-- doxytag: member="TiXmlNode::NoChildren" ref="eed21ad30630ef6e7faf096127edc9f3" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node has no children. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a4cda4b15c29f64cff419309aebed08"></a><!-- doxytag: member="TiXmlNode::ToDocument" ref="8a4cda4b15c29f64cff419309aebed08" args="() const " -->
+virtual const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="72abed96dc9667ab9e0a2a275301bb1c"></a><!-- doxytag: member="TiXmlNode::ToElement" ref="72abed96dc9667ab9e0a2a275301bb1c" args="() const " -->
+virtual const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0a5086f9eaee910bbfdc7f975e26574"></a><!-- doxytag: member="TiXmlNode::ToComment" ref="a0a5086f9eaee910bbfdc7f975e26574" args="() const " -->
+virtual const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd7205cf31d7a376929f8a36930627a2"></a><!-- doxytag: member="TiXmlNode::ToUnknown" ref="fd7205cf31d7a376929f8a36930627a2" args="() const " -->
+virtual const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95a46a52c525992d6b4ee08beb14cd69"></a><!-- doxytag: member="TiXmlNode::ToText" ref="95a46a52c525992d6b4ee08beb14cd69" args="() const " -->
+virtual const <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9f43e6984fc7d4afd6eb32714c6b7b72"></a><!-- doxytag: member="TiXmlNode::ToDeclaration" ref="9f43e6984fc7d4afd6eb32714c6b7b72" args="() const " -->
+virtual const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a4c8ac28ee7a745d059db6691e03bae"></a><!-- doxytag: member="TiXmlNode::ToDocument" ref="6a4c8ac28ee7a745d059db6691e03bae" args="()" -->
+virtual <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a65d000223187d22a4dcebd7479e9ebc"></a><!-- doxytag: member="TiXmlNode::ToElement" ref="a65d000223187d22a4dcebd7479e9ebc" args="()" -->
+virtual <a class="el" href="classTiXmlElement.html">TiXmlElement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">ToElement</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="383e06a0787f7063953934867990f849"></a><!-- doxytag: member="TiXmlNode::ToComment" ref="383e06a0787f7063953934867990f849" args="()" -->
+virtual <a class="el" href="classTiXmlComment.html">TiXmlComment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">ToComment</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06de5af852668c7e4af0d09c205f0b0d"></a><!-- doxytag: member="TiXmlNode::ToUnknown" ref="06de5af852668c7e4af0d09c205f0b0d" args="()" -->
+virtual <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3ddfbcac78fbea041fad57e5c6d60a03"></a><!-- doxytag: member="TiXmlNode::ToText" ref="3ddfbcac78fbea041fad57e5c6d60a03" args="()" -->
+virtual <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">ToText</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4027136ca820ff4a636b607231b6a6df"></a><!-- doxytag: member="TiXmlNode::ToDeclaration" ref="4027136ca820ff4a636b607231b6a6df" args="()" -->
+virtual <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">ToDeclaration</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null if not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#4508cc3a2d7a98e96a54cc09c37a78a4">Clone</a> () const =0</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exact duplicate of this node and return it.  <a href="#4508cc3a2d7a98e96a54cc09c37a78a4"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *visitor) const =0</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a hierchical visit the nodes in the TinyXML DOM.  <a href="#cc0f88b7462c6cb73809d410a4f5bb86"></a><br></td></tr>
+<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="173617f6dfe902cf484ce5552b950475"></a><!-- doxytag: member="TiXmlNode::TiXmlDocument" ref="173617f6dfe902cf484ce5552b950475" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#173617f6dfe902cf484ce5552b950475">TiXmlDocument</a></td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlNode::TiXmlElement" ref="b6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#b6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+
+<tr><td class="memItemLeft" nowrap align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An input stream operator, for every class.  <a href="#b57bd426563c926844f65a78412e18b9"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An output stream operator, for every class.  <a href="#86cd49cfb17a844c0010b3136ac966c7"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52ef17e7080df2490cf87bde380685ab"></a><!-- doxytag: member="TiXmlNode::operator&lt;&lt;" ref="52ef17e7080df2490cf87bde380685ab" args="(std::string &amp;out, const TiXmlNode &amp;base)" -->
+std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a> (std::string &amp;out, const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;base)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the XML node or attribute to a std::string. <br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+The parent class for everything in the Document Object Model. 
+<p>
+(Except for attributes). Nodes have siblings, a parent, and children. A node can be in a document, or stand on its own. The type of a <a class="el" href="classTiXmlNode.html">TiXmlNode</a> can be queried, and it can be cast to its more defined type. 
+<p>
+<hr><h2>Member Enumeration Documentation</h2>
+<a class="anchor" name="836eded4920ab9e9ef28496f48cd95a2"></a><!-- doxytag: member="TiXmlNode::NodeType" ref="836eded4920ab9e9ef28496f48cd95a2" args="" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">enum <a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">TiXmlNode::NodeType</a>          </td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+The types of XML nodes supported by TinyXml. 
+<p>
+(All the unsupported types are picked up by UNKNOWN.) 
+</div>
+</div><p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="cc0f88b7462c6cb73809d410a4f5bb86"></a><!-- doxytag: member="TiXmlNode::Accept" ref="cc0f88b7462c6cb73809d410a4f5bb86" args="(TiXmlVisitor *visitor) const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual bool TiXmlNode::Accept           </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *&nbsp;</td>
+          <td class="paramname"> <em>visitor</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Accept a hierchical visit the nodes in the TinyXML DOM. 
+<p>
+Every node in the XML tree will be conditionally visited and the host will be called back via the <a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> interface.<p>
+This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML is unchanged by using this interface versus any other.)<p>
+The interface has been based on ideas from:<p>
+<ul>
+<li><a href="http://www.saxproject.org/">http://www.saxproject.org/</a></li><li><a href="http://c2.com/cgi/wiki?HierarchicalVisitorPattern">http://c2.com/cgi/wiki?HierarchicalVisitorPattern</a></li></ul>
+<p>
+Which are both good references for "visiting".<p>
+An example of using <a class="el" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">Accept()</a>: <div class="fragment"><pre class="fragment">		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &amp;printer );
+		const char* xmlcstr = printer.CStr();
+		</pre></div> 
+<p>
+Implemented in <a class="el" href="classTiXmlElement.html#71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#f3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#d7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#a545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>.
+</div>
+</div><p>
+<a class="anchor" name="4508cc3a2d7a98e96a54cc09c37a78a4"></a><!-- doxytag: member="TiXmlNode::Clone" ref="4508cc3a2d7a98e96a54cc09c37a78a4" args="() const =0" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::Clone           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [pure virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Create an exact duplicate of this node and return it. 
+<p>
+The memory must be deleted by the caller. 
+<p>
+Implemented in <a class="el" href="classTiXmlElement.html#a464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>, <a class="el" href="classTiXmlComment.html#0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>, <a class="el" href="classTiXmlText.html#0c411e93a27537369479d034cc82da3b">TiXmlText</a>, <a class="el" href="classTiXmlDeclaration.html#7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlUnknown.html#0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>, and <a class="el" href="classTiXmlDocument.html#4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>.
+</div>
+</div><p>
+<a class="anchor" name="1f05828d023150706eeb16d6fb3f6355"></a><!-- doxytag: member="TiXmlNode::FirstChild" ref="1f05828d023150706eeb16d6fb3f6355" args="(const char *value) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::FirstChild           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>value</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+The first child of this node with the matching 'value'. 
+<p>
+Will be null if none found. 
+</div>
+</div><p>
+<a class="anchor" name="80e397fa973cf5323e33b07154b024f3"></a><!-- doxytag: member="TiXmlNode::GetDocument" ref="80e397fa973cf5323e33b07154b024f3" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>* TiXmlNode::GetDocument           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return a pointer to the Document this node lives in. 
+<p>
+Returns null if not in a document. 
+</div>
+</div><p>
+<a class="anchor" name="d9b75e54ec19301c8b4d5ff583d0b3d5"></a><!-- doxytag: member="TiXmlNode::InsertAfterChild" ref="d9b75e54ec19301c8b4d5ff583d0b3d5" args="(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertAfterChild           </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>afterThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Add a new node related to this. 
+<p>
+Adds a child after the specified child. Returns a pointer to the new object or NULL if an error occured. 
+</div>
+</div><p>
+<a class="anchor" name="0c146fa2fff0157b681594102f48cbc7"></a><!-- doxytag: member="TiXmlNode::InsertBeforeChild" ref="0c146fa2fff0157b681594102f48cbc7" args="(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertBeforeChild           </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>beforeThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Add a new node related to this. 
+<p>
+Adds a child before the specified child. Returns a pointer to the new object or NULL if an error occured. 
+</div>
+</div><p>
+<a class="anchor" name="d7d4630e1a2a916edda16be22448a8ba"></a><!-- doxytag: member="TiXmlNode::InsertEndChild" ref="d7d4630e1a2a916edda16be22448a8ba" args="(const TiXmlNode &amp;addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::InsertEndChild           </td>
+          <td>(</td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>addThis</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Add a new node related to this. 
+<p>
+Adds a child past the LastChild. Returns a pointer to the new object or NULL if an error occured. 
+</div>
+</div><p>
+<a class="anchor" name="8621196ba3705fa226bef4a761cc51b6"></a><!-- doxytag: member="TiXmlNode::IterateChildren" ref="8621196ba3705fa226bef4a761cc51b6" args="(const TiXmlNode *previous) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::IterateChildren           </td>
+          <td>(</td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>previous</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+An alternate way to walk the children of a node. 
+<p>
+One way to iterate over nodes is: <div class="fragment"><pre class="fragment">			for( child = parent-&gt;FirstChild(); child; child = child-&gt;NextSibling() )
+		</pre></div><p>
+IterateChildren does the same thing with the syntax: <div class="fragment"><pre class="fragment">			child = 0;
+			while( child = parent-&gt;IterateChildren( child ) )
+		</pre></div><p>
+IterateChildren takes the previous child as input and finds the next one. If the previous child is null, it returns the first. IterateChildren will return null when done. 
+</div>
+</div><p>
+<a class="anchor" name="5d29442ae46de6d0168429156197bfc6"></a><!-- doxytag: member="TiXmlNode::LinkEndChild" ref="5d29442ae46de6d0168429156197bfc6" args="(TiXmlNode *addThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::LinkEndChild           </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>addThis</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Add a new node related to this. 
+<p>
+Adds a child past the LastChild.<p>
+NOTE: the node to be added is passed by pointer, and will be henceforth owned (and deleted) by tinyXml. This method is efficient and avoids an extra copy, but should be used with care as it uses a different memory model than the other insert functions.<p>
+<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a> </dd></dl>
+
+</div>
+</div><p>
+<a class="anchor" name="071ba77fd7ab79402fa84b7e9b8607b3"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="071ba77fd7ab79402fa84b7e9b8607b3" args="(const char *) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlNode::NextSiblingElement           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Convenience function to get through elements. 
+<p>
+Calls NextSibling and ToElement. Will skip all non-Element nodes. Returns 0 if there is not another element. 
+</div>
+</div><p>
+<a class="anchor" name="73acf929d49d10bd0e5fb3d31b0372d1"></a><!-- doxytag: member="TiXmlNode::NextSiblingElement" ref="73acf929d49d10bd0e5fb3d31b0372d1" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const <a class="el" href="classTiXmlElement.html">TiXmlElement</a>* TiXmlNode::NextSiblingElement           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const</td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Convenience function to get through elements. 
+<p>
+Calls NextSibling and ToElement. Will skip all non-Element nodes. Returns 0 if there is not another element. 
+</div>
+</div><p>
+<a class="anchor" name="0c49e739a17b9938050c22cd89617fbd"></a><!-- doxytag: member="TiXmlNode::ReplaceChild" ref="0c49e739a17b9938050c22cd89617fbd" args="(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname"><a class="el" href="classTiXmlNode.html">TiXmlNode</a>* TiXmlNode::ReplaceChild           </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td>
+          <td class="paramname"> <em>replaceThis</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>withThis</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Replace a child of this node. 
+<p>
+Returns a pointer to the new object or NULL if an error occured. 
+</div>
+</div><p>
+<a class="anchor" name="2a38329ca5d3f28f98ce932b8299ae90"></a><!-- doxytag: member="TiXmlNode::SetValue" ref="2a38329ca5d3f28f98ce932b8299ae90" args="(const char *_value)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlNode::SetValue           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_value</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Changes the value of the node. 
+<p>
+Defined as: <div class="fragment"><pre class="fragment">		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		</pre></div> 
+</div>
+</div><p>
+<a class="anchor" name="57b99d5c97d67a42b9752f5210a1ba5e"></a><!-- doxytag: member="TiXmlNode::Type" ref="57b99d5c97d67a42b9752f5210a1ba5e" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">int TiXmlNode::Type           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Query the type (as an enumerated value, above) of this node. 
+<p>
+The possible types are: DOCUMENT, ELEMENT, COMMENT, UNKNOWN, TEXT, and DECLARATION. 
+</div>
+</div><p>
+<a class="anchor" name="77943eb90d12c2892b1337a9f5918b41"></a><!-- doxytag: member="TiXmlNode::Value" ref="77943eb90d12c2892b1337a9f5918b41" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const char* TiXmlNode::Value           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+The meaning of 'value' changes for the specific type of <a class="el" href="classTiXmlNode.html">TiXmlNode</a>. 
+<p>
+<div class="fragment"><pre class="fragment">		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		</pre></div><p>
+The subclasses will wrap this function. 
+</div>
+</div><p>
+<a class="anchor" name="6d9e505619d39bf50bfd9609c9169ea5"></a><!-- doxytag: member="TiXmlNode::ValueStr" ref="6d9e505619d39bf50bfd9609c9169ea5" args="() const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">const std::string&amp; TiXmlNode::ValueStr           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"> const<code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Return <a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value()</a> as a std::string. 
+<p>
+If you only use STL, this is more efficient than calling <a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value()</a>. Only available in STL mode. 
+</div>
+</div><p>
+<hr><h2>Friends And Related Function Documentation</h2>
+<a class="anchor" name="86cd49cfb17a844c0010b3136ac966c7"></a><!-- doxytag: member="TiXmlNode::operator&lt;&lt;" ref="86cd49cfb17a844c0010b3136ac966c7" args="(std::ostream &amp;out, const TiXmlNode &amp;base)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">std::ostream&amp; operator&lt;&lt;           </td>
+          <td>(</td>
+          <td class="paramtype">std::ostream &amp;&nbsp;</td>
+          <td class="paramname"> <em>out</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">const <a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"><code> [friend]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+An output stream operator, for every class. 
+<p>
+Note that this outputs without any newlines or formatting, as opposed to <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">Print()</a>, which includes tabs and new lines.<p>
+The operator&lt;&lt; and operator&gt;&gt; are not completely symmetric. Writing a node to a stream is very well defined. You'll get a nice stream of output, without any extra whitespace or newlines.<p>
+But reading is not as well defined. (As it always is.) If you create a <a class="el" href="classTiXmlElement.html">TiXmlElement</a> (for example) and read that from an input stream, the text needs to define an element or junk will result. This is true of all input streams, but it's worth keeping in mind.<p>
+A <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> will read nodes until it reads a root element, and all the children of that root element. 
+</div>
+</div><p>
+<a class="anchor" name="b57bd426563c926844f65a78412e18b9"></a><!-- doxytag: member="TiXmlNode::operator&gt;&gt;" ref="b57bd426563c926844f65a78412e18b9" args="(std::istream &amp;in, TiXmlNode &amp;base)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">std::istream&amp; operator&gt;&gt;           </td>
+          <td>(</td>
+          <td class="paramtype">std::istream &amp;&nbsp;</td>
+          <td class="paramname"> <em>in</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype"><a class="el" href="classTiXmlNode.html">TiXmlNode</a> &amp;&nbsp;</td>
+          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"><code> [friend]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+An input stream operator, for every class. 
+<p>
+Tolerant of newlines and formatting, but doesn't expect them. 
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlNode.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlNode.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlPrinter-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlPrinter-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlPrinter-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlPrinter Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#859eede9597d3e0355b77757be48735e">CStr</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#bb33ec7d4bad6aaeb57f4304394b133d">Indent</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#11f1b4804a460b175ec244eb5724d96d">LineBreak</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#213377a4070c7e625bae59716b089e5e">SetIndent</a>(const char *_indent)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#4be1e37e69e3858c59635aa947174fe6">SetLineBreak</a>(const char *_lineBreak)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#b23a90629e374cb1cadca090468bbd19">SetStreamPrinting</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#d01375ae9199bd2f48252eaddce3039d">Size</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#3bd4daf44309b41f5813a833caa0d1c9">Str</a>()</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#ce1b14d33eede2575c0743e2350f6a38">Visit</a>(const TiXmlDeclaration &amp;declaration)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#711e7d65d4af9ec70977568d2451fb1c">Visit</a>(const TiXmlText &amp;text)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#83c13d6b980064b30f989f9a35498979">Visit</a>(const TiXmlComment &amp;comment)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#d2dca6dd106e8982fd3c7db1f3330970">Visit</a>(const TiXmlUnknown &amp;unknown)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a>(const TiXmlDocument &amp;doc)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#0c5e7bf8622838417a0d0bfb8f433854">VisitEnter</a>(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#66b33edd76c538b462f789b797a4fdf2">VisitExit</a>(const TiXmlDocument &amp;doc)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlPrinter.html#1853cf2f6e63ad4b4232b4835e0acaf0">VisitExit</a>(const TiXmlElement &amp;element)</td><td><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a></td><td><code> [virtual]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlPrinter.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlPrinter.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlPrinter.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,184 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlPrinter Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlPrinter Class Reference</h1><!-- doxytag: class="TiXmlPrinter" --><!-- doxytag: inherits="TiXmlVisitor" -->Print to memory functionality.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlPrinter:
+<p><center><img src="classTiXmlPrinter.png" usemap="#TiXmlPrinter_map" border="0" alt=""></center>
+<map name="TiXmlPrinter_map">
+<area href="classTiXmlVisitor.html" alt="TiXmlVisitor" shape="rect" coords="0,0,81,24">
+</map>
+<a href="classTiXmlPrinter-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="799f4f0388570cbb54c0d3c345fef7c1"></a><!-- doxytag: member="TiXmlPrinter::VisitEnter" ref="799f4f0388570cbb54c0d3c345fef7c1" args="(const TiXmlDocument &amp;doc)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;doc)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="66b33edd76c538b462f789b797a4fdf2"></a><!-- doxytag: member="TiXmlPrinter::VisitExit" ref="66b33edd76c538b462f789b797a4fdf2" args="(const TiXmlDocument &amp;doc)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#66b33edd76c538b462f789b797a4fdf2">VisitExit</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;doc)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c5e7bf8622838417a0d0bfb8f433854"></a><!-- doxytag: member="TiXmlPrinter::VisitEnter" ref="0c5e7bf8622838417a0d0bfb8f433854" args="(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#0c5e7bf8622838417a0d0bfb8f433854">VisitEnter</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;element, const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *firstAttribute)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1853cf2f6e63ad4b4232b4835e0acaf0"></a><!-- doxytag: member="TiXmlPrinter::VisitExit" ref="1853cf2f6e63ad4b4232b4835e0acaf0" args="(const TiXmlElement &amp;element)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#1853cf2f6e63ad4b4232b4835e0acaf0">VisitExit</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;element)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce1b14d33eede2575c0743e2350f6a38"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="ce1b14d33eede2575c0743e2350f6a38" args="(const TiXmlDeclaration &amp;declaration)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#ce1b14d33eede2575c0743e2350f6a38">Visit</a> (const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> &amp;declaration)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a declaration. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="711e7d65d4af9ec70977568d2451fb1c"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="711e7d65d4af9ec70977568d2451fb1c" args="(const TiXmlText &amp;text)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#711e7d65d4af9ec70977568d2451fb1c">Visit</a> (const <a class="el" href="classTiXmlText.html">TiXmlText</a> &amp;text)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a text node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83c13d6b980064b30f989f9a35498979"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="83c13d6b980064b30f989f9a35498979" args="(const TiXmlComment &amp;comment)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#83c13d6b980064b30f989f9a35498979">Visit</a> (const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> &amp;comment)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a comment node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2dca6dd106e8982fd3c7db1f3330970"></a><!-- doxytag: member="TiXmlPrinter::Visit" ref="d2dca6dd106e8982fd3c7db1f3330970" args="(const TiXmlUnknown &amp;unknown)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#d2dca6dd106e8982fd3c7db1f3330970">Visit</a> (const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> &amp;unknown)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an unknow node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#213377a4070c7e625bae59716b089e5e">SetIndent</a> (const char *_indent)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the indent characters for printing.  <a href="#213377a4070c7e625bae59716b089e5e"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb33ec7d4bad6aaeb57f4304394b133d"></a><!-- doxytag: member="TiXmlPrinter::Indent" ref="bb33ec7d4bad6aaeb57f4304394b133d" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#bb33ec7d4bad6aaeb57f4304394b133d">Indent</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the indention string. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#4be1e37e69e3858c59635aa947174fe6">SetLineBreak</a> (const char *_lineBreak)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the line breaking string.  <a href="#4be1e37e69e3858c59635aa947174fe6"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="11f1b4804a460b175ec244eb5724d96d"></a><!-- doxytag: member="TiXmlPrinter::LineBreak" ref="11f1b4804a460b175ec244eb5724d96d" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#11f1b4804a460b175ec244eb5724d96d">LineBreak</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the current line breaking string. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#b23a90629e374cb1cadca090468bbd19">SetStreamPrinting</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch over to "stream printing" which is the most dense formatting without linebreaks.  <a href="#b23a90629e374cb1cadca090468bbd19"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="859eede9597d3e0355b77757be48735e"></a><!-- doxytag: member="TiXmlPrinter::CStr" ref="859eede9597d3e0355b77757be48735e" args="()" -->
+const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#859eede9597d3e0355b77757be48735e">CStr</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the result. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d01375ae9199bd2f48252eaddce3039d"></a><!-- doxytag: member="TiXmlPrinter::Size" ref="d01375ae9199bd2f48252eaddce3039d" args="()" -->
+size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#d01375ae9199bd2f48252eaddce3039d">Size</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length of the result string. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3bd4daf44309b41f5813a833caa0d1c9"></a><!-- doxytag: member="TiXmlPrinter::Str" ref="3bd4daf44309b41f5813a833caa0d1c9" args="()" -->
+const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlPrinter.html#3bd4daf44309b41f5813a833caa0d1c9">Str</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the result. <br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+Print to memory functionality. 
+<p>
+The <a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a> is useful when you need to:<p>
+<ol type=1>
+<li>Print to memory (especially in non-STL mode)</li><li>Control formatting (line endings, etc.)</li></ol>
+<p>
+When constructed, the <a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a> is in its default "pretty printing" mode. Before calling Accept() you can call methods to control the printing of the XML document. After <a class="el" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode::Accept()</a> is called, the printed document can be accessed via the <a class="el" href="classTiXmlPrinter.html#859eede9597d3e0355b77757be48735e">CStr()</a>, <a class="el" href="classTiXmlPrinter.html#3bd4daf44309b41f5813a833caa0d1c9">Str()</a>, and <a class="el" href="classTiXmlPrinter.html#d01375ae9199bd2f48252eaddce3039d">Size()</a> methods.<p>
+<a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a> uses the Visitor API. <div class="fragment"><pre class="fragment">	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &amp;printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	</pre></div> 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="213377a4070c7e625bae59716b089e5e"></a><!-- doxytag: member="TiXmlPrinter::SetIndent" ref="213377a4070c7e625bae59716b089e5e" args="(const char *_indent)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetIndent           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_indent</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Set the indent characters for printing. 
+<p>
+By default 4 spaces but tab () is also useful, or null/empty string for no indentation. 
+</div>
+</div><p>
+<a class="anchor" name="4be1e37e69e3858c59635aa947174fe6"></a><!-- doxytag: member="TiXmlPrinter::SetLineBreak" ref="4be1e37e69e3858c59635aa947174fe6" args="(const char *_lineBreak)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetLineBreak           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>_lineBreak</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Set the line breaking string. 
+<p>
+By default set to newline (<br>
+). Some operating systems prefer other characters, or can be set to the null/empty string for no indenation. 
+</div>
+</div><p>
+<a class="anchor" name="b23a90629e374cb1cadca090468bbd19"></a><!-- doxytag: member="TiXmlPrinter::SetStreamPrinting" ref="b23a90629e374cb1cadca090468bbd19" args="()" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">void TiXmlPrinter::SetStreamPrinting           </td>
+          <td>(</td>
+          <td class="paramname">          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Switch over to "stream printing" which is the most dense formatting without linebreaks. 
+<p>
+Common when the XML is needed for network transmission. 
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlPrinter.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlPrinter.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlText-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlText-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlText-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,102 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlText Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlText.html">TiXmlText</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#8483d4415ce9de6c4fa8f63d067d5de6">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#d1a6a6b83fa2271022dd97c072a2b586">CDATA</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#0c411e93a27537369479d034cc82da3b">Clone</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [protected, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#0cafbf6f236c7f02d12b2bffc2b7976b">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#cb17ff7c5d09b2c839393445a3de5ea9">SetCDATA</a>(bool _cdata)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#f659e77c6b87d684827f35a8f4895960">TiXmlText</a>(const char *initValue)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a>(const std::string &amp;initValue)</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#895bf34ffad17f7439ab2a52b9651648">ToText</a>() const </td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlText.html#e7c3a8fd3e4dbf6c0c4363a943d72f5b">ToText</a>()</td><td><a class="el" href="classTiXmlText.html">TiXmlText</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">ToUnknown</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlText.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlText.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlText.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,145 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlText Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlText Class Reference</h1><!-- doxytag: class="TiXmlText" --><!-- doxytag: inherits="TiXmlNode" -->XML text.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlText:
+<p><center><img src="classTiXmlText.png" usemap="#TiXmlText_map" border="0" alt=""></center>
+<map name="TiXmlText_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,73,80">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,73,24">
+</map>
+<a href="classTiXmlText-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#f659e77c6b87d684827f35a8f4895960">TiXmlText</a> (const char *initValue)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for text element.  <a href="#f659e77c6b87d684827f35a8f4895960"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="439792f6183a3d3fb6f2bc2b16fa5691"></a><!-- doxytag: member="TiXmlText::TiXmlText" ref="439792f6183a3d3fb6f2bc2b16fa5691" args="(const std::string &amp;initValue)" -->
+&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a> (const std::string &amp;initValue)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#0cafbf6f236c7f02d12b2bffc2b7976b">Print</a> (FILE *cfile, int depth) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#0cafbf6f236c7f02d12b2bffc2b7976b"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1a6a6b83fa2271022dd97c072a2b586"></a><!-- doxytag: member="TiXmlText::CDATA" ref="d1a6a6b83fa2271022dd97c072a2b586" args="() const " -->
+bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#d1a6a6b83fa2271022dd97c072a2b586">CDATA</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries whether this represents text using a CDATA section. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb17ff7c5d09b2c839393445a3de5ea9"></a><!-- doxytag: member="TiXmlText::SetCDATA" ref="cb17ff7c5d09b2c839393445a3de5ea9" args="(bool _cdata)" -->
+void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#cb17ff7c5d09b2c839393445a3de5ea9">SetCDATA</a> (bool _cdata)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on or off a CDATA representation of text. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="895bf34ffad17f7439ab2a52b9651648"></a><!-- doxytag: member="TiXmlText::ToText" ref="895bf34ffad17f7439ab2a52b9651648" args="() const " -->
+virtual const <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#895bf34ffad17f7439ab2a52b9651648">ToText</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e7c3a8fd3e4dbf6c0c4363a943d72f5b"></a><!-- doxytag: member="TiXmlText::ToText" ref="e7c3a8fd3e4dbf6c0c4363a943d72f5b" args="()" -->
+virtual <a class="el" href="classTiXmlText.html">TiXmlText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#e7c3a8fd3e4dbf6c0c4363a943d72f5b">ToText</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8483d4415ce9de6c4fa8f63d067d5de6"></a><!-- doxytag: member="TiXmlText::Accept" ref="8483d4415ce9de6c4fa8f63d067d5de6" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#8483d4415ce9de6c4fa8f63d067d5de6">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br></td></tr>
+<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c411e93a27537369479d034cc82da3b"></a><!-- doxytag: member="TiXmlText::Clone" ref="0c411e93a27537369479d034cc82da3b" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#0c411e93a27537369479d034cc82da3b">Clone</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[internal use] Creates a new Element and returns it. <br></td></tr>
+<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6592e32cb9132be517cc12a70564c4b"></a><!-- doxytag: member="TiXmlText::TiXmlElement" ref="b6592e32cb9132be517cc12a70564c4b" args="" -->
+class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlText.html#b6592e32cb9132be517cc12a70564c4b">TiXmlElement</a></td></tr>
+
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+XML text. 
+<p>
+A text node can have 2 ways to output the next. "normal" output and CDATA. It will default to the mode it was parsed from the XML file and you generally want to leave it alone, but you can change the output mode with <a class="el" href="classTiXmlText.html#cb17ff7c5d09b2c839393445a3de5ea9">SetCDATA()</a> and query it with <a class="el" href="classTiXmlText.html#d1a6a6b83fa2271022dd97c072a2b586">CDATA()</a>. 
+<p>
+<hr><h2>Constructor &amp; Destructor Documentation</h2>
+<a class="anchor" name="f659e77c6b87d684827f35a8f4895960"></a><!-- doxytag: member="TiXmlText::TiXmlText" ref="f659e77c6b87d684827f35a8f4895960" args="(const char *initValue)" -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">TiXmlText::TiXmlText           </td>
+          <td>(</td>
+          <td class="paramtype">const char *&nbsp;</td>
+          <td class="paramname"> <em>initValue</em>          </td>
+          <td>&nbsp;)&nbsp;</td>
+          <td width="100%"><code> [inline]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+Constructor for text element. 
+<p>
+By default, it is treated as normal, encoded text. If you want it be output as a CDATA text element, set the parameter _cdata to 'true' 
+</div>
+</div><p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="0cafbf6f236c7f02d12b2bffc2b7976b"></a><!-- doxytag: member="TiXmlText::Print" ref="0cafbf6f236c7f02d12b2bffc2b7976b" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlText::Print           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. 
+<p>
+) Either or both cfile and str can be null.<p>
+This is a formatted print, and will insert tabs and newlines.<p>
+(For an unformatted stream, use the &lt;&lt; operator.) 
+<p>
+Implements <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlText.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlText.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlUnknown-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlUnknown-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlUnknown-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,98 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlUnknown Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#d7122e5135581b3c832a1a3217760a93">Accept</a>(TiXmlVisitor *content) const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#0960bb7428b3f341da46244229604d73">Clone</a>() const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>(const TIXML_STRING &amp;str, TIXML_STRING *out)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1f05828d023150706eeb16d6fb3f6355">FirstChild</a>(const char *value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">FirstChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">FirstChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">FirstChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#ccda2c6b45c25bb5a6f9c3407a644e61">FirstChildElement</a>(const char *_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">FirstChildElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">FirstChildElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">GetUserData</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(TiXmlNode *afterThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>(TiXmlNode *beforeThis, const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>(const TiXmlNode &amp;addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>(const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#dfaef35a076b9343adc1420757376c39">IterateChildren</a>(const char *value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">IterateChildren</a>(const std::string &amp;_value, const TiXmlNode *previous)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">LastChild</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">LastChild</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">LastChild</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">LastChild</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>(TiXmlNode *addThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">NextSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">NextSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">NextSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#071ba77fd7ab79402fa84b7e9b8607b3">NextSiblingElement</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">NextSiblingElement</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">NextSiblingElement</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> enum name</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt;</a>(std::ostream &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">operator&lt;&lt;</a>(std::string &amp;out, const TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator&gt;&gt;</a>(std::istream &amp;in, TiXmlNode &amp;base)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [friend]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#5bdd49327eec1e609b7d22af706b8316">PreviousSibling</a>(const char *) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">PreviousSibling</a>(const std::string &amp;_value) const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">PreviousSibling</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#31ba089a40fb5a1869750fce09b0bacb">Print</a>(FILE *cfile, int depth) const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>(TiXmlNode *removeThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>(TiXmlNode *replaceThis, const TiXmlNode &amp;withThis)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>() const </td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>(bool condense)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline, static]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>(void *user)</td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(const char *_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">SetValue</a>(const std::string &amp;_value)</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">ToComment</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">ToDeclaration</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">ToDocument</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">ToElement</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">ToText</a>()</td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#b0313e5fe77987d746ac1a97a254419d">ToUnknown</a>() const </td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlUnknown.html#67c9fd22940e8c47f706a72cdd2e332c">ToUnknown</a>()</td><td><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a></td><td><a class="el" href="classTiXmlBase.html">TiXmlBase</a></td><td><code> [protected]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>() const </td><td><a class="el" href="classTiXmlNode.html">TiXmlNode</a></td><td><code> [inline]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlUnknown.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlUnknown.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlUnknown.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,103 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlUnknown Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlUnknown Class Reference</h1><!-- doxytag: class="TiXmlUnknown" --><!-- doxytag: inherits="TiXmlNode" -->Any tag that tinyXml doesn't recognize is saved as an unknown.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlUnknown:
+<p><center><img src="classTiXmlUnknown.png" usemap="#TiXmlUnknown_map" border="0" alt=""></center>
+<map name="TiXmlUnknown_map">
+<area href="classTiXmlNode.html" alt="TiXmlNode" shape="rect" coords="0,56,94,80">
+<area href="classTiXmlBase.html" alt="TiXmlBase" shape="rect" coords="0,0,94,24">
+</map>
+<a href="classTiXmlUnknown-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0960bb7428b3f341da46244229604d73"></a><!-- doxytag: member="TiXmlUnknown::Clone" ref="0960bb7428b3f341da46244229604d73" args="() const " -->
+virtual <a class="el" href="classTiXmlNode.html">TiXmlNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#0960bb7428b3f341da46244229604d73">Clone</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this Unknown and returns it. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#31ba089a40fb5a1869750fce09b0bacb">Print</a> (FILE *cfile, int depth) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode.  <a href="#31ba089a40fb5a1869750fce09b0bacb"></a><br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0313e5fe77987d746ac1a97a254419d"></a><!-- doxytag: member="TiXmlUnknown::ToUnknown" ref="b0313e5fe77987d746ac1a97a254419d" args="() const " -->
+virtual const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#b0313e5fe77987d746ac1a97a254419d">ToUnknown</a> () const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67c9fd22940e8c47f706a72cdd2e332c"></a><!-- doxytag: member="TiXmlUnknown::ToUnknown" ref="67c9fd22940e8c47f706a72cdd2e332c" args="()" -->
+virtual <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#67c9fd22940e8c47f706a72cdd2e332c">ToUnknown</a> ()</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast to a more defined type. Will return null not of the requested type. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d7122e5135581b3c832a1a3217760a93"></a><!-- doxytag: member="TiXmlUnknown::Accept" ref="d7122e5135581b3c832a1a3217760a93" args="(TiXmlVisitor *content) const " -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlUnknown.html#d7122e5135581b3c832a1a3217760a93">Accept</a> (<a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> *content) const </td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk the XML tree visiting this node and all of its children. <br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+Any tag that tinyXml doesn't recognize is saved as an unknown. 
+<p>
+It is a tag of text, but should not be modified. It will be written back to the XML, unchanged, when the file is saved.<p>
+DTD tags get thrown into TiXmlUnknowns. 
+<p>
+<hr><h2>Member Function Documentation</h2>
+<a class="anchor" name="31ba089a40fb5a1869750fce09b0bacb"></a><!-- doxytag: member="TiXmlUnknown::Print" ref="31ba089a40fb5a1869750fce09b0bacb" args="(FILE *cfile, int depth) const " -->
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">virtual void TiXmlUnknown::Print           </td>
+          <td>(</td>
+          <td class="paramtype">FILE *&nbsp;</td>
+          <td class="paramname"> <em>cfile</em>, </td>
+        </tr>
+        <tr>
+          <td class="paramkey"></td>
+          <td></td>
+          <td class="paramtype">int&nbsp;</td>
+          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
+        </tr>
+        <tr>
+          <td></td>
+          <td>)</td>
+          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
+        </tr>
+      </table>
+</div>
+<div class="memdoc">
+
+<p>
+All TinyXml classes can print themselves to a filestream or the string class (TiXmlString in non-STL mode, std::string in STL mode. 
+<p>
+) Either or both cfile and str can be null.<p>
+This is a formatted print, and will insert tabs and newlines.<p>
+(For an unformatted stream, use the &lt;&lt; operator.) 
+<p>
+Implements <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a>.
+</div>
+</div><p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlUnknown.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlUnknown.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/classTiXmlVisitor-members.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlVisitor-members.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlVisitor-members.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,34 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Member List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlVisitor Member List</h1>This is the complete list of members for <a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a>, including all inherited members.<p><table>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">Visit</a>(const TiXmlDeclaration &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#399b8ebca5cd14664974a32d2ce029e5">Visit</a>(const TiXmlText &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#53a60e7a528627b31af3161972cc7fa2">Visit</a>(const TiXmlComment &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#7e284d607d275c51dac1adb58159ce28">Visit</a>(const TiXmlUnknown &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a>(const TiXmlDocument &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#f6c6178ffa517bbdba95d70490875fff">VisitEnter</a>(const TiXmlElement &amp;, const TiXmlAttribute *)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#a0ade4f27087447e93974e975c3246ad">VisitExit</a>(const TiXmlDocument &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+  <tr class="memlist"><td><a class="el" href="classTiXmlVisitor.html#ec2b1f8116226d52f3a1b95dafd3a32c">VisitExit</a>(const TiXmlElement &amp;)</td><td><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a></td><td><code> [inline, virtual]</code></td></tr>
+</table><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlVisitor.html
===================================================================
--- dependencies/tinyxml/docs/classTiXmlVisitor.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/classTiXmlVisitor.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,84 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TiXmlVisitor Class Reference</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TiXmlVisitor Class Reference</h1><!-- doxytag: class="TiXmlVisitor" -->If you call the Accept() method, it requires being passed a <a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> class to handle callbacks.  
+<a href="#_details">More...</a>
+<p>
+<code>#include &lt;<a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>&gt;</code>
+<p>
+<p>Inheritance diagram for TiXmlVisitor:
+<p><center><img src="classTiXmlVisitor.png" usemap="#TiXmlVisitor_map" border="0" alt=""></center>
+<map name="TiXmlVisitor_map">
+<area href="classTiXmlPrinter.html" alt="TiXmlPrinter" shape="rect" coords="0,56,81,80">
+</map>
+<a href="classTiXmlVisitor-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
+<tr><td></td></tr>
+<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="07baecb52dd7d8716ae2a48ad0956ee0"></a><!-- doxytag: member="TiXmlVisitor::VisitEnter" ref="07baecb52dd7d8716ae2a48ad0956ee0" args="(const TiXmlDocument &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0ade4f27087447e93974e975c3246ad"></a><!-- doxytag: member="TiXmlVisitor::VisitExit" ref="a0ade4f27087447e93974e975c3246ad" args="(const TiXmlDocument &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#a0ade4f27087447e93974e975c3246ad">VisitExit</a> (const <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a> &amp;)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a document. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6c6178ffa517bbdba95d70490875fff"></a><!-- doxytag: member="TiXmlVisitor::VisitEnter" ref="f6c6178ffa517bbdba95d70490875fff" args="(const TiXmlElement &amp;, const TiXmlAttribute *)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#f6c6178ffa517bbdba95d70490875fff">VisitEnter</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;, const <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> *)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ec2b1f8116226d52f3a1b95dafd3a32c"></a><!-- doxytag: member="TiXmlVisitor::VisitExit" ref="ec2b1f8116226d52f3a1b95dafd3a32c" args="(const TiXmlElement &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#ec2b1f8116226d52f3a1b95dafd3a32c">VisitExit</a> (const <a class="el" href="classTiXmlElement.html">TiXmlElement</a> &amp;)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an element. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fad71c71ce6473fb9b4b64cd92de4a19"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="fad71c71ce6473fb9b4b64cd92de4a19" args="(const TiXmlDeclaration &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">Visit</a> (const <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> &amp;)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a declaration. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="399b8ebca5cd14664974a32d2ce029e5"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="399b8ebca5cd14664974a32d2ce029e5" args="(const TiXmlText &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#399b8ebca5cd14664974a32d2ce029e5">Visit</a> (const <a class="el" href="classTiXmlText.html">TiXmlText</a> &amp;)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a text node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53a60e7a528627b31af3161972cc7fa2"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="53a60e7a528627b31af3161972cc7fa2" args="(const TiXmlComment &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#53a60e7a528627b31af3161972cc7fa2">Visit</a> (const <a class="el" href="classTiXmlComment.html">TiXmlComment</a> &amp;)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit a comment node. <br></td></tr>
+<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e284d607d275c51dac1adb58159ce28"></a><!-- doxytag: member="TiXmlVisitor::Visit" ref="7e284d607d275c51dac1adb58159ce28" args="(const TiXmlUnknown &amp;)" -->
+virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTiXmlVisitor.html#7e284d607d275c51dac1adb58159ce28">Visit</a> (const <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> &amp;)</td></tr>
+
+<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit an unknow node. <br></td></tr>
+</table>
+<hr><a name="_details"></a><h2>Detailed Description</h2>
+If you call the Accept() method, it requires being passed a <a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a> class to handle callbacks. 
+<p>
+For nodes that contain other nodes (Document, Element) you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves are simple called with <a class="el" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">Visit()</a>.<p>
+If you return 'true' from a Visit method, recursive parsing will continue. If you return false, <b>no children of this node or its sibilings</b> will be Visited.<p>
+All flavors of Visit methods have a default implementation that returns 'true' (continue visiting). You need to only override methods that are interesting to you.<p>
+Generally Accept() is called on the <a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>, although all nodes suppert Visiting.<p>
+You should never change the document from a callback.<p>
+<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode::Accept()</a> </dd></dl>
+
+<p>
+<hr>The documentation for this class was generated from the following file:<ul>
+<li><a class="el" href="tinyxml_8h-source.html">tinyxml.h</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/classTiXmlVisitor.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/classTiXmlVisitor.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/deprecated.html
===================================================================
--- dependencies/tinyxml/docs/deprecated.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/deprecated.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,38 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Deprecated List</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<h1><a class="anchor" name="deprecated">Deprecated List</a></h1><a class="anchor" name="_deprecated000002"></a> <dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#cb5fe8388a526289ea65e817a51e05e7">TiXmlHandle::Element</a> () const  </dt>
+<dd>use ToElement. Return the handle as a <a class="el" href="classTiXmlElement.html">TiXmlElement</a>. This may return null. </dd>
+</dl>
+<p>
+<a class="anchor" name="_deprecated000001"></a> <dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#b44b723a8dc9af72838a303c079d0376">TiXmlHandle::Node</a> () const  </dt>
+<dd>use ToNode. Return the handle as a <a class="el" href="classTiXmlNode.html">TiXmlNode</a>. This may return null. </dd>
+</dl>
+<p>
+<a class="anchor" name="_deprecated000003"></a> <dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">TiXmlHandle::Text</a> () const  </dt>
+<dd>use ToText() Return the handle as a <a class="el" href="classTiXmlText.html">TiXmlText</a>. This may return null. </dd>
+</dl>
+<p>
+<a class="anchor" name="_deprecated000004"></a> <dl>
+<dt>Member <a class="el" href="classTiXmlHandle.html#49675b74357ba2aae124657a9a1ef465">TiXmlHandle::Unknown</a> () const  </dt>
+<dd>use ToUnknown() Return the handle as a <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>. This may return null. </dd>
+</dl>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/doxygen.css
===================================================================
--- dependencies/tinyxml/docs/doxygen.css	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/doxygen.css	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,358 @@
+BODY,H1,H2,H3,H4,H5,H6,P,CENTER,TD,TH,UL,DL,DIV {
+	font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+BODY,TD {
+       font-size: 90%;
+}
+H1 {
+	text-align: center;
+       font-size: 160%;
+}
+H2 {
+       font-size: 120%;
+}
+H3 {
+       font-size: 100%;
+}
+CAPTION { font-weight: bold }
+DIV.qindex {
+	width: 100%;
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	padding: 2px;
+	line-height: 140%;
+}
+DIV.nav {
+	width: 100%;
+	background-color: #e8eef2;
+	border: 1px solid #84b0c7;
+	text-align: center;
+	margin: 2px;
+	padding: 2px;
+	line-height: 140%;
+}
+DIV.navtab {
+       background-color: #e8eef2;
+       border: 1px solid #84b0c7;
+       text-align: center;
+       margin: 2px;
+       margin-right: 15px;
+       padding: 2px;
+}
+TD.navtab {
+       font-size: 70%;
+}
+A.qindex {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D;
+}
+A.qindex:visited {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D
+}
+A.qindex:hover {
+	text-decoration: none;
+	background-color: #ddddff;
+}
+A.qindexHL {
+	text-decoration: none;
+	font-weight: bold;
+	background-color: #6666cc;
+	color: #ffffff;
+	border: 1px double #9295C2;
+}
+A.qindexHL:hover {
+	text-decoration: none;
+	background-color: #6666cc;
+	color: #ffffff;
+}
+A.qindexHL:visited { text-decoration: none; background-color: #6666cc; color: #ffffff }
+A.el { text-decoration: none; font-weight: bold }
+A.elRef { font-weight: bold }
+A.code:link { text-decoration: none; font-weight: normal; color: #0000FF}
+A.code:visited { text-decoration: none; font-weight: normal; color: #0000FF}
+A.codeRef:link { font-weight: normal; color: #0000FF}
+A.codeRef:visited { font-weight: normal; color: #0000FF}
+A:hover { text-decoration: none; background-color: #f2f2ff }
+DL.el { margin-left: -1cm }
+.fragment {
+       font-family: monospace, fixed;
+       font-size: 95%;
+}
+PRE.fragment {
+	border: 1px solid #CCCCCC;
+	background-color: #f5f5f5;
+	margin-top: 4px;
+	margin-bottom: 4px;
+	margin-left: 2px;
+	margin-right: 8px;
+	padding-left: 6px;
+	padding-right: 6px;
+	padding-top: 4px;
+	padding-bottom: 4px;
+}
+DIV.ah { background-color: black; font-weight: bold; color: #ffffff; margin-bottom: 3px; margin-top: 3px }
+
+DIV.groupHeader {
+       margin-left: 16px;
+       margin-top: 12px;
+       margin-bottom: 6px;
+       font-weight: bold;
+}
+DIV.groupText { margin-left: 16px; font-style: italic; font-size: 90% }
+BODY {
+	background: white;
+	color: black;
+	margin-right: 20px;
+	margin-left: 20px;
+}
+TD.indexkey {
+	background-color: #e8eef2;
+	font-weight: bold;
+	padding-right  : 10px;
+	padding-top    : 2px;
+	padding-left   : 10px;
+	padding-bottom : 2px;
+	margin-left    : 0px;
+	margin-right   : 0px;
+	margin-top     : 2px;
+	margin-bottom  : 2px;
+	border: 1px solid #CCCCCC;
+}
+TD.indexvalue {
+	background-color: #e8eef2;
+	font-style: italic;
+	padding-right  : 10px;
+	padding-top    : 2px;
+	padding-left   : 10px;
+	padding-bottom : 2px;
+	margin-left    : 0px;
+	margin-right   : 0px;
+	margin-top     : 2px;
+	margin-bottom  : 2px;
+	border: 1px solid #CCCCCC;
+}
+TR.memlist {
+   background-color: #f0f0f0; 
+}
+P.formulaDsp { text-align: center; }
+IMG.formulaDsp { }
+IMG.formulaInl { vertical-align: middle; }
+SPAN.keyword       { color: #008000 }
+SPAN.keywordtype   { color: #604020 }
+SPAN.keywordflow   { color: #e08000 }
+SPAN.comment       { color: #800000 }
+SPAN.preprocessor  { color: #806020 }
+SPAN.stringliteral { color: #002080 }
+SPAN.charliteral   { color: #008080 }
+.mdescLeft {
+       padding: 0px 8px 4px 8px;
+	font-size: 80%;
+	font-style: italic;
+	background-color: #FAFAFA;
+	border-top: 1px none #E0E0E0;
+	border-right: 1px none #E0E0E0;
+	border-bottom: 1px none #E0E0E0;
+	border-left: 1px none #E0E0E0;
+	margin: 0px;
+}
+.mdescRight {
+       padding: 0px 8px 4px 8px;
+	font-size: 80%;
+	font-style: italic;
+	background-color: #FAFAFA;
+	border-top: 1px none #E0E0E0;
+	border-right: 1px none #E0E0E0;
+	border-bottom: 1px none #E0E0E0;
+	border-left: 1px none #E0E0E0;
+	margin: 0px;
+}
+.memItemLeft {
+	padding: 1px 0px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: solid;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memItemRight {
+	padding: 1px 8px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: solid;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memTemplItemLeft {
+	padding: 1px 0px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: none;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memTemplItemRight {
+	padding: 1px 8px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: none;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.memTemplParams {
+	padding: 1px 0px 0px 8px;
+	margin: 4px;
+	border-top-width: 1px;
+	border-right-width: 1px;
+	border-bottom-width: 1px;
+	border-left-width: 1px;
+	border-top-color: #E0E0E0;
+	border-right-color: #E0E0E0;
+	border-bottom-color: #E0E0E0;
+	border-left-color: #E0E0E0;
+	border-top-style: solid;
+	border-right-style: none;
+	border-bottom-style: none;
+	border-left-style: none;
+       color: #606060;
+	background-color: #FAFAFA;
+	font-size: 80%;
+}
+.search     { color: #003399;
+              font-weight: bold;
+}
+FORM.search {
+              margin-bottom: 0px;
+              margin-top: 0px;
+}
+INPUT.search { font-size: 75%;
+               color: #000080;
+               font-weight: normal;
+               background-color: #e8eef2;
+}
+TD.tiny      { font-size: 75%;
+}
+a {
+	color: #1A41A8;
+}
+a:visited {
+	color: #2A3798;
+}
+.dirtab { padding: 4px;
+          border-collapse: collapse;
+          border: 1px solid #84b0c7;
+}
+TH.dirtab { background: #e8eef2;
+            font-weight: bold;
+}
+HR { height: 1px;
+     border: none;
+     border-top: 1px solid black;
+}
+
+/* Style for detailed member documentation */
+.memtemplate {
+  font-size: 80%;
+  color: #606060;
+  font-weight: normal;
+} 
+.memnav { 
+  background-color: #e8eef2;
+  border: 1px solid #84b0c7;
+  text-align: center;
+  margin: 2px;
+  margin-right: 15px;
+  padding: 2px;
+}
+.memitem {
+  padding: 4px;
+  background-color: #eef3f5;
+  border-width: 1px;
+  border-style: solid;
+  border-color: #dedeee;
+  -moz-border-radius: 8px 8px 8px 8px;
+}
+.memname {
+  white-space: nowrap;
+  font-weight: bold;
+}
+.memdoc{
+  padding-left: 10px;
+}
+.memproto {
+  background-color: #d5e1e8;
+  width: 100%;
+  border-width: 1px;
+  border-style: solid;
+  border-color: #84b0c7;
+  font-weight: bold;
+  -moz-border-radius: 8px 8px 8px 8px;
+}
+.paramkey {
+  text-align: right;
+}
+.paramtype {
+  white-space: nowrap;
+}
+.paramname {
+  color: #602020;
+  font-style: italic;
+}
+/* End Styling for detailed member documentation */
+
+/* for the tree view */
+.ftvtree {
+	font-family: sans-serif;
+	margin:0.5em;
+}
+.directory { font-size: 9pt; font-weight: bold; }
+.directory h3 { margin: 0px; margin-top: 1em; font-size: 11pt; }
+.directory > h3 { margin-top: 0; }
+.directory p { margin: 0px; white-space: nowrap; }
+.directory div { display: none; margin: 0px; }
+.directory img { vertical-align: -30%; }
+

Added: dependencies/tinyxml/docs/doxygen.png
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/doxygen.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/files.html
===================================================================
--- dependencies/tinyxml/docs/files.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/files.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,23 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: File Index</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li><a href="annotated.html"><span>Classes</span></a></li>
+    <li id="current"><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<h1>TinyXml File List</h1>Here is a list of all documented files with brief descriptions:<table>
+  <tr><td class="indexkey"><b>tinystr.h</b> <a href="tinystr_8h-source.html">[code]</a></td><td class="indexvalue"></td></tr>
+  <tr><td class="indexkey"><b>tinyxml.h</b> <a href="tinyxml_8h-source.html">[code]</a></td><td class="indexvalue"></td></tr>
+</table>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/functions.html
===================================================================
--- dependencies/tinyxml/docs/functions.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/functions.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,196 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Class Members</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li id="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li id="current"><a href="functions.html"><span>All</span></a></li>
+    <li><a href="functions_func.html"><span>Functions</span></a></li>
+    <li><a href="functions_vars.html"><span>Variables</span></a></li>
+    <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+    <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+  </ul>
+</div>
+<div class="tabs">
+  <ul>
+    <li><a href="#index_a"><span>a</span></a></li>
+    <li><a href="#index_c"><span>c</span></a></li>
+    <li><a href="#index_d"><span>d</span></a></li>
+    <li><a href="#index_e"><span>e</span></a></li>
+    <li><a href="#index_f"><span>f</span></a></li>
+    <li><a href="#index_g"><span>g</span></a></li>
+    <li><a href="#index_i"><span>i</span></a></li>
+    <li><a href="#index_l"><span>l</span></a></li>
+    <li><a href="#index_n"><span>n</span></a></li>
+    <li><a href="#index_o"><span>o</span></a></li>
+    <li><a href="#index_p"><span>p</span></a></li>
+    <li><a href="#index_q"><span>q</span></a></li>
+    <li><a href="#index_r"><span>r</span></a></li>
+    <li><a href="#index_s"><span>s</span></a></li>
+    <li><a href="#index_t"><span>t</span></a></li>
+    <li><a href="#index_u"><span>u</span></a></li>
+    <li><a href="#index_v"><span>v</span></a></li>
+  </ul>
+</div>
+
+<p>
+Here is a list of all documented class members with links to the class documentation for each member:
+<p>
+<h3><a class="anchor" name="index_a">- a -</a></h3><ul>
+<li>Accept()
+: <a class="el" href="classTiXmlDocument.html#a545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>, <a class="el" href="classTiXmlUnknown.html#d7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>, <a class="el" href="classTiXmlDeclaration.html#22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlText.html#8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>, <a class="el" href="classTiXmlComment.html#f3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>, <a class="el" href="classTiXmlElement.html#71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>, <a class="el" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode</a><li>Attribute()
+: <a class="el" href="classTiXmlElement.html#eaff99d4f0ea5b34f7aee202aad457ba">TiXmlElement</a></ul>
+<h3><a class="anchor" name="index_c">- c -</a></h3><ul>
+<li>CDATA()
+: <a class="el" href="classTiXmlText.html#d1a6a6b83fa2271022dd97c072a2b586">TiXmlText</a><li>Child()
+: <a class="el" href="classTiXmlHandle.html#f9cf6a7d08a5da94a8924425ad0cd5ac">TiXmlHandle</a><li>ChildElement()
+: <a class="el" href="classTiXmlHandle.html#8786475b9d1f1518492e3a46704c7ef0">TiXmlHandle</a><li>Clear()
+: <a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">TiXmlNode</a><li>ClearError()
+: <a class="el" href="classTiXmlDocument.html#c66b8c28db86363315712a3574e87c35">TiXmlDocument</a><li>Clone()
+: <a class="el" href="classTiXmlDocument.html#4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>, <a class="el" href="classTiXmlUnknown.html#0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>, <a class="el" href="classTiXmlDeclaration.html#7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlText.html#0c411e93a27537369479d034cc82da3b">TiXmlText</a>, <a class="el" href="classTiXmlComment.html#0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>, <a class="el" href="classTiXmlElement.html#a464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>, <a class="el" href="classTiXmlNode.html#4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a><li>Column()
+: <a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">TiXmlBase</a><li>CStr()
+: <a class="el" href="classTiXmlPrinter.html#859eede9597d3e0355b77757be48735e">TiXmlPrinter</a></ul>
+<h3><a class="anchor" name="index_d">- d -</a></h3><ul>
+<li>DoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#2880ddef53fc7522c99535273954d230">TiXmlAttribute</a></ul>
+<h3><a class="anchor" name="index_e">- e -</a></h3><ul>
+<li>Element()
+: <a class="el" href="classTiXmlHandle.html#cb5fe8388a526289ea65e817a51e05e7">TiXmlHandle</a><li>EncodeString()
+: <a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">TiXmlBase</a><li>Encoding()
+: <a class="el" href="classTiXmlDeclaration.html#5d974231f9e9a2f0542f15f3a46cdb76">TiXmlDeclaration</a><li>Error()
+: <a class="el" href="classTiXmlDocument.html#6dfc01a6e5d58e56acd537dfd3bdeb29">TiXmlDocument</a><li>ErrorCol()
+: <a class="el" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">TiXmlDocument</a><li>ErrorDesc()
+: <a class="el" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">TiXmlDocument</a><li>ErrorId()
+: <a class="el" href="classTiXmlDocument.html#f96fc2f3f9ec6422782bfe916c9e778f">TiXmlDocument</a><li>ErrorRow()
+: <a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">TiXmlDocument</a></ul>
+<h3><a class="anchor" name="index_f">- f -</a></h3><ul>
+<li>FirstAttribute()
+: <a class="el" href="classTiXmlElement.html#516054c9073647d6cb29b6abe9fa0592">TiXmlElement</a><li>FirstChild()
+: <a class="el" href="classTiXmlHandle.html#8c61f64ae9365d89c264f289085541f8">TiXmlHandle</a>, <a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">TiXmlNode</a><li>FirstChildElement()
+: <a class="el" href="classTiXmlHandle.html#f0aea751320f5e430fac6f8fff3b8dd4">TiXmlHandle</a>, <a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_g">- g -</a></h3><ul>
+<li>GetDocument()
+: <a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">TiXmlNode</a><li>GetText()
+: <a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">TiXmlElement</a><li>GetUserData()
+: <a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">TiXmlBase</a></ul>
+<h3><a class="anchor" name="index_i">- i -</a></h3><ul>
+<li>Indent()
+: <a class="el" href="classTiXmlPrinter.html#bb33ec7d4bad6aaeb57f4304394b133d">TiXmlPrinter</a><li>InsertAfterChild()
+: <a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">TiXmlNode</a><li>InsertBeforeChild()
+: <a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">TiXmlNode</a><li>InsertEndChild()
+: <a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">TiXmlNode</a><li>IntValue()
+: <a class="el" href="classTiXmlAttribute.html#a1a20ad59dc7e89a0ab265396360d50f">TiXmlAttribute</a><li>IsWhiteSpaceCondensed()
+: <a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">TiXmlBase</a><li>IterateChildren()
+: <a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_l">- l -</a></h3><ul>
+<li>LastAttribute()
+: <a class="el" href="classTiXmlElement.html#86191b49f9177be132b85b14655f1381">TiXmlElement</a><li>LastChild()
+: <a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">TiXmlNode</a><li>LineBreak()
+: <a class="el" href="classTiXmlPrinter.html#11f1b4804a460b175ec244eb5724d96d">TiXmlPrinter</a><li>LinkEndChild()
+: <a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">TiXmlNode</a><li>LoadFile()
+: <a class="el" href="classTiXmlDocument.html#18ae6ed34fed7991ebc220862dfac884">TiXmlDocument</a></ul>
+<h3><a class="anchor" name="index_n">- n -</a></h3><ul>
+<li>Name()
+: <a class="el" href="classTiXmlAttribute.html#298a57287d305904ba6bd96ae6f78d3d">TiXmlAttribute</a><li>Next()
+: <a class="el" href="classTiXmlAttribute.html#1c78e92e223a40843f644ba48ef69f67">TiXmlAttribute</a><li>NextSibling()
+: <a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">TiXmlNode</a><li>NextSiblingElement()
+: <a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">TiXmlNode</a><li>NoChildren()
+: <a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">TiXmlNode</a><li>Node()
+: <a class="el" href="classTiXmlHandle.html#b44b723a8dc9af72838a303c079d0376">TiXmlHandle</a><li>NodeType
+: <a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_o">- o -</a></h3><ul>
+<li>operator&lt;&lt;
+: <a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">TiXmlNode</a><li>operator&gt;&gt;
+: <a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_p">- p -</a></h3><ul>
+<li>Parent()
+: <a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">TiXmlNode</a><li>Parse()
+: <a class="el" href="classTiXmlDocument.html#17ebabe36926ef398e78dec0d0ad0378">TiXmlDocument</a><li>Previous()
+: <a class="el" href="classTiXmlAttribute.html#6ebbfe333fe76cd834bd6cbcca3130cf">TiXmlAttribute</a><li>PreviousSibling()
+: <a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">TiXmlNode</a><li>Print()
+: <a class="el" href="classTiXmlDocument.html#8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>, <a class="el" href="classTiXmlUnknown.html#31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>, <a class="el" href="classTiXmlDeclaration.html#bf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>, <a class="el" href="classTiXmlText.html#0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>, <a class="el" href="classTiXmlComment.html#6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>, <a class="el" href="classTiXmlElement.html#fbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>, <a class="el" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>, <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a></ul>
+<h3><a class="anchor" name="index_q">- q -</a></h3><ul>
+<li>QueryDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7">TiXmlElement</a><li>QueryDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#c87b2a8489906a5d7aa2875f20be3513">TiXmlAttribute</a><li>QueryFloatAttribute()
+: <a class="el" href="classTiXmlElement.html#a04d3af11601ef5a5f88295203a843be">TiXmlElement</a><li>QueryIntAttribute()
+: <a class="el" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">TiXmlElement</a><li>QueryIntValue()
+: <a class="el" href="classTiXmlAttribute.html#d6c93088ee21af41a107931223339344">TiXmlAttribute</a><li>QueryValueAttribute()
+: <a class="el" href="classTiXmlElement.html#e3b9a03b0a56663a40801c7256683576">TiXmlElement</a></ul>
+<h3><a class="anchor" name="index_r">- r -</a></h3><ul>
+<li>RemoveAttribute()
+: <a class="el" href="classTiXmlElement.html#1afa6aea716511326a608e4c05df4f3a">TiXmlElement</a><li>RemoveChild()
+: <a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">TiXmlNode</a><li>ReplaceChild()
+: <a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">TiXmlNode</a><li>RootElement()
+: <a class="el" href="classTiXmlDocument.html#d09d17927f908f40efb406af2fb873be">TiXmlDocument</a><li>Row()
+: <a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">TiXmlBase</a></ul>
+<h3><a class="anchor" name="index_s">- s -</a></h3><ul>
+<li>SaveFile()
+: <a class="el" href="classTiXmlDocument.html#3d4fae0463f3f03679ba0b7cf6f2df52">TiXmlDocument</a><li>SetAttribute()
+: <a class="el" href="classTiXmlElement.html#ce6f4be75e373726d4774073d666d1a7">TiXmlElement</a><li>SetCDATA()
+: <a class="el" href="classTiXmlText.html#cb17ff7c5d09b2c839393445a3de5ea9">TiXmlText</a><li>SetCondenseWhiteSpace()
+: <a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">TiXmlBase</a><li>SetDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#0d1dd975d75496778177e35abfe0ec0b">TiXmlElement</a><li>SetDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#0316da31373496c4368ad549bf711394">TiXmlAttribute</a><li>SetIndent()
+: <a class="el" href="classTiXmlPrinter.html#213377a4070c7e625bae59716b089e5e">TiXmlPrinter</a><li>SetIntValue()
+: <a class="el" href="classTiXmlAttribute.html#7e065df640116a62ea4f4b7da5449cc8">TiXmlAttribute</a><li>SetLineBreak()
+: <a class="el" href="classTiXmlPrinter.html#4be1e37e69e3858c59635aa947174fe6">TiXmlPrinter</a><li>SetName()
+: <a class="el" href="classTiXmlAttribute.html#b296ff0c9a8c701055cd257a8a976e57">TiXmlAttribute</a><li>SetStreamPrinting()
+: <a class="el" href="classTiXmlPrinter.html#b23a90629e374cb1cadca090468bbd19">TiXmlPrinter</a><li>SetTabSize()
+: <a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument</a><li>SetUserData()
+: <a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">TiXmlBase</a><li>SetValue()
+: <a class="el" href="classTiXmlAttribute.html#b43f67a0cc3ec1d80e62606500f0925f">TiXmlAttribute</a>, <a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">TiXmlNode</a><li>Size()
+: <a class="el" href="classTiXmlPrinter.html#d01375ae9199bd2f48252eaddce3039d">TiXmlPrinter</a><li>Standalone()
+: <a class="el" href="classTiXmlDeclaration.html#9ff06afc033d7ef730ec7c6825b97ad9">TiXmlDeclaration</a><li>Str()
+: <a class="el" href="classTiXmlPrinter.html#3bd4daf44309b41f5813a833caa0d1c9">TiXmlPrinter</a></ul>
+<h3><a class="anchor" name="index_t">- t -</a></h3><ul>
+<li>Text()
+: <a class="el" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">TiXmlHandle</a><li>TiXmlAttribute()
+: <a class="el" href="classTiXmlAttribute.html#759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a><li>TiXmlComment()
+: <a class="el" href="classTiXmlComment.html#37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a><li>TiXmlDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a><li>TiXmlDocument()
+: <a class="el" href="classTiXmlDocument.html#2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a><li>TiXmlElement()
+: <a class="el" href="classTiXmlElement.html#40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a><li>TiXmlHandle()
+: <a class="el" href="classTiXmlHandle.html#236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a><li>TiXmlText()
+: <a class="el" href="classTiXmlText.html#439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a><li>ToComment()
+: <a class="el" href="classTiXmlComment.html#cc7c7e07e13c23f17797d642981511df">TiXmlComment</a>, <a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">TiXmlNode</a><li>ToDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#6bd3d1daddcaeb9543c24bfd090969ce">TiXmlDeclaration</a>, <a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">TiXmlNode</a><li>ToDocument()
+: <a class="el" href="classTiXmlDocument.html#1025d942a1f328fd742d545e37efdd42">TiXmlDocument</a>, <a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">TiXmlNode</a><li>ToElement()
+: <a class="el" href="classTiXmlHandle.html#bc6e7ed383a5fe1e52b0c0004b457b9e">TiXmlHandle</a>, <a class="el" href="classTiXmlElement.html#9def86337ea7a755eb41cac980f60c7a">TiXmlElement</a>, <a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">TiXmlNode</a><li>ToNode()
+: <a class="el" href="classTiXmlHandle.html#f678e5088e83be67baf76f699756f2c3">TiXmlHandle</a><li>ToText()
+: <a class="el" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">TiXmlHandle</a>, <a class="el" href="classTiXmlText.html#e7c3a8fd3e4dbf6c0c4363a943d72f5b">TiXmlText</a>, <a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">TiXmlNode</a><li>ToUnknown()
+: <a class="el" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">TiXmlHandle</a>, <a class="el" href="classTiXmlUnknown.html#67c9fd22940e8c47f706a72cdd2e332c">TiXmlUnknown</a>, <a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">TiXmlNode</a><li>Type()
+: <a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_u">- u -</a></h3><ul>
+<li>Unknown()
+: <a class="el" href="classTiXmlHandle.html#49675b74357ba2aae124657a9a1ef465">TiXmlHandle</a><li>userData
+: <a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">TiXmlBase</a></ul>
+<h3><a class="anchor" name="index_v">- v -</a></h3><ul>
+<li>Value()
+: <a class="el" href="classTiXmlAttribute.html#0f874490eac8ca00ee0070765d0e97e3">TiXmlAttribute</a>, <a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">TiXmlNode</a><li>ValueStr()
+: <a class="el" href="classTiXmlAttribute.html#87705c3ccf9ee9417beb4f7cbacd4d33">TiXmlAttribute</a>, <a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">TiXmlNode</a><li>Version()
+: <a class="el" href="classTiXmlDeclaration.html#02ee557b1a4545c3219ed377c103ec76">TiXmlDeclaration</a><li>Visit()
+: <a class="el" href="classTiXmlPrinter.html#d2dca6dd106e8982fd3c7db1f3330970">TiXmlPrinter</a>, <a class="el" href="classTiXmlVisitor.html#7e284d607d275c51dac1adb58159ce28">TiXmlVisitor</a><li>VisitEnter()
+: <a class="el" href="classTiXmlPrinter.html#0c5e7bf8622838417a0d0bfb8f433854">TiXmlPrinter</a>, <a class="el" href="classTiXmlVisitor.html#f6c6178ffa517bbdba95d70490875fff">TiXmlVisitor</a><li>VisitExit()
+: <a class="el" href="classTiXmlPrinter.html#1853cf2f6e63ad4b4232b4835e0acaf0">TiXmlPrinter</a>, <a class="el" href="classTiXmlVisitor.html#ec2b1f8116226d52f3a1b95dafd3a32c">TiXmlVisitor</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/functions_enum.html
===================================================================
--- dependencies/tinyxml/docs/functions_enum.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/functions_enum.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,39 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Class Members - Enumerations</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li id="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="functions.html"><span>All</span></a></li>
+    <li><a href="functions_func.html"><span>Functions</span></a></li>
+    <li><a href="functions_vars.html"><span>Variables</span></a></li>
+    <li id="current"><a href="functions_enum.html"><span>Enumerations</span></a></li>
+    <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+  </ul>
+</div>
+&nbsp;
+<p>
+<ul>
+<li>NodeType
+: <a class="el" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">TiXmlNode</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/functions_func.html
===================================================================
--- dependencies/tinyxml/docs/functions_func.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/functions_func.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,189 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Class Members - Functions</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li id="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="functions.html"><span>All</span></a></li>
+    <li id="current"><a href="functions_func.html"><span>Functions</span></a></li>
+    <li><a href="functions_vars.html"><span>Variables</span></a></li>
+    <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+    <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+  </ul>
+</div>
+<div class="tabs">
+  <ul>
+    <li><a href="#index_a"><span>a</span></a></li>
+    <li><a href="#index_c"><span>c</span></a></li>
+    <li><a href="#index_d"><span>d</span></a></li>
+    <li><a href="#index_e"><span>e</span></a></li>
+    <li><a href="#index_f"><span>f</span></a></li>
+    <li><a href="#index_g"><span>g</span></a></li>
+    <li><a href="#index_i"><span>i</span></a></li>
+    <li><a href="#index_l"><span>l</span></a></li>
+    <li><a href="#index_n"><span>n</span></a></li>
+    <li><a href="#index_p"><span>p</span></a></li>
+    <li><a href="#index_q"><span>q</span></a></li>
+    <li><a href="#index_r"><span>r</span></a></li>
+    <li><a href="#index_s"><span>s</span></a></li>
+    <li><a href="#index_t"><span>t</span></a></li>
+    <li><a href="#index_u"><span>u</span></a></li>
+    <li><a href="#index_v"><span>v</span></a></li>
+  </ul>
+</div>
+
+<p>
+&nbsp;
+<p>
+<h3><a class="anchor" name="index_a">- a -</a></h3><ul>
+<li>Accept()
+: <a class="el" href="classTiXmlDocument.html#a545aae325d9752ad64120bc4ecf939a">TiXmlDocument</a>, <a class="el" href="classTiXmlUnknown.html#d7122e5135581b3c832a1a3217760a93">TiXmlUnknown</a>, <a class="el" href="classTiXmlDeclaration.html#22315a535983b86535cdba3458669e3e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlText.html#8483d4415ce9de6c4fa8f63d067d5de6">TiXmlText</a>, <a class="el" href="classTiXmlComment.html#f3ac1b99fbbe9ea4fb6e14146156e43e">TiXmlComment</a>, <a class="el" href="classTiXmlElement.html#71a81b2afb0d42be1543d1c404dee6f5">TiXmlElement</a>, <a class="el" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">TiXmlNode</a><li>Attribute()
+: <a class="el" href="classTiXmlElement.html#eaff99d4f0ea5b34f7aee202aad457ba">TiXmlElement</a></ul>
+<h3><a class="anchor" name="index_c">- c -</a></h3><ul>
+<li>CDATA()
+: <a class="el" href="classTiXmlText.html#d1a6a6b83fa2271022dd97c072a2b586">TiXmlText</a><li>Child()
+: <a class="el" href="classTiXmlHandle.html#f9cf6a7d08a5da94a8924425ad0cd5ac">TiXmlHandle</a><li>ChildElement()
+: <a class="el" href="classTiXmlHandle.html#8786475b9d1f1518492e3a46704c7ef0">TiXmlHandle</a><li>Clear()
+: <a class="el" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">TiXmlNode</a><li>ClearError()
+: <a class="el" href="classTiXmlDocument.html#c66b8c28db86363315712a3574e87c35">TiXmlDocument</a><li>Clone()
+: <a class="el" href="classTiXmlDocument.html#4968661cab4a1f44a23329c6f8db1907">TiXmlDocument</a>, <a class="el" href="classTiXmlUnknown.html#0960bb7428b3f341da46244229604d73">TiXmlUnknown</a>, <a class="el" href="classTiXmlDeclaration.html#7cf459186040141cda7a180a6585ce2e">TiXmlDeclaration</a>, <a class="el" href="classTiXmlText.html#0c411e93a27537369479d034cc82da3b">TiXmlText</a>, <a class="el" href="classTiXmlComment.html#0d6662bdc52488b9e12b3c7a0453d028">TiXmlComment</a>, <a class="el" href="classTiXmlElement.html#a464535ea1994db337cb6a8ce4b588b5">TiXmlElement</a>, <a class="el" href="classTiXmlNode.html#4508cc3a2d7a98e96a54cc09c37a78a4">TiXmlNode</a><li>Column()
+: <a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">TiXmlBase</a><li>CStr()
+: <a class="el" href="classTiXmlPrinter.html#859eede9597d3e0355b77757be48735e">TiXmlPrinter</a></ul>
+<h3><a class="anchor" name="index_d">- d -</a></h3><ul>
+<li>DoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#2880ddef53fc7522c99535273954d230">TiXmlAttribute</a></ul>
+<h3><a class="anchor" name="index_e">- e -</a></h3><ul>
+<li>Element()
+: <a class="el" href="classTiXmlHandle.html#cb5fe8388a526289ea65e817a51e05e7">TiXmlHandle</a><li>EncodeString()
+: <a class="el" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">TiXmlBase</a><li>Encoding()
+: <a class="el" href="classTiXmlDeclaration.html#5d974231f9e9a2f0542f15f3a46cdb76">TiXmlDeclaration</a><li>Error()
+: <a class="el" href="classTiXmlDocument.html#6dfc01a6e5d58e56acd537dfd3bdeb29">TiXmlDocument</a><li>ErrorCol()
+: <a class="el" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">TiXmlDocument</a><li>ErrorDesc()
+: <a class="el" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">TiXmlDocument</a><li>ErrorId()
+: <a class="el" href="classTiXmlDocument.html#f96fc2f3f9ec6422782bfe916c9e778f">TiXmlDocument</a><li>ErrorRow()
+: <a class="el" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">TiXmlDocument</a></ul>
+<h3><a class="anchor" name="index_f">- f -</a></h3><ul>
+<li>FirstAttribute()
+: <a class="el" href="classTiXmlElement.html#516054c9073647d6cb29b6abe9fa0592">TiXmlElement</a><li>FirstChild()
+: <a class="el" href="classTiXmlHandle.html#8c61f64ae9365d89c264f289085541f8">TiXmlHandle</a>, <a class="el" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">TiXmlNode</a><li>FirstChildElement()
+: <a class="el" href="classTiXmlHandle.html#f0aea751320f5e430fac6f8fff3b8dd4">TiXmlHandle</a>, <a class="el" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_g">- g -</a></h3><ul>
+<li>GetDocument()
+: <a class="el" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">TiXmlNode</a><li>GetText()
+: <a class="el" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">TiXmlElement</a><li>GetUserData()
+: <a class="el" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">TiXmlBase</a></ul>
+<h3><a class="anchor" name="index_i">- i -</a></h3><ul>
+<li>Indent()
+: <a class="el" href="classTiXmlPrinter.html#bb33ec7d4bad6aaeb57f4304394b133d">TiXmlPrinter</a><li>InsertAfterChild()
+: <a class="el" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">TiXmlNode</a><li>InsertBeforeChild()
+: <a class="el" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">TiXmlNode</a><li>InsertEndChild()
+: <a class="el" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">TiXmlNode</a><li>IntValue()
+: <a class="el" href="classTiXmlAttribute.html#a1a20ad59dc7e89a0ab265396360d50f">TiXmlAttribute</a><li>IsWhiteSpaceCondensed()
+: <a class="el" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">TiXmlBase</a><li>IterateChildren()
+: <a class="el" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_l">- l -</a></h3><ul>
+<li>LastAttribute()
+: <a class="el" href="classTiXmlElement.html#86191b49f9177be132b85b14655f1381">TiXmlElement</a><li>LastChild()
+: <a class="el" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">TiXmlNode</a><li>LineBreak()
+: <a class="el" href="classTiXmlPrinter.html#11f1b4804a460b175ec244eb5724d96d">TiXmlPrinter</a><li>LinkEndChild()
+: <a class="el" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">TiXmlNode</a><li>LoadFile()
+: <a class="el" href="classTiXmlDocument.html#18ae6ed34fed7991ebc220862dfac884">TiXmlDocument</a></ul>
+<h3><a class="anchor" name="index_n">- n -</a></h3><ul>
+<li>Name()
+: <a class="el" href="classTiXmlAttribute.html#298a57287d305904ba6bd96ae6f78d3d">TiXmlAttribute</a><li>Next()
+: <a class="el" href="classTiXmlAttribute.html#1c78e92e223a40843f644ba48ef69f67">TiXmlAttribute</a><li>NextSibling()
+: <a class="el" href="classTiXmlNode.html#2e61c0b89a77e36a0e8c60490003cb46">TiXmlNode</a><li>NextSiblingElement()
+: <a class="el" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">TiXmlNode</a><li>NoChildren()
+: <a class="el" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">TiXmlNode</a><li>Node()
+: <a class="el" href="classTiXmlHandle.html#b44b723a8dc9af72838a303c079d0376">TiXmlHandle</a></ul>
+<h3><a class="anchor" name="index_p">- p -</a></h3><ul>
+<li>Parent()
+: <a class="el" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">TiXmlNode</a><li>Parse()
+: <a class="el" href="classTiXmlDocument.html#17ebabe36926ef398e78dec0d0ad0378">TiXmlDocument</a><li>Previous()
+: <a class="el" href="classTiXmlAttribute.html#6ebbfe333fe76cd834bd6cbcca3130cf">TiXmlAttribute</a><li>PreviousSibling()
+: <a class="el" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">TiXmlNode</a><li>Print()
+: <a class="el" href="classTiXmlDocument.html#8701fda1fa31b25abbc9c0df42da10e8">TiXmlDocument</a>, <a class="el" href="classTiXmlUnknown.html#31ba089a40fb5a1869750fce09b0bacb">TiXmlUnknown</a>, <a class="el" href="classTiXmlDeclaration.html#bf6303db4bd05b5be554036817ff1cb4">TiXmlDeclaration</a>, <a class="el" href="classTiXmlText.html#0cafbf6f236c7f02d12b2bffc2b7976b">TiXmlText</a>, <a class="el" href="classTiXmlComment.html#6b316527aaa8da0370cd68c22a5a0f5f">TiXmlComment</a>, <a class="el" href="classTiXmlElement.html#fbf52736e70fc91ec9d760721d6f4fd2">TiXmlElement</a>, <a class="el" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">TiXmlAttribute</a>, <a class="el" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">TiXmlBase</a></ul>
+<h3><a class="anchor" name="index_q">- q -</a></h3><ul>
+<li>QueryDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7">TiXmlElement</a><li>QueryDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#c87b2a8489906a5d7aa2875f20be3513">TiXmlAttribute</a><li>QueryFloatAttribute()
+: <a class="el" href="classTiXmlElement.html#a04d3af11601ef5a5f88295203a843be">TiXmlElement</a><li>QueryIntAttribute()
+: <a class="el" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">TiXmlElement</a><li>QueryIntValue()
+: <a class="el" href="classTiXmlAttribute.html#d6c93088ee21af41a107931223339344">TiXmlAttribute</a><li>QueryValueAttribute()
+: <a class="el" href="classTiXmlElement.html#e3b9a03b0a56663a40801c7256683576">TiXmlElement</a></ul>
+<h3><a class="anchor" name="index_r">- r -</a></h3><ul>
+<li>RemoveAttribute()
+: <a class="el" href="classTiXmlElement.html#1afa6aea716511326a608e4c05df4f3a">TiXmlElement</a><li>RemoveChild()
+: <a class="el" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">TiXmlNode</a><li>ReplaceChild()
+: <a class="el" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">TiXmlNode</a><li>RootElement()
+: <a class="el" href="classTiXmlDocument.html#d09d17927f908f40efb406af2fb873be">TiXmlDocument</a><li>Row()
+: <a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">TiXmlBase</a></ul>
+<h3><a class="anchor" name="index_s">- s -</a></h3><ul>
+<li>SaveFile()
+: <a class="el" href="classTiXmlDocument.html#3d4fae0463f3f03679ba0b7cf6f2df52">TiXmlDocument</a><li>SetAttribute()
+: <a class="el" href="classTiXmlElement.html#ce6f4be75e373726d4774073d666d1a7">TiXmlElement</a><li>SetCDATA()
+: <a class="el" href="classTiXmlText.html#cb17ff7c5d09b2c839393445a3de5ea9">TiXmlText</a><li>SetCondenseWhiteSpace()
+: <a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">TiXmlBase</a><li>SetDoubleAttribute()
+: <a class="el" href="classTiXmlElement.html#0d1dd975d75496778177e35abfe0ec0b">TiXmlElement</a><li>SetDoubleValue()
+: <a class="el" href="classTiXmlAttribute.html#0316da31373496c4368ad549bf711394">TiXmlAttribute</a><li>SetIndent()
+: <a class="el" href="classTiXmlPrinter.html#213377a4070c7e625bae59716b089e5e">TiXmlPrinter</a><li>SetIntValue()
+: <a class="el" href="classTiXmlAttribute.html#7e065df640116a62ea4f4b7da5449cc8">TiXmlAttribute</a><li>SetLineBreak()
+: <a class="el" href="classTiXmlPrinter.html#4be1e37e69e3858c59635aa947174fe6">TiXmlPrinter</a><li>SetName()
+: <a class="el" href="classTiXmlAttribute.html#b296ff0c9a8c701055cd257a8a976e57">TiXmlAttribute</a><li>SetStreamPrinting()
+: <a class="el" href="classTiXmlPrinter.html#b23a90629e374cb1cadca090468bbd19">TiXmlPrinter</a><li>SetTabSize()
+: <a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument</a><li>SetUserData()
+: <a class="el" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">TiXmlBase</a><li>SetValue()
+: <a class="el" href="classTiXmlAttribute.html#b43f67a0cc3ec1d80e62606500f0925f">TiXmlAttribute</a>, <a class="el" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">TiXmlNode</a><li>Size()
+: <a class="el" href="classTiXmlPrinter.html#d01375ae9199bd2f48252eaddce3039d">TiXmlPrinter</a><li>Standalone()
+: <a class="el" href="classTiXmlDeclaration.html#9ff06afc033d7ef730ec7c6825b97ad9">TiXmlDeclaration</a><li>Str()
+: <a class="el" href="classTiXmlPrinter.html#3bd4daf44309b41f5813a833caa0d1c9">TiXmlPrinter</a></ul>
+<h3><a class="anchor" name="index_t">- t -</a></h3><ul>
+<li>Text()
+: <a class="el" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">TiXmlHandle</a><li>TiXmlAttribute()
+: <a class="el" href="classTiXmlAttribute.html#759d0b76fb8fcf765ecab243bc14f05e">TiXmlAttribute</a><li>TiXmlComment()
+: <a class="el" href="classTiXmlComment.html#37e7802ef17bc03ebe5ae79bf0713d47">TiXmlComment</a><li>TiXmlDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#3b618d1c30c25e4b7a71f31a595ee298">TiXmlDeclaration</a><li>TiXmlDocument()
+: <a class="el" href="classTiXmlDocument.html#2c6e58fb99bfa76cc613f16840022225">TiXmlDocument</a><li>TiXmlElement()
+: <a class="el" href="classTiXmlElement.html#40fc2e3c1a955e2f78e1a32350d180e7">TiXmlElement</a><li>TiXmlHandle()
+: <a class="el" href="classTiXmlHandle.html#236d7855e1e56ccc7b980630c48c7fd7">TiXmlHandle</a><li>TiXmlText()
+: <a class="el" href="classTiXmlText.html#439792f6183a3d3fb6f2bc2b16fa5691">TiXmlText</a><li>ToComment()
+: <a class="el" href="classTiXmlComment.html#cc7c7e07e13c23f17797d642981511df">TiXmlComment</a>, <a class="el" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">TiXmlNode</a><li>ToDeclaration()
+: <a class="el" href="classTiXmlDeclaration.html#6bd3d1daddcaeb9543c24bfd090969ce">TiXmlDeclaration</a>, <a class="el" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">TiXmlNode</a><li>ToDocument()
+: <a class="el" href="classTiXmlDocument.html#1025d942a1f328fd742d545e37efdd42">TiXmlDocument</a>, <a class="el" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">TiXmlNode</a><li>ToElement()
+: <a class="el" href="classTiXmlHandle.html#bc6e7ed383a5fe1e52b0c0004b457b9e">TiXmlHandle</a>, <a class="el" href="classTiXmlElement.html#9def86337ea7a755eb41cac980f60c7a">TiXmlElement</a>, <a class="el" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">TiXmlNode</a><li>ToNode()
+: <a class="el" href="classTiXmlHandle.html#f678e5088e83be67baf76f699756f2c3">TiXmlHandle</a><li>ToText()
+: <a class="el" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">TiXmlHandle</a>, <a class="el" href="classTiXmlText.html#e7c3a8fd3e4dbf6c0c4363a943d72f5b">TiXmlText</a>, <a class="el" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">TiXmlNode</a><li>ToUnknown()
+: <a class="el" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">TiXmlHandle</a>, <a class="el" href="classTiXmlUnknown.html#67c9fd22940e8c47f706a72cdd2e332c">TiXmlUnknown</a>, <a class="el" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">TiXmlNode</a><li>Type()
+: <a class="el" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">TiXmlNode</a></ul>
+<h3><a class="anchor" name="index_u">- u -</a></h3><ul>
+<li>Unknown()
+: <a class="el" href="classTiXmlHandle.html#49675b74357ba2aae124657a9a1ef465">TiXmlHandle</a></ul>
+<h3><a class="anchor" name="index_v">- v -</a></h3><ul>
+<li>Value()
+: <a class="el" href="classTiXmlAttribute.html#0f874490eac8ca00ee0070765d0e97e3">TiXmlAttribute</a>, <a class="el" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">TiXmlNode</a><li>ValueStr()
+: <a class="el" href="classTiXmlAttribute.html#87705c3ccf9ee9417beb4f7cbacd4d33">TiXmlAttribute</a>, <a class="el" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">TiXmlNode</a><li>Version()
+: <a class="el" href="classTiXmlDeclaration.html#02ee557b1a4545c3219ed377c103ec76">TiXmlDeclaration</a><li>Visit()
+: <a class="el" href="classTiXmlPrinter.html#d2dca6dd106e8982fd3c7db1f3330970">TiXmlPrinter</a>, <a class="el" href="classTiXmlVisitor.html#7e284d607d275c51dac1adb58159ce28">TiXmlVisitor</a><li>VisitEnter()
+: <a class="el" href="classTiXmlPrinter.html#0c5e7bf8622838417a0d0bfb8f433854">TiXmlPrinter</a>, <a class="el" href="classTiXmlVisitor.html#f6c6178ffa517bbdba95d70490875fff">TiXmlVisitor</a><li>VisitExit()
+: <a class="el" href="classTiXmlPrinter.html#1853cf2f6e63ad4b4232b4835e0acaf0">TiXmlPrinter</a>, <a class="el" href="classTiXmlVisitor.html#ec2b1f8116226d52f3a1b95dafd3a32c">TiXmlVisitor</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/functions_rela.html
===================================================================
--- dependencies/tinyxml/docs/functions_rela.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/functions_rela.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,40 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Class Members - Related Functions</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li id="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="functions.html"><span>All</span></a></li>
+    <li><a href="functions_func.html"><span>Functions</span></a></li>
+    <li><a href="functions_vars.html"><span>Variables</span></a></li>
+    <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+    <li id="current"><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+  </ul>
+</div>
+&nbsp;
+<p>
+<ul>
+<li>operator&lt;&lt;
+: <a class="el" href="classTiXmlNode.html#52ef17e7080df2490cf87bde380685ab">TiXmlNode</a><li>operator&gt;&gt;
+: <a class="el" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">TiXmlNode</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/functions_vars.html
===================================================================
--- dependencies/tinyxml/docs/functions_vars.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/functions_vars.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,39 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Class Members - Variables</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li id="current"><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="functions.html"><span>All</span></a></li>
+    <li><a href="functions_func.html"><span>Functions</span></a></li>
+    <li id="current"><a href="functions_vars.html"><span>Variables</span></a></li>
+    <li><a href="functions_enum.html"><span>Enumerations</span></a></li>
+    <li><a href="functions_rela.html"><span>Related&nbsp;Functions</span></a></li>
+  </ul>
+</div>
+&nbsp;
+<p>
+<ul>
+<li>userData
+: <a class="el" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">TiXmlBase</a></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/hierarchy.html
===================================================================
--- dependencies/tinyxml/docs/hierarchy.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/hierarchy.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,45 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Hierarchical Index</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="tabs">
+  <ul>
+    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
+    <li id="current"><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
+    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
+  </ul></div>
+<h1>TinyXml Class Hierarchy</h1>This inheritance list is sorted roughly, but not completely, alphabetically:<ul>
+<li><a class="el" href="classTiXmlBase.html">TiXmlBase</a>
+<ul>
+<li><a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a>
+<li><a class="el" href="classTiXmlNode.html">TiXmlNode</a>
+<ul>
+<li><a class="el" href="classTiXmlComment.html">TiXmlComment</a>
+<li><a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>
+<li><a class="el" href="classTiXmlDocument.html">TiXmlDocument</a>
+<li><a class="el" href="classTiXmlElement.html">TiXmlElement</a>
+<li><a class="el" href="classTiXmlText.html">TiXmlText</a>
+<li><a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a>
+</ul>
+</ul>
+<li><a class="el" href="classTiXmlHandle.html">TiXmlHandle</a>
+<li><a class="el" href="classTiXmlVisitor.html">TiXmlVisitor</a>
+<ul>
+<li><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a>
+</ul>
+</ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/index.html
===================================================================
--- dependencies/tinyxml/docs/index.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/index.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,275 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Main Page</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<h1>TinyXml Documentation</h1>
+<p>
+<h3 align="center">2.5.3 </h3><h1>TinyXML </h1>
+<p>
+TinyXML is a simple, small, C++ XML parser that can be easily integrated into other programs.<p>
+<h2>What it does. </h2>
+<p>
+In brief, TinyXML parses an XML document, and builds from that a Document Object Model (DOM) that can be read, modified, and saved.<p>
+XML stands for "eXtensible Markup Language." It allows you to create your own document markups. Where HTML does a very good job of marking documents for browsers, XML allows you to define any kind of document markup, for example a document that describes a "to do" list for an organizer application. XML is a very structured and convenient format. All those random file formats created to store application data can all be replaced with XML. One parser for everything.<p>
+The best place for the complete, correct, and quite frankly hard to read spec is at <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">http://www.w3.org/TR/2004/REC-xml-20040204/</a>. An intro to XML (that I really like) can be found at <a href="http://skew.org/xml/tutorial/">http://skew.org/xml/tutorial</a>.<p>
+There are different ways to access and interact with XML data. TinyXML uses a Document Object Model (DOM), meaning the XML data is parsed into a C++ objects that can be browsed and manipulated, and then written to disk or another output stream. You can also construct an XML document from scratch with C++ objects and write this to disk or another output stream.<p>
+TinyXML is designed to be easy and fast to learn. It is two headers and four cpp files. Simply add these to your project and off you go. There is an example file - xmltest.cpp - to get you started.<p>
+TinyXML is released under the ZLib license, so you can use it in open source or commercial code. The details of the license are at the top of every source file.<p>
+TinyXML attempts to be a flexible parser, but with truly correct and compliant XML output. TinyXML should compile on any reasonably C++ compliant system. It does not rely on exceptions or RTTI. It can be compiled with or without STL support. TinyXML fully supports the UTF-8 encoding, and the first 64k character entities.<p>
+<h2>What it doesn't do. </h2>
+<p>
+TinyXML doesn't parse or use DTDs (Document Type Definitions) or XSLs (eXtensible Stylesheet Language.) There are other parsers out there (check out www.sourceforge.org, search for XML) that are much more fully featured. But they are also much bigger, take longer to set up in your project, have a higher learning curve, and often have a more restrictive license. If you are working with browsers or have more complete XML needs, TinyXML is not the parser for you.<p>
+The following DTD syntax will not parse at this time in TinyXML:<p>
+<div class="fragment"><pre class="fragment">	&lt;!DOCTYPE Archiv [
+	 &lt;!ELEMENT Comment (#PCDATA)&gt;
+	]&gt;
+</pre></div><p>
+because TinyXML sees this as a !DOCTYPE node with an illegally embedded !ELEMENT node. This may be addressed in the future.<p>
+<h2>Tutorials. </h2>
+<p>
+For the impatient, here is a tutorial to get you going. A great way to get started, but it is worth your time to read this (very short) manual completely.<p>
+<ul>
+<li><a class="el" href="tutorial0.html">TinyXML Tutorial</a></li></ul>
+<p>
+<h2>Code Status. </h2>
+<p>
+TinyXML is mature, tested code. It is very stable. If you find bugs, please file a bug report on the sourceforge web site (www.sourceforge.net/projects/tinyxml). We'll get them straightened out as soon as possible.<p>
+There are some areas of improvement; please check sourceforge if you are interested in working on TinyXML.<p>
+<h2>Related Projects </h2>
+<p>
+TinyXML projects you may find useful! (Descriptions provided by the projects.)<p>
+<ul>
+<li>
+<b>TinyXPath</b> (<a href="http://tinyxpath.sourceforge.net">http://tinyxpath.sourceforge.net</a>). TinyXPath is a small footprint XPath syntax decoder, written in C++. </li>
+<li>
+<b>TinyXML++</b> (<a href="http://code.google.com/p/ticpp/">http://code.google.com/p/ticpp/</a>). TinyXML++ is a completely new interface to TinyXML that uses MANY of the C++ strengths. Templates, exceptions, and much better error handling. </li>
+</ul>
+<p>
+<h2>Features </h2>
+<p>
+<h3>Using STL </h3>
+<p>
+TinyXML can be compiled to use or not use STL. When using STL, TinyXML uses the std::string class, and fully supports std::istream, std::ostream, operator&lt;&lt;, and operator&gt;&gt;. Many API methods have both 'const char*' and 'const std::string&amp;' forms.<p>
+When STL support is compiled out, no STL files are included whatsoever. All the string classes are implemented by TinyXML itself. API methods all use the 'const char*' form for input.<p>
+Use the compile time define:<p>
+TIXML_USE_STL<p>
+to compile one version or the other. This can be passed by the compiler, or set as the first line of "tinyxml.h".<p>
+Note: If compiling the test code in Linux, setting the environment variable TINYXML_USE_STL=YES/NO will control STL compilation. In the Windows project file, STL and non STL targets are provided. In your project, It's probably easiest to add the line "#define TIXML_USE_STL" as the first line of <a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>.<p>
+<h3>UTF-8 </h3>
+<p>
+TinyXML supports UTF-8 allowing to manipulate XML files in any language. TinyXML also supports "legacy mode" - the encoding used before UTF-8 support and probably best described as "extended ascii".<p>
+Normally, TinyXML will try to detect the correct encoding and use it. However, by setting the value of TIXML_DEFAULT_ENCODING in the header file, TinyXML can be forced to always use one encoding.<p>
+TinyXML will assume Legacy Mode until one of the following occurs: <ol>
+<li>
+If the non-standard but common "UTF-8 lead bytes" (0xef 0xbb 0xbf) begin the file or data stream, TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has an encoding="UTF-8", then TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has no encoding specified, then TinyXML will read it as UTF-8.  </li>
+<li>
+If the declaration tag is read, and it has an encoding="something else", then TinyXML will read it as Legacy Mode. In legacy mode, TinyXML will work as it did before. It's not clear what that mode does exactly, but old content should keep working. </li>
+<li>
+Until one of the above criteria is met, TinyXML runs in Legacy Mode. </li>
+</ol>
+<p>
+What happens if the encoding is incorrectly set or detected? TinyXML will try to read and pass through text seen as improperly encoded. You may get some strange results or mangled characters. You may want to force TinyXML to the correct mode.<p>
+You may force TinyXML to Legacy Mode by using LoadFile( TIXML_ENCODING_LEGACY ) or LoadFile( filename, TIXML_ENCODING_LEGACY ). You may force it to use legacy mode all the time by setting TIXML_DEFAULT_ENCODING = TIXML_ENCODING_LEGACY. Likewise, you may force it to TIXML_ENCODING_UTF8 with the same technique.<p>
+For English users, using English XML, UTF-8 is the same as low-ASCII. You don't need to be aware of UTF-8 or change your code in any way. You can think of UTF-8 as a "superset" of ASCII.<p>
+UTF-8 is not a double byte format - but it is a standard encoding of Unicode! TinyXML does not use or directly support wchar, TCHAR, or Microsoft's _UNICODE at this time. It is common to see the term "Unicode" improperly refer to UTF-16, a wide byte encoding of unicode. This is a source of confusion.<p>
+For "high-ascii" languages - everything not English, pretty much - TinyXML can handle all languages, at the same time, as long as the XML is encoded in UTF-8. That can be a little tricky, older programs and operating systems tend to use the "default" or "traditional" code page. Many apps (and almost all modern ones) can output UTF-8, but older or stubborn (or just broken) ones still output text in the default code page.<p>
+For example, Japanese systems traditionally use SHIFT-JIS encoding. Text encoded as SHIFT-JIS can not be read by TinyXML. A good text editor can import SHIFT-JIS and then save as UTF-8.<p>
+The <a href="http://skew.org/xml/tutorial/">Skew.org link</a> does a great job covering the encoding issue.<p>
+The test file "utf8test.xml" is an XML containing English, Spanish, Russian, and Simplified Chinese. (Hopefully they are translated correctly). The file "utf8test.gif" is a screen capture of the XML file, rendered in IE. Note that if you don't have the correct fonts (Simplified Chinese or Russian) on your system, you won't see output that matches the GIF file even if you can parse it correctly. Also note that (at least on my Windows machine) console output is in a Western code page, so that Print() or printf() cannot correctly display the file. This is not a bug in TinyXML - just an OS issue. No data is lost or destroyed by TinyXML. The console just doesn't render UTF-8.<p>
+<h3>Entities </h3>
+<p>
+TinyXML recognizes the pre-defined "character entities", meaning special characters. Namely:<p>
+<div class="fragment"><pre class="fragment">	&amp;amp;	&amp;
+	&amp;lt;	&lt;
+	&amp;gt;	&gt;
+	&amp;quot;	"
+	&amp;apos;	'
+</pre></div><p>
+These are recognized when the XML document is read, and translated to there UTF-8 equivalents. For instance, text with the XML of:<p>
+<div class="fragment"><pre class="fragment">	Far &amp;amp; Away
+</pre></div><p>
+will have the Value() of "Far &amp; Away" when queried from the <a class="el" href="classTiXmlText.html">TiXmlText</a> object, and will be written back to the XML stream/file as an ampersand. Older versions of TinyXML "preserved" character entities, but the newer versions will translate them into characters.<p>
+Additionally, any character can be specified by its Unicode code point: The syntax "&amp;#xA0;" or "&amp;#160;" are both to the non-breaking space characher.<p>
+<h3>Printing </h3>
+<p>
+TinyXML can print output in several different ways that all have strengths and limitations.<p>
+<ul>
+<li>Print( FILE* ). Output to a std-C stream, which includes all C files as well as stdout.<ul>
+<li>"Pretty prints", but you don't have control over printing options.</li><li>The output is streamed directly to the FILE object, so there is no memory overhead in the TinyXML code.</li><li>used by Print() and SaveFile()</li></ul>
+</li></ul>
+<p>
+<ul>
+<li>operator&lt;&lt;. Output to a c++ stream.<ul>
+<li>Integrates with standart C++ iostreams.</li><li>Outputs in "network printing" mode without line breaks. Good for network transmission and moving XML between C++ objects, but hard for a human to read.</li></ul>
+</li></ul>
+<p>
+<ul>
+<li><a class="el" href="classTiXmlPrinter.html">TiXmlPrinter</a>. Output to a std::string or memory buffer.<ul>
+<li>API is less concise</li><li>Future printing options will be put here.</li><li>Printing may change slightly in future versions as it is refined and expanded.</li></ul>
+</li></ul>
+<p>
+<h3>Streams </h3>
+<p>
+With TIXML_USE_STL on TinyXML supports C++ streams (operator &lt;&lt;,&gt;&gt;) streams as well as C (FILE*) streams. There are some differences that you may need to be aware of.<p>
+C style output:<ul>
+<li>based on FILE*</li><li>the Print() and SaveFile() methods</li></ul>
+<p>
+Generates formatted output, with plenty of white space, intended to be as human-readable as possible. They are very fast, and tolerant of ill formed XML documents. For example, an XML document that contains 2 root elements and 2 declarations, will still print.<p>
+C style input:<ul>
+<li>based on FILE*</li><li>the Parse() and LoadFile() methods</li></ul>
+<p>
+A fast, tolerant read. Use whenever you don't need the C++ streams.<p>
+C++ style output:<ul>
+<li>based on std::ostream</li><li>operator&lt;&lt;</li></ul>
+<p>
+Generates condensed output, intended for network transmission rather than readability. Depending on your system's implementation of the ostream class, these may be somewhat slower. (Or may not.) Not tolerant of ill formed XML: a document should contain the correct one root element. Additional root level elements will not be streamed out.<p>
+C++ style input:<ul>
+<li>based on std::istream</li><li>operator&gt;&gt;</li></ul>
+<p>
+Reads XML from a stream, making it useful for network transmission. The tricky part is knowing when the XML document is complete, since there will almost certainly be other data in the stream. TinyXML will assume the XML data is complete after it reads the root element. Put another way, documents that are ill-constructed with more than one root element will not read correctly. Also note that operator&gt;&gt; is somewhat slower than Parse, due to both implementation of the STL and limitations of TinyXML.<p>
+<h3>White space </h3>
+<p>
+The world simply does not agree on whether white space should be kept, or condensed. For example, pretend the '_' is a space, and look at "Hello____world". HTML, and at least some XML parsers, will interpret this as "Hello_world". They condense white space. Some XML parsers do not, and will leave it as "Hello____world". (Remember to keep pretending the _ is a space.) Others suggest that __Hello___world__ should become Hello___world.<p>
+It's an issue that hasn't been resolved to my satisfaction. TinyXML supports the first 2 approaches. Call <a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">TiXmlBase::SetCondenseWhiteSpace( bool )</a> to set the desired behavior. The default is to condense white space.<p>
+If you change the default, you should call <a class="el" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">TiXmlBase::SetCondenseWhiteSpace( bool )</a> before making any calls to Parse XML data, and I don't recommend changing it after it has been set.<p>
+<h3>Handles </h3>
+<p>
+Where browsing an XML document in a robust way, it is important to check for null returns from method calls. An error safe implementation can generate a lot of code like:<p>
+<div class="fragment"><pre class="fragment">TiXmlElement* root = document.FirstChildElement( "Document" );
+if ( root )
+{
+	TiXmlElement* element = root-&gt;FirstChildElement( "Element" );
+	if ( element )
+	{
+		TiXmlElement* child = element-&gt;FirstChildElement( "Child" );
+		if ( child )
+		{
+			TiXmlElement* child2 = child-&gt;NextSiblingElement( "Child" );
+			if ( child2 )
+			{
+				// Finally do something useful.
+</pre></div><p>
+Handles have been introduced to clean this up. Using the <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> class, the previous code reduces to:<p>
+<div class="fragment"><pre class="fragment">TiXmlHandle docHandle( &amp;document );
+TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+if ( child2 )
+{
+	// do something useful
+</pre></div><p>
+Which is much easier to deal with. See <a class="el" href="classTiXmlHandle.html">TiXmlHandle</a> for more information.<p>
+<h3>Row and Column tracking </h3>
+<p>
+Being able to track nodes and attributes back to their origin location in source files can be very important for some applications. Additionally, knowing where parsing errors occured in the original source can be very time saving.<p>
+TinyXML can tracks the row and column origin of all nodes and attributes in a text file. The <a class="el" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">TiXmlBase::Row()</a> and <a class="el" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">TiXmlBase::Column()</a> methods return the origin of the node in the source text. The correct tabs can be configured in <a class="el" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">TiXmlDocument::SetTabSize()</a>.<p>
+<h2>Using and Installing </h2>
+<p>
+To Compile and Run xmltest:<p>
+A Linux Makefile and a Windows Visual C++ .dsw file is provided. Simply compile and run. It will write the file demotest.xml to your disk and generate output on the screen. It also tests walking the DOM by printing out the number of nodes found using different techniques.<p>
+The Linux makefile is very generic and runs on many systems - it is currently tested on mingw and MacOSX. You do not need to run 'make depend'. The dependecies have been hard coded.<p>
+<h3>Windows project file for VC6</h3>
+<p>
+<ul>
+<li>
+tinyxml: tinyxml library, non-STL  </li>
+<li>
+tinyxmlSTL: tinyxml library, STL  </li>
+<li>
+tinyXmlTest: test app, non-STL  </li>
+<li>
+tinyXmlTestSTL: test app, STL  </li>
+</ul>
+<p>
+<h3>Makefile</h3>
+<p>
+At the top of the makefile you can set:<p>
+PROFILE, DEBUG, and TINYXML_USE_STL. Details (such that they are) are in the makefile.<p>
+In the tinyxml directory, type "make clean" then "make". The executable file 'xmltest' will be created.<p>
+<h3>To Use in an Application:</h3>
+<p>
+Add tinyxml.cpp, <a class="el" href="tinyxml_8h-source.html">tinyxml.h</a>, tinyxmlerror.cpp, tinyxmlparser.cpp, tinystr.cpp, and <a class="el" href="tinystr_8h-source.html">tinystr.h</a> to your project or make file. That's it! It should compile on any reasonably compliant C++ system. You do not need to enable exceptions or RTTI for TinyXML.<p>
+<h2>How TinyXML works. </h2>
+<p>
+An example is probably the best way to go. Take: <div class="fragment"><pre class="fragment">	&lt;?xml version="1.0" standalone=no&gt;
+	&lt;!-- Our to do list data --&gt;
+	&lt;ToDo&gt;
+		&lt;Item priority="1"&gt; Go to the &lt;bold&gt;Toy store!&lt;/bold&gt;&lt;/Item&gt;
+		&lt;Item priority="2"&gt; Do bills&lt;/Item&gt;
+	&lt;/ToDo&gt;
+</pre></div><p>
+Its not much of a To Do list, but it will do. To read this file (say "demo.xml") you would create a document, and parse it in: <div class="fragment"><pre class="fragment">	TiXmlDocument doc( "demo.xml" );
+	doc.LoadFile();
+</pre></div><p>
+And its ready to go. Now lets look at some lines and how they relate to the DOM.<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" standalone=no&gt;
+</pre></div><p>
+The first line is a declaration, and gets turned into the <a class="el" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> class. It will be the first child of the document node.<p>
+This is the only directive/special tag parsed by by TinyXML. Generally directive tags are stored in <a class="el" href="classTiXmlUnknown.html">TiXmlUnknown</a> so the commands wont be lost when it is saved back to disk.<p>
+<div class="fragment"><pre class="fragment">&lt;!-- Our to do list data --&gt;
+</pre></div><p>
+A comment. Will become a <a class="el" href="classTiXmlComment.html">TiXmlComment</a> object.<p>
+<div class="fragment"><pre class="fragment">&lt;ToDo&gt;
+</pre></div><p>
+The "ToDo" tag defines a <a class="el" href="classTiXmlElement.html">TiXmlElement</a> object. This one does not have any attributes, but does contain 2 other elements.<p>
+<div class="fragment"><pre class="fragment">&lt;Item priority="1"&gt; 
+</pre></div><p>
+Creates another <a class="el" href="classTiXmlElement.html">TiXmlElement</a> which is a child of the "ToDo" element. This element has 1 attribute, with the name "priority" and the value "1".<p>
+<div class="fragment"><pre class="fragment">Go to the
+</pre></div><p>
+A <a class="el" href="classTiXmlText.html">TiXmlText</a>. This is a leaf node and cannot contain other nodes. It is a child of the "Item" <a class="el" href="classTiXmlElement.html">TiXmlElement</a>.<p>
+<div class="fragment"><pre class="fragment">&lt;bold&gt;
+</pre></div><p>
+Another <a class="el" href="classTiXmlElement.html">TiXmlElement</a>, this one a child of the "Item" element.<p>
+Etc.<p>
+Looking at the entire object tree, you end up with: <div class="fragment"><pre class="fragment">TiXmlDocument					"demo.xml"
+	TiXmlDeclaration			"version='1.0'" "standalone=no"
+	TiXmlComment				" Our to do list data"
+	TiXmlElement				"ToDo"
+		TiXmlElement			"Item" Attribtutes: priority = 1
+			TiXmlText			"Go to the "
+			TiXmlElement		"bold"
+				TiXmlText		"Toy store!"
+		TiXmlElement			"Item" Attributes: priority=2
+			TiXmlText			"Do bills"
+</pre></div><p>
+<h2>Documentation </h2>
+<p>
+The documentation is build with Doxygen, using the 'dox' configuration file.<p>
+<h2>License </h2>
+<p>
+TinyXML is released under the zlib license:<p>
+This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.<p>
+Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:<p>
+1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.<p>
+2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.<p>
+3. This notice may not be removed or altered from any source distribution.<p>
+<h2>References </h2>
+<p>
+The World Wide Web Consortium is the definitive standard body for XML, and there web pages contain huge amounts of information.<p>
+The definitive spec: <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">http://www.w3.org/TR/2004/REC-xml-20040204/</a><p>
+I also recommend "XML Pocket Reference" by Robert Eckstein and published by OReilly...the book that got the whole thing started.<p>
+<h2>Contributors, Contacts, and a Brief History </h2>
+<p>
+Thanks very much to everyone who sends suggestions, bugs, ideas, and encouragement. It all helps, and makes this project fun. A special thanks to the contributors on the web pages that keep it lively.<p>
+So many people have sent in bugs and ideas, that rather than list here we try to give credit due in the "changes.txt" file.<p>
+TinyXML was originally written by Lee Thomason. (Often the "I" still in the documentation.) Lee reviews changes and releases new versions, with the help of Yves Berquin, Andrew Ellerton, and the tinyXml community.<p>
+We appreciate your suggestions, and would love to know if you use TinyXML. Hopefully you will enjoy it and find it useful. Please post questions, comments, file bugs, or contact us at:<p>
+www.sourceforge.net/projects/tinyxml<p>
+Lee Thomason, Yves Berquin, Andrew Ellerton <hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:22 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/pages.html
===================================================================
--- dependencies/tinyxml/docs/pages.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/pages.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,23 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: Page Index</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li id="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<h1>TinyXml Related Pages</h1>Here is a list of all related documentation pages:<ul>
+<li><a class="el" href="deprecated.html">Deprecated List</a>
+
+</ul>
+<hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/tab_b.gif
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/tab_b.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/tab_l.gif
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/tab_l.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/tab_r.gif
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/docs/tab_r.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/docs/tabs.css
===================================================================
--- dependencies/tinyxml/docs/tabs.css	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/tabs.css	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,102 @@
+/* tabs styles, based on http://www.alistapart.com/articles/slidingdoors */
+
+DIV.tabs
+{
+   float            : left;
+   width            : 100%;
+   background       : url("tab_b.gif") repeat-x bottom;
+   margin-bottom    : 4px;
+}
+
+DIV.tabs UL
+{
+   margin           : 0px;
+   padding-left     : 10px;
+   list-style       : none;
+}
+
+DIV.tabs LI, DIV.tabs FORM
+{
+   display          : inline;
+   margin           : 0px;
+   padding          : 0px;
+}
+
+DIV.tabs FORM
+{
+   float            : right;
+}
+
+DIV.tabs A
+{
+   float            : left;
+   background       : url("tab_r.gif") no-repeat right top;
+   border-bottom    : 1px solid #84B0C7;
+   font-size        : x-small;
+   font-weight      : bold;
+   text-decoration  : none;
+}
+
+DIV.tabs A:hover
+{
+   background-position: 100% -150px;
+}
+
+DIV.tabs A:link, DIV.tabs A:visited,
+DIV.tabs A:active, DIV.tabs A:hover
+{
+       color: #1A419D;
+}
+
+DIV.tabs SPAN
+{
+   float            : left;
+   display          : block;
+   background       : url("tab_l.gif") no-repeat left top;
+   padding          : 5px 9px;
+   white-space      : nowrap;
+}
+
+DIV.tabs INPUT
+{
+   float            : right;
+   display          : inline;
+   font-size        : 1em;
+}
+
+DIV.tabs TD
+{
+   font-size        : x-small;
+   font-weight      : bold;
+   text-decoration  : none;
+}
+
+
+
+/* Commented Backslash Hack hides rule from IE5-Mac \*/
+DIV.tabs SPAN {float : none;}
+/* End IE5-Mac hack */
+
+DIV.tabs A:hover SPAN
+{
+   background-position: 0% -150px;
+}
+
+DIV.tabs LI#current A
+{
+   background-position: 100% -150px;
+   border-width     : 0px;
+}
+
+DIV.tabs LI#current SPAN
+{
+   background-position: 0% -150px;
+   padding-bottom   : 6px;
+}
+
+DIV.nav
+{
+   background       : none;
+   border           : none;
+   border-bottom    : 1px solid #84B0C7;
+}

Added: dependencies/tinyxml/docs/tinystr_8h-source.html
===================================================================
--- dependencies/tinyxml/docs/tinystr_8h-source.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/tinystr_8h-source.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,338 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: tinystr.h Source File</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li><a href="annotated.html"><span>Classes</span></a></li>
+    <li id="current"><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<h1>tinystr.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
+<a name="l00002"></a>00002 <span class="comment">www.sourceforge.net/projects/tinyxml</span>
+<a name="l00003"></a>00003 <span class="comment">Original file by Yves Berquin.</span>
+<a name="l00004"></a>00004 <span class="comment"></span>
+<a name="l00005"></a>00005 <span class="comment">This software is provided 'as-is', without any express or implied</span>
+<a name="l00006"></a>00006 <span class="comment">warranty. In no event will the authors be held liable for any</span>
+<a name="l00007"></a>00007 <span class="comment">damages arising from the use of this software.</span>
+<a name="l00008"></a>00008 <span class="comment"></span>
+<a name="l00009"></a>00009 <span class="comment">Permission is granted to anyone to use this software for any</span>
+<a name="l00010"></a>00010 <span class="comment">purpose, including commercial applications, and to alter it and</span>
+<a name="l00011"></a>00011 <span class="comment">redistribute it freely, subject to the following restrictions:</span>
+<a name="l00012"></a>00012 <span class="comment"></span>
+<a name="l00013"></a>00013 <span class="comment">1. The origin of this software must not be misrepresented; you must</span>
+<a name="l00014"></a>00014 <span class="comment">not claim that you wrote the original software. If you use this</span>
+<a name="l00015"></a>00015 <span class="comment">software in a product, an acknowledgment in the product documentation</span>
+<a name="l00016"></a>00016 <span class="comment">would be appreciated but is not required.</span>
+<a name="l00017"></a>00017 <span class="comment"></span>
+<a name="l00018"></a>00018 <span class="comment">2. Altered source versions must be plainly marked as such, and</span>
+<a name="l00019"></a>00019 <span class="comment">must not be misrepresented as being the original software.</span>
+<a name="l00020"></a>00020 <span class="comment"></span>
+<a name="l00021"></a>00021 <span class="comment">3. This notice may not be removed or altered from any source</span>
+<a name="l00022"></a>00022 <span class="comment">distribution.</span>
+<a name="l00023"></a>00023 <span class="comment">*/</span>
+<a name="l00024"></a>00024 
+<a name="l00025"></a>00025 <span class="comment">/*</span>
+<a name="l00026"></a>00026 <span class="comment"> * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.</span>
+<a name="l00027"></a>00027 <span class="comment"> *</span>
+<a name="l00028"></a>00028 <span class="comment"> * - completely rewritten. compact, clean, and fast implementation.</span>
+<a name="l00029"></a>00029 <span class="comment"> * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)</span>
+<a name="l00030"></a>00030 <span class="comment"> * - fixed reserve() to work as per specification.</span>
+<a name="l00031"></a>00031 <span class="comment"> * - fixed buggy compares operator==(), operator&lt;(), and operator&gt;()</span>
+<a name="l00032"></a>00032 <span class="comment"> * - fixed operator+=() to take a const ref argument, following spec.</span>
+<a name="l00033"></a>00033 <span class="comment"> * - added "copy" constructor with length, and most compare operators.</span>
+<a name="l00034"></a>00034 <span class="comment"> * - added swap(), clear(), size(), capacity(), operator+().</span>
+<a name="l00035"></a>00035 <span class="comment"> */</span>
+<a name="l00036"></a>00036 
+<a name="l00037"></a>00037 <span class="preprocessor">#ifndef TIXML_USE_STL</span>
+<a name="l00038"></a>00038 <span class="preprocessor"></span>
+<a name="l00039"></a>00039 <span class="preprocessor">#ifndef TIXML_STRING_INCLUDED</span>
+<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define TIXML_STRING_INCLUDED</span>
+<a name="l00041"></a>00041 <span class="preprocessor"></span>
+<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;assert.h&gt;</span>
+<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;string.h&gt;</span>
+<a name="l00044"></a>00044 
+<a name="l00045"></a>00045 <span class="comment">/*  The support for explicit isn't that universal, and it isn't really</span>
+<a name="l00046"></a>00046 <span class="comment">    required - it is used to check that the TiXmlString class isn't incorrectly</span>
+<a name="l00047"></a>00047 <span class="comment">    used. Be nice to old compilers and macro it here:</span>
+<a name="l00048"></a>00048 <span class="comment">*/</span>
+<a name="l00049"></a>00049 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200 )</span>
+<a name="l00050"></a>00050 <span class="preprocessor"></span>    <span class="comment">// Microsoft visual studio, version 6 and higher.</span>
+<a name="l00051"></a>00051 <span class="preprocessor">    #define TIXML_EXPLICIT explicit</span>
+<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3 )</span>
+<a name="l00053"></a>00053 <span class="preprocessor"></span>    <span class="comment">// GCC version 3 and higher.s</span>
+<a name="l00054"></a>00054 <span class="preprocessor">    #define TIXML_EXPLICIT explicit</span>
+<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#else</span>
+<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">    #define TIXML_EXPLICIT</span>
+<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00058"></a>00058 <span class="preprocessor"></span>
+<a name="l00059"></a>00059 
+<a name="l00060"></a>00060 <span class="comment">/*</span>
+<a name="l00061"></a>00061 <span class="comment">   TiXmlString is an emulation of a subset of the std::string template.</span>
+<a name="l00062"></a>00062 <span class="comment">   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.</span>
+<a name="l00063"></a>00063 <span class="comment">   Only the member functions relevant to the TinyXML project have been implemented.</span>
+<a name="l00064"></a>00064 <span class="comment">   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase</span>
+<a name="l00065"></a>00065 <span class="comment">   a string and there's no more room, we allocate a buffer twice as big as we need.</span>
+<a name="l00066"></a>00066 <span class="comment">*/</span>
+<a name="l00067"></a>00067 <span class="keyword">class </span>TiXmlString
+<a name="l00068"></a>00068 {
+<a name="l00069"></a>00069   <span class="keyword">public</span> :
+<a name="l00070"></a>00070     <span class="comment">// The size type used</span>
+<a name="l00071"></a>00071     <span class="keyword">typedef</span> size_t size_type;
+<a name="l00072"></a>00072 
+<a name="l00073"></a>00073     <span class="comment">// Error value for find primitive</span>
+<a name="l00074"></a>00074     <span class="keyword">static</span> <span class="keyword">const</span> size_type npos; <span class="comment">// = -1;</span>
+<a name="l00075"></a>00075 
+<a name="l00076"></a>00076 
+<a name="l00077"></a>00077     <span class="comment">// TiXmlString empty constructor</span>
+<a name="l00078"></a>00078     TiXmlString () : rep_(&amp;nullrep_)
+<a name="l00079"></a>00079     {
+<a name="l00080"></a>00080     }
+<a name="l00081"></a>00081 
+<a name="l00082"></a>00082     <span class="comment">// TiXmlString copy constructor</span>
+<a name="l00083"></a>00083     TiXmlString ( <span class="keyword">const</span> TiXmlString &amp; copy) : rep_(0)
+<a name="l00084"></a>00084     {
+<a name="l00085"></a>00085         init(copy.length());
+<a name="l00086"></a>00086         memcpy(start(), copy.data(), length());
+<a name="l00087"></a>00087     }
+<a name="l00088"></a>00088 
+<a name="l00089"></a>00089     <span class="comment">// TiXmlString constructor, based on a string</span>
+<a name="l00090"></a>00090     TIXML_EXPLICIT TiXmlString ( <span class="keyword">const</span> <span class="keywordtype">char</span> * copy) : rep_(0)
+<a name="l00091"></a>00091     {
+<a name="l00092"></a>00092         init( static_cast&lt;size_type&gt;( strlen(copy) ));
+<a name="l00093"></a>00093         memcpy(start(), copy, length());
+<a name="l00094"></a>00094     }
+<a name="l00095"></a>00095 
+<a name="l00096"></a>00096     <span class="comment">// TiXmlString constructor, based on a string</span>
+<a name="l00097"></a>00097     TIXML_EXPLICIT TiXmlString ( <span class="keyword">const</span> <span class="keywordtype">char</span> * str, size_type len) : rep_(0)
+<a name="l00098"></a>00098     {
+<a name="l00099"></a>00099         init(len);
+<a name="l00100"></a>00100         memcpy(start(), str, len);
+<a name="l00101"></a>00101     }
+<a name="l00102"></a>00102 
+<a name="l00103"></a>00103     <span class="comment">// TiXmlString destructor</span>
+<a name="l00104"></a>00104     ~TiXmlString ()
+<a name="l00105"></a>00105     {
+<a name="l00106"></a>00106         quit();
+<a name="l00107"></a>00107     }
+<a name="l00108"></a>00108 
+<a name="l00109"></a>00109     <span class="comment">// = operator</span>
+<a name="l00110"></a>00110     TiXmlString&amp; operator = (<span class="keyword">const</span> <span class="keywordtype">char</span> * copy)
+<a name="l00111"></a>00111     {
+<a name="l00112"></a>00112         <span class="keywordflow">return</span> assign( copy, (size_type)strlen(copy));
+<a name="l00113"></a>00113     }
+<a name="l00114"></a>00114 
+<a name="l00115"></a>00115     <span class="comment">// = operator</span>
+<a name="l00116"></a>00116     TiXmlString&amp; operator = (<span class="keyword">const</span> TiXmlString &amp; copy)
+<a name="l00117"></a>00117     {
+<a name="l00118"></a>00118         <span class="keywordflow">return</span> assign(copy.start(), copy.length());
+<a name="l00119"></a>00119     }
+<a name="l00120"></a>00120 
+<a name="l00121"></a>00121 
+<a name="l00122"></a>00122     <span class="comment">// += operator. Maps to append</span>
+<a name="l00123"></a>00123     TiXmlString&amp; operator += (<span class="keyword">const</span> <span class="keywordtype">char</span> * suffix)
+<a name="l00124"></a>00124     {
+<a name="l00125"></a>00125         <span class="keywordflow">return</span> append(suffix, static_cast&lt;size_type&gt;( strlen(suffix) ));
+<a name="l00126"></a>00126     }
+<a name="l00127"></a>00127 
+<a name="l00128"></a>00128     <span class="comment">// += operator. Maps to append</span>
+<a name="l00129"></a>00129     TiXmlString&amp; operator += (<span class="keywordtype">char</span> single)
+<a name="l00130"></a>00130     {
+<a name="l00131"></a>00131         <span class="keywordflow">return</span> append(&amp;single, 1);
+<a name="l00132"></a>00132     }
+<a name="l00133"></a>00133 
+<a name="l00134"></a>00134     <span class="comment">// += operator. Maps to append</span>
+<a name="l00135"></a>00135     TiXmlString&amp; operator += (<span class="keyword">const</span> TiXmlString &amp; suffix)
+<a name="l00136"></a>00136     {
+<a name="l00137"></a>00137         <span class="keywordflow">return</span> append(suffix.data(), suffix.length());
+<a name="l00138"></a>00138     }
+<a name="l00139"></a>00139 
+<a name="l00140"></a>00140 
+<a name="l00141"></a>00141     <span class="comment">// Convert a TiXmlString into a null-terminated char *</span>
+<a name="l00142"></a>00142     <span class="keyword">const</span> <span class="keywordtype">char</span> * c_str ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00143"></a>00143 
+<a name="l00144"></a>00144     <span class="comment">// Convert a TiXmlString into a char * (need not be null terminated).</span>
+<a name="l00145"></a>00145     <span class="keyword">const</span> <span class="keywordtype">char</span> * data ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00146"></a>00146 
+<a name="l00147"></a>00147     <span class="comment">// Return the length of a TiXmlString</span>
+<a name="l00148"></a>00148     size_type length ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size; }
+<a name="l00149"></a>00149 
+<a name="l00150"></a>00150     <span class="comment">// Alias for length()</span>
+<a name="l00151"></a>00151     size_type size ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size; }
+<a name="l00152"></a>00152 
+<a name="l00153"></a>00153     <span class="comment">// Checks if a TiXmlString is empty</span>
+<a name="l00154"></a>00154     <span class="keywordtype">bool</span> empty ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;size == 0; }
+<a name="l00155"></a>00155 
+<a name="l00156"></a>00156     <span class="comment">// Return capacity of string</span>
+<a name="l00157"></a>00157     size_type capacity ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;capacity; }
+<a name="l00158"></a>00158 
+<a name="l00159"></a>00159 
+<a name="l00160"></a>00160     <span class="comment">// single char extraction</span>
+<a name="l00161"></a>00161     <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; at (size_type index)<span class="keyword"> const</span>
+<a name="l00162"></a>00162 <span class="keyword">    </span>{
+<a name="l00163"></a>00163         assert( index &lt; length() );
+<a name="l00164"></a>00164         <span class="keywordflow">return</span> rep_-&gt;str[ index ];
+<a name="l00165"></a>00165     }
+<a name="l00166"></a>00166 
+<a name="l00167"></a>00167     <span class="comment">// [] operator</span>
+<a name="l00168"></a>00168     <span class="keywordtype">char</span>&amp; operator [] (size_type index)<span class="keyword"> const</span>
+<a name="l00169"></a>00169 <span class="keyword">    </span>{
+<a name="l00170"></a>00170         assert( index &lt; length() );
+<a name="l00171"></a>00171         <span class="keywordflow">return</span> rep_-&gt;str[ index ];
+<a name="l00172"></a>00172     }
+<a name="l00173"></a>00173 
+<a name="l00174"></a>00174     <span class="comment">// find a char in a string. Return TiXmlString::npos if not found</span>
+<a name="l00175"></a>00175     size_type find (<span class="keywordtype">char</span> lookup)<span class="keyword"> const</span>
+<a name="l00176"></a>00176 <span class="keyword">    </span>{
+<a name="l00177"></a>00177         <span class="keywordflow">return</span> find(lookup, 0);
+<a name="l00178"></a>00178     }
+<a name="l00179"></a>00179 
+<a name="l00180"></a>00180     <span class="comment">// find a char in a string from an offset. Return TiXmlString::npos if not found</span>
+<a name="l00181"></a>00181     size_type find (<span class="keywordtype">char</span> tofind, size_type offset)<span class="keyword"> const</span>
+<a name="l00182"></a>00182 <span class="keyword">    </span>{
+<a name="l00183"></a>00183         <span class="keywordflow">if</span> (offset &gt;= length()) <span class="keywordflow">return</span> npos;
+<a name="l00184"></a>00184 
+<a name="l00185"></a>00185         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>* p = c_str() + offset; *p != <span class="charliteral">'\0'</span>; ++p)
+<a name="l00186"></a>00186         {
+<a name="l00187"></a>00187            <span class="keywordflow">if</span> (*p == tofind) <span class="keywordflow">return</span> static_cast&lt; size_type &gt;( p - c_str() );
+<a name="l00188"></a>00188         }
+<a name="l00189"></a>00189         <span class="keywordflow">return</span> npos;
+<a name="l00190"></a>00190     }
+<a name="l00191"></a>00191 
+<a name="l00192"></a>00192     <span class="keywordtype">void</span> clear ()
+<a name="l00193"></a>00193     {
+<a name="l00194"></a>00194         <span class="comment">//Lee:</span>
+<a name="l00195"></a>00195         <span class="comment">//The original was just too strange, though correct:</span>
+<a name="l00196"></a>00196         <span class="comment">//  TiXmlString().swap(*this);</span>
+<a name="l00197"></a>00197         <span class="comment">//Instead use the quit &amp; re-init:</span>
+<a name="l00198"></a>00198         quit();
+<a name="l00199"></a>00199         init(0,0);
+<a name="l00200"></a>00200     }
+<a name="l00201"></a>00201 
+<a name="l00202"></a>00202     <span class="comment">/*  Function to reserve a big amount of data when we know we'll need it. Be aware that this</span>
+<a name="l00203"></a>00203 <span class="comment">        function DOES NOT clear the content of the TiXmlString if any exists.</span>
+<a name="l00204"></a>00204 <span class="comment">    */</span>
+<a name="l00205"></a>00205     <span class="keywordtype">void</span> reserve (size_type cap);
+<a name="l00206"></a>00206 
+<a name="l00207"></a>00207     TiXmlString&amp; assign (<span class="keyword">const</span> <span class="keywordtype">char</span>* str, size_type len);
+<a name="l00208"></a>00208 
+<a name="l00209"></a>00209     TiXmlString&amp; append (<span class="keyword">const</span> <span class="keywordtype">char</span>* str, size_type len);
+<a name="l00210"></a>00210 
+<a name="l00211"></a>00211     <span class="keywordtype">void</span> swap (TiXmlString&amp; other)
+<a name="l00212"></a>00212     {
+<a name="l00213"></a>00213         Rep* r = rep_;
+<a name="l00214"></a>00214         rep_ = other.rep_;
+<a name="l00215"></a>00215         other.rep_ = r;
+<a name="l00216"></a>00216     }
+<a name="l00217"></a>00217 
+<a name="l00218"></a>00218   <span class="keyword">private</span>:
+<a name="l00219"></a>00219 
+<a name="l00220"></a>00220     <span class="keywordtype">void</span> init(size_type sz) { init(sz, sz); }
+<a name="l00221"></a>00221     <span class="keywordtype">void</span> set_size(size_type sz) { rep_-&gt;str[ rep_-&gt;size = sz ] = <span class="charliteral">'\0'</span>; }
+<a name="l00222"></a>00222     <span class="keywordtype">char</span>* start()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str; }
+<a name="l00223"></a>00223     <span class="keywordtype">char</span>* finish()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rep_-&gt;str + rep_-&gt;size; }
+<a name="l00224"></a>00224 
+<a name="l00225"></a>00225     <span class="keyword">struct </span>Rep
+<a name="l00226"></a>00226     {
+<a name="l00227"></a>00227         size_type size, capacity;
+<a name="l00228"></a>00228         <span class="keywordtype">char</span> str[1];
+<a name="l00229"></a>00229     };
+<a name="l00230"></a>00230 
+<a name="l00231"></a>00231     <span class="keywordtype">void</span> init(size_type sz, size_type cap)
+<a name="l00232"></a>00232     {
+<a name="l00233"></a>00233         <span class="keywordflow">if</span> (cap)
+<a name="l00234"></a>00234         {
+<a name="l00235"></a>00235             <span class="comment">// Lee: the original form:</span>
+<a name="l00236"></a>00236             <span class="comment">//  rep_ = static_cast&lt;Rep*&gt;(operator new(sizeof(Rep) + cap));</span>
+<a name="l00237"></a>00237             <span class="comment">// doesn't work in some cases of new being overloaded. Switching</span>
+<a name="l00238"></a>00238             <span class="comment">// to the normal allocation, although use an 'int' for systems</span>
+<a name="l00239"></a>00239             <span class="comment">// that are overly picky about structure alignment.</span>
+<a name="l00240"></a>00240             <span class="keyword">const</span> size_type bytesNeeded = <span class="keyword">sizeof</span>(Rep) + cap;
+<a name="l00241"></a>00241             <span class="keyword">const</span> size_type intsNeeded = ( bytesNeeded + <span class="keyword">sizeof</span>(int) - 1 ) / <span class="keyword">sizeof</span>( int ); 
+<a name="l00242"></a>00242             rep_ = reinterpret_cast&lt;Rep*&gt;( <span class="keyword">new</span> <span class="keywordtype">int</span>[ intsNeeded ] );
+<a name="l00243"></a>00243 
+<a name="l00244"></a>00244             rep_-&gt;str[ rep_-&gt;size = sz ] = <span class="charliteral">'\0'</span>;
+<a name="l00245"></a>00245             rep_-&gt;capacity = cap;
+<a name="l00246"></a>00246         }
+<a name="l00247"></a>00247         <span class="keywordflow">else</span>
+<a name="l00248"></a>00248         {
+<a name="l00249"></a>00249             rep_ = &amp;nullrep_;
+<a name="l00250"></a>00250         }
+<a name="l00251"></a>00251     }
+<a name="l00252"></a>00252 
+<a name="l00253"></a>00253     <span class="keywordtype">void</span> quit()
+<a name="l00254"></a>00254     {
+<a name="l00255"></a>00255         <span class="keywordflow">if</span> (rep_ != &amp;nullrep_)
+<a name="l00256"></a>00256         {
+<a name="l00257"></a>00257             <span class="comment">// The rep_ is really an array of ints. (see the allocator, above).</span>
+<a name="l00258"></a>00258             <span class="comment">// Cast it back before delete, so the compiler won't incorrectly call destructors.</span>
+<a name="l00259"></a>00259             <span class="keyword">delete</span> [] ( reinterpret_cast&lt;int*&gt;( rep_ ) );
+<a name="l00260"></a>00260         }
+<a name="l00261"></a>00261     }
+<a name="l00262"></a>00262 
+<a name="l00263"></a>00263     Rep * rep_;
+<a name="l00264"></a>00264     <span class="keyword">static</span> Rep nullrep_;
+<a name="l00265"></a>00265 
+<a name="l00266"></a>00266 } ;
+<a name="l00267"></a>00267 
+<a name="l00268"></a>00268 
+<a name="l00269"></a>00269 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b)
+<a name="l00270"></a>00270 {
+<a name="l00271"></a>00271     <span class="keywordflow">return</span>    ( a.length() == b.length() )              <span class="comment">// optimization on some platforms</span>
+<a name="l00272"></a>00272            &amp;&amp; ( strcmp(a.c_str(), b.c_str()) == 0 );    <span class="comment">// actual compare</span>
+<a name="l00273"></a>00273 }
+<a name="l00274"></a>00274 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b)
+<a name="l00275"></a>00275 {
+<a name="l00276"></a>00276     <span class="keywordflow">return</span> strcmp(a.c_str(), b.c_str()) &lt; 0;
+<a name="l00277"></a>00277 }
+<a name="l00278"></a>00278 
+<a name="l00279"></a>00279 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(a == b); }
+<a name="l00280"></a>00280 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;  (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> b &lt; a; }
+<a name="l00281"></a>00281 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt;= (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(b &lt; a); }
+<a name="l00282"></a>00282 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(a &lt; b); }
+<a name="l00283"></a>00283 
+<a name="l00284"></a>00284 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b) { <span class="keywordflow">return</span> strcmp(a.c_str(), b) == 0; }
+<a name="l00285"></a>00285 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> b == a; }
+<a name="l00286"></a>00286 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b) { <span class="keywordflow">return</span> !(a == b); }
+<a name="l00287"></a>00287 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b) { <span class="keywordflow">return</span> !(b == a); }
+<a name="l00288"></a>00288 
+<a name="l00289"></a>00289 TiXmlString operator + (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> TiXmlString &amp; b);
+<a name="l00290"></a>00290 TiXmlString operator + (<span class="keyword">const</span> TiXmlString &amp; a, <span class="keyword">const</span> <span class="keywordtype">char</span>* b);
+<a name="l00291"></a>00291 TiXmlString operator + (<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> TiXmlString &amp; b);
+<a name="l00292"></a>00292 
+<a name="l00293"></a>00293 
+<a name="l00294"></a>00294 <span class="comment">/*</span>
+<a name="l00295"></a>00295 <span class="comment">   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.</span>
+<a name="l00296"></a>00296 <span class="comment">   Only the operators that we need for TinyXML have been developped.</span>
+<a name="l00297"></a>00297 <span class="comment">*/</span>
+<a name="l00298"></a>00298 <span class="keyword">class </span>TiXmlOutStream : <span class="keyword">public</span> TiXmlString
+<a name="l00299"></a>00299 {
+<a name="l00300"></a>00300 <span class="keyword">public</span> :
+<a name="l00301"></a>00301 
+<a name="l00302"></a>00302     <span class="comment">// TiXmlOutStream &lt;&lt; operator.</span>
+<a name="l00303"></a>00303     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> TiXmlString &amp; in)
+<a name="l00304"></a>00304     {
+<a name="l00305"></a>00305         *<span class="keyword">this</span> += in;
+<a name="l00306"></a>00306         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
+<a name="l00307"></a>00307     }
+<a name="l00308"></a>00308 
+<a name="l00309"></a>00309     <span class="comment">// TiXmlOutStream &lt;&lt; operator.</span>
+<a name="l00310"></a>00310     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> <span class="keywordtype">char</span> * in)
+<a name="l00311"></a>00311     {
+<a name="l00312"></a>00312         *<span class="keyword">this</span> += in;
+<a name="l00313"></a>00313         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
+<a name="l00314"></a>00314     }
+<a name="l00315"></a>00315 
+<a name="l00316"></a>00316 } ;
+<a name="l00317"></a>00317 
+<a name="l00318"></a>00318 <span class="preprocessor">#endif  // TIXML_STRING_INCLUDED</span>
+<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">#endif  // TIXML_USE_STL</span>
+</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:22 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/tinyxml_8h-source.html
===================================================================
--- dependencies/tinyxml/docs/tinyxml_8h-source.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/tinyxml_8h-source.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,1201 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: tinyxml.h Source File</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li><a href="annotated.html"><span>Classes</span></a></li>
+    <li id="current"><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<h1>tinyxml.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
+<a name="l00002"></a>00002 <span class="comment">www.sourceforge.net/projects/tinyxml</span>
+<a name="l00003"></a>00003 <span class="comment">Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)</span>
+<a name="l00004"></a>00004 <span class="comment"></span>
+<a name="l00005"></a>00005 <span class="comment">This software is provided 'as-is', without any express or implied</span>
+<a name="l00006"></a>00006 <span class="comment">warranty. In no event will the authors be held liable for any</span>
+<a name="l00007"></a>00007 <span class="comment">damages arising from the use of this software.</span>
+<a name="l00008"></a>00008 <span class="comment"></span>
+<a name="l00009"></a>00009 <span class="comment">Permission is granted to anyone to use this software for any</span>
+<a name="l00010"></a>00010 <span class="comment">purpose, including commercial applications, and to alter it and</span>
+<a name="l00011"></a>00011 <span class="comment">redistribute it freely, subject to the following restrictions:</span>
+<a name="l00012"></a>00012 <span class="comment"></span>
+<a name="l00013"></a>00013 <span class="comment">1. The origin of this software must not be misrepresented; you must</span>
+<a name="l00014"></a>00014 <span class="comment">not claim that you wrote the original software. If you use this</span>
+<a name="l00015"></a>00015 <span class="comment">software in a product, an acknowledgment in the product documentation</span>
+<a name="l00016"></a>00016 <span class="comment">would be appreciated but is not required.</span>
+<a name="l00017"></a>00017 <span class="comment"></span>
+<a name="l00018"></a>00018 <span class="comment">2. Altered source versions must be plainly marked as such, and</span>
+<a name="l00019"></a>00019 <span class="comment">must not be misrepresented as being the original software.</span>
+<a name="l00020"></a>00020 <span class="comment"></span>
+<a name="l00021"></a>00021 <span class="comment">3. This notice may not be removed or altered from any source</span>
+<a name="l00022"></a>00022 <span class="comment">distribution.</span>
+<a name="l00023"></a>00023 <span class="comment">*/</span>
+<a name="l00024"></a>00024 
+<a name="l00025"></a>00025 
+<a name="l00026"></a>00026 <span class="preprocessor">#ifndef TINYXML_INCLUDED</span>
+<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define TINYXML_INCLUDED</span>
+<a name="l00028"></a>00028 <span class="preprocessor"></span>
+<a name="l00029"></a>00029 <span class="preprocessor">#ifdef _MSC_VER</span>
+<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( push )</span>
+<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4530 )</span>
+<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4786 )</span>
+<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00034"></a>00034 <span class="preprocessor"></span>
+<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
+<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
+<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
+<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;string.h&gt;</span>
+<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;assert.h&gt;</span>
+<a name="l00040"></a>00040 
+<a name="l00041"></a>00041 <span class="comment">// Help out windows:</span>
+<a name="l00042"></a>00042 <span class="preprocessor">#if defined( _DEBUG ) &amp;&amp; !defined( DEBUG )</span>
+<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG</span>
+<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00045"></a>00045 <span class="preprocessor"></span>
+<a name="l00046"></a>00046 <span class="preprocessor">#ifdef TIXML_USE_STL</span>
+<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;string&gt;</span>
+<a name="l00048"></a>00048 <span class="preprocessor">    #include &lt;iostream&gt;</span>
+<a name="l00049"></a>00049 <span class="preprocessor">    #include &lt;sstream&gt;</span>
+<a name="l00050"></a>00050 <span class="preprocessor">    #define TIXML_STRING        std::string</span>
+<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#else</span>
+<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">    #include "tinystr.h"</span>
+<a name="l00053"></a>00053 <span class="preprocessor">    #define TIXML_STRING        TiXmlString</span>
+<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l00055"></a>00055 <span class="preprocessor"></span>
+<a name="l00056"></a>00056 <span class="comment">// Deprecated library function hell. Compilers want to use the</span>
+<a name="l00057"></a>00057 <span class="comment">// new safe versions. This probably doesn't fully address the problem,</span>
+<a name="l00058"></a>00058 <span class="comment">// but it gets closer. There are too many compilers for me to fully</span>
+<a name="l00059"></a>00059 <span class="comment">// test. If you get compilation troubles, undefine TIXML_SAFE</span>
+<a name="l00060"></a>00060 <span class="preprocessor">#define TIXML_SAFE</span>
+<a name="l00061"></a>00061 <span class="preprocessor"></span>
+<a name="l00062"></a>00062 <span class="preprocessor">#ifdef TIXML_SAFE</span>
+<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">    #if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400 )</span>
+<a name="l00064"></a>00064 <span class="preprocessor"></span>        <span class="comment">// Microsoft visual studio, version 2005 and higher.</span>
+<a name="l00065"></a>00065 <span class="preprocessor">        #define TIXML_SNPRINTF _snprintf_s</span>
+<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SNSCANF  _snscanf_s</span>
+<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf_s</span>
+<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">    #elif defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200 )</span>
+<a name="l00069"></a>00069 <span class="preprocessor"></span>        <span class="comment">// Microsoft visual studio, version 6 and higher.</span>
+<a name="l00070"></a>00070         <span class="comment">//#pragma message( "Using _sn* functions." )</span>
+<a name="l00071"></a>00071 <span class="preprocessor">        #define TIXML_SNPRINTF _snprintf</span>
+<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SNSCANF  _snscanf</span>
+<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">    #elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3 )</span>
+<a name="l00075"></a>00075 <span class="preprocessor"></span>        <span class="comment">// GCC version 3 and higher.s</span>
+<a name="l00076"></a>00076         <span class="comment">//#warning( "Using sn* functions." )</span>
+<a name="l00077"></a>00077 <span class="preprocessor">        #define TIXML_SNPRINTF snprintf</span>
+<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SNSCANF  snscanf</span>
+<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
+<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">        #define TIXML_SSCANF   sscanf</span>
+<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#endif  </span>
+<a name="l00084"></a>00084 <span class="preprocessor"></span>
+<a name="l00085"></a>00085 <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>;
+<a name="l00086"></a>00086 <span class="keyword">class </span><a class="code" href="classTiXmlElement.html">TiXmlElement</a>;
+<a name="l00087"></a>00087 <span class="keyword">class </span><a class="code" href="classTiXmlComment.html">TiXmlComment</a>;
+<a name="l00088"></a>00088 <span class="keyword">class </span><a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>;
+<a name="l00089"></a>00089 <span class="keyword">class </span><a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>;
+<a name="l00090"></a>00090 <span class="keyword">class </span><a class="code" href="classTiXmlText.html">TiXmlText</a>;
+<a name="l00091"></a>00091 <span class="keyword">class </span><a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>;
+<a name="l00092"></a>00092 <span class="keyword">class </span>TiXmlParsingData;
+<a name="l00093"></a>00093 
+<a name="l00094"></a>00094 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_MAJOR_VERSION = 2;
+<a name="l00095"></a>00095 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_MINOR_VERSION = 5;
+<a name="l00096"></a>00096 <span class="keyword">const</span> <span class="keywordtype">int</span> TIXML_PATCH_VERSION = 3;
+<a name="l00097"></a>00097 
+<a name="l00098"></a>00098 <span class="comment">/*  Internal structure for tracking location of items </span>
+<a name="l00099"></a>00099 <span class="comment">    in the XML file.</span>
+<a name="l00100"></a>00100 <span class="comment">*/</span>
+<a name="l00101"></a>00101 <span class="keyword">struct </span>TiXmlCursor
+<a name="l00102"></a>00102 {
+<a name="l00103"></a>00103     TiXmlCursor()       { Clear(); }
+<a name="l00104"></a>00104     <span class="keywordtype">void</span> Clear()        { row = col = -1; }
+<a name="l00105"></a>00105 
+<a name="l00106"></a>00106     <span class="keywordtype">int</span> row;    <span class="comment">// 0 based.</span>
+<a name="l00107"></a>00107     <span class="keywordtype">int</span> col;    <span class="comment">// 0 based.</span>
+<a name="l00108"></a>00108 };
+<a name="l00109"></a>00109 
+<a name="l00110"></a>00110 
+<a name="l00129"></a><a class="code" href="classTiXmlVisitor.html">00129</a> <span class="keyword">class </span><a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>
+<a name="l00130"></a>00130 {
+<a name="l00131"></a>00131 <span class="keyword">public</span>:
+<a name="l00132"></a>00132     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>() {}
+<a name="l00133"></a>00133 
+<a name="l00135"></a><a class="code" href="classTiXmlVisitor.html#07baecb52dd7d8716ae2a48ad0956ee0">00135</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>&amp; <span class="comment">/*doc*/</span> )         { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00137"></a><a class="code" href="classTiXmlVisitor.html#a0ade4f27087447e93974e975c3246ad">00137</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a0ade4f27087447e93974e975c3246ad">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>&amp; <span class="comment">/*doc*/</span> )          { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00138"></a>00138 
+<a name="l00140"></a><a class="code" href="classTiXmlVisitor.html#f6c6178ffa517bbdba95d70490875fff">00140</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#07baecb52dd7d8716ae2a48ad0956ee0">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>&amp; <span class="comment">/*element*/</span>, <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <span class="comment">/*firstAttribute*/</span> )    { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00142"></a><a class="code" href="classTiXmlVisitor.html#ec2b1f8116226d52f3a1b95dafd3a32c">00142</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#a0ade4f27087447e93974e975c3246ad">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>&amp; <span class="comment">/*element*/</span> )       { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00143"></a>00143 
+<a name="l00145"></a><a class="code" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">00145</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>&amp; <span class="comment">/*declaration*/</span> )   { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00147"></a><a class="code" href="classTiXmlVisitor.html#399b8ebca5cd14664974a32d2ce029e5">00147</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>&amp; <span class="comment">/*text*/</span> )                 { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00149"></a><a class="code" href="classTiXmlVisitor.html#53a60e7a528627b31af3161972cc7fa2">00149</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>&amp; <span class="comment">/*comment*/</span> )           { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00151"></a><a class="code" href="classTiXmlVisitor.html#7e284d607d275c51dac1adb58159ce28">00151</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlVisitor.html#fad71c71ce6473fb9b4b64cd92de4a19">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>&amp; <span class="comment">/*unknown*/</span> )           { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
+<a name="l00152"></a>00152 };
+<a name="l00153"></a>00153 
+<a name="l00154"></a>00154 <span class="comment">// Only used by Attribute::Query functions</span>
+<a name="l00155"></a>00155 <span class="keyword">enum</span> 
+<a name="l00156"></a>00156 { 
+<a name="l00157"></a>00157     TIXML_SUCCESS,
+<a name="l00158"></a>00158     TIXML_NO_ATTRIBUTE,
+<a name="l00159"></a>00159     TIXML_WRONG_TYPE
+<a name="l00160"></a>00160 };
+<a name="l00161"></a>00161 
+<a name="l00162"></a>00162 
+<a name="l00163"></a>00163 <span class="comment">// Used by the parsing routines.</span>
+<a name="l00164"></a>00164 <span class="keyword">enum</span> TiXmlEncoding
+<a name="l00165"></a>00165 {
+<a name="l00166"></a>00166     TIXML_ENCODING_UNKNOWN,
+<a name="l00167"></a>00167     TIXML_ENCODING_UTF8,
+<a name="l00168"></a>00168     TIXML_ENCODING_LEGACY
+<a name="l00169"></a>00169 };
+<a name="l00170"></a>00170 
+<a name="l00171"></a>00171 <span class="keyword">const</span> TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+<a name="l00172"></a>00172 
+<a name="l00195"></a><a class="code" href="classTiXmlBase.html">00195</a> <span class="keyword">class </span><a class="code" href="classTiXmlBase.html">TiXmlBase</a>
+<a name="l00196"></a>00196 {
+<a name="l00197"></a>00197     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlNode.html">TiXmlNode</a>;
+<a name="l00198"></a>00198     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html">TiXmlElement</a>;
+<a name="l00199"></a>00199     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>;
+<a name="l00200"></a>00200 
+<a name="l00201"></a>00201 <span class="keyword">public</span>:
+<a name="l00202"></a>00202     <a class="code" href="classTiXmlBase.html">TiXmlBase</a>() :   <a class="code" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a>(0)     {}
+<a name="l00203"></a>00203     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlBase.html">TiXmlBase</a>()            {}
+<a name="l00204"></a>00204 
+<a name="l00214"></a>00214     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#0de56b3f2ef14c65091a3b916437b512">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const </span>= 0;
+<a name="l00215"></a>00215 
+<a name="l00222"></a><a class="code" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">00222</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#0f799ec645bfb8d8a969e83478f379c1">SetCondenseWhiteSpace</a>( <span class="keywordtype">bool</span> condense )      { condenseWhiteSpace = condense; }
+<a name="l00223"></a>00223 
+<a name="l00225"></a><a class="code" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">00225</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlBase.html#d4b1472531c647a25b1840a87ae42438">IsWhiteSpaceCondensed</a>()                     { <span class="keywordflow">return</span> condenseWhiteSpace; }
+<a name="l00226"></a>00226 
+<a name="l00245"></a><a class="code" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">00245</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlBase.html#024bceb070188df92c2a8d8852dd0853">Row</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> location.row + 1; }
+<a name="l00246"></a><a class="code" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">00246</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlBase.html#b54bfb9b70fe6dd276e7b279cab7f003">Column</a>()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> location.col + 1; }    
+<a name="l00247"></a>00247 
+<a name="l00248"></a><a class="code" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">00248</a>     <span class="keywordtype">void</span>  <a class="code" href="classTiXmlBase.html#c6b3e0f790930d4970ec30764e937b5d">SetUserData</a>( <span class="keywordtype">void</span>* user )         { <a class="code" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a> = user; }    
+<a name="l00249"></a><a class="code" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">00249</a>     <span class="keywordtype">void</span>* <a class="code" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()                     { <span class="keywordflow">return</span> <a class="code" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a>; }    
+<a name="l00250"></a><a class="code" href="classTiXmlBase.html#d0120210e4680ef2088601753ce0ede4">00250</a>     <span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code" href="classTiXmlBase.html#6559a530ca6763fc301a14d77ed28c17">GetUserData</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a>; }    
+<a name="l00251"></a>00251 
+<a name="l00252"></a>00252     <span class="comment">// Table that returs, for a given lead byte, the total number of bytes</span>
+<a name="l00253"></a>00253     <span class="comment">// in the UTF-8 sequence.</span>
+<a name="l00254"></a>00254     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> utf8ByteTable[256];
+<a name="l00255"></a>00255 
+<a name="l00256"></a>00256     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlDocument.html#17ebabe36926ef398e78dec0d0ad0378">Parse</a>(  <span class="keyword">const</span> <span class="keywordtype">char</span>* p, 
+<a name="l00257"></a>00257                                 TiXmlParsingData* data, 
+<a name="l00258"></a>00258                                 TiXmlEncoding encoding <span class="comment">/*= TIXML_ENCODING_UNKNOWN */</span> ) = 0;
+<a name="l00259"></a>00259 
+<a name="l00263"></a>00263     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlBase.html#6bd8c315c1acb09e34107b8736505948">EncodeString</a>( <span class="keyword">const</span> TIXML_STRING&amp; str, TIXML_STRING* out );
+<a name="l00264"></a>00264 
+<a name="l00265"></a>00265     <span class="keyword">enum</span>
+<a name="l00266"></a>00266     {
+<a name="l00267"></a>00267         TIXML_NO_ERROR = 0,
+<a name="l00268"></a>00268         TIXML_ERROR,
+<a name="l00269"></a>00269         TIXML_ERROR_OPENING_FILE,
+<a name="l00270"></a>00270         TIXML_ERROR_OUT_OF_MEMORY,
+<a name="l00271"></a>00271         TIXML_ERROR_PARSING_ELEMENT,
+<a name="l00272"></a>00272         TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+<a name="l00273"></a>00273         TIXML_ERROR_READING_ELEMENT_VALUE,
+<a name="l00274"></a>00274         TIXML_ERROR_READING_ATTRIBUTES,
+<a name="l00275"></a>00275         TIXML_ERROR_PARSING_EMPTY,
+<a name="l00276"></a>00276         TIXML_ERROR_READING_END_TAG,
+<a name="l00277"></a>00277         TIXML_ERROR_PARSING_UNKNOWN,
+<a name="l00278"></a>00278         TIXML_ERROR_PARSING_COMMENT,
+<a name="l00279"></a>00279         TIXML_ERROR_PARSING_DECLARATION,
+<a name="l00280"></a>00280         TIXML_ERROR_DOCUMENT_EMPTY,
+<a name="l00281"></a>00281         TIXML_ERROR_EMBEDDED_NULL,
+<a name="l00282"></a>00282         TIXML_ERROR_PARSING_CDATA,
+<a name="l00283"></a>00283         TIXML_ERROR_DOCUMENT_TOP_ONLY,
+<a name="l00284"></a>00284 
+<a name="l00285"></a>00285         TIXML_ERROR_STRING_COUNT
+<a name="l00286"></a>00286     };
+<a name="l00287"></a>00287 
+<a name="l00288"></a>00288 <span class="keyword">protected</span>:
+<a name="l00289"></a>00289 
+<a name="l00290"></a>00290     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* SkipWhiteSpace( <span class="keyword">const</span> <span class="keywordtype">char</span>*, TiXmlEncoding encoding );
+<a name="l00291"></a>00291     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> IsWhiteSpace( <span class="keywordtype">char</span> c )       
+<a name="l00292"></a>00292     { 
+<a name="l00293"></a>00293         <span class="keywordflow">return</span> ( isspace( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) c ) || c == <span class="charliteral">'\n'</span> || c == <span class="charliteral">'\r'</span> ); 
+<a name="l00294"></a>00294     }
+<a name="l00295"></a>00295     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> IsWhiteSpace( <span class="keywordtype">int</span> c )
+<a name="l00296"></a>00296     {
+<a name="l00297"></a>00297         <span class="keywordflow">if</span> ( c &lt; 256 )
+<a name="l00298"></a>00298             <span class="keywordflow">return</span> IsWhiteSpace( (<span class="keywordtype">char</span>) c );
+<a name="l00299"></a>00299         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// Again, only truly correct for English/Latin...but usually works.</span>
+<a name="l00300"></a>00300     }
+<a name="l00301"></a>00301 
+<a name="l00302"></a>00302 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00303"></a>00303 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">bool</span> StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+<a name="l00304"></a>00304     <span class="keyword">static</span> <span class="keywordtype">bool</span> StreamTo( std::istream * in, <span class="keywordtype">int</span> character, TIXML_STRING * tag );
+<a name="l00305"></a>00305 <span class="preprocessor">    #endif</span>
+<a name="l00306"></a>00306 <span class="preprocessor"></span>
+<a name="l00307"></a>00307     <span class="comment">/*  Reads an XML name into the string provided. Returns</span>
+<a name="l00308"></a>00308 <span class="comment">        a pointer just past the last character of the name,</span>
+<a name="l00309"></a>00309 <span class="comment">        or 0 if the function has an error.</span>
+<a name="l00310"></a>00310 <span class="comment">    */</span>
+<a name="l00311"></a>00311     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadName( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TIXML_STRING* name, TiXmlEncoding encoding );
+<a name="l00312"></a>00312 
+<a name="l00313"></a>00313     <span class="comment">/*  Reads text. Returns a pointer past the given end tag.</span>
+<a name="l00314"></a>00314 <span class="comment">        Wickedly complex options, but it keeps the (sensitive) code in one place.</span>
+<a name="l00315"></a>00315 <span class="comment">    */</span>
+<a name="l00316"></a>00316     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadText(    <span class="keyword">const</span> <span class="keywordtype">char</span>* in,             <span class="comment">// where to start</span>
+<a name="l00317"></a>00317                                     TIXML_STRING* text,         <span class="comment">// the string read</span>
+<a name="l00318"></a>00318                                     <span class="keywordtype">bool</span> ignoreWhiteSpace,      <span class="comment">// whether to keep the white space</span>
+<a name="l00319"></a>00319                                     <span class="keyword">const</span> <span class="keywordtype">char</span>* endTag,         <span class="comment">// what ends this text</span>
+<a name="l00320"></a>00320                                     <span class="keywordtype">bool</span> ignoreCase,            <span class="comment">// whether to ignore case in the end tag</span>
+<a name="l00321"></a>00321                                     TiXmlEncoding encoding );   <span class="comment">// the current encoding</span>
+<a name="l00322"></a>00322 
+<a name="l00323"></a>00323     <span class="comment">// If an entity has been found, transform it into a character.</span>
+<a name="l00324"></a>00324     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* GetEntity( <span class="keyword">const</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span>* length, TiXmlEncoding encoding );
+<a name="l00325"></a>00325 
+<a name="l00326"></a>00326     <span class="comment">// Get a character, while interpreting entities.</span>
+<a name="l00327"></a>00327     <span class="comment">// The length can be from 0 to 4 bytes.</span>
+<a name="l00328"></a>00328     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* GetChar( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, <span class="keywordtype">char</span>* _value, <span class="keywordtype">int</span>* length, TiXmlEncoding encoding )
+<a name="l00329"></a>00329     {
+<a name="l00330"></a>00330         assert( p );
+<a name="l00331"></a>00331         <span class="keywordflow">if</span> ( encoding == TIXML_ENCODING_UTF8 )
+<a name="l00332"></a>00332         {
+<a name="l00333"></a>00333             *length = utf8ByteTable[ *((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)p) ];
+<a name="l00334"></a>00334             assert( *length &gt;= 0 &amp;&amp; *length &lt; 5 );
+<a name="l00335"></a>00335         }
+<a name="l00336"></a>00336         <span class="keywordflow">else</span>
+<a name="l00337"></a>00337         {
+<a name="l00338"></a>00338             *length = 1;
+<a name="l00339"></a>00339         }
+<a name="l00340"></a>00340 
+<a name="l00341"></a>00341         <span class="keywordflow">if</span> ( *length == 1 )
+<a name="l00342"></a>00342         {
+<a name="l00343"></a>00343             <span class="keywordflow">if</span> ( *p == <span class="charliteral">'&amp;'</span> )
+<a name="l00344"></a>00344                 <span class="keywordflow">return</span> GetEntity( p, _value, length, encoding );
+<a name="l00345"></a>00345             *_value = *p;
+<a name="l00346"></a>00346             <span class="keywordflow">return</span> p+1;
+<a name="l00347"></a>00347         }
+<a name="l00348"></a>00348         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( *length )
+<a name="l00349"></a>00349         {
+<a name="l00350"></a>00350             <span class="comment">//strncpy( _value, p, *length );    // lots of compilers don't like this function (unsafe),</span>
+<a name="l00351"></a>00351                                                 <span class="comment">// and the null terminator isn't needed</span>
+<a name="l00352"></a>00352             <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; p[i] &amp;&amp; i&lt;*length; ++i ) {
+<a name="l00353"></a>00353                 _value[i] = p[i];
+<a name="l00354"></a>00354             }
+<a name="l00355"></a>00355             <span class="keywordflow">return</span> p + (*length);
+<a name="l00356"></a>00356         }
+<a name="l00357"></a>00357         <span class="keywordflow">else</span>
+<a name="l00358"></a>00358         {
+<a name="l00359"></a>00359             <span class="comment">// Not valid text.</span>
+<a name="l00360"></a>00360             <span class="keywordflow">return</span> 0;
+<a name="l00361"></a>00361         }
+<a name="l00362"></a>00362     }
+<a name="l00363"></a>00363 
+<a name="l00364"></a>00364     <span class="comment">// Return true if the next characters in the stream are any of the endTag sequences.</span>
+<a name="l00365"></a>00365     <span class="comment">// Ignore case only works for english, and should only be relied on when comparing</span>
+<a name="l00366"></a>00366     <span class="comment">// to English words: StringEqual( p, "version", true ) is fine.</span>
+<a name="l00367"></a>00367     <span class="keyword">static</span> <span class="keywordtype">bool</span> StringEqual(    <span class="keyword">const</span> <span class="keywordtype">char</span>* p,
+<a name="l00368"></a>00368                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* endTag,
+<a name="l00369"></a>00369                                 <span class="keywordtype">bool</span> ignoreCase,
+<a name="l00370"></a>00370                                 TiXmlEncoding encoding );
+<a name="l00371"></a>00371 
+<a name="l00372"></a>00372     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* errorString[ TIXML_ERROR_STRING_COUNT ];
+<a name="l00373"></a>00373 
+<a name="l00374"></a>00374     TiXmlCursor location;
+<a name="l00375"></a>00375 
+<a name="l00377"></a><a class="code" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">00377</a>     <span class="keywordtype">void</span>*           <a class="code" href="classTiXmlBase.html#b242c01590191f644569fa89a080d97c">userData</a>;
+<a name="l00378"></a>00378     
+<a name="l00379"></a>00379     <span class="comment">// None of these methods are reliable for any language except English.</span>
+<a name="l00380"></a>00380     <span class="comment">// Good for approximation, not great for accuracy.</span>
+<a name="l00381"></a>00381     <span class="keyword">static</span> <span class="keywordtype">int</span> IsAlpha( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> anyByte, TiXmlEncoding encoding );
+<a name="l00382"></a>00382     <span class="keyword">static</span> <span class="keywordtype">int</span> IsAlphaNum( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> anyByte, TiXmlEncoding encoding );
+<a name="l00383"></a>00383     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> ToLower( <span class="keywordtype">int</span> v, TiXmlEncoding encoding )
+<a name="l00384"></a>00384     {
+<a name="l00385"></a>00385         <span class="keywordflow">if</span> ( encoding == TIXML_ENCODING_UTF8 )
+<a name="l00386"></a>00386         {
+<a name="l00387"></a>00387             <span class="keywordflow">if</span> ( v &lt; 128 ) <span class="keywordflow">return</span> tolower( v );
+<a name="l00388"></a>00388             <span class="keywordflow">return</span> v;
+<a name="l00389"></a>00389         }
+<a name="l00390"></a>00390         <span class="keywordflow">else</span>
+<a name="l00391"></a>00391         {
+<a name="l00392"></a>00392             <span class="keywordflow">return</span> tolower( v );
+<a name="l00393"></a>00393         }
+<a name="l00394"></a>00394     }
+<a name="l00395"></a>00395     <span class="keyword">static</span> <span class="keywordtype">void</span> ConvertUTF32ToUTF8( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> input, <span class="keywordtype">char</span>* output, <span class="keywordtype">int</span>* length );
+<a name="l00396"></a>00396 
+<a name="l00397"></a>00397 <span class="keyword">private</span>:
+<a name="l00398"></a>00398     <a class="code" href="classTiXmlBase.html">TiXmlBase</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlBase.html">TiXmlBase</a>&amp; );              <span class="comment">// not implemented.</span>
+<a name="l00399"></a>00399     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlBase.html">TiXmlBase</a>&amp; base );    <span class="comment">// not allowed.</span>
+<a name="l00400"></a>00400 
+<a name="l00401"></a>00401     <span class="keyword">struct </span>Entity
+<a name="l00402"></a>00402     {
+<a name="l00403"></a>00403         <span class="keyword">const</span> <span class="keywordtype">char</span>*     str;
+<a name="l00404"></a>00404         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    strLength;
+<a name="l00405"></a>00405         <span class="keywordtype">char</span>            chr;
+<a name="l00406"></a>00406     };
+<a name="l00407"></a>00407     <span class="keyword">enum</span>
+<a name="l00408"></a>00408     {
+<a name="l00409"></a>00409         NUM_ENTITY = 5,
+<a name="l00410"></a>00410         MAX_ENTITY_LENGTH = 6
+<a name="l00411"></a>00411 
+<a name="l00412"></a>00412     };
+<a name="l00413"></a>00413     <span class="keyword">static</span> Entity entity[ NUM_ENTITY ];
+<a name="l00414"></a>00414     <span class="keyword">static</span> <span class="keywordtype">bool</span> condenseWhiteSpace;
+<a name="l00415"></a>00415 };
+<a name="l00416"></a>00416 
+<a name="l00417"></a>00417 
+<a name="l00424"></a><a class="code" href="classTiXmlNode.html">00424</a> <span class="keyword">class </span><a class="code" href="classTiXmlNode.html">TiXmlNode</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlBase.html">TiXmlBase</a>
+<a name="l00425"></a>00425 {
+<a name="l00426"></a>00426     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>;
+<a name="l00427"></a>00427     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html">TiXmlElement</a>;
+<a name="l00428"></a>00428 
+<a name="l00429"></a>00429 <span class="keyword">public</span>:
+<a name="l00430"></a>00430 <span class="preprocessor">    #ifdef TIXML_USE_STL    </span>
+<a name="l00431"></a>00431 <span class="preprocessor"></span>
+<a name="l00435"></a>00435         <span class="keyword">friend</span> std::istream&amp; <a class="code" href="classTiXmlNode.html#b57bd426563c926844f65a78412e18b9">operator &gt;&gt; </a>(std::istream&amp; in, <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; base);
+<a name="l00436"></a>00436 
+<a name="l00453"></a>00453         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt; </a>(std::ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; base);
+<a name="l00454"></a>00454 
+<a name="l00456"></a>00456         <span class="keyword">friend</span> std::string&amp; <a class="code" href="classTiXmlNode.html#86cd49cfb17a844c0010b3136ac966c7">operator&lt;&lt; </a>(std::string&amp; out, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; base );
+<a name="l00457"></a>00457 
+<a name="l00458"></a>00458 <span class="preprocessor">    #endif</span>
+<a name="l00459"></a>00459 <span class="preprocessor"></span>
+<a name="l00463"></a><a class="code" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">00463</a>     <span class="keyword">enum</span> <a class="code" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a>
+<a name="l00464"></a>00464     {
+<a name="l00465"></a>00465         DOCUMENT,
+<a name="l00466"></a>00466         ELEMENT,
+<a name="l00467"></a>00467         COMMENT,
+<a name="l00468"></a>00468         UNKNOWN,
+<a name="l00469"></a>00469         TEXT,
+<a name="l00470"></a>00470         DECLARATION,
+<a name="l00471"></a>00471         TYPECOUNT
+<a name="l00472"></a>00472     };
+<a name="l00473"></a>00473 
+<a name="l00474"></a>00474     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlNode.html">TiXmlNode</a>();
+<a name="l00475"></a>00475 
+<a name="l00488"></a><a class="code" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">00488</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlNode.html#77943eb90d12c2892b1337a9f5918b41">Value</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value.c_str (); }
+<a name="l00489"></a>00489 
+<a name="l00490"></a>00490 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00491"></a>00491 <span class="preprocessor"></span>
+<a name="l00495"></a><a class="code" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">00495</a>     <span class="keyword">const</span> std::string&amp; <a class="code" href="classTiXmlNode.html#6d9e505619d39bf50bfd9609c9169ea5">ValueStr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }
+<a name="l00496"></a>00496 <span class="preprocessor">    #endif</span>
+<a name="l00497"></a>00497 <span class="preprocessor"></span>
+<a name="l00498"></a>00498     <span class="keyword">const</span> TIXML_STRING&amp; ValueTStr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }
+<a name="l00499"></a>00499 
+<a name="l00509"></a><a class="code" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">00509</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * _value) { value = _value;}
+<a name="l00510"></a>00510 
+<a name="l00511"></a>00511 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00513"></a><a class="code" href="classTiXmlNode.html#2598d5f448042c1abbeae4503dd45ff2">00513</a> <span class="preprocessor">    void SetValue( const std::string&amp; _value )  { value = _value; }</span>
+<a name="l00514"></a>00514 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00515"></a>00515 <span class="preprocessor"></span>
+<a name="l00517"></a>00517     <span class="keywordtype">void</span> <a class="code" href="classTiXmlNode.html#708e7f953df61d4d2d12f73171550a4b">Clear</a>();
+<a name="l00518"></a>00518 
+<a name="l00520"></a><a class="code" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">00520</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()                         { <span class="keywordflow">return</span> parent; }
+<a name="l00521"></a>00521     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#b643043132ffd794f8602685d34a982e">Parent</a>()<span class="keyword"> const             </span>{ <span class="keywordflow">return</span> parent; }
+<a name="l00522"></a>00522 
+<a name="l00523"></a><a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">00523</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>()<span class="keyword">   const       </span>{ <span class="keywordflow">return</span> firstChild; }  
+<a name="l00524"></a>00524     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>()                     { <span class="keywordflow">return</span> firstChild; }
+<a name="l00525"></a>00525     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;            
+<a name="l00526"></a>00526 
+<a name="l00527"></a><a class="code" href="classTiXmlNode.html#bc8bf32be6419ec453a731868de19554">00527</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00528"></a>00528         <span class="comment">// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)</span>
+<a name="l00529"></a>00529         <span class="comment">// call the method, cast the return back to non-const.</span>
+<a name="l00530"></a>00530         <span class="keywordflow">return</span> const_cast&lt; TiXmlNode* &gt; ((const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;FirstChild( _value ));
+<a name="l00531"></a>00531     }
+<a name="l00532"></a>00532     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* LastChild()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> lastChild; }       
+<a name="l00533"></a><a class="code" href="classTiXmlNode.html#6432d2b2495f6caf9cb4278df706a031">00533</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* LastChild()  { <span class="keywordflow">return</span> lastChild; }
+<a name="l00534"></a>00534     
+<a name="l00535"></a>00535     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* LastChild( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;         
+<a name="l00536"></a><a class="code" href="classTiXmlNode.html#bad5bf1059c48127b958711ef89e8e5d">00536</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* LastChild( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00537"></a>00537         <span class="keywordflow">return</span> const_cast&lt; TiXmlNode* &gt; ((const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;LastChild( _value ));
+<a name="l00538"></a>00538     }
+<a name="l00539"></a>00539 
+<a name="l00540"></a>00540 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00541"></a><a class="code" href="classTiXmlNode.html#07f6200a5956c723c5b52d70f29c46f6">00541</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const  </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a> (_value.c_str ());    }   
+<a name="l00542"></a><a class="code" href="classTiXmlNode.html#10d2669ccb5e29e02fcb0e4408685ef6">00542</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )              {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#44c8eee26bbe2d1b2762038df9dde2f0">FirstChild</a> (_value.c_str ());    }   
+<a name="l00543"></a><a class="code" href="classTiXmlNode.html#256d0cdbfcfeccae83f3a1c9747a8b63">00543</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* LastChild( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const   </span>{   <span class="keywordflow">return</span> LastChild (_value.c_str ()); }   
+<a name="l00544"></a><a class="code" href="classTiXmlNode.html#69772c9202f70553f940b15c06b07be3">00544</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* LastChild( <span class="keyword">const</span> std::string&amp; _value )               {   <span class="keywordflow">return</span> LastChild (_value.c_str ()); }   
+<a name="l00545"></a>00545 <span class="preprocessor">    #endif</span>
+<a name="l00546"></a>00546 <span class="preprocessor"></span>
+<a name="l00563"></a>00563     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* previous ) <span class="keyword">const</span>;
+<a name="l00564"></a>00564     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* previous ) {
+<a name="l00565"></a>00565         <span class="keywordflow">return</span> const_cast&lt; TiXmlNode* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;IterateChildren( previous ) );
+<a name="l00566"></a>00566     }
+<a name="l00567"></a>00567 
+<a name="l00569"></a>00569     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* previous ) <span class="keyword">const</span>;
+<a name="l00570"></a>00570     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* previous ) {
+<a name="l00571"></a>00571         <span class="keywordflow">return</span> const_cast&lt; TiXmlNode* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;IterateChildren( _value, previous ) );
+<a name="l00572"></a>00572     }
+<a name="l00573"></a>00573 
+<a name="l00574"></a>00574 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00575"></a><a class="code" href="classTiXmlNode.html#1cbaaf8e82c09ad763d52616d75724df">00575</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* previous )<span class="keyword"> const  </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a> (_value.c_str (), previous); }   
+<a name="l00576"></a><a class="code" href="classTiXmlNode.html#16e9ad53e2f5445b14bf325c90aa862c">00576</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* previous ) {    <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#8621196ba3705fa226bef4a761cc51b6">IterateChildren</a> (_value.c_str (), previous); }   
+<a name="l00577"></a>00577 <span class="preprocessor">    #endif</span>
+<a name="l00578"></a>00578 <span class="preprocessor"></span>
+<a name="l00582"></a>00582     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#d7d4630e1a2a916edda16be22448a8ba">InsertEndChild</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; addThis );
+<a name="l00583"></a>00583 
+<a name="l00584"></a>00584 
+<a name="l00594"></a>00594     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#5d29442ae46de6d0168429156197bfc6">LinkEndChild</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* addThis );
+<a name="l00595"></a>00595 
+<a name="l00599"></a>00599     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#0c146fa2fff0157b681594102f48cbc7">InsertBeforeChild</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* beforeThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; addThis );
+<a name="l00600"></a>00600 
+<a name="l00604"></a>00604     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#d9b75e54ec19301c8b4d5ff583d0b3d5">InsertAfterChild</a>(  <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* afterThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; addThis );
+<a name="l00605"></a>00605 
+<a name="l00609"></a>00609     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#0c49e739a17b9938050c22cd89617fbd">ReplaceChild</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* replaceThis, <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; withThis );
+<a name="l00610"></a>00610 
+<a name="l00612"></a>00612     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#e19d8510efc90596552f4feeac9a8fbf">RemoveChild</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* removeThis );
+<a name="l00613"></a>00613 
+<a name="l00615"></a><a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">00615</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>()<span class="keyword"> const            </span>{ <span class="keywordflow">return</span> prev; }
+<a name="l00616"></a>00616     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>()                        { <span class="keywordflow">return</span> prev; }
+<a name="l00617"></a>00617 
+<a name="l00619"></a>00619     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00620"></a>00620     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *_prev ) {
+<a name="l00621"></a>00621         <span class="keywordflow">return</span> const_cast&lt; TiXmlNode* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;PreviousSibling( _prev ) );
+<a name="l00622"></a>00622     }
+<a name="l00623"></a>00623 
+<a name="l00624"></a>00624 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00625"></a><a class="code" href="classTiXmlNode.html#658276f57d35d5d4256d1dc1a2c398ab">00625</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a> (_value.c_str ());   }   
+<a name="l00626"></a><a class="code" href="classTiXmlNode.html#cc8a0434c7f401d4a3b6dee77c1a5912">00626</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a>( <span class="keyword">const</span> std::string&amp; _value )             {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#c2cd892768726270e511b2ab32de4d10">PreviousSibling</a> (_value.c_str ());   }   
+<a name="l00627"></a><a class="code" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9">00627</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>( <span class="keyword">const</span> std::string&amp; _value)<span class="keyword"> const      </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a> (_value.c_str ());   }   
+<a name="l00628"></a><a class="code" href="classTiXmlNode.html#1757c1f4d01e8c9596ffdbd561c76aea">00628</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>( <span class="keyword">const</span> std::string&amp; _value)                  {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a> (_value.c_str ());   }   
+<a name="l00629"></a>00629 <span class="preprocessor">    #endif</span>
+<a name="l00630"></a>00630 <span class="preprocessor"></span>
+<a name="l00632"></a><a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">00632</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>()<span class="keyword"> const                </span>{ <span class="keywordflow">return</span> next; }
+<a name="l00633"></a>00633     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>()                            { <span class="keywordflow">return</span> next; }
+<a name="l00634"></a>00634 
+<a name="l00636"></a>00636     <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00637"></a>00637     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#f854baeba384f5fe9859f5aee03b548e">NextSibling</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _next ) {
+<a name="l00638"></a>00638         <span class="keywordflow">return</span> const_cast&lt; TiXmlNode* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;NextSibling( _next ) );
+<a name="l00639"></a>00639     }
+<a name="l00640"></a>00640 
+<a name="l00645"></a>00645     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() <span class="keyword">const</span>;
+<a name="l00646"></a>00646     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>() {
+<a name="l00647"></a>00647         <span class="keywordflow">return</span> const_cast&lt; TiXmlElement* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;NextSiblingElement() );
+<a name="l00648"></a>00648     }
+<a name="l00649"></a>00649 
+<a name="l00654"></a>00654     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * ) <span class="keyword">const</span>;
+<a name="l00655"></a>00655     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *_next ) {
+<a name="l00656"></a>00656         <span class="keywordflow">return</span> const_cast&lt; TiXmlElement* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;NextSiblingElement( _next ) );
+<a name="l00657"></a>00657     }
+<a name="l00658"></a>00658 
+<a name="l00659"></a>00659 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00660"></a><a class="code" href="classTiXmlNode.html#7572d0af9d1e696ee3f05d8bb5ebb463">00660</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>( <span class="keyword">const</span> std::string&amp; _value)<span class="keyword"> const    </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a> (_value.c_str ());    }   
+<a name="l00661"></a><a class="code" href="classTiXmlNode.html#506958e34406729a4e4c5326ea39d081">00661</a>     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a>( <span class="keyword">const</span> std::string&amp; _value)                {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#73acf929d49d10bd0e5fb3d31b0372d1">NextSiblingElement</a> (_value.c_str ());    }   
+<a name="l00662"></a>00662 <span class="preprocessor">    #endif</span>
+<a name="l00663"></a>00663 <span class="preprocessor"></span>
+<a name="l00665"></a>00665     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() <span class="keyword">const</span>;
+<a name="l00666"></a>00666     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>() {
+<a name="l00667"></a>00667         <span class="keywordflow">return</span> const_cast&lt; TiXmlElement* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;FirstChildElement() );
+<a name="l00668"></a>00668     }
+<a name="l00669"></a>00669 
+<a name="l00671"></a>00671     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) <span class="keyword">const</span>;
+<a name="l00672"></a>00672     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _value ) {
+<a name="l00673"></a>00673         <span class="keywordflow">return</span> const_cast&lt; TiXmlElement* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;FirstChildElement( _value ) );
+<a name="l00674"></a>00674     }
+<a name="l00675"></a>00675 
+<a name="l00676"></a>00676 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00677"></a><a class="code" href="classTiXmlNode.html#327ad4bbd90073c5dfc931b07314f5f7">00677</a> <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const    </span>{   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a> (_value.c_str ()); }   
+<a name="l00678"></a><a class="code" href="classTiXmlNode.html#7f1d7291880534c1e5cdeb392d8c1f45">00678</a>     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )                {   <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a> (_value.c_str ()); }   
+<a name="l00679"></a>00679 <span class="preprocessor">    #endif</span>
+<a name="l00680"></a>00680 <span class="preprocessor"></span>
+<a name="l00685"></a><a class="code" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">00685</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlNode.html#57b99d5c97d67a42b9752f5210a1ba5e">Type</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> type; }
+<a name="l00686"></a>00686 
+<a name="l00690"></a>00690     <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>* <a class="code" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() <span class="keyword">const</span>;
+<a name="l00691"></a>00691     <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>* <a class="code" href="classTiXmlNode.html#80e397fa973cf5323e33b07154b024f3">GetDocument</a>() {
+<a name="l00692"></a>00692         <span class="keywordflow">return</span> const_cast&lt; TiXmlDocument* &gt;( (const_cast&lt; const TiXmlNode* &gt;(<span class="keyword">this</span>))-&gt;GetDocument() );
+<a name="l00693"></a>00693     }
+<a name="l00694"></a>00694 
+<a name="l00696"></a><a class="code" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">00696</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#eed21ad30630ef6e7faf096127edc9f3">NoChildren</a>()<span class="keyword"> const                     </span>{ <span class="keywordflow">return</span> !firstChild; }
+<a name="l00697"></a>00697 
+<a name="l00698"></a><a class="code" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">00698</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>*    <a class="code" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00699"></a><a class="code" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">00699</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>*     <a class="code" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00700"></a><a class="code" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">00700</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>*     <a class="code" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00701"></a><a class="code" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">00701</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>*     <a class="code" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00702"></a><a class="code" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">00702</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>*        <a class="code" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>()<span class="keyword">        const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00703"></a><a class="code" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">00703</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>* <a class="code" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; } 
+<a name="l00704"></a>00704 
+<a name="l00705"></a><a class="code" href="classTiXmlNode.html#6a4c8ac28ee7a745d059db6691e03bae">00705</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>*          <a class="code" href="classTiXmlNode.html#8a4cda4b15c29f64cff419309aebed08">ToDocument</a>()    { <span class="keywordflow">return</span> 0; } 
+<a name="l00706"></a><a class="code" href="classTiXmlNode.html#a65d000223187d22a4dcebd7479e9ebc">00706</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>*           <a class="code" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00707"></a><a class="code" href="classTiXmlNode.html#383e06a0787f7063953934867990f849">00707</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>*           <a class="code" href="classTiXmlNode.html#a0a5086f9eaee910bbfdc7f975e26574">ToComment</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00708"></a><a class="code" href="classTiXmlNode.html#06de5af852668c7e4af0d09c205f0b0d">00708</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>*           <a class="code" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>()     { <span class="keywordflow">return</span> 0; } 
+<a name="l00709"></a><a class="code" href="classTiXmlNode.html#3ddfbcac78fbea041fad57e5c6d60a03">00709</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>*              <a class="code" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>()        { <span class="keywordflow">return</span> 0; } 
+<a name="l00710"></a><a class="code" href="classTiXmlNode.html#4027136ca820ff4a636b607231b6a6df">00710</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>*       <a class="code" href="classTiXmlNode.html#9f43e6984fc7d4afd6eb32714c6b7b72">ToDeclaration</a>() { <span class="keywordflow">return</span> 0; } 
+<a name="l00711"></a>00711 
+<a name="l00715"></a>00715     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlNode.html#4508cc3a2d7a98e96a54cc09c37a78a4">Clone</a>() <span class="keyword">const </span>= 0;
+<a name="l00716"></a>00716 
+<a name="l00739"></a>00739     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlNode.html#cc0f88b7462c6cb73809d410a4f5bb86">Accept</a>( <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>* visitor ) <span class="keyword">const </span>= 0;
+<a name="l00740"></a>00740 
+<a name="l00741"></a>00741 <span class="keyword">protected</span>:
+<a name="l00742"></a>00742     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a> _type );
+<a name="l00743"></a>00743 
+<a name="l00744"></a>00744     <span class="comment">// Copy to the allocated object. Shared functionality between Clone, Copy constructor,</span>
+<a name="l00745"></a>00745     <span class="comment">// and the assignment operator.</span>
+<a name="l00746"></a>00746     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* target ) <span class="keyword">const</span>;
+<a name="l00747"></a>00747 
+<a name="l00748"></a>00748 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00749"></a>00749 <span class="preprocessor"></span>        <span class="comment">// The real work of the input operator.</span>
+<a name="l00750"></a>00750     <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+<a name="l00751"></a>00751 <span class="preprocessor">    #endif</span>
+<a name="l00752"></a>00752 <span class="preprocessor"></span>
+<a name="l00753"></a>00753     <span class="comment">// Figure out what is at *p, and parse it. Returns null if it is not an xml node.</span>
+<a name="l00754"></a>00754     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* Identify( <span class="keyword">const</span> <span class="keywordtype">char</span>* start, TiXmlEncoding encoding );
+<a name="l00755"></a>00755 
+<a name="l00756"></a>00756     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>*      parent;
+<a name="l00757"></a>00757     <a class="code" href="classTiXmlNode.html#836eded4920ab9e9ef28496f48cd95a2">NodeType</a>        type;
+<a name="l00758"></a>00758 
+<a name="l00759"></a>00759     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>*      firstChild;
+<a name="l00760"></a>00760     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>*      lastChild;
+<a name="l00761"></a>00761 
+<a name="l00762"></a>00762     TIXML_STRING    value;
+<a name="l00763"></a>00763 
+<a name="l00764"></a>00764     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>*      prev;
+<a name="l00765"></a>00765     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>*      next;
+<a name="l00766"></a>00766 
+<a name="l00767"></a>00767 <span class="keyword">private</span>:
+<a name="l00768"></a>00768     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; );              <span class="comment">// not implemented.</span>
+<a name="l00769"></a>00769     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>&amp; base );    <span class="comment">// not allowed.</span>
+<a name="l00770"></a>00770 };
+<a name="l00771"></a>00771 
+<a name="l00772"></a>00772 
+<a name="l00780"></a><a class="code" href="classTiXmlAttribute.html">00780</a> <span class="keyword">class </span><a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlBase.html">TiXmlBase</a>
+<a name="l00781"></a>00781 {
+<a name="l00782"></a>00782     <span class="keyword">friend</span> <span class="keyword">class </span>TiXmlAttributeSet;
+<a name="l00783"></a>00783 
+<a name="l00784"></a>00784 <span class="keyword">public</span>:
+<a name="l00786"></a><a class="code" href="classTiXmlAttribute.html#9cfa3c8179873fd485d83003b114f8e1">00786</a>     <a class="code" href="classTiXmlAttribute.html#9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>() : <a class="code" href="classTiXmlBase.html">TiXmlBase</a>()
+<a name="l00787"></a>00787     {
+<a name="l00788"></a>00788         document = 0;
+<a name="l00789"></a>00789         prev = next = 0;
+<a name="l00790"></a>00790     }
+<a name="l00791"></a>00791 
+<a name="l00792"></a>00792 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00794"></a><a class="code" href="classTiXmlAttribute.html#052213522caac3979960e0714063861d">00794</a> <span class="preprocessor">    TiXmlAttribute( const std::string&amp; _name, const std::string&amp; _value )</span>
+<a name="l00795"></a>00795 <span class="preprocessor"></span>    {
+<a name="l00796"></a>00796         name = _name;
+<a name="l00797"></a>00797         value = _value;
+<a name="l00798"></a>00798         document = 0;
+<a name="l00799"></a>00799         prev = next = 0;
+<a name="l00800"></a>00800     }
+<a name="l00801"></a>00801 <span class="preprocessor">    #endif</span>
+<a name="l00802"></a>00802 <span class="preprocessor"></span>
+<a name="l00804"></a><a class="code" href="classTiXmlAttribute.html#759d0b76fb8fcf765ecab243bc14f05e">00804</a>     <a class="code" href="classTiXmlAttribute.html#9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * _name, <span class="keyword">const</span> <span class="keywordtype">char</span> * _value )
+<a name="l00805"></a>00805     {
+<a name="l00806"></a>00806         name = _name;
+<a name="l00807"></a>00807         value = _value;
+<a name="l00808"></a>00808         document = 0;
+<a name="l00809"></a>00809         prev = next = 0;
+<a name="l00810"></a>00810     }
+<a name="l00811"></a>00811 
+<a name="l00812"></a><a class="code" href="classTiXmlAttribute.html#298a57287d305904ba6bd96ae6f78d3d">00812</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>*     <a class="code" href="classTiXmlAttribute.html#298a57287d305904ba6bd96ae6f78d3d">Name</a>()<span class="keyword">  const       </span>{ <span class="keywordflow">return</span> name.c_str(); }        
+<a name="l00813"></a><a class="code" href="classTiXmlAttribute.html#0f874490eac8ca00ee0070765d0e97e3">00813</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>*     <a class="code" href="classTiXmlAttribute.html#0f874490eac8ca00ee0070765d0e97e3">Value</a>()<span class="keyword"> const       </span>{ <span class="keywordflow">return</span> value.c_str(); }       
+<a name="l00814"></a>00814 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00815"></a><a class="code" href="classTiXmlAttribute.html#87705c3ccf9ee9417beb4f7cbacd4d33">00815</a> <span class="preprocessor"></span>    <span class="keyword">const</span> std::string&amp; <a class="code" href="classTiXmlAttribute.html#87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value; }               
+<a name="l00816"></a>00816 <span class="preprocessor">    #endif</span>
+<a name="l00817"></a>00817 <span class="preprocessor"></span>    <span class="keywordtype">int</span>             <a class="code" href="classTiXmlAttribute.html#a1a20ad59dc7e89a0ab265396360d50f">IntValue</a>() <span class="keyword">const</span>;                                   
+<a name="l00818"></a>00818     <span class="keywordtype">double</span>          <a class="code" href="classTiXmlAttribute.html#2880ddef53fc7522c99535273954d230">DoubleValue</a>() <span class="keyword">const</span>;                                
+<a name="l00819"></a>00819 
+<a name="l00820"></a>00820     <span class="comment">// Get the tinyxml string representation</span>
+<a name="l00821"></a>00821     <span class="keyword">const</span> TIXML_STRING&amp; NameTStr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name; }
+<a name="l00822"></a>00822 
+<a name="l00832"></a>00832     <span class="keywordtype">int</span> <a class="code" href="classTiXmlAttribute.html#d6c93088ee21af41a107931223339344">QueryIntValue</a>( <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l00834"></a>00834     <span class="keywordtype">int</span> <a class="code" href="classTiXmlAttribute.html#c87b2a8489906a5d7aa2875f20be3513">QueryDoubleValue</a>( <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l00835"></a>00835 
+<a name="l00836"></a><a class="code" href="classTiXmlAttribute.html#b7fa3d21ff8d7c5764cf9af15b667a99">00836</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#b7fa3d21ff8d7c5764cf9af15b667a99">SetName</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name )   { name = _name; }               
+<a name="l00837"></a><a class="code" href="classTiXmlAttribute.html#2dae44178f668b3cb48101be4f2236a0">00837</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#2dae44178f668b3cb48101be4f2236a0">SetValue</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _value ) { value = _value; }             
+<a name="l00838"></a>00838 
+<a name="l00839"></a>00839     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#7e065df640116a62ea4f4b7da5449cc8">SetIntValue</a>( <span class="keywordtype">int</span> _value );                                     
+<a name="l00840"></a>00840     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#0316da31373496c4368ad549bf711394">SetDoubleValue</a>( <span class="keywordtype">double</span> _value );                               
+<a name="l00841"></a>00841 
+<a name="l00842"></a>00842 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00844"></a><a class="code" href="classTiXmlAttribute.html#b296ff0c9a8c701055cd257a8a976e57">00844</a> <span class="preprocessor">    void SetName( const std::string&amp; _name )    { name = _name; }   </span>
+<a name="l00846"></a><a class="code" href="classTiXmlAttribute.html#b43f67a0cc3ec1d80e62606500f0925f">00846</a> <span class="preprocessor">    void SetValue( const std::string&amp; _value )  { value = _value; }</span>
+<a name="l00847"></a>00847 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00848"></a>00848 <span class="preprocessor"></span>
+<a name="l00850"></a>00850     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#1c78e92e223a40843f644ba48ef69f67">Next</a>() <span class="keyword">const</span>;
+<a name="l00851"></a>00851     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#1c78e92e223a40843f644ba48ef69f67">Next</a>() {
+<a name="l00852"></a>00852         <span class="keywordflow">return</span> const_cast&lt; TiXmlAttribute* &gt;( (const_cast&lt; const TiXmlAttribute* &gt;(<span class="keyword">this</span>))-&gt;Next() ); 
+<a name="l00853"></a>00853     }
+<a name="l00854"></a>00854 
+<a name="l00856"></a>00856     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a>() <span class="keyword">const</span>;
+<a name="l00857"></a>00857     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlAttribute.html#6ebbfe333fe76cd834bd6cbcca3130cf">Previous</a>() {
+<a name="l00858"></a>00858         <span class="keywordflow">return</span> const_cast&lt; TiXmlAttribute* &gt;( (const_cast&lt; const TiXmlAttribute* &gt;(<span class="keyword">this</span>))-&gt;Previous() ); 
+<a name="l00859"></a>00859     }
+<a name="l00860"></a>00860 
+<a name="l00861"></a>00861     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>&amp; rhs )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rhs.<a class="code" href="classTiXmlAttribute.html#fcbe165f33f08cf9b24daa33f0ee951a">name</a> == name; }
+<a name="l00862"></a>00862     <span class="keywordtype">bool</span> operator&lt;( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>&amp; rhs )<span class="keyword">  const </span>{ <span class="keywordflow">return</span> name &lt; rhs.<a class="code" href="classTiXmlAttribute.html#fcbe165f33f08cf9b24daa33f0ee951a">name</a>; }
+<a name="l00863"></a>00863     <span class="keywordtype">bool</span> operator&gt;( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>&amp; rhs )<span class="keyword">  const </span>{ <span class="keywordflow">return</span> name &gt; rhs.<a class="code" href="classTiXmlAttribute.html#fcbe165f33f08cf9b24daa33f0ee951a">name</a>; }
+<a name="l00864"></a>00864 
+<a name="l00865"></a>00865     <span class="comment">/*  Attribute parsing starts: first letter of the name</span>
+<a name="l00866"></a>00866 <span class="comment">                         returns: the next char after the value end quote</span>
+<a name="l00867"></a>00867 <span class="comment">    */</span>
+<a name="l00868"></a>00868     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l00869"></a>00869 
+<a name="l00870"></a>00870     <span class="comment">// Prints this Attribute to a FILE stream.</span>
+<a name="l00871"></a><a class="code" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">00871</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth )<span class="keyword"> const </span>{
+<a name="l00872"></a>00872         <a class="code" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">Print</a>( cfile, depth, 0 );
+<a name="l00873"></a>00873     }
+<a name="l00874"></a>00874     <span class="keywordtype">void</span> <a class="code" href="classTiXmlAttribute.html#cc04956c1d5c4c31fe74f7a7528d109a">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth, TIXML_STRING* str ) <span class="keyword">const</span>;
+<a name="l00875"></a>00875 
+<a name="l00876"></a>00876     <span class="comment">// [internal use]</span>
+<a name="l00877"></a>00877     <span class="comment">// Set the document pointer so the attribute can report errors.</span>
+<a name="l00878"></a>00878     <span class="keywordtype">void</span> SetDocument( <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>* doc )  { document = doc; }
+<a name="l00879"></a>00879 
+<a name="l00880"></a>00880 <span class="keyword">private</span>:
+<a name="l00881"></a>00881     <a class="code" href="classTiXmlAttribute.html#9cfa3c8179873fd485d83003b114f8e1">TiXmlAttribute</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>&amp; );                <span class="comment">// not implemented.</span>
+<a name="l00882"></a>00882     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>&amp; base );   <span class="comment">// not allowed.</span>
+<a name="l00883"></a>00883 
+<a name="l00884"></a>00884     <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>*  document;   <span class="comment">// A pointer back to a document, for error reporting.</span>
+<a name="l00885"></a>00885     TIXML_STRING name;
+<a name="l00886"></a>00886     TIXML_STRING value;
+<a name="l00887"></a>00887     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* prev;
+<a name="l00888"></a>00888     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* next;
+<a name="l00889"></a>00889 };
+<a name="l00890"></a>00890 
+<a name="l00891"></a>00891 
+<a name="l00892"></a>00892 <span class="comment">/*  A class used to manage a group of attributes.</span>
+<a name="l00893"></a>00893 <span class="comment">    It is only used internally, both by the ELEMENT and the DECLARATION.</span>
+<a name="l00894"></a>00894 <span class="comment">    </span>
+<a name="l00895"></a>00895 <span class="comment">    The set can be changed transparent to the Element and Declaration</span>
+<a name="l00896"></a>00896 <span class="comment">    classes that use it, but NOT transparent to the Attribute</span>
+<a name="l00897"></a>00897 <span class="comment">    which has to implement a next() and previous() method. Which makes</span>
+<a name="l00898"></a>00898 <span class="comment">    it a bit problematic and prevents the use of STL.</span>
+<a name="l00899"></a>00899 <span class="comment"></span>
+<a name="l00900"></a>00900 <span class="comment">    This version is implemented with circular lists because:</span>
+<a name="l00901"></a>00901 <span class="comment">        - I like circular lists</span>
+<a name="l00902"></a>00902 <span class="comment">        - it demonstrates some independence from the (typical) doubly linked list.</span>
+<a name="l00903"></a>00903 <span class="comment">*/</span>
+<a name="l00904"></a>00904 <span class="keyword">class </span>TiXmlAttributeSet
+<a name="l00905"></a>00905 {
+<a name="l00906"></a>00906 <span class="keyword">public</span>:
+<a name="l00907"></a>00907     TiXmlAttributeSet();
+<a name="l00908"></a>00908     ~TiXmlAttributeSet();
+<a name="l00909"></a>00909 
+<a name="l00910"></a>00910     <span class="keywordtype">void</span> Add( <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* attribute );
+<a name="l00911"></a>00911     <span class="keywordtype">void</span> Remove( <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* attribute );
+<a name="l00912"></a>00912 
+<a name="l00913"></a>00913     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* First()<span class="keyword">   const   </span>{ <span class="keywordflow">return</span> ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
+<a name="l00914"></a>00914     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* First()                 { <span class="keywordflow">return</span> ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
+<a name="l00915"></a>00915     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* Last()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
+<a name="l00916"></a>00916     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* Last()                  { <span class="keywordflow">return</span> ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
+<a name="l00917"></a>00917 
+<a name="l00918"></a>00918     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>*   Find( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name ) <span class="keyword">const</span>;
+<a name="l00919"></a>00919     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* Find( <span class="keyword">const</span> <span class="keywordtype">char</span>* _name ) {
+<a name="l00920"></a>00920         <span class="keywordflow">return</span> const_cast&lt; TiXmlAttribute* &gt;( (const_cast&lt; const TiXmlAttributeSet* &gt;(<span class="keyword">this</span>))-&gt;Find( _name ) );
+<a name="l00921"></a>00921     }
+<a name="l00922"></a>00922 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00923"></a>00923 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>*   Find( <span class="keyword">const</span> std::string&amp; _name ) <span class="keyword">const</span>;
+<a name="l00924"></a>00924     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* Find( <span class="keyword">const</span> std::string&amp; _name ) {
+<a name="l00925"></a>00925         <span class="keywordflow">return</span> const_cast&lt; TiXmlAttribute* &gt;( (const_cast&lt; const TiXmlAttributeSet* &gt;(<span class="keyword">this</span>))-&gt;Find( _name ) );
+<a name="l00926"></a>00926     }
+<a name="l00927"></a>00927 
+<a name="l00928"></a>00928 <span class="preprocessor">    #endif</span>
+<a name="l00929"></a>00929 <span class="preprocessor"></span>
+<a name="l00930"></a>00930 <span class="keyword">private</span>:
+<a name="l00931"></a>00931     <span class="comment">//*ME:  Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),</span>
+<a name="l00932"></a>00932     <span class="comment">//*ME:  this class must be also use a hidden/disabled copy-constructor !!!</span>
+<a name="l00933"></a>00933     TiXmlAttributeSet( <span class="keyword">const</span> TiXmlAttributeSet&amp; );  <span class="comment">// not allowed</span>
+<a name="l00934"></a>00934     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> TiXmlAttributeSet&amp; ); <span class="comment">// not allowed (as TiXmlAttribute)</span>
+<a name="l00935"></a>00935 
+<a name="l00936"></a>00936     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a> sentinel;
+<a name="l00937"></a>00937 };
+<a name="l00938"></a>00938 
+<a name="l00939"></a>00939 
+<a name="l00944"></a><a class="code" href="classTiXmlElement.html">00944</a> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html">TiXmlElement</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>
+<a name="l00945"></a>00945 {
+<a name="l00946"></a>00946 <span class="keyword">public</span>:
+<a name="l00948"></a>00948     <a class="code" href="classTiXmlElement.html#01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> * in_value);
+<a name="l00949"></a>00949 
+<a name="l00950"></a>00950 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l00952"></a>00952 <span class="preprocessor">    TiXmlElement( const std::string&amp; _value );</span>
+<a name="l00953"></a>00953 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l00954"></a>00954 <span class="preprocessor"></span>
+<a name="l00955"></a>00955     <a class="code" href="classTiXmlElement.html#01bc3ab372d35da08efcbbe65ad90c60">TiXmlElement</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>&amp; );
+<a name="l00956"></a>00956 
+<a name="l00957"></a>00957     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>&amp; base );
+<a name="l00958"></a>00958 
+<a name="l00959"></a>00959     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlElement.html">TiXmlElement</a>();
+<a name="l00960"></a>00960 
+<a name="l00964"></a>00964     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name ) <span class="keyword">const</span>;
+<a name="l00965"></a>00965 
+<a name="l00972"></a>00972     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span>* i ) <span class="keyword">const</span>;
+<a name="l00973"></a>00973 
+<a name="l00980"></a>00980     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">double</span>* d ) <span class="keyword">const</span>;
+<a name="l00981"></a>00981 
+<a name="l00989"></a>00989     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l00991"></a>00991     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l00993"></a><a class="code" href="classTiXmlElement.html#a04d3af11601ef5a5f88295203a843be">00993</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#a04d3af11601ef5a5f88295203a843be">QueryFloatAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">float</span>* _value )<span class="keyword"> const </span>{
+<a name="l00994"></a>00994         <span class="keywordtype">double</span> d;
+<a name="l00995"></a>00995         <span class="keywordtype">int</span> result = <a class="code" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a>( name, &amp;d );
+<a name="l00996"></a>00996         <span class="keywordflow">if</span> ( result == TIXML_SUCCESS ) {
+<a name="l00997"></a>00997             *_value = (float)d;
+<a name="l00998"></a>00998         }
+<a name="l00999"></a>00999         <span class="keywordflow">return</span> result;
+<a name="l01000"></a>01000     }
+<a name="l01001"></a>01001 
+<a name="l01002"></a>01002 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01003"></a>01003 <span class="preprocessor"></span>
+<a name="l01011"></a><a class="code" href="classTiXmlElement.html#e3b9a03b0a56663a40801c7256683576">01011</a>     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt; <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#e3b9a03b0a56663a40801c7256683576">QueryValueAttribute</a>( <span class="keyword">const</span> std::string&amp; name, T* outValue )<span class="keyword"> const</span>
+<a name="l01012"></a>01012 <span class="keyword">    </span>{
+<a name="l01013"></a>01013         <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* node = attributeSet.Find( name );
+<a name="l01014"></a>01014         <span class="keywordflow">if</span> ( !node )
+<a name="l01015"></a>01015             <span class="keywordflow">return</span> TIXML_NO_ATTRIBUTE;
+<a name="l01016"></a>01016 
+<a name="l01017"></a>01017         std::stringstream sstream( node-&gt;<a class="code" href="classTiXmlAttribute.html#87705c3ccf9ee9417beb4f7cbacd4d33">ValueStr</a>() );
+<a name="l01018"></a>01018         sstream &gt;&gt; *outValue;
+<a name="l01019"></a>01019         <span class="keywordflow">if</span> ( !sstream.fail() )
+<a name="l01020"></a>01020             <span class="keywordflow">return</span> TIXML_SUCCESS;
+<a name="l01021"></a>01021         <span class="keywordflow">return</span> TIXML_WRONG_TYPE;
+<a name="l01022"></a>01022     }
+<a name="l01023"></a>01023     <span class="comment">/*</span>
+<a name="l01024"></a>01024 <span class="comment">     This is - in theory - a bug fix for "QueryValueAtribute returns truncated std::string"</span>
+<a name="l01025"></a>01025 <span class="comment">     but template specialization is hard to get working cross-compiler. Leaving the bug for now.</span>
+<a name="l01026"></a>01026 <span class="comment">     </span>
+<a name="l01027"></a>01027 <span class="comment">    // The above will fail for std::string because the space character is used as a seperator.</span>
+<a name="l01028"></a>01028 <span class="comment">    // Specialize for strings. Bug [ 1695429 ] QueryValueAtribute returns truncated std::string</span>
+<a name="l01029"></a>01029 <span class="comment">    template&lt;&gt; int QueryValueAttribute( const std::string&amp; name, std::string* outValue ) const</span>
+<a name="l01030"></a>01030 <span class="comment">    {</span>
+<a name="l01031"></a>01031 <span class="comment">        const TiXmlAttribute* node = attributeSet.Find( name );</span>
+<a name="l01032"></a>01032 <span class="comment">        if ( !node )</span>
+<a name="l01033"></a>01033 <span class="comment">            return TIXML_NO_ATTRIBUTE;</span>
+<a name="l01034"></a>01034 <span class="comment">        *outValue = node-&gt;ValueStr();</span>
+<a name="l01035"></a>01035 <span class="comment">        return TIXML_SUCCESS;</span>
+<a name="l01036"></a>01036 <span class="comment">    }</span>
+<a name="l01037"></a>01037 <span class="comment">    */</span>
+<a name="l01038"></a>01038 <span class="preprocessor">    #endif</span>
+<a name="l01039"></a>01039 <span class="preprocessor"></span>
+<a name="l01043"></a>01043     <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#bf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> <span class="keywordtype">char</span> * _value );
+<a name="l01044"></a>01044 
+<a name="l01045"></a>01045 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01046"></a>01046 <span class="preprocessor"></span>    <span class="keyword">const</span> std::string* <a class="code" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>( <span class="keyword">const</span> std::string&amp; name ) <span class="keyword">const</span>;
+<a name="l01047"></a>01047     <span class="keyword">const</span> std::string* <a class="code" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span>* i ) <span class="keyword">const</span>;
+<a name="l01048"></a>01048     <span class="keyword">const</span> std::string* <a class="code" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d">Attribute</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span>* d ) <span class="keyword">const</span>;
+<a name="l01049"></a>01049     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9">QueryIntAttribute</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span>* _value ) <span class="keyword">const</span>;
+<a name="l01050"></a>01050     <span class="keywordtype">int</span> <a class="code" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7">QueryDoubleAttribute</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span>* _value ) <span class="keyword">const</span>;
+<a name="l01051"></a>01051 
+<a name="l01053"></a>01053     <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#bf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; _value );
+<a name="l01055"></a>01055     <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#bf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span> _value );
+<a name="l01056"></a>01056 <span class="preprocessor">    #endif</span>
+<a name="l01057"></a>01057 <span class="preprocessor"></span>
+<a name="l01061"></a>01061     <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#bf0b3bd7f0e4c746a89ec6e7f101fc32">SetAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <span class="keywordtype">int</span> value );
+<a name="l01062"></a>01062 
+<a name="l01066"></a>01066     <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#0d1dd975d75496778177e35abfe0ec0b">SetDoubleAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <span class="keywordtype">double</span> value );
+<a name="l01067"></a>01067 
+<a name="l01070"></a>01070     <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#56979767deca794376b1dfa69a525b2a">RemoveAttribute</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * name );
+<a name="l01071"></a>01071 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01072"></a><a class="code" href="classTiXmlElement.html#1afa6aea716511326a608e4c05df4f3a">01072</a> <span class="preprocessor"></span>    <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#56979767deca794376b1dfa69a525b2a">RemoveAttribute</a>( <span class="keyword">const</span> std::string&amp; name ) {   <a class="code" href="classTiXmlElement.html#56979767deca794376b1dfa69a525b2a">RemoveAttribute</a> (name.c_str ());    }   
+<a name="l01073"></a>01073 <span class="preprocessor">    #endif</span>
+<a name="l01074"></a>01074 <span class="preprocessor"></span>
+<a name="l01075"></a><a class="code" href="classTiXmlElement.html#516054c9073647d6cb29b6abe9fa0592">01075</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> attributeSet.First(); }        
+<a name="l01076"></a>01076     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#516054c9073647d6cb29b6abe9fa0592">FirstAttribute</a>()                { <span class="keywordflow">return</span> attributeSet.First(); }
+<a name="l01077"></a><a class="code" href="classTiXmlElement.html#86191b49f9177be132b85b14655f1381">01077</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#86191b49f9177be132b85b14655f1381">LastAttribute</a>()<span class="keyword">   const   </span>{ <span class="keywordflow">return</span> attributeSet.Last(); }     
+<a name="l01078"></a>01078     <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* <a class="code" href="classTiXmlElement.html#86191b49f9177be132b85b14655f1381">LastAttribute</a>()                 { <span class="keywordflow">return</span> attributeSet.Last(); }
+<a name="l01079"></a>01079 
+<a name="l01112"></a>01112     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlElement.html#f3282294986cdb216646ea1f67af2c87">GetText</a>() <span class="keyword">const</span>;
+<a name="l01113"></a>01113 
+<a name="l01115"></a>01115     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlElement.html#a464535ea1994db337cb6a8ce4b588b5">Clone</a>() <span class="keyword">const</span>;
+<a name="l01116"></a>01116     <span class="comment">// Print the Element to a FILE stream.</span>
+<a name="l01117"></a>01117     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlElement.html#fbf52736e70fc91ec9d760721d6f4fd2">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01118"></a>01118 
+<a name="l01119"></a>01119     <span class="comment">/*  Attribtue parsing starts: next char past '&lt;'</span>
+<a name="l01120"></a>01120 <span class="comment">                         returns: next char past '&gt;'</span>
+<a name="l01121"></a>01121 <span class="comment">    */</span>
+<a name="l01122"></a>01122     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01123"></a>01123 
+<a name="l01124"></a><a class="code" href="classTiXmlElement.html#c5b8d0e25fa23fd9acbb6d146082901c">01124</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>*     <a class="code" href="classTiXmlElement.html#c5b8d0e25fa23fd9acbb6d146082901c">ToElement</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01125"></a><a class="code" href="classTiXmlElement.html#9def86337ea7a755eb41cac980f60c7a">01125</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>*           <a class="code" href="classTiXmlElement.html#c5b8d0e25fa23fd9acbb6d146082901c">ToElement</a>()           { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01126"></a>01126 
+<a name="l01129"></a>01129     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlElement.html#71a81b2afb0d42be1543d1c404dee6f5">Accept</a>( <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01130"></a>01130 
+<a name="l01131"></a>01131 <span class="keyword">protected</span>:
+<a name="l01132"></a>01132 
+<a name="l01133"></a>01133     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* target ) <span class="keyword">const</span>;
+<a name="l01134"></a>01134     <span class="keywordtype">void</span> ClearThis();   <span class="comment">// like clear, but initializes 'this' object as well</span>
+<a name="l01135"></a>01135 
+<a name="l01136"></a>01136     <span class="comment">// Used to be public [internal use]</span>
+<a name="l01137"></a>01137 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01138"></a>01138 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01139"></a>01139 <span class="preprocessor">    #endif</span>
+<a name="l01140"></a>01140 <span class="preprocessor"></span>    <span class="comment">/*  [internal use]</span>
+<a name="l01141"></a>01141 <span class="comment">        Reads the "value" of the element -- another element, or text.</span>
+<a name="l01142"></a>01142 <span class="comment">        This should terminate with the current end tag.</span>
+<a name="l01143"></a>01143 <span class="comment">    */</span>
+<a name="l01144"></a>01144     <span class="keyword">const</span> <span class="keywordtype">char</span>* ReadValue( <span class="keyword">const</span> <span class="keywordtype">char</span>* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+<a name="l01145"></a>01145 
+<a name="l01146"></a>01146 <span class="keyword">private</span>:
+<a name="l01147"></a>01147 
+<a name="l01148"></a>01148     TiXmlAttributeSet attributeSet;
+<a name="l01149"></a>01149 };
+<a name="l01150"></a>01150 
+<a name="l01151"></a>01151 
+<a name="l01154"></a><a class="code" href="classTiXmlComment.html">01154</a> <span class="keyword">class </span><a class="code" href="classTiXmlComment.html">TiXmlComment</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>
+<a name="l01155"></a>01155 {
+<a name="l01156"></a>01156 <span class="keyword">public</span>:
+<a name="l01158"></a><a class="code" href="classTiXmlComment.html#aa3252031d3e8bd3a2bf51a1c61201b7">01158</a>     <a class="code" href="classTiXmlComment.html#aa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>() : <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>::COMMENT ) {}
+<a name="l01160"></a><a class="code" href="classTiXmlComment.html#37e7802ef17bc03ebe5ae79bf0713d47">01160</a>     <a class="code" href="classTiXmlComment.html#aa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _value ) : <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>::COMMENT ) {
+<a name="l01161"></a>01161         <a class="code" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>( _value );
+<a name="l01162"></a>01162     }
+<a name="l01163"></a>01163     <a class="code" href="classTiXmlComment.html#aa3252031d3e8bd3a2bf51a1c61201b7">TiXmlComment</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>&amp; );
+<a name="l01164"></a>01164     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>&amp; base );
+<a name="l01165"></a>01165 
+<a name="l01166"></a>01166     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlComment.html">TiXmlComment</a>() {}
+<a name="l01167"></a>01167 
+<a name="l01169"></a>01169     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlComment.html#0d6662bdc52488b9e12b3c7a0453d028">Clone</a>() <span class="keyword">const</span>;
+<a name="l01170"></a>01170     <span class="comment">// Write this Comment to a FILE stream.</span>
+<a name="l01171"></a>01171     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlComment.html#6b316527aaa8da0370cd68c22a5a0f5f">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01172"></a>01172 
+<a name="l01173"></a>01173     <span class="comment">/*  Attribtue parsing starts: at the ! of the !--</span>
+<a name="l01174"></a>01174 <span class="comment">                         returns: next char past '&gt;'</span>
+<a name="l01175"></a>01175 <span class="comment">    */</span>
+<a name="l01176"></a>01176     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01177"></a>01177 
+<a name="l01178"></a><a class="code" href="classTiXmlComment.html#00fb4215c20a2399ea05ac9b9e7e68a0">01178</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>*  <a class="code" href="classTiXmlComment.html#00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01179"></a><a class="code" href="classTiXmlComment.html#cc7c7e07e13c23f17797d642981511df">01179</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>*  <a class="code" href="classTiXmlComment.html#00fb4215c20a2399ea05ac9b9e7e68a0">ToComment</a>() { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01180"></a>01180 
+<a name="l01183"></a>01183     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlComment.html#f3ac1b99fbbe9ea4fb6e14146156e43e">Accept</a>( <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01184"></a>01184 
+<a name="l01185"></a>01185 <span class="keyword">protected</span>:
+<a name="l01186"></a>01186     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlComment.html">TiXmlComment</a>* target ) <span class="keyword">const</span>;
+<a name="l01187"></a>01187 
+<a name="l01188"></a>01188     <span class="comment">// used to be public</span>
+<a name="l01189"></a>01189 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01190"></a>01190 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01191"></a>01191 <span class="preprocessor">    #endif</span>
+<a name="l01192"></a>01192 <span class="preprocessor"></span><span class="comment">//  virtual void StreamOut( TIXML_OSTREAM * out ) const;</span>
+<a name="l01193"></a>01193 
+<a name="l01194"></a>01194 <span class="keyword">private</span>:
+<a name="l01195"></a>01195 
+<a name="l01196"></a>01196 };
+<a name="l01197"></a>01197 
+<a name="l01198"></a>01198 
+<a name="l01204"></a><a class="code" href="classTiXmlText.html">01204</a> <span class="keyword">class </span><a class="code" href="classTiXmlText.html">TiXmlText</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>
+<a name="l01205"></a>01205 {
+<a name="l01206"></a>01206     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTiXmlElement.html">TiXmlElement</a>;
+<a name="l01207"></a>01207 <span class="keyword">public</span>:
+<a name="l01212"></a><a class="code" href="classTiXmlText.html#f659e77c6b87d684827f35a8f4895960">01212</a>     <a class="code" href="classTiXmlText.html#f659e77c6b87d684827f35a8f4895960">TiXmlText</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> * initValue ) : <a class="code" href="classTiXmlNode.html">TiXmlNode</a> (<a class="code" href="classTiXmlNode.html">TiXmlNode</a>::TEXT)
+<a name="l01213"></a>01213     {
+<a name="l01214"></a>01214         <a class="code" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>( initValue );
+<a name="l01215"></a>01215         cdata = <span class="keyword">false</span>;
+<a name="l01216"></a>01216     }
+<a name="l01217"></a>01217     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlText.html">TiXmlText</a>() {}
+<a name="l01218"></a>01218 
+<a name="l01219"></a>01219 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01221"></a><a class="code" href="classTiXmlText.html#439792f6183a3d3fb6f2bc2b16fa5691">01221</a> <span class="preprocessor">    TiXmlText( const std::string&amp; initValue ) : TiXmlNode (TiXmlNode::TEXT)</span>
+<a name="l01222"></a>01222 <span class="preprocessor"></span>    {
+<a name="l01223"></a>01223         <a class="code" href="classTiXmlNode.html#2a38329ca5d3f28f98ce932b8299ae90">SetValue</a>( initValue );
+<a name="l01224"></a>01224         cdata = <span class="keyword">false</span>;
+<a name="l01225"></a>01225     }
+<a name="l01226"></a>01226 <span class="preprocessor">    #endif</span>
+<a name="l01227"></a>01227 <span class="preprocessor"></span>
+<a name="l01228"></a>01228     <a class="code" href="classTiXmlText.html#f659e77c6b87d684827f35a8f4895960">TiXmlText</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>&amp; copy ) : <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>::TEXT )   { copy.<a class="code" href="classTiXmlText.html#dcec7d9b6fccfc5777452bb97e6031c1">CopyTo</a>( <span class="keyword">this</span> ); }
+<a name="l01229"></a>01229     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>&amp; base )                             { base.<a class="code" href="classTiXmlText.html#dcec7d9b6fccfc5777452bb97e6031c1">CopyTo</a>( <span class="keyword">this</span> ); }
+<a name="l01230"></a>01230 
+<a name="l01231"></a>01231     <span class="comment">// Write this text object to a FILE stream.</span>
+<a name="l01232"></a>01232     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlText.html#0cafbf6f236c7f02d12b2bffc2b7976b">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01233"></a>01233 
+<a name="l01235"></a><a class="code" href="classTiXmlText.html#d1a6a6b83fa2271022dd97c072a2b586">01235</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlText.html#d1a6a6b83fa2271022dd97c072a2b586">CDATA</a>()<span class="keyword"> const              </span>{ <span class="keywordflow">return</span> cdata; }
+<a name="l01237"></a><a class="code" href="classTiXmlText.html#cb17ff7c5d09b2c839393445a3de5ea9">01237</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlText.html#cb17ff7c5d09b2c839393445a3de5ea9">SetCDATA</a>( <span class="keywordtype">bool</span> _cdata )    { cdata = _cdata; }
+<a name="l01238"></a>01238 
+<a name="l01239"></a>01239     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01240"></a>01240 
+<a name="l01241"></a><a class="code" href="classTiXmlText.html#895bf34ffad17f7439ab2a52b9651648">01241</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>* <a class="code" href="classTiXmlText.html#895bf34ffad17f7439ab2a52b9651648">ToText</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01242"></a><a class="code" href="classTiXmlText.html#e7c3a8fd3e4dbf6c0c4363a943d72f5b">01242</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>*       <a class="code" href="classTiXmlText.html#895bf34ffad17f7439ab2a52b9651648">ToText</a>()       { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01243"></a>01243 
+<a name="l01246"></a>01246     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlText.html#8483d4415ce9de6c4fa8f63d067d5de6">Accept</a>( <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01247"></a>01247 
+<a name="l01248"></a>01248 <span class="keyword">protected</span> :
+<a name="l01250"></a>01250     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlText.html#0c411e93a27537369479d034cc82da3b">Clone</a>() <span class="keyword">const</span>;
+<a name="l01251"></a>01251     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlText.html">TiXmlText</a>* target ) <span class="keyword">const</span>;
+<a name="l01252"></a>01252 
+<a name="l01253"></a>01253     <span class="keywordtype">bool</span> Blank() <span class="keyword">const</span>; <span class="comment">// returns true if all white space and new lines</span>
+<a name="l01254"></a>01254     <span class="comment">// [internal use]</span>
+<a name="l01255"></a>01255 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01256"></a>01256 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01257"></a>01257 <span class="preprocessor">    #endif</span>
+<a name="l01258"></a>01258 <span class="preprocessor"></span>
+<a name="l01259"></a>01259 <span class="keyword">private</span>:
+<a name="l01260"></a>01260     <span class="keywordtype">bool</span> cdata;         <span class="comment">// true if this should be input and output as a CDATA style text element</span>
+<a name="l01261"></a>01261 };
+<a name="l01262"></a>01262 
+<a name="l01263"></a>01263 
+<a name="l01277"></a><a class="code" href="classTiXmlDeclaration.html">01277</a> <span class="keyword">class </span><a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>
+<a name="l01278"></a>01278 {
+<a name="l01279"></a>01279 <span class="keyword">public</span>:
+<a name="l01281"></a><a class="code" href="classTiXmlDeclaration.html#a0484d059bea0ea1acb47c9094382d79">01281</a>     <a class="code" href="classTiXmlDeclaration.html#a0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a>()   : <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>::DECLARATION ) {}
+<a name="l01282"></a>01282 
+<a name="l01283"></a>01283 <span class="preprocessor">#ifdef TIXML_USE_STL</span>
+<a name="l01285"></a>01285 <span class="preprocessor">    TiXmlDeclaration(   const std::string&amp; _version,</span>
+<a name="l01286"></a>01286 <span class="preprocessor"></span>                        <span class="keyword">const</span> std::string&amp; _encoding,
+<a name="l01287"></a>01287                         <span class="keyword">const</span> std::string&amp; _standalone );
+<a name="l01288"></a>01288 <span class="preprocessor">#endif</span>
+<a name="l01289"></a>01289 <span class="preprocessor"></span>
+<a name="l01291"></a>01291     <a class="code" href="classTiXmlDeclaration.html#a0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a>(   <span class="keyword">const</span> <span class="keywordtype">char</span>* _version,
+<a name="l01292"></a>01292                         <span class="keyword">const</span> <span class="keywordtype">char</span>* _encoding,
+<a name="l01293"></a>01293                         <span class="keyword">const</span> <span class="keywordtype">char</span>* _standalone );
+<a name="l01294"></a>01294 
+<a name="l01295"></a>01295     <a class="code" href="classTiXmlDeclaration.html#a0484d059bea0ea1acb47c9094382d79">TiXmlDeclaration</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>&amp; copy );
+<a name="l01296"></a>01296     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>&amp; copy );
+<a name="l01297"></a>01297 
+<a name="l01298"></a>01298     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>() {}
+<a name="l01299"></a>01299 
+<a name="l01301"></a><a class="code" href="classTiXmlDeclaration.html#02ee557b1a4545c3219ed377c103ec76">01301</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#02ee557b1a4545c3219ed377c103ec76">Version</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> version.c_str (); }
+<a name="l01303"></a><a class="code" href="classTiXmlDeclaration.html#5d974231f9e9a2f0542f15f3a46cdb76">01303</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#5d974231f9e9a2f0542f15f3a46cdb76">Encoding</a>()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> encoding.c_str (); }
+<a name="l01305"></a><a class="code" href="classTiXmlDeclaration.html#9ff06afc033d7ef730ec7c6825b97ad9">01305</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTiXmlDeclaration.html#9ff06afc033d7ef730ec7c6825b97ad9">Standalone</a>()<span class="keyword"> const      </span>{ <span class="keywordflow">return</span> standalone.c_str (); }
+<a name="l01306"></a>01306 
+<a name="l01308"></a>01308     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlDeclaration.html#7cf459186040141cda7a180a6585ce2e">Clone</a>() <span class="keyword">const</span>;
+<a name="l01309"></a>01309     <span class="comment">// Print this declaration to a FILE stream.</span>
+<a name="l01310"></a>01310     <span class="keyword">virtual</span> <span class="keywordtype">void</span> Print( FILE* cfile, <span class="keywordtype">int</span> depth, TIXML_STRING* str ) <span class="keyword">const</span>;
+<a name="l01311"></a><a class="code" href="classTiXmlDeclaration.html#bf6303db4bd05b5be554036817ff1cb4">01311</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> Print( FILE* cfile, <span class="keywordtype">int</span> depth )<span class="keyword"> const </span>{
+<a name="l01312"></a>01312         Print( cfile, depth, 0 );
+<a name="l01313"></a>01313     }
+<a name="l01314"></a>01314 
+<a name="l01315"></a>01315     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01316"></a>01316 
+<a name="l01317"></a><a class="code" href="classTiXmlDeclaration.html#1e085d3fefd1dbf5ccdbff729931a967">01317</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>* <a class="code" href="classTiXmlDeclaration.html#1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01318"></a><a class="code" href="classTiXmlDeclaration.html#6bd3d1daddcaeb9543c24bfd090969ce">01318</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>*       <a class="code" href="classTiXmlDeclaration.html#1e085d3fefd1dbf5ccdbff729931a967">ToDeclaration</a>()       { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01319"></a>01319 
+<a name="l01322"></a>01322     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDeclaration.html#22315a535983b86535cdba3458669e3e">Accept</a>( <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>* visitor ) <span class="keyword">const</span>;
+<a name="l01323"></a>01323 
+<a name="l01324"></a>01324 <span class="keyword">protected</span>:
+<a name="l01325"></a>01325     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>* target ) <span class="keyword">const</span>;
+<a name="l01326"></a>01326     <span class="comment">// used to be public</span>
+<a name="l01327"></a>01327 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01328"></a>01328 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01329"></a>01329 <span class="preprocessor">    #endif</span>
+<a name="l01330"></a>01330 <span class="preprocessor"></span>
+<a name="l01331"></a>01331 <span class="keyword">private</span>:
+<a name="l01332"></a>01332 
+<a name="l01333"></a>01333     TIXML_STRING version;
+<a name="l01334"></a>01334     TIXML_STRING encoding;
+<a name="l01335"></a>01335     TIXML_STRING standalone;
+<a name="l01336"></a>01336 };
+<a name="l01337"></a>01337 
+<a name="l01338"></a>01338 
+<a name="l01346"></a><a class="code" href="classTiXmlUnknown.html">01346</a> <span class="keyword">class </span><a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>
+<a name="l01347"></a>01347 {
+<a name="l01348"></a>01348 <span class="keyword">public</span>:
+<a name="l01349"></a>01349     <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>() : <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( TiXmlNode::UNKNOWN )    {}
+<a name="l01350"></a>01350     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>() {}
+<a name="l01351"></a>01351 
+<a name="l01352"></a>01352     <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>&amp; copy ) : <a class="code" href="classTiXmlNode.html">TiXmlNode</a>( TiXmlNode::UNKNOWN )      { copy.<a class="code" href="classTiXmlUnknown.html#08ca7b225a2bcb604d3c72e199d33408">CopyTo</a>( <span class="keyword">this</span> ); }
+<a name="l01353"></a>01353     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>&amp; copy )                                      { copy.<a class="code" href="classTiXmlUnknown.html#08ca7b225a2bcb604d3c72e199d33408">CopyTo</a>( <span class="keyword">this</span> ); }
+<a name="l01354"></a>01354 
+<a name="l01356"></a>01356     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlUnknown.html#0960bb7428b3f341da46244229604d73">Clone</a>() <span class="keyword">const</span>;
+<a name="l01357"></a>01357     <span class="comment">// Print this Unknown to a FILE stream.</span>
+<a name="l01358"></a>01358     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlUnknown.html#31ba089a40fb5a1869750fce09b0bacb">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth ) <span class="keyword">const</span>;
+<a name="l01359"></a>01359 
+<a name="l01360"></a>01360     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Parse( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+<a name="l01361"></a>01361 
+<a name="l01362"></a><a class="code" href="classTiXmlUnknown.html#b0313e5fe77987d746ac1a97a254419d">01362</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>*     <a class="code" href="classTiXmlUnknown.html#b0313e5fe77987d746ac1a97a254419d">ToUnknown</a>()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01363"></a><a class="code" href="classTiXmlUnknown.html#67c9fd22940e8c47f706a72cdd2e332c">01363</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>*           <a class="code" href="classTiXmlUnknown.html#b0313e5fe77987d746ac1a97a254419d">ToUnknown</a>()     { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01364"></a>01364 
+<a name="l01367"></a>01367     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlUnknown.html#d7122e5135581b3c832a1a3217760a93">Accept</a>( <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01368"></a>01368 
+<a name="l01369"></a>01369 <span class="keyword">protected</span>:
+<a name="l01370"></a>01370     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>* target ) <span class="keyword">const</span>;
+<a name="l01371"></a>01371 
+<a name="l01372"></a>01372 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01373"></a>01373 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01374"></a>01374 <span class="preprocessor">    #endif</span>
+<a name="l01375"></a>01375 <span class="preprocessor"></span>
+<a name="l01376"></a>01376 <span class="keyword">private</span>:
+<a name="l01377"></a>01377 
+<a name="l01378"></a>01378 };
+<a name="l01379"></a>01379 
+<a name="l01380"></a>01380 
+<a name="l01385"></a><a class="code" href="classTiXmlDocument.html">01385</a> <span class="keyword">class </span><a class="code" href="classTiXmlDocument.html">TiXmlDocument</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>
+<a name="l01386"></a>01386 {
+<a name="l01387"></a>01387 <span class="keyword">public</span>:
+<a name="l01389"></a>01389     <a class="code" href="classTiXmlDocument.html#9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>();
+<a name="l01391"></a>01391     <a class="code" href="classTiXmlDocument.html#9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * documentName );
+<a name="l01392"></a>01392 
+<a name="l01393"></a>01393 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01395"></a>01395 <span class="preprocessor">    TiXmlDocument( const std::string&amp; documentName );</span>
+<a name="l01396"></a>01396 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l01397"></a>01397 <span class="preprocessor"></span>
+<a name="l01398"></a>01398     <a class="code" href="classTiXmlDocument.html#9f5e84335708fde98400230f9f12659c">TiXmlDocument</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>&amp; copy );
+<a name="l01399"></a>01399     <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>&amp; copy );
+<a name="l01400"></a>01400 
+<a name="l01401"></a>01401     <span class="keyword">virtual</span> ~<a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>() {}
+<a name="l01402"></a>01402 
+<a name="l01407"></a>01407     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01409"></a>01409     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>() <span class="keyword">const</span>;
+<a name="l01411"></a>01411     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01413"></a>01413     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * filename ) <span class="keyword">const</span>;
+<a name="l01419"></a>01419     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01421"></a>01421     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>( FILE* ) <span class="keyword">const</span>;
+<a name="l01422"></a>01422 
+<a name="l01423"></a>01423 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01424"></a><a class="code" href="classTiXmlDocument.html#18ae6ed34fed7991ebc220862dfac884">01424</a> <span class="preprocessor"></span>    <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>( <span class="keyword">const</span> std::string&amp; filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )           
+<a name="l01425"></a>01425     {
+<a name="l01426"></a>01426 <span class="comment">//      StringToBuffer f( filename );</span>
+<a name="l01427"></a>01427 <span class="comment">//      return ( f.buffer &amp;&amp; LoadFile( f.buffer, encoding ));</span>
+<a name="l01428"></a>01428         <span class="keywordflow">return</span> <a class="code" href="classTiXmlDocument.html#4c852a889c02cf251117fd1d9fe1845f">LoadFile</a>( filename.c_str(), encoding );
+<a name="l01429"></a>01429     }
+<a name="l01430"></a><a class="code" href="classTiXmlDocument.html#3d4fae0463f3f03679ba0b7cf6f2df52">01430</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>( <span class="keyword">const</span> std::string&amp; filename ) <span class="keyword">const</span>      
+<a name="l01431"></a>01431     {
+<a name="l01432"></a>01432 <span class="comment">//      StringToBuffer f( filename );</span>
+<a name="l01433"></a>01433 <span class="comment">//      return ( f.buffer &amp;&amp; SaveFile( f.buffer ));</span>
+<a name="l01434"></a>01434         <span class="keywordflow">return</span> <a class="code" href="classTiXmlDocument.html#21c0aeb0d0a720169ad4ac89523ebe93">SaveFile</a>( filename.c_str() );
+<a name="l01435"></a>01435     }
+<a name="l01436"></a>01436 <span class="preprocessor">    #endif</span>
+<a name="l01437"></a>01437 <span class="preprocessor"></span>
+<a name="l01442"></a>01442     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlDocument.html#17ebabe36926ef398e78dec0d0ad0378">Parse</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+<a name="l01443"></a>01443 
+<a name="l01448"></a><a class="code" href="classTiXmlDocument.html#d09d17927f908f40efb406af2fb873be">01448</a>     <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlDocument.html#d09d17927f908f40efb406af2fb873be">RootElement</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>(); }
+<a name="l01449"></a>01449     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlDocument.html#d09d17927f908f40efb406af2fb873be">RootElement</a>()                 { <span class="keywordflow">return</span> <a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba">FirstChildElement</a>(); }
+<a name="l01450"></a>01450 
+<a name="l01456"></a><a class="code" href="classTiXmlDocument.html#6dfc01a6e5d58e56acd537dfd3bdeb29">01456</a>     <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#6dfc01a6e5d58e56acd537dfd3bdeb29">Error</a>()<span class="keyword"> const                      </span>{ <span class="keywordflow">return</span> error; }
+<a name="l01457"></a>01457 
+<a name="l01459"></a><a class="code" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">01459</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="classTiXmlDocument.html#9d0f689f6e09ea494ea547be8d79c25e">ErrorDesc</a>()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> errorDesc.c_str (); }
+<a name="l01460"></a>01460 
+<a name="l01464"></a><a class="code" href="classTiXmlDocument.html#f96fc2f3f9ec6422782bfe916c9e778f">01464</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#f96fc2f3f9ec6422782bfe916c9e778f">ErrorId</a>()<span class="keyword">   const               </span>{ <span class="keywordflow">return</span> errorId; }
+<a name="l01465"></a>01465 
+<a name="l01473"></a><a class="code" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">01473</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#f30efc75e804aa2e92fb8be3a8cb676e">ErrorRow</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> errorLocation.row+1; }
+<a name="l01474"></a><a class="code" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">01474</a>     <span class="keywordtype">int</span> <a class="code" href="classTiXmlDocument.html#a90bc630ee5203c6109ca5fad3323649">ErrorCol</a>()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> errorLocation.col+1; } 
+<a name="l01475"></a>01475 
+<a name="l01500"></a><a class="code" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">01500</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#51dac56316f89b35bdb7d0d433ba988e">SetTabSize</a>( <span class="keywordtype">int</span> _tabsize )     { tabsize = _tabsize; }
+<a name="l01501"></a>01501 
+<a name="l01502"></a>01502     <span class="keywordtype">int</span> TabSize()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tabsize; }
+<a name="l01503"></a>01503 
+<a name="l01507"></a><a class="code" href="classTiXmlDocument.html#c66b8c28db86363315712a3574e87c35">01507</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#c66b8c28db86363315712a3574e87c35">ClearError</a>()                       {   error = <span class="keyword">false</span>; 
+<a name="l01508"></a>01508                                                 errorId = 0; 
+<a name="l01509"></a>01509                                                 errorDesc = <span class="stringliteral">""</span>; 
+<a name="l01510"></a>01510                                                 errorLocation.row = errorLocation.col = 0; 
+<a name="l01511"></a>01511                                                 <span class="comment">//errorLocation.last = 0; </span>
+<a name="l01512"></a>01512                                             }
+<a name="l01513"></a>01513 
+<a name="l01515"></a><a class="code" href="classTiXmlDocument.html#f08389ec70ee9b2de7f800e206a18510">01515</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#f08389ec70ee9b2de7f800e206a18510">Print</a>()<span class="keyword"> const                      </span>{ <a class="code" href="classTiXmlDocument.html#f08389ec70ee9b2de7f800e206a18510">Print</a>( stdout, 0 ); }
+<a name="l01516"></a>01516 
+<a name="l01517"></a>01517     <span class="comment">/* Write the document to a string using formatted printing ("pretty print"). This</span>
+<a name="l01518"></a>01518 <span class="comment">        will allocate a character array (new char[]) and return it as a pointer. The</span>
+<a name="l01519"></a>01519 <span class="comment">        calling code pust call delete[] on the return char* to avoid a memory leak.</span>
+<a name="l01520"></a>01520 <span class="comment">    */</span>
+<a name="l01521"></a>01521     <span class="comment">//char* PrintToMemory() const; </span>
+<a name="l01522"></a>01522 
+<a name="l01524"></a>01524     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTiXmlDocument.html#f08389ec70ee9b2de7f800e206a18510">Print</a>( FILE* cfile, <span class="keywordtype">int</span> depth = 0 ) <span class="keyword">const</span>;
+<a name="l01525"></a>01525     <span class="comment">// [internal use]</span>
+<a name="l01526"></a>01526     <span class="keywordtype">void</span> SetError( <span class="keywordtype">int</span> err, <span class="keyword">const</span> <span class="keywordtype">char</span>* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+<a name="l01527"></a>01527 
+<a name="l01528"></a><a class="code" href="classTiXmlDocument.html#1dc977bde3e4fe85a8eb9d88a35ef5a4">01528</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>*    <a class="code" href="classTiXmlDocument.html#1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a>()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01529"></a><a class="code" href="classTiXmlDocument.html#1025d942a1f328fd742d545e37efdd42">01529</a>     <span class="keyword">virtual</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>*          <a class="code" href="classTiXmlDocument.html#1dc977bde3e4fe85a8eb9d88a35ef5a4">ToDocument</a>()          { <span class="keywordflow">return</span> <span class="keyword">this</span>; } 
+<a name="l01530"></a>01530 
+<a name="l01533"></a>01533     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlDocument.html#a545aae325d9752ad64120bc4ecf939a">Accept</a>( <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>* content ) <span class="keyword">const</span>;
+<a name="l01534"></a>01534 
+<a name="l01535"></a>01535 <span class="keyword">protected</span> :
+<a name="l01536"></a>01536     <span class="comment">// [internal use]</span>
+<a name="l01537"></a>01537     <span class="keyword">virtual</span> <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlDocument.html#4968661cab4a1f44a23329c6f8db1907">Clone</a>() <span class="keyword">const</span>;
+<a name="l01538"></a>01538 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01539"></a>01539 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> StreamIn( std::istream * in, TIXML_STRING * tag );
+<a name="l01540"></a>01540 <span class="preprocessor">    #endif</span>
+<a name="l01541"></a>01541 <span class="preprocessor"></span>
+<a name="l01542"></a>01542 <span class="keyword">private</span>:
+<a name="l01543"></a>01543     <span class="keywordtype">void</span> CopyTo( <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>* target ) <span class="keyword">const</span>;
+<a name="l01544"></a>01544 
+<a name="l01545"></a>01545     <span class="keywordtype">bool</span> error;
+<a name="l01546"></a>01546     <span class="keywordtype">int</span>  errorId;
+<a name="l01547"></a>01547     TIXML_STRING errorDesc;
+<a name="l01548"></a>01548     <span class="keywordtype">int</span> tabsize;
+<a name="l01549"></a>01549     TiXmlCursor errorLocation;
+<a name="l01550"></a>01550     <span class="keywordtype">bool</span> useMicrosoftBOM;       <span class="comment">// the UTF-8 BOM were found when read. Note this, and try to write.</span>
+<a name="l01551"></a>01551 };
+<a name="l01552"></a>01552 
+<a name="l01553"></a>01553 
+<a name="l01634"></a><a class="code" href="classTiXmlHandle.html">01634</a> <span class="keyword">class </span><a class="code" href="classTiXmlHandle.html">TiXmlHandle</a>
+<a name="l01635"></a>01635 {
+<a name="l01636"></a>01636 <span class="keyword">public</span>:
+<a name="l01638"></a><a class="code" href="classTiXmlHandle.html#ba18fd7bdefb942ecdea4bf4b8e29ec8">01638</a>     <a class="code" href="classTiXmlHandle.html#ba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a>( <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* _node )                 { this-&gt;node = _node; }
+<a name="l01640"></a><a class="code" href="classTiXmlHandle.html#236d7855e1e56ccc7b980630c48c7fd7">01640</a>     <a class="code" href="classTiXmlHandle.html#ba18fd7bdefb942ecdea4bf4b8e29ec8">TiXmlHandle</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a>&amp; ref )           { this-&gt;node = ref.<a class="code" href="classTiXmlHandle.html#c5429de14bb78b16288bac5bf33c6858">node</a>; }
+<a name="l01641"></a>01641     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> operator=( <span class="keyword">const</span> <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a>&amp; ref ) { this-&gt;node = ref.<a class="code" href="classTiXmlHandle.html#c5429de14bb78b16288bac5bf33c6858">node</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
+<a name="l01642"></a>01642 
+<a name="l01644"></a>01644     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#cdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a>() <span class="keyword">const</span>;
+<a name="l01646"></a>01646     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#cdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;
+<a name="l01648"></a>01648     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a>() <span class="keyword">const</span>;
+<a name="l01650"></a>01650     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * value ) <span class="keyword">const</span>;
+<a name="l01651"></a>01651 
+<a name="l01655"></a>01655     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#072492b4be1acdb0db2d03cd8f71ccc4">Child</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01659"></a>01659     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#072492b4be1acdb0db2d03cd8f71ccc4">Child</a>( <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01664"></a>01664     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#979a3f850984a176ee884e394c7eed2d">ChildElement</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* value, <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01669"></a>01669     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#979a3f850984a176ee884e394c7eed2d">ChildElement</a>( <span class="keywordtype">int</span> index ) <span class="keyword">const</span>;
+<a name="l01670"></a>01670 
+<a name="l01671"></a>01671 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01672"></a>01672 <span class="preprocessor"></span>    <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#cdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const               </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#cdb1faaf88a700b40ca2c8d9aee21139">FirstChild</a>( _value.c_str() ); }
+<a name="l01673"></a>01673     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a>( <span class="keyword">const</span> std::string&amp; _value )<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#24d1112e995e937e4dddb202d4113d4a">FirstChildElement</a>( _value.c_str() ); }
+<a name="l01674"></a>01674 
+<a name="l01675"></a>01675     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#072492b4be1acdb0db2d03cd8f71ccc4">Child</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keywordtype">int</span> index )<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#072492b4be1acdb0db2d03cd8f71ccc4">Child</a>( _value.c_str(), index ); }
+<a name="l01676"></a>01676     <a class="code" href="classTiXmlHandle.html">TiXmlHandle</a> <a class="code" href="classTiXmlHandle.html#979a3f850984a176ee884e394c7eed2d">ChildElement</a>( <span class="keyword">const</span> std::string&amp; _value, <span class="keywordtype">int</span> index )<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#979a3f850984a176ee884e394c7eed2d">ChildElement</a>( _value.c_str(), index ); }
+<a name="l01677"></a>01677 <span class="preprocessor">    #endif</span>
+<a name="l01678"></a>01678 <span class="preprocessor"></span>
+<a name="l01681"></a><a class="code" href="classTiXmlHandle.html#f678e5088e83be67baf76f699756f2c3">01681</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlHandle.html#f678e5088e83be67baf76f699756f2c3">ToNode</a>()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> node; } 
+<a name="l01684"></a><a class="code" href="classTiXmlHandle.html#bc6e7ed383a5fe1e52b0c0004b457b9e">01684</a>     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlHandle.html#bc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;<a class="code" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() ) ? node-&gt;<a class="code" href="classTiXmlNode.html#72abed96dc9667ab9e0a2a275301bb1c">ToElement</a>() : 0 ); }
+<a name="l01687"></a><a class="code" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">01687</a>     <a class="code" href="classTiXmlText.html">TiXmlText</a>* <a class="code" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">ToText</a>()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;<a class="code" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() ) ? node-&gt;<a class="code" href="classTiXmlNode.html#95a46a52c525992d6b4ee08beb14cd69">ToText</a>() : 0 ); }
+<a name="l01690"></a><a class="code" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">01690</a>     <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>* <a class="code" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">ToUnknown</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> ( ( node &amp;&amp; node-&gt;<a class="code" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() ) ? node-&gt;<a class="code" href="classTiXmlNode.html#fd7205cf31d7a376929f8a36930627a2">ToUnknown</a>() : 0 ); }
+<a name="l01691"></a>01691 
+<a name="l01695"></a><a class="code" href="classTiXmlHandle.html#b44b723a8dc9af72838a303c079d0376">01695</a>     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* <a class="code" href="classTiXmlHandle.html#b44b723a8dc9af72838a303c079d0376">Node</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#f678e5088e83be67baf76f699756f2c3">ToNode</a>(); } 
+<a name="l01699"></a><a class="code" href="classTiXmlHandle.html#cb5fe8388a526289ea65e817a51e05e7">01699</a>     <a class="code" href="classTiXmlElement.html">TiXmlElement</a>* <a class="code" href="classTiXmlHandle.html#cb5fe8388a526289ea65e817a51e05e7">Element</a>()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#bc6e7ed383a5fe1e52b0c0004b457b9e">ToElement</a>(); }
+<a name="l01703"></a><a class="code" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">01703</a>     <a class="code" href="classTiXmlText.html">TiXmlText</a>* <a class="code" href="classTiXmlHandle.html#9fc739c8a18d160006f82572fc143d13">Text</a>()<span class="keyword"> const         </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#4ac53a652296203a5b5e13854d923586">ToText</a>(); }
+<a name="l01707"></a><a class="code" href="classTiXmlHandle.html#49675b74357ba2aae124657a9a1ef465">01707</a>     <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>* <a class="code" href="classTiXmlHandle.html#49675b74357ba2aae124657a9a1ef465">Unknown</a>()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> <a class="code" href="classTiXmlHandle.html#1381c17507a130767b1e23afc93b3674">ToUnknown</a>(); }
+<a name="l01708"></a>01708 
+<a name="l01709"></a>01709 <span class="keyword">private</span>:
+<a name="l01710"></a>01710     <a class="code" href="classTiXmlNode.html">TiXmlNode</a>* node;
+<a name="l01711"></a>01711 };
+<a name="l01712"></a>01712 
+<a name="l01713"></a>01713 
+<a name="l01733"></a><a class="code" href="classTiXmlPrinter.html">01733</a> <span class="keyword">class </span><a class="code" href="classTiXmlPrinter.html">TiXmlPrinter</a> : <span class="keyword">public</span> <a class="code" href="classTiXmlVisitor.html">TiXmlVisitor</a>
+<a name="l01734"></a>01734 {
+<a name="l01735"></a>01735 <span class="keyword">public</span>:
+<a name="l01736"></a>01736     <a class="code" href="classTiXmlPrinter.html">TiXmlPrinter</a>() : depth( 0 ), simpleTextPrint( <span class="keyword">false</span> ),
+<a name="l01737"></a>01737                      buffer(), indent( <span class="stringliteral">"    "</span> ), lineBreak( <span class="stringliteral">"\n"</span> ) {}
+<a name="l01738"></a>01738 
+<a name="l01739"></a>01739     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>&amp; doc );
+<a name="l01740"></a>01740     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#66b33edd76c538b462f789b797a4fdf2">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDocument.html">TiXmlDocument</a>&amp; doc );
+<a name="l01741"></a>01741 
+<a name="l01742"></a>01742     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#799f4f0388570cbb54c0d3c345fef7c1">VisitEnter</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>&amp; element, <span class="keyword">const</span> <a class="code" href="classTiXmlAttribute.html">TiXmlAttribute</a>* firstAttribute );
+<a name="l01743"></a>01743     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#66b33edd76c538b462f789b797a4fdf2">VisitExit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlElement.html">TiXmlElement</a>&amp; element );
+<a name="l01744"></a>01744 
+<a name="l01745"></a>01745     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ce1b14d33eede2575c0743e2350f6a38">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlDeclaration.html">TiXmlDeclaration</a>&amp; declaration );
+<a name="l01746"></a>01746     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ce1b14d33eede2575c0743e2350f6a38">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlText.html">TiXmlText</a>&amp; text );
+<a name="l01747"></a>01747     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ce1b14d33eede2575c0743e2350f6a38">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlComment.html">TiXmlComment</a>&amp; comment );
+<a name="l01748"></a>01748     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classTiXmlPrinter.html#ce1b14d33eede2575c0743e2350f6a38">Visit</a>( <span class="keyword">const</span> <a class="code" href="classTiXmlUnknown.html">TiXmlUnknown</a>&amp; unknown );
+<a name="l01749"></a>01749 
+<a name="l01753"></a><a class="code" href="classTiXmlPrinter.html#213377a4070c7e625bae59716b089e5e">01753</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#213377a4070c7e625bae59716b089e5e">SetIndent</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _indent )           { indent = _indent ? _indent : <span class="stringliteral">""</span> ; }
+<a name="l01755"></a><a class="code" href="classTiXmlPrinter.html#bb33ec7d4bad6aaeb57f4304394b133d">01755</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#bb33ec7d4bad6aaeb57f4304394b133d">Indent</a>()                            { <span class="keywordflow">return</span> indent.c_str(); }
+<a name="l01760"></a><a class="code" href="classTiXmlPrinter.html#4be1e37e69e3858c59635aa947174fe6">01760</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#4be1e37e69e3858c59635aa947174fe6">SetLineBreak</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* _lineBreak )     { lineBreak = _lineBreak ? _lineBreak : <span class="stringliteral">""</span>; }
+<a name="l01762"></a><a class="code" href="classTiXmlPrinter.html#11f1b4804a460b175ec244eb5724d96d">01762</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#11f1b4804a460b175ec244eb5724d96d">LineBreak</a>()                         { <span class="keywordflow">return</span> lineBreak.c_str(); }
+<a name="l01763"></a>01763 
+<a name="l01767"></a><a class="code" href="classTiXmlPrinter.html#b23a90629e374cb1cadca090468bbd19">01767</a>     <span class="keywordtype">void</span> <a class="code" href="classTiXmlPrinter.html#b23a90629e374cb1cadca090468bbd19">SetStreamPrinting</a>()                        { indent = <span class="stringliteral">""</span>;
+<a name="l01768"></a>01768                                                       lineBreak = <span class="stringliteral">""</span>;
+<a name="l01769"></a>01769                                                     }   
+<a name="l01771"></a><a class="code" href="classTiXmlPrinter.html#859eede9597d3e0355b77757be48735e">01771</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classTiXmlPrinter.html#859eede9597d3e0355b77757be48735e">CStr</a>()                              { <span class="keywordflow">return</span> buffer.c_str(); }
+<a name="l01773"></a><a class="code" href="classTiXmlPrinter.html#d01375ae9199bd2f48252eaddce3039d">01773</a>     size_t <a class="code" href="classTiXmlPrinter.html#d01375ae9199bd2f48252eaddce3039d">Size</a>()                                   { <span class="keywordflow">return</span> buffer.size(); }
+<a name="l01774"></a>01774 
+<a name="l01775"></a>01775 <span class="preprocessor">    #ifdef TIXML_USE_STL</span>
+<a name="l01777"></a><a class="code" href="classTiXmlPrinter.html#3bd4daf44309b41f5813a833caa0d1c9">01777</a> <span class="preprocessor">    const std::string&amp; Str()                        { return buffer; }</span>
+<a name="l01778"></a>01778 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
+<a name="l01779"></a>01779 <span class="preprocessor"></span>
+<a name="l01780"></a>01780 <span class="keyword">private</span>:
+<a name="l01781"></a>01781     <span class="keywordtype">void</span> DoIndent() {
+<a name="l01782"></a>01782         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;depth; ++i )
+<a name="l01783"></a>01783             buffer += indent;
+<a name="l01784"></a>01784     }
+<a name="l01785"></a>01785     <span class="keywordtype">void</span> DoLineBreak() {
+<a name="l01786"></a>01786         buffer += lineBreak;
+<a name="l01787"></a>01787     }
+<a name="l01788"></a>01788 
+<a name="l01789"></a>01789     <span class="keywordtype">int</span> depth;
+<a name="l01790"></a>01790     <span class="keywordtype">bool</span> simpleTextPrint;
+<a name="l01791"></a>01791     TIXML_STRING buffer;
+<a name="l01792"></a>01792     TIXML_STRING indent;
+<a name="l01793"></a>01793     TIXML_STRING lineBreak;
+<a name="l01794"></a>01794 };
+<a name="l01795"></a>01795 
+<a name="l01796"></a>01796 
+<a name="l01797"></a>01797 <span class="preprocessor">#ifdef _MSC_VER</span>
+<a name="l01798"></a>01798 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( pop )</span>
+<a name="l01799"></a>01799 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
+<a name="l01800"></a>01800 <span class="preprocessor"></span>
+<a name="l01801"></a>01801 <span class="preprocessor">#endif</span>
+<a name="l01802"></a>01802 <span class="preprocessor"></span>
+</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/docs/tutorial0.html
===================================================================
--- dependencies/tinyxml/docs/tutorial0.html	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/docs/tutorial0.html	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,721 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TinyXml: TinyXML Tutorial</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+<link href="tabs.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.4.7 -->
+<div class="tabs">
+  <ul>
+    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
+    <li><a href="annotated.html"><span>Classes</span></a></li>
+    <li><a href="files.html"><span>Files</span></a></li>
+    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
+  </ul></div>
+<div class="nav">
+<a class="el" href="index.html">index</a></div>
+<h1><a class="anchor" name="tutorial0">TinyXML Tutorial</a></h1><h1>What is this? </h1>
+<p>
+This tutorial has a few tips and suggestions on how to use TinyXML effectively.<p>
+I've also tried to include some C++ tips like how to convert strings to integers and vice versa. This isn't anything to do with TinyXML itself, but it may helpful for your project so I've put it in anyway.<p>
+If you don't know basic C++ concepts this tutorial won't be useful. Likewise if you don't know what a DOM is, look elsewhere first.<p>
+<h1>Before we start </h1>
+<p>
+Some example XML datasets/files will be used.<p>
+example1.xml:<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>
+example2.xml:<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;poetry&gt;
+	&lt;verse&gt;
+		Alas
+		  Great World
+			Alas (again)
+	&lt;/verse&gt;
+&lt;/poetry&gt;
+</pre></div><p>
+example3.xml:<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;shapes&gt;
+	&lt;circle name="int-based" x="20" y="30" r="50" /&gt;
+	&lt;point name="float-based" x="3.5" y="52.1" /&gt;
+&lt;/shapes&gt;
+</pre></div><p>
+example4.xml<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;MyApp&gt;
+    &lt;!-- Settings for MyApp --&gt;
+    &lt;Messages&gt;
+        &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt;
+        &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.1" timeout="123.456000" /&gt;
+&lt;/MyApp&gt;
+</pre></div><p>
+<h1>Getting Started </h1>
+<p>
+<h2>Load XML from a file </h2>
+<p>
+The simplest way to load a file into a TinyXML DOM is:<p>
+<div class="fragment"><pre class="fragment">TiXmlDocument doc( "demo.xml" );
+doc.LoadFile();
+</pre></div><p>
+A more real-world usage is shown below. This will load the file and display the contents to STDOUT:<p>
+<div class="fragment"><pre class="fragment">// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &amp;doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+</pre></div><p>
+A simple demonstration of this function is to use a main like this:<p>
+<div class="fragment"><pre class="fragment">int main(void)
+{
+	dump_to_stdout("example1.xml");
+	return 0;
+}
+</pre></div><p>
+Recall that Example 1 XML is:<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>
+Running the program with this XML will display this in the console/DOS window:<p>
+<div class="fragment"><pre class="fragment">DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+</pre></div><p>
+The ``dump_to_stdout`` function is defined later in this tutorial and is useful if you want to understand recursive traversal of a DOM.<p>
+<h2>Building Documents Programatically </h2>
+<p>
+This is how to build Example 1 pragmatically:<p>
+<div class="fragment"><pre class="fragment">void build_simple_doc( )
+{
+	// Make xml: &lt;?xml ..&gt;&lt;Hello&gt;World&lt;/Hello&gt;
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	TiXmlText * text = new TiXmlText( "World" );
+	element-&gt;LinkEndChild( text );
+	doc.LinkEndChild( decl );
+	doc.LinkEndChild( element );
+	doc.SaveFile( "madeByHand.xml" );
+}
+</pre></div><p>
+This can be loaded and displayed on the console with:<p>
+<div class="fragment"><pre class="fragment">dump_to_stdout("madeByHand.xml"); // this func defined later in the tutorial
+</pre></div><p>
+and you'll see it is identical to Example 1:<p>
+<div class="fragment"><pre class="fragment">madeByHand.xml:
+Document
++ Declaration
++ Element [Hello]
+  + Text: [World]
+</pre></div><p>
+This code produces exactly the same XML DOM but it shows a different ordering to node creation and linking:<p>
+<div class="fragment"><pre class="fragment">void write_simple_doc2( )
+{
+	// same as write_simple_doc1 but add each node
+	// as early as possible into the tree.
+
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	doc.LinkEndChild( decl );
+	
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	doc.LinkEndChild( element );
+	
+	TiXmlText * text = new TiXmlText( "World" );
+	element-&gt;LinkEndChild( text );
+	
+	doc.SaveFile( "madeByHand2.xml" );
+}
+</pre></div><p>
+Both of these produce the same XML, namely:<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;Hello&gt;World&lt;/Hello&gt;
+</pre></div><p>
+Or in structure form:<p>
+<div class="fragment"><pre class="fragment">DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+</pre></div><p>
+<h2>Attributes </h2>
+<p>
+Given an existing node, settings attributes is easy:<p>
+<div class="fragment"><pre class="fragment">window = new TiXmlElement( "Demo" );  
+window-&gt;SetAttribute("name", "Circle");
+window-&gt;SetAttribute("x", 5);
+window-&gt;SetAttribute("y", 15);
+window-&gt;SetDoubleAttribute("radius", 3.14159);
+</pre></div><p>
+You can it also work with the <a class="el" href="classTiXmlAttribute.html">TiXmlAttribute</a> objects if you want.<p>
+The following code shows one way (not the only way) to get all attributes of an element, print the name and string value, and if the value can be converted to an integer or double, print that value too:<p>
+<div class="fragment"><pre class="fragment">// print all attributes of pElement.
+// returns the number of attributes printed
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement-&gt;FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib-&gt;Name(), pAttrib-&gt;Value());
+
+		if (pAttrib-&gt;QueryIntValue(&amp;ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib-&gt;QueryDoubleValue(&amp;dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib-&gt;Next();
+	}
+	return i;
+}
+</pre></div><p>
+<h2>Writing a document to a file </h2>
+<p>
+Writing a pre-built DOM to a file is trivial:<p>
+<div class="fragment"><pre class="fragment">doc.SaveFile( saveFilename );  
+</pre></div><p>
+Recall, for example, example 4:<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;MyApp&gt;
+    &lt;!-- Settings for MyApp --&gt;
+    &lt;Messages&gt;
+        &lt;Welcome&gt;Welcome to MyApp&lt;/Welcome&gt;
+        &lt;Farewell&gt;Thank you for using MyApp&lt;/Farewell&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="MainFrame" x="5" y="15" w="400" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.1" timeout="123.456000" /&gt;
+&lt;/MyApp&gt;
+</pre></div><p>
+The following function builds this DOM and writes the file "appsettings.xml":<p>
+<div class="fragment"><pre class="fragment">void write_app_settings_doc( )  
+{  
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl );  
+ 
+	TiXmlElement * root = new TiXmlElement( "MyApp" );  
+	doc.LinkEndChild( root );  
+
+	TiXmlComment * comment = new TiXmlComment();
+	comment-&gt;SetValue(" Settings for MyApp " );  
+	root-&gt;LinkEndChild( comment );  
+ 
+	TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+	root-&gt;LinkEndChild( msgs );  
+ 
+	msg = new TiXmlElement( "Welcome" );  
+	msg-&gt;LinkEndChild( new TiXmlText( "Welcome to MyApp" ));  
+	msgs-&gt;LinkEndChild( msg );  
+ 
+	msg = new TiXmlElement( "Farewell" );  
+	msg-&gt;LinkEndChild( new TiXmlText( "Thank you for using MyApp" ));  
+	msgs-&gt;LinkEndChild( msg );  
+ 
+	TiXmlElement * windows = new TiXmlElement( "Windows" );  
+	root-&gt;LinkEndChild( windows );  
+
+	TiXmlElement * window;
+	window = new TiXmlElement( "Window" );  
+	windows-&gt;LinkEndChild( window );  
+	window-&gt;SetAttribute("name", "MainFrame");
+	window-&gt;SetAttribute("x", 5);
+	window-&gt;SetAttribute("y", 15);
+	window-&gt;SetAttribute("w", 400);
+	window-&gt;SetAttribute("h", 250);
+
+	TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+	root-&gt;LinkEndChild( cxn );  
+	cxn-&gt;SetAttribute("ip", "192.168.0.1");
+	cxn-&gt;SetDoubleAttribute("timeout", 123.456); // floating point attrib
+	
+	dump_to_stdout( &amp;doc );
+	doc.SaveFile( "appsettings.xml" );  
+} 
+</pre></div><p>
+The dump_to_stdout function will show this structure:<p>
+<div class="fragment"><pre class="fragment">Document
++ Declaration
++ Element [MyApp]
+ (No attributes)
+  + Comment: [ Settings for MyApp ]
+  + Element [Messages]
+ (No attributes)
+    + Element [Welcome]
+ (No attributes)
+      + Text: [Welcome to MyApp]
+    + Element [Farewell]
+ (No attributes)
+      + Text: [Thank you for using MyApp]
+  + Element [Windows]
+ (No attributes)
+    + Element [Window]
+      + name: value=[MainFrame]
+      + x: value=[5] int=5 d=5.0
+      + y: value=[15] int=15 d=15.0
+      + w: value=[400] int=400 d=400.0
+      + h: value=[250] int=250 d=250.0
+      5 attributes
+  + Element [Connection]
+    + ip: value=[192.168.0.1] int=192 d=192.2
+    + timeout: value=[123.456000] int=123 d=123.5
+    2 attributes
+</pre></div><p>
+I was surprised that TinyXml, by default, writes the XML in what other APIs call a "pretty" format - it modifies the whitespace of text of elements that contain other nodes so that writing the tree includes an indication of nesting level.<p>
+I haven't looked yet to see if there is a way to turn off indenting when writing a file - its bound to be easy.<p>
+[Lee: It's easy in STL mode, just use cout &lt;&lt; myDoc. Non-STL mode is always in "pretty" format. Adding a switch would be a nice feature and has been requested.]<p>
+<h1>XML to/from C++ objects </h1>
+<p>
+<h2>Intro </h2>
+<p>
+This example assumes you're loading and saving your app settings in an XML file, e.g. something like example4.xml.<p>
+There are a number of ways to do this. For example, look into the TinyBind project at <a href="http://sourceforge.net/projects/tinybind">http://sourceforge.net/projects/tinybind</a><p>
+This section shows a plain-old approach to loading and saving a basic object structure using XML.<p>
+<h2>Set up your object classes </h2>
+<p>
+Start off with some basic classes like these:<p>
+<div class="fragment"><pre class="fragment">#include &lt;string&gt;
+#include &lt;map&gt;
+using namespace std;
+
+typedef std::map&lt;std::string,std::string&gt; MessageMap;
+
+// a basic window abstraction - demo purposes only
+class WindowSettings
+{
+public:
+	int x,y,w,h;
+	string name;
+
+	WindowSettings()
+		: x(0), y(0), w(100), h(100), name("Untitled")
+	{
+	}
+
+	WindowSettings(int x, int y, int w, int h, const string&amp; name)
+	{
+		this-&gt;x=x;
+		this-&gt;y=y;
+		this-&gt;w=w;
+		this-&gt;h=h;
+		this-&gt;name=name;
+	}
+};
+
+class ConnectionSettings
+{
+public:
+	string ip;
+	double timeout;
+};
+
+class AppSettings
+{
+public:
+	string m_name;
+	MessageMap m_messages;
+	list&lt;WindowSettings&gt; m_windows;
+	ConnectionSettings m_connection;
+
+	AppSettings() {}
+
+	void save(const char* pFilename);
+	void load(const char* pFilename);
+	
+	// just to show how to do it
+	void setDemoValues()
+	{
+		m_name="MyApp";
+		m_messages.clear();
+		m_messages["Welcome"]="Welcome to "+m_name;
+		m_messages["Farewell"]="Thank you for using "+m_name;
+		m_windows.clear();
+		m_windows.push_back(WindowSettings(15,15,400,250,"Main"));
+		m_connection.ip="Unknown";
+		m_connection.timeout=123.456;
+	}
+};
+</pre></div><p>
+This is a basic main() that shows how to create a default settings object tree, save it and load it again:<p>
+<div class="fragment"><pre class="fragment">int main(void)
+{
+	AppSettings settings;
+	
+	settings.save("appsettings2.xml");
+	settings.load("appsettings2.xml");
+	return 0;
+}
+</pre></div><p>
+The following main() shows creation, modification, saving and then loading of a settings structure:<p>
+<div class="fragment"><pre class="fragment">int main(void)
+{
+	// block: customise and save settings
+	{
+		AppSettings settings;
+		settings.m_name="HitchHikerApp";
+		settings.m_messages["Welcome"]="Don't Panic";
+		settings.m_messages["Farewell"]="Thanks for all the fish";
+		settings.m_windows.push_back(WindowSettings(15,25,300,250,"BookFrame"));
+		settings.m_connection.ip="192.168.0.77";
+		settings.m_connection.timeout=42.0;
+
+		settings.save("appsettings2.xml");
+	}
+	
+	// block: load settings
+	{
+		AppSettings settings;
+		settings.load("appsettings2.xml");
+		printf("%s: %s\n", settings.m_name.c_str(), 
+			settings.m_messages["Welcome"].c_str());
+		WindowSettings &amp; w=settings.m_windows.front();
+		printf("%s: Show window '%s' at %d,%d (%d x %d)\n", 
+			settings.m_name.c_str(), w.name.c_str(), w.x, w.y, w.w, w.h);
+		printf("%s: %s\n", settings.m_name.c_str(), settings.m_messages["Farewell"].c_str());
+	}
+	return 0;
+}
+</pre></div><p>
+When the save() and load() are completed (see below), running this main() displays on the console:<p>
+<div class="fragment"><pre class="fragment">HitchHikerApp: Don't Panic
+HitchHikerApp: Show window 'BookFrame' at 15,25 (300 x 100)
+HitchHikerApp: Thanks for all the fish
+</pre></div><p>
+<h2>Encode C++ state as XML </h2>
+<p>
+There are lots of different ways to approach saving this to a file. Here's one:<p>
+<div class="fragment"><pre class="fragment">void AppSettings::save(const char* pFilename)
+{
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+	TiXmlComment * comment;
+	string s;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl ); 
+ 
+	TiXmlElement * root = new TiXmlElement(m_name.c_str());  
+	doc.LinkEndChild( root );  
+
+	comment = new TiXmlComment();
+	s=" Settings for "+m_name+" ";
+	comment-&gt;SetValue(s.c_str());  
+	root-&gt;LinkEndChild( comment );  
+
+	// block: messages
+	{
+		MessageMap::iterator iter;
+
+		TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+		root-&gt;LinkEndChild( msgs );  
+ 
+		for (iter=m_messages.begin(); iter != m_messages.end(); iter++)
+		{
+			const string &amp; key=(*iter).first;
+			const string &amp; value=(*iter).second;
+			msg = new TiXmlElement(key.c_str());  
+			msg-&gt;LinkEndChild( new TiXmlText(value.c_str()));  
+			msgs-&gt;LinkEndChild( msg );  
+		}
+	}
+
+	// block: windows
+	{
+		TiXmlElement * windowsNode = new TiXmlElement( "Windows" );  
+		root-&gt;LinkEndChild( windowsNode );  
+
+		list&lt;WindowSettings&gt;::iterator iter;
+
+		for (iter=m_windows.begin(); iter != m_windows.end(); iter++)
+		{
+			const WindowSettings&amp; w=*iter;
+
+			TiXmlElement * window;
+			window = new TiXmlElement( "Window" );  
+			windowsNode-&gt;LinkEndChild( window );  
+			window-&gt;SetAttribute("name", w.name.c_str());
+			window-&gt;SetAttribute("x", w.x);
+			window-&gt;SetAttribute("y", w.y);
+			window-&gt;SetAttribute("w", w.w);
+			window-&gt;SetAttribute("h", w.h);
+		}
+	}
+
+	// block: connection
+	{
+		TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+		root-&gt;LinkEndChild( cxn );  
+		cxn-&gt;SetAttribute("ip", m_connection.ip.c_str());
+		cxn-&gt;SetDoubleAttribute("timeout", m_connection.timeout); 
+	}
+
+	doc.SaveFile(pFilename);  
+}
+</pre></div><p>
+Running this with the modified main produces this file:<p>
+<div class="fragment"><pre class="fragment">&lt;?xml version="1.0" ?&gt;
+&lt;HitchHikerApp&gt;
+    &lt;!-- Settings for HitchHikerApp --&gt;
+    &lt;Messages&gt;
+        &lt;Farewell&gt;Thanks for all the fish&lt;/Farewell&gt;
+        &lt;Welcome&gt;Don&amp;apos;t Panic&lt;/Welcome&gt;
+    &lt;/Messages&gt;
+    &lt;Windows&gt;
+        &lt;Window name="BookFrame" x="15" y="25" w="300" h="250" /&gt;
+    &lt;/Windows&gt;
+    &lt;Connection ip="192.168.0.77" timeout="42.000000" /&gt;
+&lt;/HitchHikerApp&gt;
+</pre></div><p>
+<h2>Decoding state from XML </h2>
+<p>
+As with encoding objects, there are a number of approaches to decoding XML into your own C++ object structure. The following approach uses TiXmlHandles.<p>
+<div class="fragment"><pre class="fragment">void AppSettings::load(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	if (!doc.LoadFile()) return;
+
+	TiXmlHandle hDoc(&amp;doc);
+	TiXmlElement* pElem;
+	TiXmlHandle hRoot(0);
+
+	// block: name
+	{
+		pElem=hDoc.FirstChildElement().Element();
+		// should always have a valid root but handle gracefully if it does
+		if (!pElem) return;
+		m_name=pElem-&gt;Value();
+
+		// save this for later
+		hRoot=TiXmlHandle(pElem);
+	}
+
+	// block: string table
+	{
+		m_messages.clear(); // trash existing table
+
+		pElem=hRoot.FirstChild( "Messages" ).FirstChild().Element();
+		for( pElem; pElem; pElem=pElem-&gt;NextSiblingElement())
+		{
+			const char *pKey=pElem-&gt;Value();
+			const char *pText=pElem-&gt;GetText();
+			if (pKey &amp;&amp; pText) 
+			{
+				m_messages[pKey]=pText;
+			}
+		}
+	}
+
+	// block: windows
+	{
+		m_windows.clear(); // trash existing list
+
+		TiXmlElement* pWindowNode=hRoot.FirstChild( "Windows" ).FirstChild().Element();
+		for( pWindowNode; pWindowNode; pWindowNode=pWindowNode-&gt;NextSiblingElement())
+		{
+			WindowSettings w;
+			const char *pName=pWindowNode-&gt;Attribute("name");
+			if (pName) w.name=pName;
+			
+			pWindowNode-&gt;QueryIntAttribute("x", &amp;w.x); // If this fails, original value is left as-is
+			pWindowNode-&gt;QueryIntAttribute("y", &amp;w.y);
+			pWindowNode-&gt;QueryIntAttribute("w", &amp;w.w);
+			pWindowNode-&gt;QueryIntAttribute("hh", &amp;w.h);
+
+			m_windows.push_back(w);
+		}
+	}
+
+	// block: connection
+	{
+		pElem=hRoot.FirstChild("Connection").Element();
+		if (pElem)
+		{
+			m_connection.ip=pElem-&gt;Attribute("ip");
+			pElem-&gt;QueryDoubleAttribute("timeout",&amp;m_connection.timeout);
+		}
+	}
+}
+</pre></div><p>
+<h1>Full listing for dump_to_stdout </h1>
+<p>
+Below is a copy-and-paste demo program for loading arbitrary XML files and dumping the structure to STDOUT using the recursive traversal listed above.<p>
+<div class="fragment"><pre class="fragment">// tutorial demo program
+#include "stdafx.h"
+#include "tinyxml.h"
+
+// ----------------------------------------------------------------------
+// STDOUT dump and indenting utility functions
+// ----------------------------------------------------------------------
+const unsigned int NUM_INDENTS_PER_SPACE=2;
+
+const char * getIndent( unsigned int numIndents )
+{
+	static const char * pINDENT="                                      + ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n &gt; LENGTH ) n = LENGTH;
+
+	return &amp;pINDENT[ LENGTH-n ];
+}
+
+// same as getIndent but no "+" at the end
+const char * getIndentAlt( unsigned int numIndents )
+{
+	static const char * pINDENT="                                        ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n &gt; LENGTH ) n = LENGTH;
+
+	return &amp;pINDENT[ LENGTH-n ];
+}
+
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement-&gt;FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib-&gt;Name(), pAttrib-&gt;Value());
+
+		if (pAttrib-&gt;QueryIntValue(&amp;ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib-&gt;QueryDoubleValue(&amp;dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib-&gt;Next();
+	}
+	return i;	
+}
+
+void dump_to_stdout( TiXmlNode* pParent, unsigned int indent = 0 )
+{
+	if ( !pParent ) return;
+
+	TiXmlNode* pChild;
+	TiXmlText* pText;
+	int t = pParent-&gt;Type();
+	printf( "%s", getIndent(indent));
+	int num;
+
+	switch ( t )
+	{
+	case TiXmlNode::DOCUMENT:
+		printf( "Document" );
+		break;
+
+	case TiXmlNode::ELEMENT:
+		printf( "Element [%s]", pParent-&gt;Value() );
+		num=dump_attribs_to_stdout(pParent-&gt;ToElement(), indent+1);
+		switch(num)
+		{
+			case 0:  printf( " (No attributes)"); break;
+			case 1:  printf( "%s1 attribute", getIndentAlt(indent)); break;
+			default: printf( "%s%d attributes", getIndentAlt(indent), num); break;
+		}
+		break;
+
+	case TiXmlNode::COMMENT:
+		printf( "Comment: [%s]", pParent-&gt;Value());
+		break;
+
+	case TiXmlNode::UNKNOWN:
+		printf( "Unknown" );
+		break;
+
+	case TiXmlNode::TEXT:
+		pText = pParent-&gt;ToText();
+		printf( "Text: [%s]", pText-&gt;Value() );
+		break;
+
+	case TiXmlNode::DECLARATION:
+		printf( "Declaration" );
+		break;
+	default:
+		break;
+	}
+	printf( "\n" );
+	for ( pChild = pParent-&gt;FirstChild(); pChild != 0; pChild = pChild-&gt;NextSibling()) 
+	{
+		dump_to_stdout( pChild, indent+1 );
+	}
+}
+
+// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &amp;doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+
+// ----------------------------------------------------------------------
+// main() for printing files named on the command line
+// ----------------------------------------------------------------------
+int main(int argc, char* argv[])
+{
+	for (int i=1; i&lt;argc; i++)
+	{
+		dump_to_stdout(argv[i]);
+	}
+	return 0;
+}
+</pre></div><p>
+Run this from the command line or a DOS window, e.g.:<p>
+<div class="fragment"><pre class="fragment">C:\dev\tinyxml&gt; Debug\tinyxml_1.exe example1.xml
+
+example1.xml:
+Document
++ Declaration
++ Element [Hello]
+ (No attributes)
+  + Text: [World]
+</pre></div><p>
+<em> Authors and Changes <ul>
+<li>
+Written by Ellers, April, May, June 2005  </li>
+<li>
+Minor edits and integration into doc system, Lee Thomason September 2005  </li>
+<li>
+Updated by Ellers, October 2005  </li>
+</ul>
+</em> <hr size="1"><address style="align: right;"><small>Generated on Sun May 6 15:41:23 2007 for TinyXml by&nbsp;
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
+</body>
+</html>

Added: dependencies/tinyxml/echo.dsp
===================================================================
--- dependencies/tinyxml/echo.dsp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/echo.dsp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,113 @@
+# Microsoft Developer Studio Project File - Name="echo" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=echo - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "echo.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "echo.mak" CFG="echo - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "echo - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "echo - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "echo - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "echoRelease"
+# PROP Intermediate_Dir "echoRelease"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /YX /FD /c
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "echo - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "echo___Win32_Debug"
+# PROP BASE Intermediate_Dir "echo___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "echoDebug"
+# PROP Intermediate_Dir "echoDebug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "echo - Win32 Release"
+# Name "echo - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltester\bugtest.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Target
+# End Project

Added: dependencies/tinyxml/readme.txt
===================================================================
--- dependencies/tinyxml/readme.txt	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/readme.txt	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,530 @@
+/** @mainpage
+
+<h1> TinyXML </h1>
+
+TinyXML is a simple, small, C++ XML parser that can be easily 
+integrated into other programs.
+
+<h2> What it does. </h2>
+	
+In brief, TinyXML parses an XML document, and builds from that a 
+Document Object Model (DOM) that can be read, modified, and saved.
+
+XML stands for "eXtensible Markup Language." It allows you to create 
+your own document markups. Where HTML does a very good job of marking 
+documents for browsers, XML allows you to define any kind of document 
+markup, for example a document that describes a "to do" list for an 
+organizer application. XML is a very structured and convenient format.
+All those random file formats created to store application data can 
+all be replaced with XML. One parser for everything.
+
+The best place for the complete, correct, and quite frankly hard to
+read spec is at <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">
+http://www.w3.org/TR/2004/REC-xml-20040204/</a>. An intro to XML
+(that I really like) can be found at 
+<a href="http://skew.org/xml/tutorial/">http://skew.org/xml/tutorial</a>.
+
+There are different ways to access and interact with XML data.
+TinyXML uses a Document Object Model (DOM), meaning the XML data is parsed
+into a C++ objects that can be browsed and manipulated, and then 
+written to disk or another output stream. You can also construct an XML document 
+from scratch with C++ objects and write this to disk or another output
+stream.
+
+TinyXML is designed to be easy and fast to learn. It is two headers 
+and four cpp files. Simply add these to your project and off you go. 
+There is an example file - xmltest.cpp - to get you started. 
+
+TinyXML is released under the ZLib license, 
+so you can use it in open source or commercial code. The details
+of the license are at the top of every source file.
+
+TinyXML attempts to be a flexible parser, but with truly correct and
+compliant XML output. TinyXML should compile on any reasonably C++
+compliant system. It does not rely on exceptions or RTTI. It can be 
+compiled with or without STL support. TinyXML fully supports
+the UTF-8 encoding, and the first 64k character entities.
+
+
+<h2> What it doesn't do. </h2>
+
+TinyXML doesn't parse or use DTDs (Document Type Definitions) or XSLs
+(eXtensible Stylesheet Language.) There are other parsers out there 
+(check out www.sourceforge.org, search for XML) that are much more fully
+featured. But they are also much bigger, take longer to set up in
+your project, have a higher learning curve, and often have a more
+restrictive license. If you are working with browsers or have more
+complete XML needs, TinyXML is not the parser for you.
+
+The following DTD syntax will not parse at this time in TinyXML:
+
+ at verbatim
+	<!DOCTYPE Archiv [
+	 <!ELEMENT Comment (#PCDATA)>
+	]>
+ at endverbatim
+
+because TinyXML sees this as a !DOCTYPE node with an illegally 
+embedded !ELEMENT node. This may be addressed in the future.
+
+<h2> Tutorials. </h2>
+
+For the impatient, here is a tutorial to get you going. A great way to get started, 
+but it is worth your time to read this (very short) manual completely.
+
+- @subpage tutorial0
+
+<h2> Code Status.  </h2>
+
+TinyXML is mature, tested code. It is very stable. If you find
+bugs, please file a bug report on the sourceforge web site
+(www.sourceforge.net/projects/tinyxml). We'll get them straightened 
+out as soon as possible.
+
+There are some areas of improvement; please check sourceforge if you are
+interested in working on TinyXML.
+
+<h2> Related Projects </h2>
+
+TinyXML projects you may find useful! (Descriptions provided by the projects.)
+
+<ul>
+<li> <b>TinyXPath</b> (http://tinyxpath.sourceforge.net). TinyXPath is a small footprint 
+     XPath syntax decoder, written in C++.</li>
+<li> <b>TinyXML++</b> (http://code.google.com/p/ticpp/). TinyXML++ is a completely new 
+     interface to TinyXML that uses MANY of the C++ strengths. Templates, 
+	 exceptions, and much better error handling.</li>
+</ul>
+
+<h2> Features </h2>
+
+<h3> Using STL </h3>
+
+TinyXML can be compiled to use or not use STL. When using STL, TinyXML
+uses the std::string class, and fully supports std::istream, std::ostream,
+operator<<, and operator>>. Many API methods have both 'const char*' and
+'const std::string&' forms.
+
+When STL support is compiled out, no STL files are included whatsoever. All
+the string classes are implemented by TinyXML itself. API methods
+all use the 'const char*' form for input.
+
+Use the compile time #define:
+
+	TIXML_USE_STL
+
+to compile one version or the other. This can be passed by the compiler,
+or set as the first line of "tinyxml.h".
+
+Note: If compiling the test code in Linux, setting the environment
+variable TINYXML_USE_STL=YES/NO will control STL compilation. In the
+Windows project file, STL and non STL targets are provided. In your project,
+It's probably easiest to add the line "#define TIXML_USE_STL" as the first
+line of tinyxml.h.
+
+<h3> UTF-8 </h3>
+
+TinyXML supports UTF-8 allowing to manipulate XML files in any language. TinyXML
+also supports "legacy mode" - the encoding used before UTF-8 support and
+probably best described as "extended ascii".
+
+Normally, TinyXML will try to detect the correct encoding and use it. However,
+by setting the value of TIXML_DEFAULT_ENCODING in the header file, TinyXML
+can be forced to always use one encoding.
+
+TinyXML will assume Legacy Mode until one of the following occurs:
+<ol>
+	<li> If the non-standard but common "UTF-8 lead bytes" (0xef 0xbb 0xbf)
+		 begin the file or data stream, TinyXML will read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has an encoding="UTF-8", then
+		 TinyXML will read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has no encoding specified, then TinyXML will 
+		 read it as UTF-8. </li>
+	<li> If the declaration tag is read, and it has an encoding="something else", then TinyXML 
+		 will read it as Legacy Mode. In legacy mode, TinyXML will work as it did before. It's 
+		 not clear what that mode does exactly, but old content should keep working.</li>
+	<li> Until one of the above criteria is met, TinyXML runs in Legacy Mode.</li>
+</ol>
+
+What happens if the encoding is incorrectly set or detected? TinyXML will try
+to read and pass through text seen as improperly encoded. You may get some strange results or 
+mangled characters. You may want to force TinyXML to the correct mode.
+
+You may force TinyXML to Legacy Mode by using LoadFile( TIXML_ENCODING_LEGACY ) or
+LoadFile( filename, TIXML_ENCODING_LEGACY ). You may force it to use legacy mode all
+the time by setting TIXML_DEFAULT_ENCODING = TIXML_ENCODING_LEGACY. Likewise, you may 
+force it to TIXML_ENCODING_UTF8 with the same technique.
+
+For English users, using English XML, UTF-8 is the same as low-ASCII. You
+don't need to be aware of UTF-8 or change your code in any way. You can think
+of UTF-8 as a "superset" of ASCII.
+
+UTF-8 is not a double byte format - but it is a standard encoding of Unicode!
+TinyXML does not use or directly support wchar, TCHAR, or Microsoft's _UNICODE at this time. 
+It is common to see the term "Unicode" improperly refer to UTF-16, a wide byte encoding
+of unicode. This is a source of confusion.
+
+For "high-ascii" languages - everything not English, pretty much - TinyXML can
+handle all languages, at the same time, as long as the XML is encoded
+in UTF-8. That can be a little tricky, older programs and operating systems
+tend to use the "default" or "traditional" code page. Many apps (and almost all
+modern ones) can output UTF-8, but older or stubborn (or just broken) ones
+still output text in the default code page. 
+
+For example, Japanese systems traditionally use SHIFT-JIS encoding. 
+Text encoded as SHIFT-JIS can not be read by TinyXML. 
+A good text editor can import SHIFT-JIS and then save as UTF-8.
+
+The <a href="http://skew.org/xml/tutorial/">Skew.org link</a> does a great
+job covering the encoding issue.
+
+The test file "utf8test.xml" is an XML containing English, Spanish, Russian,
+and Simplified Chinese. (Hopefully they are translated correctly). The file
+"utf8test.gif" is a screen capture of the XML file, rendered in IE. Note that
+if you don't have the correct fonts (Simplified Chinese or Russian) on your
+system, you won't see output that matches the GIF file even if you can parse
+it correctly. Also note that (at least on my Windows machine) console output
+is in a Western code page, so that Print() or printf() cannot correctly display
+the file. This is not a bug in TinyXML - just an OS issue. No data is lost or 
+destroyed by TinyXML. The console just doesn't render UTF-8.
+
+
+<h3> Entities </h3>
+TinyXML recognizes the pre-defined "character entities", meaning special
+characters. Namely:
+
+ at verbatim
+	&amp;	&
+	&lt;	<
+	&gt;	>
+	&quot;	"
+	&apos;	'
+ at endverbatim
+
+These are recognized when the XML document is read, and translated to there
+UTF-8 equivalents. For instance, text with the XML of:
+
+ at verbatim
+	Far &amp; Away
+ at endverbatim
+
+will have the Value() of "Far & Away" when queried from the TiXmlText object,
+and will be written back to the XML stream/file as an ampersand. Older versions
+of TinyXML "preserved" character entities, but the newer versions will translate
+them into characters.
+
+Additionally, any character can be specified by its Unicode code point:
+The syntax "&#xA0;" or "&#160;" are both to the non-breaking space characher.
+
+<h3> Printing </h3>
+TinyXML can print output in several different ways that all have strengths and limitations.
+
+- Print( FILE* ). Output to a std-C stream, which includes all C files as well as stdout.
+	- "Pretty prints", but you don't have control over printing options.
+	- The output is streamed directly to the FILE object, so there is no memory overhead
+	  in the TinyXML code.
+	- used by Print() and SaveFile()
+
+- operator<<. Output to a c++ stream.
+	- Integrates with standart C++ iostreams.
+	- Outputs in "network printing" mode without line breaks. Good for network transmission
+	  and moving XML between C++ objects, but hard for a human to read.
+
+- TiXmlPrinter. Output to a std::string or memory buffer.
+	- API is less concise
+	- Future printing options will be put here.
+	- Printing may change slightly in future versions as it is refined and expanded.
+
+<h3> Streams </h3>
+With TIXML_USE_STL on TinyXML supports C++ streams (operator <<,>>) streams as well
+as C (FILE*) streams. There are some differences that you may need to be aware of.
+
+C style output:
+	- based on FILE*
+	- the Print() and SaveFile() methods
+
+	Generates formatted output, with plenty of white space, intended to be as 
+	human-readable as possible. They are very fast, and tolerant of ill formed 
+	XML documents. For example, an XML document that contains 2 root elements 
+	and 2 declarations, will still print.
+
+C style input:
+	- based on FILE*
+	- the Parse() and LoadFile() methods
+
+	A fast, tolerant read. Use whenever you don't need the C++ streams.
+
+C++ style output:
+	- based on std::ostream
+	- operator<<
+
+	Generates condensed output, intended for network transmission rather than
+	readability. Depending on your system's implementation of the ostream class,
+	these may be somewhat slower. (Or may not.) Not tolerant of ill formed XML:
+	a document should contain the correct one root element. Additional root level
+	elements will not be streamed out.
+
+C++ style input:
+	- based on std::istream
+	- operator>>
+
+	Reads XML from a stream, making it useful for network transmission. The tricky
+	part is knowing when the XML document is complete, since there will almost
+	certainly be other data in the stream. TinyXML will assume the XML data is
+	complete after it reads the root element. Put another way, documents that
+	are ill-constructed with more than one root element will not read correctly.
+	Also note that operator>> is somewhat slower than Parse, due to both 
+	implementation of the STL and limitations of TinyXML.
+
+<h3> White space </h3>
+The world simply does not agree on whether white space should be kept, or condensed.
+For example, pretend the '_' is a space, and look at "Hello____world". HTML, and 
+at least some XML parsers, will interpret this as "Hello_world". They condense white
+space. Some XML parsers do not, and will leave it as "Hello____world". (Remember
+to keep pretending the _ is a space.) Others suggest that __Hello___world__ should become
+Hello___world.
+
+It's an issue that hasn't been resolved to my satisfaction. TinyXML supports the
+first 2 approaches. Call TiXmlBase::SetCondenseWhiteSpace( bool ) to set the desired behavior.
+The default is to condense white space.
+
+If you change the default, you should call TiXmlBase::SetCondenseWhiteSpace( bool )
+before making any calls to Parse XML data, and I don't recommend changing it after
+it has been set.
+
+
+<h3> Handles </h3>
+
+Where browsing an XML document in a robust way, it is important to check
+for null returns from method calls. An error safe implementation can
+generate a lot of code like:
+
+ at verbatim
+TiXmlElement* root = document.FirstChildElement( "Document" );
+if ( root )
+{
+	TiXmlElement* element = root->FirstChildElement( "Element" );
+	if ( element )
+	{
+		TiXmlElement* child = element->FirstChildElement( "Child" );
+		if ( child )
+		{
+			TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+			if ( child2 )
+			{
+				// Finally do something useful.
+ at endverbatim
+
+Handles have been introduced to clean this up. Using the TiXmlHandle class,
+the previous code reduces to:
+
+ at verbatim
+TiXmlHandle docHandle( &document );
+TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+if ( child2 )
+{
+	// do something useful
+ at endverbatim
+
+Which is much easier to deal with. See TiXmlHandle for more information.
+
+
+<h3> Row and Column tracking </h3>
+Being able to track nodes and attributes back to their origin location
+in source files can be very important for some applications. Additionally,
+knowing where parsing errors occured in the original source can be very
+time saving.
+
+TinyXML can tracks the row and column origin of all nodes and attributes
+in a text file. The TiXmlBase::Row() and TiXmlBase::Column() methods return
+the origin of the node in the source text. The correct tabs can be 
+configured in TiXmlDocument::SetTabSize().
+
+
+<h2> Using and Installing </h2>
+
+To Compile and Run xmltest:
+
+A Linux Makefile and a Windows Visual C++ .dsw file is provided. 
+Simply compile and run. It will write the file demotest.xml to your 
+disk and generate output on the screen. It also tests walking the
+DOM by printing out the number of nodes found using different 
+techniques.
+
+The Linux makefile is very generic and runs on many systems - it 
+is currently tested on mingw and
+MacOSX. You do not need to run 'make depend'. The dependecies have been
+hard coded.
+
+<h3>Windows project file for VC6</h3>
+<ul>
+<li>tinyxml:		tinyxml library, non-STL </li>
+<li>tinyxmlSTL:		tinyxml library, STL </li>
+<li>tinyXmlTest:	test app, non-STL </li>
+<li>tinyXmlTestSTL: test app, STL </li>
+</ul>
+
+<h3>Makefile</h3>
+At the top of the makefile you can set:
+
+PROFILE, DEBUG, and TINYXML_USE_STL. Details (such that they are) are in
+the makefile.
+
+In the tinyxml directory, type "make clean" then "make". The executable
+file 'xmltest' will be created.
+
+
+
+<h3>To Use in an Application:</h3>
+
+Add tinyxml.cpp, tinyxml.h, tinyxmlerror.cpp, tinyxmlparser.cpp, tinystr.cpp, and tinystr.h to your
+project or make file. That's it! It should compile on any reasonably
+compliant C++ system. You do not need to enable exceptions or
+RTTI for TinyXML.
+
+
+<h2> How TinyXML works.  </h2>
+
+An example is probably the best way to go. Take:
+ at verbatim
+	<?xml version="1.0" standalone=no>
+	<!-- Our to do list data -->
+	<ToDo>
+		<Item priority="1"> Go to the <bold>Toy store!</bold></Item>
+		<Item priority="2"> Do bills</Item>
+	</ToDo>
+ at endverbatim
+
+Its not much of a To Do list, but it will do. To read this file 
+(say "demo.xml") you would create a document, and parse it in:
+ at verbatim
+	TiXmlDocument doc( "demo.xml" );
+	doc.LoadFile();
+ at endverbatim
+
+And its ready to go. Now lets look at some lines and how they 
+relate to the DOM.
+
+ at verbatim
+<?xml version="1.0" standalone=no>
+ at endverbatim
+
+	The first line is a declaration, and gets turned into the
+	TiXmlDeclaration class. It will be the first child of the
+	document node.
+	
+	This is the only directive/special tag parsed by by TinyXML.
+	Generally directive tags are stored in TiXmlUnknown so the 
+	commands wont be lost when it is saved back to disk.
+
+ at verbatim
+<!-- Our to do list data -->
+ at endverbatim
+
+	A comment. Will become a TiXmlComment object.
+
+ at verbatim
+<ToDo>
+ at endverbatim
+
+	The "ToDo" tag defines a TiXmlElement object. This one does not have 
+	any attributes, but does contain 2 other elements.
+
+ at verbatim
+<Item priority="1"> 
+ at endverbatim
+
+	Creates another TiXmlElement which is a child of the "ToDo" element. 
+	This element has 1 attribute, with the name "priority" and the value 
+	"1".
+
+ at verbatim
+Go to the
+ at endverbatim 
+
+	A TiXmlText. This is a leaf node and cannot contain other nodes. 
+	It is a child of the "Item" TiXmlElement.
+
+ at verbatim
+<bold>
+ at endverbatim
+
+	
+	Another TiXmlElement, this one a child of the "Item" element.
+
+Etc.
+
+Looking at the entire object tree, you end up with:
+ at verbatim
+TiXmlDocument					"demo.xml"
+	TiXmlDeclaration			"version='1.0'" "standalone=no"
+	TiXmlComment				" Our to do list data"
+	TiXmlElement				"ToDo"
+		TiXmlElement			"Item" Attribtutes: priority = 1
+			TiXmlText			"Go to the "
+			TiXmlElement		"bold"
+				TiXmlText		"Toy store!"
+		TiXmlElement			"Item" Attributes: priority=2
+			TiXmlText			"Do bills"
+ at endverbatim
+
+<h2> Documentation </h2>
+
+The documentation is build with Doxygen, using the 'dox' 
+configuration file.
+
+<h2> License </h2>
+
+TinyXML is released under the zlib license:
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must 
+not claim that you wrote the original software. If you use this 
+software in a product, an acknowledgment in the product documentation 
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+distribution.
+
+<h2> References  </h2>
+
+The World Wide Web Consortium is the definitive standard body for 
+XML, and there web pages contain huge amounts of information. 
+
+The definitive spec: <a href="http://www.w3.org/TR/2004/REC-xml-20040204/">
+http://www.w3.org/TR/2004/REC-xml-20040204/</a>
+
+I also recommend "XML Pocket Reference" by Robert Eckstein and published by 
+OReilly...the book that got the whole thing started.
+
+<h2> Contributors, Contacts, and a Brief History </h2>
+
+Thanks very much to everyone who sends suggestions, bugs, ideas, and 
+encouragement. It all helps, and makes this project fun. A special thanks
+to the contributors on the web pages that keep it lively.
+
+So many people have sent in bugs and ideas, that rather than list here 
+we try to give credit due in the "changes.txt" file.
+
+TinyXML was originally written by Lee Thomason. (Often the "I" still
+in the documentation.) Lee reviews changes and releases new versions,
+with the help of Yves Berquin, Andrew Ellerton, and the tinyXml community.
+
+We appreciate your suggestions, and would love to know if you 
+use TinyXML. Hopefully you will enjoy it and find it useful. 
+Please post questions, comments, file bugs, or contact us at:
+
+www.sourceforge.net/projects/tinyxml
+
+Lee Thomason, Yves Berquin, Andrew Ellerton
+*/

Added: dependencies/tinyxml/tinyXmlTest.dsp
===================================================================
--- dependencies/tinyxml/tinyXmlTest.dsp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyXmlTest.dsp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,92 @@
+# Microsoft Developer Studio Project File - Name="tinyXmlTest" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=tinyXmlTest - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTest.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTest.mak" CFG="tinyXmlTest - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyXmlTest - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "tinyXmlTest - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyXmlTest - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyXmlTest___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyXmlTest___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "tinyXmlTest___Win32_Release"
+# PROP Intermediate_Dir "tinyXmlTest___Win32_Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 ./Release/tinyxml.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "tinyXmlTest - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyXmlTest___Win32_Debug"
+# PROP BASE Intermediate_Dir "tinyXmlTest___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "tinyXmlTest___Win32_Debug"
+# PROP Intermediate_Dir "tinyXmlTest___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TUNE" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 ./Debug/tinyxmld.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyXmlTest - Win32 Release"
+# Name "tinyXmlTest - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltest.cpp
+# End Source File
+# End Target
+# End Project

Added: dependencies/tinyxml/tinyXmlTest.vcproj
===================================================================
--- dependencies/tinyxml/tinyXmlTest.vcproj	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyXmlTest.vcproj	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,227 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="tinyXmlTest"
+	ProjectGUID="{34719950-09E8-457E-BE23-8F1CE3A1F1F6}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\tinyXmlTest___Win32_Debug"
+			IntermediateDirectory=".\tinyXmlTest___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTest___Win32_Debug/tinyXmlTest.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;TUNE;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.pch"
+				AssemblerListingLocation=".\tinyXmlTest___Win32_Debug/"
+				ObjectFile=".\tinyXmlTest___Win32_Debug/"
+				ProgramDataBaseFileName=".\tinyXmlTest___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Debug/tinyxmld.lib"
+				OutputFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTest___Win32_Debug/tinyXmlTest.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\tinyXmlTest___Win32_Release"
+			IntermediateDirectory=".\tinyXmlTest___Win32_Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTest___Win32_Release/tinyXmlTest.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.pch"
+				AssemblerListingLocation=".\tinyXmlTest___Win32_Release/"
+				ObjectFile=".\tinyXmlTest___Win32_Release/"
+				ProgramDataBaseFileName=".\tinyXmlTest___Win32_Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Release/tinyxml.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTest___Win32_Release/tinyXmlTest.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="xmltest.cpp"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Added: dependencies/tinyxml/tinyXmlTestSTL.dsp
===================================================================
--- dependencies/tinyxml/tinyXmlTestSTL.dsp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyXmlTestSTL.dsp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,92 @@
+# Microsoft Developer Studio Project File - Name="tinyXmlTestSTL" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=tinyXmlTestSTL - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTestSTL.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyXmlTestSTL.mak" CFG="tinyXmlTestSTL - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyXmlTestSTL - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "tinyXmlTestSTL - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyXmlTestSTL - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP Intermediate_Dir "tinyXmlTestSTL___Win32_Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 ./Release_STL/tinyxml_stl.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "tinyXmlTestSTL - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP BASE Intermediate_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP Intermediate_Dir "tinyXmlTestSTL___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "TIXML_USE_STL" /D "TUNE" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 ./Debug_STL/tinyxmld_stl.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyXmlTestSTL - Win32 Release"
+# Name "tinyXmlTestSTL - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\xmltest.cpp
+# End Source File
+# End Target
+# End Project

Added: dependencies/tinyxml/tinyXmlTestSTL.vcproj
===================================================================
--- dependencies/tinyxml/tinyXmlTestSTL.vcproj	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyXmlTestSTL.vcproj	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,226 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="tinyXmlTestSTL"
+	ProjectGUID="{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\tinyXmlTestSTL___Win32_Debug"
+			IntermediateDirectory=".\tinyXmlTestSTL___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;TIXML_USE_STL;TUNE;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.pch"
+				AssemblerListingLocation=".\tinyXmlTestSTL___Win32_Debug/"
+				ObjectFile=".\tinyXmlTestSTL___Win32_Debug/"
+				ProgramDataBaseFileName=".\tinyXmlTestSTL___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Debug_STL/tinyxmld_stl.lib"
+				OutputFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTestSTL___Win32_Debug/tinyXmlTestSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\tinyXmlTestSTL___Win32_Release"
+			IntermediateDirectory=".\tinyXmlTestSTL___Win32_Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;TIXML_USE_STL;_CRT_SECURE_NO_WARNINGS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.pch"
+				AssemblerListingLocation=".\tinyXmlTestSTL___Win32_Release/"
+				ObjectFile=".\tinyXmlTestSTL___Win32_Release/"
+				ProgramDataBaseFileName=".\tinyXmlTestSTL___Win32_Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="./Release_STL/tinyxml_stl.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\tinyXmlTestSTL___Win32_Release/tinyXmlTestSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="xmltest.cpp"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Added: dependencies/tinyxml/tinystr.cpp
===================================================================
--- dependencies/tinyxml/tinystr.cpp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinystr.cpp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,116 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge L?vset, 7. April 2005.
+ */
+
+
+#ifndef TIXML_USE_STL
+
+#include "tinystr.h"
+
+// Error value for find primitive
+const TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);
+
+
+// Null rep.
+TiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, { '\0' } };
+
+
+void TiXmlString::reserve (size_type cap)
+{
+	if (cap > capacity())
+	{
+		TiXmlString tmp;
+		tmp.init(length(), cap);
+		memcpy(tmp.start(), data(), length());
+		swap(tmp);
+	}
+}
+
+
+TiXmlString& TiXmlString::assign(const char* str, size_type len)
+{
+	size_type cap = capacity();
+	if (len > cap || cap > 3*(len + 8))
+	{
+		TiXmlString tmp;
+		tmp.init(len);
+		memcpy(tmp.start(), str, len);
+		swap(tmp);
+	}
+	else
+	{
+		memmove(start(), str, len);
+		set_size(len);
+	}
+	return *this;
+}
+
+
+TiXmlString& TiXmlString::append(const char* str, size_type len)
+{
+	size_type newsize = length() + len;
+	if (newsize > capacity())
+	{
+		reserve (newsize + capacity());
+	}
+	memmove(finish(), str, len);
+	set_size(newsize);
+	return *this;
+}
+
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	tmp.reserve(a.length() + b.length());
+	tmp += a;
+	tmp += b;
+	return tmp;
+}
+
+TiXmlString operator + (const TiXmlString & a, const char* b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );
+	tmp.reserve(a.length() + b_len);
+	tmp += a;
+	tmp.append(b, b_len);
+	return tmp;
+}
+
+TiXmlString operator + (const char* a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );
+	tmp.reserve(a_len + b.length());
+	tmp.append(a, a_len);
+	tmp += b;
+	return tmp;
+}
+
+
+#endif	// TIXML_USE_STL

Added: dependencies/tinyxml/tinystr.h
===================================================================
--- dependencies/tinyxml/tinystr.h	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinystr.h	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,318 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.
+ *
+ * - completely rewritten. compact, clean, and fast implementation.
+ * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)
+ * - fixed reserve() to work as per specification.
+ * - fixed buggy compares operator==(), operator<(), and operator>()
+ * - fixed operator+=() to take a const ref argument, following spec.
+ * - added "copy" constructor with length, and most compare operators.
+ * - added swap(), clear(), size(), capacity(), operator+().
+ */
+#ifndef TIXML_USE_STL
+
+#ifndef TIXML_STRING_INCLUDED
+#define TIXML_STRING_INCLUDED
+
+#include <assert.h>
+#include <string.h>
+
+/*	The support for explicit isn't that universal, and it isn't really
+	required - it is used to check that the TiXmlString class isn't incorrectly
+	used. Be nice to old compilers and macro it here:
+*/
+#if defined(_MSC_VER) && (_MSC_VER >= 1200 )
+	// Microsoft visual studio, version 6 and higher.
+	#define TIXML_EXPLICIT explicit
+#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+	// GCC version 3 and higher.s
+	#define TIXML_EXPLICIT explicit
+#else
+	#define TIXML_EXPLICIT
+#endif
+
+
+/*
+   TiXmlString is an emulation of a subset of the std::string template.
+   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
+   Only the member functions relevant to the TinyXML project have been implemented.
+   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
+   a string and there's no more room, we allocate a buffer twice as big as we need.
+*/
+class TiXmlString
+{
+  public :
+	// The size type used
+  	typedef size_t size_type;
+
+	// Error value for find primitive
+	static const size_type npos; // = -1;
+
+
+	// TiXmlString empty constructor
+	TiXmlString () : rep_(&nullrep_)
+	{
+	}
+
+	// TiXmlString copy constructor
+	TiXmlString ( const TiXmlString & copy) : rep_(0)
+	{
+		init(copy.length());
+		memcpy(start(), copy.data(), length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)
+	{
+		init( static_cast<size_type>( strlen(copy) ));
+		memcpy(start(), copy, length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)
+	{
+		init(len);
+		memcpy(start(), str, len);
+	}
+
+	// TiXmlString destructor
+	~TiXmlString ()
+	{
+		quit();
+	}
+
+	// = operator
+	TiXmlString& operator = (const char * copy)
+	{
+		return assign( copy, (size_type)strlen(copy));
+	}
+
+	// = operator
+	TiXmlString& operator = (const TiXmlString & copy)
+	{
+		return assign(copy.start(), copy.length());
+	}
+
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const char * suffix)
+	{
+		return append(suffix, static_cast<size_type>( strlen(suffix) ));
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (char single)
+	{
+		return append(&single, 1);
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const TiXmlString & suffix)
+	{
+		return append(suffix.data(), suffix.length());
+	}
+
+
+	// Convert a TiXmlString into a null-terminated char *
+	const char * c_str () const { return rep_->str; }
+
+	// Convert a TiXmlString into a char * (need not be null terminated).
+	const char * data () const { return rep_->str; }
+
+	// Return the length of a TiXmlString
+	size_type length () const { return rep_->size; }
+
+	// Alias for length()
+	size_type size () const { return rep_->size; }
+
+	// Checks if a TiXmlString is empty
+	bool empty () const { return rep_->size == 0; }
+
+	// Return capacity of string
+	size_type capacity () const { return rep_->capacity; }
+
+
+	// single char extraction
+	const char& at (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// [] operator
+	char& operator [] (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// find a char in a string. Return TiXmlString::npos if not found
+	size_type find (char lookup) const
+	{
+		return find(lookup, 0);
+	}
+
+	// find a char in a string from an offset. Return TiXmlString::npos if not found
+	size_type find (char tofind, size_type offset) const
+	{
+		if (offset >= length()) return npos;
+
+		for (const char* p = c_str() + offset; *p != '\0'; ++p)
+		{
+		   if (*p == tofind) return static_cast< size_type >( p - c_str() );
+		}
+		return npos;
+	}
+
+	void clear ()
+	{
+		//Lee:
+		//The original was just too strange, though correct:
+		//	TiXmlString().swap(*this);
+		//Instead use the quit & re-init:
+		quit();
+		init(0,0);
+	}
+
+	/*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
+		function DOES NOT clear the content of the TiXmlString if any exists.
+	*/
+	void reserve (size_type cap);
+
+	TiXmlString& assign (const char* str, size_type len);
+
+	TiXmlString& append (const char* str, size_type len);
+
+	void swap (TiXmlString& other)
+	{
+		Rep* r = rep_;
+		rep_ = other.rep_;
+		other.rep_ = r;
+	}
+
+  private:
+
+	void init(size_type sz) { init(sz, sz); }
+	void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
+	char* start() const { return rep_->str; }
+	char* finish() const { return rep_->str + rep_->size; }
+
+	struct Rep
+	{
+		size_type size, capacity;
+		char str[1];
+	};
+
+	void init(size_type sz, size_type cap)
+	{
+		if (cap)
+		{
+			// Lee: the original form:
+			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
+			// doesn't work in some cases of new being overloaded. Switching
+			// to the normal allocation, although use an 'int' for systems
+			// that are overly picky about structure alignment.
+			const size_type bytesNeeded = sizeof(Rep) + cap;
+			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 
+			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );
+
+			rep_->str[ rep_->size = sz ] = '\0';
+			rep_->capacity = cap;
+		}
+		else
+		{
+			rep_ = &nullrep_;
+		}
+	}
+
+	void quit()
+	{
+		if (rep_ != &nullrep_)
+		{
+			// The rep_ is really an array of ints. (see the allocator, above).
+			// Cast it back before delete, so the compiler won't incorrectly call destructors.
+			delete [] ( reinterpret_cast<int*>( rep_ ) );
+		}
+	}
+
+	Rep * rep_;
+	static Rep nullrep_;
+
+} ;
+
+
+inline bool operator == (const TiXmlString & a, const TiXmlString & b)
+{
+	return    ( a.length() == b.length() )				// optimization on some platforms
+	       && ( strcmp(a.c_str(), b.c_str()) == 0 );	// actual compare
+}
+inline bool operator < (const TiXmlString & a, const TiXmlString & b)
+{
+	return strcmp(a.c_str(), b.c_str()) < 0;
+}
+
+inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
+inline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }
+inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
+inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }
+
+inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
+inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
+inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
+inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
+TiXmlString operator + (const TiXmlString & a, const char* b);
+TiXmlString operator + (const char* a, const TiXmlString & b);
+
+
+/*
+   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
+   Only the operators that we need for TinyXML have been developped.
+*/
+class TiXmlOutStream : public TiXmlString
+{
+public :
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const TiXmlString & in)
+	{
+		*this += in;
+		return *this;
+	}
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const char * in)
+	{
+		*this += in;
+		return *this;
+	}
+
+} ;
+
+#endif	// TIXML_STRING_INCLUDED
+#endif	// TIXML_USE_STL

Added: dependencies/tinyxml/tinyxml.cpp
===================================================================
--- dependencies/tinyxml/tinyxml.cpp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxml.cpp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,1888 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include <ctype.h>
+
+#ifdef TIXML_USE_STL
+#include <sstream>
+#include <iostream>
+#endif
+
+#include "tinyxml.h"
+
+
+bool TiXmlBase::condenseWhiteSpace = true;
+
+// Microsoft compiler security
+FILE* TiXmlFOpen( const char* filename, const char* mode )
+{
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		FILE* fp = 0;
+		errno_t err = fopen_s( &fp, filename, mode );
+		if ( !err && fp )
+			return fp;
+		return 0;
+	#else
+		return fopen( filename, mode );
+	#endif
+}
+
+void TiXmlBase::EncodeString( const TIXML_STRING& str, TIXML_STRING* outString )
+{
+	int i=0;
+
+	while( i<(int)str.length() )
+	{
+		unsigned char c = (unsigned char) str[i];
+
+		if (    c == '&' 
+		     && i < ( (int)str.length() - 2 )
+			 && str[i+1] == '#'
+			 && str[i+2] == 'x' )
+		{
+			// Hexadecimal character reference.
+			// Pass through unchanged.
+			// &#xA9;	-- copyright symbol, for example.
+			//
+			// The -1 is a bug fix from Rob Laveaux. It keeps
+			// an overflow from happening if there is no ';'.
+			// There are actually 2 ways to exit this loop -
+			// while fails (error case) and break (semicolon found).
+			// However, there is no mechanism (currently) for
+			// this function to return an error.
+			while ( i<(int)str.length()-1 )
+			{
+				outString->append( str.c_str() + i, 1 );
+				++i;
+				if ( str[i] == ';' )
+					break;
+			}
+		}
+		else if ( c == '&' )
+		{
+			outString->append( entity[0].str, entity[0].strLength );
+			++i;
+		}
+		else if ( c == '<' )
+		{
+			outString->append( entity[1].str, entity[1].strLength );
+			++i;
+		}
+		else if ( c == '>' )
+		{
+			outString->append( entity[2].str, entity[2].strLength );
+			++i;
+		}
+		else if ( c == '\"' )
+		{
+			outString->append( entity[3].str, entity[3].strLength );
+			++i;
+		}
+		else if ( c == '\'' )
+		{
+			outString->append( entity[4].str, entity[4].strLength );
+			++i;
+		}
+		else if ( c < 32 )
+		{
+			// Easy pass at non-alpha/numeric/symbol
+			// Below 32 is symbolic.
+			char buf[ 32 ];
+			
+			#if defined(TIXML_SNPRINTF)		
+				TIXML_SNPRINTF( buf, sizeof(buf), "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#else
+				sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#endif		
+
+			//*ME:	warning C4267: convert 'size_t' to 'int'
+			//*ME:	Int-Cast to make compiler happy ...
+			outString->append( buf, (int)strlen( buf ) );
+			++i;
+		}
+		else
+		{
+			//char realc = (char) c;
+			//outString->append( &realc, 1 );
+			*outString += (char) c;	// somewhat more efficient function call.
+			++i;
+		}
+	}
+}
+
+
+TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
+{
+	parent = 0;
+	type = _type;
+	firstChild = 0;
+	lastChild = 0;
+	prev = 0;
+	next = 0;
+}
+
+
+TiXmlNode::~TiXmlNode()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+}
+
+
+void TiXmlNode::CopyTo( TiXmlNode* target ) const
+{
+	target->SetValue (value.c_str() );
+	target->userData = userData; 
+}
+
+
+void TiXmlNode::Clear()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}	
+
+	firstChild = 0;
+	lastChild = 0;
+}
+
+
+TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
+{
+	assert( node->parent == 0 || node->parent == this );
+	assert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );
+
+	if ( node->Type() == TiXmlNode::DOCUMENT )
+	{
+		delete node;
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	node->parent = this;
+
+	node->prev = lastChild;
+	node->next = 0;
+
+	if ( lastChild )
+		lastChild->next = node;
+	else
+		firstChild = node;			// it was an empty list.
+
+	lastChild = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+
+	return LinkEndChild( node );
+}
+
+
+TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
+{	
+	if ( !beforeThis || beforeThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->next = beforeThis;
+	node->prev = beforeThis->prev;
+	if ( beforeThis->prev )
+	{
+		beforeThis->prev->next = node;
+	}
+	else
+	{
+		assert( firstChild == beforeThis );
+		firstChild = node;
+	}
+	beforeThis->prev = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
+{
+	if ( !afterThis || afterThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->prev = afterThis;
+	node->next = afterThis->next;
+	if ( afterThis->next )
+	{
+		afterThis->next->prev = node;
+	}
+	else
+	{
+		assert( lastChild == afterThis );
+		lastChild = node;
+	}
+	afterThis->next = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
+{
+	if ( replaceThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = withThis.Clone();
+	if ( !node )
+		return 0;
+
+	node->next = replaceThis->next;
+	node->prev = replaceThis->prev;
+
+	if ( replaceThis->next )
+		replaceThis->next->prev = node;
+	else
+		lastChild = node;
+
+	if ( replaceThis->prev )
+		replaceThis->prev->next = node;
+	else
+		firstChild = node;
+
+	delete replaceThis;
+	node->parent = this;
+	return node;
+}
+
+
+bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
+{
+	if ( removeThis->parent != this )
+	{	
+		assert( 0 );
+		return false;
+	}
+
+	if ( removeThis->next )
+		removeThis->next->prev = removeThis->prev;
+	else
+		lastChild = removeThis->prev;
+
+	if ( removeThis->prev )
+		removeThis->prev->next = removeThis->next;
+	else
+		firstChild = removeThis->next;
+
+	delete removeThis;
+	return true;
+}
+
+const TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = firstChild; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = lastChild; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild();
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling();
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild( val );
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling( val );
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const 
+{
+	const TiXmlNode* node;
+	for ( node = next; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = prev; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+void TiXmlElement::RemoveAttribute( const char * name )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING str( name );
+	TiXmlAttribute* node = attributeSet.Find( str );
+	#else
+	TiXmlAttribute* node = attributeSet.Find( name );
+	#endif
+	if ( node )
+	{
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+const TiXmlElement* TiXmlNode::FirstChildElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlDocument* TiXmlNode::GetDocument() const
+{
+	const TiXmlNode* node;
+
+	for( node = this; node; node = node->parent )
+	{
+		if ( node->ToDocument() )
+			return node->ToDocument();
+	}
+	return 0;
+}
+
+
+TiXmlElement::TiXmlElement (const char * _value)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlElement::TiXmlElement( const std::string& _value ) 
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+#endif
+
+
+TiXmlElement::TiXmlElement( const TiXmlElement& copy)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlElement::operator=( const TiXmlElement& base )
+{
+	ClearThis();
+	base.CopyTo( this );
+}
+
+
+TiXmlElement::~TiXmlElement()
+{
+	ClearThis();
+}
+
+
+void TiXmlElement::ClearThis()
+{
+	Clear();
+	while( attributeSet.First() )
+	{
+		TiXmlAttribute* node = attributeSet.First();
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+
+const char* TiXmlElement::Attribute( const char* name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return node->Value();
+	return 0;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return &node->ValueStr();
+	return 0;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, int* i ) const
+{
+	const char* s = Attribute( name );
+	if ( i )
+	{
+		if ( s ) {
+			*i = atoi( s );
+		}
+		else {
+			*i = 0;
+		}
+	}
+	return s;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, int* i ) const
+{
+	const std::string* s = Attribute( name );
+	if ( i )
+	{
+		if ( s ) {
+			*i = atoi( s->c_str() );
+		}
+		else {
+			*i = 0;
+		}
+	}
+	return s;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, double* d ) const
+{
+	const char* s = Attribute( name );
+	if ( d )
+	{
+		if ( s ) {
+			*d = atof( s );
+		}
+		else {
+			*d = 0;
+		}
+	}
+	return s;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, double* d ) const
+{
+	const std::string* s = Attribute( name );
+	if ( d )
+	{
+		if ( s ) {
+			*d = atof( s->c_str() );
+		}
+		else {
+			*d = 0;
+		}
+	}
+	return s;
+}
+#endif
+
+
+int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryIntValue( ival );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryIntAttribute( const std::string& name, int* ival ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryIntValue( ival );
+}
+#endif
+
+
+int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryDoubleValue( dval );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryDoubleAttribute( const std::string& name, double* dval ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryDoubleValue( dval );
+}
+#endif
+
+
+void TiXmlElement::SetAttribute( const char * name, int val )
+{	
+	char buf[64];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%d", val );
+	#else
+		sprintf( buf, "%d", val );
+	#endif
+	SetAttribute( name, buf );
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, int val )
+{	
+   std::ostringstream oss;
+   oss << val;
+   SetAttribute( name, oss.str() );
+}
+#endif
+
+
+void TiXmlElement::SetDoubleAttribute( const char * name, double val )
+{	
+	char buf[256];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%f", val );
+	#else
+		sprintf( buf, "%f", val );
+	#endif
+	SetAttribute( name, buf );
+}
+
+
+void TiXmlElement::SetAttribute( const char * cname, const char * cvalue )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING _name( cname );
+	TIXML_STRING _value( cvalue );
+	#else
+	const char* _name = cname;
+	const char* _value = cvalue;
+	#endif
+
+	TiXmlAttribute* node = attributeSet.Find( _name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( cname, cvalue );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, const std::string& _value )
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+#endif
+
+
+void TiXmlElement::Print( FILE* cfile, int depth ) const
+{
+	int i;
+	assert( cfile );
+	for ( i=0; i<depth; i++ ) {
+		fprintf( cfile, "    " );
+	}
+
+	fprintf( cfile, "<%s", value.c_str() );
+
+	const TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		fprintf( cfile, " " );
+		attrib->Print( cfile, depth );
+	}
+
+	// There are 3 different formatting approaches:
+	// 1) An element without children is printed as a <foo /> node
+	// 2) An element with only a text child is printed as <foo> text </foo>
+	// 3) An element with children is printed on multiple lines.
+	TiXmlNode* node;
+	if ( !firstChild )
+	{
+		fprintf( cfile, " />" );
+	}
+	else if ( firstChild == lastChild && firstChild->ToText() )
+	{
+		fprintf( cfile, ">" );
+		firstChild->Print( cfile, depth + 1 );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+	else
+	{
+		fprintf( cfile, ">" );
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			if ( !node->ToText() )
+			{
+				fprintf( cfile, "\n" );
+			}
+			node->Print( cfile, depth+1 );
+		}
+		fprintf( cfile, "\n" );
+		for( i=0; i<depth; ++i ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+}
+
+
+void TiXmlElement::CopyTo( TiXmlElement* target ) const
+{
+	// superclass:
+	TiXmlNode::CopyTo( target );
+
+	// Element class: 
+	// Clone the attributes, then clone the children.
+	const TiXmlAttribute* attribute = 0;
+	for(	attribute = attributeSet.First();
+	attribute;
+	attribute = attribute->Next() )
+	{
+		target->SetAttribute( attribute->Name(), attribute->Value() );
+	}
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+bool TiXmlElement::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this, attributeSet.First() ) ) 
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+TiXmlNode* TiXmlElement::Clone() const
+{
+	TiXmlElement* clone = new TiXmlElement( Value() );
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+const char* TiXmlElement::GetText() const
+{
+	const TiXmlNode* child = this->FirstChild();
+	if ( child ) {
+		const TiXmlText* childText = child->ToText();
+		if ( childText ) {
+			return childText->Value();
+		}
+	}
+	return 0;
+}
+
+
+TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	ClearError();
+}
+
+TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	value = documentName;
+	ClearError();
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+    value = documentName;
+	ClearError();
+}
+#endif
+
+
+TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDocument::operator=( const TiXmlDocument& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
+{
+	// See STL_STRING_BUG below.
+	//StringToBuffer buf( value );
+
+	return LoadFile( Value(), encoding );
+}
+
+
+bool TiXmlDocument::SaveFile() const
+{
+	// See STL_STRING_BUG below.
+//	StringToBuffer buf( value );
+//
+//	if ( buf.buffer && SaveFile( buf.buffer ) )
+//		return true;
+//
+//	return false;
+	return SaveFile( Value() );
+}
+
+bool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )
+{
+	// There was a really terrifying little bug here. The code:
+	//		value = filename
+	// in the STL case, cause the assignment method of the std::string to
+	// be called. What is strange, is that the std::string had the same
+	// address as it's c_str() method, and so bad things happen. Looks
+	// like a bug in the Microsoft STL implementation.
+	// Add an extra string to avoid the crash.
+	TIXML_STRING filename( _filename );
+	value = filename;
+
+	// reading in binary mode so that tinyxml can normalize the EOL
+	FILE* file = TiXmlFOpen( value.c_str (), "rb" );	
+
+	if ( file )
+	{
+		bool result = LoadFile( file, encoding );
+		fclose( file );
+		return result;
+	}
+	else
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+}
+
+bool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )
+{
+	if ( !file ) 
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Delete the existing data:
+	Clear();
+	location.Clear();
+
+	// Get the file size, so we can pre-allocate the string. HUGE speed impact.
+	long length = 0;
+	fseek( file, 0, SEEK_END );
+	length = ftell( file );
+	fseek( file, 0, SEEK_SET );
+
+	// Strange case, but good to handle up front.
+	if ( length <= 0 )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// If we have a file, assume it is all one big XML file, and read it in.
+	// The document parser may decide the document ends sooner than the entire file, however.
+	TIXML_STRING data;
+	data.reserve( length );
+
+	// Subtle bug here. TinyXml did use fgets. But from the XML spec:
+	// 2.11 End-of-Line Handling
+	// <snip>
+	// <quote>
+	// ...the XML processor MUST behave as if it normalized all line breaks in external 
+	// parsed entities (including the document entity) on input, before parsing, by translating 
+	// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to 
+	// a single #xA character.
+	// </quote>
+	//
+	// It is not clear fgets does that, and certainly isn't clear it works cross platform. 
+	// Generally, you expect fgets to translate from the convention of the OS to the c/unix
+	// convention, and not work generally.
+
+	/*
+	while( fgets( buf, sizeof(buf), file ) )
+	{
+		data += buf;
+	}
+	*/
+
+	char* buf = new char[ length+1 ];
+	buf[0] = 0;
+
+	if ( fread( buf, length, 1, file ) != 1 ) {
+		delete [] buf;
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	const char* lastPos = buf;
+	const char* p = buf;
+
+	buf[length] = 0;
+	while( *p ) {
+		assert( p < (buf+length) );
+		if ( *p == 0xa ) {
+			// Newline character. No special rules for this. Append all the characters
+			// since the last string, and include the newline.
+			data.append( lastPos, (p-lastPos+1) );	// append, include the newline
+			++p;									// move past the newline
+			lastPos = p;							// and point to the new buffer (may be 0)
+			assert( p <= (buf+length) );
+		}
+		else if ( *p == 0xd ) {
+			// Carriage return. Append what we have so far, then
+			// handle moving forward in the buffer.
+			if ( (p-lastPos) > 0 ) {
+				data.append( lastPos, p-lastPos );	// do not add the CR
+			}
+			data += (char)0xa;						// a proper newline
+
+			if ( *(p+1) == 0xa ) {
+				// Carriage return - new line sequence
+				p += 2;
+				lastPos = p;
+				assert( p <= (buf+length) );
+			}
+			else {
+				// it was followed by something else...that is presumably characters again.
+				++p;
+				lastPos = p;
+				assert( p <= (buf+length) );
+			}
+		}
+		else {
+			++p;
+		}
+	}
+	// Handle any left over characters.
+	if ( p-lastPos ) {
+		data.append( lastPos, p-lastPos );
+	}		
+	delete [] buf;
+	buf = 0;
+
+	Parse( data.c_str(), 0, encoding );
+
+	if (  Error() )
+        return false;
+    else
+		return true;
+}
+
+
+bool TiXmlDocument::SaveFile( const char * filename ) const
+{
+	// The old c stuff lives on...
+	FILE* fp = TiXmlFOpen( filename, "w" );
+	if ( fp )
+	{
+		bool result = SaveFile( fp );
+		fclose( fp );
+		return result;
+	}
+	return false;
+}
+
+
+bool TiXmlDocument::SaveFile( FILE* fp ) const
+{
+	if ( useMicrosoftBOM ) 
+	{
+		const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+		const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+		const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+		fputc( TIXML_UTF_LEAD_0, fp );
+		fputc( TIXML_UTF_LEAD_1, fp );
+		fputc( TIXML_UTF_LEAD_2, fp );
+	}
+	Print( fp, 0 );
+	return (ferror(fp) == 0);
+}
+
+
+void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->error = error;
+	target->errorId = errorId;
+	target->errorDesc = errorDesc;
+	target->tabsize = tabsize;
+	target->errorLocation = errorLocation;
+	target->useMicrosoftBOM = useMicrosoftBOM;
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}	
+}
+
+
+TiXmlNode* TiXmlDocument::Clone() const
+{
+	TiXmlDocument* clone = new TiXmlDocument();
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlDocument::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->Print( cfile, depth );
+		fprintf( cfile, "\n" );
+	}
+}
+
+
+bool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this ) )
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+const TiXmlAttribute* TiXmlAttribute::Next() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Next()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+*/
+
+const TiXmlAttribute* TiXmlAttribute::Previous() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Previous()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+*/
+
+void TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	TIXML_STRING n, v;
+
+	EncodeString( name, &n );
+	EncodeString( value, &v );
+
+	if (value.find ('\"') == TIXML_STRING::npos) {
+		if ( cfile ) {
+		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "=\""; (*str) += v; (*str) += "\"";
+		}
+	}
+	else {
+		if ( cfile ) {
+		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "='"; (*str) += v; (*str) += "'";
+		}
+	}
+}
+
+
+int TiXmlAttribute::QueryIntValue( int* ival ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%d", ival ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+int TiXmlAttribute::QueryDoubleValue( double* dval ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%lf", dval ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+void TiXmlAttribute::SetIntValue( int _value )
+{
+	char buf [64];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF(buf, sizeof(buf), "%d", _value);
+	#else
+		sprintf (buf, "%d", _value);
+	#endif
+	SetValue (buf);
+}
+
+void TiXmlAttribute::SetDoubleValue( double _value )
+{
+	char buf [256];
+	#if defined(TIXML_SNPRINTF)		
+		TIXML_SNPRINTF( buf, sizeof(buf), "%lf", _value);
+	#else
+		sprintf (buf, "%lf", _value);
+	#endif
+	SetValue (buf);
+}
+
+int TiXmlAttribute::IntValue() const
+{
+	return atoi (value.c_str ());
+}
+
+double  TiXmlAttribute::DoubleValue() const
+{
+	return atof (value.c_str ());
+}
+
+
+TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::COMMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlComment::operator=( const TiXmlComment& base )
+{
+	Clear();
+	base.CopyTo( this );
+}
+
+
+void TiXmlComment::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( int i=0; i<depth; i++ )
+	{
+		fprintf( cfile,  "    " );
+	}
+	fprintf( cfile, "<!--%s-->", value.c_str() );
+}
+
+
+void TiXmlComment::CopyTo( TiXmlComment* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlComment::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlComment::Clone() const
+{
+	TiXmlComment* clone = new TiXmlComment();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlText::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	if ( cdata )
+	{
+		int i;
+		fprintf( cfile, "\n" );
+		for ( i=0; i<depth; i++ ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "<![CDATA[%s]]>\n", value.c_str() );	// unformatted output
+	}
+	else
+	{
+		TIXML_STRING buffer;
+		EncodeString( value, &buffer );
+		fprintf( cfile, "%s", buffer.c_str() );
+	}
+}
+
+
+void TiXmlText::CopyTo( TiXmlText* target ) const
+{
+	TiXmlNode::CopyTo( target );
+	target->cdata = cdata;
+}
+
+
+bool TiXmlText::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlText::Clone() const
+{	
+	TiXmlText* clone = 0;
+	clone = new TiXmlText( "" );
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDeclaration::TiXmlDeclaration( const char * _version,
+									const char * _encoding,
+									const char * _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
+									const std::string& _encoding,
+									const std::string& _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+#endif
+
+
+TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	copy.CopyTo( this );	
+}
+
+
+void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	if ( cfile ) fprintf( cfile, "<?xml " );
+	if ( str )	 (*str) += "<?xml ";
+
+	if ( !version.empty() ) {
+		if ( cfile ) fprintf (cfile, "version=\"%s\" ", version.c_str ());
+		if ( str ) { (*str) += "version=\""; (*str) += version; (*str) += "\" "; }
+	}
+	if ( !encoding.empty() ) {
+		if ( cfile ) fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
+		if ( str ) { (*str) += "encoding=\""; (*str) += encoding; (*str) += "\" "; }
+	}
+	if ( !standalone.empty() ) {
+		if ( cfile ) fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
+		if ( str ) { (*str) += "standalone=\""; (*str) += standalone; (*str) += "\" "; }
+	}
+	if ( cfile ) fprintf( cfile, "?>" );
+	if ( str )	 (*str) += "?>";
+}
+
+
+void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->version = version;
+	target->encoding = encoding;
+	target->standalone = standalone;
+}
+
+
+bool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlDeclaration::Clone() const
+{	
+	TiXmlDeclaration* clone = new TiXmlDeclaration();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlUnknown::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+		fprintf( cfile, "    " );
+	fprintf( cfile, "<%s>", value.c_str() );
+}
+
+
+void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlUnknown::Clone() const
+{
+	TiXmlUnknown* clone = new TiXmlUnknown();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlAttributeSet::TiXmlAttributeSet()
+{
+	sentinel.next = &sentinel;
+	sentinel.prev = &sentinel;
+}
+
+
+TiXmlAttributeSet::~TiXmlAttributeSet()
+{
+	assert( sentinel.next == &sentinel );
+	assert( sentinel.prev == &sentinel );
+}
+
+
+void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
+{
+    #ifdef TIXML_USE_STL
+	assert( !Find( TIXML_STRING( addMe->Name() ) ) );	// Shouldn't be multiply adding to the set.
+	#else
+	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
+	#endif
+
+	addMe->next = &sentinel;
+	addMe->prev = sentinel.prev;
+
+	sentinel.prev->next = addMe;
+	sentinel.prev      = addMe;
+}
+
+void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node == removeMe )
+		{
+			node->prev->next = node->next;
+			node->next->prev = node->prev;
+			node->next = 0;
+			node->prev = 0;
+			return;
+		}
+	}
+	assert( 0 );		// we tried to remove a non-linked attribute.
+}
+
+
+#ifdef TIXML_USE_STL
+const TiXmlAttribute* TiXmlAttributeSet::Find( const std::string& name ) const
+{
+	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+
+/*
+TiXmlAttribute*	TiXmlAttributeSet::Find( const std::string& name )
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+*/
+#endif
+
+
+const TiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const
+{
+	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+/*
+TiXmlAttribute*	TiXmlAttributeSet::Find( const char* name )
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+*/
+
+#ifdef TIXML_USE_STL	
+std::istream& operator>> (std::istream & in, TiXmlNode & base)
+{
+	TIXML_STRING tag;
+	tag.reserve( 8 * 1000 );
+	base.StreamIn( &in, &tag );
+
+	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
+	return in;
+}
+#endif
+
+
+#ifdef TIXML_USE_STL	
+std::ostream& operator<< (std::ostream & out, const TiXmlNode & base)
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out << printer.Str();
+
+	return out;
+}
+
+
+std::string& operator<< (std::string& out, const TiXmlNode& base )
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out.append( printer.Str() );
+
+	return out;
+}
+#endif
+
+
+TiXmlHandle TiXmlHandle::FirstChild() const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement() const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+bool TiXmlPrinter::VisitEnter( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitExit( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += element.Value();
+
+	for( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )
+	{
+		buffer += " ";
+		attrib->Print( 0, 0, &buffer );
+	}
+
+	if ( !element.FirstChild() ) 
+	{
+		buffer += " />";
+		DoLineBreak();
+	}
+	else 
+	{
+		buffer += ">";
+		if (    element.FirstChild()->ToText()
+			  && element.LastChild() == element.FirstChild()
+			  && element.FirstChild()->ToText()->CDATA() == false )
+		{
+			simpleTextPrint = true;
+			// no DoLineBreak()!
+		}
+		else
+		{
+			DoLineBreak();
+		}
+	}
+	++depth;	
+	return true;
+}
+
+
+bool TiXmlPrinter::VisitExit( const TiXmlElement& element )
+{
+	--depth;
+	if ( !element.FirstChild() ) 
+	{
+		// nothing.
+	}
+	else 
+	{
+		if ( simpleTextPrint )
+		{
+			simpleTextPrint = false;
+		}
+		else
+		{
+			DoIndent();
+		}
+		buffer += "</";
+		buffer += element.Value();
+		buffer += ">";
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlText& text )
+{
+	if ( text.CDATA() )
+	{
+		DoIndent();
+		buffer += "<![CDATA[";
+		buffer += text.Value();
+		buffer += "]]>";
+		DoLineBreak();
+	}
+	else if ( simpleTextPrint )
+	{
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+	}
+	else
+	{
+		DoIndent();
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )
+{
+	DoIndent();
+	declaration.Print( 0, 0, &buffer );
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlComment& comment )
+{
+	DoIndent();
+	buffer += "<!--";
+	buffer += comment.Value();
+	buffer += "-->";
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += unknown.Value();
+	buffer += ">";
+	DoLineBreak();
+	return true;
+}
+

Added: dependencies/tinyxml/tinyxml.dsw
===================================================================
--- dependencies/tinyxml/tinyxml.dsw	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxml.dsw	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,71 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "tinyXmlTest"=.\tinyXmlTest.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name tinyxml
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "tinyXmlTestSTL"=.\tinyXmlTestSTL.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name tinyxmlSTL
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "tinyxml"=.\tinyxml_lib.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "tinyxmlSTL"=.\tinyxmlSTL.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+

Added: dependencies/tinyxml/tinyxml.h
===================================================================
--- dependencies/tinyxml/tinyxml.h	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxml.h	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,1800 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+#ifndef TINYXML_INCLUDED
+#define TINYXML_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( push )
+#pragma warning( disable : 4530 )
+#pragma warning( disable : 4786 )
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+// Help out windows:
+#if defined( _DEBUG ) && !defined( DEBUG )
+#define DEBUG
+#endif
+
+#ifdef TIXML_USE_STL
+	#include <string>
+ 	#include <iostream>
+	#include <sstream>
+	#define TIXML_STRING		std::string
+#else
+	#include "tinystr.h"
+	#define TIXML_STRING		TiXmlString
+#endif
+
+// Deprecated library function hell. Compilers want to use the
+// new safe versions. This probably doesn't fully address the problem,
+// but it gets closer. There are too many compilers for me to fully
+// test. If you get compilation troubles, undefine TIXML_SAFE
+#define TIXML_SAFE
+
+#ifdef TIXML_SAFE
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		// Microsoft visual studio, version 2005 and higher.
+		#define TIXML_SNPRINTF _snprintf_s
+		#define TIXML_SNSCANF  _snscanf_s
+		#define TIXML_SSCANF   sscanf_s
+	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
+		// Microsoft visual studio, version 6 and higher.
+		//#pragma message( "Using _sn* functions." )
+		#define TIXML_SNPRINTF _snprintf
+		#define TIXML_SNSCANF  _snscanf
+		#define TIXML_SSCANF   sscanf
+	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+		// GCC version 3 and higher.s
+		//#warning( "Using sn* functions." )
+		#define TIXML_SNPRINTF snprintf
+		#define TIXML_SNSCANF  snscanf
+		#define TIXML_SSCANF   sscanf
+	#else
+		#define TIXML_SSCANF   sscanf
+	#endif
+#endif	
+
+class TiXmlDocument;
+class TiXmlElement;
+class TiXmlComment;
+class TiXmlUnknown;
+class TiXmlAttribute;
+class TiXmlText;
+class TiXmlDeclaration;
+class TiXmlParsingData;
+
+const int TIXML_MAJOR_VERSION = 2;
+const int TIXML_MINOR_VERSION = 5;
+const int TIXML_PATCH_VERSION = 3;
+
+/*	Internal structure for tracking location of items 
+	in the XML file.
+*/
+struct TiXmlCursor
+{
+	TiXmlCursor()		{ Clear(); }
+	void Clear()		{ row = col = -1; }
+
+	int row;	// 0 based.
+	int col;	// 0 based.
+};
+
+
+/**
+	If you call the Accept() method, it requires being passed a TiXmlVisitor
+	class to handle callbacks. For nodes that contain other nodes (Document, Element)
+	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
+	are simple called with Visit().
+
+	If you return 'true' from a Visit method, recursive parsing will continue. If you return
+	false, <b>no children of this node or its sibilings</b> will be Visited.
+
+	All flavors of Visit methods have a default implementation that returns 'true' (continue 
+	visiting). You need to only override methods that are interesting to you.
+
+	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.
+
+	You should never change the document from a callback.
+
+	@sa TiXmlNode::Accept()
+*/
+class TiXmlVisitor
+{
+public:
+	virtual ~TiXmlVisitor() {}
+
+	/// Visit a document.
+	virtual bool VisitEnter( const TiXmlDocument& /*doc*/ )			{ return true; }
+	/// Visit a document.
+	virtual bool VisitExit( const TiXmlDocument& /*doc*/ )			{ return true; }
+
+	/// Visit an element.
+	virtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )	{ return true; }
+	/// Visit an element.
+	virtual bool VisitExit( const TiXmlElement& /*element*/ )		{ return true; }
+
+	/// Visit a declaration
+	virtual bool Visit( const TiXmlDeclaration& /*declaration*/ )	{ return true; }
+	/// Visit a text node
+	virtual bool Visit( const TiXmlText& /*text*/ )					{ return true; }
+	/// Visit a comment node
+	virtual bool Visit( const TiXmlComment& /*comment*/ )			{ return true; }
+	/// Visit an unknow node
+	virtual bool Visit( const TiXmlUnknown& /*unknown*/ )			{ return true; }
+};
+
+// Only used by Attribute::Query functions
+enum 
+{ 
+	TIXML_SUCCESS,
+	TIXML_NO_ATTRIBUTE,
+	TIXML_WRONG_TYPE
+};
+
+
+// Used by the parsing routines.
+enum TiXmlEncoding
+{
+	TIXML_ENCODING_UNKNOWN,
+	TIXML_ENCODING_UTF8,
+	TIXML_ENCODING_LEGACY
+};
+
+const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+
+/** TiXmlBase is a base class for every class in TinyXml.
+	It does little except to establish that TinyXml classes
+	can be printed and provide some utility functions.
+
+	In XML, the document and elements can contain
+	other elements and other types of nodes.
+
+	@verbatim
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	@endverbatim
+*/
+class TiXmlBase
+{
+	friend class TiXmlNode;
+	friend class TiXmlElement;
+	friend class TiXmlDocument;
+
+public:
+	TiXmlBase()	:	userData(0)		{}
+	virtual ~TiXmlBase()			{}
+
+	/**	All TinyXml classes can print themselves to a filestream
+		or the string class (TiXmlString in non-STL mode, std::string
+		in STL mode.) Either or both cfile and str can be null.
+		
+		This is a formatted print, and will insert 
+		tabs and newlines.
+		
+		(For an unformatted stream, use the << operator.)
+	*/
+	virtual void Print( FILE* cfile, int depth ) const = 0;
+
+	/**	The world does not agree on whether white space should be kept or
+		not. In order to make everyone happy, these global, static functions
+		are provided to set whether or not TinyXml will condense all white space
+		into a single space or not. The default is to condense. Note changing this
+		value is not thread safe.
+	*/
+	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
+
+	/// Return the current white space setting.
+	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
+
+	/** Return the position, in the original source file, of this node or attribute.
+		The row and column are 1-based. (That is the first row and first column is
+		1,1). If the returns values are 0 or less, then the parser does not have
+		a row and column value.
+
+		Generally, the row and column value will be set when the TiXmlDocument::Load(),
+		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
+		when the DOM was created from operator>>.
+
+		The values reflect the initial load. Once the DOM is modified programmatically
+		(by adding or changing nodes and attributes) the new values will NOT update to
+		reflect changes in the document.
+
+		There is a minor performance cost to computing the row and column. Computation
+		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
+
+		@sa TiXmlDocument::SetTabSize()
+	*/
+	int Row() const			{ return location.row + 1; }
+	int Column() const		{ return location.col + 1; }	///< See Row()
+
+	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
+	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
+	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.
+
+	// Table that returs, for a given lead byte, the total number of bytes
+	// in the UTF-8 sequence.
+	static const int utf8ByteTable[256];
+
+	virtual const char* Parse(	const char* p, 
+								TiXmlParsingData* data, 
+								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
+
+	/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, 
+		or they will be transformed into entities!
+	*/
+	static void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );
+
+	enum
+	{
+		TIXML_NO_ERROR = 0,
+		TIXML_ERROR,
+		TIXML_ERROR_OPENING_FILE,
+		TIXML_ERROR_OUT_OF_MEMORY,
+		TIXML_ERROR_PARSING_ELEMENT,
+		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+		TIXML_ERROR_READING_ELEMENT_VALUE,
+		TIXML_ERROR_READING_ATTRIBUTES,
+		TIXML_ERROR_PARSING_EMPTY,
+		TIXML_ERROR_READING_END_TAG,
+		TIXML_ERROR_PARSING_UNKNOWN,
+		TIXML_ERROR_PARSING_COMMENT,
+		TIXML_ERROR_PARSING_DECLARATION,
+		TIXML_ERROR_DOCUMENT_EMPTY,
+		TIXML_ERROR_EMBEDDED_NULL,
+		TIXML_ERROR_PARSING_CDATA,
+		TIXML_ERROR_DOCUMENT_TOP_ONLY,
+
+		TIXML_ERROR_STRING_COUNT
+	};
+
+protected:
+
+	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );
+	inline static bool IsWhiteSpace( char c )		
+	{ 
+		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 
+	}
+	inline static bool IsWhiteSpace( int c )
+	{
+		if ( c < 256 )
+			return IsWhiteSpace( (char) c );
+		return false;	// Again, only truly correct for English/Latin...but usually works.
+	}
+
+	#ifdef TIXML_USE_STL
+	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
+	#endif
+
+	/*	Reads an XML name into the string provided. Returns
+		a pointer just past the last character of the name,
+		or 0 if the function has an error.
+	*/
+	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
+
+	/*	Reads text. Returns a pointer past the given end tag.
+		Wickedly complex options, but it keeps the (sensitive) code in one place.
+	*/
+	static const char* ReadText(	const char* in,				// where to start
+									TIXML_STRING* text,			// the string read
+									bool ignoreWhiteSpace,		// whether to keep the white space
+									const char* endTag,			// what ends this text
+									bool ignoreCase,			// whether to ignore case in the end tag
+									TiXmlEncoding encoding );	// the current encoding
+
+	// If an entity has been found, transform it into a character.
+	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
+
+	// Get a character, while interpreting entities.
+	// The length can be from 0 to 4 bytes.
+	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
+	{
+		assert( p );
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			*length = utf8ByteTable[ *((const unsigned char*)p) ];
+			assert( *length >= 0 && *length < 5 );
+		}
+		else
+		{
+			*length = 1;
+		}
+
+		if ( *length == 1 )
+		{
+			if ( *p == '&' )
+				return GetEntity( p, _value, length, encoding );
+			*_value = *p;
+			return p+1;
+		}
+		else if ( *length )
+		{
+			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
+												// and the null terminator isn't needed
+			for( int i=0; p[i] && i<*length; ++i ) {
+				_value[i] = p[i];
+			}
+			return p + (*length);
+		}
+		else
+		{
+			// Not valid text.
+			return 0;
+		}
+	}
+
+	// Return true if the next characters in the stream are any of the endTag sequences.
+	// Ignore case only works for english, and should only be relied on when comparing
+	// to English words: StringEqual( p, "version", true ) is fine.
+	static bool StringEqual(	const char* p,
+								const char* endTag,
+								bool ignoreCase,
+								TiXmlEncoding encoding );
+
+	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
+
+	TiXmlCursor location;
+
+    /// Field containing a generic user pointer
+	void*			userData;
+	
+	// None of these methods are reliable for any language except English.
+	// Good for approximation, not great for accuracy.
+	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
+	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
+	inline static int ToLower( int v, TiXmlEncoding encoding )
+	{
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			if ( v < 128 ) return tolower( v );
+			return v;
+		}
+		else
+		{
+			return tolower( v );
+		}
+	}
+	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+private:
+	TiXmlBase( const TiXmlBase& );				// not implemented.
+	void operator=( const TiXmlBase& base );	// not allowed.
+
+	struct Entity
+	{
+		const char*     str;
+		unsigned int	strLength;
+		char		    chr;
+	};
+	enum
+	{
+		NUM_ENTITY = 5,
+		MAX_ENTITY_LENGTH = 6
+
+	};
+	static Entity entity[ NUM_ENTITY ];
+	static bool condenseWhiteSpace;
+};
+
+
+/** The parent class for everything in the Document Object Model.
+	(Except for attributes).
+	Nodes have siblings, a parent, and children. A node can be
+	in a document, or stand on its own. The type of a TiXmlNode
+	can be queried, and it can be cast to its more defined type.
+*/
+class TiXmlNode : public TiXmlBase
+{
+	friend class TiXmlDocument;
+	friend class TiXmlElement;
+
+public:
+	#ifdef TIXML_USE_STL	
+
+	    /** An input stream operator, for every class. Tolerant of newlines and
+		    formatting, but doesn't expect them.
+	    */
+	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
+
+	    /** An output stream operator, for every class. Note that this outputs
+		    without any newlines or formatting, as opposed to Print(), which
+		    includes tabs and new lines.
+
+		    The operator<< and operator>> are not completely symmetric. Writing
+		    a node to a stream is very well defined. You'll get a nice stream
+		    of output, without any extra whitespace or newlines.
+		    
+		    But reading is not as well defined. (As it always is.) If you create
+		    a TiXmlElement (for example) and read that from an input stream,
+		    the text needs to define an element or junk will result. This is
+		    true of all input streams, but it's worth keeping in mind.
+
+		    A TiXmlDocument will read nodes until it reads a root element, and
+			all the children of that root element.
+	    */	
+	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
+
+		/// Appends the XML node or attribute to a std::string.
+		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
+
+	#endif
+
+	/** The types of XML nodes supported by TinyXml. (All the
+			unsupported types are picked up by UNKNOWN.)
+	*/
+	enum NodeType
+	{
+		DOCUMENT,
+		ELEMENT,
+		COMMENT,
+		UNKNOWN,
+		TEXT,
+		DECLARATION,
+		TYPECOUNT
+	};
+
+	virtual ~TiXmlNode();
+
+	/** The meaning of 'value' changes for the specific type of
+		TiXmlNode.
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+
+		The subclasses will wrap this function.
+	*/
+	const char *Value() const { return value.c_str (); }
+
+    #ifdef TIXML_USE_STL
+	/** Return Value() as a std::string. If you only use STL,
+	    this is more efficient than calling Value().
+		Only available in STL mode.
+	*/
+	const std::string& ValueStr() const { return value; }
+	#endif
+
+	const TIXML_STRING& ValueTStr() const { return value; }
+
+	/** Changes the value of the node. Defined as:
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+	*/
+	void SetValue(const char * _value) { value = _value;}
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Delete all the children of this node. Does not affect 'this'.
+	void Clear();
+
+	/// One step up the DOM.
+	TiXmlNode* Parent()							{ return parent; }
+	const TiXmlNode* Parent() const				{ return parent; }
+
+	const TiXmlNode* FirstChild()	const		{ return firstChild; }	///< The first child of this node. Will be null if there are no children.
+	TiXmlNode* FirstChild()						{ return firstChild; }
+	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
+	/// The first child of this node with the matching 'value'. Will be null if none found.
+	TiXmlNode* FirstChild( const char * _value ) {
+		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
+		// call the method, cast the return back to non-const.
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
+	}
+	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
+	TiXmlNode* LastChild()	{ return lastChild; }
+	
+	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
+	TiXmlNode* LastChild( const char * _value ) {
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** An alternate way to walk the children of a node.
+		One way to iterate over nodes is:
+		@verbatim
+			for( child = parent->FirstChild(); child; child = child->NextSibling() )
+		@endverbatim
+
+		IterateChildren does the same thing with the syntax:
+		@verbatim
+			child = 0;
+			while( child = parent->IterateChildren( child ) )
+		@endverbatim
+
+		IterateChildren takes the previous child as input and finds
+		the next one. If the previous child is null, it returns the
+		first. IterateChildren will return null when done.
+	*/
+	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
+	}
+
+	/// This flavor of IterateChildren searches for children with a particular 'value'
+	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	#endif
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
+
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+
+		NOTE: the node to be added is passed by pointer, and will be
+		henceforth owned (and deleted) by tinyXml. This method is efficient
+		and avoids an extra copy, but should be used with care as it
+		uses a different memory model than the other insert functions.
+
+		@sa InsertEndChild
+	*/
+	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
+
+	/** Add a new node related to this. Adds a child before the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
+
+	/** Add a new node related to this. Adds a child after the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
+
+	/** Replace a child of this node.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
+
+	/// Delete a child of this node.
+	bool RemoveChild( TiXmlNode* removeThis );
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling() const			{ return prev; }
+	TiXmlNode* PreviousSibling()						{ return prev; }
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling( const char * ) const;
+	TiXmlNode* PreviousSibling( const char *_prev ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* NextSibling() const				{ return next; }
+	TiXmlNode* NextSibling()							{ return next; }
+
+	/// Navigate to a sibling node with the given 'value'.
+	const TiXmlNode* NextSibling( const char * ) const;
+	TiXmlNode* NextSibling( const char* _next ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement() const;
+	TiXmlElement* NextSiblingElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement( const char * ) const;
+	TiXmlElement* NextSiblingElement( const char *_next ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement()	const;
+	TiXmlElement* FirstChildElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
+	}
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement( const char * _value ) const;
+	TiXmlElement* FirstChildElement( const char * _value ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** Query the type (as an enumerated value, above) of this node.
+		The possible types are: DOCUMENT, ELEMENT, COMMENT,
+								UNKNOWN, TEXT, and DECLARATION.
+	*/
+	int Type() const	{ return type; }
+
+	/** Return a pointer to the Document this node lives in.
+		Returns null if not in a document.
+	*/
+	const TiXmlDocument* GetDocument() const;
+	TiXmlDocument* GetDocument() {
+		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
+	}
+
+	/// Returns true if this node has no children.
+	bool NoChildren() const						{ return !firstChild; }
+
+	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	/** Create an exact duplicate of this node and return it. The memory must be deleted
+		by the caller. 
+	*/
+	virtual TiXmlNode* Clone() const = 0;
+
+	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
+		XML tree will be conditionally visited and the host will be called back
+		via the TiXmlVisitor interface.
+
+		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
+		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
+		interface versus any other.)
+
+		The interface has been based on ideas from:
+
+		- http://www.saxproject.org/
+		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern 
+
+		Which are both good references for "visiting".
+
+		An example of using Accept():
+		@verbatim
+		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &printer );
+		const char* xmlcstr = printer.CStr();
+		@endverbatim
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;
+
+protected:
+	TiXmlNode( NodeType _type );
+
+	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
+	// and the assignment operator.
+	void CopyTo( TiXmlNode* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    // The real work of the input operator.
+	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+	#endif
+
+	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
+	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
+
+	TiXmlNode*		parent;
+	NodeType		type;
+
+	TiXmlNode*		firstChild;
+	TiXmlNode*		lastChild;
+
+	TIXML_STRING	value;
+
+	TiXmlNode*		prev;
+	TiXmlNode*		next;
+
+private:
+	TiXmlNode( const TiXmlNode& );				// not implemented.
+	void operator=( const TiXmlNode& base );	// not allowed.
+};
+
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+	number of attributes, each with a unique name.
+
+	@note The attributes are not TiXmlNodes, since they are not
+		  part of the tinyXML document object model. There are other
+		  suggested ways to look at this problem.
+*/
+class TiXmlAttribute : public TiXmlBase
+{
+	friend class TiXmlAttributeSet;
+
+public:
+	/// Construct an empty attribute.
+	TiXmlAttribute() : TiXmlBase()
+	{
+		document = 0;
+		prev = next = 0;
+	}
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlAttribute( const std::string& _name, const std::string& _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+	#endif
+
+	/// Construct an attribute with a name and value.
+	TiXmlAttribute( const char * _name, const char * _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+
+	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
+	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
+	#ifdef TIXML_USE_STL
+	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
+	#endif
+	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
+	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.
+
+	// Get the tinyxml string representation
+	const TIXML_STRING& NameTStr() const { return name; }
+
+	/** QueryIntValue examines the value string. It is an alternative to the
+		IntValue() method with richer error checking.
+		If the value is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE.
+
+		A specialized but useful call. Note that for success it returns 0,
+		which is the opposite of almost all other TinyXml calls.
+	*/
+	int QueryIntValue( int* _value ) const;
+	/// QueryDoubleValue examines the value string. See QueryIntValue().
+	int QueryDoubleValue( double* _value ) const;
+
+	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
+	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
+
+	void SetIntValue( int _value );										///< Set the value from an integer.
+	void SetDoubleValue( double _value );								///< Set the value from a double.
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetName( const std::string& _name )	{ name = _name; }	
+	/// STL std::string form.	
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Get the next sibling attribute in the DOM. Returns null at end.
+	const TiXmlAttribute* Next() const;
+	TiXmlAttribute* Next() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() ); 
+	}
+
+	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
+	const TiXmlAttribute* Previous() const;
+	TiXmlAttribute* Previous() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() ); 
+	}
+
+	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
+	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
+	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
+
+	/*	Attribute parsing starts: first letter of the name
+						 returns: the next char after the value end quote
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	// Prints this Attribute to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+
+	// [internal use]
+	// Set the document pointer so the attribute can report errors.
+	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
+
+private:
+	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
+	void operator=( const TiXmlAttribute& base );	// not allowed.
+
+	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
+	TIXML_STRING name;
+	TIXML_STRING value;
+	TiXmlAttribute*	prev;
+	TiXmlAttribute*	next;
+};
+
+
+/*	A class used to manage a group of attributes.
+	It is only used internally, both by the ELEMENT and the DECLARATION.
+	
+	The set can be changed transparent to the Element and Declaration
+	classes that use it, but NOT transparent to the Attribute
+	which has to implement a next() and previous() method. Which makes
+	it a bit problematic and prevents the use of STL.
+
+	This version is implemented with circular lists because:
+		- I like circular lists
+		- it demonstrates some independence from the (typical) doubly linked list.
+*/
+class TiXmlAttributeSet
+{
+public:
+	TiXmlAttributeSet();
+	~TiXmlAttributeSet();
+
+	void Add( TiXmlAttribute* attribute );
+	void Remove( TiXmlAttribute* attribute );
+
+	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+
+	const TiXmlAttribute*	Find( const char* _name ) const;
+	TiXmlAttribute*	Find( const char* _name ) {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
+	}
+	#ifdef TIXML_USE_STL
+	const TiXmlAttribute*	Find( const std::string& _name ) const;
+	TiXmlAttribute*	Find( const std::string& _name ) {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
+	}
+
+	#endif
+
+private:
+	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
+	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
+	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
+	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)
+
+	TiXmlAttribute sentinel;
+};
+
+
+/** The element is a container class. It has a value, the element name,
+	and can contain other elements, text, comments, and unknowns.
+	Elements also contain an arbitrary number of attributes.
+*/
+class TiXmlElement : public TiXmlNode
+{
+public:
+	/// Construct an element.
+	TiXmlElement (const char * in_value);
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlElement( const std::string& _value );
+	#endif
+
+	TiXmlElement( const TiXmlElement& );
+
+	void operator=( const TiXmlElement& base );
+
+	virtual ~TiXmlElement();
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+	*/
+	const char* Attribute( const char* name ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an integer,
+		the integer value will be put in the return 'i', if 'i'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, int* i ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an double,
+		the double value will be put in the return 'd', if 'd'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, double* d ) const;
+
+	/** QueryIntAttribute examines the attribute - it is an alternative to the
+		Attribute() method with richer error checking.
+		If the attribute is an integer, it is stored in 'value' and 
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE. If the attribute
+		does not exist, then TIXML_NO_ATTRIBUTE is returned.
+	*/	
+	int QueryIntAttribute( const char* name, int* _value ) const;
+	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
+	int QueryDoubleAttribute( const char* name, double* _value ) const;
+	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
+	int QueryFloatAttribute( const char* name, float* _value ) const {
+		double d;
+		int result = QueryDoubleAttribute( name, &d );
+		if ( result == TIXML_SUCCESS ) {
+			*_value = (float)d;
+		}
+		return result;
+	}
+
+    #ifdef TIXML_USE_STL
+	/** Template form of the attribute query which will try to read the
+		attribute into the specified type. Very easy, very powerful, but
+		be careful to make sure to call this with the correct type.
+		
+		NOTE: This method doesn't work correctly for 'string' types.
+
+		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
+	*/
+	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+
+		std::stringstream sstream( node->ValueStr() );
+		sstream >> *outValue;
+		if ( !sstream.fail() )
+			return TIXML_SUCCESS;
+		return TIXML_WRONG_TYPE;
+	}
+	/*
+	 This is - in theory - a bug fix for "QueryValueAtribute returns truncated std::string"
+	 but template specialization is hard to get working cross-compiler. Leaving the bug for now.
+	 
+	// The above will fail for std::string because the space character is used as a seperator.
+	// Specialize for strings. Bug [ 1695429 ] QueryValueAtribute returns truncated std::string
+	template<> int QueryValueAttribute( const std::string& name, std::string* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+		*outValue = node->ValueStr();
+		return TIXML_SUCCESS;
+	}
+	*/
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char* name, const char * _value );
+
+    #ifdef TIXML_USE_STL
+	const std::string* Attribute( const std::string& name ) const;
+	const std::string* Attribute( const std::string& name, int* i ) const;
+	const std::string* Attribute( const std::string& name, double* d ) const;
+	int QueryIntAttribute( const std::string& name, int* _value ) const;
+	int QueryDoubleAttribute( const std::string& name, double* _value ) const;
+
+	/// STL std::string form.
+	void SetAttribute( const std::string& name, const std::string& _value );
+	///< STL std::string form.
+	void SetAttribute( const std::string& name, int _value );
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char * name, int value );
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetDoubleAttribute( const char * name, double value );
+
+	/** Deletes an attribute with the given name.
+	*/
+	void RemoveAttribute( const char * name );
+    #ifdef TIXML_USE_STL
+	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
+	#endif
+
+	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
+	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
+	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
+	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }
+
+	/** Convenience function for easy access to the text inside an element. Although easy
+		and concise, GetText() is limited compared to getting the TiXmlText child
+		and accessing it directly.
+	
+		If the first child of 'this' is a TiXmlText, the GetText()
+		returns the character string of the Text node, else null is returned.
+
+		This is a convenient method for getting the text of simple contained text:
+		@verbatim
+		<foo>This is text</foo>
+		const char* str = fooElement->GetText();
+		@endverbatim
+
+		'str' will be a pointer to "This is text". 
+		
+		Note that this function can be misleading. If the element foo was created from
+		this XML:
+		@verbatim
+		<foo><b>This is text</b></foo> 
+		@endverbatim
+
+		then the value of str would be null. The first child node isn't a text node, it is
+		another element. From this XML:
+		@verbatim
+		<foo>This is <b>text</b></foo> 
+		@endverbatim
+		GetText() will return "This is ".
+
+		WARNING: GetText() accesses a child node - don't become confused with the 
+				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
+				 safe type casts on the referenced node.
+	*/
+	const char* GetText() const;
+
+	/// Creates a new Element and returns it - the returned element is a copy.
+	virtual TiXmlNode* Clone() const;
+	// Print the Element to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: next char past '<'
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+
+	void CopyTo( TiXmlElement* target ) const;
+	void ClearThis();	// like clear, but initializes 'this' object as well
+
+	// Used to be public [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+	/*	[internal use]
+		Reads the "value" of the element -- another element, or text.
+		This should terminate with the current end tag.
+	*/
+	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+private:
+
+	TiXmlAttributeSet attributeSet;
+};
+
+
+/**	An XML comment.
+*/
+class TiXmlComment : public TiXmlNode
+{
+public:
+	/// Constructs an empty comment.
+	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
+	/// Construct a comment from text.
+	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::COMMENT ) {
+		SetValue( _value );
+	}
+	TiXmlComment( const TiXmlComment& );
+	void operator=( const TiXmlComment& base );
+
+	virtual ~TiXmlComment()	{}
+
+	/// Returns a copy of this Comment.
+	virtual TiXmlNode* Clone() const;
+	// Write this Comment to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: at the ! of the !--
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlComment* target ) const;
+
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+//	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** XML text. A text node can have 2 ways to output the next. "normal" output 
+	and CDATA. It will default to the mode it was parsed from the XML file and
+	you generally want to leave it alone, but you can change the output mode with 
+	SetCDATA() and query it with CDATA().
+*/
+class TiXmlText : public TiXmlNode
+{
+	friend class TiXmlElement;
+public:
+	/** Constructor for text element. By default, it is treated as 
+		normal, encoded text. If you want it be output as a CDATA text
+		element, set the parameter _cdata to 'true'
+	*/
+	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	virtual ~TiXmlText() {}
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	#endif
+
+	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
+	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
+
+	// Write this text object to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/// Queries whether this represents text using a CDATA section.
+	bool CDATA() const				{ return cdata; }
+	/// Turns on or off a CDATA representation of text.
+	void SetCDATA( bool _cdata )	{ cdata = _cdata; }
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	///  [internal use] Creates a new Element and returns it.
+	virtual TiXmlNode* Clone() const;
+	void CopyTo( TiXmlText* target ) const;
+
+	bool Blank() const;	// returns true if all white space and new lines
+	// [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	bool cdata;			// true if this should be input and output as a CDATA style text element
+};
+
+
+/** In correct XML the declaration is the first entry in the file.
+	@verbatim
+		<?xml version="1.0" standalone="yes"?>
+	@endverbatim
+
+	TinyXml will happily read or write files without a declaration,
+	however. There are 3 possible attributes to the declaration:
+	version, encoding, and standalone.
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 3 and they are always the same.
+*/
+class TiXmlDeclaration : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDeclaration(	const std::string& _version,
+						const std::string& _encoding,
+						const std::string& _standalone );
+#endif
+
+	/// Construct.
+	TiXmlDeclaration(	const char* _version,
+						const char* _encoding,
+						const char* _standalone );
+
+	TiXmlDeclaration( const TiXmlDeclaration& copy );
+	void operator=( const TiXmlDeclaration& copy );
+
+	virtual ~TiXmlDeclaration()	{}
+
+	/// Version. Will return an empty string if none was found.
+	const char *Version() const			{ return version.c_str (); }
+	/// Encoding. Will return an empty string if none was found.
+	const char *Encoding() const		{ return encoding.c_str (); }
+	/// Is this a standalone document?
+	const char *Standalone() const		{ return standalone.c_str (); }
+
+	/// Creates a copy of this Declaration and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlDeclaration* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+	TIXML_STRING version;
+	TIXML_STRING encoding;
+	TIXML_STRING standalone;
+};
+
+
+/** Any tag that tinyXml doesn't recognize is saved as an
+	unknown. It is a tag of text, but should not be modified.
+	It will be written back to the XML, unchanged, when the file
+	is saved.
+
+	DTD tags get thrown into TiXmlUnknowns.
+*/
+class TiXmlUnknown : public TiXmlNode
+{
+public:
+	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
+	virtual ~TiXmlUnknown() {}
+
+	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
+	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
+
+	/// Creates a copy of this Unknown and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this Unknown to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected:
+	void CopyTo( TiXmlUnknown* target ) const;
+
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+};
+
+
+/** Always the top level node. A document binds together all the
+	XML pieces. It can be saved, loaded, and printed to the screen.
+	The 'value' of a document node is the xml file name.
+*/
+class TiXmlDocument : public TiXmlNode
+{
+public:
+	/// Create an empty document, that has no name.
+	TiXmlDocument();
+	/// Create a document with a name. The name of the document is also the filename of the xml.
+	TiXmlDocument( const char * documentName );
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDocument( const std::string& documentName );
+	#endif
+
+	TiXmlDocument( const TiXmlDocument& copy );
+	void operator=( const TiXmlDocument& copy );
+
+	virtual ~TiXmlDocument() {}
+
+	/** Load a file using the current document value.
+		Returns true if successful. Will delete any existing
+		document data before loading.
+	*/
+	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the current document value. Returns true if successful.
+	bool SaveFile() const;
+	/// Load a file using the given filename. Returns true if successful.
+	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given filename. Returns true if successful.
+	bool SaveFile( const char * filename ) const;
+	/** Load a file using the given FILE*. Returns true if successful. Note that this method
+		doesn't stream - the entire object pointed at by the FILE*
+		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
+		file location. Streaming may be added in the future.
+	*/
+	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given FILE*. Returns true if successful.
+	bool SaveFile( FILE* ) const;
+
+	#ifdef TIXML_USE_STL
+	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
+	{
+//		StringToBuffer f( filename );
+//		return ( f.buffer && LoadFile( f.buffer, encoding ));
+		return LoadFile( filename.c_str(), encoding );
+	}
+	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
+	{
+//		StringToBuffer f( filename );
+//		return ( f.buffer && SaveFile( f.buffer ));
+		return SaveFile( filename.c_str() );
+	}
+	#endif
+
+	/** Parse the given null terminated block of xml data. Passing in an encoding to this
+		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
+		to use that encoding, regardless of what TinyXml might otherwise try to detect.
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+	/** Get the root element -- the only top level element -- of the document.
+		In well formed XML, there should only be one. TinyXml is tolerant of
+		multiple elements at the document level.
+	*/
+	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
+	TiXmlElement* RootElement()					{ return FirstChildElement(); }
+
+	/** If an error occurs, Error will be set to true. Also,
+		- The ErrorId() will contain the integer identifier of the error (not generally useful)
+		- The ErrorDesc() method will return the name of the error. (very useful)
+		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
+	*/	
+	bool Error() const						{ return error; }
+
+	/// Contains a textual (english) description of the error if one occurs.
+	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
+
+	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
+		prefer the ErrorId, this function will fetch it.
+	*/
+	int ErrorId()	const				{ return errorId; }
+
+	/** Returns the location (if known) of the error. The first column is column 1, 
+		and the first row is row 1. A value of 0 means the row and column wasn't applicable
+		(memory errors, for example, have no row/column) or the parser lost the error. (An
+		error in the error reporting, in that case.)
+
+		@sa SetTabSize, Row, Column
+	*/
+	int ErrorRow() const	{ return errorLocation.row+1; }
+	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
+
+	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
+		to report the correct values for row and column. It does not change the output
+		or input in any way.
+		
+		By calling this method, with a tab size
+		greater than 0, the row and column of each node and attribute is stored
+		when the file is loaded. Very useful for tracking the DOM back in to
+		the source file.
+
+		The tab size is required for calculating the location of nodes. If not
+		set, the default of 4 is used. The tabsize is set per document. Setting
+		the tabsize to 0 disables row/column tracking.
+
+		Note that row and column tracking is not supported when using operator>>.
+
+		The tab size needs to be enabled before the parse or load. Correct usage:
+		@verbatim
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		@endverbatim
+
+		@sa Row, Column
+	*/
+	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
+
+	int TabSize() const	{ return tabsize; }
+
+	/** If you have handled the error, it can be reset with this call. The error
+		state is automatically cleared if you Parse a new XML block.
+	*/
+	void ClearError()						{	error = false; 
+												errorId = 0; 
+												errorDesc = ""; 
+												errorLocation.row = errorLocation.col = 0; 
+												//errorLocation.last = 0; 
+											}
+
+	/** Write the document to standard out using formatted printing ("pretty print"). */
+	void Print() const						{ Print( stdout, 0 ); }
+
+	/* Write the document to a string using formatted printing ("pretty print"). This
+		will allocate a character array (new char[]) and return it as a pointer. The
+		calling code pust call delete[] on the return char* to avoid a memory leak.
+	*/
+	//char* PrintToMemory() const; 
+
+	/// Print this Document to a FILE stream.
+	virtual void Print( FILE* cfile, int depth = 0 ) const;
+	// [internal use]
+	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children. 
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	// [internal use]
+	virtual TiXmlNode* Clone() const;
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	void CopyTo( TiXmlDocument* target ) const;
+
+	bool error;
+	int  errorId;
+	TIXML_STRING errorDesc;
+	int tabsize;
+	TiXmlCursor errorLocation;
+	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
+};
+
+
+/**
+	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
+	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
+	DOM structure. It is a separate utility class.
+
+	Take an example:
+	@verbatim
+	<Document>
+		<Element attributeA = "valueA">
+			<Child attributeB = "value1" />
+			<Child attributeB = "value2" />
+		</Element>
+	<Document>
+	@endverbatim
+
+	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
+	easy to write a *lot* of code that looks like:
+
+	@verbatim
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root->FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element->FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	@endverbatim
+
+	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
+	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe 
+	and correct to use:
+
+	@verbatim
+	TiXmlHandle docHandle( &document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	@endverbatim
+
+	Which is MUCH more concise and useful.
+
+	It is also safe to copy handles - internally they are nothing more than node pointers.
+	@verbatim
+	TiXmlHandle handleCopy = handle;
+	@endverbatim
+
+	What they should not be used for is iteration:
+
+	@verbatim
+	int i=0; 
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	@endverbatim
+
+	It seems reasonable, but it is in fact two embedded while loops. The Child method is 
+	a linear walk to find the element, so this code would iterate much more than it needs 
+	to. Instead, prefer:
+
+	@verbatim
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child->NextSiblingElement() )
+	{
+		// do something
+	}
+	@endverbatim
+*/
+class TiXmlHandle
+{
+public:
+	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
+	/// Copy constructor
+	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
+	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
+
+	/// Return a handle to the first child node.
+	TiXmlHandle FirstChild() const;
+	/// Return a handle to the first child node with the given name.
+	TiXmlHandle FirstChild( const char * value ) const;
+	/// Return a handle to the first child element.
+	TiXmlHandle FirstChildElement() const;
+	/// Return a handle to the first child element with the given name.
+	TiXmlHandle FirstChildElement( const char * value ) const;
+
+	/** Return a handle to the "index" child with the given name. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( const char* value, int index ) const;
+	/** Return a handle to the "index" child. 
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( int index ) const;
+	/** Return a handle to the "index" child element with the given name. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( const char* value, int index ) const;
+	/** Return a handle to the "index" child element. 
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( int index ) const;
+
+	#ifdef TIXML_USE_STL
+	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
+	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
+
+	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
+	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
+	#endif
+
+	/** Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* ToNode() const			{ return node; } 
+	/** Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
+	/**	Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
+	/** Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
+
+	/** @deprecated use ToNode. 
+		Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* Node() const			{ return ToNode(); } 
+	/** @deprecated use ToElement. 
+		Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* Element() const	{ return ToElement(); }
+	/**	@deprecated use ToText()
+		Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* Text() const			{ return ToText(); }
+	/** @deprecated use ToUnknown()
+		Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }
+
+private:
+	TiXmlNode* node;
+};
+
+
+/** Print to memory functionality. The TiXmlPrinter is useful when you need to:
+
+	-# Print to memory (especially in non-STL mode)
+	-# Control formatting (line endings, etc.)
+
+	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
+	Before calling Accept() you can call methods to control the printing
+	of the XML document. After TiXmlNode::Accept() is called, the printed document can
+	be accessed via the CStr(), Str(), and Size() methods.
+
+	TiXmlPrinter uses the Visitor API.
+	@verbatim
+	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	@endverbatim
+*/
+class TiXmlPrinter : public TiXmlVisitor
+{
+public:
+	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
+					 buffer(), indent( "    " ), lineBreak( "\n" ) {}
+
+	virtual bool VisitEnter( const TiXmlDocument& doc );
+	virtual bool VisitExit( const TiXmlDocument& doc );
+
+	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
+	virtual bool VisitExit( const TiXmlElement& element );
+
+	virtual bool Visit( const TiXmlDeclaration& declaration );
+	virtual bool Visit( const TiXmlText& text );
+	virtual bool Visit( const TiXmlComment& comment );
+	virtual bool Visit( const TiXmlUnknown& unknown );
+
+	/** Set the indent characters for printing. By default 4 spaces
+		but tab (\t) is also useful, or null/empty string for no indentation.
+	*/
+	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
+	/// Query the indention string.
+	const char* Indent()							{ return indent.c_str(); }
+	/** Set the line breaking string. By default set to newline (\n). 
+		Some operating systems prefer other characters, or can be
+		set to the null/empty string for no indenation.
+	*/
+	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
+	/// Query the current line breaking string.
+	const char* LineBreak()							{ return lineBreak.c_str(); }
+
+	/** Switch over to "stream printing" which is the most dense formatting without 
+		linebreaks. Common when the XML is needed for network transmission.
+	*/
+	void SetStreamPrinting()						{ indent = "";
+													  lineBreak = "";
+													}	
+	/// Return the result.
+	const char* CStr()								{ return buffer.c_str(); }
+	/// Return the length of the result string.
+	size_t Size()									{ return buffer.size(); }
+
+	#ifdef TIXML_USE_STL
+	/// Return the result.
+	const std::string& Str()						{ return buffer; }
+	#endif
+
+private:
+	void DoIndent()	{
+		for( int i=0; i<depth; ++i )
+			buffer += indent;
+	}
+	void DoLineBreak() {
+		buffer += lineBreak;
+	}
+
+	int depth;
+	bool simpleTextPrint;
+	TIXML_STRING buffer;
+	TIXML_STRING indent;
+	TIXML_STRING lineBreak;
+};
+
+
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+
+#endif
+

Added: dependencies/tinyxml/tinyxml.sln
===================================================================
--- dependencies/tinyxml/tinyxml.sln	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxml.sln	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,44 @@
+???
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual C++ Express 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyXmlTest", "tinyXmlTest.vcproj", "{34719950-09E8-457E-BE23-8F1CE3A1F1F6}"
+	ProjectSection(ProjectDependencies) = postProject
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1} = {C406DAEC-0886-4771-8DEA-9D7329B46CC1}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyXmlTestSTL", "tinyXmlTestSTL.vcproj", "{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{A3A84737-5017-4577-B8A2-79429A25B8B6} = {A3A84737-5017-4577-B8A2-79429A25B8B6}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyxml", "tinyxml_lib.vcproj", "{C406DAEC-0886-4771-8DEA-9D7329B46CC1}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tinyxmlSTL", "tinyxmlSTL.vcproj", "{A3A84737-5017-4577-B8A2-79429A25B8B6}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Debug|Win32.ActiveCfg = Debug|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Debug|Win32.Build.0 = Debug|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Release|Win32.ActiveCfg = Release|Win32
+		{34719950-09E8-457E-BE23-8F1CE3A1F1F6}.Release|Win32.Build.0 = Release|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Debug|Win32.Build.0 = Debug|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Release|Win32.ActiveCfg = Release|Win32
+		{53ED5965-5BCA-47B5-9EB0-EDD20882F22F}.Release|Win32.Build.0 = Release|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Debug|Win32.ActiveCfg = Debug|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Debug|Win32.Build.0 = Debug|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Release|Win32.ActiveCfg = Release|Win32
+		{C406DAEC-0886-4771-8DEA-9D7329B46CC1}.Release|Win32.Build.0 = Release|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Debug|Win32.Build.0 = Debug|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Release|Win32.ActiveCfg = Release|Win32
+		{A3A84737-5017-4577-B8A2-79429A25B8B6}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal

Added: dependencies/tinyxml/tinyxmlSTL.dsp
===================================================================
--- dependencies/tinyxml/tinyxmlSTL.dsp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxmlSTL.dsp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,126 @@
+# Microsoft Developer Studio Project File - Name="tinyxmlSTL" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=tinyxmlSTL - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxmlSTL.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxmlSTL.mak" CFG="tinyxmlSTL - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyxmlSTL - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "tinyxmlSTL - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyxmlSTL - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "tinyxmlSTL___Win32_Release"
+# PROP BASE Intermediate_Dir "tinyxmlSTL___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release_STL"
+# PROP Intermediate_Dir "Release_STL"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "TIXML_USE_STL" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Release_STL\tinyxml_STL.lib"
+
+!ELSEIF  "$(CFG)" == "tinyxmlSTL - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "tinyxmlSTL___Win32_Debug0"
+# PROP BASE Intermediate_Dir "tinyxmlSTL___Win32_Debug0"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug_STL"
+# PROP Intermediate_Dir "Debug_STL"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "TIXML_USE_STL" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug_STL\tinyxmld_STL.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyxmlSTL - Win32 Release"
+# Name "tinyxmlSTL - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\changes.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\readme.txt
+# End Source File
+# End Target
+# End Project

Added: dependencies/tinyxml/tinyxmlSTL.vcproj
===================================================================
--- dependencies/tinyxml/tinyxmlSTL.vcproj	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxmlSTL.vcproj	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,278 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="tinyxmlSTL"
+	ProjectGUID="{A3A84737-5017-4577-B8A2-79429A25B8B6}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug_STL"
+			IntermediateDirectory=".\Debug_STL"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;TIXML_USE_STL;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug_STL/tinyxmlSTL.pch"
+				AssemblerListingLocation=".\Debug_STL/"
+				ObjectFile=".\Debug_STL/"
+				ProgramDataBaseFileName=".\Debug_STL/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug_STL\tinyxmld_STL.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug_STL/tinyxmlSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release_STL"
+			IntermediateDirectory=".\Release_STL"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;TIXML_USE_STL"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release_STL/tinyxmlSTL.pch"
+				AssemblerListingLocation=".\Release_STL/"
+				ObjectFile=".\Release_STL/"
+				ProgramDataBaseFileName=".\Release_STL/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Release_STL\tinyxml_STL.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release_STL/tinyxmlSTL.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			>
+			<File
+				RelativePath="tinystr.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxml.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlerror.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlparser.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			>
+			<File
+				RelativePath="tinystr.h"
+				>
+			</File>
+			<File
+				RelativePath="tinyxml.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath="changes.txt"
+			>
+		</File>
+		<File
+			RelativePath="readme.txt"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Added: dependencies/tinyxml/tinyxml_lib.dsp
===================================================================
--- dependencies/tinyxml/tinyxml_lib.dsp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxml_lib.dsp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,130 @@
+# Microsoft Developer Studio Project File - Name="tinyxml" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=tinyxml - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxml_lib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "tinyxml_lib.mak" CFG="tinyxml - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "tinyxml - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "tinyxml - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "tinyxml - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "NDEBUG"
+# ADD RSC /l 0x407 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Release\tinyxml.lib"
+
+!ELSEIF  "$(CFG)" == "tinyxml - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /FR /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x407 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug\tinyxmld.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "tinyxml - Win32 Release"
+# Name "tinyxml - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\tinystr.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlerror.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxmlparser.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\tinystr.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\tinyxml.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\changes.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\readme.txt
+# End Source File
+# Begin Source File
+
+SOURCE=.\tutorial_gettingStarted.txt
+# End Source File
+# End Target
+# End Project

Added: dependencies/tinyxml/tinyxml_lib.vcproj
===================================================================
--- dependencies/tinyxml/tinyxml_lib.vcproj	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxml_lib.vcproj	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,283 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="tinyxml"
+	ProjectGUID="{C406DAEC-0886-4771-8DEA-9D7329B46CC1}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/tinyxml_lib.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1031"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Release\tinyxml.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/tinyxml_lib.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/tinyxml_lib.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				BrowseInformation="1"
+				WarningLevel="4"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1031"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug\tinyxmld.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/tinyxml_lib.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="tinystr.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxml.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlerror.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="tinyxmlparser.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="tinystr.h"
+				>
+			</File>
+			<File
+				RelativePath="tinyxml.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath="changes.txt"
+			>
+		</File>
+		<File
+			RelativePath="readme.txt"
+			>
+		</File>
+		<File
+			RelativePath="tutorial_gettingStarted.txt"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Added: dependencies/tinyxml/tinyxmlerror.cpp
===================================================================
--- dependencies/tinyxml/tinyxmlerror.cpp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxmlerror.cpp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,53 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+// The goal of the seperate error file is to make the first
+// step towards localization. tinyxml (currently) only supports
+// english error messages, but the could now be translated.
+//
+// It also cleans up the code a bit.
+//
+
+const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
+{
+	"No error",
+	"Error",
+	"Failed to open file",
+	"Memory allocation failed.",
+	"Error parsing Element.",
+	"Failed to read Element name",
+	"Error reading Element value.",
+	"Error reading Attributes.",
+	"Error: empty tag.",
+	"Error reading end tag.",
+	"Error parsing Unknown.",
+	"Error parsing Comment.",
+	"Error parsing Declaration.",
+	"Error document empty.",
+	"Error null (0) or unexpected EOF found in input stream.",
+	"Error parsing CDATA.",
+	"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.",
+};

Added: dependencies/tinyxml/tinyxmlparser.cpp
===================================================================
--- dependencies/tinyxml/tinyxmlparser.cpp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/tinyxmlparser.cpp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,1638 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must 
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+distribution.
+*/
+
+#include <ctype.h>
+#include <stddef.h>
+
+#include "tinyxml.h"
+
+//#define DEBUG_PARSER
+#if defined( DEBUG_PARSER )
+#	if defined( DEBUG ) && defined( _MSC_VER )
+#		include <windows.h>
+#		define TIXML_LOG OutputDebugString
+#	else
+#		define TIXML_LOG printf
+#	endif
+#endif
+
+// Note tha "PutString" hardcodes the same list. This
+// is less flexible than it appears. Changing the entries
+// or order will break putstring.	
+TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = 
+{
+	{ "&amp;",  5, '&' },
+	{ "&lt;",   4, '<' },
+	{ "&gt;",   4, '>' },
+	{ "&quot;", 6, '\"' },
+	{ "&apos;", 6, '\'' }
+};
+
+// Bunch of unicode info at:
+//		http://www.unicode.org/faq/utf_bom.html
+// Including the basic of this table, which determines the #bytes in the
+// sequence from the lead byte. 1 placed for invalid sequences --
+// although the result will be junk, pass it through as much as possible.
+// Beware of the non-characters in UTF-8:	
+//				ef bb bf (Microsoft "lead bytes")
+//				ef bf be
+//				ef bf bf 
+
+const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+const int TiXmlBase::utf8ByteTable[256] = 
+{
+	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0 
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0 
+		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
+		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
+		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
+		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+
+
+void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+	const unsigned long BYTE_MASK = 0xBF;
+	const unsigned long BYTE_MARK = 0x80;
+	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+	if (input < 0x80) 
+		*length = 1;
+	else if ( input < 0x800 )
+		*length = 2;
+	else if ( input < 0x10000 )
+		*length = 3;
+	else if ( input < 0x200000 )
+		*length = 4;
+	else
+		{ *length = 0; return; }	// This code won't covert this correctly anyway.
+
+	output += *length;
+
+	// Scary scary fall throughs.
+	switch (*length) 
+	{
+		case 4:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 3:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 2:
+			--output; 
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
+			input >>= 6;
+		case 1:
+			--output; 
+			*output = (char)(input | FIRST_BYTE_MARK[*length]);
+	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalpha( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalpha( anyByte );
+//	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very 
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalnum( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalnum( anyByte );
+//	}
+}
+
+
+class TiXmlParsingData
+{
+	friend class TiXmlDocument;
+  public:
+	void Stamp( const char* now, TiXmlEncoding encoding );
+
+	const TiXmlCursor& Cursor()	{ return cursor; }
+
+  private:
+	// Only used by the document!
+	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
+	{
+		assert( start );
+		stamp = start;
+		tabsize = _tabsize;
+		cursor.row = row;
+		cursor.col = col;
+	}
+
+	TiXmlCursor		cursor;
+	const char*		stamp;
+	int				tabsize;
+};
+
+
+void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
+{
+	assert( now );
+
+	// Do nothing if the tabsize is 0.
+	if ( tabsize < 1 )
+	{
+		return;
+	}
+
+	// Get the current row, column.
+	int row = cursor.row;
+	int col = cursor.col;
+	const char* p = stamp;
+	assert( p );
+
+	while ( p < now )
+	{
+		// Treat p as unsigned, so we have a happy compiler.
+		const unsigned char* pU = (const unsigned char*)p;
+
+		// Code contributed by Fletcher Dunn: (modified by lee)
+		switch (*pU) {
+			case 0:
+				// We *should* never get here, but in case we do, don't
+				// advance past the terminating null character, ever
+				return;
+
+			case '\r':
+				// bump down to the next line
+				++row;
+				col = 0;				
+				// Eat the character
+				++p;
+
+				// Check for \r\n sequence, and treat this as a single character
+				if (*p == '\n') {
+					++p;
+				}
+				break;
+
+			case '\n':
+				// bump down to the next line
+				++row;
+				col = 0;
+
+				// Eat the character
+				++p;
+
+				// Check for \n\r sequence, and treat this as a single
+				// character.  (Yes, this bizarre thing does occur still
+				// on some arcane platforms...)
+				if (*p == '\r') {
+					++p;
+				}
+				break;
+
+			case '\t':
+				// Eat the character
+				++p;
+
+				// Skip to next tab stop
+				col = (col / tabsize + 1) * tabsize;
+				break;
+
+			case TIXML_UTF_LEAD_0:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					if ( *(p+1) && *(p+2) )
+					{
+						// In these cases, don't advance the column. These are
+						// 0-width spaces.
+						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )
+							p += 3;	
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )
+							p += 3;	
+						else
+							{ p +=3; ++col; }	// A normal character.
+					}
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+
+			default:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					// Eat the 1 to 4 byte utf8 character.
+					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];
+					if ( step == 0 )
+						step = 1;		// Error case from bad encoding, but handle gracefully.
+					p += step;
+
+					// Just advance one column, of course.
+					++col;
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+		}
+	}
+	cursor.row = row;
+	cursor.col = col;
+	assert( cursor.row >= -1 );
+	assert( cursor.col >= -1 );
+	stamp = p;
+	assert( stamp );
+}
+
+
+const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
+{
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+	if ( encoding == TIXML_ENCODING_UTF8 )
+	{
+		while ( *p )
+		{
+			const unsigned char* pU = (const unsigned char*)p;
+			
+			// Skip the stupid Microsoft UTF-8 Byte order marks
+			if (	*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==TIXML_UTF_LEAD_1 
+				 && *(pU+2)==TIXML_UTF_LEAD_2 )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbeU )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbfU )
+			{
+				p += 3;
+				continue;
+			}
+
+			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.
+				++p;
+			else
+				break;
+		}
+	}
+	else
+	{
+		while ( *p && IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )
+			++p;
+	}
+
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )
+{
+	for( ;; )
+	{
+		if ( !in->good() ) return false;
+
+		int c = in->peek();
+		// At this scope, we can't get to a document. So fail silently.
+		if ( !IsWhiteSpace( c ) || c <= 0 )
+			return true;
+
+		*tag += (char) in->get();
+	}
+}
+
+/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )
+{
+	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == character )
+			return true;
+		if ( c <= 0 )		// Silent failure: can't get document at this scope
+			return false;
+
+		in->get();
+		*tag += (char) c;
+	}
+	return false;
+}
+#endif
+
+// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The
+// "assign" optimization removes over 10% of the execution time.
+//
+const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
+{
+	// Oddly, not supported on some comilers,
+	//name->clear();
+	// So use this:
+	*name = "";
+	assert( p );
+
+	// Names start with letters or underscores.
+	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
+	// algorithm is generous.
+	//
+	// After that, they can be letters, underscores, numbers,
+	// hyphens, or colons. (Colons are valid ony for namespaces,
+	// but tinyxml can't tell namespaces from names.)
+	if (    p && *p 
+		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
+	{
+		const char* start = p;
+		while(		p && *p
+				&&	(		IsAlphaNum( (unsigned char ) *p, encoding ) 
+						 || *p == '_'
+						 || *p == '-'
+						 || *p == '.'
+						 || *p == ':' ) )
+		{
+			//(*name) += *p; // expensive
+			++p;
+		}
+		if ( p-start > 0 ) {
+			name->assign( start, p-start );
+		}
+		return p;
+	}
+	return 0;
+}
+
+const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
+{
+	// Presume an entity, and pull it out.
+    TIXML_STRING ent;
+	int i;
+	*length = 0;
+
+	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
+	{
+		unsigned long ucs = 0;
+		ptrdiff_t delta = 0;
+		unsigned mult = 1;
+
+		if ( *(p+2) == 'x' )
+		{
+			// Hexadecimal.
+			if ( !*(p+3) ) return 0;
+
+			const char* q = p+3;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != 'x' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else if ( *q >= 'a' && *q <= 'f' )
+					ucs += mult * (*q - 'a' + 10);
+				else if ( *q >= 'A' && *q <= 'F' )
+					ucs += mult * (*q - 'A' + 10 );
+				else 
+					return 0;
+				mult *= 16;
+				--q;
+			}
+		}
+		else
+		{
+			// Decimal.
+			if ( !*(p+2) ) return 0;
+
+			const char* q = p+2;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != '#' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else 
+					return 0;
+				mult *= 10;
+				--q;
+			}
+		}
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			// convert the UCS to UTF-8
+			ConvertUTF32ToUTF8( ucs, value, length );
+		}
+		else
+		{
+			*value = (char)ucs;
+			*length = 1;
+		}
+		return p + delta + 1;
+	}
+
+	// Now try to match it.
+	for( i=0; i<NUM_ENTITY; ++i )
+	{
+		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
+		{
+			assert( strlen( entity[i].str ) == entity[i].strLength );
+			*value = entity[i].chr;
+			*length = 1;
+			return ( p + entity[i].strLength );
+		}
+	}
+
+	// So it wasn't an entity, its unrecognized, or something like that.
+	*value = *p;	// Don't put back the last one, since we return it!
+	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
+					// Just writes strange XML.
+	return p+1;
+}
+
+
+bool TiXmlBase::StringEqual( const char* p,
+							 const char* tag,
+							 bool ignoreCase,
+							 TiXmlEncoding encoding )
+{
+	assert( p );
+	assert( tag );
+	if ( !p || !*p )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	const char* q = p;
+
+	if ( ignoreCase )
+	{
+		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )
+			return true;
+	}
+	else
+	{
+		while ( *q && *tag && *q == *tag )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
+			return true;
+	}
+	return false;
+}
+
+const char* TiXmlBase::ReadText(	const char* p, 
+									TIXML_STRING * text, 
+									bool trimWhiteSpace, 
+									const char* endTag, 
+									bool caseInsensitive,
+									TiXmlEncoding encoding )
+{
+    *text = "";
+	if (    !trimWhiteSpace			// certain tags always keep whitespace
+		 || !condenseWhiteSpace )	// if true, whitespace is always kept
+	{
+		// Keep all the white space.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding )
+			  )
+		{
+			int len;
+			char cArr[4] = { 0, 0, 0, 0 };
+			p = GetChar( p, cArr, &len, encoding );
+			text->append( cArr, len );
+		}
+	}
+	else
+	{
+		bool whitespace = false;
+
+		// Remove leading white space:
+		p = SkipWhiteSpace( p, encoding );
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
+		{
+			if ( *p == '\r' || *p == '\n' )
+			{
+				whitespace = true;
+				++p;
+			}
+			else if ( IsWhiteSpace( *p ) )
+			{
+				whitespace = true;
+				++p;
+			}
+			else
+			{
+				// If we've found whitespace, add it before the
+				// new character. Any whitespace just becomes a space.
+				if ( whitespace )
+				{
+					(*text) += ' ';
+					whitespace = false;
+				}
+				int len;
+				char cArr[4] = { 0, 0, 0, 0 };
+				p = GetChar( p, cArr, &len, encoding );
+				if ( len == 1 )
+					(*text) += cArr[0];	// more efficient
+				else
+					text->append( cArr, len );
+			}
+		}
+	}
+	if ( p ) 
+		p += strlen( endTag );
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	// The basic issue with a document is that we don't know what we're
+	// streaming. Read something presumed to be a tag (and hope), then
+	// identify it, and call the appropriate stream method on the tag.
+	//
+	// This "pre-streaming" will never read the closing ">" so the
+	// sub-tag can orient itself.
+
+	if ( !StreamTo( in, '<', tag ) ) 
+	{
+		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return;
+	}
+
+	while ( in->good() )
+	{
+		int tagIndex = (int) tag->length();
+		while ( in->good() && in->peek() != '>' )
+		{
+			int c = in->get();
+			if ( c <= 0 )
+			{
+				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+				break;
+			}
+			(*tag) += (char) c;
+		}
+
+		if ( in->good() )
+		{
+			// We now have something we presume to be a node of 
+			// some sort. Identify it, and call the node to
+			// continue streaming.
+			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
+
+			if ( node )
+			{
+				node->StreamIn( in, tag );
+				bool isElement = node->ToElement() != 0;
+				delete node;
+				node = 0;
+
+				// If this is the root element, we're done. Parsing will be
+				// done by the >> operator.
+				if ( isElement )
+				{
+					return;
+				}
+			}
+			else
+			{
+				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+				return;
+			}
+		}
+	}
+	// We should have returned sooner.
+	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+}
+
+#endif
+
+const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
+{
+	ClearError();
+
+	// Parse away, at the document level. Since a document
+	// contains nothing but other tags, most of what happens
+	// here is skipping white space.
+	if ( !p || !*p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	// Note that, for a document, this needs to come
+	// before the while space skip, so that parsing
+	// starts from the pointer we are given.
+	location.Clear();
+	if ( prevData )
+	{
+		location.row = prevData->cursor.row;
+		location.col = prevData->cursor.col;
+	}
+	else
+	{
+		location.row = 0;
+		location.col = 0;
+	}
+	TiXmlParsingData data( p, TabSize(), location.row, location.col );
+	location = data.Cursor();
+
+	if ( encoding == TIXML_ENCODING_UNKNOWN )
+	{
+		// Check for the Microsoft UTF-8 lead bytes.
+		const unsigned char* pU = (const unsigned char*)p;
+		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
+			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
+			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )
+		{
+			encoding = TIXML_ENCODING_UTF8;
+			useMicrosoftBOM = true;
+		}
+	}
+
+    p = SkipWhiteSpace( p, encoding );
+	if ( !p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	while ( p && *p )
+	{
+		TiXmlNode* node = Identify( p, encoding );
+		if ( node )
+		{
+			p = node->Parse( p, &data, encoding );
+			LinkEndChild( node );
+		}
+		else
+		{
+			break;
+		}
+
+		// Did we get encoding info?
+		if (    encoding == TIXML_ENCODING_UNKNOWN
+			 && node->ToDeclaration() )
+		{
+			TiXmlDeclaration* dec = node->ToDeclaration();
+			const char* enc = dec->Encoding();
+			assert( enc );
+
+			if ( *enc == 0 )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
+			else 
+				encoding = TIXML_ENCODING_LEGACY;
+		}
+
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	// Was this empty?
+	if ( !firstChild ) {
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );
+		return 0;
+	}
+
+	// All is well.
+	return p;
+}
+
+void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
+{	
+	// The first error in a chain is more accurate - don't set again!
+	if ( error )
+		return;
+
+	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
+	error   = true;
+	errorId = err;
+	errorDesc = errorString[ errorId ];
+
+	errorLocation.Clear();
+	if ( pError && data )
+	{
+		data->Stamp( pError, encoding );
+		errorLocation = data->Cursor();
+	}
+}
+
+
+TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
+{
+	TiXmlNode* returnNode = 0;
+
+	p = SkipWhiteSpace( p, encoding );
+	if( !p || !*p || *p != '<' )
+	{
+		return 0;
+	}
+
+	TiXmlDocument* doc = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+
+	// What is this thing? 
+	// - Elements start with a letter or underscore, but xml is reserved.
+	// - Comments: <!--
+	// - Decleration: <?xml
+	// - Everthing else is unknown to tinyxml.
+	//
+
+	const char* xmlHeader = { "<?xml" };
+	const char* commentHeader = { "<!--" };
+	const char* dtdHeader = { "<!" };
+	const char* cdataHeader = { "<![CDATA[" };
+
+	if ( StringEqual( p, xmlHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Declaration\n" );
+		#endif
+		returnNode = new TiXmlDeclaration();
+	}
+	else if ( StringEqual( p, commentHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Comment\n" );
+		#endif
+		returnNode = new TiXmlComment();
+	}
+	else if ( StringEqual( p, cdataHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing CDATA\n" );
+		#endif
+		TiXmlText* text = new TiXmlText( "" );
+		text->SetCDATA( true );
+		returnNode = text;
+	}
+	else if ( StringEqual( p, dtdHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(1)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+	else if (    IsAlpha( *(p+1), encoding )
+			  || *(p+1) == '_' )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Element\n" );
+		#endif
+		returnNode = new TiXmlElement( "" );
+	}
+	else
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(2)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+
+	if ( returnNode )
+	{
+		// Set the parent, so it can report errors
+		returnNode->parent = this;
+	}
+	else
+	{
+		if ( doc )
+			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+	return returnNode;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)
+{
+	// We're called with some amount of pre-parsing. That is, some of "this"
+	// element is in "tag". Go ahead and stream to the closing ">"
+	while( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c ;
+		
+		if ( c == '>' )
+			break;
+	}
+
+	if ( tag->length() < 3 ) return;
+
+	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
+	// If not, identify and stream.
+
+	if (    tag->at( tag->length() - 1 ) == '>' 
+		 && tag->at( tag->length() - 2 ) == '/' )
+	{
+		// All good!
+		return;
+	}
+	else if ( tag->at( tag->length() - 1 ) == '>' )
+	{
+		// There is more. Could be:
+		//		text
+		//		cdata text (which looks like another node)
+		//		closing tag
+		//		another node.
+		for ( ;; )
+		{
+			StreamWhiteSpace( in, tag );
+
+			// Do we have text?
+			if ( in->good() && in->peek() != '<' ) 
+			{
+				// Yep, text.
+				TiXmlText text( "" );
+				text.StreamIn( in, tag );
+
+				// What follows text is a closing tag or another node.
+				// Go around again and figure it out.
+				continue;
+			}
+
+			// We now have either a closing tag...or another node.
+			// We should be at a "<", regardless.
+			if ( !in->good() ) return;
+			assert( in->peek() == '<' );
+			int tagIndex = (int) tag->length();
+
+			bool closingTag = false;
+			bool firstCharFound = false;
+
+			for( ;; )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->peek();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				
+				if ( c == '>' )
+					break;
+
+				*tag += (char) c;
+				in->get();
+
+				// Early out if we find the CDATA id.
+				if ( c == '[' && tag->size() >= 9 )
+				{
+					size_t len = tag->size();
+					const char* start = tag->c_str() + len - 9;
+					if ( strcmp( start, "<![CDATA[" ) == 0 ) {
+						assert( !closingTag );
+						break;
+					}
+				}
+
+				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
+				{
+					firstCharFound = true;
+					if ( c == '/' )
+						closingTag = true;
+				}
+			}
+			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
+			// If it was not, the streaming will be done by the tag.
+			if ( closingTag )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->get();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				assert( c == '>' );
+				*tag += (char) c;
+
+				// We are done, once we've found our closing tag.
+				return;
+			}
+			else
+			{
+				// If not a closing tag, id it, and stream.
+				const char* tagloc = tag->c_str() + tagIndex;
+				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
+				if ( !node )
+					return;
+				node->StreamIn( in, tag );
+				delete node;
+				node = 0;
+
+				// No return: go around from the beginning: text, closing tag, or node.
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	TiXmlDocument* document = GetDocument();
+
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
+		return 0;
+	}
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	if ( *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p+1, encoding );
+
+	// Read the name.
+	const char* pErr = p;
+
+    p = ReadName( p, &value, encoding );
+	if ( !p || !*p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
+		return 0;
+	}
+
+    TIXML_STRING endTag ("</");
+	endTag += value;
+	endTag += ">";
+
+	// Check for and read attributes. Also look for an empty
+	// tag or an end tag.
+	while ( p && *p )
+	{
+		pErr = p;
+		p = SkipWhiteSpace( p, encoding );
+		if ( !p || !*p )
+		{
+			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+			return 0;
+		}
+		if ( *p == '/' )
+		{
+			++p;
+			// Empty tag.
+			if ( *p  != '>' )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );		
+				return 0;
+			}
+			return (p+1);
+		}
+		else if ( *p == '>' )
+		{
+			// Done with attributes (if there were any.)
+			// Read the value -- which can include other
+			// elements -- read the end tag, and return.
+			++p;
+			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
+			if ( !p || !*p ) {
+				// We were looking for the end tag, but found nothing.
+				// Fix for [ 1663758 ] Failure to report error on bad XML
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+
+			// We should find the end tag now
+			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
+			{
+				p += endTag.length();
+				return p;
+			}
+			else
+			{
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+		}
+		else
+		{
+			// Try to read an attribute:
+			TiXmlAttribute* attrib = new TiXmlAttribute();
+			if ( !attrib )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );
+				return 0;
+			}
+
+			attrib->SetDocument( document );
+			pErr = p;
+			p = attrib->Parse( p, data, encoding );
+
+			if ( !p || !*p )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			// Handle the strange case of double attributes:
+			#ifdef TIXML_USE_STL
+			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
+			#else
+			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
+			#endif
+			if ( node )
+			{
+				node->SetValue( attrib->Value() );
+				delete attrib;
+				return 0;
+			}
+
+			attributeSet.Add( attrib );
+		}
+	}
+	return p;
+}
+
+
+const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+
+	// Read in text and elements in any order.
+	const char* pWithWhiteSpace = p;
+	p = SkipWhiteSpace( p, encoding );
+
+	while ( p && *p )
+	{
+		if ( *p != '<' )
+		{
+			// Take what we have, make a text element.
+			TiXmlText* textNode = new TiXmlText( "" );
+
+			if ( !textNode )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );
+				    return 0;
+			}
+
+			if ( TiXmlBase::IsWhiteSpaceCondensed() )
+			{
+				p = textNode->Parse( p, data, encoding );
+			}
+			else
+			{
+				// Special case: we want to keep the white space
+				// so that leading spaces aren't removed.
+				p = textNode->Parse( pWithWhiteSpace, data, encoding );
+			}
+
+			if ( !textNode->Blank() )
+				LinkEndChild( textNode );
+			else
+				delete textNode;
+		} 
+		else 
+		{
+			// We hit a '<'
+			// Have we hit a new element or an end tag? This could also be
+			// a TiXmlText in the "CDATA" style.
+			if ( StringEqual( p, "</", false, encoding ) )
+			{
+				return p;
+			}
+			else
+			{
+				TiXmlNode* node = Identify( p, encoding );
+				if ( node )
+				{
+					p = node->Parse( p, data, encoding );
+					LinkEndChild( node );
+				}				
+				else
+				{
+					return 0;
+				}
+			}
+		}
+		pWithWhiteSpace = p;
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	if ( !p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
+	}	
+	return p;
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	if ( !p || !*p || *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
+		return 0;
+	}
+	++p;
+    value = "";
+
+	while ( p && *p && *p != '>' )
+	{
+		value += *p;
+		++p;
+	}
+
+	if ( !p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
+	}
+	if ( *p == '>' )
+		return p+1;
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();	
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+
+		if ( c == '>' 
+			 && tag->at( tag->length() - 2 ) == '-'
+			 && tag->at( tag->length() - 3 ) == '-' )
+		{
+			// All is well.
+			return;		
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	value = "";
+
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	const char* startTag = "<!--";
+	const char* endTag   = "-->";
+
+	if ( !StringEqual( p, startTag, false, encoding ) )
+	{
+		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
+		return 0;
+	}
+	p += strlen( startTag );
+
+	// [ 1475201 ] TinyXML parses entities in comments
+	// Oops - ReadText doesn't work, because we don't want to parse the entities.
+	// p = ReadText( p, &value, false, endTag, false, encoding );
+	//
+	// from the XML spec:
+	/*
+	 [Definition: Comments may appear anywhere in a document outside other markup; in addition, 
+	              they may appear within the document type declaration at places allowed by the grammar. 
+				  They are not part of the document's character data; an XML processor MAY, but need not, 
+				  make it possible for an application to retrieve the text of comments. For compatibility, 
+				  the string "--" (double-hyphen) MUST NOT occur within comments.] Parameter entity 
+				  references MUST NOT be recognized within comments.
+
+				  An example of a comment:
+
+				  <!-- declarations for <head> & <body> -->
+	*/
+
+    value = "";
+	// Keep all the white space.
+	while (	p && *p && !StringEqual( p, endTag, false, encoding ) )
+	{
+		value.append( p, 1 );
+		++p;
+	}
+	if ( p ) 
+		p += strlen( endTag );
+
+	return p;
+}
+
+
+const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p ) return 0;
+
+//	int tabsize = 4;
+//	if ( document )
+//		tabsize = document->TabSize();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	// Read the name, the '=' and the value.
+	const char* pErr = p;
+	p = ReadName( p, &name, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+		return 0;
+	}
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p || *p != '=' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	++p;	// skip '='
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+	
+	const char* end;
+	const char SINGLE_QUOTE = '\'';
+	const char DOUBLE_QUOTE = '\"';
+
+	if ( *p == SINGLE_QUOTE )
+	{
+		++p;
+		end = "\'";		// single quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else if ( *p == DOUBLE_QUOTE )
+	{
+		++p;
+		end = "\"";		// double quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else
+	{
+		// All attribute values should be in single or double quotes.
+		// But this is such a common error that the parser will try
+		// its best, even without them.
+		value = "";
+		while (    p && *p											// existence
+				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
+				&& *p != '/' && *p != '>' )							// tag end
+		{
+			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {
+				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
+				// We did not have an opening quote but seem to have a 
+				// closing one. Give up and throw an error.
+				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+				return 0;
+			}
+			value += *p;
+			++p;
+		}
+	}
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->peek();	
+		if ( !cdata && (c == '<' ) ) 
+		{
+			return;
+		}
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+		in->get();	// "commits" the peek made above
+
+		if ( cdata && c == '>' && tag->size() >= 3 ) {
+			size_t len = tag->size();
+			if ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {
+				// terminator of cdata.
+				return;
+			}
+		}    
+	}
+}
+#endif
+
+const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	value = "";
+	TiXmlDocument* document = GetDocument();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	const char* const startTag = "<![CDATA[";
+	const char* const endTag   = "]]>";
+
+	if ( cdata || StringEqual( p, startTag, false, encoding ) )
+	{
+		cdata = true;
+
+		if ( !StringEqual( p, startTag, false, encoding ) )
+		{
+			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );
+			return 0;
+		}
+		p += strlen( startTag );
+
+		// Keep all the white space, ignore the encoding, etc.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, false, encoding )
+			  )
+		{
+			value += *p;
+			++p;
+		}
+
+		TIXML_STRING dummy; 
+		p = ReadText( p, &dummy, false, endTag, false, encoding );
+		return p;
+	}
+	else
+	{
+		bool ignoreWhite = true;
+
+		const char* end = "<";
+		p = ReadText( p, &value, ignoreWhite, end, false, encoding );
+		if ( p )
+			return p-1;	// don't truncate the '<'
+		return 0;
+	}
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	version = "";
+	encoding = "";
+	standalone = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "version", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			version = attrib.Value();
+		}
+		else if ( StringEqual( p, "encoding", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			encoding = attrib.Value();
+		}
+		else if ( StringEqual( p, "standalone", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );		
+			standalone = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
+
+bool TiXmlText::Blank() const
+{
+	for ( unsigned i=0; i<value.length(); i++ )
+		if ( !IsWhiteSpace( value[i] ) )
+			return false;
+	return true;
+}
+

Added: dependencies/tinyxml/utf8test.gif
===================================================================
(Binary files differ)


Property changes on: dependencies/tinyxml/utf8test.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/tinyxml/utf8test.xml
===================================================================
--- dependencies/tinyxml/utf8test.xml	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/utf8test.xml	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,11 @@
+???<?xml version="1.0" encoding="UTF-8"?>
+<document>
+    <English name="name" value="value">The world has many languages</English>
+    <Russian name="????????????????(??????)" value="????????????????">?????? ?????????? ?????????? ????????????</Russian>
+    <Spanish name="el nombre" value="el valor">el mundo tiene muchos idiomas</Spanish>
+    <SimplifiedChinese name="??????" value="??????">?????????????????????</SimplifiedChinese>
+    <?????????????? ????????????????="name" ????????????????="value">&lt;??????????&gt;</??????????????>
+    <?????? ??????="name" ??????="value">?????????????????????</??????>
+    <Heavy>"M&#x0eB;t&#230;l!"</Heavy>
+    <??>Umlaut Element</??>
+</document>

Added: dependencies/tinyxml/utf8testverify.xml
===================================================================
--- dependencies/tinyxml/utf8testverify.xml	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/utf8testverify.xml	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,11 @@
+???<?xml version="1.0" encoding="UTF-8" ?>
+<document>
+    <English name="name" value="value">The world has many languages</English>
+    <Russian name="????????????????(??????)" value="????????????????">?????? ?????????? ?????????? ????????????</Russian>
+    <Spanish name="el nombre" value="el valor">el mundo tiene muchos idiomas</Spanish>
+    <SimplifiedChinese name="??????" value="??????">?????????????????????</SimplifiedChinese>
+    <?????????????? ????????????????="name" ????????????????="value">&lt;??????????&gt;</??????????????>
+    <?????? ??????="name" ??????="value">?????????????????????</??????>
+    <Heavy>&quot;M??t??l!&quot;</Heavy>
+    <??>Umlaut Element</??>
+</document>

Added: dependencies/tinyxml/xmltest.cpp
===================================================================
--- dependencies/tinyxml/xmltest.cpp	2009-11-05 23:40:44 UTC (rev 4959)
+++ dependencies/tinyxml/xmltest.cpp	2009-11-07 19:36:41 UTC (rev 4960)
@@ -0,0 +1,1294 @@
+/*
+   Test program for TinyXML.
+*/
+
+
+#ifdef TIXML_USE_STL
+	#include <iostream>
+	#include <sstream>
+	using namespace std;
+#else
+	#include <stdio.h>
+#endif
+
+#if defined( WIN32 ) && defined( TUNE )
+	#include <crtdbg.h>
+	_CrtMemState startMemState;
+	_CrtMemState endMemState;
+#endif
+
+#include "tinyxml.h"
+
+static int gPass = 0;
+static int gFail = 0;
+
+
+bool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho = false)
+{
+	bool pass = !strcmp( expected, found );
+	if ( pass )
+		printf ("[pass]");
+	else
+		printf ("[fail]");
+
+	if ( noEcho )
+		printf (" %s\n", testString);
+	else
+		printf (" %s [%s][%s]\n", testString, expected, found);
+
+	if ( pass )
+		++gPass;
+	else
+		++gFail;
+	return pass;
+}
+
+
+bool XmlTest( const char* testString, int expected, int found, bool noEcho = false )
+{
+	bool pass = ( expected == found );
+	if ( pass )
+		printf ("[pass]");
+	else
+		printf ("[fail]");
+
+	if ( noEcho )
+		printf (" %s\n", testString);
+	else
+		printf (" %s [%d][%d]\n", testString, expected, found);
+
+	if ( pass )
+		++gPass;
+	else
+		++gFail;
+	return pass;
+}
+
+
+//
+// This file demonstrates some basic functionality of TinyXml.
+// Note that the example is very contrived. It presumes you know
+// what is in the XML file. But it does test the basic operations,
+// and show how to add and remove nodes.
+//
+
+int main()
+{
+	//
+	// We start with the 'demoStart' todo list. Process it. And
+	// should hopefully end up with the todo list as illustrated.
+	//
+	const char* demoStart =
+		"<?xml version=\"1.0\"  standalone='no' >\n"
+		"<!-- Our to do list data -->"
+		"<ToDo>\n"
+		"<!-- Do I need a secure PDA? -->\n"
+		"<Item priority=\"1\" distance='close'> Go to the <bold>Toy store!</bold></Item>"
+		"<Item priority=\"2\" distance='none'> Do bills   </Item>"
+		"<Item priority=\"2\" distance='far &amp; back'> Look for Evil Dinosaurs! </Item>"
+		"</ToDo>";
+		
+	{
+
+	#ifdef TIXML_USE_STL
+		/*	What the todo list should look like after processing.
+			In stream (no formatting) representation. */
+		const char* demoEnd =
+			"<?xml version=\"1.0\" standalone=\"no\" ?>"
+			"<!-- Our to do list data -->"
+			"<ToDo>"
+			"<!-- Do I need a secure PDA? -->"
+			"<Item priority=\"2\" distance=\"close\">Go to the"
+			"<bold>Toy store!"
+			"</bold>"
+			"</Item>"
+			"<Item priority=\"1\" distance=\"far\">Talk to:"
+			"<Meeting where=\"School\">"
+			"<Attendee name=\"Marple\" position=\"teacher\" />"
+			"<Attendee name=\"Voel\" position=\"counselor\" />"
+			"</Meeting>"
+			"<Meeting where=\"Lunch\" />"
+			"</Item>"
+			"<Item priority=\"2\" distance=\"here\">Do bills"
+			"</Item>"
+			"</ToDo>";
+	#endif
+
+		// The example parses from the character string (above):
+		#if defined( WIN32 ) && defined( TUNE )
+		_CrtMemCheckpoint( &startMemState );
+		#endif	
+
+		{
+			// Write to a file and read it back, to check file I/O.
+
+			TiXmlDocument doc( "demotest.xml" );
+			doc.Parse( demoStart );
+
+			if ( doc.Error() )
+			{
+				printf( "Error in %s: %s\n", doc.Value(), doc.ErrorDesc() );
+				exit( 1 );
+			}
+			doc.SaveFile();
+		}
+
+		TiXmlDocument doc( "demotest.xml" );
+		bool loadOkay = doc.LoadFile();
+
+		if ( !loadOkay )
+		{
+			printf( "Could not load test file 'demotest.xml'. Error='%s'. Exiting.\n", doc.ErrorDesc() );
+			exit( 1 );
+		}
+
+		printf( "** Demo doc read from disk: ** \n\n" );
+		printf( "** Printing via doc.Print **\n" );
+		doc.Print( stdout );
+
+		{
+			printf( "** Printing via TiXmlPrinter **\n" );
+			TiXmlPrinter printer;
+			doc.Accept( &printer );
+			fprintf( stdout, "%s", printer.CStr() );
+		}
+		#ifdef TIXML_USE_STL	
+		{
+			printf( "** Printing via operator<< **\n" );
+			std::cout << doc;
+		}
+		#endif
+		TiXmlNode* node = 0;
+		TiXmlElement* todoElement = 0;
+		TiXmlElement* itemElement = 0;
+
+
+		// --------------------------------------------------------
+		// An example of changing existing attributes, and removing
+		// an element from the document.
+		// --------------------------------------------------------
+
+		// Get the "ToDo" element.
+		// It is a child of the document, and can be selected by name.
+		node = doc.FirstChild( "ToDo" );
+		assert( node );
+		todoElement = node->ToElement();
+		assert( todoElement  );
+
+		// Going to the toy store is now our second priority...
+		// So set the "priority" attribute of the first item in the list.
+		node = todoElement->FirstChildElement();	// This skips the "PDA" comment.
+		assert( node );
+		itemElement = node->ToElement();
+		assert( itemElement  );
+		itemElement->SetAttribute( "priority", 2 );
+
+		// Change the distance to "doing bills" from
+		// "none" to "here". It's the next sibling element.
+		itemElement = itemElement->NextSiblingElement();
+		assert( itemElement );
+		itemElement->SetAttribute( "distance", "here" );
+
+		// Remove the "Look for Evil Dinosaurs!" item.
+		// It is 1 more sibling away. We ask the parent to remove
+		// a particular child.
+		itemElement = itemElement->NextSiblingElement();
+		todoElement->RemoveChild( itemElement );
+
+		itemElement = 0;
+
+		// --------------------------------------------------------
+		// What follows is an example of created elements and text
+		// nodes and adding them to the document.
+		// --------------------------------------------------------
+
+		// Add some meetings.
+		TiXmlElement item( "Item" );
+		item.SetAttribute( "priority", "1" );
+		item.SetAttribute( "distance", "far" );
+
+		TiXmlText text( "Talk to:" );
+
+		TiXmlElement meeting1( "Meeting" );
+		meeting1.SetAttribute( "where", "School" );
+
+		TiXmlElement meeting2( "Meeting" );
+		meeting2.SetAttribute( "where", "Lunch" );
+
+		TiXmlElement attendee1( "Attendee" );
+		attendee1.SetAttribute( "name", "Marple" );
+		attendee1.SetAttribute( "position", "teacher" );
+
+		TiXmlElement attendee2( "Attendee" );
+		attendee2.SetAttribute( "name", "Voel" );
+		attendee2.SetAttribute( "position", "counselor" );
+
+		// Assemble the nodes we've created:
+		meeting1.InsertEndChild( attendee1 );
+		meeting1.InsertEndChild( attendee2 );
+
+		item.InsertEndChild( text );
+		item.InsertEndChild( meeting1 );
+		item.InsertEndChild( meeting2 );
+
+		// And add the node to the existing list after the first child.
+		node = todoElement->FirstChild( "Item" );
+		assert( node );
+		itemElement = node->ToElement();
+		assert( itemElement );
+
+		todoElement->InsertAfterChild( itemElement, item );
+
+		printf( "\n** Demo doc processed: ** \n\n" );
+		doc.Print( stdout );
+
+
+	#ifdef TIXML_USE_STL
+		printf( "** Demo doc processed to stream: ** \n\n" );
+		cout << doc << endl << endl;
+	#endif
+
+		// --------------------------------------------------------
+		// Different tests...do we have what we expect?
+		// --------------------------------------------------------
+
+		int count = 0;
+		TiXmlElement*	element;
+
+		//////////////////////////////////////////////////////
+
+	#ifdef TIXML_USE_STL
+		cout << "** Basic structure. **\n";
+		ostringstream outputStream( ostringstream::out );
+		outputStream << doc;
+		XmlTest( "Output stream correct.",	string( demoEnd ).c_str(),
+											outputStream.str().c_str(), true );
+	#endif
+
+		node = doc.RootElement();
+		assert( node );
+		XmlTest( "Root element exists.", true, ( node != 0 && node->ToElement() ) );
+		XmlTest ( "Root element value is 'ToDo'.", "ToDo",  node->Value());
+
+		node = node->FirstChild();
+		XmlTest( "First child exists & is a comment.", true, ( node != 0 && node->ToComment() ) );
+		node = node->NextSibling();
+		XmlTest( "Sibling element exists & is an element.", true, ( node != 0 && node->ToElement() ) );
+		XmlTest ( "Value is 'Item'.", "Item", node->Value() );
+
+		node = node->FirstChild();
+		XmlTest ( "First child exists.", true, ( node != 0 && node->ToText() ) );
+		XmlTest ( "Value is 'Go to the'.", "Go to the", node->Value() );
+
+
+		//////////////////////////////////////////////////////
+		printf ("\n** Iterators. **\n");
+
+		// Walk all the top level nodes of the document.
+		count = 0;
+		for( node = doc.FirstChild();
+			 node;
+			 node = node->NextSibling() )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using First / Next.", 3, count );
+
+		count = 0;
+		for( node = doc.LastChild();
+			 node;
+			 node = node->PreviousSibling() )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using Last / Previous.", 3, count );
+
+		// Walk all the top level nodes of the document,
+		// using a different syntax.
+		count = 0;
+		for( node = doc.IterateChildren( 0 );
+			 node;
+			 node = doc.IterateChildren( node ) )
+		{
+			count++;
+		}
+		XmlTest( "Top level nodes, using IterateChildren.", 3, count );
+
+		// Walk all the elements in a node.
+		count = 0;
+		for( element = todoElement->FirstChildElement();
+			 element;
+			 element = element->NextSiblingElement() )
+		{
+			count++;
+		}
+		XmlTest( "Children of the 'ToDo' element, using First / Next.",
+			3, count );
+
+		// Walk all the elements in a node by value.
+		count = 0;
+		for( node = todoElement->FirstChild( "Item" );
+			 node;
+			 node = node->NextSibling( "Item" ) )
+		{
+			count++;
+		}
+		XmlTest( "'Item' children of the 'ToDo' element, using First/Next.", 3, count );
+
+		count = 0;
+		for( node = todoElement->LastChild( "Item" );
+			 node;
+			 node = node->PreviousSibling( "Item" ) )
+		{
+			count++;
+		}
+		XmlTest( "'Item' children of the 'ToDo' element, using Last/Previous.", 3, count );
+
+	#ifdef TIXML_USE_STL
+		{
+			cout << "\n** Parsing. **\n";
+			istringstream parse0( "<Element0 attribute0='foo0' attribute1= noquotes attribute2 = '&gt;' />" );
+			TiXmlElement element0( "default" );
+			parse0 >> element0;
+
+			XmlTest ( "Element parsed, value is 'Element0'.", "Element0", element0.Value() );
+			XmlTest ( "Reads attribute 'attribute0=\"foo0\"'.", "foo0", element0.Attribute( "attribute0" ));
+			XmlTest ( "Reads incorrectly formatted 'attribute1=noquotes'.", "noquotes", element0.Attribute( "attribute1" ) );
+			XmlTest ( "Read attribute with entity value '>'.", ">", element0.Attribute( "attribute2" ) );
+		}
+	#endif
+
+		{
+			const char* error =	"<?xml version=\"1.0\" standalone=\"no\" ?>\n"
+								"<passages count=\"006\" formatversion=\"20020620\">\n"
+								"    <wrong error>\n"
+								"</passages>";
+
+			TiXmlDocument docTest;
+			docTest.Parse( error );
+			XmlTest( "Error row", docTest.ErrorRow(), 3 );
+			XmlTest( "Error column", docTest.ErrorCol(), 17 );
+			//printf( "error=%d id='%s' row %d col%d\n", (int) doc.Error(), doc.ErrorDesc(), doc.ErrorRow()+1, doc.ErrorCol() + 1 );
+
+		}
+
+	#ifdef TIXML_USE_STL
+		{
+			//////////////////////////////////////////////////////
+			cout << "\n** Streaming. **\n";
+
+			// Round trip check: stream in, then stream back out to verify. The stream
+			// out has already been checked, above. We use the output
+
+			istringstream inputStringStream( outputStream.str() );
+			TiXmlDocument document0;
+
+			inputStringStream >> document0;
+
+			ostringstream outputStream0( ostringstream::out );
+			outputStream0 << document0;
+
+			XmlTest( "Stream round trip correct.",	string( demoEnd ).c_str(), 
+													outputStream0.str().c_str(), true );
+
+			std::string str;
+			str << document0;
+
+			XmlTest( "String printing correct.", string( demoEnd ).c_str(), 
+												 str.c_str(), true );
+		}
+	#endif
+	}
+	
+	{
+		const char* str = "<doc attr0='1' attr1='2.0' attr2='foo' />";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlElement* ele = doc.FirstChildElement();
+
+		int iVal, result;
+		double dVal;
+
+		result = ele->QueryDoubleAttribute( "attr0", &dVal );
+		XmlTest( "Query attribute: int as double", result, TIXML_SUCCESS );
+		XmlTest( "Query attribute: int as double", (int)dVal, 1 );
+		result = ele->QueryDoubleAttribute( "attr1", &dVal );
+		XmlTest( "Query attribute: double as double", (int)dVal, 2 );
+		result = ele->QueryIntAttribute( "attr1", &iVal );
+		XmlTest( "Query attribute: double as int", result, TIXML_SUCCESS );
+		XmlTest( "Query attribute: double as int", iVal, 2 );
+		result = ele->QueryIntAttribute( "attr2", &iVal );
+		XmlTest( "Query attribute: not a number", result, TIXML_WRONG_TYPE );
+		result = ele->QueryIntAttribute( "bar", &iVal );
+		XmlTest( "Query attribute: does not exist", result, TIXML_NO_ATTRIBUTE );
+	}
+	
+	{
+		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
+							"</room>";
+
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Parse( str );
+
+		TiXmlHandle docHandle( &doc );
+		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );
+
+		assert( docHandle.Node() );
+		assert( roomHandle.Element() );
+
+		TiXmlElement* room = roomHandle.Element();
+		assert( room );
+		TiXmlAttribute* doors = room->FirstAttribute();
+		assert( doors );
+
+		XmlTest( "Location tracking: Tab 8: room row", room->Row(), 1 );
+		XmlTest( "Location tracking: Tab 8: room col", room->Column(), 49 );
+		XmlTest( "Location tracking: Tab 8: doors row", doors->Row(), 1 );
+		XmlTest( "Location tracking: Tab 8: doors col", doors->Column(), 55 );
+	}
+	
+	{
+		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
+							"  <!-- Silly example -->\n"
+							"    <door wall='north'>A great door!</door>\n"
+							"\t<door wall='east'/>"
+							"</room>";
+
+		TiXmlDocument doc;
+		doc.Parse( str );
+
+		TiXmlHandle docHandle( &doc );
+		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );
+		TiXmlHandle commentHandle = docHandle.FirstChildElement( "room" ).FirstChild();
+		TiXmlHandle textHandle = docHandle.FirstChildElement( "room" ).ChildElement( "door", 0 ).FirstChild();
+		TiXmlHandle door0Handle = docHandle.FirstChildElement( "room" ).ChildElement( 0 );
+		TiXmlHandle door1Handle = docHandle.FirstChildElement( "room" ).ChildElement( 1 );
+
+		assert( docHandle.Node() );
+		assert( roomHandle.Element() );
+		assert( commentHandle.Node() );
+		assert( textHandle.Text() );
+		assert( door0Handle.Element() );
+		assert( door1Handle.Element() );
+
+		TiXmlDeclaration* declaration = doc.FirstChild()->ToDeclaration();
+		assert( declaration );
+		TiXmlElement* room = roomHandle.Element();
+		assert( room );
+		TiXmlAttribute* doors = room->FirstAttribute();
+		assert( doors );
+		TiXmlText* text = textHandle.Text();
+		TiXmlComment* comment = commentHandle.Node()->ToComment();
+		assert( comment );
+		TiXmlElement* door0 = door0Handle.Element();
+		TiXmlElement* door1 = door1Handle.Element();
+
+		XmlTest( "Location tracking: Declaration row", declaration->Row(), 1 );
+		XmlTest( "Location tracking: Declaration col", declaration->Column(), 5 );
+		XmlTest( "Location tracking: room row", room->Row(), 1 );
+		XmlTest( "Location tracking: room col", room->Column(), 45 );
+		XmlTest( "Location tracking: doors row", doors->Row(), 1 );
+		XmlTest( "Location tracking: doors col", doors->Column(), 51 );
+		XmlTest( "Location tracking: Comment row", comment->Row(), 2 );
+		XmlTest( "Location tracking: Comment col", comment->Column(), 3 );
+		XmlTest( "Location tracking: text row", text->Row(), 3 ); 
+		XmlTest( "Location tracking: text col", text->Column(), 24 );
+		XmlTest( "Location tracking: door0 row", door0->Row(), 3 );
+		XmlTest( "Location tracking: door0 col", door0->Column(), 5 );
+		XmlTest( "Location tracking: door1 row", door1->Row(), 4 );
+		XmlTest( "Location tracking: door1 col", door1->Column(), 5 );
+	}
+
+
+	// --------------------------------------------------------
+	// UTF-8 testing. It is important to test:
+	//	1. Making sure name, value, and text read correctly
+	//	2. Row, Col functionality
+	//	3. Correct output
+	// --------------------------------------------------------
+	printf ("\n** UTF-8 **\n");
+	{
+		TiXmlDocument doc( "utf8test.xml" );
+		doc.LoadFile();
+		if ( doc.Error() && doc.ErrorId() == TiXmlBase::TIXML_ERROR_OPENING_FILE ) {
+			printf( "WARNING: File 'utf8test.xml' not found.\n"
+					"(Are you running the test from the wrong directory?)\n"
+				    "Could not test UTF-8 functionality.\n" );
+		}
+		else
+		{
+			TiXmlHandle docH( &doc );
+			// Get the attribute "value" from the "Russian" element and check it.
+			TiXmlElement* element = docH.FirstChildElement( "document" ).FirstChildElement( "Russian" ).Element();
+			const unsigned char correctValue[] = {	0xd1U, 0x86U, 0xd0U, 0xb5U, 0xd0U, 0xbdU, 0xd0U, 0xbdU, 
+													0xd0U, 0xbeU, 0xd1U, 0x81U, 0xd1U, 0x82U, 0xd1U, 0x8cU, 0 };
+
+			XmlTest( "UTF-8: Russian value.", (const char*)correctValue, element->Attribute( "value" ), true );
+			XmlTest( "UTF-8: Russian value row.", 4, element->Row() );
+			XmlTest( "UTF-8: Russian value column.", 5, element->Column() );
+
+			const unsigned char russianElementName[] = {	0xd0U, 0xa0U, 0xd1U, 0x83U,
+															0xd1U, 0x81U, 0xd1U, 0x81U,
+															0xd0U, 0xbaU, 0xd0U, 0xb8U,
+															0xd0U, 0xb9U, 0 };
+			const char russianText[] = "<\xD0\xB8\xD0\xBC\xD0\xB5\xD0\xB5\xD1\x82>";
+
+			TiXmlText* text = docH.FirstChildElement( "document" ).FirstChildElement( (const char*) russianElementName ).Child( 0 ).Text();
+			XmlTest( "UTF-8: Browsing russian element name.",
+					 russianText,
+					 text->Value(),
+					 true );
+			XmlTest( "UTF-8: Russian element name row.", 7, text->Row() );
+			XmlTest( "UTF-8: Russian element name column.", 47, text->Column() );
+
+			TiXmlDeclaration* dec = docH.Child( 0 ).Node()->ToDeclaration();
+			XmlTest( "UTF-8: Declaration column.", 1, dec->Column() );
+			XmlTest( "UTF-8: Document column.", 1, doc.Column() );
+
+			// Now try for a round trip.
+			doc.SaveFile( "utf8testout.xml" );
+
+			// Check the round trip.
+			char savedBuf[256];
+			char verifyBuf[256];
+			int okay = 1;
+
+			FILE* saved  = fopen( "utf8testout.xml", "r" );
+			FILE* verify = fopen( "utf8testverify.xml", "r" );
+			if ( saved && verify )
+			{
+				while ( fgets( verifyBuf, 256, verify ) )
+				{
+					fgets( savedBuf, 256, saved );
+					if ( strcmp( verifyBuf, savedBuf ) )
+					{
+						okay = 0;
+						break;
+					}
+				}
+				fclose( saved );
+				fclose( verify );
+			}
+			XmlTest( "UTF-8: Verified multi-language round trip.", 1, okay );
+
+			// On most Western machines, this is an element that contains
+			// the word "resume" with the correct accents, in a latin encoding.
+			// It will be something else completely on non-wester machines,
+			// which is why TinyXml is switching to UTF-8.
+			const char latin[] = "<element>r\x82sum\x82</element>";
+
+			TiXmlDocument latinDoc;
+			latinDoc.Parse( latin, 0, TIXML_ENCODING_LEGACY );
+
+			text = latinDoc.FirstChildElement()->FirstChild()->ToText();
+			XmlTest( "Legacy encoding: Verify text element.", "r\x82sum\x82", text->Value() );
+		}
+	}		
+
+	//////////////////////
+	// Copy and assignment
+	//////////////////////
+	printf ("\n** Copy and Assignment **\n");
+	{
+		TiXmlElement element( "foo" );
+		element.Parse( "<element name='value' />", 0, TIXML_ENCODING_UNKNOWN );
+
+		TiXmlElement elementCopy( element );
+		TiXmlElement elementAssign( "foo" );
+		elementAssign.Parse( "<incorrect foo='bar'/>", 0, TIXML_ENCODING_UNKNOWN );
+		elementAssign = element;
+
+		XmlTest( "Copy/Assign: element copy #1.", "element", elementCopy.Value() );
+		XmlTest( "Copy/Assign: element copy #2.", "value", elementCopy.Attribute( "name" ) );
+		XmlTest( "Copy/Assign: element assign #1.", "element", elementAssign.Value() );
+		XmlTest( "Copy/Assign: element assign #2.", "value", elementAssign.Attribute( "name" ) );
+		XmlTest( "Copy/Assign: element assign #3.", true, ( 0 == elementAssign.Attribute( "foo" )) );
+
+		TiXmlComment comment;
+		comment.Parse( "<!--comment-->", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlComment commentCopy( comment );
+		TiXmlComment commentAssign;
+		commentAssign = commentCopy;
+		XmlTest( "Copy/Assign: comment copy.", "comment", commentCopy.Value() );
+		XmlTest( "Copy/Assign: comment assign.", "comment", commentAssign.Value() );
+
+		TiXmlUnknown unknown;
+		unknown.Parse( "<[unknown]>", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlUnknown unknownCopy( unknown );
+		TiXmlUnknown unknownAssign;
+		unknownAssign.Parse( "incorrect", 0, TIXML_ENCODING_UNKNOWN );
+		unknownAssign = unknownCopy;
+		XmlTest( "Copy/Assign: unknown copy.", "[unknown]", unknownCopy.Value() );
+		XmlTest( "Copy/Assign: unknown assign.", "[unknown]", unknownAssign.Value() );
+		
+		TiXmlText text( "TextNode" );
+		TiXmlText textCopy( text );
+		TiXmlText textAssign( "incorrect" );
+		textAssign = text;
+		XmlTest( "Copy/Assign: text copy.", "TextNode", textCopy.Value() );
+		XmlTest( "Copy/Assign: text assign.", "TextNode", textAssign.Value() );
+
+		TiXmlDeclaration dec;
+		dec.Parse( "<?xml version='1.0' encoding='UTF-8'?>", 0, TIXML_ENCODING_UNKNOWN );
+		TiXmlDeclaration decCopy( dec );
+		TiXmlDeclaration decAssign;
+		decAssign = dec;
+
+		XmlTest( "Copy/Assign: declaration copy.", "UTF-8", decCopy.Encoding() );
+		XmlTest( "Copy/Assign: text assign.", "UTF-8", decAssign.Encoding() );
+
+		TiXmlDocument doc;
+		elementCopy.InsertEndChild( textCopy );
+		doc.InsertEndChild( decAssign );
+		doc.InsertEndChild( elementCopy );
+		doc.InsertEndChild( unknownAssign );
+
+		TiXmlDocument docCopy( doc );
+		TiXmlDocument docAssign;
+		docAssign = docCopy;
+
+		#ifdef TIXML_USE_STL
+		std::string original, copy, assign;
+		original << doc;
+		copy << docCopy;
+		assign << docAssign;
+		XmlTest( "Copy/Assign: document copy.", original.c_str(), copy.c_str(), true );
+		XmlTest( "Copy/Assign: document assign.", original.c_str(), assign.c_str(), true );
+
+		#endif
+	}	
+
+	//////////////////////////////////////////////////////
+#ifdef TIXML_USE_STL
+	printf ("\n** Parsing, no Condense Whitespace **\n");
+	TiXmlBase::SetCondenseWhiteSpace( false );
+	{
+		istringstream parse1( "<start>This  is    \ntext</start>" );
+		TiXmlElement text1( "text" );
+		parse1 >> text1;
+
+		XmlTest ( "Condense white space OFF.", "This  is    \ntext",
+					text1.FirstChild()->Value(),
+					true );
+	}
+	TiXmlBase::SetCondenseWhiteSpace( true );
+#endif
+
+	//////////////////////////////////////////////////////
+	// GetText();
+	{
+		const char* str = "<foo>This is text</foo>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		const TiXmlElement* element = doc.RootElement();
+
+		XmlTest( "GetText() normal use.", "This is text", element->GetText() );
+
+		str = "<foo><b>This is text</b></foo>";
+		doc.Clear();
+		doc.Parse( str );
+		element = doc.RootElement();
+
+		XmlTest( "GetText() contained element.", element->GetText() == 0, true );
+
+		str = "<foo>This is <b>text</b></foo>";
+		doc.Clear();
+		TiXmlBase::SetCondenseWhiteSpace( false );
+		doc.Parse( str );
+		TiXmlBase::SetCondenseWhiteSpace( true );
+		element = doc.RootElement();
+
+		XmlTest( "GetText() partial.", "This is ", element->GetText() );
+	}
+
+
+	//////////////////////////////////////////////////////
+	// CDATA
+	{
+		const char* str =	"<xmlElement>"
+								"<![CDATA["
+									"I am > the rules!\n"
+									"...since I make symbolic puns"
+								"]]>"
+							"</xmlElement>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		doc.Print();
+
+		XmlTest( "CDATA parse.", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+
+		#ifdef TIXML_USE_STL
+		//cout << doc << '\n';
+
+		doc.Clear();
+
+		istringstream parse0( str );
+		parse0 >> doc;
+		//cout << doc << '\n';
+
+		XmlTest( "CDATA stream.", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+		#endif
+
+		TiXmlDocument doc1 = doc;
+		//doc.Print();
+
+		XmlTest( "CDATA copy.", doc1.FirstChildElement()->FirstChild()->Value(), 
+								 "I am > the rules!\n...since I make symbolic puns",
+								 true );
+	}
+	{
+		// [ 1482728 ] Wrong wide char parsing
+		char buf[256];
+		buf[255] = 0;
+		for( int i=0; i<255; ++i ) {
+			buf[i] = (char)((i>=32) ? i : 32);
+		}
+		TIXML_STRING str( "<xmlElement><![CDATA[" );
+		str += buf;
+		str += "]]></xmlElement>";
+
+		TiXmlDocument doc;
+		doc.Parse( str.c_str() );
+
+		TiXmlPrinter printer;
+		printer.SetStreamPrinting();
+		doc.Accept( &printer );
+
+		XmlTest( "CDATA with all bytes #1.", str.c_str(), printer.CStr(), true );
+
+		#ifdef TIXML_USE_STL
+		doc.Clear();
+		istringstream iss( printer.Str() );
+		iss >> doc;
+		std::string out;
+		out << doc;
+		XmlTest( "CDATA with all bytes #2.", out.c_str(), printer.CStr(), true );
+		#endif
+	}
+	{
+		// [ 1480107 ] Bug-fix for STL-streaming of CDATA that contains tags
+		// CDATA streaming had a couple of bugs, that this tests for.
+		const char* str =	"<xmlElement>"
+								"<![CDATA["
+									"<b>I am > the rules!</b>\n"
+									"...since I make symbolic puns"
+								"]]>"
+							"</xmlElement>";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		doc.Print();
+
+		XmlTest( "CDATA parse. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+
+		#ifdef TIXML_USE_STL
+
+		doc.Clear();
+
+		istringstream parse0( str );
+		parse0 >> doc;
+
+		XmlTest( "CDATA stream. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+		#endif
+
+		TiXmlDocument doc1 = doc;
+		//doc.Print();
+
+		XmlTest( "CDATA copy. [ 1480107 ]", doc1.FirstChildElement()->FirstChild()->Value(), 
+								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
+								 true );
+	}
+	//////////////////////////////////////////////////////
+	// Visit()
+
+
+
+	//////////////////////////////////////////////////////
+	printf( "\n** Fuzzing... **\n" );
+
+	const int FUZZ_ITERATION = 300;
+
+	// The only goal is not to crash on bad input.
+	int len = (int) strlen( demoStart );
+	for( int i=0; i<FUZZ_ITERATION; ++i ) 
+	{
+		char* demoCopy = new char[ len+1 ];
+		strcpy( demoCopy, demoStart );
+
+		demoCopy[ i%len ] = (char)((i+1)*3);
+		demoCopy[ (i*7)%len ] = '>';
+		demoCopy[ (i*11)%len ] = '<';
+
+		TiXmlDocument xml;
+		xml.Parse( demoCopy );
+
+		delete [] demoCopy;
+	}
+	printf( "** Fuzzing Complete. **\n" );
+	
+	//////////////////////////////////////////////////////
+	printf ("\n** Bug regression tests **\n");
+
+	// InsertBeforeChild and InsertAfterChild causes crash.
+	{
+		TiXmlElement parent( "Parent" );
+		TiXmlElement childText0( "childText0" );
+		TiXmlElement childText1( "childText1" );
+		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
+		TiXmlNode* childNode1 = parent.InsertBeforeChild( childNode0, childText1 );
+
+		XmlTest( "Test InsertBeforeChild on empty node.", ( childNode1 == parent.FirstChild() ), true );
+	}
+
+	{
+		// InsertBeforeChild and InsertAfterChild causes crash.
+		TiXmlElement parent( "Parent" );
+		TiXmlElement childText0( "childText0" );
+		TiXmlElement childText1( "childText1" );
+		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
+		TiXmlNode* childNode1 = parent.InsertAfterChild( childNode0, childText1 );
+
+		XmlTest( "Test InsertAfterChild on empty node. ", ( childNode1 == parent.LastChild() ), true );
+	}
+
+	// Reports of missing constructors, irregular string problems.
+	{
+		// Missing constructor implementation. No test -- just compiles.
+		TiXmlText text( "Missing" );
+
+		#ifdef TIXML_USE_STL
+			// Missing implementation:
+			TiXmlDocument doc;
+			string name = "missing";
+			doc.LoadFile( name );
+
+			TiXmlText textSTL( name );
+		#else
+			// verifying some basic string functions:
+			TiXmlString a;
+			TiXmlString b( "Hello" );
+			TiXmlString c( "ooga" );
+
+			c = " World!";
+			a = b;
+			a += c;
+			a = a;
+
+			XmlTest( "Basic TiXmlString test. ", "Hello World!", a.c_str() );
+		#endif
+ 	}
+
+	// Long filenames crashing STL version
+	{
+		TiXmlDocument doc( "midsummerNightsDreamWithAVeryLongFilenameToConfuseTheStringHandlingRoutines.xml" );
+		bool loadOkay = doc.LoadFile();
+		loadOkay = true;	// get rid of compiler warning.
+		// Won't pass on non-dev systems. Just a "no crash" check.
+		//XmlTest( "Long filename. ", true, loadOkay );
+	}
+
+	{
+		// Entities not being written correctly.
+		// From Lynn Allen
+
+		const char* passages =
+			"<?xml version=\"1.0\" standalone=\"no\" ?>"
+			"<passages count=\"006\" formatversion=\"20020620\">"
+				"<psg context=\"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
+				" It also has &lt;, &gt;, and &amp;, as well as a fake copyright &#xA9;.\"> </psg>"
+			"</passages>";
+
+		TiXmlDocument doc( "passages.xml" );
+		doc.Parse( passages );
+		TiXmlElement* psg = doc.RootElement()->FirstChildElement();
+		const char* context = psg->Attribute( "context" );
+		const char* expected = "Line 5 has \"quotation marks\" and 'apostrophe marks'. It also has <, >, and &, as well as a fake copyright \xC2\xA9.";
+
+		XmlTest( "Entity transformation: read. ", expected, context, true );
+
+		FILE* textfile = fopen( "textfile.txt", "w" );
+		if ( textfile )
+		{
+			psg->Print( textfile, 0 );
+			fclose( textfile );
+		}
+		textfile = fopen( "textfile.txt", "r" );
+		assert( textfile );
+		if ( textfile )
+		{
+			char buf[ 1024 ];
+			fgets( buf, 1024, textfile );
+			XmlTest( "Entity transformation: write. ",
+					 "<psg context=\'Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
+					 " It also has &lt;, &gt;, and &amp;, as well as a fake copyright \xC2\xA9.' />",
+					 buf,
+					 true );
+		}
+		fclose( textfile );
+	}
+
+    {
+		FILE* textfile = fopen( "test5.xml", "w" );
+		if ( textfile )
+		{
+            fputs("<?xml version='1.0'?><a.elem xmi.version='2.0'/>", textfile);
+            fclose(textfile);
+
+			TiXmlDocument doc;
+            doc.LoadFile( "test5.xml" );
+            XmlTest( "dot in element attributes and names", doc.Error(), 0);
+		}
+    }
+
+	{
+		FILE* textfile = fopen( "test6.xml", "w" );
+		if ( textfile )
+		{
+            fputs("<element><Name>1.1 Start easy ignore fin thickness&#xA;</Name></element>", textfile );
+            fclose(textfile);
+
+            TiXmlDocument doc;
+            bool result = doc.LoadFile( "test6.xml" );
+            XmlTest( "Entity with one digit.", result, true );
+
+			TiXmlText* text = doc.FirstChildElement()->FirstChildElement()->FirstChild()->ToText();
+			XmlTest( "Entity with one digit.",
+						text->Value(), "1.1 Start easy ignore fin thickness\n" );
+		}
+    }
+
+	{
+		// DOCTYPE not preserved (950171)
+		// 
+		const char* doctype =
+			"<?xml version=\"1.0\" ?>"
+			"<!DOCTYPE PLAY SYSTEM 'play.dtd'>"
+			"<!ELEMENT title (#PCDATA)>"
+			"<!ELEMENT books (title,authors)>"
+			"<element />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		doc.SaveFile( "test7.xml" );
+		doc.Clear();
+		doc.LoadFile( "test7.xml" );
+		
+		TiXmlHandle docH( &doc );
+		TiXmlUnknown* unknown = docH.Child( 1 ).Unknown();
+		XmlTest( "Correct value of unknown.", "!DOCTYPE PLAY SYSTEM 'play.dtd'", unknown->Value() );
+		#ifdef TIXML_USE_STL
+		TiXmlNode* node = docH.Child( 2 ).Node();
+		std::string str;
+		str << (*node);
+		XmlTest( "Correct streaming of unknown.", "<!ELEMENT title (#PCDATA)>", str.c_str() );
+		#endif
+	}
+
+	{
+		// [ 791411 ] Formatting bug
+		// Comments do not stream out correctly.
+		const char* doctype = 
+			"<!-- Somewhat<evil> -->";
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+
+		TiXmlHandle docH( &doc );
+		TiXmlComment* comment = docH.Child( 0 ).Node()->ToComment();
+
+		XmlTest( "Comment formatting.", " Somewhat<evil> ", comment->Value() );
+		#ifdef TIXML_USE_STL
+		std::string str;
+		str << (*comment);
+		XmlTest( "Comment streaming.", "<!-- Somewhat<evil> -->", str.c_str() );
+		#endif
+	}
+
+	{
+		// [ 870502 ] White space issues
+		TiXmlDocument doc;
+		TiXmlText* text;
+		TiXmlHandle docH( &doc );
+	
+		const char* doctype0 = "<element> This has leading and trailing space </element>";
+		const char* doctype1 = "<element>This has  internal space</element>";
+		const char* doctype2 = "<element> This has leading, trailing, and  internal space </element>";
+
+		TiXmlBase::SetCondenseWhiteSpace( false );
+		doc.Clear();
+		doc.Parse( doctype0 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", " This has leading and trailing space ", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype1 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", "This has  internal space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype2 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space kept.", " This has leading, trailing, and  internal space ", text->Value() );
+
+		TiXmlBase::SetCondenseWhiteSpace( true );
+		doc.Clear();
+		doc.Parse( doctype0 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has leading and trailing space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype1 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has internal space", text->Value() );
+
+		doc.Clear();
+		doc.Parse( doctype2 );
+		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
+		XmlTest( "White space condensed.", "This has leading, trailing, and internal space", text->Value() );
+	}
+
+	{
+		// Double attributes
+		const char* doctype = "<element attr='red' attr='blue' />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		
+		XmlTest( "Parsing repeated attributes.", 0, (int)doc.Error() );	// not an  error to tinyxml
+		XmlTest( "Parsing repeated attributes.", "blue", doc.FirstChildElement( "element" )->Attribute( "attr" ) );
+	}
+
+	{
+		// Embedded null in stream.
+		const char* doctype = "<element att\0r='red' attr='blue' />";
+
+		TiXmlDocument doc;
+		doc.Parse( doctype );
+		XmlTest( "Embedded null throws error.", true, doc.Error() );
+
+		#ifdef TIXML_USE_STL
+		istringstream strm( doctype );
+		doc.Clear();
+		doc.ClearError();
+		strm >> doc;
+		XmlTest( "Embedded null throws error.", true, doc.Error() );
+		#endif
+	}
+
+    {
+            // Legacy mode test. (This test may only pass on a western system)
+            const char* str =
+                        "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>"
+                        "<?>"
+                        "C?nt?nt???????"
+                        "</?>";
+
+            TiXmlDocument doc;
+            doc.Parse( str );
+
+            TiXmlHandle docHandle( &doc );
+            TiXmlHandle aHandle = docHandle.FirstChildElement( "?" );
+            TiXmlHandle tHandle = aHandle.Child( 0 );
+            assert( aHandle.Element() );
+            assert( tHandle.Text() );
+            XmlTest( "ISO-8859-1 Parsing.", "C?nt?nt???????", tHandle.Text()->Value() );
+    }
+
+	{
+		// Empty documents should return TIXML_ERROR_PARSING_EMPTY, bug 1070717
+		const char* str = "    ";
+		TiXmlDocument doc;
+		doc.Parse( str );
+		XmlTest( "Empty document error TIXML_ERROR_DOCUMENT_EMPTY", TiXmlBase::TIXML_ERROR_DOCUMENT_EMPTY, doc.ErrorId() );
+	}
+	#ifndef TIXML_USE_STL
+	{
+		// String equality. [ 1006409 ] string operator==/!= no worky in all cases
+		TiXmlString temp;
+		XmlTest( "Empty tinyxml string compare equal", ( temp == "" ), true );
+
+		TiXmlString    foo;
+		TiXmlString    bar( "" );
+		XmlTest( "Empty tinyxml string compare equal", ( foo == bar ), true );
+	}
+
+	#endif
+	{
+		// Bug [ 1195696 ] from marlonism
+		TiXmlBase::SetCondenseWhiteSpace(false); 
+		TiXmlDocument xml; 
+		xml.Parse("<text><break/>This hangs</text>"); 
+		XmlTest( "Test safe error return.", xml.Error(), false );
+	}
+
+	{
+		// Bug [ 1243992 ] - another infinite loop
+		TiXmlDocument doc;
+		doc.SetCondenseWhiteSpace(false);
+		doc.Parse("<p><pb></pb>test</p>");
+	} 
+	{
+		// Low entities
+		TiXmlDocument xml;
+		xml.Parse( "<test>&#x0e;</test>" );
+		const char result[] = { 0x0e, 0 };
+		XmlTest( "Low entities.", xml.FirstChildElement()->GetText(), result );
+		xml.Print();
+	}
+	{
+		// Bug [ 1451649 ] Attribute values with trailing quotes not handled correctly
+		TiXmlDocument xml;
+		xml.Parse( "<foo attribute=bar\" />" );
+		XmlTest( "Throw error with bad end quotes.", xml.Error(), true );
+	}
+	#ifdef TIXML_USE_STL
+	{
+		// Bug [ 1449463 ] Consider generic query
+		TiXmlDocument xml;
+		xml.Parse( "<foo bar='3' barStr='a string'/>" );
+
+		TiXmlElement* ele = xml.FirstChildElement();
+		double d;
+		int i;
+		float f;
+		bool b;
+		//std::string str;
+
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &d ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &i ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &f ), TIXML_SUCCESS );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &b ), TIXML_WRONG_TYPE );
+		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "nobar", &b ), TIXML_NO_ATTRIBUTE );
+		//XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "barStr", &str ), TIXML_SUCCESS );
+
+		XmlTest( "QueryValueAttribute", (d==3.0), true );
+		XmlTest( "QueryValueAttribute", (i==3), true );
+		XmlTest( "QueryValueAttribute", (f==3.0f), true );
+		//XmlTest( "QueryValueAttribute", (str==std::string( "a string" )), true );
+	}
+	#endif
+
+	#ifdef TIXML_USE_STL
+	{
+		// [ 1505267 ] redundant malloc in TiXmlElement::Attribute
+		TiXmlDocument xml;
+		xml.Parse( "<foo bar='3' />" );
+		TiXmlElement* ele = xml.FirstChildElement();
+		double d;
+		int i;
+
+		std::string bar = "bar";
+
+		const std::string* atrrib = ele->Attribute( bar );
+		ele->Attribute( bar, &d );
+		ele->Attribute( bar, &i );
+
+		XmlTest( "Attribute", atrrib->empty(), false );
+		XmlTest( "Attribute", (d==3.0), true );
+		XmlTest( "Attribute", (i==3), true );
+	}
+	#endif
+
+	{
+		// [ 1356059 ] Allow TiXMLDocument to only be at the top level
+		TiXmlDocument xml, xml2;
+		xml.InsertEndChild( xml2 );
+		XmlTest( "Document only at top level.", xml.Error(), true );
+		XmlTest( "Document only at top level.", xml.ErrorId(), TiXmlBase::TIXML_ERROR_DOCUMENT_TOP_ONLY );
+	}
+
+	{
+		// [ 1663758 ] Failure to report error on bad XML
+		TiXmlDocument xml;
+		xml.Parse("<x>");
+		XmlTest("Missing end tag at end of input", xml.Error(), true);
+		xml.Parse("<x> ");
+		XmlTest("Missing end tag with trailing whitespace", xml.Error(), true);
+	} 
+
+	{
+		// [ 1635701 ] fail to parse files with a tag separated into two lines
+		// I'm not sure this is a bug. Marked 'pending' for feedback.
+		TiXmlDocument xml;
+		xml.Parse( "<title><p>text</p\n><title>" );
+		//xml.Print();
+		//XmlTest( "Tag split by newline", xml.Error(), false );
+	}
+
+	#ifdef TIXML_USE_STL
+	{
+		// [ 1475201 ] TinyXML parses entities in comments
+		TiXmlDocument xml;
+		istringstream parse1( "<!-- declarations for <head> & <body> -->"
+						      "<!-- far &amp; away -->" );
+		parse1 >> xml;
+
+		TiXmlNode* e0 = xml.FirstChild();
+		TiXmlNode* e1 = e0->NextSibling();
+		TiXmlComment* c0 = e0->ToComment();
+		TiXmlComment* c1 = e1->ToComment();
+
+		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
+		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
+	}
+	#endif
+
+	{
+		// [ 1475201 ] TinyXML parses entities in comments
+		TiXmlDocument xml;
+		xml.Parse("<!-- declarations for <head> & <body> -->"
+				  "<!-- far &amp; away -->" );
+
+		TiXmlNode* e0 = xml.FirstChild();
+		TiXmlNode* e1 = e0->NextSibling();
+		TiXmlComment* c0 = e0->ToComment();
+		TiXmlComment* c1 = e1->ToComment();
+
+		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
+		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
+	}
+	/*
+	{
+		TiXmlDocument xml;
+		xml.Parse( "<tag>/</tag>" );
+		xml.Print();
+		xml.FirstChild()->Print( stdout, 0 );
+		xml.FirstChild()->Type();
+	}
+	*/
+	
+	/*  1417717 experiment
+	{
+		TiXmlDocument xml;
+		xml.Parse("<text>Dan & Tracie</text>");
+		xml.Print(stdout);
+	}
+	{
+		TiXmlDocument xml;
+		xml.Parse("<text>Dan &foo; Tracie</text>");
+		xml.Print(stdout);
+	}
+	*/
+	#if defined( WIN32 ) && defined( TUNE )
+	_CrtMemCheckpoint( &endMemState );
+	//_CrtMemDumpStatistics( &endMemState );
+
+	_CrtMemState diffMemState;
+	_CrtMemDifference( &diffMemState, &startMemState, &endMemState );
+	_CrtMemDumpStatistics( &diffMemState );
+	#endif
+
+	printf ("\nPass %d, Fail %d\n", gPass, gFail);
+	return gFail;
+}
+
+



From blakharaz at mail.berlios.de  Sat Nov  7 20:39:40 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 20:39:40 +0100
Subject: [Dsa-hl-svn] r4961 - in rl/trunk: . cmake engine/ai
	engine/ai/include engine/ai/src engine/common
	engine/common/include engine/common/src engine/core
	engine/core/include engine/core/src engine/rules
	engine/rules/include engine/rules/src engine/script
	engine/script/include engine/script/src engine/startup
	engine/startup/src engine/ui engine/ui/include engine/ui/src
Message-ID: <200911071939.nA7JdesV003038@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 20:39:22 +0100 (Sat, 07 Nov 2009)
New Revision: 4961

Added:
   rl/trunk/cmake/FindTinyXML.cmake
Removed:
   rl/trunk/engine/common/include/OgreXercesInput.h
   rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h
   rl/trunk/engine/common/src/OgreXercesInput.cpp
   rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp
Modified:
   rl/trunk/.project
   rl/trunk/CMakeLists.txt
   rl/trunk/engine/ai/CMakeLists.txt
   rl/trunk/engine/ai/include/DialogLoaderImpl.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/common/CMakeLists.txt
   rl/trunk/engine/common/include/CommonPrerequisites.h
   rl/trunk/engine/common/include/RastullahPrerequisites.h
   rl/trunk/engine/common/include/XmlProcessor.h
   rl/trunk/engine/common/include/XmlPropertyReader.h
   rl/trunk/engine/common/include/XmlPropertyWriter.h
   rl/trunk/engine/common/include/XmlResource.h
   rl/trunk/engine/common/src/XmlProcessor.cpp
   rl/trunk/engine/common/src/XmlPropertyReader.cpp
   rl/trunk/engine/common/src/XmlPropertyWriter.cpp
   rl/trunk/engine/common/src/XmlResource.cpp
   rl/trunk/engine/core/CMakeLists.txt
   rl/trunk/engine/core/include/PhysicsRagDoll.h
   rl/trunk/engine/core/include/SaveGameFile.h
   rl/trunk/engine/core/include/SaveGameFileReader.h
   rl/trunk/engine/core/src/ContentModule.cpp
   rl/trunk/engine/core/src/GenericWorld.cpp
   rl/trunk/engine/core/src/JobScheduler.cpp
   rl/trunk/engine/core/src/PhysicsRagDoll.cpp
   rl/trunk/engine/core/src/SaveGameFile.cpp
   rl/trunk/engine/core/src/SaveGameFileReader.cpp
   rl/trunk/engine/core/src/SaveGameFileWriter.cpp
   rl/trunk/engine/core/src/SaveGameManager.cpp
   rl/trunk/engine/core/src/TimeSource.cpp
   rl/trunk/engine/core/src/ZoneManager.cpp
   rl/trunk/engine/rules/CMakeLists.txt
   rl/trunk/engine/rules/include/DsaDataLoader.h
   rl/trunk/engine/rules/include/QuestBook.h
   rl/trunk/engine/rules/src/DsaDataLoader.cpp
   rl/trunk/engine/rules/src/GlobalProperties.cpp
   rl/trunk/engine/rules/src/QuestBook.cpp
   rl/trunk/engine/script/CMakeLists.txt
   rl/trunk/engine/script/include/AbstractMapNodeProcessor.h
   rl/trunk/engine/script/include/EntityNodeProcessor.h
   rl/trunk/engine/script/include/EnvironmentProcessor.h
   rl/trunk/engine/script/include/GameObjectNodeProcessor.h
   rl/trunk/engine/script/include/LightNodeProcessor.h
   rl/trunk/engine/script/include/MapLoader.h
   rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
   rl/trunk/engine/script/include/PlaneNodeProcessor.h
   rl/trunk/engine/script/include/SoundNodeProcessor.h
   rl/trunk/engine/script/include/WaypointProcessor.h
   rl/trunk/engine/script/include/ZoneProcessor.h
   rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
   rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
   rl/trunk/engine/script/src/LightNodeProcessor.cpp
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/script/src/SceneLoader.cpp
   rl/trunk/engine/script/src/SoundNodeProcessor.cpp
   rl/trunk/engine/script/src/TriggerFactory.cpp
   rl/trunk/engine/script/src/WaypointProcessor.cpp
   rl/trunk/engine/script/src/ZoneProcessor.cpp
   rl/trunk/engine/startup/CMakeLists.txt
   rl/trunk/engine/startup/src/RastullahMain.cpp
   rl/trunk/engine/ui/CMakeLists.txt
   rl/trunk/engine/ui/include/UiPrerequisites.h
   rl/trunk/engine/ui/src/InputManager.cpp
Log:
Replaced XML library (Xerces-C) by TinyXML (smaller and simpler and doesn't use symbols defined by ruby)

Modified: rl/trunk/.project
===================================================================
--- rl/trunk/.project	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/.project	2009-11-07 19:39:22 UTC (rev 4961)
@@ -79,7 +79,7 @@
 				</dictionary>
 				<dictionary>
 					<key>org.eclipse.cdt.make.core.environment</key>
-					<value></value>
+					<value>MAKEFLAGS=-j4|</value>
 				</dictionary>
 				<dictionary>
 					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>

Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -24,7 +24,7 @@
 
 # Check for required components
 FIND_PACKAGE(PkgConfig)
-FIND_PACKAGE(XercesC REQUIRED)
+FIND_PACKAGE(TinyXML REQUIRED)
 FIND_PACKAGE(OGRE 1.6 REQUIRED)
 FIND_PACKAGE(OIS REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)

Added: rl/trunk/cmake/FindTinyXML.cmake
===================================================================
--- rl/trunk/cmake/FindTinyXML.cmake	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/cmake/FindTinyXML.cmake	2009-11-07 19:39:22 UTC (rev 4961)
@@ -0,0 +1,64 @@
+# Find TinyXML (A small XML DOM library)
+#
+# This module defines
+# TINYXML_FOUND       - TinyXML was found
+# TINYXML_INCLUDE_DIR - Directory containing TinyXML header files
+# TINYXML_LIBRARY     - Library name of TinyXML library
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# On a new cmake run, we do not need to be verbose
+IF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY)
+	SET(TINYXML_FOUND_QUIETLY TRUE)
+ENDIF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY)
+
+IF(WIN32)
+
+ELSE(WIN32)
+	IF(NOT TINYXML_FOUND)
+		SET(TINYXML_INCLUDE_SEARCH_DIRS
+		    /usr/include
+		    /usr/local/include
+		    /opt/include
+		    /opt/tinyxml/include)
+		SET(TINYXML_LIBRARY_SEARCH_DIRS
+		    /usr/lib
+		    /usr/lib64
+		    /usr/local/lib
+		    /usr/local/lib64
+		    /opt/tinyxml/lib
+		    /opt/tinyxml/lib64)
+		SET(TINYXML_INC_DIR_SUFFIXES PATH_SUFFIXES tinyxml)
+		FIND_PATH(TINYXML_INCLUDE_DIR tinyxml.h
+		          PATHS ${TINYXML_INCLUDE_SEARCH_DIRS}
+		          PATH_SUFFIXES ${TINYXML_INC_DIR_SUFFIXES})
+		SET(TINYXML_LIBRARY tinyxml)
+		FIND_PATH(TINYXML_LIBRARY_DIRS libtinyxml.a
+		             PATHS ${TINYXML_LIBRARY_SEARCH_DIRS}
+		             PATH_SUFFIXES ${TINYXML_LIB_DIR_SUFFIXES}})
+	ENDIF(NOT TINYXML_FOUND)
+ENDIF(WIN32)
+
+SET(TINYXML_INCLUDE_DIR ${TINYXML_INCLUDE_DIR} CACHE STRING "Directory containing TinyXML header files")
+SET(TINYXML_LIBRARY ${TINYXML_LIBRARY} CACHE STRING "Library name of TinyXML library")
+
+IF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY_DIRS)
+	SET(TINYXML_FOUND TRUE)
+ENDIF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY_DIRS)
+
+IF(TINYXML_FOUND)
+	IF(NOT TINYXML_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries: ${TINYXML_LIBRARY} from ${TINYXML_LIBRARY_DIRS}")
+		MESSAGE(STATUS "  includes: ${TINYXML_INCLUDE_DIR}")
+	ENDIF(NOT TINYXML_FIND_QUIETLY)
+ELSE(TINYXML_FOUND)
+	IF(TINYXML_FIND_REQUIRED)
+		IF(NOT TINYXML_LIBRARY_DIRS)
+			MESSAGE(SEND_ERROR, "TinyXML library could not be found.")
+		ENDIF(NOT TINYXML_LIBRARY)
+		IF(NOT TINYXML_INCLUDE_DIR)
+			MESSAGE(SEND_ERROR "TinyXML include files could not be found.")
+		ENDIF(NOT TINYXML_INCLUDE_DIR)
+	ENDIF(TINYXML_FIND_REQUIRED)
+ENDIF(TINYXML_FOUND)

Modified: rl/trunk/engine/ai/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ai/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -7,7 +7,7 @@
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIRS}
 ${OPENSTEER_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR})
+${TINYXML_INCLUDE_DIR})
 
 SET(RlAi_LIB_SRCS
 src/Agent.cpp

Modified: rl/trunk/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,10 +16,11 @@
 #include "AiPrerequisites.h"
 
 #include <list>
+#include <tinyxml.h>
 
+#include "Creature.h"
 #include "Properties.h"
 #include "XmlProcessor.h"
-#include "Creature.h"
 
 namespace rl
 {
@@ -33,14 +34,15 @@
     class DialogVariable;
 	class Property;
 
-    class DialogLoaderImpl : private XmlProcessor
+	class DialogLoaderImpl : private XmlProcessor, public TiXmlVisitor
     {
     public:
         DialogLoaderImpl();
-        ~DialogLoaderImpl();
+        virtual ~DialogLoaderImpl();
 
         Dialog* createDialog(const Ogre::String& name, const CreatureList& participants) const;
         void parseDialog(Ogre::DataStreamPtr& stream, const Ogre::String& groupName);
+        virtual bool VisitEnter(const TiXmlElement &element, const TiXmlAttribute *firstAttribute);
 
     private:
         class DialogParticipant
@@ -83,23 +85,23 @@
             PropertyRecord mPropertyVariables;
         };
 
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        DialogParticipant* processPerson(XERCES_CPP_NAMESPACE::DOMElement* personXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype);
+        void processDialog(const TiXmlElement* dialogXml);
+        DialogResponse* processResponseClasses(const TiXmlNode *node, DialogPrototype* dialogPrototype);
+        DialogResponse* processResponse(const TiXmlElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogResponse* processSwitchResponse(const TiXmlElement* switchRespXml, DialogPrototype* dialogPrototype);
+        DialogOption* processOptionClasses(const TiXmlNode *node, DialogPrototype *dialogPrototype);
+        DialogOption* processOption(const TiXmlElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogOption* processSwitchOption(const TiXmlElement* switchOptXml, DialogPrototype* dialogPrototype);
+        DialogCondition* processIf(const TiXmlElement *ifXml);
+        DialogCondition* processCase(const TiXmlElement *caseXml);
+        DialogVariable* processVariableClasses(const TiXmlElement* variableXml);
+        DialogCondition* processConditionClasses(const TiXmlElement* conditionXml);
+        DialogParagraph* processParagraph(const TiXmlElement* paragraphXml);
+        DialogImplication* processImplicationClasses(const TiXmlNode* implicationXml);
+        DialogParticipant* processPerson(const TiXmlElement* personXml);
+        void processTranslation(DialogElement* element, const TiXmlNode* translationXml);
+        void createDialogVariable(const TiXmlElement* variableXml, DialogPrototype* dialogPrototype);
+        void processElementNodes(const TiXmlElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype);
 
         std::map<Ogre::String, DialogPrototype*> mDialogs;
 

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -26,8 +26,6 @@
 #include "LandmarkPath.h"
 #include "WayPointGraphManager.h"
 
-#include <xercesc/util/PlatformUtils.hpp>
-
 #include "XmlProcessor.h"
 #include "XmlResourceManager.h"
 #include "ContentModule.h"
@@ -35,7 +33,6 @@
 
 using namespace Ogre;
 using namespace OpenSteer;
-using namespace XERCES_CPP_NAMESPACE;
 
 template<> rl::AiSubsystem* Singleton<rl::AiSubsystem>::ms_Singleton = 0;
 

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -15,8 +15,6 @@
  */
 #include "stdinc.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #ifdef __APPLE__
 #   include <CEGUI/CEGUIPropertyHelper.h>
 #else
@@ -40,7 +38,6 @@
 
 using namespace Ogre;
 using namespace std;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -64,21 +61,22 @@
 
     void DialogLoaderImpl::parseDialog(DataStreamPtr& stream, const Ogre::String& groupName)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
+        TiXmlDocument* doc = loadDocument(stream);
         if (doc)
         {
-            DOMNodeList* dialogNodes = doc->getElementsByTagName(AutoXMLCh("dialog").data());
-
-            for (XMLSize_t i = 0; i < dialogNodes->getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes->item(i);
-                processDialog(static_cast<DOMElement*>(cur));
-            }
+        	doc->Accept(this);
         }
+        delete doc;
+    }
 
-        shutdownXml();
+    bool DialogLoaderImpl::VisitEnter(const TiXmlElement &element, const TiXmlAttribute *firstAttribute)
+    {
+    	if (element.ValueTStr() == "dialog")
+    	{
+    		processDialog(&element);
+    		return false;
+    	}
+    	return true;
     }
 
     Dialog* DialogLoaderImpl::createDialog(const String& name, const CreatureList& participants) const
@@ -94,7 +92,7 @@
         return it->second->createDialog(participants);
     }
 
-    void DialogLoaderImpl::processDialog(DOMElement* dialogElem)
+    void DialogLoaderImpl::processDialog(const TiXmlElement* dialogElem)
     {
         DialogPrototype* dialogPrototype = new DialogPrototype();
         Ogre::String name = getAttributeValueAsStdString(dialogElem, "name");
@@ -106,32 +104,32 @@
         processElementNodes(dialogElem, "response", dialogPrototype);
         processElementNodes(dialogElem, "switchresponse", dialogPrototype);
 
-        for (DOMNode* curChild = dialogElem->getFirstChild(); curChild != NULL; curChild = curChild->getNextSibling())
+        for (const TiXmlNode* curChild = dialogElem->FirstChild(); curChild != NULL; curChild = curChild->NextSibling())
         {
             if (hasNodeName(curChild, "variable"))
             {
-                createDialogVariable(static_cast<DOMElement*>(curChild), dialogPrototype);
+                createDialogVariable(curChild->ToElement(), dialogPrototype);
             }
             else if (hasNodeName(curChild, "option"))
             {
-                processOption(static_cast<DOMElement*>(curChild), dialogPrototype, true);
+                processOption(curChild->ToElement(), dialogPrototype, true);
             }
             else if (hasNodeName(curChild, "switchoption"))
             {
-                processSwitchOption(static_cast<DOMElement*>(curChild), dialogPrototype);
+                processSwitchOption(curChild->ToElement(), dialogPrototype);
             }
             else if (hasNodeName(curChild, "response"))
             {
-                processResponse(static_cast<DOMElement*>(curChild), dialogPrototype, true);
+                processResponse(curChild->ToElement(), dialogPrototype, true);
             }
             else if (hasNodeName(curChild, "switchresponse"))
             {
-                processSwitchResponse(static_cast<DOMElement*>(curChild), dialogPrototype);
+                processSwitchResponse(curChild->ToElement(), dialogPrototype);
             }
             else if (hasNodeName(curChild, "start"))
             {
-                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL;
-                     curChildChild = curChildChild->getNextSibling())
+                for (const TiXmlNode* curChildChild = curChild->FirstChild(); curChildChild != NULL;
+                     curChildChild = curChildChild->NextSibling())
                 {
                     DialogResponse* response = processResponseClasses(curChildChild, dialogPrototype);
                     if (response)
@@ -142,12 +140,12 @@
             }
             else if (hasNodeName(curChild, "persons"))
             {
-                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL;
-                                     curChildChild = curChildChild->getNextSibling())
+                for (const TiXmlNode* curChildChild = curChild->FirstChild(); curChildChild != NULL;
+                                     curChildChild = curChildChild->NextSibling())
                 {
                     if (hasNodeName(curChildChild, "person"))
                     {
-                        dialogPrototype->addParticipant(processPerson(static_cast<DOMElement*>(curChildChild)));
+                        dialogPrototype->addParticipant(processPerson(curChildChild->ToElement()));
                     }
                 }
             }
@@ -155,12 +153,12 @@
         LOG_MESSAGE(Logger::AI, "Processed Dialog "+ name);
     }
 
-    void DialogLoaderImpl::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype)
+    void DialogLoaderImpl::processElementNodes(const TiXmlElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype)
     {
-        DOMNodeList* dialogElemNodes = dialogXml->getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i < dialogElemNodes->getLength(); ++i)
+        XmlElementList dialogElemNodes = getElementsByTagName(dialogXml, nodeName.c_str());
+        for (XmlElementList::iterator it = dialogElemNodes.begin(); it != dialogElemNodes.end(); ++it)
         {
-            DOMElement* dialogElemXml = static_cast<DOMElement*>(dialogElemNodes->item(i));
+            const TiXmlElement* dialogElemXml = *it;
             if (!hasAttribute(dialogElemXml, "id"))
             {
                 Throw(WrongFormatException, "option/switchoption/response/switchresponse node without id found");
@@ -205,25 +203,25 @@
 
     }
 
-    DialogResponse* DialogLoaderImpl::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    DialogResponse* DialogLoaderImpl::processResponseClasses(const TiXmlNode *node, DialogPrototype *dialogPrototype)
     {
         DialogResponse* response = NULL;
         if (hasNodeName(node, "response"))
         {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, true);
+            response = processResponse(node->ToElement(), dialogPrototype, true);
         }
         else if (hasNodeName(node, "gotoresponse"))
         {
-            response = processResponse(static_cast<DOMElement*>(node), dialogPrototype, false);
+            response = processResponse(node->ToElement(), dialogPrototype, false);
         }
         else if (hasNodeName(node, "switchresponse"))
         {
-            response = processSwitchResponse(static_cast<DOMElement*>(node), dialogPrototype);
+            response = processSwitchResponse(node->ToElement(), dialogPrototype);
         }
         return response;
     }
 
-    DialogResponse* DialogLoaderImpl::processResponse(DOMElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
+    DialogResponse* DialogLoaderImpl::processResponse(const TiXmlElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(responseXml, "id");
 
@@ -232,12 +230,12 @@
         if (!response)  Throw(IllegalArgumentException, CeGuiString("No response with ID "+ id).c_str());
 
         bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
+        const TiXmlElement* defaultLanguage = NULL;
         if (subelements)
         {
             bool paragraphsDefined = false;
 
-            for (DOMNode* cur = responseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+            for (const TiXmlNode* cur = responseXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
             {
                 DialogOption* option = processOptionClasses(cur, dialogPrototype);
                 if (option)
@@ -255,13 +253,13 @@
 
                 if (hasNodeName(cur, "p"))
                 {
-                    response->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
+                    response->addParagraph(processParagraph(cur->ToElement()));
                     paragraphsDefined = true;
                 }
                 // process translations
                 else if (hasNodeName(cur, "t"))
                 {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
+                	const TiXmlElement* translation = cur->ToElement();
                     // check loca
                     if (getAttributeValueAsStdString(translation, "language")
                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
@@ -278,7 +276,7 @@
                 }
                 else if (hasNodeName(cur, "gotoresponse"))
                 {
-                    CeGuiString id = getAttributeValueAsString(static_cast<DOMElement*>(cur), "id");
+                    CeGuiString id = getAttributeValueAsString(cur->ToElement(), "id");
                     response->addParagraph(new DialogGotoResponse(dialogPrototype->getResponse(id)));
                 }
             }
@@ -301,24 +299,24 @@
         return response;
     }
 
-    DialogResponse* DialogLoaderImpl::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
+    DialogResponse* DialogLoaderImpl::processSwitchResponse(const TiXmlElement* switchRespXml, DialogPrototype* dialogPrototype)
     {
         CeGuiString id = getAttributeValueAsString(switchRespXml, "id");
         DialogSelection<DialogResponse>* response = dynamic_cast<DialogSelection<DialogResponse>*>(dialogPrototype->getResponse(id));
 
         if (!response)  Throw(IllegalArgumentException, CeGuiString("No switchresponse with ID "+ id).c_str());
 
-        for (DOMNode* cur = switchRespXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        for (const TiXmlNode* cur = switchRespXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
+            DialogVariable* variable = processVariableClasses(cur->ToElement());
             if (variable != NULL)
             {
                 response->setVariable(variable);
             }
             else if (hasNodeName(cur, "case"))
             {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
+                DialogCondition* condition = processCase(cur->ToElement());
+                for (const TiXmlNode* caseChild = cur->FirstChild(); caseChild != NULL; caseChild = caseChild->NextSibling())
                 {
                     DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
                     if (responseCase)
@@ -334,26 +332,26 @@
         return response;
     }
 
-    DialogOption* DialogLoaderImpl::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    DialogOption* DialogLoaderImpl::processOptionClasses(const TiXmlNode *node, DialogPrototype *dialogPrototype)
     {
         DialogOption* option = NULL;
         if (hasNodeName(node, "option"))
         {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, true);
+            option = processOption(node->ToElement(), dialogPrototype, true);
         }
         else if (hasNodeName(node, "optionref"))
         {
-            option = processOption(static_cast<DOMElement*>(node), dialogPrototype, false);
+            option = processOption(node->ToElement(), dialogPrototype, false);
         }
         else if (hasNodeName(node, "switchoption"))
         {
-            option = processSwitchOption(static_cast<DOMElement*>(node), dialogPrototype);
+            option = processSwitchOption(node->ToElement(), dialogPrototype);
         }
 
         return option;
     }
 
-    DialogOption* DialogLoaderImpl::processOption(DOMElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
+    DialogOption* DialogLoaderImpl::processOption(const TiXmlElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(optionXml, "id");
 
@@ -362,13 +360,13 @@
         if (!option)    Throw(IllegalArgumentException, CeGuiString("No option with ID "+ id).c_str());
 
         bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
+        const TiXmlElement* defaultLanguage = NULL;
 
         if (subelements)
         {
             bool paragraphsDefined = false;
 
-            for (DOMNode* cur = optionXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+            for (const TiXmlNode* cur = optionXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
             {
                 DialogResponse* response = processResponseClasses(cur, dialogPrototype);
                 if (response)
@@ -377,17 +375,17 @@
                 }
                 else if (hasNodeName(cur, "if"))
                 {
-                    option->setPrecondition(processIf(static_cast<DOMElement*>(cur)));
+                    option->setPrecondition(processIf(cur->ToElement()));
                 }
                 else if (hasNodeName(cur, "p"))
                 {
-                    option->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
+                    option->addParagraph(processParagraph(cur->ToElement()));
                     paragraphsDefined = true;
                 }
                 // process translations
                 else if (hasNodeName(cur, "t"))
                 {
-                    DOMElement* translation = static_cast<DOMElement*>(cur);
+                    const TiXmlElement* translation = cur->ToElement();
                     // check locale
                     if (getAttributeValueAsStdString(translation, "language")
                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
@@ -433,24 +431,24 @@
         return option;
     }
 
-    DialogOption* DialogLoaderImpl::processSwitchOption(DOMElement *switchOptXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
+    DialogOption* DialogLoaderImpl::processSwitchOption(const TiXmlElement *switchOptXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
     {
         CeGuiString id = getAttributeValueAsString(switchOptXml, "id");
         DialogOptionSelection* option = dynamic_cast<DialogOptionSelection*>(dialogPrototype->getOption(id));
 
         if (!option) Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
 
-        for (DOMNode* cur = switchOptXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        for (const TiXmlNode* cur = switchOptXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
-            DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
+            DialogVariable* variable = processVariableClasses(cur->ToElement());
             if (variable != NULL)
             {
                 option->setVariable(variable);
             }
             else if (hasNodeName(cur, "case"))
             {
-                DialogCondition* condition = processCase(static_cast<DOMElement*>(cur));
-                for (DOMNode* caseChild = cur->getFirstChild(); caseChild != NULL; caseChild = caseChild->getNextSibling())
+                DialogCondition* condition = processCase(cur->ToElement());
+                for (const TiXmlNode* caseChild = cur->FirstChild(); caseChild != NULL; caseChild = caseChild->NextSibling())
                 {
                     DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
                     if (optionCase)
@@ -463,7 +461,7 @@
             // process translations
             else if (hasNodeName(cur, "t"))
             {
-                DOMElement* translation = static_cast<DOMElement*>(cur);
+                const TiXmlElement* translation = cur->ToElement();
                 // check loca
                 if (getAttributeValueAsStdString(translation, "language") ==
                    ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
@@ -480,23 +478,23 @@
         return option;
     }
 
-    void DialogLoaderImpl::createDialogVariable(DOMElement *variableXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
+    void DialogLoaderImpl::createDialogVariable(const TiXmlElement *variableXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
     {
         XmlPropertyReader reader;
         PropertyEntry entry = reader.processProperty(variableXml);
         dialogPrototype->setProperty(entry.first, entry.second);
     }
 
-    DialogCondition* DialogLoaderImpl::processIf(DOMElement *ifXml)
+    DialogCondition* DialogLoaderImpl::processIf(const TiXmlElement *ifXml)
     {
         DialogCondition* cond = NULL;
         DialogVariable* var = NULL;
 
-        for (DOMNode* cur = ifXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        for (const TiXmlNode* cur = ifXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+            if (cur->Type() == TiXmlNode::ELEMENT)
             {
-                DOMElement* curElem = static_cast<DOMElement*>(cur);
+                const TiXmlElement* curElem = cur->ToElement();
 
                 DialogCondition* curCond = processConditionClasses(curElem);
                 if (curCond)
@@ -516,7 +514,7 @@
         return cond;
     }
 
-    DialogParagraph* DialogLoaderImpl::processParagraph(DOMElement* paragraphXml)
+    DialogParagraph* DialogLoaderImpl::processParagraph(const TiXmlElement* paragraphXml)
     {
         Ogre::String voicefile = "";
         CeGuiString person = "";
@@ -531,15 +529,15 @@
         return new DialogParagraph(getValueAsString(paragraphXml), person, voicefile);
     }
 
-    DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
+    DialogCondition* DialogLoaderImpl::processCase(const TiXmlElement *caseXml)
     {
         DialogCondition* cond = NULL;
 
-        for (DOMNode* cur = caseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        for (const TiXmlNode* cur = caseXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+            if (cur->Type() == TiXmlNode::ELEMENT)
             {
-                DialogCondition* curCond = processConditionClasses(static_cast<DOMElement*>(cur));
+                DialogCondition* curCond = processConditionClasses(cur->ToElement());
                 if (curCond)
                 {
                     cond = curCond;
@@ -695,7 +693,7 @@
             && (mName.empty() || creature->getName() == mName);
     }
 
-    DialogCondition* DialogLoaderImpl::processConditionClasses(DOMElement* conditionXml)
+    DialogCondition* DialogLoaderImpl::processConditionClasses(const TiXmlElement* conditionXml)
     {
         if (hasNodeName(conditionXml, "equals"))
         {
@@ -732,7 +730,7 @@
         return NULL;
     }
 
-    DialogVariable* DialogLoaderImpl::processVariableClasses(DOMElement* variableXml)
+    DialogVariable* DialogLoaderImpl::processVariableClasses(const TiXmlElement* variableXml)
     {
         if (hasNodeName(variableXml, "dialogvariable"))
         {
@@ -776,11 +774,11 @@
     }
 
 
-    DialogImplication* DialogLoaderImpl::processImplicationClasses(DOMNode* implicationXml)
+    DialogImplication* DialogLoaderImpl::processImplicationClasses(const TiXmlNode* implicationXml)
     {
-        if (implicationXml->getNodeType() == DOMNode::ELEMENT_NODE)
+        if (implicationXml->Type() == TiXmlNode::ELEMENT)
         {
-            DOMElement* implicationElem = static_cast<DOMElement*>(implicationXml);
+        	const TiXmlElement* implicationElem = implicationXml->ToElement();
 
             if (hasNodeName(implicationElem, "setvariable"))
             {
@@ -826,18 +824,18 @@
         return NULL;
     }
 
-    void DialogLoaderImpl::processTranslation(DialogElement* element, DOMNode* translationXml)
+    void DialogLoaderImpl::processTranslation(DialogElement* element, const TiXmlNode* translationXml)
     {
-        for (DOMNode* cur = translationXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        for (const TiXmlNode* cur = translationXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
             if (hasNodeName(cur, "p"))
             {
-                element->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
+                element->addParagraph(processParagraph(cur->ToElement()));
             }
         }
     }
 
-    DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(DOMElement* personXml)
+    DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(const TiXmlElement* personXml)
     {
         CeGuiString personId(""), goClass(""), name("");
         int goId = -1;

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,7 +17,6 @@
 
 #include "DialogManager.h"
 
-
 #include "Creature.h"
 #include "Dialog.h"
 #include "DialogLoader.h"
@@ -27,7 +26,6 @@
 
 using namespace Ogre;
 using namespace std;
-using namespace XERCES_CPP_NAMESPACE;
 
 template<>
     rl::DialogManager* Ogre::Singleton<rl::DialogManager>::ms_Singleton = NULL;

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -18,7 +18,6 @@
 #include "WayPointGraph.h"
 
 #include <algorithm>
-#include <xercesc/dom/DOM.hpp>
 
 #include "ConfigurationManager.h"
 #include "ContentModule.h"
@@ -97,29 +96,24 @@
 
 void WayPointGraph::load(const Ogre::String& filename, const Ogre::String& resourceGroup)
 {
-    using namespace XERCES_CPP_NAMESPACE;
-
     Ogre::String group = resourceGroup;
     if (group.empty())
     {
         group = CoreSubsystem::getSingleton().getActiveAdventureModule()->getId();
     }
 
-    initializeXml();
-
-    DOMDocument* doc = loadDocument(filename, group);
+    TiXmlDocument* doc = loadDocument(filename, group);
     if (doc)
     {
-        DOMElement* rootElem = doc->getDocumentElement();
+        TiXmlElement* rootElem = doc->RootElement();
 
-        DOMElement* nodesElem = getChildNamed(rootElem, "waypointnodes");
+        TiXmlElement* nodesElem = getChildNamed(rootElem, "waypointnodes");
         std::map<int, WayPointNode*> lookupTable;
-        for (DOMNode* curNode = nodesElem->getFirstChild(); curNode; curNode = curNode->getNextSibling())
+        for (TiXmlNode* curNode = nodesElem->FirstChild(); curNode; curNode = curNode->NextSibling())
         {
-            if (curNode->getNodeType() == DOMNode::ELEMENT_NODE
-                || hasNodeName(curNode, "node"))
+            if (curNode->Type() == TiXmlNode::ELEMENT || hasNodeName(curNode, "node"))
             {
-                DOMElement* curElem = static_cast<DOMElement*>(curNode);
+                TiXmlElement* curElem = static_cast<TiXmlElement*>(curNode);
 
                 Vector3 pos = getValueAsVector3(curElem);
                 CeGuiString typeS = getAttributeValueAsString(curElem, "type");
@@ -140,21 +134,18 @@
             }
         }
 
-        DOMElement* edgesElem = getChildNamed(rootElem, "waypointedges");
-        for (DOMNode* curNode = edgesElem->getFirstChild(); curNode; curNode = curNode->getNextSibling())
+        TiXmlElement* edgesElem = getChildNamed(rootElem, "waypointedges");
+        for (TiXmlNode* curNode = edgesElem->FirstChild(); curNode; curNode = curNode->NextSibling())
         {
-            if (curNode->getNodeType() == DOMNode::ELEMENT_NODE
-                || hasNodeName(curNode, "edge"))
+            if (curNode->Type() == TiXmlNode::ELEMENT || hasNodeName(curNode, "edge"))
             {
-                DOMElement* curElem = static_cast<DOMElement*>(curNode);
+                TiXmlElement* curElem = static_cast<TiXmlElement*>(curNode);
                 int source = getAttributeValueAsInteger(curElem, "source");
                 int destination = getAttributeValueAsInteger(curElem, "destination");
                 addDirectedConnection(lookupTable[source], lookupTable[destination]);
             }
         }
     }
-
-    shutdownXml();
 }
 
 const WayPointNode* WayPointGraph::getNearestWayPoint(const Vector3& position) const

Modified: rl/trunk/engine/common/CMakeLists.txt
===================================================================
--- rl/trunk/engine/common/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,6 +1,6 @@
 INCLUDE_DIRECTORIES(
 ${CMAKE_CURRENT_SOURCE_DIR}/include
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS})
 
@@ -11,12 +11,10 @@
 src/GameTask.cpp
 src/Logger.cpp
 src/MathUtil.cpp
-src/OgreXercesInput.cpp
 src/Properties.cpp
 src/Property.cpp
 src/ScriptWrapper.cpp
 src/WriteableDataStream.cpp
-src/WriteableDataStreamFormatTarget.cpp
 src/WriteableFileSystemArchiv.cpp
 src/XmlProcessor.cpp
 src/XmlPropertyReader.cpp
@@ -26,7 +24,7 @@
 
 ADD_LIBRARY(RlCommon SHARED ${RlCommon_LIB_SRCS})
 
-TARGET_LINK_LIBRARIES(RlCommon ${XERCESC_LIBRARIES} ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${Boost_FILESYSTEM_LIBRARY})
+TARGET_LINK_LIBRARIES(RlCommon ${TINYXML_LIBRARY} ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${Boost_FILESYSTEM_LIBRARY})
 
 SET_TARGET_PROPERTIES(RlCommon PROPERTIES
 	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}

Modified: rl/trunk/engine/common/include/CommonPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/CommonPrerequisites.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/CommonPrerequisites.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -33,7 +33,6 @@
 #	endif
 #endif
 
-
 #undef _assert
 
 #undef max

Deleted: rl/trunk/engine/common/include/OgreXercesInput.h
===================================================================
--- rl/trunk/engine/common/include/OgreXercesInput.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/OgreXercesInput.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,55 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __OgreXercesInput_H__
-#define __OgreXercesInput_H__
-
-#pragma warning (push)
-#pragma warning (disable : 4244)
-#include <xercesc/sax/InputSource.hpp>
-#include <xercesc/util/BinInputStream.hpp>
-#pragma warning (pop)
-
-#include "CommonPrerequisites.h"
-
-
-namespace rl {
-
-    class _RlCommonExport OgreBinInputStream : public XERCES_CPP_NAMESPACE::BinInputStream
-    {
-    public:
-        OgreBinInputStream(const Ogre::DataStreamPtr& stream);
-
-        virtual unsigned int curPos() const;
-        virtual unsigned int readBytes(XMLByte* const toFill, const unsigned int maxToRead);
-
-    private:
-        Ogre::DataStreamPtr mStream;
-    };
-
-    class _RlCommonExport OgreInputSource : public XERCES_CPP_NAMESPACE::InputSource
-    {
-    public:
-        OgreInputSource(const Ogre::DataStreamPtr& stream);
-
-        virtual XERCES_CPP_NAMESPACE::BinInputStream* makeStream() const;
-
-    private:
-        Ogre::DataStreamPtr mStream;
-    };
-}
-
-#endif //__OgreXercesInput_H__

Modified: rl/trunk/engine/common/include/RastullahPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/RastullahPrerequisites.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/RastullahPrerequisites.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -59,4 +59,6 @@
 #    endif
 #endif
 
+#define TIXML_USE_STL 1  // Let TinyXML use STL strings
+
 #endif

Deleted: rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,33 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-
-#include <xercesc/framework/XMLFormatter.hpp>
-#include "WriteableDataStream.h"
-
-namespace rl
-{
-    class WriteableDataStreamFormatTarget : public XERCES_CPP_NAMESPACE::XMLFormatTarget
-    {
-    public:
-        WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream);
-        void writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter);
-        void flush ();
-    protected:
-        WriteableDataStreamPtr mStream;
-    };
-}
-

Modified: rl/trunk/engine/common/include/XmlProcessor.h
===================================================================
--- rl/trunk/engine/common/include/XmlProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,62 +17,48 @@
 #ifndef __XmlHelper_h__
 #define __XmlHelper_h__
 
-#include <xercesc/dom/DOM.hpp>
-#include <xercesc/util/XMLChar.hpp>
-#include <xercesc/util/TransService.hpp>
-#include <xercesc/sax/ErrorHandler.hpp>
-#include <xercesc/sax2/Attributes.hpp>
-
-namespace XERCES_CPP_NAMESPACE
-{
-    class SAXParseException;
-}
-
 #include "CommonPrerequisites.h"
 
+#include <tinyxml.h>
+
 #include "Tripel.h"
 
-// Da sollten wir uns auf etwas einigen
-// So ist das laestig.
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-#   pragma warning (push)
-#   pragma warning (disable : 4267)
-#   include <CEGUIString.h>
-#   pragma warning (pop)
-#else
-#   include <CEGUI/CEGUIString.h>
-#endif
-namespace XERCES_CPP_NAMESPACE
-{
-    class XercesDOMParser;
-}
-
 namespace rl {
 
+typedef std::vector<const TiXmlElement*> XmlElementList;
+
 /**
  * This class offers helper methods for XML processing
  * To use this methods, just inherit this class privately 
  */
 class _RlCommonExport XmlProcessor
-    : public XERCES_CPP_NAMESPACE::ErrorHandler
 {
 public:
-    XmlProcessor() : mOpenParser(NULL) {}
+    XmlProcessor() {}
 
     /**
 	 * Erzeugt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat, 
 	 * dieser ist wiederum ein Element-Knoten
 	 *
-     * @param doc Das DOM-Document
 	 * @param parent Knoten, dessen Kind erzeugt wird
 	 * @param name Name des Kindknotens von parent
 	 *
 	 * @return Der Kindknoten
 	 */
-    XERCES_CPP_NAMESPACE::DOMElement* appendChildElement(XERCES_CPP_NAMESPACE::DOMDocument* doc, 
-        XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name) const;
+    TiXmlElement* appendChildElement(TiXmlElement* parent, const char* const name) const;
 
     /**
+	 * Erzeugt einen Kindknoten des Roots eines DOM-Dokuments, das einen bestimmten Namen hat,
+	 * dieser ist wiederum ein Element-Knoten
+	 *
+	 * @param parent Dokument
+	 * @param name Name des Kindknotens von parent
+	 *
+	 * @return Der Kindknoten
+	 */
+    TiXmlElement* appendChildElement(TiXmlDocument* parent, const char* const name) const;
+
+    /**
 	 * Ermittelt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat, 
 	 * dieser ist wiederum ein Element-Knoten
 	 *
@@ -81,16 +67,47 @@
 	 *
 	 * @return Der Kindknoten
 	 */
-	XERCES_CPP_NAMESPACE::DOMElement* getChildNamed(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name) const;
+    const TiXmlElement* getChildNamed(const TiXmlElement* parent, const char* const name) const;
+
+    /**
+	 * Ermittelt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat,
+	 * dieser ist wiederum ein Element-Knoten
+	 *
+	 * @param parent Knoten, dessen Kinder gesucht sind
+	 * @param name Name des gesuchten Kindknotens von parent
+	 *
+	 * @return Der Kindknoten
+	 */
+    TiXmlElement* getChildNamed(TiXmlElement* parent, const char* const name) const;
+
+    /**
+     * Collects all element nodes with a specified tag name
+	 *
+	 * @param parent start node
+	 * @param name node name to search
+	 *
+	 * @return vector of found element nodes
+     */
+    XmlElementList getElementsByTagName(const TiXmlElement* parent, const char* const name) const;
 	
     /**
+     * Collects all element nodes with a specified tag name
+	 *
+	 * @param parent start node
+	 * @param name node name to search
+	 *
+	 * @return vector of found element nodes
+     */
+    XmlElementList getElementsByTagName(const TiXmlDocument* parent, const char* const name) const;
+
+    /**
 	 * Setzt den Text eines Elementknotens
 	 *
 	 * @param element the DOM element node
      * @param string Der zu setzende String
 	 * @return the DOM element node
 	 */
-    void setValueAsString(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, const CeGuiString &value) const;
+    void setValueAsString(TiXmlElement* element, const CeGuiString &value) const;
     
     /**
 	 * Ermittelt den Text eines Elementknotens
@@ -98,7 +115,7 @@
 	 * @param element the DOM element node
 	 * @return Text innerhalb der Element-Tags, als CeGuiString
 	 */
-	CeGuiString getValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	CeGuiString getValueAsString(const TiXmlElement* element) const;
 	
     /**
 	 * Ermittelt den Text eines Elementknotens
@@ -106,7 +123,7 @@
 	 * @param element the DOM element node
 	 * @return Text innerhalb der Element-Tags, als CeGuiString
 	 */
-    std::string getValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    std::string getValueAsStdString(const TiXmlElement* element) const;
 
     /**
 	 * Setzt den Text eines Elementknotens, als UTF-8
@@ -116,17 +133,17 @@
      * @param utf Der zu setzende UTF String
 	 * @return the DOM element node
 	 */
-	void setValueAsUtf8(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, CEGUI::utf8* value) const;
+	void setValueAsUtf8(TiXmlElement* element, CEGUI::utf8* value) const;
     
     /**
 	 * Ermittelt den Text eines Elementknotens, als UTF-8
 	 * vor Benutzung muss initializeTranscoder() aufgerufen werden
 	 *
 	 * @param element the DOM element node
-	 * @return Text innerhalb der Element-Tags, als utf8* (muss selbst gel?scht werden)
+	 * @return Text innerhalb der Element-Tags, als utf8* (muss selbst gel???scht werden)
 	 * @see initializeTranscoder()
 	 */
-	CEGUI::utf8* getValueAsUtf8(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	const CEGUI::utf8* getValueAsUtf8(const TiXmlElement* element) const;
 
 	
     /**
@@ -136,7 +153,7 @@
      * @param value Der zu setzende Bool
 	 * @return the DOM element node
 	 */
-	void setValueAsBool(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, bool value) const;
+	void setValueAsBool(TiXmlElement* element, bool value) const;
 
     
     /**
@@ -145,7 +162,7 @@
 	 * @param element the DOM element node
 	 * @return boolean within the element tags
 	 */
-	bool getValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	bool getValueAsBool(const TiXmlElement* element) const;
     
     
     /**
@@ -155,7 +172,7 @@
      * @param value Der zu setzende Integer
 	 * @return the DOM element node
 	 */
-	void setValueAsInteger(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, int value) const;
+	void setValueAsInteger(TiXmlElement* element, int value) const;
 
     
     /**
@@ -164,7 +181,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-	int getValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	int getValueAsInteger(const TiXmlElement* element) const;
 
     /**
 	 * Get the text value of an element node and parse it into a real number
@@ -172,7 +189,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-    Ogre::Real getValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    Ogre::Real getValueAsReal(const TiXmlElement* element) const;
 
     /**
 	 * Convert an integer pair into a string and sets it as the text of a DOM element
@@ -181,7 +198,7 @@
      * @param value the integer pair
 	 * @return the DOM element node
 	 */
-    void setValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, IntPair value) const;
+    void setValueAsIntegerPair(TiXmlElement* element, IntPair value) const;
 
     /**
 	 * Get the text value of an element node and parse it into an integer pair
@@ -189,7 +206,7 @@
 	 * @param element the DOM element node
 	 * @return pair within the element tags
 	 */
-    IntPair getValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    IntPair getValueAsIntegerPair(const TiXmlElement* element) const;
 
     /**
 	 * Convert an integer triple into a string and set is as the text of a DOM element
@@ -198,7 +215,7 @@
      * @param value the integer triple
 	 * @return the DOM element node
 	 */
-    void setValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Tripel<int> value) const;
+    void setValueAsIntegerTriple(TiXmlElement* element, Tripel<int> value) const;
 
     /**
 	 * Get the text value of an element node and parse it into an integer triple
@@ -206,7 +223,7 @@
 	 * @param element the DOM element node
 	 * @return triple within the element tags
 	 */
-    Tripel<int> getValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    Tripel<int> getValueAsIntegerTriple(const TiXmlElement* element) const;
 	
     /**
      * Convert a vector3 to an xml tag
@@ -215,7 +232,7 @@
      * @param value The vector input
 	 * @return The DOM element
 	 */
-    void setValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Vector3 value) const;
+    void setValueAsVector3(TiXmlElement* element, Ogre::Vector3 value) const;
 
     /**
 	 * Processes an element node of shape <any_node_name x="0" y="0" z="0"/>
@@ -224,7 +241,7 @@
 	 * @param element The DOM element
 	 * @return the vector
 	 */
-	Ogre::Vector3 getValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	Ogre::Vector3 getValueAsVector3(const TiXmlElement* element) const;
 
     /**
      * Convert a quaternion to an xml tag
@@ -233,7 +250,7 @@
      * @param value The quaternion input
 	 * @return The DOM element
 	 */
-    void setValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Quaternion value) const;
+    void setValueAsQuaternion(TiXmlElement* element, Ogre::Quaternion value) const;
 
     /**
 	 * Processes an element node of shape <any_node_name x="0" y="0" z="0" w="1"/>
@@ -242,7 +259,7 @@
 	 * @param element The DOM element
 	 * @return the quaternion
 	 */
-    Ogre::Quaternion getValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    Ogre::Quaternion getValueAsQuaternion(const TiXmlElement* element) const;
 
 	
     /**
@@ -252,7 +269,7 @@
 	 * @param name Name des Attributes
 	 * @return <code>true</code>, wenn das Attribut an diesem Element existiert, sonst <code>false</code>
 	 */
-	bool hasAttribute(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	bool hasAttribute(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Setzt den Wert von einem Attribut eines Elementes
@@ -262,7 +279,7 @@
      * @param value Wert der gesetzt werden muss
 	 * @return <code>true</code>, wenn das Attribut an diesem Element existiert, sonst <code>false</code>
 	 */
-    void setAttribute(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const char* const value) const;
+    void setAttribute(TiXmlElement* element, const char* const name, const char* const value) const;
 
     /**
 	 * Checks whether a DOMNode has a certain name
@@ -271,7 +288,7 @@
 	 * @param name the name to check
 	 * @return <code>true</code>, if the DOM node the name <code>name</code>, <code>false</code> otherwise
 	 */
-	bool hasNodeName(XERCES_CPP_NAMESPACE::DOMNode* node, const char* const name) const;
+	bool hasNodeName(const TiXmlNode* node, const char* const name) const;
 
     
     /**
@@ -282,7 +299,7 @@
      * @param value das zu setzende Integer
 	 * @return the DOM element node
 	 */
-	void setAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, int value) const;
+	void setAttributeValueAsInteger(TiXmlElement* element, const char* const name, int value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -292,7 +309,7 @@
 	 * @param name Name des Attributes
      * @return Zahlenwert des Attributes
 	 */
-	int getAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	int getAttributeValueAsInteger(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Converts a 64 bit integer (long long) into a string and sets it as the text of a DOM element attribute
@@ -300,7 +317,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-	void setAttributeValueAsInt64(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, RL_LONGLONG value) const;
+	void setAttributeValueAsInt64(TiXmlElement* element, const char* const name, RL_LONGLONG value) const;
 
     /**
 	 * Gets the text value of an element attribute and parse it into a 64 bit integer (long long) 
@@ -308,7 +325,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-	RL_LONGLONG getAttributeValueAsInt64(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	RL_LONGLONG getAttributeValueAsInt64(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Wandelt eine Ganzzahldubel in einen Text um und setzt diesen als Attribut 
@@ -318,7 +335,7 @@
      * @param value das zu setzende IntegerPair
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, IntPair value) const;
+    void setAttributeValueAsIntegerPair(TiXmlElement* element, const char* const name, IntPair value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -328,7 +345,7 @@
 	 * @param name Name des Attributes
      * @return Zahlendubel des Attributes
 	 */
-    IntPair getAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    IntPair getAttributeValueAsIntegerPair(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Wandelt eine Ganzzahltripel in einen Text um und setzt diesen als Attribut 
@@ -338,7 +355,7 @@
      * @param value das zu setzende Tripel<int>
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Tripel<int> value) const;
+    void setAttributeValueAsIntegerTriple(TiXmlElement* element, const char* const name, Tripel<int> value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -348,7 +365,7 @@
 	 * @param name Name des Attributes
      * @return Zahlentripel des Attributes
 	 */
-    Tripel<int> getAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    Tripel<int> getAttributeValueAsIntegerTriple(const TiXmlElement* element, const char* const name) const;
 	
 	
     /**
@@ -359,7 +376,7 @@
      * @param value das zu setzende Vector3
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Ogre::Vector3 value) const;
+    void setAttributeValueAsVector3(TiXmlElement* element, const char* const name, Ogre::Vector3 value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -369,7 +386,7 @@
 	 * @param name Name des Attributes
      * @return Vector3 des Attributes
 	 */
-    Ogre::Vector3 getAttributeValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    Ogre::Vector3 getAttributeValueAsVector3(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Wandelt eine Quaternion in einen Text um und setzt diesen als Attribut 
@@ -379,7 +396,7 @@
      * @param value das zu setzende Quaternion
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Ogre::Quaternion value) const;
+    void setAttributeValueAsQuaternion(TiXmlElement* element, const char* const name, Ogre::Quaternion value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -389,7 +406,7 @@
 	 * @param name Name des Attributes
      * @return Quaternion des Attributes
 	 */
-    Ogre::Quaternion getAttributeValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    Ogre::Quaternion getAttributeValueAsQuaternion(const TiXmlElement* element, const char* const name) const;
     
 
     /**
@@ -400,7 +417,7 @@
 	 * @param value das zu setzende CeGuiString
 	 * @return the DOM element node
 	 */	
-	void setAttributeValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const CeGuiString &value) const;
+	void setAttributeValueAsString(TiXmlElement* element, const char* const name, const CeGuiString &value) const;
     
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu einem CeGuiString
@@ -409,7 +426,7 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als CeGuiString
 	 */	
-	CeGuiString getAttributeValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	CeGuiString getAttributeValueAsString(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Setzt den Text eines DOMElement-Attributes
@@ -419,7 +436,7 @@
 	 * @param value der zu setzende std::string
 	 * @return the DOM element node
 	 */	
-    void setAttributeValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const std::string &value) const;
+    void setAttributeValueAsStdString(TiXmlElement* element, const char* const name, const std::string &value) const;
 
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu einem std::string
@@ -428,18 +445,9 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als std::string
 	 */	
-    std::string getAttributeValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    std::string getAttributeValueAsStdString(const TiXmlElement* element, const char* const name) const;
 	
     /**
-	 * Ermittelt den Text eines SAX Element-Attributes und konvertiert ihn zu einem CeGuiString
-	 *
-	 * @param element Liste aller Attribute des aktuellen Elementes
-	 * @param name Name des Attributes
-	 * @return Konvertierter Text als CeGuiString
-	 */
-	CeGuiString getAttributeValueAsString(const XERCES_CPP_NAMESPACE::Attributes& attributes, const char* const name) const;
-
-    /**
 	 * Setzt den Text eines DOMElement-Attributes
 	 * 
 	 * @param element the DOM element node
@@ -447,7 +455,7 @@
 	 * @param value der zu setzende boolean
 	 * @return the DOM element node
 	 */	
-	void setAttributeValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, bool value) const;
+	void setAttributeValueAsBool(TiXmlElement* element, const char* const name, bool value) const;
 
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und interpretier ihn als bool
@@ -456,7 +464,7 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als bool
 	 */	
-	bool getAttributeValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	bool getAttributeValueAsBool(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Setzt den Text eines DOMElement-Attributes
@@ -466,7 +474,7 @@
 	 * @param value der zu setzende Real Wert
 	 * @return the DOM element node
 	 */	
-    void setAttributeValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Ogre::Real value) const;
+    void setAttributeValueAsReal(TiXmlElement* element, const char* const name, Ogre::Real value) const;
 
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu Ogre::Real
@@ -475,148 +483,20 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als Ogre::Real
 	 */	
-	Ogre::Real getAttributeValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	Ogre::Real getAttributeValueAsReal(const TiXmlElement* element, const char* const name) const;
 
 
-	/**
-	 * Initialisiert den XML<->UTF-8 Transcoder, 
-	 * davor muss XMLPlatformUtils::Initialize() aufgerufen worden sein
-	 */
-	void initializeTranscoder();
-
-	/**
-	 * Konvertiert einen Xerces-XMLCh* in eine CeGuiString
-	 * Intern wird eine Konvertierung in utf8* vorgenommen,
-	 * wobei man sich hier um das nachtr?gliche aufr?umen 
-	 * nicht mehr zu k?mmern braucht.
-	 * 
-	 * @param string16 Der zu konvertierende Xerces-XMLCh*
-	 * @return Konvertierter Text als CeGuiString
-	 * @see transcodeToUtf8(const XMLCh* const string16) const;
-	 */
-	CeGuiString transcodeToString(const XMLCh* const string16) const;
-
-	std::string transcodeToStdString(const XMLCh* const string16) const;
-
-    XERCES_CPP_NAMESPACE::DOMDocument* loadDocument(
+	TiXmlDocument* loadDocument(
         const Ogre::String& resourceName, const Ogre::String& resourceGroup = "");
-    XERCES_CPP_NAMESPACE::DOMDocument* loadDocument(
+	TiXmlDocument* loadDocument(
         const Ogre::DataStreamPtr& stream);
 
-    void initializeXml();
-    void shutdownXml();
-
-        virtual void warning(const XERCES_CPP_NAMESPACE::SAXParseException& exc);
-        virtual void error(const XERCES_CPP_NAMESPACE::SAXParseException& exc);
-        virtual void fatalError(const XERCES_CPP_NAMESPACE::SAXParseException& exc);
-        virtual void resetErrors();
-
 protected:
-	static XERCES_CPP_NAMESPACE::XMLTranscoder* sTranscoder;
-	static XERCES_CPP_NAMESPACE::XMLTransService::Codes sFailCode;
+    std::string mOpenXmlFileName;
 
-        std::string toString( const std::string& type,
-                              const XERCES_CPP_NAMESPACE::SAXParseException& exc ) const;
-        
-        std::string mOpenXmlFileName;
-        XERCES_CPP_NAMESPACE::XercesDOMParser *mOpenParser;
-
-	/**
-	 * Konvertiert ein Xerces-XMLCh* in einen UTF-8-String
-	 * Vor Benutzung muss initializeTranscoder() aufgerufen werden
-	 *
-	 * @param string16 Der zu konvertierende Xerces-XMLCh*
-	 * @return Konvertierter Text als utf8* (muss selbst gel?scht werden)
-	 * @see initializeTranscoder()
-	 */
-	CEGUI::utf8* transcodeToUtf8(const XMLCh* const string16) const;
-};
-
-class _RlCommonExport AutoXMLCh
-{
-public:
-    AutoXMLCh() : mData(0) { }
-
-    AutoXMLCh(const char* rhs) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(rhs);
-    }
-
-    AutoXMLCh(const AutoXMLCh& rhs) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-    }
-
-    ~AutoXMLCh()
-    {
-        XERCES_CPP_NAMESPACE::XMLString::release(&mData);
-    }
-
-    const AutoXMLCh& operator=(const AutoXMLCh& rhs)
-    {
-        if (mData != NULL)
-        {
-            XERCES_CPP_NAMESPACE::XMLString::release(&mData);
-        }
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-        return *this;
-    }
-
-    const AutoXMLCh& operator=(const char* rhs)
-    {
-        if (mData != NULL)
-        {
-            XERCES_CPP_NAMESPACE::XMLString::release(&mData);
-        }
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(rhs);
-        return *this;
-    }
-
-    XMLCh* data() const { return mData; }
 private:
-    XMLCh* mData;
-};
+    TiXmlDocument* parseToXmlDocument(const char* content) const;
 
-class _RlCommonExport AutoChar
-{
-public:
-    AutoChar() : mData(0) { }
-
-    AutoChar(const XMLCh* str) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(str);
-    }
-
-    AutoChar(const AutoChar& rhs) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-    }
-
-    ~AutoChar()
-    {
-        XERCES_CPP_NAMESPACE::XMLString::release(&mData);
-    }
-
-    const AutoChar& operator=(const AutoChar& rhs)
-    {
-        XERCES_CPP_NAMESPACE::XMLString::release(&mData);
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-        return *this;
-    }
-
-    const AutoChar& operator=(XMLCh* rhs)
-    {
-        if (mData != NULL)
-        {
-            XERCES_CPP_NAMESPACE::XMLString::release(&mData);
-        }
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(rhs);
-        return *this;
-    }
-
-    char* data() const { return mData; }
-private:
-    char* mData;
 };
 
 }

Modified: rl/trunk/engine/common/include/XmlPropertyReader.h
===================================================================
--- rl/trunk/engine/common/include/XmlPropertyReader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlPropertyReader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -19,8 +19,7 @@
 
 #include "CommonPrerequisites.h"
 
-#include <xercesc/dom/DOMAttr.hpp>
-#include <xercesc/dom/DOMElement.hpp>
+#include <tinyxml.h>
 
 #include "Properties.h"
 #include "XmlProcessor.h"
@@ -33,7 +32,7 @@
     typedef std::pair<Ogre::String, Property> PropertyEntry;
 
     class _RlCommonExport XmlPropertyReader
-         : public XmlProcessor
+         : public XmlProcessor, public TiXmlVisitor
     {
     public:
         XmlPropertyReader();
@@ -42,14 +41,16 @@
         void parseGameObjectFile(Ogre::DataStreamPtr &stream, const Ogre::String &groupName);
         PropertyRecordVector getPropertyRecords();
 
-        PropertyEntry processProperty(XERCES_CPP_NAMESPACE::DOMElement* domElem) const;
-		PropertyEntry processProperty(XERCES_CPP_NAMESPACE::DOMAttr* domAttr) const;
+        PropertyEntry processProperty(const TiXmlElement* domElem) const;
+		PropertyEntry processProperty(const TiXmlAttribute* domAttr) const;
 
-        virtual PropertyRecordPtr getPropertiesAsRecord(XERCES_CPP_NAMESPACE::DOMElement* parent);
+        virtual PropertyRecordPtr getPropertiesAsRecord(const TiXmlElement* parent);
+        virtual bool VisitEnter(const TiXmlElement &element, const TiXmlAttribute *firstAttribute);
     private:
         PropertyRecordVector mPropertyRecords;
 
         Property getProperty(const Ogre::String& key, const CeGuiString& value);
+        void processGameObjectClassNode(const TiXmlElement &element);
     };
 } // namespace rl
 

Modified: rl/trunk/engine/common/include/XmlPropertyWriter.h
===================================================================
--- rl/trunk/engine/common/include/XmlPropertyWriter.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlPropertyWriter.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -19,9 +19,7 @@
 
 #include "CommonPrerequisites.h"
 
-#include <xercesc/dom/DOM.hpp>
-#include <xercesc/dom/DOMAttr.hpp>
-#include <xercesc/dom/DOMElement.hpp>
+#include <tinyxml.h>
 
 #include "Properties.h"
 #include "XmlProcessor.h"
@@ -40,25 +38,22 @@
         XmlPropertyWriter();
         virtual ~XmlPropertyWriter();
 
-        XERCES_CPP_NAMESPACE::DOMDocument* getDocument();
+        TiXmlDocument* getDocument();
 
         PropertyRecordPtr getPropertyRecords();
         void setPropertyRecords(PropertyRecordVector sets);
         void addPropertyRecord(PropertyRecordPtr set);
 
-        XERCES_CPP_NAMESPACE::DOMElement* processProperty(XERCES_CPP_NAMESPACE::DOMElement* parent, const PropertyEntry& entry);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyRecord(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, const PropertyRecord& set);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyArray(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, const PropertyArray& vector);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyMap(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, const PropertyMap& map);
+        TiXmlElement* processProperty(TiXmlElement* parent, const PropertyEntry& entry);
+        TiXmlElement* processPropertyRecord(TiXmlElement* parent, const char* const name, const PropertyRecord& set);
+        TiXmlElement* processPropertyArray(TiXmlElement* parent, const char* const name, const PropertyArray& vector);
+        TiXmlElement* processPropertyMap(TiXmlElement* parent, const char* const name, const PropertyMap& map);
 
-        void writeEachPropertyToElem(XERCES_CPP_NAMESPACE::DOMElement* parent, const PropertyMap &map);
+        void writeEachPropertyToElem(TiXmlElement* parent, const PropertyMap &map);
     protected:
         PropertyRecordVector mPropertyRecords;
 
-        XERCES_CPP_NAMESPACE::DOMDocument* mDocument;
-        XERCES_CPP_NAMESPACE::DOMImplementation* mImplementation;
-        XERCES_CPP_NAMESPACE::DOMWriter* mWriter;
-        XERCES_CPP_NAMESPACE::XMLFormatTarget* mTarget;
+        TiXmlDocument* mDocument;
 
         Property getProperty(const Ogre::String& key, const CeGuiString& value);
     };

Modified: rl/trunk/engine/common/include/XmlResource.h
===================================================================
--- rl/trunk/engine/common/include/XmlResource.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlResource.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,13 +17,6 @@
 #ifndef __XmlResource_H__
 #define __XmlResource_H__
 
-#pragma warning (push)
-#pragma warning (disable : 4244)
-#include <xercesc/framework/MemBufInputSource.hpp>
-#include <xercesc/parsers/XercesDOMParser.hpp>
-#include <xercesc/sax2/SAX2XMLReader.hpp>
-#pragma warning (pop)
-
 #include "CommonPrerequisites.h"
 #include "XmlProcessor.h"
 
@@ -43,8 +36,7 @@
 
         virtual ~XmlResource();
 
-        bool parseBy(XERCES_CPP_NAMESPACE::XercesDOMParser* parser, XmlProcessor* const proc = NULL);
-        bool parseBy(XERCES_CPP_NAMESPACE::SAX2XMLReader* parser, XmlProcessor* const proc = NULL);
+        const char* getContent();
 
     protected:
         size_t calculateSize() const;
@@ -53,8 +45,7 @@
         void unloadImpl();
 
     private:
-        XERCES_CPP_NAMESPACE::MemBufInputSource* mXmlBuffer;
-        XMLByte* mCharBuffer;
+        char* mCharBuffer;
     };
 
     class _RlCommonExport XmlPtr :

Deleted: rl/trunk/engine/common/src/OgreXercesInput.cpp
===================================================================
--- rl/trunk/engine/common/src/OgreXercesInput.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/OgreXercesInput.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,51 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "stdinc.h" //precompiled header
-
-#include "OgreXercesInput.h"
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace Ogre;
-
-namespace rl {
-
-    OgreInputSource::OgreInputSource(const Ogre::DataStreamPtr& stream)
-    : mStream(stream)
-    {
-    }
-
-    BinInputStream* OgreInputSource::makeStream() const
-    {
-        return new OgreBinInputStream(mStream);
-    }
-
-    OgreBinInputStream::OgreBinInputStream(const Ogre::DataStreamPtr& stream)
-    : mStream(stream)
-    {
-    }
-
-    unsigned int OgreBinInputStream::curPos() const
-    {
-        return mStream->tell();
-    }
-
-    unsigned int OgreBinInputStream::readBytes(XMLByte* const toFill, const unsigned int maxToRead)
-    {
-        return mStream->read(toFill, maxToRead);
-    }
-
-}

Deleted: rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,38 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "stdinc.h" //precompiled header
-
-#include "WriteableDataStreamFormatTarget.h"
-
-namespace rl
-{
-    WriteableDataStreamFormatTarget::WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream)
-    {
-        mStream = stream;
-    }
-
-    void WriteableDataStreamFormatTarget::writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter)
-    {
-        mStream->write((char*)toWrite, count);
-    }
-
-    void WriteableDataStreamFormatTarget::flush ()
-    {
-        mStream->flush();
-    }
-}
-

Modified: rl/trunk/engine/common/src/XmlProcessor.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,136 +17,171 @@
 #include "stdinc.h" //precompiled header
 
 #include <CEGUIPropertyHelper.h>
-#include <xercesc/dom/DOM.hpp>
-#include <xercesc/parsers/XercesDOMParser.hpp>
-#include <xercesc/util/PlatformUtils.hpp>
-#include <xercesc/sax/SAXParseException.hpp>
 
 #include "XmlProcessor.h"
 
 #include "Exception.h"
 #include "Logger.h"
-#include "OgreXercesInput.h"
 #include "XmlResource.h"
 #include "XmlResourceManager.h"
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 using CEGUI::utf8;
 
 namespace rl 
 {
 
-XERCES_CPP_NAMESPACE::XMLTranscoder* XmlProcessor::sTranscoder = NULL;
-XERCES_CPP_NAMESPACE::XMLTransService::Codes XmlProcessor::sFailCode = XERCES_CPP_NAMESPACE::XMLTransService::Ok;
-
-DOMElement* XmlProcessor::appendChildElement(DOMDocument* doc, DOMElement* parent, const char* const name) const
+TiXmlElement* XmlProcessor::appendChildElement(TiXmlElement* parent, const char* const name) const
 {
     RlAssert(parent != NULL, "XmlProcessor::appendChildElement: parent must not be NULL" );
 
-    DOMElement* child = doc->createElement(XMLString::transcode(name));
-    parent->appendChild(child);
+    TiXmlElement* child = new TiXmlElement(name);
+    parent->LinkEndChild(child);
     return child;
 }
 
-DOMElement* XmlProcessor::getChildNamed(DOMElement* parent, const char* const name) const
+TiXmlElement* XmlProcessor::appendChildElement(TiXmlDocument* parent, const char* const name) const
 {
+    RlAssert(parent != NULL, "XmlProcessor::appendChildElement: parent must not be NULL" );
+
+	return appendChildElement(parent->RootElement(), name);
+}
+
+
+const TiXmlElement* XmlProcessor::getChildNamed(const TiXmlElement* parent, const char* const name) const
+{
     RlAssert(parent != NULL, "XmlProcessor::getChildNamed: parent must not be NULL" );
 
-	AutoXMLCh nameXml = name;
+	for (const TiXmlNode* cur = parent->FirstChild(); cur; cur = cur->NextSibling())
+	{
+		if (cur->Type() == TiXmlNode::ELEMENT && cur->Value() == name)
+		{
+			return cur->ToElement();
+		}
+	}
 
-	DOMElement* rval = 0;
-	
-	for (DOMNode* cur = parent->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+	return NULL;
+}
+
+TiXmlElement* XmlProcessor::getChildNamed(TiXmlElement* parent, const char* const name) const
+{
+    RlAssert(parent != NULL, "XmlProcessor::getChildNamed: parent must not be NULL" );
+
+	for (TiXmlNode* cur = parent->FirstChild(); cur; cur = cur->NextSibling())
 	{
-		if (cur->getNodeType() == DOMNode::ELEMENT_NODE &&
-			XMLString::compareString(cur->getNodeName(), nameXml.data()) == 0)
+		if (cur->Type() == TiXmlNode::ELEMENT && cur->Value() == name)
 		{
-			rval = static_cast<DOMElement*>(cur);
-			break;
+			return cur->ToElement();
 		}
 	}
 
-	return rval;
+	return NULL;
 }
 
-void XmlProcessor::setValueAsString(DOMDocument* doc, DOMElement *element, const CeGuiString &value) const
+class XmlElementFinder : public TiXmlVisitor
 {
+public:
+	XmlElementFinder(const char* const tagName)
+		: mResult(),
+		  mTagName(tagName)
+	{
+	}
+
+	virtual bool VisitEnter(const TiXmlElement &element, const TiXmlAttribute *firstAttribute)
+	{
+		if (element.ValueTStr() == mTagName)
+		{
+			mResult.push_back(&element);
+		}
+		return true;
+	}
+
+	XmlElementList getResult() const
+	{
+		return mResult;
+	}
+
+private:
+	XmlElementList mResult;
+	const char* mTagName;
+};
+
+XmlElementList XmlProcessor::getElementsByTagName(const TiXmlElement* parent, const char* const name) const
+{
+}
+
+
+XmlElementList XmlProcessor::getElementsByTagName(const TiXmlDocument* parent, const char* const name) const
+{
+	return getElementsByTagName(parent->RootElement(), name);
+}
+
+
+void XmlProcessor::setValueAsString(TiXmlElement *element, const CeGuiString &value) const
+{
     RlAssert(element != NULL, "XmlProcessor::setValueAsString: Element must not be NULL");
-    DOMText* text = doc->createTextNode(XMLString::transcode(value.c_str()));
-    element->appendChild(text);
+    TiXmlText* text = new TiXmlText(value.c_str());
+    element->LinkEndChild(text);
 }
 
-CeGuiString XmlProcessor::getValueAsString(DOMElement* element) const
+CeGuiString XmlProcessor::getValueAsString(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsString: Element must not be NULL");
-	return transcodeToString( element->getFirstChild()->getNodeValue() );
+	return element->FirstChild()->Value();
 }
 
-std::string XmlProcessor::getValueAsStdString(DOMElement* element) const
+std::string XmlProcessor::getValueAsStdString(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsStdString: Element must not be NULL");
-	return transcodeToStdString( element->getFirstChild()->getNodeValue() );
+	return element->FirstChild()->Value();
 }
 
-void XmlProcessor::setValueAsUtf8(DOMDocument* doc, DOMElement* element, utf8* value) const
+void XmlProcessor::setValueAsUtf8(TiXmlElement* element, utf8* value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsUtf8: Element must not be NULL");
     CeGuiString temp(value);
-    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
-    element->appendChild(text);
+    element->LinkEndChild(new TiXmlText(temp.c_str()));
 }
 
-utf8* XmlProcessor::getValueAsUtf8(DOMElement* element) const
+const utf8* XmlProcessor::getValueAsUtf8(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsUtf8: Element must not be NULL");
-	return XmlProcessor::transcodeToUtf8(element->getFirstChild()->getNodeValue());
+	return reinterpret_cast<const utf8*>(element->FirstChild()->Value());
 }
 
-bool XmlProcessor::hasAttribute(DOMElement* element,const char* const name) const
+bool XmlProcessor::hasAttribute(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::hasAttribute: Element must not be NULL");
-    AutoXMLCh attrName(name);
-    bool rVal = element->hasAttribute(attrName.data());
-    return rVal;
+    return element->Attribute(name);
 }
 
-bool XmlProcessor::hasNodeName(DOMNode* node, const char* const name) const
+bool XmlProcessor::hasNodeName(const TiXmlNode* node, const char* const name) const
 {
     RlAssert(node != NULL, "XmlProcessor::hasNodeName: node must not be NULL");
-    XMLCh* nodeName = XMLString::transcode(name);
-    int ival = XMLString::compareString(node->getNodeName(), nodeName);
-    bool rVal = (0 == ival);
-    XMLString::release(&nodeName);
-    return rVal;
+    return node->ValueTStr() == name;
 }
 
-void XmlProcessor::setAttribute(DOMElement* element, const char* const name, const char* const value) const
+void XmlProcessor::setAttribute(TiXmlElement* element, const char* const name, const char* const value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttribute: Element must not be NULL");
-    AutoXMLCh attrName(name);
-    element->setAttribute(attrName.data(), XMLString::transcode(value));
+    element->SetAttribute(name, value);
 }
 
-void XmlProcessor::setAttributeValueAsInteger(DOMElement *element, const char *const name, int value) const
+void XmlProcessor::setAttributeValueAsInteger(TiXmlElement *element, const char *const name, int value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsInteger: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element->SetAttribute(name, Ogre::StringConverter::toString(value).c_str());
 }
 
-int XmlProcessor::getAttributeValueAsInteger(DOMElement* element,const char* const name) const
+int XmlProcessor::getAttributeValueAsInteger(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsInteger: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    return XMLString::parseInt(element->getAttribute(attrName.data()));
+    return Ogre::StringConverter::parseInt(element->Attribute(name));
 }
 
-void XmlProcessor::setAttributeValueAsInt64(DOMElement *element, const char *const name, RL_LONGLONG value) const
+void XmlProcessor::setAttributeValueAsInt64(TiXmlElement *element, const char *const name, RL_LONGLONG value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsInt64: Element must not be NULL");
-	AutoXMLCh attrName(name);
     
     bool negative = false;
     if (value < 0)
@@ -155,7 +190,7 @@
         negative = true;
     }
 
-    CeGuiString temp("");
+    std::string temp("");
     RL_LONGLONG divider = 1000000000;
     while (value > divider)
     {
@@ -169,15 +204,13 @@
         temp = "-" + temp;
     }
     
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element->SetAttribute(name, temp.c_str());
 }
 
-RL_LONGLONG XmlProcessor::getAttributeValueAsInt64(DOMElement* element,const char* const name) const
+RL_LONGLONG XmlProcessor::getAttributeValueAsInt64(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsInteger: Element must not be NULL");
-	AutoXMLCh attrName(name);    
-	const XMLCh* attribute = element->getAttribute(attrName.data());
-    Ogre::String value = transcodeToStdString(attribute);
+	Ogre::String value = element->Attribute(name);
 
     RL_LONGLONG sign = 1;
     if (value[0] == '-')
@@ -202,21 +235,17 @@
 	return rVal;
 }
 
-void XmlProcessor::setAttributeValueAsIntegerPair(DOMElement* element, const char* const name, IntPair value) const
+void XmlProcessor::setAttributeValueAsIntegerPair(TiXmlElement* element, const char* const name, IntPair value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsIntegerPair: Element must not be NULL");
-	AutoXMLCh attrName(name);
     CeGuiString temp = Ogre::StringConverter::toString(value.first) + "," + Ogre::StringConverter::toString(value.second);
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element->SetAttribute(name, temp.c_str());
 }
 
-IntPair XmlProcessor::getAttributeValueAsIntegerPair(DOMElement* element, const char* const name) const
+IntPair XmlProcessor::getAttributeValueAsIntegerPair(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsIntegerPair: Element must not be NULL");
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element->getAttribute(attrName.data());
-	
-    CeGuiString value = transcodeToString(attribute);
+    CeGuiString value = getAttributeValueAsString(element, name);
     CeGuiString::size_type comma1 = value.find(",");
 
 	std::pair<int,int> intPairVal = std::make_pair(0, 0);
@@ -230,22 +259,18 @@
     return intPairVal;
 }
 
-void XmlProcessor::setAttributeValueAsIntegerTriple(DOMElement *element, const char *const name, Tripel<int> value) const
+void XmlProcessor::setAttributeValueAsIntegerTriple(TiXmlElement *element, const char *const name, Tripel<int> value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsIntegerTriple: Element must not be NULL");
-	AutoXMLCh attrName(name);
     CeGuiString temp = Ogre::StringConverter::toString(value.first) + "," + Ogre::StringConverter::toString(value.second) + "," + Ogre::StringConverter::toString(value.third);
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element->SetAttribute(name, temp.c_str());
 }
 
-Tripel<int> XmlProcessor::getAttributeValueAsIntegerTriple(DOMElement* element, const char* const name) const
+Tripel<int> XmlProcessor::getAttributeValueAsIntegerTriple(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsIntegerTriple: Element must not be NULL");
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element->getAttribute(attrName.data());
+    CeGuiString value = getAttributeValueAsString(element, name);
 
-    CeGuiString value = transcodeToString(attribute);
-
     CeGuiString::size_type comma1 = value.find(",");
     CeGuiString::size_type comma2 = value.find(",", comma1 + 1);
 
@@ -260,129 +285,94 @@
     return intTripel;
 }
 
-void XmlProcessor::setAttributeValueAsReal(DOMElement *element, const char *const name, Ogre::Real value) const
+void XmlProcessor::setAttributeValueAsReal(TiXmlElement *element, const char *const name, Ogre::Real value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsReal: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element->SetAttribute(name, Ogre::StringConverter::toString(value).c_str());
 }
 
-Ogre::Real XmlProcessor::getAttributeValueAsReal(DOMElement* element,const char* const name) const
+Ogre::Real XmlProcessor::getAttributeValueAsReal(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsReal: Element must not be NULL");
-	AutoXMLCh attrName(name);
-	Ogre::Real rVal = Ogre::StringConverter::parseReal(
-		transcodeToString(element->getAttribute(attrName.data())).c_str() );
+	Ogre::Real rVal = Ogre::StringConverter::parseReal(getAttributeValueAsStdString(element, name));
 	return rVal;
 }
 
-void XmlProcessor::setAttributeValueAsString(DOMElement *element, const char *const name, const CeGuiString &value) const
+void XmlProcessor::setAttributeValueAsString(TiXmlElement *element, const char *const name, const CeGuiString &value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsString: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    element->setAttribute(attrName.data(), XMLString::transcode(value.c_str()));
+    element->SetAttribute(name, value.c_str());
 }
 
-CeGuiString XmlProcessor::getAttributeValueAsString(DOMElement* element, const char* const name) const
+CeGuiString XmlProcessor::getAttributeValueAsString(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsString: Element must not be NULL");
-	AutoXMLCh attrName(name);
-	CeGuiString rVal(transcodeToString(element->getAttribute(attrName.data())));
+	CeGuiString rVal(element->Attribute(name));
 	return rVal;
 }
 
-CeGuiString XmlProcessor::getAttributeValueAsString(const XERCES_CPP_NAMESPACE::Attributes& attributes, const char* const name) const
+void XmlProcessor::setAttributeValueAsStdString(TiXmlElement *element, const char *const name, const std::string &value) const
 {
-	AutoXMLCh attrName(name);
-	const XMLCh* valStr = attributes.getValue(attrName.data());
-	if (valStr != NULL)
-	{
-		return transcodeToString(valStr);
-	}
-	return CeGuiString();
-}
-
-void XmlProcessor::setAttributeValueAsStdString(DOMElement *element, const char *const name, const std::string &value) const
-{
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsStdString: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    element->setAttribute(attrName.data(), XMLString::transcode(value.c_str()));
+    element->SetAttribute(name, value.c_str());
 }
 
-std::string XmlProcessor::getAttributeValueAsStdString(DOMElement* element, const char* const name) const
+std::string XmlProcessor::getAttributeValueAsStdString(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsStdString: Element must not be NULL");
-	AutoXMLCh attrName(name);
-	std::string rVal(transcodeToStdString(element->getAttribute(attrName.data())));
-	return rVal;
+	return element->Attribute(name);
 }
 
-void XmlProcessor::setAttributeValueAsBool(DOMElement *element, const char *const name, bool value) const
+void XmlProcessor::setAttributeValueAsBool(TiXmlElement *element, const char *const name, bool value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsBool: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element->SetAttribute(name, Ogre::StringConverter::toString(value).c_str());
 }
 
-bool XmlProcessor::getAttributeValueAsBool(DOMElement* element,const char* const name) const
+bool XmlProcessor::getAttributeValueAsBool(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsBool: Element must not be NULL");
-	if ( XMLString::compareIString(getAttributeValueAsString(element, name).c_str(),"true") == 0  )
-		return true;
-	else
-		return false;
+	return getAttributeValueAsStdString(element, name) == "true";
 }
 
-void XmlProcessor::setValueAsBool(DOMDocument* doc, DOMElement *element, bool value) const
+void XmlProcessor::setValueAsBool(TiXmlElement *element, bool value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsBool: Element must not be NULL");
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
-    element->appendChild(text);
+    element->LinkEndChild(new TiXmlText(Ogre::StringConverter::toString(value).c_str()));
 }
 
-bool XmlProcessor::getValueAsBool(DOMElement* element) const
+bool XmlProcessor::getValueAsBool(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsBool: Element must not be NULL");
-	
-    if ( XMLString::compareIString(getValueAsString(element).c_str(),"true") == 0  )
-		return true;
-	else
-		return false;
+    return getValueAsStdString(element) == "true";
 }
 
-void XmlProcessor::setValueAsInteger(DOMDocument* doc, DOMElement *element, int value) const
+void XmlProcessor::setValueAsInteger(TiXmlElement *element, int value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsInteger: Element must not be NULL");
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
-    element->appendChild(text);
+    element->LinkEndChild(new TiXmlText(Ogre::StringConverter::toString(value).c_str()));
 }
 
-int XmlProcessor::getValueAsInteger(DOMElement* element) const
+int XmlProcessor::getValueAsInteger(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsInteger: Element must not be NULL");
-	return XMLString::parseInt(element->getFirstChild()->getNodeValue());
+	return Ogre::StringConverter::parseInt(element->FirstChild()->Value());
 }
 
-Ogre::Real XmlProcessor::getValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element) const
+Ogre::Real XmlProcessor::getValueAsReal(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsInteger: Element must not be NULL");
-    return Ogre::StringConverter::parseReal(
-        transcodeToString(element->getFirstChild()->getNodeValue()).c_str());
+    return Ogre::StringConverter::parseReal(getValueAsStdString(element));
 }
 
-void XmlProcessor::setValueAsIntegerPair(DOMDocument *doc, DOMElement *element, IntPair value) const
+void XmlProcessor::setValueAsIntegerPair(TiXmlElement *element, IntPair value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsIntegerPair: Element must not be NULL");
     CeGuiString temp = CEGUI::PropertyHelper::intToString(value.first) + ',' + CEGUI::PropertyHelper::intToString(value.second);
-    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
-    element->appendChild(text);
+    element->LinkEndChild(new TiXmlText(temp.c_str()));
 }
 
-IntPair XmlProcessor::getValueAsIntegerPair(DOMElement* element) const
+IntPair XmlProcessor::getValueAsIntegerPair(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsIntegerPair: Element must not be NULL");
     CeGuiString value = getValueAsString(element);
@@ -398,16 +388,15 @@
     return intPairVal;
 }
 
-void XmlProcessor::setValueAsIntegerTriple(DOMDocument *doc, DOMElement *element, Tripel<int> value) const
+void XmlProcessor::setValueAsIntegerTriple(TiXmlElement *element, Tripel<int> value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsIntegerTriple: Element must not be NULL");
     RlAssert(element != NULL, "XmlProcessor::setValueAsIntegerPair: Element must not be NULL");
     CeGuiString temp = CEGUI::PropertyHelper::intToString(value.first) + ',' + CEGUI::PropertyHelper::intToString(value.second) + ',' + CEGUI::PropertyHelper::intToString(value.third);
-    DOMText* text = doc->createTextNode(XMLString::transcode(temp.c_str()));
-    element->appendChild(text);
+    element->LinkEndChild(new TiXmlText(temp.c_str()));
 }
 
-Tripel<int> XmlProcessor::getValueAsIntegerTriple(DOMElement *element) const
+Tripel<int> XmlProcessor::getValueAsIntegerTriple(const TiXmlElement *element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsIntegerTriple: Element must not be NULL");
     CeGuiString value = getValueAsString(element);
@@ -425,22 +414,18 @@
     return intTripel;
 }
 
-void XmlProcessor::setAttributeValueAsVector3( DOMElement *element, const char* const name, Ogre::Vector3 value) const
+void XmlProcessor::setAttributeValueAsVector3(TiXmlElement *element, const char* const name, Ogre::Vector3 value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsVector3: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value.x) + "," + Ogre::StringConverter::toString(value.y) + "," + Ogre::StringConverter::toString(value.z);
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    std::string temp = Ogre::StringConverter::toString(value.x) + "," + Ogre::StringConverter::toString(value.y) + "," + Ogre::StringConverter::toString(value.z);
+    element->SetAttribute(name, temp.c_str());
 }
 
-Ogre::Vector3 XmlProcessor::getAttributeValueAsVector3(DOMElement* element, const char* const name) const
+Ogre::Vector3 XmlProcessor::getAttributeValueAsVector3(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsVector3: Element must not be NULL");
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element->getAttribute(attrName.data());
+    CeGuiString value = getAttributeValueAsString(element, name);
 
-    CeGuiString value = transcodeToString(attribute);
-
     CeGuiString::size_type comma1 = value.find(",");
     CeGuiString::size_type comma2 = value.find(",", comma1 + 1);
 
@@ -455,7 +440,7 @@
     return vec;
 }
 
-void XmlProcessor::setValueAsVector3( DOMElement *element, Ogre::Vector3 value) const
+void XmlProcessor::setValueAsVector3(TiXmlElement *element, Ogre::Vector3 value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsVector3: Element must not be NULL");
     setAttribute(element, "x", Ogre::StringConverter::toString(value.x).c_str());
@@ -463,7 +448,7 @@
     setAttribute(element, "z", Ogre::StringConverter::toString(value.z).c_str());
 }
 
-Ogre::Vector3 XmlProcessor::getValueAsVector3(DOMElement* element) const
+Ogre::Vector3 XmlProcessor::getValueAsVector3(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsVector3: Element must not be NULL");
 	RlAssert(
@@ -477,7 +462,7 @@
 		getAttributeValueAsReal(element, "z"));
 }
 
-void XmlProcessor::setValueAsQuaternion(DOMElement *element, Ogre::Quaternion value) const
+void XmlProcessor::setValueAsQuaternion(TiXmlElement *element, Ogre::Quaternion value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsQuaternion: Element must not be NULL");
     setAttribute(element, "x", Ogre::StringConverter::toString(value.x).c_str());
@@ -486,7 +471,7 @@
     setAttribute(element, "w", Ogre::StringConverter::toString(value.w).c_str());
 }
 
-Ogre::Quaternion XmlProcessor::getValueAsQuaternion(DOMElement* element) const
+Ogre::Quaternion XmlProcessor::getValueAsQuaternion(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsQuaternion: Element must not be NULL");
 	RlAssert(
@@ -502,22 +487,18 @@
         getAttributeValueAsReal(element, "w"));
 }
 
-void XmlProcessor::setAttributeValueAsQuaternion(DOMElement *element, const char* const name, Ogre::Quaternion value) const
+void XmlProcessor::setAttributeValueAsQuaternion(TiXmlElement *element, const char* const name, Ogre::Quaternion value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setAttributeValueAsQuaternion: Element must not be NULL");
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value.w) + "," + Ogre::StringConverter::toString(value.x) + "," + Ogre::StringConverter::toString(value.y) + "," + Ogre::StringConverter::toString(value.z);
-    element->setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    std::string temp = Ogre::StringConverter::toString(value.w) + "," + Ogre::StringConverter::toString(value.x) + "," + Ogre::StringConverter::toString(value.y) + "," + Ogre::StringConverter::toString(value.z);
+    element->SetAttribute(name, temp.c_str());
 }
 
-Ogre::Quaternion XmlProcessor::getAttributeValueAsQuaternion(DOMElement* element, const char* const name) const
+Ogre::Quaternion XmlProcessor::getAttributeValueAsQuaternion(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsQuaternion: Element must not be NULL");
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element->getAttribute(attrName.data());
+    CeGuiString value = getAttributeValueAsString(element, name);
 
-    CeGuiString value = transcodeToString(attribute);
-
     CeGuiString::size_type comma1 = value.find(",");
     CeGuiString::size_type comma2 = value.find(",", comma1 + 1);
     CeGuiString::size_type comma3 = value.find(",", comma2 + 1);
@@ -558,80 +539,8 @@
     return quat;
 }
 
-utf8* XmlProcessor::transcodeToUtf8(const XMLCh* const string16) const
+TiXmlDocument* XmlProcessor::loadDocument(const Ogre::String& resourceName, const Ogre::String& resourceGroup)
 {
-	unsigned int str16len = XMLString::stringLen(string16);
-
-    /// Check if the XMLCh contains nothing but whitespaces. If so, remove them 
-    /// @note this does also mean, that this method will never return something like " " 
-    XMLCh* tmpVal = XMLString::replicate(string16);
-    if(XMLChar1_0::isAllSpaces(tmpVal, str16len) && str16len != 1)
-    {
-        XMLString::removeWS(tmpVal);
-        str16len = XMLString::stringLen(tmpVal);
-    }
-
-	utf8* rval;
-	unsigned int eaten = 0;
-	unsigned int size = str16len;
-
-	do
-	{
-		rval = new utf8[size+1];
-	
-		sTranscoder->transcodeTo(tmpVal, str16len, rval, size, eaten, XMLTranscoder::UnRep_RepChar);
-		rval[size] = 0;
-
-		if (eaten < str16len)
-		{
-			size += str16len - eaten;
-			delete[] rval;
-		}
-	}
-	while (eaten < str16len);
-    XMLString::release(&tmpVal);
-	return rval;	
-}
-
-CeGuiString XmlProcessor::transcodeToString(const XMLCh* const string16) const
-{
-	unsigned int str16len = XMLString::stringLen(string16);
-	if (str16len == 0)
-	{
-		return CeGuiString();
-	}
-
-	utf8* tmpVal = transcodeToUtf8(string16);
-	CeGuiString rVal(tmpVal);
-	delete[] tmpVal;
-	return rVal;
-}
-
-std::string XmlProcessor::transcodeToStdString(const XMLCh* const string16) const
-{
-    if ( string16 == NULL )
-        return "";
-
-	char* tmpVal = XMLString::transcode(string16);
-	std::string rVal(tmpVal);
-	XMLString::release(&tmpVal);
-	return rVal;
-}
-
-DOMDocument* XmlProcessor::loadDocument(
-    const Ogre::String& resourceName, const Ogre::String& resourceGroup)
-{
-    if( mOpenParser != NULL )
-    {
-        LOG_WARNING(Logger::COMMON, 
-                "XmlProcessor: there is already an opened DOMParser, but perhaps its still used, so we don't delete it");
-    }
-    mOpenParser = new XercesDOMParser();
-
-    mOpenParser->setValidationScheme(XercesDOMParser::Val_Auto);    // optional.
-    //mOpenParser->setIncludeIgnorableWhitespace(false); // optional, if you want to ignore whitespaces
-    mOpenParser->setDoNamespaces(true);    // optional
-
     XmlPtr res = XmlResourceManager::getSingleton().getByName(resourceName);
     if (res.isNull())
     {
@@ -645,103 +554,47 @@
         res = XmlResourceManager::getSingleton().create(resourceName, group);
     }
 
-    mOpenXmlFileName = resourceName;
+    TiXmlDocument* doc = parseToXmlDocument(res->getContent());
 
-    if (!res.isNull() && res->parseBy(mOpenParser, this))
-    {
-        mOpenXmlFileName = "";
-        return mOpenParser->getDocument();
-    }
-
-
-    return NULL;
+    return doc;
 }
 
-DOMDocument* XmlProcessor::loadDocument(const Ogre::DataStreamPtr& stream)
+TiXmlDocument* XmlProcessor::loadDocument(const Ogre::DataStreamPtr& stream)
 {
-    if( mOpenParser != NULL )
-    {
-        LOG_WARNING(Logger::COMMON, 
-                "XmlProcessor: there is already an opened DOMParser, but perhaps its still used, so we don't delete it");
-    }
-    mOpenParser = new XercesDOMParser();
+	TiXmlDocument* doc = NULL;
+	size_t size = stream->size();
+	if (size > 0)
+	{
+		char* buffer = new char[size + 1];
+		stream->read(buffer, size);
+		buffer[size] = 0;
+		doc = parseToXmlDocument(buffer);
+		delete[] buffer;
+	}
 
-    mOpenParser->setValidationScheme(XercesDOMParser::Val_Auto);    // optional.
-    mOpenParser->setDoNamespaces(true);    // optional
-
-    OgreInputSource source(stream);
-    mOpenParser->setErrorHandler(this);
-
-    mOpenXmlFileName = stream->getName();
-    mOpenParser->parse(source);
-    mOpenXmlFileName = "";
-
-    if (mOpenParser->getErrorCount() == 0)
-    {
-        return mOpenParser->getDocument();
-    }
-
-    return NULL;
+    return doc;
 }
 
-void XmlProcessor::initializeXml()
+TiXmlDocument* XmlProcessor::parseToXmlDocument(const char* content) const
 {
-  	XMLPlatformUtils::Initialize();
+    TiXmlDocument* doc = new TiXmlDocument();
+    doc->Parse(content);
 
-	sTranscoder 
-        = XMLPlatformUtils::fgTransService->makeNewTranscoderFor(
-            XMLRecognizer::UTF_8, sFailCode, 16*1024);
-}
-
-void XmlProcessor::shutdownXml()
-{
-    if( mOpenParser )
+    if (doc->Error())
     {
-        delete mOpenParser;
-        mOpenParser = NULL;
+    	std::string msg;
+    	msg += "XML Error '";
+		msg += doc->ErrorDesc();
+		msg += "' at row ";
+		msg += doc->ErrorRow();
+		msg += ", col ";
+		msg += doc->ErrorCol();
+    	LOG_ERROR(Logger::COMMON, msg);
+
+    	return NULL;
     }
-    delete sTranscoder;
-    sTranscoder = NULL;
-    
-    XMLPlatformUtils::Terminate();
-}
 
-std::string XmlProcessor::toString( const std::string& type,
-        const XERCES_CPP_NAMESPACE::SAXParseException& exc ) const
-{
-    std::stringstream strs;
-    strs << "A" << type << " occured while parsing " << mOpenXmlFileName
-         << " at line " << exc.getLineNumber() << " column " <<  exc.getColumnNumber();
-
-    if( exc.getSystemId() != NULL )
-        strs << " with system " << transcodeToStdString( exc.getSystemId() );
-    if( exc.getPublicId() != NULL )
-        strs << " with public " << transcodeToStdString( exc.getPublicId() );
-
-    std::string msg = transcodeToStdString(exc.getMessage());
-    strs << ": " << msg;
-
-    return strs.str();
+    return doc;
 }
 
-void XmlProcessor::warning(const XERCES_CPP_NAMESPACE::SAXParseException& exc)
-{
-    LOG_MESSAGE(Logger::CORE, toString( " warning ", exc ) );
-}
-
-void XmlProcessor::error(const XERCES_CPP_NAMESPACE::SAXParseException& exc)
-{
-    LOG_ERROR(Logger::CORE, toString( "n error", exc ) );
-}
-
-void XmlProcessor::fatalError(const XERCES_CPP_NAMESPACE::SAXParseException& exc)
-{
-    LOG_CRITICAL(Logger::CORE, toString( " fatal error", exc ) );
-}
-
-void XmlProcessor::resetErrors()
-{
-}
-
-
 } // end namespace rl

Modified: rl/trunk/engine/common/src/XmlPropertyReader.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlPropertyReader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlPropertyReader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 
 #include "stdinc.h" //precompiled header
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "Properties.h"
 
 #include "XmlProcessor.h"
@@ -25,8 +23,6 @@
 
 #include <CEGUIPropertyHelper.h>
 
-
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
@@ -41,43 +37,45 @@
 
 void XmlPropertyReader::parseGameObjectFile(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
 {
-    initializeXml();
+    TiXmlDocument* doc = loadDocument(stream);
+    doc->Accept(this);
+}
 
-    XERCES_CPP_NAMESPACE::DOMDocument* doc = loadDocument(stream);
+bool XmlPropertyReader::VisitEnter(const TiXmlElement &element, const TiXmlAttribute *firstAttribute)
+{
+	if (element.ValueTStr() == "gameobjectclass")
+	{
+		processGameObjectClassNode(element);
+		return false;
+	}
+	return true;
+}
 
-    DOMNodeList* godefsXml = doc->getDocumentElement()->getElementsByTagName(AutoXMLCh("gameobjectclass").data());
-    for (unsigned int idx = 0; idx < godefsXml->getLength(); idx++)
-    {
-		PropertyRecordPtr ps(new PropertyRecord());
-		DOMElement* curNode = static_cast<DOMElement*>(godefsXml->item(idx));
-		
-		const DOMNamedNodeMap* godefAttrs = curNode->getAttributes();
-		for (XMLSize_t attrIdx = 0; attrIdx < godefAttrs->getLength(); attrIdx++)
+void XmlPropertyReader::processGameObjectClassNode(const TiXmlElement &element)
+{
+	PropertyRecordPtr ps(new PropertyRecord());
+
+	for (const TiXmlAttribute* curAttr = element.FirstAttribute(); curAttr; curAttr = curAttr->Next())
+	{
+		PropertyEntry entry = processProperty(curAttr);
+		if (entry.first != "")
 		{
-			PropertyEntry entry = processProperty(static_cast<DOMAttr*>(godefAttrs->item(attrIdx)));
-            if (entry.first != "")
-            {
-                ps->setProperty(entry.first, entry.second);
-            }
+			ps->setProperty(entry.first, entry.second);
 		}
+	}
 
-        DOMNodeList* godefChildren = curNode->getChildNodes();
-        for (XMLSize_t childIdx = 0; childIdx < godefChildren->getLength(); childIdx++)
-        {
-            DOMNode* curChild = godefChildren->item(childIdx);
-            if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
-                if (entry.first != "")
-                {
-                    ps->setProperty(entry.first, entry.second);
-                }
-            }
-        }
-        mPropertyRecords.push_back(ps);
-    }
-	
-    shutdownXml();
+	for (const TiXmlNode* curChild = element.FirstChild(); curChild; curChild = curChild->NextSibling())
+	{
+		if (curChild->Type() == TiXmlNode::ELEMENT)
+		{
+			PropertyEntry entry = processProperty(curChild->ToElement());
+			if (entry.first != "")
+			{
+				ps->setProperty(entry.first, entry.second);
+			}
+		}
+	}
+	mPropertyRecords.push_back(ps);
 }
 
 PropertyRecordVector XmlPropertyReader::getPropertyRecords()
@@ -85,14 +83,12 @@
     return mPropertyRecords;
 }
 
-PropertyEntry XmlPropertyReader::processProperty(XERCES_CPP_NAMESPACE::DOMAttr* domAttr) const
+PropertyEntry XmlPropertyReader::processProperty(const TiXmlAttribute* attribute) const
 {
-	return std::make_pair(
-		transcodeToStdString(domAttr->getName()), 
-		Property(transcodeToString(domAttr->getValue())));
+	return std::make_pair(attribute->Name(), Property(CeGuiString(attribute->Value())));
 }
 
-PropertyEntry XmlPropertyReader::processProperty(XERCES_CPP_NAMESPACE::DOMElement* domElem) const
+PropertyEntry XmlPropertyReader::processProperty(const TiXmlElement* domElem) const
 {
     if (!hasAttribute(domElem, "type"))
     {
@@ -184,12 +180,12 @@
 	else if (type == "ARRAY")
 	{
 		std::vector<Property> vecVal;
-		for (DOMNode* curChild  = domElem->getFirstChild(); curChild != NULL;
-			curChild = curChild->getNextSibling())
+		for (const TiXmlNode* curChild  = domElem->FirstChild(); curChild;
+			curChild = curChild->NextSibling())
 		{
-			if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
+			if (curChild->Type() == TiXmlNode::ELEMENT)
 			{
-				PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
+				PropertyEntry entry = processProperty(curChild->ToElement());
 				vecVal.push_back(entry.second);
 			}
 		}
@@ -225,12 +221,12 @@
 	else if (type == "MAP")
 	{
 		PropertyMap mapVal;
-		for (DOMNode* curChild  = domElem->getFirstChild(); curChild != NULL;
-			curChild = curChild->getNextSibling())
+		for (const TiXmlNode* curChild  = domElem->FirstChild(); curChild;
+					curChild = curChild->NextSibling())
 		{
-			if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
+			if (curChild->Type() == TiXmlNode::ELEMENT)
 			{
-				DOMElement* curElem = static_cast<DOMElement*>(curChild);
+				const TiXmlElement* curElem = curChild->ToElement();
 				CeGuiString key = getAttributeValueAsString(curElem, "name");
 				PropertyEntry entry = processProperty(curElem);
 				mapVal[key] = entry.second;
@@ -242,17 +238,16 @@
     return std::make_pair(key, prop);
 }
 
-PropertyRecordPtr XmlPropertyReader::getPropertiesAsRecord(DOMElement *parent)
+PropertyRecordPtr XmlPropertyReader::getPropertiesAsRecord(const TiXmlElement *parent)
 {
     PropertyRecordPtr ps(new PropertyRecord());
 
-    DOMNodeList* propertyDefChildren = parent->getChildNodes();
-    for (XMLSize_t childIdx = 0; childIdx < propertyDefChildren->getLength(); childIdx++)
-    {
-        DOMNode* curChild = propertyDefChildren->item(childIdx);
-        if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
+	for (const TiXmlNode* curChild = parent->FirstChild(); curChild;
+				curChild = curChild->NextSibling())
+	{
+		if (curChild->Type() == TiXmlNode::ELEMENT)
+		{
+            PropertyEntry entry = processProperty(curChild->ToElement());
             if (entry.first != "")
             {
                 ps->setProperty(entry.first, entry.second);

Modified: rl/trunk/engine/common/src/XmlPropertyWriter.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlPropertyWriter.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlPropertyWriter.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -24,7 +24,6 @@
 #include <CEGUIPropertyHelper.h>
 
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
@@ -37,7 +36,7 @@
     {
     }
 
-    DOMDocument* XmlPropertyWriter::getDocument()
+    TiXmlDocument* XmlPropertyWriter::getDocument()
     {
         return mDocument;
     }
@@ -52,9 +51,9 @@
         mPropertyRecords.push_back(set);
     }
 
-    DOMElement* XmlPropertyWriter::processProperty(DOMElement* parent, const PropertyEntry& entry)
+    TiXmlElement* XmlPropertyWriter::processProperty(TiXmlElement* parent, const PropertyEntry& entry)
     {
-        DOMElement* element = NULL;
+    	TiXmlElement* element = NULL;
         if(!entry.second.isEmpty())
         {
             if(entry.second.isArray())
@@ -67,7 +66,7 @@
             }
             else
             {
-                element = appendChildElement(mDocument, parent, "property");
+                element = appendChildElement(parent, "property");
                 if(!entry.first.empty())
                     setAttribute(element, "name", entry.first.c_str());
 
@@ -97,16 +96,16 @@
         return element;
     }
 
-    DOMElement* XmlPropertyWriter::processPropertyRecord(DOMElement* parent, const char* const name, const PropertyRecord& set)
+    TiXmlElement* XmlPropertyWriter::processPropertyRecord(TiXmlElement* parent, const char* const name, const PropertyRecord& set)
     {
         PropertyMap map = set.toPropertyMap();
 
         return processPropertyMap(parent, name, map);
     }
 
-    DOMElement* XmlPropertyWriter::processPropertyArray(DOMElement *parent, const char *const name, const PropertyArray& vector)
+    TiXmlElement* XmlPropertyWriter::processPropertyArray(TiXmlElement *parent, const char *const name, const PropertyArray& vector)
     {
-        DOMElement* element = appendChildElement(mDocument, parent, "property");
+    	TiXmlElement* element = appendChildElement(parent, "property");
         if(name[0] != '\0')
             setAttribute(element, "name", name);
         setAttribute(element, "type", "ARRAY");
@@ -119,9 +118,9 @@
         return element;
     }
 
-    DOMElement* XmlPropertyWriter::processPropertyMap(DOMElement *parent, const char *const name, const PropertyMap& map)
+    TiXmlElement* XmlPropertyWriter::processPropertyMap(TiXmlElement *parent, const char *const name, const PropertyMap& map)
     {
-        DOMElement* element = appendChildElement(mDocument, parent, "property");
+    	TiXmlElement* element = appendChildElement(parent, "property");
         if(name[0] != '\0')
             setAttribute(element, "name", name);
         setAttribute(element, "type", "MAP");
@@ -134,7 +133,7 @@
         return element;
     }
 
-    void XmlPropertyWriter::writeEachPropertyToElem(DOMElement* parent, const rl::PropertyMap &map)
+    void XmlPropertyWriter::writeEachPropertyToElem(TiXmlElement* parent, const rl::PropertyMap &map)
     {
         PropertyMap::const_iterator it_properties;
         for(it_properties = map.begin(); it_properties != map.end(); it_properties++)

Modified: rl/trunk/engine/common/src/XmlResource.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlResource.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlResource.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -20,7 +20,6 @@
 #include "XmlResourceManager.h"
 #include "XmlProcessor.h"
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
@@ -29,8 +28,7 @@
         ResourceManager* creator, const Ogre::String& name, ResourceHandle handle,
         const Ogre::String& group, bool isManual, ManualResourceLoader* loader)
 	: Resource(creator, name, handle, group, isManual, loader),
-	mCharBuffer(NULL),
-	mXmlBuffer(NULL)
+	mCharBuffer(NULL)
 {
 }
 
@@ -45,18 +43,12 @@
 	DataStreamPtr ds = Ogre::ResourceGroupManager::getSingleton().openResource(mName, mGroup);
 	mSize = ds->size();
 	
-	mCharBuffer = new XMLByte[mSize];
+	mCharBuffer = new char[mSize];
 	ds->read(mCharBuffer, mSize);
-
-	mXmlBuffer = new MemBufInputSource(
-        mCharBuffer,
-	    static_cast<const unsigned int>(mSize), "rl::XmlResourceManager");
 }
 
 void XmlResource::unloadImpl()
 {
-	delete mXmlBuffer;
-    mXmlBuffer = 0;
 	delete[] mCharBuffer;
     mCharBuffer = 0;
 }
@@ -66,45 +58,15 @@
 {
     return mSize;
 }
-/**
- * @todo both parseby methods could be merged in one template method, to avoid redundancy
- */
-bool XmlResource::parseBy(XERCES_CPP_NAMESPACE::XercesDOMParser* parser, XmlProcessor* const errorHandler)
-{
-	if (!isLoaded())
-		load();
 
-    if (errorHandler 
-        && parser->getErrorHandler() == NULL)
-    {
-        parser->setErrorHandler(errorHandler);
-    }
-
-    parser->parse(*mXmlBuffer);
-    if(parser->getErrorCount() > 0)
-    {
-        return false;
-    }
-    return true;
-}
-
-bool XmlResource::parseBy(XERCES_CPP_NAMESPACE::SAX2XMLReader* parser, XmlProcessor* const errorHandler)
+const char* XmlResource::getContent()
 {
-	if (!isLoaded())
+	if (!mCharBuffer)
+	{
 		load();
+	}
 
-    if (errorHandler 
-        && parser->getErrorHandler() == NULL)
-    {
-        parser->setErrorHandler(errorHandler);
-    }
-
-    parser->parse(*mXmlBuffer);
-    if(parser->getErrorCount() > 0)
-    {
-        return false;
-    }
-    return true;
+	return mCharBuffer;
 }
 
 XmlPtr::XmlPtr(const ResourcePtr& res) : SharedPtr<XmlResource>()

Modified: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -3,7 +3,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include/fmod4driver
 ${CMAKE_CURRENT_SOURCE_DIR}/include/nulldriver
 ${RL_COMMON_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}

Modified: rl/trunk/engine/core/include/PhysicsRagDoll.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsRagDoll.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/include/PhysicsRagDoll.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,7 +17,7 @@
 #ifndef __PhysicsRagdoll_H__
 #define __PhysicsRagdoll_H__
 
-#include <xercesc/dom/DOMElement.hpp>
+#include <tinyxml.h>
 
 #include "CorePrerequisites.h"
 #include "PhysicsManager.h"
@@ -179,7 +179,7 @@
 	RagBone* _addBone( OgreNewt::World* world, RagBone* parent, Ogre::Vector3 dir, RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Ogre::Bone* ogrebone, Actor* parentActor );
 
 	//! recursive function for creating bones and joints
-	RagBone* _addAllBones( RagBone* parent, XERCES_CPP_NAMESPACE::DOMElement* boneElem, Actor* parentActor );
+	RagBone* _addAllBones( RagBone* parent, TiXmlElement* boneElem, Actor* parentActor );
 
     //! add a joint between two bodies
 	void _joinBones( PhysicsRagDoll::JointType type, RagBone* parent, RagBone* child, Ogre::Vector3 pos, Ogre::Vector3 pin, Ogre::Real limit1, Ogre::Real limit2, OgreNewt::World* world );

Modified: rl/trunk/engine/core/include/SaveGameFile.h
===================================================================
--- rl/trunk/engine/core/include/SaveGameFile.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/include/SaveGameFile.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,10 +17,8 @@
 #ifndef __SaveGameFile_H__
 #define __SaveGameFile_H__
 
-
-
 #include "CorePrerequisites.h"
-#include <xercesc/framework/XMLFormatter.hpp>
+
 #include <ctime>
 
 #include "Property.h"
@@ -47,7 +45,6 @@
         //access to file
         Ogre::DataStreamPtr &getDataStream();
         void closeDataStream();
-        XERCES_CPP_NAMESPACE::XMLFormatTarget* getFormatTarget();
         void deleteFileFromStorage();
 
         //data to be saved

Modified: rl/trunk/engine/core/include/SaveGameFileReader.h
===================================================================
--- rl/trunk/engine/core/include/SaveGameFileReader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/include/SaveGameFileReader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,6 +17,8 @@
 #ifndef _SaveGameFileReader_H_
 #define _SaveGameFileReader_H_
 
+#include <tinyxml.h>
+
 #include "SaveGameFile.h"
 #include "XmlPropertyReader.h"
 
@@ -28,7 +30,7 @@
     class _RlCoreExport SaveGameFileReader : public XmlPropertyReader
     {
     protected:
-        XERCES_CPP_NAMESPACE::DOMDocument* mDocument;
+        TiXmlDocument* mDocument;
     public:
         SaveGameFileReader();
         void parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &map);
@@ -36,7 +38,7 @@
 
         PropertyRecordPtr getAllPropertiesAsRecord(SaveGameData* data);
 
-        XERCES_CPP_NAMESPACE::DOMDocument* getDocument() {return mDocument;}
+        TiXmlDocument* getDocument() {return mDocument;}
     };
 }
 

Modified: rl/trunk/engine/core/src/ContentModule.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentModule.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/ContentModule.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -217,19 +217,17 @@
         return "ContentModule";
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void ContentModule::writeData(SaveGameFileWriter* writer)
     {
-        if(!this->isCommon())
+        if (!this->isCommon())
         {
             LOG_MESSAGE(Logger::CORE, "Saving ContentLoaders");
-            DOMElement* contentLoadersNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
+            TiXmlElement* contentLoadersNode = writer->appendChildElement(writer->getDocument()->RootElement(), getXmlNodeIdentifier().c_str());
             writer->setAttributeValueAsString(contentLoadersNode, "name", mName);
 
             for(ContentLoaderVector::const_iterator it = mContentLoaders.begin(); it != mContentLoaders.end(); ++it)
             {
-                DOMElement* contentLoaderNode = writer->appendChildElement(writer->getDocument(), contentLoadersNode, "contentloader");
+                TiXmlElement* contentLoaderNode = writer->appendChildElement(contentLoadersNode, "contentloader");
                 writer->setAttributeValueAsString(contentLoaderNode, "classname", Property((*it)->getClassName()));
                 writer->writeEachPropertyToElem(contentLoaderNode, (*it)->getAllProperties()->toPropertyMap());
             }

Modified: rl/trunk/engine/core/src/GenericWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/GenericWorld.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/GenericWorld.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -15,7 +15,6 @@
 */
 #include "stdinc.h" //precompiled header
 
-// Xerces geht vor allen Ogre includes...
 #include "XmlResourceManager.h"
 
 #include "GenericWorld.h"

Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -173,7 +173,7 @@
 
     void JobScheduler::removeJob(unsigned long ticket)
     {
-        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
+        JobQueue::iterator it = std::find_if (mJobQueue.begin(), mJobQueue.end(),
             std::bind2nd(FindJobEntryByTicket(), ticket));
         if (it != mJobQueue.end())
         {
@@ -182,7 +182,7 @@
         }
         else
         {
-			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
+			it = std::find_if (mAddedJobs.begin(), mAddedJobs.end(),
 				std::bind2nd(FindJobEntryByTicket(), ticket));
 			if (it != mAddedJobs.end())
 			{
@@ -202,17 +202,15 @@
         return NAME;
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void JobScheduler::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* jobSchedulerParentNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
+        TiXmlElement* jobSchedulerParentNode = writer->appendChildElement(writer->getDocument()->RootElement(), getXmlNodeIdentifier().c_str());
 
         for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
         {
-            if( iter->job->getPersistenceType() == Job::PERSISTENT && !(iter->markedToRemove) )
+            if ( iter->job->getPersistenceType() == Job::PERSISTENT && !(iter->markedToRemove) )
             {
-                DOMElement* jobNode = writer->appendChildElement(writer->getDocument(), jobSchedulerParentNode, "job");
+                TiXmlElement* jobNode = writer->appendChildElement(jobSchedulerParentNode, "job");
                 writer->setAttributeValueAsInteger(jobNode, "priority", iter->priority);
                 writer->setAttributeValueAsInteger(jobNode, "tokens", iter->tokens);
                 writer->setAttributeValueAsInteger(jobNode, "start", iter->start);
@@ -246,15 +244,15 @@
         // delete and discard old jobs
         for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
         {
-            if( iter->job->getPersistenceType() == Job::PERSISTENT )
+            if ( iter->job->getPersistenceType() == Job::PERSISTENT )
             {
                 // delete the job, but do not discard it!
                 iter->markedToRemove = true;
             }
-            else if( iter->job->getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
+            else if ( iter->job->getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
             {
                 // discard the job, then delete it
-                if( iter->job->isDiscardable() )
+                if ( iter->job->isDiscardable() )
                     iter->job->discard();
                 iter->markedToRemove = true;
             }
@@ -263,22 +261,19 @@
         
         // load jobs from savegamefile
 
-        reader->initializeXml();
-
-
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
+        XmlElementList rootNodeList = reader->getElementsByTagName(reader->getDocument()->RootElement(), getXmlNodeIdentifier().c_str());
         
-        if(rootNodeList->getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNodeList* xmlJobs = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("job").data());
-            if (xmlJobs->getLength())
+            XmlElementList xmlJobs = reader->getElementsByTagName(rootNodeList[0], "job");
+            if (!xmlJobs.empty())
             {
-                for (XMLSize_t childIdx1 = 0; childIdx1 < xmlJobs->getLength(); childIdx1++)
+                for (XmlElementList::iterator it = xmlJobs.begin(); it != xmlJobs.end(); ++it)
                 {
-                    DOMNode* xmlJob_ = xmlJobs->item(childIdx1);
-                    if (xmlJob_->getNodeType() == DOMNode::ELEMENT_NODE)
+                    const TiXmlNode* xmlJob_ = *it;
+                    if (xmlJob_->Type() == TiXmlNode::ELEMENT)
                     {
-                        DOMElement* xmlJob = static_cast<DOMElement*>(xmlJob_);
+                    	const TiXmlElement* xmlJob = xmlJob_->ToElement();
                         JobPriority priority;
                         unsigned short tokens;
                         int start, end;
@@ -331,8 +326,6 @@
                 }
             }
         }
-
-        reader->shutdownXml();
     }
 
     int JobScheduler::getPriority() const

Modified: rl/trunk/engine/core/src/PhysicsRagDoll.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -23,13 +23,11 @@
 
 #include <sstream>
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
 
-PhysicsRagDoll::RagBone::RagBone( PhysicsRagDoll* creator, OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Bone* ogreBone, Ogre::MeshPtr mesh, 
-						  Ogre::Vector3 dir, PhysicsRagDoll::RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Actor* parentActor )
+PhysicsRagDoll::RagBone::RagBone(PhysicsRagDoll* creator, OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Bone* ogreBone, Ogre::MeshPtr mesh,
+						  Ogre::Vector3 dir, PhysicsRagDoll::RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Actor* parentActor)
 {
 	mDoll = creator;
 	mParent = parent;
@@ -45,13 +43,13 @@
 	if (dir == Ogre::Vector3::UNIT_Y)
 	{
 		rot.FromEulerAnglesXYZ(Ogre::Degree(0), Ogre::Degree(0), Ogre::Degree(90));
-		orient.FromRotationMatrix( rot );
+		orient.FromRotationMatrix(rot);
 	}
 
 	if (dir == Ogre::Vector3::UNIT_Z)
 	{
 		rot.FromEulerAnglesXYZ(Ogre::Degree(0), Ogre::Degree(90), Ogre::Degree(0));
-		orient.FromRotationMatrix( rot );
+		orient.FromRotationMatrix(rot);
 	}
 
 
@@ -59,102 +57,102 @@
 	switch (shape)
 	{
 	case PhysicsRagDoll::RagBone::BS_BOX:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, 0));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CAPSULE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, 0, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(world, size.y, size.x, 0, orient, pos));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, 0, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone(world, size.y, size.x, 0, orient, pos));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CYLINDER:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, 0, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(world, size.y, size.x, 0, orient, pos));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_ELLIPSOID:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size, 0 ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(world, size, 0));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONVEXHULL:
-		col = _makeConvexHull( world, mesh, size.x );
+		col = _makeConvexHull(world, mesh, size.x);
 		break;
 
 	default:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, 0));
 		break;
 	}
 
-    if( col )
+    if (col)
     {
-        if( col->getNewtonCollision() == NULL )
+        if (col->getNewtonCollision() == NULL)
         {
             col.reset();
         }
     }
 
-    if( !col )
+    if (!col)
     {
         LOG_WARNING(Logger::CORE, " error creating collision for '" + ogreBone->getName() + "', still continuing.");
         mBody = NULL;
     }
     else
     {
-    	mBody = new OgreNewt::Body( world, col );
-        mBody->setUserData( Ogre::Any(parentActor) );
+    	mBody = new OgreNewt::Body(world, col);
+        mBody->setUserData(Ogre::Any(parentActor));
     	mBody->setStandardForceCallback();
         const OgreNewt::MaterialID* ragdollMat = PhysicsManager::getSingleton().createMaterialID("default");
         mBody->setMaterialGroupID(ragdollMat);
 
 	    Ogre::Vector3 inertia;
     	Ogre::Vector3 com;
-    	col->calculateInertialMatrix( inertia, com );
+    	col->calculateInertialMatrix(inertia, com);
 	
-	    mBody->setMassMatrix( mass, inertia * mass );
-    	mBody->setCenterOfMass( com );
+	    mBody->setMassMatrix(mass, inertia * mass);
+    	mBody->setCenterOfMass(com);
 
-	    mBody->setCustomTransformCallback( PhysicsRagDoll::_placementCallback );
+	    mBody->setCustomTransformCallback(PhysicsRagDoll::_placementCallback);
 
 
-    	mOgreBone->setManuallyControlled( true );
+    	mOgreBone->setManuallyControlled(true);
     }
 }
 
 
 PhysicsRagDoll::RagBone::~RagBone()
 {
-	mOgreBone->setManuallyControlled( false );
-    if( mBody )
+	mOgreBone->setManuallyControlled(false);
+    if (mBody)
     	delete mBody;
 }
 
 
-void PhysicsRagDoll::RagBone::_hingeCallback( OgreNewt::BasicJoints::Hinge* me )
+void PhysicsRagDoll::RagBone::_hingeCallback(OgreNewt::BasicJoints::Hinge* me)
 {
     PhysicsRagDoll::RagBone* bone = Ogre::any_cast<PhysicsRagDoll::RagBone*>(me->getUserData());
 
 	Ogre::Degree angle = me->getJointAngle();
-	Ogre::Degree lim1( bone->getLimit1() );
-	Ogre::Degree lim2( bone->getLimit2() );
+	Ogre::Degree lim1(bone->getLimit1());
+	Ogre::Degree lim2(bone->getLimit2());
 
 	if (angle < lim1)
 	{
-		Ogre::Real accel = me->calculateStopAlpha( lim1 );
-		me->setCallbackAccel( accel );
+		Ogre::Real accel = me->calculateStopAlpha(lim1);
+		me->setCallbackAccel(accel);
 	}
 
 	if (angle > lim2)
 	{
-		Ogre::Real accel = me->calculateStopAlpha( lim2 );
-		me->setCallbackAccel( accel );
+		Ogre::Real accel = me->calculateStopAlpha(lim2);
+		me->setCallbackAccel(accel);
 	}
 
 }
 
 
-OgreNewt::ConvexCollisionPtr PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
+OgreNewt::ConvexCollisionPtr PhysicsRagDoll::RagBone::_makeConvexHull(OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight)
 {
 	std::vector< Ogre::Vector3 > vertexVector;
 
@@ -163,7 +161,7 @@
 	unsigned int boneIndex = mOgreBone->getHandle();
 
 	Ogre::Matrix4 invMatrix;
-	invMatrix.makeInverseTransform( -mOgreBone->_getBindingPoseInversePosition(), Ogre::Vector3::UNIT_SCALE / mOgreBone->_getBindingPoseInverseScale(), mOgreBone->_getBindingPoseInverseOrientation().Inverse());
+	invMatrix.makeInverseTransform(-mOgreBone->_getBindingPoseInversePosition(), Ogre::Vector3::UNIT_SCALE / mOgreBone->_getBindingPoseInverseScale(), mOgreBone->_getBindingPoseInverseOrientation().Inverse());
 
 	unsigned int num_sub = mesh->getNumSubMeshes();
 
@@ -183,20 +181,20 @@
 			v_data = mesh->sharedVertexData;
 			v_count = v_data->vertexCount;
 			v_decl = v_data->vertexDeclaration;
-			p_elem = v_decl->findElementBySemantic( Ogre::VES_POSITION );
+			p_elem = v_decl->findElementBySemantic(Ogre::VES_POSITION);
 		}
 		else
 		{
 			v_data = submesh->vertexData;
 			v_count = v_data->vertexCount;
 			v_decl = v_data->vertexDeclaration;
-			p_elem = v_decl->findElementBySemantic( Ogre::VES_POSITION );
+			p_elem = v_decl->findElementBySemantic(Ogre::VES_POSITION);
 		}		
 			
 		size_t start = v_data->vertexStart;
 		//pointer
-		Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data->vertexBufferBinding->getBuffer( p_elem->getSource() );
-		unsigned char* v_ptr = static_cast<unsigned char*>(v_sptr->lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+		Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data->vertexBufferBinding->getBuffer(p_elem->getSource());
+		unsigned char* v_ptr = static_cast<unsigned char*>(v_sptr->lock(Ogre::HardwareBuffer::HBL_READ_ONLY));
 		unsigned char* v_offset;
 		
 		while (bai.hasMoreElements())
@@ -209,7 +207,7 @@
 				{
 					//get offset to Position data!
 					v_offset = v_ptr + (vba.vertexIndex * v_sptr->getVertexSize());
-					p_elem->baseVertexPointerToElement( v_offset, &v_Posptr );
+					p_elem->baseVertexPointerToElement(v_offset, &v_Posptr);
 
 					Ogre::Vector3 vert;
 					vert.x = *v_Posptr; v_Posptr++;
@@ -219,7 +217,7 @@
 					// apply transformation in to local space.
 					vert = invMatrix * vert;
 
-					vertexVector.push_back( vert );
+					vertexVector.push_back(vert);
 
 					Ogre::LogManager::getSingletonPtr()->logMessage("  vertex found! id:"+Ogre::StringConverter::toString(vba.vertexIndex));
 				}
@@ -245,8 +243,8 @@
 
 	//////////////////////////////////////////////////////////////////////////////////
     OgreNewt::ConvexCollisionPtr col;
-    if( numVerts > 0 )
-    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts, 0 ));
+    if (numVerts > 0)
+    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(world, verts, numVerts, 0));
 
 	delete []verts;
 
@@ -256,7 +254,7 @@
 
 
 
-PhysicsRagDoll::PhysicsRagDoll( const Ogre::String& ragdollResource, Actor* actor) :
+PhysicsRagDoll::PhysicsRagDoll(const Ogre::String& ragdollResource, Actor* actor) :
     mRootBone(NULL),
     mNode(NULL),
     mWorld(NULL),
@@ -266,7 +264,7 @@
     mRootBone = NULL;
 	mNode = actor->_getSceneNode();
 	mWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-    if( !actor->getControlledObject()->isMeshObject() )
+    if (!actor->getControlledObject()->isMeshObject())
         Throw(IllegalArgumentException, "PhysicsRagDoll::PhysicsRagDoll needs a Mesh-Actor as argument!");
 
     MeshObject* meshObj = static_cast<MeshObject*>(actor->getControlledObject());
@@ -283,37 +281,34 @@
 
     LOG_MESSAGE(Logger::CORE, "Loading ragdoll '" + ragdollResource + "'");
 
-    initializeXml();
-    DOMDocument* doc = loadDocument(ragdollResource);
-    if( !doc )
+    TiXmlDocument* doc = loadDocument(ragdollResource);
+    if (!doc)
     {
         LOG_ERROR(Logger::CORE, "Ragdoll resource '" + ragdollResource + "' not found");
     }
     else
     {
 
-	    DOMElement* dataDocumentContent = doc->getDocumentElement();
-		mRootBone =_addAllBones( NULL, getChildNamed(dataDocumentContent, "Bone"), actor);
+	    TiXmlElement* dataDocumentContent = doc->RootElement();
+		mRootBone =_addAllBones(NULL, getChildNamed(dataDocumentContent, "Bone"), actor);
     }
-    shutdownXml();
-
 }
 
 
-PhysicsRagDoll::RagBone* PhysicsRagDoll::_addAllBones(PhysicsRagDoll::RagBone* parent, DOMElement* boneElement, Actor* parentActor)
+PhysicsRagDoll::RagBone* PhysicsRagDoll::_addAllBones(PhysicsRagDoll::RagBone* parent, TiXmlElement* boneElement, Actor* parentActor)
 {
 	// get the information for the bone represented by this element.
     Ogre::Vector3 dir = getAttributeValueAsVector3(boneElement, "dir");
-	Ogre::Real length = getAttributeValueAsReal( boneElement, "length");
+	Ogre::Real length = getAttributeValueAsReal(boneElement, "length");
 		
-	Ogre::Vector3 size = getAttributeValueAsVector3( boneElement, "size");
+	Ogre::Vector3 size = getAttributeValueAsVector3(boneElement, "size");
 	
 	
-	Ogre::String skeleton_bone = getAttributeValueAsStdString( boneElement, "skeleton_bone");
-	Ogre::Bone* ogrebone = mSkeleton->getBone( skeleton_bone );
+	Ogre::String skeleton_bone = getAttributeValueAsStdString(boneElement, "skeleton_bone");
+	Ogre::Bone* ogrebone = mSkeleton->getBone(skeleton_bone);
 
 
-	Ogre::String shapestr = getAttributeValueAsStdString( boneElement, "shape");
+	Ogre::String shapestr = getAttributeValueAsStdString(boneElement, "shape");
 	PhysicsRagDoll::RagBone::BoneShape shape = PhysicsRagDoll::RagBone::BS_BOX;
 
 	if (shapestr=="box")
@@ -334,10 +329,10 @@
 	if (shapestr=="hull")
 		shape = PhysicsRagDoll::RagBone::BS_CONVEXHULL;
 
-	Ogre::Real mass = getAttributeValueAsReal( boneElement, "mass" );
+	Ogre::Real mass = getAttributeValueAsReal(boneElement, "mass");
 	
 	///////////////////////////////////////////////////////////////////////////////
-	RagBone* me = _addBone( mWorld, parent, dir, shape, size, mass, ogrebone,  parentActor);
+	RagBone* me = _addBone(mWorld, parent, dir, shape, size, mass, ogrebone,  parentActor);
 	///////////////////////////////////////////////////////////////////////////////
 
 	// position the bone.
@@ -348,22 +343,22 @@
 	else
 		bonepos = mNode->_getFullTransform() * ogrebone->_getDerivedPosition();
 
-    if( me->getBody() )
-    	me->getBody()->setPositionOrientation( bonepos, boneorient );
+    if (me->getBody())
+    	me->getBody()->setPositionOrientation(bonepos, boneorient);
 
 	// set offsets
 	if (!parent)
 	{
 		Ogre::Quaternion offsetorient = (boneorient.Inverse()) * mNode->_getDerivedOrientation();
 		Ogre::Vector3 offsetpos = boneorient.Inverse() * (mNode->_getDerivedPosition() - bonepos);
-		me->setOffset( offsetorient, offsetpos );
+		me->setOffset(offsetorient, offsetpos);
 	}
 
 
 	// get the joint to connect this bone with it's parent.
-	if (parent && me->getBody() )
+	if (parent && me->getBody())
 	{
-		DOMElement* jointElement = getChildNamed( boneElement, "Joint" );
+		TiXmlElement* jointElement = getChildNamed(boneElement, "Joint");
 		if (!jointElement)
 		{
 			// error!
@@ -371,8 +366,8 @@
 			return me;
 		}
 
-		Ogre::Vector3 jointpin = getAttributeValueAsVector3( jointElement, "pin");
-		Ogre::String jointtypestr = getAttributeValueAsStdString( jointElement, "type");
+		Ogre::Vector3 jointpin = getAttributeValueAsVector3(jointElement, "pin");
+		Ogre::String jointtypestr = getAttributeValueAsStdString(jointElement, "type");
 		PhysicsRagDoll::JointType jointtype = PhysicsRagDoll::JT_BALLSOCKET;
 
 		if (jointtypestr == "ballsocket")
@@ -382,13 +377,13 @@
 			jointtype = PhysicsRagDoll::JT_HINGE;
 
 
-		Ogre::Real limit1 = getAttributeValueAsReal( jointElement, "limit1" );
-		Ogre::Real limit2 = getAttributeValueAsReal( jointElement, "limit2" );
+		Ogre::Real limit1 = getAttributeValueAsReal(jointElement, "limit1");
+		Ogre::Real limit2 = getAttributeValueAsReal(jointElement, "limit2");
 
 		Ogre::Vector3 jpos = mNode->_getFullTransform() * ogrebone->_getDerivedPosition();
 		Ogre::Vector3 jpin = (mNode->_getDerivedOrientation() * parent->getOgreBone()->_getDerivedOrientation()) * jointpin;
 
-		_joinBones( jointtype, parent, me, jpos, jpin, limit1, limit2, mWorld);
+		_joinBones(jointtype, parent, me, jpos, jpin, limit1, limit2, mWorld);
 	}
 	
     LOG_MESSAGE(Logger::CORE, " added bone from '"+ogrebone->getName()+"'.");
@@ -396,12 +391,11 @@
 	///////////////////////////////////////////////////////////////////////////////
 	///////////////////////////////////////////////////////////////////////////////
 	// add all children of this bone.
-    for (DOMNode* cur = boneElement->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+    for (TiXmlNode* cur = boneElement->FirstChild(); cur; cur = cur->NextSibling())
     {
-        if (cur->getNodeType() == DOMNode::ELEMENT_NODE && hasNodeName(cur, "Bone"))
+        if (cur->Type() == TiXmlNode::ELEMENT && hasNodeName(cur, "Bone"))
         {
-            DOMElement* childBoneElem = static_cast<DOMElement*>(cur);
-		    _addAllBones( me, childBoneElem, parentActor );
+		    _addAllBones(me, cur->ToElement(), parentActor);
         }
 	}
 
@@ -411,7 +405,7 @@
 
 PhysicsRagDoll::~PhysicsRagDoll()
 {
-    for(RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
+    for (RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
     {
 		RagBone* bone = it->second;
 		delete bone;
@@ -419,16 +413,16 @@
 }
 
 
-PhysicsRagDoll::RagBone* PhysicsRagDoll::_addBone( OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Vector3 dir, RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Ogre::Bone* ogrebone, Actor* parentActor )
+PhysicsRagDoll::RagBone* PhysicsRagDoll::_addBone(OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Vector3 dir, RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Ogre::Bone* ogrebone, Actor* parentActor)
 {
-	PhysicsRagDoll::RagBone* bone = new PhysicsRagDoll::RagBone( this, world, parent, ogrebone, mMesh, dir, shape, size, mass, parentActor );
+	PhysicsRagDoll::RagBone* bone = new PhysicsRagDoll::RagBone(this, world, parent, ogrebone, mMesh, dir, shape, size, mass, parentActor);
 
-	mRagBonesMap.insert(std::make_pair( bone->getBody(), bone ));
+	mRagBonesMap.insert(std::make_pair(bone->getBody(), bone));
 
 	return bone;
 }
 
-void PhysicsRagDoll::_joinBones( PhysicsRagDoll::JointType type, RagBone* parent, RagBone* child, Ogre::Vector3 pos, Ogre::Vector3 pin, Ogre::Real limit1, Ogre::Real limit2, OgreNewt::World* world )
+void PhysicsRagDoll::_joinBones(PhysicsRagDoll::JointType type, RagBone* parent, RagBone* child, Ogre::Vector3 pos, Ogre::Vector3 pin, Ogre::Real limit1, Ogre::Real limit2, OgreNewt::World* world)
 {
 	pin.normalise();
 	OgreNewt::Joint* joint = NULL;
@@ -436,27 +430,27 @@
 	switch (type)
 	{
 	case PhysicsRagDoll::JT_BALLSOCKET:
-		joint = new OgreNewt::BasicJoints::BallAndSocket( world, child->getBody(), parent->getBody(), pos );
+		joint = new OgreNewt::BasicJoints::BallAndSocket(world, child->getBody(), parent->getBody(), pos);
 		((OgreNewt::BasicJoints::BallAndSocket*)joint)->setLimits(pin, Ogre::Degree(limit1), Ogre::Degree(limit2));
 		break;
 
 	case PhysicsRagDoll::JT_HINGE:
-		joint = new OgreNewt::BasicJoints::Hinge( world, child->getBody(), parent->getBody(), pos, pin );
-		((OgreNewt::BasicJoints::Hinge*)joint)->setCallback( RagBone::_hingeCallback );
-		joint->setUserData( Ogre::Any(child) );
-		child->setLimits( limit1, limit2 );
+		joint = new OgreNewt::BasicJoints::Hinge(world, child->getBody(), parent->getBody(), pos, pin);
+		((OgreNewt::BasicJoints::Hinge*)joint)->setCallback(RagBone::_hingeCallback);
+		joint->setUserData(Ogre::Any(child));
+		child->setLimits(limit1, limit2);
 		break;
 	}
 
 }
 
 
-void PhysicsRagDoll::_placementCallback( OgreNewt::Body* me, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, int threadindex )
+void PhysicsRagDoll::_placementCallback(OgreNewt::Body* me, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, int threadindex)
 {
     Actor* parentActor = Ogre::any_cast<Actor*>(me->getUserData());
 	PhysicsRagDoll* doll = parentActor->getPhysicalThing()->getRagDoll();
     PhysicsRagDoll::RagBoneMapIterator it = doll->mRagBonesMap.find(me);
-    if( it == doll->mRagBonesMap.end() )
+    if (it == doll->mRagBonesMap.end())
     {
         LOG_ERROR(Logger::CORE, "Could not find ragdoll-bone in PhysicsRagDoll::_placementCallback!");
         return;
@@ -469,8 +463,8 @@
 		Ogre::Quaternion finalorient = (orient * bone->getOffsetOrient());
 		Ogre::Vector3 finalpos = pos + (orient * bone->getOffsetPos());
 
-		doll->mNode->setPosition( finalpos );
-		doll->mNode->setOrientation( finalorient );
+		doll->mNode->setPosition(finalpos);
+		doll->mNode->setOrientation(finalorient);
 	}
 	else
 	{
@@ -478,22 +472,22 @@
 		Ogre::Quaternion parentorient;
 		Ogre::Vector3 parentpos;
 
-        if( bone->getParent()->getBody() )
-    		bone->getParent()->getBody()->getPositionOrientation( parentpos, parentorient );
+        if (bone->getParent()->getBody())
+    		bone->getParent()->getBody()->getPositionOrientation(parentpos, parentorient);
         else
             parentorient = bone->getParent()->getOgreBone()->getOrientation();
 
 
         Ogre::Quaternion localorient = orient;
-        if( bone->getOgreBone()->getInheritOrientation() )
+        if (bone->getOgreBone()->getInheritOrientation())
             localorient = parentorient.Inverse() * localorient;
 
-		bone->getOgreBone()->setOrientation( localorient );
+		bone->getOgreBone()->setOrientation(localorient);
 	}
 }
 
 
-void PhysicsRagDoll::setInheritedVelOmega( const Ogre::Vector3& vel, const Ogre::Vector3& omega )
+void PhysicsRagDoll::setInheritedVelOmega(const Ogre::Vector3& vel, const Ogre::Vector3& omega)
 {
 	// find main position.
 	Ogre::Vector3 mainpos = mNode->_getDerivedPosition();
@@ -503,15 +497,15 @@
 		Ogre::Vector3 pos;
 		Ogre::Quaternion orient;
 
-        if( it->second->getBody() )
+        if (it->second->getBody())
         {
-		    it->second->getBody()->getPositionOrientation( pos, orient );
-		    it->second->getBody()->setVelocity( vel + omega.crossProduct( pos - mainpos ) );
+		    it->second->getBody()->getPositionOrientation(pos, orient);
+		    it->second->getBody()->setVelocity(vel + omega.crossProduct(pos - mainpos));
         }
 	}
 }
 
-void PhysicsRagDoll::setPositionOrientation( const Ogre::Vector3& pos, const Ogre::Quaternion &orient )
+void PhysicsRagDoll::setPositionOrientation(const Ogre::Vector3& pos, const Ogre::Quaternion &orient)
 {
     Ogre::Vector3 oldPos = mNode->_getDerivedPosition();
     Ogre::Quaternion oldOri = mNode->_getDerivedOrientation();
@@ -520,7 +514,7 @@
     for (RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
     {
         OgreNewt::Body* body = it->second->getBody();
-        if( body )
+        if (body)
         {
             Ogre::Vector3 boneOldPos;
             Ogre::Quaternion boneOldOri;
@@ -541,9 +535,9 @@
 
 void PhysicsRagDoll::setMaterialID(const OgreNewt::MaterialID* materialid)
 {
-    for(RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
+    for (RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
     {
-        if( it->second->getBody() )
+        if (it->second->getBody())
             it->second->getBody()->setMaterialGroupID(materialid);
     }
 }

Modified: rl/trunk/engine/core/src/SaveGameFile.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFile.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameFile.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -18,7 +18,6 @@
 
 #include "SaveGameFile.h"
 #include "SaveGameManager.h"
-#include <xercesc/framework/LocalFileFormatTarget.hpp>
 
 #include <ConfigurationManager.h>
 #include <CoreSubsystem.h>
@@ -87,12 +86,6 @@
         Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
     }
 
-    XERCES_CPP_NAMESPACE::XMLFormatTarget* SaveGameFile::getFormatTarget()
-    {
-        ///@todo: encryption
-        return new XERCES_CPP_NAMESPACE::LocalFileFormatTarget(this->buildFilename().c_str());
-    }
-
     void SaveGameFile::deleteFileFromStorage()
     {
         if(remove(buildFilename().c_str()))

Modified: rl/trunk/engine/core/src/SaveGameFileReader.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFileReader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameFileReader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,16 +16,12 @@
 
 #include "stdinc.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "SaveGameFileReader.h"
 #include "SaveGameManager.h"
 #include "SaveGameData.h"
 
 #include "CoreSubsystem.h"
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
     SaveGameFileReader::SaveGameFileReader()
@@ -34,12 +30,10 @@
 
     void SaveGameFileReader::parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &map)
     {
-        initializeXml();
-
         mDocument = loadDocument(file->getDataStream());
 
-        int version = getAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion");
-        if(version >= CoreSubsystem::getSingleton().getEngineBuildNumber())
+        int version = getAttributeValueAsInteger(mDocument->RootElement(), "Engineversion");
+        if (version >= CoreSubsystem::getSingleton().getEngineBuildNumber())
             LOG_MESSAGE(Logger::CORE, "Loading save game: Engine version is ok");
         else
             LOG_ERROR(Logger::CORE, "Loading save game: Save game version is newer then engine version! Loading save game could crash");
@@ -52,31 +46,28 @@
 
         file->closeDataStream(); //make the save game writable
 
-        mDocument = NULL;
-
-        shutdownXml();
+		mDocument = NULL;
+        delete mDocument;
     }
 
     void SaveGameFileReader::parseSaveGameFileHeader(Ogre::DataStreamPtr &stream, const Ogre::String &groupName, SaveGameFile* file)
     {
-        initializeXml();
-
-        if(stream->size())
+        if (stream->size())
         {
-            DOMDocument* doc = loadDocument(stream);
+            TiXmlDocument* doc = loadDocument(stream);
 
-             DOMNodeList* headerDefsXml = doc->getDocumentElement()->getElementsByTagName(AutoXMLCh("header").data());
-             if(headerDefsXml->getLength())
+             XmlElementList headerDefsXml = getElementsByTagName(mDocument->RootElement(), "header");
+             if (!headerDefsXml.empty())
              {
-                 DOMElement* elem = static_cast<DOMElement*>(headerDefsXml->item(0));
-                 /*DOMNodeList* headerDefChildren = elem->getChildNodes();
+            	 const TiXmlElement* elem = headerDefsXml[0];
+                 /*TiXmlNodeList* headerDefChildren = elem->getChildNodes();
                  for(XMLSize_t childIdx = 0; childIdx < headerDefChildren->getLength(); childIdx++)
                  {
-                     DOMNode* curChild = headerDefChildren->item(childIdx);
-                     if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
+                     TiXmlNode* curChild = headerDefChildren->item(childIdx);
+                     if (curChild->getNodeType() == TiXmlNode::ELEMENT_NODE)
                      {
-                         PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
-                         if(entry.first != "")
+                         PropertyEntry entry = processProperty(static_cast<TiXmlElement*>(curChild));
+                         if (entry.first != "")
                          {
                             file->setProperty(entry.first, entry.second);
                          }
@@ -85,27 +76,21 @@
                  PropertyRecordPtr set = getPropertiesAsRecord(elem);
                  file->setProperties(set);
              }
+             delete doc;
         }
-
-        shutdownXml();
     }
 
     PropertyRecordPtr SaveGameFileReader::getAllPropertiesAsRecord(SaveGameData* data)
     {
         PropertyRecordPtr properties(new PropertyRecord());
 
-        initializeXml();
+        XmlElementList rootNodeList = getElementsByTagName(mDocument->RootElement(), data->getXmlNodeIdentifier().c_str());
 
-        DOMNodeList* rootNodeList = getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(data->getXmlNodeIdentifier().c_str()).data());
-
-        if (rootNodeList->getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNode* xmlPropElem = rootNodeList->item(0);
-            properties = getPropertiesAsRecord(static_cast<DOMElement*>(xmlPropElem));
+            properties = getPropertiesAsRecord(rootNodeList[0]);
         }
 
-        shutdownXml();
-
         return properties;
     }
 }

Modified: rl/trunk/engine/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFileWriter.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameFileWriter.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,9 +21,6 @@
 #include "SaveGameManager.h"
 
 #include <XmlProcessor.h>
-#include <xercesc/dom/DOM.hpp>
-#include <xercesc/dom/DOMAttr.hpp>
-#include <xercesc/dom/DOMElement.hpp>
 #include <Properties.h>
 
 #ifdef __APPLE__
@@ -36,9 +33,9 @@
 #include <ContentModule.h>
 #include <TimeSource.h>
 
+#include <cstdio>
 #include <ctime>
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl
@@ -46,39 +43,27 @@
     void SaveGameFileWriter::buildSaveGameFile(SaveGameFile *file, const SaveGameDataOrderMap &map)
     {
         //@toto: build
-        initializeXml();
 
-        XMLCh tempStr[100];
-        XMLString::transcode("LS", tempStr, 99);
-        mImplementation = DOMImplementationRegistry::getDOMImplementation(tempStr);
-        mWriter = static_cast<DOMImplementationLS*>(mImplementation)->createDOMWriter();
-        mTarget = file->getFormatTarget();
-        mDocument = static_cast<DOMImplementation*>(mImplementation)->createDocument(0, XMLString::transcode("SaveGameFile"), 0);
+        mDocument = new TiXmlDocument();
+        mDocument->SetValue("SaveGameFile");
 
-        if (mWriter->canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true))
-            mWriter->setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true);
-
-        if (mWriter->canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true))
-             mWriter->setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true);
-
-        mDocument->setNodeValue(XMLString::transcode("SaveGameFile")); //Set name of document root node
-
+        TiXmlElement* rootElem = mDocument->RootElement();
         //Write SaveGameVersion
-        setAttributeValueAsString(mDocument->getDocumentElement(), "SaveGameFormatVersion", "0.5");
-        setAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion", CoreSubsystem::getSingleton().getEngineBuildNumber());
+        setAttributeValueAsString(rootElem, "SaveGameFormatVersion", "0.5");
+        setAttributeValueAsInteger(rootElem, "Engineversion", CoreSubsystem::getSingleton().getEngineBuildNumber());
 
         //Write modul of save game
-        DOMElement* header = appendChildElement(mDocument, mDocument->getDocumentElement(), "header");
+        TiXmlElement* header = appendChildElement(rootElem, "header");
         
         PropertyRecordPtr headerSet = file->getAllProperties();
         for (PropertyRecord::PropertyRecordMap::const_iterator it_header = headerSet->begin(); it_header != headerSet->end(); it_header++)
         {
-            this->processProperty(header, PropertyEntry(it_header->first.c_str(), it_header->second));
+            processProperty(header, PropertyEntry(it_header->first.c_str(), it_header->second));
         }
 
         ////Write globals
-        //DOMElement* globals = appendChildElement(mDocument, mDocument->getDocumentElement(), "globals");
-        //DOMElement* gameTime = appendChildElement(mDocument, globals, "gametime");
+        //TiXmlElement* globals = appendChildElement(mDocument, mDocument->getDocumentElement(), "globals");
+        //TiXmlElement* gameTime = appendChildElement(mDocument, globals, "gametime");
         //TimeSource* gameTimeSource = TimeSourceManager::getSingleton().getTimeSource(TimeSource::GAMETIME);
         //setAttributeValueAsInteger(gameTime, "milliseconds", gameTimeSource->getClock());
 
@@ -87,20 +72,19 @@
             data_iter->second->writeData(this);
         }
 
-        mWriter->writeNode(mTarget, *mDocument);
+        std::FILE* fileHandle = std::fopen(file->buildFilename().c_str(), "w");
+        if (fileHandle)
+        {
+        	mDocument->Print(fileHandle);
+        }
 
-
-        mWriter->release();
-
         delete mDocument;
-        delete mTarget;
-
-        shutdownXml();
+        mDocument = NULL;
     }
 
     void SaveGameFileWriter::writeEachProperty(SaveGameData* data, const rl::PropertyMap &map)
     {
-        DOMElement* saveElem = appendChildElement(getDocument(), getDocument()->getDocumentElement(), data->getXmlNodeIdentifier().c_str());
+        TiXmlElement* saveElem = appendChildElement(mDocument->RootElement(), data->getXmlNodeIdentifier().c_str());
 
         XmlPropertyWriter::writeEachPropertyToElem(saveElem, map);
     }

Modified: rl/trunk/engine/core/src/SaveGameManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,12 +25,8 @@
 
 #include "XmlProcessor.h"
 
-#include <xercesc/framework/LocalFileFormatTarget.hpp>
-
 template<> rl::SaveGameManager* Ogre::Singleton<rl::SaveGameManager>::ms_Singleton = 0;
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
     SaveGameData::SaveGameData()

Modified: rl/trunk/engine/core/src/TimeSource.cpp
===================================================================
--- rl/trunk/engine/core/src/TimeSource.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/TimeSource.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -180,17 +180,15 @@
 		return "time_sources";
 	}
 
-	using namespace XERCES_CPP_NAMESPACE;
-
     void TimeSourceManager::writeData(SaveGameFileWriter* writer)
 	{
-		DOMElement* timesources = writer->appendChildElement(writer->getDocument(), 
-			writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
+		TiXmlElement* timesources = writer->appendChildElement(
+			writer->getDocument(), getXmlNodeIdentifier().c_str());
 
-		for(std::map<TimeSource::TimeSourceType, TimeSource*>::const_iterator it_time_sources = mTimeSources.begin(); 
+		for (std::map<TimeSource::TimeSourceType, TimeSource*>::const_iterator it_time_sources = mTimeSources.begin();
 			it_time_sources != mTimeSources.end(); it_time_sources++)
         {
-            DOMElement* timesource = writer->appendChildElement(writer->getDocument(), timesources, "time_source");
+            TiXmlElement* timesource = writer->appendChildElement(timesources, "time_source");
 			writer->setAttributeValueAsInteger(timesource, "ID", it_time_sources->first);
 			Property time((int)it_time_sources->second->getClock());
 
@@ -202,33 +200,25 @@
 
 	void TimeSourceManager::readData(SaveGameFileReader* reader)
 	{
-		reader->initializeXml();
+		XmlElementList rootNodeList = reader->getElementsByTagName(reader->getDocument()->RootElement(), getXmlNodeIdentifier().c_str());
 
-		DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-		if(rootNodeList->getLength())
+		if (!rootNodeList.empty())
         {
-			DOMNodeList* xmlTimeSources = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("gameobject").data()); //there should be only one "gameobjects" node
-            if(xmlTimeSources->getLength())
-            {
-				for(XMLSize_t childIdx = 0; childIdx < xmlTimeSources->getLength(); childIdx++)
+			XmlElementList xmlTimeSources = reader->getElementsByTagName(rootNodeList[0], "gameobject"); //there should be only one "gameobjects" node
+			for (XmlElementList::iterator it = xmlTimeSources.begin(); it != xmlTimeSources.end(); ++it)
+			{
+				const TiXmlElement* xmlTimeSource = *it;
+				TimeSource::TimeSourceType ID = (TimeSource::TimeSourceType)reader->getAttributeValueAsInteger(
+					xmlTimeSource, "ID");
+				PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlTimeSource);
+
+				std::map<TimeSource::TimeSourceType, TimeSource*>::const_iterator it_time_sources = mTimeSources.find(ID);
+				if (it_time_sources != mTimeSources.end())
 				{
-					DOMNode* xmlTimeSource = xmlTimeSources->item(childIdx);
-					if(xmlTimeSource->getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-						TimeSource::TimeSourceType ID = (TimeSource::TimeSourceType)reader->getAttributeValueAsInteger(
-							static_cast<DOMElement*>(xmlTimeSource), "ID");
-                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(static_cast<DOMElement*>(xmlTimeSource));
-	
-						std::map<TimeSource::TimeSourceType, TimeSource*>::const_iterator it_time_sources = mTimeSources.find(ID);
-						if(it_time_sources != mTimeSources.end())
-							it_time_sources->second->setClock(properties->toPropertyMap()["time"].toInt());
-                    }
+					it_time_sources->second->setClock(properties->toPropertyMap()["time"].toInt());
 				}
 			}
 		}
-
-		reader->shutdownXml();
 	}
     
     int TimeSourceManager::getPriority() const

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -559,11 +559,9 @@
         return "zonemanager";
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void ZoneManager::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* zoneManagerNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
+        TiXmlElement* zoneManagerNode = writer->appendChildElement(writer->getDocument()->RootElement(), getXmlNodeIdentifier().c_str());
 
         // look at all zones if they need to be saved
         for(ZoneMap::iterator zone = mZones.begin(); zone != mZones.end(); zone++)
@@ -571,7 +569,7 @@
             // does this zone wants to be saved
             if( zone->second->needsToBeSaved() )
             {
-                DOMElement* zoneNode = writer->appendChildElement(writer->getDocument(), zoneManagerNode, "zone");
+                TiXmlElement* zoneNode = writer->appendChildElement(zoneManagerNode, "zone");
                 writer->setAttributeValueAsStdString(zoneNode, "name", zone->first);
                     
                 
@@ -579,7 +577,7 @@
                 GameAreaEventSourceList::iterator gam; ;
                 for( gam = zone->second->getEventSources().begin(); gam != zone->second->getEventSources().end(); gam++)
                 {
-                    DOMElement* areaNode = writer->appendChildElement(writer->getDocument(), zoneNode, "area");
+                    TiXmlElement* areaNode = writer->appendChildElement(zoneNode, "area");
                     writer->writeEachPropertyToElem(areaNode, (*gam)->mProperties.toPropertyMap());
                 }
 
@@ -611,41 +609,27 @@
 
         // load zones
         // initialize xmlreader
-        reader->initializeXml();
+        XmlElementList rootNodeList = reader->getElementsByTagName(reader->getDocument(), getXmlNodeIdentifier().c_str());
 
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList->getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNodeList* xmlZones = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("zone").data());
-            if(xmlZones->getLength())
-            {
-                for(XMLSize_t childIdx1 = 0; childIdx1 < xmlZones->getLength(); childIdx1++)
-                {
-                    DOMNode* xmlZone = xmlZones->item(childIdx1);
-                    if(xmlZone->getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        Ogre::String name = reader->getAttributeValueAsStdString(static_cast<DOMElement*>(xmlZone), "name");
-                        Zone* zone = createZone(name, true);
+            XmlElementList xmlZones = reader->getElementsByTagName(rootNodeList[0], "zone");
 
-                        DOMNodeList* xmlAreas = static_cast<DOMElement*>(xmlZone)->getElementsByTagName(AutoXMLCh("area").data());
-                        if( xmlAreas->getLength() )
-                        {
-                            for(XMLSize_t childIdx2 = 0; childIdx2 < xmlAreas->getLength(); childIdx2++)
-                            {
-                                DOMNode* xmlArea = xmlAreas->item(childIdx2);
-                                PropertyRecordPtr properties = reader->getPropertiesAsRecord(static_cast<DOMElement*>(xmlArea));
-                                parseAreaProperties(name, properties);
-                            }
-                        }
-                    }
-                }
-            }
-        }
+			for (XmlElementList::iterator it = xmlZones.begin(); it != xmlZones.end(); ++it)
+			{
+				const TiXmlElement* xmlZone = *it;
+				Ogre::String name = reader->getAttributeValueAsStdString(xmlZone, "name");
+				Zone* zone = createZone(name, true);
 
-
-        // close xmlreader
-        reader->shutdownXml();
+				XmlElementList xmlAreas = reader->getElementsByTagName(xmlZone, "area");
+				for (XmlElementList::iterator itA = xmlAreas.begin(); itA != xmlAreas.end(); ++itA)
+				{
+					const TiXmlElement* xmlArea = *itA;
+					PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlArea);
+					parseAreaProperties(name, properties);
+				}
+			}
+        }
     }
 
     void ZoneManager::parseAreaProperties(const Ogre::String& name, const PropertyRecordPtr properties)

Modified: rl/trunk/engine/rules/CMakeLists.txt
===================================================================
--- rl/trunk/engine/rules/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -2,7 +2,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include
 ${RL_COMMON_INCLUDE_DIR}
 ${RL_CORE_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR})

Modified: rl/trunk/engine/rules/include/DsaDataLoader.h
===================================================================
--- rl/trunk/engine/rules/include/DsaDataLoader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/include/DsaDataLoader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,9 +17,6 @@
 #ifndef __XdimlLoader_H__
 #define __XdimlLoader_H__
 
-#include <xercesc/dom/DOMDocument.hpp>
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "XmlProcessor.h"
 
 namespace rl {
@@ -29,8 +26,7 @@
 	class Kampftechnik;
 
     class XdimlLoader 
-        : public Ogre::ScriptLoader,
-        private XmlProcessor
+        : public Ogre::ScriptLoader, private XmlProcessor
 	{
     public:
         XdimlLoader();
@@ -42,14 +38,14 @@
     private:
 		int getEBeFromString(const Ogre::String& eBeString);
 
-		void initializeTalente(XERCES_CPP_NAMESPACE::DOMElement* rootTalente);
-		Talent* processTalent(int gruppe, XERCES_CPP_NAMESPACE::DOMElement* talentXml);
+		void initializeTalente(const TiXmlElement* rootTalente);
+		Talent* processTalent(int gruppe, const TiXmlElement* talentXml);
 
-		void initializeCreatures(XERCES_CPP_NAMESPACE::DOMElement* rootCreatures);
-		Creature* processCreature(XERCES_CPP_NAMESPACE::DOMElement* talentXml);
+		void initializeCreatures(const TiXmlElement* rootCreatures);
+		Creature* processCreature(const TiXmlElement* talentXml);
 			
-		void initializeKampftechniken(XERCES_CPP_NAMESPACE::DOMElement* rootKampftechniken);
-		Kampftechnik* processKampftechnik(XERCES_CPP_NAMESPACE::DOMElement* kampftechnikXml);
+		void initializeKampftechniken(const TiXmlElement* rootKampftechniken);
+		Kampftechnik* processKampftechnik(const TiXmlElement* kampftechnikXml);
 
         Ogre::StringVector mScriptPatterns;
     };

Modified: rl/trunk/engine/rules/include/QuestBook.h
===================================================================
--- rl/trunk/engine/rules/include/QuestBook.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/include/QuestBook.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -96,6 +96,7 @@
     virtual const Ogre::StringVector &getScriptPatterns(void) const;
     virtual void parseScript(Ogre::DataStreamPtr &,const Ogre::String &);
     virtual Ogre::Real getLoadingOrder(void) const;
+
 private:
     Ogre::StringVector mScriptPatterns;
 
@@ -112,7 +113,7 @@
     void fireJournalChanged(JournalEntry* entry, int reason);
 
     //loading quests from xml
-    virtual Quest* processQuest(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, Quest* parent);
+    virtual Quest* processQuest(TiXmlElement* dialogXml, Quest* parent);
 };
 
 }

Modified: rl/trunk/engine/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaDataLoader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/src/DsaDataLoader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -15,14 +15,11 @@
  */
 #include "stdinc.h" //precompiled header
 
-#include <xercesc/dom/DOM.hpp>
-
 // #include "XdimlLoader.h"
 #include "DsaDataLoader.h"
 
 
 #include "XmlProcessor.h"
-#include "OgreXercesInput.h"
 
 #include "DsaManager.h"
 #include "Talent.h"
@@ -33,13 +30,10 @@
 
 #include "Exception.h"
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
 
-	using XERCES_CPP_NAMESPACE::DOMDocument; //XXX: Warum brauche ich das unter VS 2003?
-
     XdimlLoader::XdimlLoader()
         : ScriptLoader()
     {
@@ -50,17 +44,12 @@
 
     void XdimlLoader::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
     {
-        initializeXml();
+		TiXmlDocument* doc = loadDocument(stream);
+		TiXmlElement* dataDocumentContent = getChildNamed(doc->RootElement(), "Inhalt");
 
-		DOMDocument* doc = loadDocument(stream);
-		DOMElement* dataDocumentContent = getChildNamed(
-            doc->getDocumentElement(), "Inhalt");
-
 		initializeTalente(getChildNamed(dataDocumentContent, "Talente"));
 		initializeKampftechniken(getChildNamed(dataDocumentContent, "Kampftechniken"));
 		initializeCreatures(getChildNamed(dataDocumentContent, "Personen"));
-
-        shutdownXml();
     }
 
     const StringVector& XdimlLoader::getScriptPatterns() const
@@ -73,42 +62,41 @@
         return 1000.0;
     }
 
-    void XdimlLoader::initializeTalente(DOMElement* rootTalente)
+    void XdimlLoader::initializeTalente(const TiXmlElement* rootTalente)
     {
 		if (rootTalente == NULL)
 			return;
 
-	    DOMNodeList* talentGruppen =
-            rootTalente->getElementsByTagName(AutoXMLCh("Talentgruppe").data());
-        for (unsigned int gruppe = 0; gruppe < talentGruppen->getLength(); gruppe++)
+	    XmlElementList talentGruppen = getElementsByTagName(rootTalente, "Talentgruppe");
+        for (unsigned int gruppe = 0; gruppe < talentGruppen.size(); gruppe++)
 		{
-			DOMElement* gruppeData = static_cast<DOMElement*>(talentGruppen->item(gruppe));
-			DOMNodeList* talenteXml =
-                gruppeData->getElementsByTagName(AutoXMLCh("Talent").data());
+        	const TiXmlElement* gruppeData = talentGruppen[gruppe];
+			XmlElementList talenteXml = getElementsByTagName(gruppeData, "Talent");
             //int numTalent = 0;
-            for (unsigned int talentIdx = 0; talentIdx < talenteXml->getLength(); talentIdx++)
+            for (unsigned int talentIdx = 0; talentIdx < talenteXml.size(); talentIdx++)
             {
-                Talent* t = processTalent(gruppe, static_cast<DOMElement*>(talenteXml->item(talentIdx)));
+                Talent* t = processTalent(gruppe, talenteXml[talentIdx]);
                 //numTalent++;
 				DsaManager::getSingleton()._addTalent(t);
             }
 		}
     }
 
-    Talent* XdimlLoader::processTalent(int gruppe, DOMElement* talentXml)
+    Talent* XdimlLoader::processTalent(int gruppe, const TiXmlElement* talentXml)
     {
 		CeGuiString desc = getValueAsString(getChildNamed(talentXml, "Beschreibung"));
         CeGuiString probe = getValueAsString(getChildNamed(talentXml, "Probe"));
         CeGuiString art = getValueAsString(getChildNamed(talentXml, "Art"));
-		DOMElement* eBeNode = getChildNamed(talentXml, "eBE");
-        DOMElement* ausweichTalenteNode = static_cast<DOMElement*>(getChildNamed(talentXml, "Ausweichtalente"));
+        const TiXmlElement* eBeNode = getChildNamed(talentXml, "eBE");
+        const TiXmlElement* ausweichTalenteNode = getChildNamed(talentXml, "Ausweichtalente");
 
 		int ebe = EBE_KEINE_BE;
         if (eBeNode != NULL)
-			ebe = getEBeFromString(AutoChar(eBeNode->getFirstChild()->getNodeValue()).data());
+        {
+			ebe = getEBeFromString(eBeNode->FirstChild()->Value());
+        }
 
-		CeGuiString name = transcodeToString(
-            talentXml->getAttribute(AutoXMLCh("ID").data()));
+		CeGuiString name = getAttributeValueAsString(talentXml, "ID");
         EigenschaftTripel eigenschaften;
 		eigenschaften.first = probe.substr(0,2);
         eigenschaften.second = probe.substr(3,2);
@@ -119,16 +107,13 @@
         Talent::AusweichTalente ausweichTalente;
         if( ausweichTalenteNode )
         {
-	        DOMNodeList* ausweichTalentGruppen =
-                ausweichTalenteNode->getElementsByTagName(AutoXMLCh("Ausweichtalent").data());
-            for( unsigned int ausweich = 0; ausweich < ausweichTalentGruppen->getLength(); ausweich++ )
+	        XmlElementList ausweichTalentGruppen = getElementsByTagName(ausweichTalenteNode, "Ausweichtalent");
+            for( unsigned int ausweich = 0; ausweich < ausweichTalentGruppen.size(); ausweich++ )
             {
-			    DOMElement* ausweichData = static_cast<DOMElement*>(ausweichTalentGruppen->item(ausweich));
-	            CeGuiString ausweichName = transcodeToString(
-                    ausweichData->getAttribute(AutoXMLCh("ID").data()));
+            	const TiXmlElement* ausweichData = ausweichTalentGruppen[ausweich];
+	            CeGuiString ausweichName = getAttributeValueAsString(ausweichData, "ID");
 
-                ausweichTalente[ausweichName] = 
-                    getValueAsInteger(getChildNamed(ausweichData, "Aufschlag"));
+                ausweichTalente[ausweichName] = getValueAsInteger(getChildNamed(ausweichData, "Aufschlag"));
             }
         }
 
@@ -147,35 +132,41 @@
 	int XdimlLoader::getEBeFromString(const Ogre::String& eBeString)
 	{
 		if (eBeString.length() == 0)
+		{
 			return EBE_KEINE_BE;
+		}
 
 		if (!(eBeString.substr(0, 2).compare("BE")) == 0)
+		{
 			Throw(IllegalArgumentException, "Ungueltige EBE-Angabe.");
+		}
 
 		Ogre::String ebe = eBeString.substr(2);
 		if (ebe.compare("x2") == 0)
+		{
 			return EBE_BEx2;
+		}
 		if (ebe.compare("") == 0)
+		{
 			return 0;
+		}
 		return atoi(ebe.c_str());
 	}
 
-    void XdimlLoader::initializeKampftechniken(DOMElement* rootKampftechniken)
+    void XdimlLoader::initializeKampftechniken(const TiXmlElement* rootKampftechniken)
     {
 		if (rootKampftechniken == NULL)
 			return;
 
-		DOMNodeList* kampfarten =
-            rootKampftechniken->getElementsByTagName(AutoXMLCh("Kampfart").data());
-		for (unsigned int art = 0; art < kampfarten->getLength(); art++)
+		XmlElementList kampfarten = getElementsByTagName(rootKampftechniken, "Kampfart");
+		for (unsigned int art = 0; art < kampfarten.size(); art++)
 		{
-			DOMElement* artData = static_cast<DOMElement*>(kampfarten->item(art));
-			DOMNodeList* kampftechnikenXml =
-                artData->getElementsByTagName(AutoXMLCh("Kampftechnik").data());
+			const TiXmlElement* artData = kampfarten[art];
+			XmlElementList kampftechnikenXml = getElementsByTagName(artData, "Kampftechnik");
 			int numKampftechnik = 0;
-			for (unsigned int kampftechnikIdx = 0; kampftechnikIdx < kampftechnikenXml->getLength(); kampftechnikIdx++)
+			for (unsigned int kampftechnikIdx = 0; kampftechnikIdx < kampftechnikenXml.size(); kampftechnikIdx++)
 			{
-				Kampftechnik* k = processKampftechnik(static_cast<DOMElement*>(kampftechnikenXml->item(kampftechnikIdx)));
+				Kampftechnik* k = processKampftechnik(kampftechnikenXml[kampftechnikIdx]);
 				numKampftechnik++;
 				DsaManager::getSingleton()._addKampftechnik(k);
 			}
@@ -183,51 +174,40 @@
 
 	}
 
-	Kampftechnik* XdimlLoader::processKampftechnik(DOMElement* kampftechnikXml)
+	Kampftechnik* XdimlLoader::processKampftechnik(const TiXmlElement* kampftechnikXml)
 	{
 		CeGuiString desc = getValueAsString(getChildNamed(kampftechnikXml, "Beschreibung"));
 		CeGuiString art = getValueAsString(getChildNamed(kampftechnikXml, "Art"));
-		DOMElement* eBeNode = getChildNamed(kampftechnikXml, "eBE");
+		const TiXmlElement* eBeNode = getChildNamed(kampftechnikXml, "eBE");
 		int ebe = EBE_KEINE_BE;
 		if (eBeNode != NULL)
-			ebe = getEBeFromString(AutoChar(eBeNode->getFirstChild()->getNodeValue()).data());
+		{
+			ebe = getEBeFromString(getValueAsStdString(eBeNode));
+		}
 
-		CeGuiString name = transcodeToString(
-            kampftechnikXml->getAttribute(AutoXMLCh("ID").data()));
+		CeGuiString name = getAttributeValueAsString(kampftechnikXml, "ID");
 
-		Kampftechnik* k = new Kampftechnik(
-			name,
-			desc,
-			ebe);
-
+		Kampftechnik* k = new Kampftechnik(name, desc, ebe);
 		return k;
-
 	}
 
 
-	void XdimlLoader::initializeCreatures(DOMElement* rootPersons)
+	void XdimlLoader::initializeCreatures(const TiXmlElement* rootPersons)
 	{
 		if (rootPersons == NULL)
 			return;
 
-		DOMNodeList* personenXml = rootPersons->getElementsByTagName(AutoXMLCh("Person").data());
-		for (unsigned int idx = 0; idx < personenXml->getLength(); idx++)
+		XmlElementList personenXml = getElementsByTagName(rootPersons, "Person");
+		for (unsigned int idx = 0; idx < personenXml.size(); idx++)
 		{
-			Creature* p =
-				processCreature(
-					static_cast<DOMElement*>(personenXml->item(idx)));
+			Creature* p = processCreature(personenXml[idx]);
 			DsaManager::getSingleton()._addCreature(p);
 		}
 
 	}
 
-	Creature* XdimlLoader::processCreature(DOMElement* personXml)
+	Creature* XdimlLoader::processCreature(const TiXmlElement* personXml)
 	{
-		AutoXMLCh TALENT = "Talent";
-		AutoXMLCh ID = "ID";
-		AutoXMLCh ABGELEITETER_WERT = "AbgeleiteterWert";
-		AutoXMLCh EIGENSCHAFT = "Eigenschaft";
-
 		CeGuiString name =
 			getValueAsString(getChildNamed(personXml, "Name"));
 		CeGuiString desc =
@@ -239,14 +219,12 @@
         rval->setDescription(desc);
 
 		// Eigenschaften laden
-		DOMNodeList* eigensch =
-			getChildNamed(personXml, "Eigenschaften")->
-				getElementsByTagName(EIGENSCHAFT.data());
+		XmlElementList eigensch = getElementsByTagName(getChildNamed(personXml, "Eigenschaften"), "Eigenschaft");
 		// Die Eigenschaftsnamen mssen durch ihre Abkrzung ersetzt werden.
-		for (unsigned int idx = 0; idx < eigensch->getLength(); idx++)
+		for (unsigned int idx = 0; idx < eigensch.size(); idx++)
 		{
-			DOMElement* eigenschXml = static_cast<DOMElement*>(eigensch->item(idx));
-			CeGuiString eigName = transcodeToString(eigenschXml->getAttribute(ID.data()));
+			const TiXmlElement* eigenschXml = eigensch[idx];
+			CeGuiString eigName = getAttributeValueAsString(eigenschXml, "ID");
 			if (eigName == DsaManager::getSingleton().getEigenschaft(E_MUT)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_MUT)->getNameAbbreviation();
 			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KLUGHEIT)->getName())
@@ -269,16 +247,14 @@
 		}
 
 		// Abgeleitete Werte laden
-		DOMNodeList* werte =
-			getChildNamed(personXml, "AbgeleiteteWerte")->
-				getElementsByTagName(ABGELEITETER_WERT.data());
-		for (unsigned int idx = 0; idx < werte->getLength(); idx++)
+		XmlElementList werte = getElementsByTagName(getChildNamed(personXml, "AbgeleiteteWerte"), "AbgeleiteterWert");
+		for (unsigned int idx = 0; idx < werte.size(); idx++)
 		{
-			DOMElement* wertXml = static_cast<DOMElement*>(werte->item(idx));
+			const TiXmlElement* wertXml = werte[idx];
 			int basis = getValueAsInteger(getChildNamed(wertXml, "Basiswert"));
 			int wert = getValueAsInteger(getChildNamed(wertXml, "Wert"));
 
-			AutoChar wertId = wertXml->getAttribute(ID.data());
+			std::string wertId = getAttributeValueAsStdString(wertXml, "ID");
 			if (strcmp(wertId.data(), "Lebensenergie") == 0)
 				rval->setWert(rl::Creature::WERT_MOD_LE, wert - basis);
 			else if (strcmp(wertId.data(), "Ausdauer") == 0)
@@ -302,23 +278,17 @@
 		// Talente laden
 		// Talente, die direkt unter <Person> angeordnet sind,
         // ergeben bereits die zusammengefassten Werte
-		DOMNodeList* talente =
-			getChildNamed(personXml, "Talente")->
-				getElementsByTagName(TALENT.data());
-		for (unsigned int idx = 0; idx < talente->getLength(); idx++)
+		XmlElementList talente = getElementsByTagName(getChildNamed(personXml, "Talente"), "Talent");
+		for (unsigned int idx = 0; idx < talente.size(); idx++)
 		{
-			DOMElement* talentXml = static_cast<DOMElement*>(talente->item(idx));
+			const TiXmlElement* talentXml = talente[idx];
 
-			CeGuiString talentName = transcodeToString(
-                talentXml->getAttribute(ID.data()));
+			CeGuiString talentName = getAttributeValueAsString(talentXml, "ID");
 
-			Talent* tal =
-				DsaManager::getSingleton().getTalent(talentName);
+			Talent* tal = DsaManager::getSingleton().getTalent(talentName);
 
 			rval->addTalent(talentName);
-			rval->setTalent(
-				talentName,
-				getValueAsInteger(getChildNamed(talentXml, "Wert")));
+			rval->setTalent(talentName,	getValueAsInteger(getChildNamed(talentXml, "Wert")));
 		}
 		return rval;
 	}

Modified: rl/trunk/engine/rules/src/GlobalProperties.cpp
===================================================================
--- rl/trunk/engine/rules/src/GlobalProperties.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/src/GlobalProperties.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,8 +21,6 @@
 
 template<> rl::GlobalProperties* Ogre::Singleton<rl::GlobalProperties>::ms_Singleton = 0;
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
     GlobalProperties::GlobalProperties()
@@ -66,26 +64,21 @@
 
     void GlobalProperties::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* elem = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
-
+        TiXmlElement* elem = writer->appendChildElement(writer->getDocument()->RootElement(), getXmlNodeIdentifier().c_str());
         writer->writeEachPropertyToElem(elem, mProperties.toPropertyMap());
     }
 
     void GlobalProperties::readData(SaveGameFileReader* reader)
     {
-        reader->initializeXml();
-        
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-        if(rootNodeList->getLength())
+        XmlElementList rootNodeList = reader->getElementsByTagName(reader->getDocument(), getXmlNodeIdentifier().c_str());
+        if (!rootNodeList.empty())
         {
-            DOMElement* elem = static_cast<DOMElement*>(rootNodeList->item(0));
+        	const TiXmlElement* elem = rootNodeList[0];
 
             PropertyRecordPtr properties = reader->getPropertiesAsRecord(elem);
 
             setProperties(properties);
         }
-
-        reader->shutdownXml();
     }
 
     int GlobalProperties::getPriority() const

Modified: rl/trunk/engine/rules/src/QuestBook.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestBook.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/src/QuestBook.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -22,7 +22,6 @@
 #include "SaveGameManager.h"
 
 using namespace std;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl {
     const Ogre::String QuestBook::PROPERTY_QUESTS = "quests";
@@ -203,13 +202,13 @@
     PropertyArray QuestBook::getQuestsProperty(const Quest* rootQuest) const
     {
         PropertyArray parray;
-        if(rootQuest->hasSubquests())
+        if (rootQuest->hasSubquests())
         {
             QuestVector quests = rootQuest->getSubquests();
             for(unsigned int i = 0; i < quests.size(); i++)
             {
                 PropertyMap map = quests[i]->getAllProperties()->toPropertyMap();
-                if(quests[i]->hasSubquests())
+                if (quests[i]->hasSubquests())
                     map.insert(std::pair<CeGuiString, Property>("quests", getQuestsProperty(quests[i])));
                 parray.push_back(map);
             }
@@ -271,7 +270,7 @@
             }
 
             quest->setProperties(curVal);
-            if(curVal.find("quests") != curVal.end())
+            if (curVal.find("quests") != curVal.end())
             {
                 setQuestsProperty(curVal["quests"], quest);
             }            
@@ -354,23 +353,22 @@
 
     void QuestBook::parseScript(Ogre::DataStreamPtr& stream,const Ogre::String& groupname)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
+        TiXmlDocument* doc = loadDocument(stream);
         if (doc)
         {
-            for (DOMNode* cur = doc->getDocumentElement()->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+            for (TiXmlNode* cur = doc->RootElement()->FirstChild(); cur != NULL; cur = cur->NextSibling())
             {
-                if(hasNodeName(cur, "quest"))
+                if (hasNodeName(cur, "quest"))
                 {
-                    processQuest(static_cast<DOMElement*>(cur), mRootQuest);
+                    processQuest(cur->ToElement(), mRootQuest);
                 }
             }
+            delete doc;
         }
         else
+        {
             LOG_ERROR(Logger::RULES,"Quests XML is not valid!");
-
-        shutdownXml();
+        }
     }
 
     Ogre::Real QuestBook::getLoadingOrder(void) const
@@ -378,28 +376,34 @@
         return 1000;
     }
 
-    Quest* QuestBook::processQuest(XERCES_CPP_NAMESPACE::DOMElement* questXml, Quest* parent)
+    Quest* QuestBook::processQuest(TiXmlElement* questXml, Quest* parent)
     {
         Quest* quest = new Quest(getAttributeValueAsString(questXml, "id"));
         parent->addSubquest(quest);
         quest->setKnown(false);
         quest->setState(Quest::OPEN);
-        for (DOMNode* cur = questXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        for (TiXmlNode* cur = questXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
-            if(hasNodeName(cur, "name"))
-                quest->setProperty(Quest::PROPERTY_NAME,  Property(getValueAsString(static_cast<DOMElement*>(cur))));
-            
-            if(hasNodeName(cur, "description"))
-                quest->setProperty(Quest::PROPERTY_DESCRIPTION, Property(getValueAsString(static_cast<DOMElement*>(cur))));
-            
-            if(hasNodeName(cur, "known"))
-                quest->setKnown(getValueAsBool(static_cast<DOMElement*>(cur)));                
-            
-            if(hasNodeName(cur, "state"))
-                quest->setState(Quest::getStateFromName(getValueAsString(static_cast<DOMElement*>(cur))));
-
-            if(hasNodeName(cur, "quest"))
-                processQuest(static_cast<DOMElement*>(cur), quest);
+            if (hasNodeName(cur, "name"))
+            {
+                quest->setProperty(Quest::PROPERTY_NAME,  Property(getValueAsString(cur->ToElement())));
+            }
+            else if (hasNodeName(cur, "description"))
+            {
+                quest->setProperty(Quest::PROPERTY_DESCRIPTION, Property(getValueAsString(cur->ToElement())));
+            }
+            else if (hasNodeName(cur, "known"))
+            {
+                quest->setKnown(getValueAsBool(cur->ToElement()));
+            }
+            else if (hasNodeName(cur, "state"))
+            {
+                quest->setState(Quest::getStateFromName(getValueAsString(cur->ToElement())));
+            }
+            else if (hasNodeName(cur, "quest"))
+            {
+                processQuest(cur->ToElement(), quest);
+            }
         }
 
         return quest;

Modified: rl/trunk/engine/script/CMakeLists.txt
===================================================================
--- rl/trunk/engine/script/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -8,7 +8,7 @@
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}

Modified: rl/trunk/engine/script/include/AbstractMapNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/AbstractMapNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/AbstractMapNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,11 +16,8 @@
 #ifndef __AbstractMapNodeProcessor_H__
 #define __AbstractMapNodeProcessor_H__
 
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "ScriptPrerequisites.h"
 
-
 #include "XmlPropertyReader.h"
 
 namespace rl
@@ -33,7 +30,7 @@
     public:
         virtual ~AbstractMapNodeProcessor();
         
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects) = 0;
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects) = 0;
         
         void setRootSceneNode(Ogre::SceneNode* node);
 
@@ -41,10 +38,10 @@
         AbstractMapNodeProcessor();
     
         Ogre::String getRandomName(const Ogre::String& baseName) const;
-        Ogre::Vector3 processVector3(XERCES_CPP_NAMESPACE::DOMElement* nodeElem) const;
-		Ogre::Vector2 processVector2(XERCES_CPP_NAMESPACE::DOMElement* nodeElem) const;
-        Ogre::Quaternion processQuaternion(XERCES_CPP_NAMESPACE::DOMElement* nodeElem) const;
-        Ogre::ColourValue processColour(XERCES_CPP_NAMESPACE::DOMElement* colElem) const;
+        Ogre::Vector3 processVector3(const TiXmlElement* nodeElem) const;
+		Ogre::Vector2 processVector2(const TiXmlElement* nodeElem) const;
+        Ogre::Quaternion processQuaternion(const TiXmlElement* nodeElem) const;
+        Ogre::ColourValue processColour(const TiXmlElement* colElem) const;
         
         Ogre::SceneNode* getRootSceneNode() const;
         

Modified: rl/trunk/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __EntityNodeProcessor_H__
 #define __EntityNodeProcessor_H__
 
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "ScriptPrerequisites.h"
 
 #ifdef __APPLE__
@@ -35,13 +33,13 @@
     public:
         EntityNodeProcessor(const Ogre::String& resourcegroup);
 
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 
     private:
         Ogre::String mResourceGroup;
 
-        void createCollision(Ogre::Entity* entity, Ogre::String meshFile, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);
-		void processAnimation(Ogre::Entity* entity, XERCES_CPP_NAMESPACE::DOMElement *animationElem);
+        void createCollision(Ogre::Entity* entity, Ogre::String meshFile, const TiXmlElement* physicsProxyElem);
+		void processAnimation(Ogre::Entity* entity, const TiXmlElement *animationElem);
 	};
 }
 

Modified: rl/trunk/engine/script/include/EnvironmentProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EnvironmentProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/EnvironmentProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,9 +25,9 @@
 	class EnvironmentProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
-		void processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem);
-		void processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem);
+		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+		void processFogSettings(const TiXmlElement* fogElem);
+		void processSkySettings(const TiXmlElement* fogElem);
 	};
 }
 

Modified: rl/trunk/engine/script/include/GameObjectNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/GameObjectNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/GameObjectNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __GameObjectNodeProcessor_H__
 #define __GameObjectNodeProcessor_H__
 
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "ScriptPrerequisites.h"
 #include "AbstractMapNodeProcessor.h"
 
@@ -26,7 +24,7 @@
     class GameObjectNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/LightNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/LightNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/LightNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __LightNodeProcessor_H__
 #define __LightNodeProcessor_H__
 
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "ScriptPrerequisites.h"
 #include "AbstractMapNodeProcessor.h"
 
@@ -27,7 +25,7 @@
     class LightNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/MapLoader.h
===================================================================
--- rl/trunk/engine/script/include/MapLoader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/MapLoader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -74,7 +74,7 @@
         Ogre::StringVector mDefaultMaps;
 
         void setRootSceneNode(Ogre::SceneNode* node);
-        void processSceneNodes(XERCES_CPP_NAMESPACE::DOMElement* nodesElem, bool loadGameObjects);
+        void processSceneNodes(const TiXmlElement* nodesElem, bool loadGameObjects);
         void setLoadingPercentage(Ogre::Real percentage, const Ogre::String& text = "");
         bool changeScene(Ogre::StringVector mapsresources);
         void initialize(const Ogre::String& resourceGroup);

Modified: rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __ParticleSystemNodeProcessor_H__
 #define __ParticleSystemNodeProcessor_H__
 
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "ScriptPrerequisites.h"
 #include "AbstractMapNodeProcessor.h"
 
@@ -27,7 +25,7 @@
     class ParticleSystemNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/PlaneNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/PlaneNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/PlaneNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __PlaneNodeProcessor_H__
 #define __PlaneNodeProcessor_H__
 
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "ScriptPrerequisites.h"
 
 #ifdef __APPLE__
@@ -38,12 +36,12 @@
     public:
         PlaneNodeProcessor();
 
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 
     private:
 
-        void createCollision(Ogre::Entity* entity, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);
-		void createRenderToTextures(Ogre::Entity* entity, Ogre::Plane* plane, Ogre::MaterialPtr mat, XERCES_CPP_NAMESPACE::DOMElement* rttElem);
+        void createCollision(Ogre::Entity* entity, const TiXmlElement* physicsProxyElem);
+		void createRenderToTextures(Ogre::Entity* entity, Ogre::Plane* plane, Ogre::MaterialPtr mat, const TiXmlElement* rttElem);
 	};
 
 	class PlaneReflectionTextureListener : public Ogre::RenderTargetListener

Modified: rl/trunk/engine/script/include/SoundNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/SoundNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/SoundNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,18 +16,16 @@
 #ifndef __SoundNodeProcessor_H__
 #define __SoundNodeProcessor_H__
 
-#include <xercesc/dom/DOMElement.hpp>
-
 #include "ScriptPrerequisites.h"
+
 #include "AbstractMapNodeProcessor.h"
 
-
 namespace rl
 {
     class SoundNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/WaypointProcessor.h
===================================================================
--- rl/trunk/engine/script/include/WaypointProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/WaypointProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,7 +25,7 @@
 	class WaypointProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 	};
 }
 

Modified: rl/trunk/engine/script/include/ZoneProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ZoneProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/ZoneProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,7 +25,7 @@
 	class ZoneProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 	};
 }
 

Modified: rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,9 +17,7 @@
 
 #include "AbstractMapNodeProcessor.h"
 
-
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -33,7 +31,7 @@
     {
     }
 
-    Vector3 AbstractMapNodeProcessor::processVector3(DOMElement* vec3Elem) const
+    Vector3 AbstractMapNodeProcessor::processVector3(const TiXmlElement* vec3Elem) const
     {
         Vector3 rval(Vector3::ZERO);
         if (vec3Elem != NULL)
@@ -55,7 +53,7 @@
         return rval;
     }
 
-	Vector2 AbstractMapNodeProcessor::processVector2(DOMElement* vec2Elem) const
+	Vector2 AbstractMapNodeProcessor::processVector2(const TiXmlElement* vec2Elem) const
     {
         Vector2 rval(Vector2::ZERO);
         if (vec2Elem != NULL)
@@ -73,7 +71,7 @@
         return rval;
     }
 
-    Quaternion AbstractMapNodeProcessor::processQuaternion(DOMElement* quatElem) const
+    Quaternion AbstractMapNodeProcessor::processQuaternion(const TiXmlElement* quatElem) const
     {
         Quaternion rval(Quaternion::IDENTITY);
         if (quatElem != NULL)
@@ -99,7 +97,7 @@
         return rval;
     }
 
-    ColourValue AbstractMapNodeProcessor::processColour(DOMElement* colElem) const
+    ColourValue AbstractMapNodeProcessor::processColour(const TiXmlElement* colElem) const
     {
         ColourValue rval(1, 1, 1, 1);
         if (colElem != NULL)

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,14 +17,11 @@
 
 #include "EntityNodeProcessor.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "CoreSubsystem.h"
 #include "PhysicsManager.h"
 #include "World.h"
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -34,7 +31,7 @@
     {
     }
 
-    bool EntityNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool EntityNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "entity"))
         {
@@ -66,7 +63,7 @@
         Vector3 position(Vector3::ZERO);
         Quaternion orientation(Quaternion::IDENTITY);
 
-        DOMElement* posElem = getChildNamed(nodeElem, "position");
+        const TiXmlElement* posElem = getChildNamed(nodeElem, "position");
         if (posElem != NULL)
         {
             position = processVector3(posElem);
@@ -76,7 +73,7 @@
             LOG_WARNING(Logger::SCRIPT, "No position given for entity, used (0,0,0)");
         }
 
-        DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
+        const TiXmlElement* oriElem = getChildNamed(nodeElem, "rotation");
         if (oriElem != NULL)
         {
             orientation = processQuaternion(oriElem);
@@ -118,7 +115,7 @@
 
         parentNode->attachObject(newEnt);
 
-        DOMElement* scaleElem = getChildNamed(nodeElem, "scale");
+        const TiXmlElement* scaleElem = getChildNamed(nodeElem, "scale");
         if (scaleElem != NULL)
         {
             parentNode->scale(processVector3(scaleElem));
@@ -127,21 +124,17 @@
         // in order for the scale to work correctly the collision needs to be created after the scale was applied
         createCollision(newEnt, meshFile, getChildNamed(nodeElem, "physicsproxy"));
 
-		AutoXMLCh animation("animation");
-		DOMNodeList* list = nodeElem->getElementsByTagName(animation.data());
-		for (XMLSize_t idx = 0; idx < list->getLength(); idx++)
+		XmlElementList list = getElementsByTagName(nodeElem, "animation");
+		for (size_t idx = 0; idx < list.size(); idx++)
 		{
-			DOMNode* cur = list->item(idx);
-			if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-			{
-				processAnimation(newEnt, static_cast<DOMElement*>(cur));
-			}
+			const TiXmlElement* cur = list[idx];
+			processAnimation(newEnt, cur);
 		}
 
         return true;
     }
 
-    void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, DOMElement* physicsProxyElem)
+    void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, const TiXmlElement* physicsProxyElem)
 	{
         Ogre::String physicsProxyTypeAsString;
         if (physicsProxyElem == NULL || !hasAttribute(physicsProxyElem, "type"))
@@ -347,7 +340,7 @@
 */
     }
 
-	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, DOMElement *animationElem)
+	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, const TiXmlElement *animationElem)
 	{
 		///@todo EntityNodeProcessor::processAnimation
 	}

Modified: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,13 +21,12 @@
 #include "World.h"
 #include "XmlProcessor.h"
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 
 namespace rl
 {
-	bool EnvironmentProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+	bool EnvironmentProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
 	{
 		if (nodeElem)
 		{
@@ -38,7 +37,7 @@
 		return true;
 	}
 
-	void EnvironmentProcessor::processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* skyElem)
+	void EnvironmentProcessor::processSkySettings(const TiXmlElement* skyElem)
 	{
         if (skyElem)
 		{
@@ -70,7 +69,7 @@
 				    Ogre::Real curvature = 10;
 				    Ogre::Real tiling = 8;
 
-				    DOMElement* domeSettings = getChildNamed(skyElem, "skydomesettings");
+				    const TiXmlElement* domeSettings = getChildNamed(skyElem, "skydomesettings");
 				    if (domeSettings != NULL)
 				    {
 					    if (hasAttribute(domeSettings, "curvature"))
@@ -98,7 +97,7 @@
 	}
 
 
-	void EnvironmentProcessor::processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem)
+	void EnvironmentProcessor::processFogSettings(const TiXmlElement* fogElem)
 	{
         if (fogElem)
         {
@@ -110,7 +109,7 @@
 			    return;
 		    }
 
-		    DOMElement* colourElem = getChildNamed(fogElem, "colour");
+		    const TiXmlElement* colourElem = getChildNamed(fogElem, "colour");
 		    if (colourElem == NULL)
 		    {
 			    LOG_ERROR(Logger::RULES, "No fog colour set.");

Modified: rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,17 +17,14 @@
 
 #include "GameObjectNodeProcessor.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "GameObject.h"
 #include "GameObjectManager.h"
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool GameObjectNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool GameObjectNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "gameobject"))
         {
@@ -61,28 +58,25 @@
                 return true;
             }
 
-            DOMElement* posElem = getChildNamed(nodeElem, "position");
+            const TiXmlElement* posElem = getChildNamed(nodeElem, "position");
             if (posElem != NULL)
             {
                 Vector3 pos = processVector3(posElem);
                 go->setPosition(pos);
             }
 
-            DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
+            const TiXmlElement* oriElem = getChildNamed(nodeElem, "rotation");
             if (oriElem != NULL)
             {
                 Quaternion ori = processQuaternion(oriElem);
                 go->setOrientation(ori);
             }
 
-            DOMNodeList* goElChildNodes = nodeElem->getChildNodes();
-            for (XMLSize_t idx = 0; idx < goElChildNodes->getLength(); idx++)
+            for (const TiXmlNode* cur = nodeElem->FirstChild(); cur; cur = cur->NextSibling())
             {
-                DOMNode* cur = goElChildNodes->item(idx);
-                if (cur->getNodeType() == DOMNode::ELEMENT_NODE
-                    && hasNodeName(cur, "property"))
+                if (cur->Type() == TiXmlNode::ELEMENT && hasNodeName(cur, "property"))
                 {
-                    PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(cur));
+                    PropertyEntry propEntry = processProperty(cur->ToElement());
                     if (propEntry.first != "")
                     {
                         go->setProperty(propEntry.first, propEntry.second);

Modified: rl/trunk/engine/script/src/LightNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/LightNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/LightNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,11 +21,10 @@
 #include "ActorManager.h"
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool LightNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool LightNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "light"))
         {
@@ -61,7 +60,7 @@
         }
         Actor* lightActor = ActorManager::getSingleton().createLightActor(name, type);
 
-        DOMElement* posElem = getChildNamed(nodeElem, "position");
+        const TiXmlElement* posElem = getChildNamed(nodeElem, "position");
         if (posElem != NULL)
         {
             lightActor->placeIntoScene(processVector3(posElem));
@@ -76,19 +75,19 @@
         light->setCastShadows(shadowCaster);
         light->setActive(visible);
 
-        DOMElement* diffElem = getChildNamed(nodeElem, "colourDiffuse");
+        const TiXmlElement* diffElem = getChildNamed(nodeElem, "colourDiffuse");
         if (diffElem != NULL)
         {
             light->setDiffuseColour(processColour(diffElem));
         }
 
-        DOMElement* specElem = getChildNamed(nodeElem, "colourSpecular");
+        const TiXmlElement* specElem = getChildNamed(nodeElem, "colourSpecular");
         if (specElem != NULL)
         {
             light->setSpecularColour(processColour(specElem));
         }
 
-        DOMElement* attElem = getChildNamed(nodeElem, "lightAttenuation");
+        const TiXmlElement* attElem = getChildNamed(nodeElem, "lightAttenuation");
         if (attElem != NULL)
         {
             if (hasAttribute(attElem, "range")
@@ -108,7 +107,7 @@
 
         if (stype == "directional")
         {
-            DOMElement* dirElem = getChildNamed(nodeElem, "direction");
+        	const TiXmlElement* dirElem = getChildNamed(nodeElem, "direction");
             if (dirElem != NULL)
             {
                 light->setDirection(processVector3(dirElem));
@@ -120,7 +119,7 @@
         }
         else if (stype == "spot")
         {
-            DOMElement* rangeElem = getChildNamed(nodeElem, "spotlightrange");
+        	const TiXmlElement* rangeElem = getChildNamed(nodeElem, "spotlightrange");
             if (rangeElem != NULL)
             {
                 Ogre::Real innerAngle = getAttributeValueAsReal(rangeElem, "inner");

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 
 #include "MapLoader.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "AbstractMapNodeProcessor.h"
 #include "CoreSubsystem.h"
 #include "EntityNodeProcessor.h"
@@ -40,13 +38,10 @@
 #include "PlaneNodeProcessor.h"
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 using std::list;
 
 namespace rl {
 
-    using XERCES_CPP_NAMESPACE::DOMDocument; //XXX: for VS 2003/2005
-
     const CeGuiString MapLoader::PROPERTY_ACTIVEMAPS = "activemaps";
 
     MapLoader::MapLoader()
@@ -132,16 +127,16 @@
         {
             LOG_MESSAGE(Logger::RULES, "Loading map " + mapresource);
 
-  		    initializeXml();
+            TiXmlDocument* doc = loadDocument(mapresource, mResourceGroup);
 
-            DOMDocument* doc = loadDocument(mapresource, mResourceGroup);
-
             if (doc)
             {
                 setRootSceneNode(CoreSubsystem::getSingleton().getWorld()
                         ->getSceneManager()->getRootSceneNode()->createChildSceneNode(mapresource));
 
-                if(getAttributeValueAsString(doc->getDocumentElement(), "formatVersion") != "0.4.0")
+                TiXmlElement* dataDocumentContent = doc->RootElement();
+
+                if(getAttributeValueAsString(dataDocumentContent, "formatVersion") != "0.4.0")
                     LOG_ERROR(Logger::SCRIPT, "Map format version doesn't match with the required version");
 
 			    CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
@@ -149,7 +144,6 @@
 
                 LOG_MESSAGE(Logger::RULES, "Processing nodes");
 
-                DOMElement* dataDocumentContent = doc->getDocumentElement();
                 processSceneNodes(getChildNamed(dataDocumentContent, "nodes"), loadGameObjects);
 
 			    ZoneProcessor zp;
@@ -163,11 +157,11 @@
 
                 LOG_MESSAGE(Logger::SCRIPT, "Map " + mapresource + " loaded");
 
-                if(hasAttribute(doc->getDocumentElement(), "scenescript"))
+                if(hasAttribute(dataDocumentContent, "scenescript"))
                 {
-                    if(getAttributeValueAsString(doc->getDocumentElement(), "scenescript").length() != 0)
+                    if(getAttributeValueAsString(dataDocumentContent, "scenescript").length() != 0)
                     {
-                        if(!CoreSubsystem::getSingleton().getRubyInterpreter()->executeFile(getAttributeValueAsStdString(doc->getDocumentElement(), "scenescript")))
+                        if(!CoreSubsystem::getSingleton().getRubyInterpreter()->executeFile(getAttributeValueAsStdString(dataDocumentContent, "scenescript")))
                             LOG_MESSAGE(Logger::SCRIPT, "Executed init script of map " + mapresource);
                         else
                             LOG_ERROR(Logger::SCRIPT, "Error while executing init script of map " + mapresource);
@@ -183,8 +177,6 @@
                 LOG_ERROR(Logger::RULES, "Map resource '" + mapresource + "' not found");
             }
 
-            shutdownXml();
-            
             mLoadedMaps.push_back(mapresource);
         }
         else
@@ -256,7 +248,7 @@
         return keys;
     }
 
-    void MapLoader::processSceneNodes(DOMElement* nodesElem, bool loadGameObjects)
+    void MapLoader::processSceneNodes(const TiXmlElement* nodesElem, bool loadGameObjects)
     {
 		if (nodesElem == NULL)
 		{
@@ -264,16 +256,19 @@
 		}
 
         setLoadingPercentage(0, "Loading map nodes");
-        Ogre::Real numChildren = nodesElem->getChildNodes()->getLength();
+        Ogre::Real numChildren = 0;
+        for (const TiXmlNode* cur = nodesElem->FirstChild(); cur != NULL; cur = cur->NextSibling())
+        {
+        	numChildren++;
+        }
+
         int count = 0;
 
-        for (DOMNode* cur = nodesElem->getFirstChild();
-            cur != NULL;
-            cur = cur->getNextSibling())
+        for (const TiXmlNode* cur = nodesElem->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+            if (cur->Type() == TiXmlNode::ELEMENT)
             {
-                DOMElement* curElem = static_cast<DOMElement*>(cur);
+            	const TiXmlElement* curElem = cur->ToElement();
 
                 list<AbstractMapNodeProcessor*>::iterator it = mNodeProcessors.begin();
                 while (it != mNodeProcessors.end() && !(*it)->processNode(curElem, loadGameObjects))
@@ -284,7 +279,7 @@
                 if (it == mNodeProcessors.end())
                 {
                     LOG_WARNING(Logger::RULES,
-                        "Node " + transcodeToString(curElem->getNodeName()) + " could not be processed.");
+                        "Node " + Ogre::String(curElem->Value()) + " could not be processed.");
                 }
             }
 

Modified: rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -22,11 +22,10 @@
 #include "ParticleSystemObject.h"
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool ParticleSystemNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool ParticleSystemNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
 		if (!hasNodeName(nodeElem, "particlesystem"))
 		{

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 
 #include "PlaneNodeProcessor.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "CoreSubsystem.h"
 #include "PhysicsManager.h"
 #include "World.h"
@@ -26,7 +24,6 @@
 //#include <OgreMaterialManager.h>
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -34,7 +31,7 @@
 	{
 	}
 
-	bool PlaneNodeProcessor::processNode(DOMElement *nodeElem, bool loadGameObjects)
+	bool PlaneNodeProcessor::processNode(const TiXmlElement *nodeElem, bool loadGameObjects)
 	{
 		if (!hasNodeName(nodeElem, "plane"))
         {
@@ -46,7 +43,7 @@
 		LOG_DEBUG(Logger::RULES,
             "Processing plane node "
                 + entName);
-		if(entName=="")
+		if (entName=="")
 		{
 			entName = getRandomName("Plane");
 		}
@@ -55,7 +52,7 @@
 		Vector3 position(Vector3::ZERO);
 		Vector2 scale(1,1);
 
-		DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
+		const TiXmlElement* oriElem = getChildNamed(nodeElem, "rotation");
         if (oriElem != NULL)
         {
             orientation = processQuaternion(oriElem);
@@ -65,7 +62,7 @@
             LOG_WARNING(Logger::RULES, "No orientation given for plane, used Identity");
         }
 
-		DOMElement* posElem = getChildNamed(nodeElem, "position");
+        const TiXmlElement* posElem = getChildNamed(nodeElem, "position");
         if (posElem != NULL)
         {
             position = processVector3(posElem);
@@ -75,7 +72,7 @@
             LOG_WARNING(Logger::RULES, "No position given for plane, used (0,0,0)");
         }
 
-		DOMElement* scaleElem = getChildNamed(nodeElem, "scale");
+        const TiXmlElement* scaleElem = getChildNamed(nodeElem, "scale");
         if (posElem != NULL)
         {
             scale = processVector2(scaleElem);
@@ -108,10 +105,10 @@
 
 		createCollision(ent, getChildNamed(nodeElem, "physicsproxy"));
 		
-		DOMElement* materialElem = getChildNamed(nodeElem, "material");
-		if(materialElem)
+		const TiXmlElement* materialElem = getChildNamed(nodeElem, "material");
+		if (materialElem)
 		{	
-			if(getChildNamed(nodeElem, "renderToTexture"))
+			if (getChildNamed(nodeElem, "renderToTexture"))
 			{
 				Ogre::String matName = getAttributeValueAsStdString(materialElem, "name");
 				MaterialPtr material = static_cast<MaterialPtr>(MaterialManager::getSingleton().getByName(matName))->clone(matName + entName);
@@ -128,14 +125,14 @@
 		return true;
 	}
 
-	void PlaneNodeProcessor::createCollision(Ogre::Entity *entity, DOMElement *physicsProxyElem)
+	void PlaneNodeProcessor::createCollision(Ogre::Entity *entity, const TiXmlElement *physicsProxyElem)
 	{
 		bool collisionEnabled = false;
 		if (physicsProxyElem == NULL || !hasAttribute(physicsProxyElem, "collision"))
 			collisionEnabled = false;
-		else if(getAttributeValueAsBool(physicsProxyElem, "collision"))
+		else if (getAttributeValueAsBool(physicsProxyElem, "collision"))
 			collisionEnabled = true;
-		if(collisionEnabled)
+		if (collisionEnabled)
 		{
 			std::vector<OgreNewt::CollisionPtr> collisions;
 			OgreNewt::CollisionPtr collision = OgreNewt::CollisionPtr();
@@ -164,9 +161,9 @@
 		}
 	}
 
-	void PlaneNodeProcessor::createRenderToTextures(Ogre::Entity* entity, Plane* plane, MaterialPtr material, XERCES_CPP_NAMESPACE::DOMElement* rttElem)
+	void PlaneNodeProcessor::createRenderToTextures(Ogre::Entity* entity, Plane* plane, MaterialPtr material, const TiXmlElement* rttElem)
 	{
-		if(rttElem == NULL)
+		if (rttElem == NULL)
 			return;
 
 		Camera* cam = CoreSubsystem::getSingleton().getWorld()->getSceneManager()->createCamera("Cam" + entity->getName());
@@ -178,7 +175,7 @@
 
 		AliasTextureNamePairList aliases;
 
-		if(getAttributeValueAsBool(rttElem, "reflection"))
+		if (getAttributeValueAsBool(rttElem, "reflection"))
 		{
 			TexturePtr texture = Ogre::TextureManager::getSingleton().createManual( "Reflection" + entity->getName(), 
 				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, TEX_TYPE_2D, 
@@ -193,7 +190,7 @@
 
 			cam->enableCustomNearClipPlane((MovablePlane*)plane);
 		}
-		if(getAttributeValueAsBool(rttElem, "refraction"))
+		if (getAttributeValueAsBool(rttElem, "refraction"))
 		{
 			TexturePtr texture = Ogre::TextureManager::getSingleton().createManual( "Refraction" + entity->getName(), 
 				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, TEX_TYPE_2D, 
@@ -209,7 +206,7 @@
 			plane->normal = Vector3::NEGATIVE_UNIT_Y;
 			cam->enableCustomNearClipPlane((MovablePlane*)plane);
 		}
-		if(!material->applyTextureAliases(aliases))
+		if (!material->applyTextureAliases(aliases))
 			LOG_ERROR("PLANE", "Texture Aliase konnten nicht angewandt werden");
 	}
 

Modified: rl/trunk/engine/script/src/SceneLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneLoader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/SceneLoader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,30 +17,22 @@
 
 #include "SceneLoader.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #include "Scene.h"
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
 
 Scene* SceneLoader::loadScene(Ogre::DataStreamPtr &data)
 {
-    initializeXml();
-
-    DOMDocument* doc = loadDocument(data);
-    DOMElement* root = doc->getDocumentElement();
+    TiXmlDocument* doc = loadDocument(data);
+    TiXmlElement* root = doc->RootElement();
     Scene* scene = new Scene(getAttributeValueAsString(root, "name"));
     
-    DOMNodeList* children = root->getChildNodes();
-    for (XMLSize_t i = 0; i < children->getLength(); ++i)
+    for (TiXmlNode* cur = root->FirstChild(); cur; cur = cur->NextSibling())
     {
-        DOMNode* cur = children->item(i);
-        if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+        if (cur->Type() == TiXmlNode::ELEMENT)
         {
-            DOMElement* elem = static_cast<DOMElement*>(cur);
+            TiXmlElement* elem = cur->ToElement();
             if (hasNodeName(elem, "map"))
             {
                 scene->addMap(getAttributeValueAsStdString(elem, "file"));
@@ -48,7 +40,7 @@
         }
     }
 
-    shutdownXml();
+    delete doc;
 
     return scene;
 }

Modified: rl/trunk/engine/script/src/SoundNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -18,11 +18,10 @@
 #include "SoundNodeProcessor.h"
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool SoundNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool SoundNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "sound"))
         {
@@ -33,8 +32,6 @@
             "Processing sound node "
                 + getAttributeValueAsStdString(nodeElem, "name"));
 
-
-
         return false;
     }
 }

Modified: rl/trunk/engine/script/src/TriggerFactory.cpp
===================================================================
--- rl/trunk/engine/script/src/TriggerFactory.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/TriggerFactory.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -41,11 +41,9 @@
         return "triggerfactory";
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void TriggerFactory::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* triggerParentNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
+        TiXmlElement* triggerParentNode = writer->appendChildElement(writer->getDocument()->RootElement(), getXmlNodeIdentifier().c_str());
 
         const ZoneManager::ZoneMap &zoneMap(ZoneManager::getSingleton().getAllZones());
         ZoneManager::ZoneMap::const_iterator zone;
@@ -57,9 +55,9 @@
             // search for triggers in a zone
             for(std::list<Trigger*>::iterator trigger = allTriggers.begin(); trigger != allTriggers.end(); trigger++)
             {
-                if((*trigger)->needsToBeSaved())
+                if ((*trigger)->needsToBeSaved())
                 {
-                    DOMElement* triggerNode = writer->appendChildElement(writer->getDocument(), triggerParentNode, "trigger");
+                    TiXmlElement* triggerNode = writer->appendChildElement(triggerParentNode, "trigger");
                     writer->setAttributeValueAsStdString(triggerNode, "name", (*trigger)->getName());
                     writer->setAttributeValueAsStdString(triggerNode, "classname", (*trigger)->getClassName());
                     writer->setAttributeValueAsStdString(triggerNode, "zone", zone->first);
@@ -83,10 +81,10 @@
             // search for triggers in a zone
             for(std::list<Trigger*>::iterator trigger = allTriggers.begin(); trigger != allTriggers.end(); trigger++)
             {
-                if((*trigger)->needsToBeSaved())
+                if ((*trigger)->needsToBeSaved())
                 {
                     zone->second->removeTrigger((*trigger));
-                    if((*trigger)->deleteIfZoneDestroyed())
+                    if ((*trigger)->deleteIfZoneDestroyed())
                     {
                         //ScriptWrapper::getSingleton().owned((*trigger));
                         delete (*trigger);
@@ -96,52 +94,43 @@
             }
         }
 
+        XmlElementList rootNodeList = reader->getElementsByTagName(reader->getDocument(), getXmlNodeIdentifier().c_str());
 
-
-
-        // initialize xmlreader
-        reader->initializeXml();
-
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList->getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNodeList* xmlTriggerFactory = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("trigger").data());
-            if(xmlTriggerFactory->getLength())
-            {
-                for(XMLSize_t childIdx1 = 0; childIdx1 < xmlTriggerFactory->getLength(); childIdx1++)
-                {
-                    DOMNode* xmlTrigger = xmlTriggerFactory->item(childIdx1);
-                    if(xmlTrigger->getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        Ogre::String classname = reader->getAttributeValueAsStdString(static_cast<DOMElement*>(xmlTrigger), "classname");
-                        Ogre::String name = reader->getAttributeValueAsStdString(static_cast<DOMElement*>(xmlTrigger), "name");
-                        Ogre::String zoneName = reader->getAttributeValueAsStdString(static_cast<DOMElement*>(xmlTrigger), "zone");
+            XmlElementList xmlTriggerFactory = reader->getElementsByTagName(rootNodeList[0], "trigger");
+			for (XmlElementList::iterator it = xmlTriggerFactory.begin(); it != xmlTriggerFactory.end(); ++it)
+			{
+				const TiXmlNode* xmlTrigger = *it;
+				if (xmlTrigger->Type() == TiXmlNode::ELEMENT)
+				{
+					const TiXmlElement* xmlTriggerElem = xmlTrigger->ToElement();
+					Ogre::String classname = reader->getAttributeValueAsStdString(xmlTriggerElem, "classname");
+					Ogre::String name = reader->getAttributeValueAsStdString(xmlTriggerElem, "name");
+					Ogre::String zoneName = reader->getAttributeValueAsStdString(xmlTriggerElem, "zone");
 
-                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(static_cast<DOMElement*>(xmlTrigger));
+					PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlTriggerElem);
 
 
-                        Trigger *trigger = createTrigger(classname, name);
-                        if( trigger ) // if not, there is an error-msg from the script!
-                        {
-                            trigger->setProperties(properties);
-                            Zone *zone = ZoneManager::getSingleton().getZone(zoneName);
-                            if(zone == NULL)
-                            {
-                                LOG_ERROR(Logger::SCRIPT, "Tried to load trigger for zone '"+zoneName+"', but the zone could not be found!");
-                                delete trigger;
-                            }
-                            else
-                                zone->addTrigger(trigger);
-                        }
+					Trigger *trigger = createTrigger(classname, name);
+					if (trigger) // if not, there is an error-msg from the script!
+					{
+						trigger->setProperties(properties);
+						Zone *zone = ZoneManager::getSingleton().getZone(zoneName);
+						if (zone == NULL)
+						{
+							LOG_ERROR(Logger::SCRIPT, "Tried to load trigger for zone '"+zoneName+"', but the zone could not be found!");
+							delete trigger;
+						}
+						else
+						{
+							zone->addTrigger(trigger);
+						}
+					}
 
-                    }
-                }
-            }
+				}
+			}
         }
-
-        // close xmlreader
-        reader->shutdownXml();
     }
 
     int TriggerFactory::getPriority() const

Modified: rl/trunk/engine/script/src/WaypointProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/WaypointProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/WaypointProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,25 +21,24 @@
 #include "Landmark.h"
 #include "LandmarkPath.h"
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl
 {
-	bool WaypointProcessor::processNode(DOMElement* nodeElem, bool loadGameObjects)
+	bool WaypointProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
 	{
 		if (nodeElem == NULL)
 		{
 			return false;
 		}
 
-		for (DOMNode* cur = nodeElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+		for (const TiXmlNode* cur = nodeElem->FirstChild(); cur != NULL; cur = cur->NextSibling())
 		{
-			if (cur->getNodeType() == DOMNode::ELEMENT_NODE && hasNodeName(cur, "landmark"))
+			if (cur->Type() == TiXmlNode::ELEMENT && hasNodeName(cur, "landmark"))
 			{
-				DOMElement* elem = static_cast<DOMElement*>(cur);
+				const TiXmlElement* elem = cur->ToElement();
 				Ogre::String name = getAttributeValueAsStdString(elem, "name");
-				DOMElement* posChild = getChildNamed(elem, "position");
+				const TiXmlElement* posChild = getChildNamed(elem, "position");
 				if (name != "" && posChild != NULL)
 				{
 					AiSubsystem::getSingleton().createLandmark(
@@ -48,23 +47,23 @@
 			}
 		}
 
-		for (DOMNode* cur = nodeElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+		for (const TiXmlNode* cur = nodeElem->FirstChild(); cur != NULL; cur = cur->NextSibling())
 		{
-			if (cur->getNodeType() == DOMNode::ELEMENT_NODE && hasNodeName(cur, "landmarkgraph"))
+			if (cur->Type() == TiXmlNode::ELEMENT && hasNodeName(cur, "landmarkgraph"))
 			{
-				DOMElement* elem = static_cast<DOMElement*>(cur);
+				const TiXmlElement* elem = cur->ToElement();
 				///@todo process waypointgraph
 				Ogre::String name;
 
 				LandmarkPath* path = AiSubsystem::getSingleton().createLandmarkPath(name);
 
-				for (DOMNode* curPathChild = nodeElem->getFirstChild();
-					curPathChild != NULL; curPathChild = curPathChild->getNextSibling())
+				for (const TiXmlNode* curPathChild = nodeElem->FirstChild();
+					curPathChild != NULL; curPathChild = curPathChild->NextSibling())
 				{
-					if (curPathChild->getNodeType() == DOMNode::ELEMENT_NODE
+					if (curPathChild->Type() == TiXmlNode::ELEMENT
 						&& hasNodeName(curPathChild, "landmark"))
 					{
-						DOMElement* curLmElem = static_cast<DOMElement*>(curPathChild);
+						const TiXmlElement* curLmElem = curPathChild->ToElement();
 						Landmark* lm = AiSubsystem::getSingleton().getLandmark(
 							getAttributeValueAsStdString(curLmElem, "name"));
 

Modified: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,25 +25,24 @@
 #include "Zone.h"
 #include "ZoneManager.h"
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl
 {
 
-	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
+	bool ZoneProcessor::processNode(const TiXmlElement* zonesElem, bool loadGameObjects)
 	{
 		if (zonesElem == NULL)
 		{
 			return false; // no zones
 		}
 
-        for (DOMNode* cur = zonesElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        for (const TiXmlNode* cur = zonesElem->FirstChild(); cur != NULL; cur = cur->NextSibling())
         {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE
+            if (cur->Type() == TiXmlNode::ELEMENT
 				&& hasNodeName(cur, "zone"))
             {
-				DOMElement* curZoneElem = static_cast<DOMElement*>(cur);
+            	const TiXmlElement* curZoneElem = cur->ToElement();
 				if (hasAttribute(curZoneElem, "name"))
 				{
 					Ogre::String name = getAttributeValueAsStdString(curZoneElem, "name");
@@ -62,12 +61,12 @@
                         }
 
                         // multiple areas
-                        for(DOMNode* curArea = cur->getFirstChild(); curArea != NULL; curArea = curArea->getNextSibling())
+                        for (const TiXmlNode* curArea = cur->FirstChild(); curArea != NULL; curArea = curArea->NextSibling())
                         {
-                            if (curArea->getNodeType() == DOMNode::ELEMENT_NODE
+                            if (curArea->Type() == TiXmlNode::ELEMENT
                                 && hasNodeName(curArea, "area"))
                             {
-                                DOMElement *curAreaElem = static_cast<DOMElement*>(curArea);
+                            	const TiXmlElement *curAreaElem = curArea->ToElement();
                                 if (hasAttribute(curAreaElem, "type"))
                                 {
                                     // type
@@ -83,7 +82,7 @@
 
                                     // position
                                     Vector3 position = Vector3::ZERO;
-                                    DOMElement* positionElem = getChildNamed(curAreaElem, "position");
+                                    const TiXmlElement* positionElem = getChildNamed(curAreaElem, "position");
                                     if (positionElem)
                                     {
                                         position = getValueAsVector3(positionElem);
@@ -91,7 +90,7 @@
 
                                     //scale, rotation, offset
                                     Vector3 scale = Vector3::UNIT_SCALE;
-                                    DOMElement* scaleElem = getChildNamed(curAreaElem, "scale");
+                                    const TiXmlElement* scaleElem = getChildNamed(curAreaElem, "scale");
                                     if (!scaleElem)
                                     {
                                         scaleElem = getChildNamed(curAreaElem, "size");
@@ -103,14 +102,14 @@
                                     }
 
                                     Vector3 offset = Vector3::ZERO;
-                                    DOMElement* offsetElem = getChildNamed(curAreaElem, "offset");
+                                    const TiXmlElement* offsetElem = getChildNamed(curAreaElem, "offset");
                                     if (offsetElem)
                                     {
                                         offset = getValueAsVector3(offsetElem);
                                     }
 
                                     Quaternion rotation = Quaternion::IDENTITY;
-                                    DOMElement* rotationElem = getChildNamed(curAreaElem, "rotation");
+                                    const TiXmlElement* rotationElem = getChildNamed(curAreaElem, "rotation");
                                     if (rotationElem)
                                     {
                                         rotation = getValueAsQuaternion(rotationElem);
@@ -118,7 +117,7 @@
 
                                     //transition distance
                                     Real transitionDistance = 0;
-                                    DOMElement* transitionElem = getChildNamed(curAreaElem, "transition_distance");
+                                    const TiXmlElement* transitionElem = getChildNamed(curAreaElem, "transition_distance");
                                     if (transitionElem)
                                     {
                                         transitionDistance = getValueAsReal(transitionElem);
@@ -199,11 +198,11 @@
 
 					if (zone)
 					{
-						for (DOMNode* cur = curZoneElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+						for (const TiXmlNode* cur = curZoneElem->FirstChild(); cur != NULL; cur = cur->NextSibling())
 						{
-							if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+							if (cur->Type() == TiXmlNode::ELEMENT)
 							{
-								DOMElement* curElem = static_cast<DOMElement*>(cur);
+								const TiXmlElement* curElem = cur->ToElement();
 								if (hasNodeName(curElem, "light"))
 								{
 									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
@@ -226,11 +225,11 @@
 										->createTrigger(classname, name);
 
                                     // add trigger properties
-                                    for( DOMNode* curProperty = cur->getFirstChild(); curProperty != NULL; curProperty = curProperty->getNextSibling())
+                                    for (const TiXmlNode* curProperty = cur->FirstChild(); curProperty != NULL; curProperty = curProperty->NextSibling())
                                     {
                                         if (hasNodeName(curProperty, "property"))
                                         {
-                                            PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(curProperty));
+                                            PropertyEntry propEntry = processProperty(curProperty->ToElement());
                                             if (propEntry.first != "")
                                             {
                                                 trigger->setProperty(propEntry.first, propEntry.second);

Modified: rl/trunk/engine/startup/CMakeLists.txt
===================================================================
--- rl/trunk/engine/startup/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/startup/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -5,7 +5,7 @@
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
 ${RL_SCRIPT_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
@@ -16,6 +16,6 @@
 
 ADD_EXECUTABLE(rastullah ${Rastullah_APP_SRCS})
 
-TARGET_LINK_LIBRARIES(rastullah RlCommon RlCore RlRules RlAi RlUi RlScript)
+TARGET_LINK_LIBRARIES(rastullah RlCommon RlCore RlRules RlAi RlUi RlScript ${TINYXML_LIBRARY})
 
 INSTALL(TARGETS rastullah RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/${BINDIR})

Modified: rl/trunk/engine/startup/src/RastullahMain.cpp
===================================================================
--- rl/trunk/engine/startup/src/RastullahMain.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/startup/src/RastullahMain.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -14,8 +14,6 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
-#include <xercesc/util/XMemory.hpp>    // Muss vor Ogre stehen (zumindest fuer VS)
-
 #include <stdexcept>
 #include <errno.h>
 

Modified: rl/trunk/engine/ui/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ui/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ui/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -4,7 +4,7 @@
 ${RL_CORE_INCLUDE_DIR}
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${OIS_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}

Modified: rl/trunk/engine/ui/include/UiPrerequisites.h
===================================================================
--- rl/trunk/engine/ui/include/UiPrerequisites.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ui/include/UiPrerequisites.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 #ifndef __UiPrerequisites_H__
 #define __UiPrerequisites_H__
 
-#include <xercesc/util/XMemory.hpp>	// Muss vor Ogre stehen (zumindest f???r VS)
-
 #undef _assert
 
 #include <vector>

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 
 #include "InputManager.h"
 
-#include <xercesc/dom/DOM.hpp>
-
 #ifdef __APPLE__
 #   include <OIS/OISInputManager.h>
 #else
@@ -267,20 +265,15 @@
 
     void InputManager::loadKeyMapping(const Ogre::String& filename)
     {
-        using namespace XERCES_CPP_NAMESPACE;
-        using XERCES_CPP_NAMESPACE::DOMDocument;
         using std::make_pair;
 
-        initializeXml();
+        TiXmlDocument* doc = loadDocument(filename);
+        TiXmlElement* dataDocumentContent = doc->RootElement();
 
-        DOMDocument* doc = loadDocument(filename);
-        DOMElement* dataDocumentContent = doc->getDocumentElement();
-
-        DOMNodeList* keymaps
-            = dataDocumentContent->getElementsByTagName(AutoXMLCh("Key").data());
-        for (unsigned int idx = 0; idx < keymaps->getLength(); idx++)
+        XmlElementList keymaps = getElementsByTagName(dataDocumentContent, "Key");
+        for (unsigned int idx = 0; idx < keymaps.size(); idx++)
         {
-            DOMElement* key = static_cast<DOMElement*>(keymaps->item(idx));
+            const TiXmlElement* key = keymaps[idx];
             int keycode = getAttributeValueAsInteger(key, "KeyCode");
 
             CeGuiString s;
@@ -305,8 +298,6 @@
             s = getAttributeValueAsString(key, "KeyDescription");
             mKeyNames.insert(make_pair(keycode, s));
         }
-
-        shutdownXml();
     }
 
     const CEGUI::utf8& InputManager::getKeyChar(int scancode, int modifiers) const



From blakharaz at mail.berlios.de  Sat Nov  7 20:49:45 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 20:49:45 +0100
Subject: [Dsa-hl-svn] r4962 - in rl/trunk/engine/core: include src
Message-ID: <200911071949.nA7JnjA4003616@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 20:49:41 +0100 (Sat, 07 Nov 2009)
New Revision: 4962

Modified:
   rl/trunk/engine/core/include/Actor.h
   rl/trunk/engine/core/src/ActorControlledObject.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/SceneQuery.cpp
Log:
Replaced Ogre::UserDefinedObject (deprecated in Ogre) by Ogre::Any

Modified: rl/trunk/engine/core/include/Actor.h
===================================================================
--- rl/trunk/engine/core/include/Actor.h	2009-11-07 19:39:22 UTC (rev 4961)
+++ rl/trunk/engine/core/include/Actor.h	2009-11-07 19:49:41 UTC (rev 4962)
@@ -36,7 +36,7 @@
 
 
     // this is used to notify a gameobject (which is derived from ActorNotifiedObject) if his actor was deleted
-    class ActorNotifiedObject : public Ogre::UserDefinedObject
+    class ActorNotifiedObject
     {
     public:
         virtual void setActor(Actor*) = 0;
@@ -46,7 +46,8 @@
     typedef std::vector<Actor*> ActorVector;
     typedef std::pair<const Ogre::String,Actor*> ActorPair;
 
-    class _RlCoreExport Actor : public Ogre::UserDefinedObject, public Ogre::Node::Listener
+    class _RlCoreExport Actor
+		: public Ogre::Node::Listener
     {
     public:
         static const Ogre::String DEFAULT_SLOT_NAME;
@@ -72,32 +73,32 @@
         */
         ~Actor();
 
-        /// Gibt den eindeutigen Namen des Aktors zur?ck
+        /// Gibt den eindeutigen Namen des Aktors zur???ck
         const Ogre::String& getName() const;
 
-        /// Gibt das UserdefinedObject der n?chsten Schicht zur?ck
+        /// Gibt das UserdefinedObject der n???chsten Schicht zur???ck
         ActorNotifiedObject* getGameObject() const;
-        /// Setzt das UserdefinedObject der n?chsten Schicht
+        /// Setzt das UserdefinedObject der n???chsten Schicht
         void setGameObject(ActorNotifiedObject* uo);
 
-        /// Gibt die Physikalische Repr?sentation zur?ck
+        /// Gibt die Physikalische Repr???sentation zur???ck
         PhysicalThing* getPhysicalThing() const;
-        /// Setzt die Physikalische Repr?sentation
+        /// Setzt die Physikalische Repr???sentation
         void setPhysicalThing( PhysicalThing* pt );
 
-        /// Gibt das kontrollierte Objekt zur?ck
+        /// Gibt das kontrollierte Objekt zur???ck
         ActorControlledObject* getControlledObject() const;
         /// Setzt das kontrollierte Objekt
         void setControlledObject( ActorControlledObject* act );
 
 
-        /** F?gt diesen Aktor in einen SzenenKnoten ein.
+        /** F???gt diesen Aktor in einen SzenenKnoten ein.
         * 
-        * @param parent Der SzenenKnoten in den der Aktor eingef?gt werden soll
+        * @param parent Der SzenenKnoten in den der Aktor eingef???gt werden soll
         * @param offsetPosition Die Verschiebung
         * @param offsetOrientation Die Drehung
         * @param physicsBone Der Knochen an den die 
-        *        Physikalische Verkn?pfung gebunden werden soll
+        *        Physikalische Verkn???pfung gebunden werden soll
         *	
         */
         void placeIntoNode( 
@@ -105,19 +106,19 @@
             const Ogre::Vector3& offsetPosition = Ogre::Vector3::ZERO,
             const Ogre::Quaternion& offsetOrientation = Ogre::Quaternion::IDENTITY,
             const Ogre::String& physicsBone = "");
-        /** F?gt diesen Aktor in die Szene (der RootNode) ein.
+        /** F???gt diesen Aktor in die Szene (der RootNode) ein.
         * 
         * @param offsetPosition Die Verschiebung
         * @param offsetOrientation Die Drehung
         * @param physicsBone Der Knochen an den die 
-        *        Physikalische Verkn?pfung gebunden werden soll
+        *        Physikalische Verkn???pfung gebunden werden soll
         *	
         */
         void placeIntoScene(
             const Ogre::Vector3& position = Ogre::Vector3::ZERO,
             const Ogre::Quaternion& orientation = Ogre::Quaternion::IDENTITY,
             const Ogre::String& physicsBone = "");   
-        /// F?gt diesen Aktor in die Szene (der RootNode) ein.
+        /// F???gt diesen Aktor in die Szene (der RootNode) ein.
         void placeIntoScene(
             Ogre::Real px, Ogre::Real py, Ogre::Real pz,
             Ogre::Real ow, Ogre::Real ox, Ogre::Real oy, Ogre::Real oz,
@@ -127,21 +128,21 @@
         void removeFromScene();
 
 
-        /// Gibt die Anfrage-Maske zur?ck,
+        /// Gibt die Anfrage-Maske zur???ck,
         unsigned long getQueryFlags() const;
         /// Setzt die Anfrage-Maske
         void setQueryFlags( unsigned long mask = 0xFFFFFFFF );
 
-        /// F?gt der Anfrage-Maske ein Flag hinzu
+        /// F???gt der Anfrage-Maske ein Flag hinzu
         void addQueryFlag( unsigned long flag  );
         /// Entfernt ein Flag aus der Anfrage-Maske
         void removeQueryFlag( unsigned long flag );
 
 
 
-        /// Gibt die aktuelle Position des Aktors relativ zu seinem Parent zur?ck
+        /// Gibt die aktuelle Position des Aktors relativ zu seinem Parent zur???ck
         const Ogre::Vector3& getPosition(void) const;
-        /// Gibt die aktuelle Position des Aktors relativ zur Welt zur?ck
+        /// Gibt die aktuelle Position des Aktors relativ zur Welt zur???ck
         const Ogre::Vector3& getWorldPosition(void) const;
 
         /// Ermittelt die aktuelle Geschwindigkeit des Actors, falls moeglich
@@ -155,12 +156,12 @@
         /// Skaliert den Aktor
         void setScale( Ogre::Real sx, Ogre::Real sy, Ogre::Real sz );
 
-        /// Gibt die Orientierung des Aktors relativ zu seinem Parent zur?ck
+        /// Gibt die Orientierung des Aktors relativ zu seinem Parent zur???ck
         const Ogre::Quaternion& getOrientation(void) const;
-        /// Gibt die Orientierung des Aktors relativ zur Welt zur?ck
+        /// Gibt die Orientierung des Aktors relativ zur Welt zur???ck
         const Ogre::Quaternion& getWorldOrientation(void) const;
 
-        /// Gibt die bounding box in world space zur?ck.
+        /// Gibt die bounding box in world space zur???ck.
         Ogre::AxisAlignedBox getWorldBoundingBox() const;
 
         /// Setzt die Orientierung des Aktors
@@ -181,13 +182,13 @@
 
 
         /**
-        *	Befestigt einen anderen Aktor ?ber einen UnterNode an diesem Aktors.
+        *	Befestigt einen anderen Aktor ???ber einen UnterNode an diesem Aktors.
         *
         * @param actor Der Aktor
         * @param childSlot Der Slot an dem zu befestigenden Aktor, wenn DEFAULT_SLOT_NAME ignoriert
-        *                  verursacht zus?tzliche Offset/Drehung
-        * @param offsetPosition Die zus?tzliche Verschiebung
-        * @param offsetOrientation Die zus?tzliche Drehung
+        *                  verursacht zus???tzliche Offset/Drehung
+        * @param offsetPosition Die zus???tzliche Verschiebung
+        * @param offsetOrientation Die zus???tzliche Drehung
         */
         void attach( 
             Actor* actor,
@@ -197,14 +198,14 @@
             );
 
         /**
-        *	Befestigt einen anderen Aktor ?ber einen UnterNode an diesem Aktors.
+        *	Befestigt einen anderen Aktor ???ber einen UnterNode an diesem Aktors.
         *
         * @param actor Der Aktor
         * @param childSlot Der Slot an dem zu befestigenden Aktor, wenn DEFAULT_SLOT_NAME ignoriert,
-        *                  verursacht zus?tzliche Offset/Drehung
-        * @param offsetPosition Die zus?tzliche Verschiebung
-        * @param offsetAxis Die Achse der zus?tzlichen Drehung
-        * @param offsetRotation Die zus?tzliche Drehung
+        *                  verursacht zus???tzliche Offset/Drehung
+        * @param offsetPosition Die zus???tzliche Verschiebung
+        * @param offsetAxis Die Achse der zus???tzlichen Drehung
+        * @param offsetRotation Die zus???tzliche Drehung
         */
         void attachAxisRot( 
             Actor* actor,
@@ -219,9 +220,9 @@
         * @param actor Der Aktor
         * @param slot Der Slot an diesem Aktor, wenn DEFAULT_SLOT_NAME ignoriert
         * @param childSlot Der Slot an dem zu befestigenden Aktor, wenn DEFAULT_SLOT_NAME ignoriert,
-        *                  verursacht zus?tzliche Offset/Drehung
-        * @param offsetPosition Die zus?tzliche Verschiebung
-        * @param offsetOrientation Die zus?tzliche Drehung
+        *                  verursacht zus???tzliche Offset/Drehung
+        * @param offsetPosition Die zus???tzliche Verschiebung
+        * @param offsetOrientation Die zus???tzliche Drehung
         */
         void attachToSlot( 
             Actor* actor,
@@ -236,10 +237,10 @@
         * @param actor Der Aktor
         * @param slot Der Slot an diesem Aktor, wenn DEFAULT_SLOT_NAME ignoriert
         * @param childSlot Der Slot an dem zu befestigenden Aktor, wenn DEFAULT_SLOT_NAME ignoriert, 
-        *                  verursacht zus?tzliche Offset/Drehung
-        * @param offsetPosition Die zus?tzliche Verschiebung
-        * @param offsetAxis Die Achse der zus?tzlichen Drehung
-        * @param offsetRotation Die zus?tzliche Drehung
+        *                  verursacht zus???tzliche Offset/Drehung
+        * @param offsetPosition Die zus???tzliche Verschiebung
+        * @param offsetAxis Die Achse der zus???tzlichen Drehung
+        * @param offsetRotation Die zus???tzliche Drehung
         */
         void attachToSlotAxisRot( 
             Actor* actor,
@@ -270,10 +271,10 @@
 
         /// Setzt diesem Aktor ein Highlight
         void setHighlighted(bool highlight, const CeGuiString& descriptionText = "");
-        /// Gibt zur?ck ob der Aktor gehighlighted ist
+        /// Gibt zur???ck ob der Aktor gehighlighted ist
         bool isHighlighted() const;
 
-        ///@todo mehr Query-Methoden f?r Childs
+        ///@todo mehr Query-Methoden f???r Childs
         Actor* getChildByName(const Ogre::String& name ) const;
         bool hasChild(Actor*) const;
         /// Sets the Visibility
@@ -291,7 +292,7 @@
         virtual void nodeDetached (const Ogre::Node *node);
         /// Setze den Listener des Nodes
         void setListenerOf(Ogre::SceneNode *node);
-        /// gib das Bone zur?ck
+        /// gib das Bone zur???ck
         Ogre::Bone *_getBone() const;
 
         bool isInScene() const;
@@ -308,11 +309,11 @@
 
         /// Der einzigartige Name
         Ogre::String mName;
-        /// Verkn?pfung zur Physikalischen Repr?sentation
+        /// Verkn???pfung zur Physikalischen Repr???sentation
         PhysicalThing* mPhysicalThing;
-        /// Verkn?pfung zur N?chsten Schicht
+        /// Verkn???pfung zur N???chsten Schicht
         ActorNotifiedObject* mGameObject;
-        /// Verkn?pfung zum kontrollierten Objekt
+        /// Verkn???pfung zum kontrollierten Objekt
         ActorControlledObject* mActorControlledObject;
         /// Der Parent-Aktor
         Actor* mParent;
@@ -326,7 +327,7 @@
         bool mHighlighted;
         /// Ist der Aktor an einem Bone angehangen?
         //bool mAttachedToBone;
-        /// Der Bone, an dem wir vielleicht h?ngen.
+        /// Der Bone, an dem wir vielleicht h???ngen.
         Ogre::Bone *mBone;
 
         /// the actor is in these areas, this is needed to notify areas of deleted actors
@@ -339,14 +340,14 @@
             const Ogre::String& physicsBone = "" );   
 
         /**
-        *	K?mmert sich um das Durchf?hren des Befestigens
+        *	K???mmert sich um das Durchf???hren des Befestigens
         *
         * @param actor Der Aktor
         * @param slot Der Slot an diesem Aktor, wenn DEFAULT_SLOT_NAME ignoriert
         * @param childSlot Der Slot an dem zu befestigenden Aktor, wenn DEFAULT_SLOT_NAME ignoriert
-        *                  verursacht zus?tzliche Offset/Drehung
-        * @param offsetPosition Die zus?tzliche Verschiebung
-        * @param offsetOrientation Die zus?tzliche Drehung
+        *                  verursacht zus???tzliche Offset/Drehung
+        * @param offsetPosition Die zus???tzliche Verschiebung
+        * @param offsetOrientation Die zus???tzliche Drehung
         */
         void doAttach(
             Actor* actor,
@@ -356,7 +357,7 @@
             const Ogre::Quaternion& offsetOrientation);
 
         /**
-        *	K?mmert sich um das Durchf?hren des Abnehmens
+        *	K???mmert sich um das Durchf???hren des Abnehmens
         */
         void doDetach(Actor* actor);
 

Modified: rl/trunk/engine/core/src/ActorControlledObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorControlledObject.cpp	2009-11-07 19:39:22 UTC (rev 4961)
+++ rl/trunk/engine/core/src/ActorControlledObject.cpp	2009-11-07 19:49:41 UTC (rev 4962)
@@ -41,7 +41,7 @@
     {
         if (mMovableObject != NULL)
         {
-            mMovableObject->setUserObject(actor);
+            mMovableObject->setUserAny(Ogre::Any(actor));
         }
     }
 
@@ -49,7 +49,7 @@
     {
         if (mMovableObject != NULL)
         {
-            return static_cast<Actor*>(mMovableObject->getUserObject());
+            return any_cast<Actor*>(mMovableObject->getUserAny());
         }
         return NULL;
     }

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-11-07 19:39:22 UTC (rev 4961)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-11-07 19:49:41 UTC (rev 4962)
@@ -75,10 +75,10 @@
         for (it = movList.begin(); it != movList.end(); ++it)
         {
             MovableObject* mov = *it;
-            if( mov->getUserObject() != NULL )
+            if (!mov->getUserAny().isNull())
             {
                 // Zur Zeit sind die einzigen an Movables gekn??pfte Objekte Actoren
-                Actor* act = dynamic_cast<Actor*>( mov->getUserObject() );
+                Actor* act = any_cast<Actor*>(mov->getUserAny());
                 retMap.insert(ActorPair(act->getName(),act));
             }
         }

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2009-11-07 19:39:22 UTC (rev 4961)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2009-11-07 19:49:41 UTC (rev 4962)
@@ -173,8 +173,11 @@
         for (SceneQueryResultMovableList::const_iterator it = result.movables.begin(),
             end = result.movables.end(); it != end; ++it)
         {
-            Actor* actor = dynamic_cast<Actor*>((*it)->getUserObject());
-            if (actor != NULL) mResult.push_back(actor);
+            Actor* actor = any_cast<Actor*>((*it)->getUserAny());
+            if (actor)
+            {
+            	mResult.push_back(actor);
+            }
         }
 
         return mResult;
@@ -247,8 +250,11 @@
             Vector3 movablePos = (*it)->getParentNode()->_getDerivedPosition();
             if (forward.dotProduct(movablePos - mPosition) > 0.0f)
             {
-                Actor* actor = dynamic_cast<Actor*>((*it)->getUserObject());
-                if (actor != NULL) mResult.push_back(actor);
+                Actor* actor = any_cast<Actor*>((*it)->getUserAny());
+                if (actor != NULL)
+                {
+                	mResult.push_back(actor);
+                }
             }
         }
 
@@ -291,8 +297,8 @@
 	bool OgreRaySceneQuery::queryResult(
 		Ogre::MovableObject* obj, Ogre::Real distance)
 	{
-        Actor* actor = dynamic_cast<Actor*>(obj->getUserObject());
-        if (actor != NULL)
+        Actor* actor = any_cast<Actor*>(obj->getUserAny());
+        if (actor)
 		{
 			mResult.push_back(actor);
 		}



From blakharaz at mail.berlios.de  Sat Nov  7 21:30:25 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 21:30:25 +0100
Subject: [Dsa-hl-svn] r4963 - in rl/trunk/engine: ai ai/src common
	common/src core core/include core/src rules script
	script/include script/src script/swig ui ui/include ui/src
Message-ID: <200911072030.nA7KUPlb007071@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 21:30:04 +0100 (Sat, 07 Nov 2009)
New Revision: 4963

Modified:
   rl/trunk/engine/ai/RlAI2008.vcproj
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/common/RlCommon2008.vcproj
   rl/trunk/engine/common/src/XmlProcessor.cpp
   rl/trunk/engine/core/RlCore2008.vcproj
   rl/trunk/engine/core/include/stdinc.h
   rl/trunk/engine/core/src/BoxPrimitive.cpp
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/rules/RlRules2008.vcproj
   rl/trunk/engine/script/RlScript2008.vcproj
   rl/trunk/engine/script/include/Scene.h
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/ui/RlUI2008.vcproj
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/src/AbstractWindow.cpp
   rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
   rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp
   rl/trunk/engine/ui/src/Console.cpp
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/GameLoggerWindow.cpp
   rl/trunk/engine/ui/src/GameOverWindow.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
   rl/trunk/engine/ui/src/InGameMenuWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Adaptations for Ogre 1.7, CEGUI 0.7 and tinyxml on Windows (VS 2008)

Modified: rl/trunk/engine/ai/RlAI2008.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2008.vcproj	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ai/RlAI2008.vcproj	2009-11-07 20:30:04 UTC (rev 4963)
@@ -74,10 +74,10 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="false"
 				AdditionalOptions="/NODEFAULTLIB:MSVCRT&#x0D;&#x0A;"
-				AdditionalDependencies="OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib xerces-c_2D.lib"
+				AdditionalDependencies="OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib tinyxmld_STL.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\xerces\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlAI.pdb"
@@ -161,10 +161,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib xerces-c_2.lib"
+				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib tinyxml_STL.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\xerces\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -246,10 +246,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2.lib"
+				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib tinyxml_STL.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\xerces\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -640,7 +640,7 @@
             }
 
 
-            for (list<DialogLoaderImpl::DialogParticipant*>::iterator it = mParticipantFilter.begin();
+            for (std::list<DialogLoaderImpl::DialogParticipant*>::iterator it = mParticipantFilter.begin();
                     it != mParticipantFilter.end(); ++it)
             {
                 if ((*it)->isMatching(curCr))

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -51,8 +51,8 @@
 			mDialogLoader);
 		delete mDialogLoader;
         SaveGameManager::getSingleton().unregisterSaveGameData(this);
-		map<DialogConfiguration, Dialog*>::iterator itr = mDialogStates.begin();
-		map<DialogConfiguration, Dialog*>::iterator end = mDialogStates.end();
+		std::map<DialogConfiguration, Dialog*>::iterator itr = mDialogStates.begin();
+		std::map<DialogConfiguration, Dialog*>::iterator end = mDialogStates.end();
 		for(; itr != end; ++itr)
 		{
 			delete itr->second;
@@ -66,7 +66,7 @@
         if (key == DialogManager::PROPERTY_DIALOGS)
         {
             PropertyArray vec;
-            for (map<DialogConfiguration, Dialog*>::const_iterator it
+            for (std::map<DialogConfiguration, Dialog*>::const_iterator it
                 = mDialogStates.begin(); it != mDialogStates.end(); ++it)
             {
                 PropertyMap curDialogProp;
@@ -152,7 +152,7 @@
             participants.push_back(*it);
         }
 
-        map<DialogConfiguration, Dialog*>::iterator it
+        std::map<DialogConfiguration, Dialog*>::iterator it
             = mDialogStates.find(DialogConfiguration(name, participants));
 
         Dialog* dialog;

Modified: rl/trunk/engine/common/RlCommon2008.vcproj
===================================================================
--- rl/trunk/engine/common/RlCommon2008.vcproj	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/common/RlCommon2008.vcproj	2009-11-07 20:30:04 UTC (rev 4963)
@@ -70,7 +70,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain_d.lib xerces-c_2D.lib CEGUIBase_d.lib"
+				AdditionalDependencies="OgreMain_d.lib tinyxmld_STL.lib CEGUIBase_d.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCommon.dll"
 				LinkIncremental="2"
 				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\cegui_mk2\lib\$(PlatformName)\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib\;..\..\dependencies\boost\lib"
@@ -157,7 +157,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib xerces-c_2.lib CEGUIBase.lib"
+				AdditionalDependencies="OgreMain.lib tinyxml_STL.lib CEGUIBase.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCommon.dll"
 				LinkIncremental="1"
 				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\cegui_mk2\lib\$(PlatformName)\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib\;..\..\dependencies\boost\lib"
@@ -242,7 +242,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="OgreMain.lib xerces-c_2.lib CEGUIBase.lib"
+				AdditionalDependencies="OgreMain.lib tinyxml_STL.lib CEGUIBase.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCommon.dll"
 				LinkIncremental="1"
 				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\cegui_mk2\lib\$(PlatformName)\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib\;..\..\dependencies\boost\lib"
@@ -321,10 +321,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\OgreXercesInput.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\Properties.cpp"
 				>
 			</File>
@@ -369,10 +365,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\WriteableDataStreamFormatTarget.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\WriteableFileSystemArchiv.cpp"
 				>
 			</File>
@@ -453,10 +445,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\OgreXercesInput.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\Properties.h"
 				>
 			</File>
@@ -489,10 +477,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\WriteableDataStreamFormatTarget.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\WriteableFileSystemArchiv.h"
 				>
 			</File>

Modified: rl/trunk/engine/common/src/XmlProcessor.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -108,15 +108,16 @@
 
 XmlElementList XmlProcessor::getElementsByTagName(const TiXmlElement* parent, const char* const name) const
 {
+	XmlElementFinder finder(name);
+	parent->Accept(&finder);
+	return finder.getResult();
 }
 
-
 XmlElementList XmlProcessor::getElementsByTagName(const TiXmlDocument* parent, const char* const name) const
 {
 	return getElementsByTagName(parent->RootElement(), name);
 }
 
-
 void XmlProcessor::setValueAsString(TiXmlElement *element, const CeGuiString &value) const
 {
     RlAssert(element != NULL, "XmlProcessor::setValueAsString: Element must not be NULL");
@@ -152,7 +153,7 @@
 bool XmlProcessor::hasAttribute(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::hasAttribute: Element must not be NULL");
-    return element->Attribute(name);
+    return element->Attribute(name) != NULL;
 }
 
 bool XmlProcessor::hasNodeName(const TiXmlNode* node, const char* const name) const

Modified: rl/trunk/engine/core/RlCore2008.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2008.vcproj	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/core/RlCore2008.vcproj	2009-11-07 20:30:04 UTC (rev 4963)
@@ -86,12 +86,12 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt_d.lib OgreMain_d.lib xerces-c_2D.lib CEGUIBase_d.lib Newton.lib meshmagick_d.lib fmodex_vc.lib"
+				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt_d.lib OgreMain_d.lib tinyxmld_STL.lib CEGUIBase_d.lib Newton.lib meshmagick_d.lib fmodex_vc.lib"
 				ShowProgress="0"
 				OutputFile="./lib/$(ConfigurationName)/RlCore.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
 				IgnoreDefaultLibraryNames=""
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				GenerateDebugInformation="true"
@@ -198,11 +198,11 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib xerces-c_2.lib CEGUIBase.lib OgreMain.lib Newton.lib meshmagick.lib fmodex_vc.lib"
+				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib tinyxml_STL.lib CEGUIBase.lib OgreMain.lib Newton.lib meshmagick.lib fmodex_vc.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCore.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				ProgramDatabaseFile=""
 				SubSystem="2"
@@ -304,11 +304,11 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib xerces-c_2.lib CEGUIBase.lib OgreMain.lib Newton.lib meshmagick.lib fmodex_vc.lib"
+				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib tinyxml_STL.lib CEGUIBase.lib OgreMain.lib Newton.lib meshmagick.lib fmodex_vc.lib"
 				OutputFile="$(OutDir)/RlCore.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(TargetDir)$(TargetName).pdb"

Modified: rl/trunk/engine/core/include/stdinc.h
===================================================================
--- rl/trunk/engine/core/include/stdinc.h	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/core/include/stdinc.h	2009-11-07 20:30:04 UTC (rev 4963)
@@ -58,7 +58,7 @@
 #include <boost/filesystem/operations.hpp>
 #include <boost/filesystem/exception.hpp>
 #include <boost/any.hpp>
-#include <boost/smartptr.hpp>
+#include <boost/smart_ptr.hpp>
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 #  include <Windows.h>

Modified: rl/trunk/engine/core/src/BoxPrimitive.cpp
===================================================================
--- rl/trunk/engine/core/src/BoxPrimitive.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/core/src/BoxPrimitive.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -52,7 +52,7 @@
     {
         ManualObject* manualObject = getManualObject();
         manualObject->clear();
-        vector<Vector3> corners;
+		std::vector<Vector3> corners;
         corners.reserve(8);
 
         Vector3 vmin = mSize.getMinimum();

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -220,7 +220,7 @@
             ConfigFile* configfile = new ConfigFile();
 
             // Split the path at the ':' character
-            std::vector<Ogre::String> cfg_paths = Ogre::StringUtil::split(mRastullahCfgPath, ":");
+            Ogre::StringVector cfg_paths = Ogre::StringUtil::split(mRastullahCfgPath, ":");
 
             for (unsigned int i = 0; i < cfg_paths.size(); i++)
             {

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -194,10 +194,10 @@
         }
 
         // Find out, what Renderer plugins are available
-        RenderSystemList* rsl = mOgreRoot->getAvailableRenderers();
+        RenderSystemList rsl = mOgreRoot->getAvailableRenderers();
         RenderSystemList::iterator it;
 
-        for (it = rsl->begin(); it < rsl->end(); it++)
+        for (it = rsl.begin(); it != rsl.end(); it++)
         {
             if ((*it)->getName() == ConfigurationManager::getSingleton().getStringSetting(
                 "Video", "Render System"))

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -118,7 +118,7 @@
         clearLevelGeometry();
 
         // remove all physical things
-        for( vector<PhysicalThing*>::iterator it = mPhysicalThings.begin(); it != mPhysicalThings.end(); it++ )
+		for (std::vector<PhysicalThing*>::iterator it = mPhysicalThings.begin(); it != mPhysicalThings.end(); it++ )
         {
             delete (*it);
         }
@@ -269,10 +269,10 @@
 
     void PhysicsManager::removeAndDestroyPhysicalThing(PhysicalThing* thing)
     {
-        vector<PhysicalThing*>::iterator it = find(mPhysicalThings.begin(),
+        std::vector<PhysicalThing*>::iterator it = find(mPhysicalThings.begin(),
             mPhysicalThings.end(), thing);
 
-        if( it != mPhysicalThings.end() )
+        if (it != mPhysicalThings.end())
         {
             PhysicalThing* phys = *it;
             mPhysicalThings.erase(it);
@@ -388,7 +388,7 @@
 
 	void PhysicsManager::destroyPhysicsProxy(PhysicalThing* pt)
 	{
-        vector<PhysicalThing*>::iterator it = find(mPhysicalThings.begin(),
+        std::vector<PhysicalThing*>::iterator it = find(mPhysicalThings.begin(),
             mPhysicalThings.end(), pt);
 		if (it != mPhysicalThings.end())
 		{

Modified: rl/trunk/engine/rules/RlRules2008.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2008.vcproj	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/rules/RlRules2008.vcproj	2009-11-07 20:30:04 UTC (rev 4963)
@@ -70,10 +70,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="msvcrt-ruby18.lib xerces-c_2D.lib OgreMain_d.lib CEGUIBase_d.lib RlCore.lib OgreNewt_d.lib Newton.lib"
+				AdditionalDependencies="msvcrt-ruby18.lib tinyxmld_STL.lib OgreMain_d.lib CEGUIBase_d.lib RlCore.lib OgreNewt_d.lib Newton.lib"
 				OutputFile="$(OutDir)/RlRules.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlRules.pdb"
@@ -157,10 +157,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="msvcrt-ruby18.lib OgreMain.lib xerces-c_2.lib CEGUIBase.lib RlCore.lib OgreNewt.lib Newton.lib"
+				AdditionalDependencies="msvcrt-ruby18.lib OgreMain.lib tinyxml_STL.lib CEGUIBase.lib RlCore.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlRules.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -242,10 +242,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="msvcrt-ruby18.lib OgreMain.lib xerces-c_2.lib CEGUIBase.lib RlCore.lib OgreNewt.lib Newton.lib"
+				AdditionalDependencies="msvcrt-ruby18.lib OgreMain.lib tinyxml_STL.lib CEGUIBase.lib RlCore.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlRules.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"

Modified: rl/trunk/engine/script/RlScript2008.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2008.vcproj	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/script/RlScript2008.vcproj	2009-11-07 20:30:04 UTC (rev 4963)
@@ -67,10 +67,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain_d.lib msvcrt-ruby18.lib CEGUIBase_d.lib xerces-c_2D.lib OgreNewt_d.lib Newton.lib"
+				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain_d.lib msvcrt-ruby18.lib CEGUIBase_d.lib tinyxmld_STL.lib OgreNewt_d.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlScript.pdb"
@@ -152,10 +152,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
+				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib tinyxml_STL.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -235,10 +235,10 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
+				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib tinyxml_STL.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				OptimizeReferences="2"
@@ -526,7 +526,7 @@
 					<Tool
 						Name="VCCustomBuildTool"
 						Description="[SWIG] RubyWrapper erzeugen."
-						CommandLine="cd &quot;$(InputDir)&quot;&#x0D;&#x0A;&quot;$(ProjectDir)..\..\dependencies\swig\swig.exe&quot; -o &quot;$(InputDir)$(InputName)_wrap.cxx&quot; -c++ -ruby -minherit -v -Wall  &quot;$(InputPath)&quot;&#x0D;&#x0A;"
+						CommandLine="cd &quot;$(InputDir)&quot;&#x0D;&#x0A;&quot;$(ProjectDir)..\..\..\dependencies\swig\swig.exe&quot; -o &quot;$(InputDir)$(InputName)_wrap.cxx&quot; -c++ -ruby -minherit -v -Wall  &quot;$(InputPath)&quot;&#x0D;&#x0A;"
 						AdditionalDependencies="&quot;$(InputDir)TypeMaps.i&quot;;&quot;$(InputDir)RlCore.swig&quot;;&quot;$(InputDir)RlDialog.swig&quot;;&quot;$(InputDir)RlCommon.swig&quot;;&quot;$(InputDir)RlRules.swig&quot;;&quot;$(InputDir)RlScript.swig&quot;;&quot;$(InputDir)RlSound.swig&quot;;&quot;$(InputDir)RlUi.swig&quot;;&quot;$(InputDir)RlAi.swig&quot;"
 						Outputs="&quot;$(InputDir)$(InputName)_wrap.cxx&quot;"
 					/>

Modified: rl/trunk/engine/script/include/Scene.h
===================================================================
--- rl/trunk/engine/script/include/Scene.h	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/script/include/Scene.h	2009-11-07 20:30:04 UTC (rev 4963)
@@ -43,7 +43,7 @@
 
     private:
         CeGuiString mName;
-        std::vector<Ogre::String> mMaps;
+        Ogre::StringVector mMaps;
     };
 
 }

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -64,7 +64,7 @@
 
     MapLoader::~MapLoader()
     {
-        for (list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin();
+        for (std::list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin();
             it != mNodeProcessors.end(); ++it)
         {
             delete *it;
@@ -270,7 +270,7 @@
             {
             	const TiXmlElement* curElem = cur->ToElement();
 
-                list<AbstractMapNodeProcessor*>::iterator it = mNodeProcessors.begin();
+                std::list<AbstractMapNodeProcessor*>::iterator it = mNodeProcessors.begin();
                 while (it != mNodeProcessors.end() && !(*it)->processNode(curElem, loadGameObjects))
                 {
                     ++it;
@@ -297,7 +297,7 @@
     void MapLoader::setRootSceneNode(SceneNode* node)
     {
         mRootSceneNode = node;
-        for (list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin();
+        for (std::list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin();
             it != mNodeProcessors.end(); ++it)
         {
             (*it)->setRootSceneNode(node);

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/script/swig/RlCore.swig	2009-11-07 20:30:04 UTC (rev 4963)
@@ -571,7 +571,7 @@
     void setOrientation( const Ogre::Quaternion& );
     
     rl::ActorControlledObject* getControlledObject();
-    Ogre::UserDefinedObject* getGameObject() const;
+    rl::ActorNotifiedObject* getGameObject() const;
     rl::PhysicalThing* getPhysicalThing() const;
 
     void setScale( Ogre::Real sx, Ogre::Real sy, Ogre::Real sz );

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/script/swig/RlExports.i	2009-11-07 20:30:04 UTC (rev 4963)
@@ -30,9 +30,6 @@
 #	endif
 #endif
 
-// Has to be included before Ogre, MemoryManager issues...
-#include <xercesc/util/XMemory.hpp>	
-
 // Exporting the function for getting ruby instances
 VALUE RL_RubyInstanceFor(void* ptr) 
 {

Modified: rl/trunk/engine/ui/RlUI2008.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2008.vcproj	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/RlUI2008.vcproj	2009-11-07 20:30:04 UTC (rev 4963)
@@ -86,12 +86,12 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCore.lib RlRules.lib msvcrt-ruby18.lib OgreMain_d.lib OgreGuiRenderer_d.lib CEGUIBase_d.lib xerces-c_2D.lib OgreNewt_d.lib Newton.lib OIS_d.lib"
+				AdditionalDependencies="RlCore.lib RlRules.lib msvcrt-ruby18.lib OgreMain_d.lib CEGUIOgreRenderer_d.lib CEGUIBase_d.lib tinyxmld_STL.lib OgreNewt_d.lib Newton.lib OIS_d.lib"
 				ShowProgress="0"
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				IgnoreDefaultLibraryNames=""
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
@@ -195,11 +195,11 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCore.lib RlRules.lib msvcrt-ruby18.lib OgreMain.lib OgreGuiRenderer.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib OIS.lib"
+				AdditionalDependencies="RlCore.lib RlRules.lib msvcrt-ruby18.lib OgreMain.lib CEGUIOgreRenderer.lib CEGUIBase.lib tinyxml_STL.lib OgreNewt.lib Newton.lib OIS.lib"
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				ProgramDatabaseFile=""
 				SubSystem="2"
 				RandomizedBaseAddress="1"
@@ -298,11 +298,11 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCore.lib RlRules.lib msvcrt-ruby18.lib OgreMain.lib OgreGuiRenderer.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib OIS.lib"
+				AdditionalDependencies="RlCore.lib RlRules.lib msvcrt-ruby18.lib OgreMain.lib CEGUIOgreRenderer.lib CEGUIBase.lib tinyxml_STL.lib OgreNewt.lib Newton.lib OIS.lib"
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\..\dependencies\NewtonSDK\sdk\x32\dll_vs9;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(TargetDir)$(TargetName).pdb"
 				SubSystem="2"
@@ -522,10 +522,6 @@
 					>
 				</File>
 				<File
-					RelativePath=".\include\ListboxWrappedTextItem.h"
-					>
-				</File>
-				<File
 					RelativePath=".\include\LogWindow.h"
 					>
 				</File>
@@ -775,10 +771,6 @@
 					>
 				</File>
 				<File
-					RelativePath=".\src\ListboxWrappedTextItem.cpp"
-					>
-				</File>
-				<File
 					RelativePath=".\src\LogWindow.cpp"
 					>
 				</File>

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2009-11-07 20:30:04 UTC (rev 4963)
@@ -27,8 +27,7 @@
 // Gar nicht sch??n, aber ansonsten gibt es unn??tige Abh???ngigkeiten,
 // wenn man die Header hier inkludiert.
 namespace CEGUI {
-    class OgreCEGUIRenderer;
-    class OgreCEGUIResourceProvider;
+    class OgreRenderer;
     class System;
 }
 
@@ -51,7 +50,7 @@
         /** Default Deconstructor */
         virtual ~UiSubsystem();
 
-        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
+        CEGUI::OgreRenderer* getGUIRenderer();
 
         void initializeSubsystem();
 
@@ -78,7 +77,7 @@
         WindowFactory* mWindowFactory;
         WindowManager* mWindowManager;
 
-        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
+        CEGUI::OgreRenderer* mGuiRenderer;
         CEGUI::ResourceProvider* mGuiResourceProvider;
         CEGUI::System* mGuiSystem;
         

Modified: rl/trunk/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AbstractWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -270,7 +270,7 @@
 
 	void AbstractWindow::centerWindow()
 	{
-		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
+		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getDisplaySize();
 		CEGUI::Size windowSize = mWindow->getPixelSize();
 		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
 		float y = 0.5f * (screenSize.d_height - windowSize.d_height);

Modified: rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -253,12 +253,6 @@
 
 		CEGUI::UVector2 size = button->getSize();
 		button->setPosition(pos - size * UVector2(cegui_reldim(0.5), cegui_reldim(0.5)));
-		LOG_DEBUG2(Logger::UI,
-			(button->getText()+" "+
-            StringConverter::toString(button->getPixelRect().d_left) + ", " +
-            StringConverter::toString(button->getPixelRect().d_top)).c_str(),
-			"createButton");
-
 		return static_cast<PushButton*>(button);
 	}
 
@@ -321,7 +315,7 @@
 		ActionNode* root = new ActionNode(false);
 		root->setGroup(rootGroup);
 
-		set<ActionGroup*> groups;
+		std::set<ActionGroup*> groups;
 		ActionVector rest;
 
 		for (ActionVector::const_iterator iter = actions.begin(); iter != actions.end(); iter++)
@@ -329,10 +323,14 @@
 			Action* action = *iter;
 
 			ActionGroup* group = action->getGroup();
-			if (group == NULL || group == rootGroup )
+			if (group == NULL || group == rootGroup ) 
+			{
 				rest.push_back(action);
+			}
 			else if (groups.find(group) == groups.end())
+			{
 				groups.insert(group);
+			}
 		}
 
 		if (actions.size() / 1.2 <= rest.size() + groups.size())
@@ -341,7 +339,7 @@
 			rest = actions;
 		}
 
-		for (set<ActionGroup*>::iterator groupIter = groups.begin();
+		for (std::set<ActionGroup*>::iterator groupIter = groups.begin();
 			 groupIter != groups.end(); groupIter++)
 		{
 			ActionVector actionsThisGroup;

Modified: rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -54,9 +54,9 @@
         {
             Element* elem = new Element(this);
             mCharacterWindow->addChildWindow(elem->getWindow());
-            CEGUI::Rect size = elem->getWindow()->getPixelRect();
+            CEGUI::Size size = elem->getWindow()->getPixelSize();
             size_t windowNum = mCharacterWindows.size();
-            elem->getWindow()->setPosition(UVector2(UDim(0, 0), UDim(0, windowNum * size.getHeight())));
+			elem->getWindow()->setPosition(UVector2(UDim(0, 0), UDim(0, windowNum * size.d_height)));
             elem->setVisible(true);
             elem->getWindow()->subscribeEvent(
                  Window::EventMouseClick,
@@ -73,7 +73,7 @@
             delete elem;
         }
         
-        for (int i = 0; i < party.size(); ++i)
+        for (unsigned int i = 0; i < party.size(); ++i)
         {
             mCharacterWindows[i]->setCreature(party[i]);
         }

Modified: rl/trunk/engine/ui/src/Console.cpp
===================================================================
--- rl/trunk/engine/ui/src/Console.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/Console.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -20,9 +20,9 @@
 
 #include <boost/bind.hpp>
 #include <elements/CEGUIFrameWindow.h>
+#include <elements/CEGUIListboxTextItem.h>
 
 #include "RubyInterpreter.h"
-#include "ListboxWrappedTextItem.h"
 #include "InputManager.h"
 #include "CoreSubsystem.h"
 #include "JobScheduler.h"
@@ -32,7 +32,6 @@
 
 using CEGUI::utf8; using CEGUI::ListboxTextItem;
 using CEGUI::KeyEventArgs; using CEGUI::Key; using CEGUI::colour;
-using CEGUI::ListboxWrappedTextItem; using CEGUI::TextFormatting;
 
 namespace rl
 {

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -163,10 +163,9 @@
 			Item* item = dragcont->getItem();
 
 
-            int x = evtArgs.dragDropItem->getPixelRect().d_left;
-            int y = evtArgs.dragDropItem->getPixelRect().d_top;
-            x -= mContentWindow->getPixelRect().d_left;
-            y -= mContentWindow->getPixelRect().d_top;
+			CEGUI::Vector2 relPos = evtArgs.dragDropItem->getPosition().asAbsolute(evtArgs.dragDropItem->getParentPixelSize()) - 
+									mContentWindow->getPosition().asAbsolute(mContentWindow->getParentPixelSize());
+			int x = relPos.d_x, y = relPos.d_y;
 
             // ?bergangspixel
             x += 14;

Modified: rl/trunk/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -97,7 +97,7 @@
             return nullPos;
         }
         
-        for (vector<CameraPosition>::const_iterator it = mPositions.begin(), end = mPositions.end(); it != end; ++it)
+		for (std::vector<CameraPosition>::const_iterator it = mPositions.begin(), end = mPositions.end(); it != end; ++it)
         {
             
         }

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -164,7 +164,7 @@
 
     void DebugWindow::updateFps()
     {
-        const RenderTarget::FrameStats& stats = CoreSubsystem::getSingleton().getRenderWindow()->getStatistics();
+		const Ogre::RenderTarget::FrameStats& stats = CoreSubsystem::getSingleton().getRenderWindow()->getStatistics();
 
         Ogre::String textSt = "Current FPS: " +
             StringConverter::toString(stats.lastFPS)+

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -19,6 +19,7 @@
 
 #include <boost/bind.hpp>
 #include <elements/CEGUIFrameWindow.h>
+#include <elements/CEGUIListboxTextItem.h>
 
 #include "Exception.h"
 #include "ConfigurationManager.h"
@@ -30,7 +31,6 @@
 #include "DialogResponse.h"
 #include "GameLoggerWindow.h"
 #include "InputManager.h"
-#include "ListboxWrappedTextItem.h"
 #include "UiSubsystem.h"
 
 
@@ -67,11 +67,11 @@
 
 		// Add 2 ListboxItems, one for the nsc responses, 
 		// one for the player selections
-		mPlayerText = new ListboxWrappedTextItem("", 6);
+		mPlayerText = new ListboxTextItem("", 6);
 		mPlayerText->setTextColours(COLOR_PLAYER_CHARACTER);
 		mQuestion->addItem(mPlayerText);
 
-		mNscText = new ListboxWrappedTextItem("", 0);
+		mNscText = new ListboxTextItem("", 0);
 		mNscText->setTextColours(COLOR_NON_PLAYER_CHARACTER);
 		mQuestion->addItem(mNscText);
 	}
@@ -100,7 +100,7 @@
 		{
             DialogOption* cur = *itr;
 
-			ListboxWrappedTextItem* item = NULL;
+			ListboxTextItem* item = NULL;
             CeGuiString text;
             if (cur->getLabel().empty())
             {
@@ -126,19 +126,19 @@
 
 			if (optionCount < mDialogOptions->getItemCount())
 			{
-				item = static_cast<ListboxWrappedTextItem*>(
+				item = static_cast<ListboxTextItem*>(
 					mDialogOptions->getListboxItemFromIndex(optionCount));
                 item->setText(text);
                 item->setUserData(cur);
 			}
 			else
 			{
-				item = new ListboxWrappedTextItem(text, 6, true);
+				item = new ListboxTextItem(text, 6, NULL, true);
                 item->setUserData(cur);
 				mDialogOptions->addItem(item);
 			}
 
-			item->setTextFormatting(CEGUI::WordWrapLeftAligned);
+			//item->setTextFormatting(CEGUI::WordWrapLeftAligned);
 			mDialogOptions->handleUpdatedItemData();
 
 			++optionCount;

Modified: rl/trunk/engine/ui/src/GameLoggerWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -17,9 +17,10 @@
 
 #include "GameLoggerWindow.h"
 
+#include <elements/CEGUIListboxTextItem.h>
+
 #include "Creature.h"
 #include "GameEventLog.h"
-#include "ListboxWrappedTextItem.h"
 #include "RulesMessages.h"
 
 namespace rl {
@@ -51,7 +52,7 @@
 
 	void GameLoggerWindow::logEvent(const CeGuiString& text, const CEGUI::colour color)
 	{
-		CEGUI::ListboxWrappedTextItem* item = new CEGUI::ListboxWrappedTextItem(text);
+		CEGUI::ListboxTextItem* item = new CEGUI::ListboxTextItem(text);
 		item->setTextColours(color);
 		mLog->addItem(item);
 		mLog->ensureItemIsVisible(item);

Modified: rl/trunk/engine/ui/src/GameOverWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameOverWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/GameOverWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -23,6 +23,7 @@
 #include "WindowFactory.h"
 #include "UiSubsystem.h"
 
+
 namespace rl
 {
 

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -177,14 +177,14 @@
     {
         Root* root = Ogre::Root::getSingletonPtr();
         
-        RenderSystemList* renderers = root->getAvailableRenderers();
-        RenderSystem* renderer = root->getRenderSystem();
+        const RenderSystemList& renderers = root->getAvailableRenderers();
+		Ogre::RenderSystem* renderer = root->getRenderSystem();
         
-        createElements(mVideoRenderer, renderers->size());
+        createElements(mVideoRenderer, renderers.size());
 
-        for (int i = 0; i < renderers->size(); ++i)
+        for (unsigned int i = 0; i < renderers.size(); ++i)
         {
-            RenderSystem* cur = renderers->operator[](i);
+			Ogre::RenderSystem* cur = renderers[i];
             ListboxItem* item = mVideoRenderer->getListboxItemFromIndex(i);
             item->setText(cur->getName());
             if (cur == renderer)
@@ -196,19 +196,19 @@
         ConfigOptionMap config = renderer->getConfigOptions();
         
         setOption(config, "Full Screen", mVideoFullscreen);
-        vector<RadioButton*> videoColorDepth;
+        std::vector<RadioButton*> videoColorDepth;
         videoColorDepth.push_back(mVideoColorDepth32);
         videoColorDepth.push_back(mVideoColorDepth16);
         
         setOption(config, "Colour Depth", videoColorDepth);
-        vector<RadioButton*> videoAntiAliasing;
+        std::vector<RadioButton*> videoAntiAliasing;
         videoAntiAliasing.push_back(mVideoFsaa0);
         videoAntiAliasing.push_back(mVideoFsaa2);
         videoAntiAliasing.push_back(mVideoFsaa4);
         videoAntiAliasing.push_back(mVideoFsaa8);
         setOption(config, "FSAA", videoAntiAliasing);
         
-        vector<RadioButton*> videoRttMode;
+		std::vector<RadioButton*> videoRttMode;
         videoRttMode.push_back(mVideoRttModeFBO);
         videoRttMode.push_back(mVideoRttModePBuffer);
         videoRttMode.push_back(mVideoRttModeCopy);
@@ -250,7 +250,7 @@
                 }
             }
             
-            for (int i = 0; i < combobox->getItemCount(); ++i)
+            for (unsigned int i = 0; i < combobox->getItemCount(); ++i)
             {
                 ListboxItem* item = combobox->getListboxItemFromIndex(i);
                 item->setText(curOption.possibleValues[i]);

Modified: rl/trunk/engine/ui/src/InGameMenuWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -49,7 +49,7 @@
 	CEGUI::WindowManager* windowMan = CEGUI::WindowManager::getSingletonPtr();
 
 	const ActionVector actions = ActionManager::getSingleton().getInGameGlobalActions();
-	map<CeGuiString, PopupMenu*> menuGroups;
+	std::map<CeGuiString, PopupMenu*> menuGroups;
 
 	for (ActionVector::const_iterator actIter = actions.begin(); actIter != actions.end(); actIter++)
 	{
@@ -58,7 +58,7 @@
 		if (group != NULL)
 		{
 			PopupMenu* menuGrp;
-			map<CeGuiString, PopupMenu*>::iterator grpIter = menuGroups.find(group->getName());
+			std::map<CeGuiString, PopupMenu*>::iterator grpIter = menuGroups.find(group->getName());
 			if (grpIter != menuGroups.end())
 			{
 				menuGrp = (*grpIter).second;

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -410,13 +410,12 @@
 			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
-			Ogre::Vector3 targetPosWindow(
-				dragcont->getPixelRect().d_left / getRoot()->getPixelSize().d_width,
-				dragcont->getPixelRect().d_top / getRoot()->getPixelSize().d_height,
-				-1);
 
+			CEGUI::Vector2 relPos = dragcont->getPosition().asRelative(getRoot()->getPixelSize());
 
-                        CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+			Ogre::Vector3 targetPosWindow(relPos.d_x, relPos.d_y,-1);
+
+            CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
 //            dragcont->destroyWindow();
 
 			Ogre::Vector3 targetPosWorldSpace =

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -22,7 +22,8 @@
 #ifdef __APPLE__
 #   include <OgreCEGUIRenderer/OgreCEGUIRenderer.h>
 #else
-#   include <OgreCEGUIRenderer.h>
+#   include <CEGUIOgreRenderer.h>
+#   include <CEGUIOgreResourceProvider.h>
 #endif
 
 #include "Actor.h"
@@ -100,8 +101,8 @@
         delete mWindowManager;
         
 
-        delete mGuiSystem;
-        delete mGuiRenderer;
+        mGuiSystem->destroy();
+        mGuiRenderer->destroySystem();
     }
 
     void UiSubsystem::initializeSubsystem()
@@ -117,15 +118,14 @@
 
         LOG_MESSAGE2(Logger::UI,
             "Initializing CEGUI Renderer.", "UiSubsystem::initializeUiSubsystem");
-        mGuiRenderer = new OgreCEGUIRenderer(CoreSubsystem::getSingleton().getRenderWindow(),
-            Ogre::RENDER_QUEUE_OVERLAY, false, 3000, sceneMgr);
+		mGuiRenderer = &OgreRenderer::bootstrapSystem(*CoreSubsystem::getSingleton().getRenderWindow());
 
         LOG_MESSAGE2(Logger::UI,
             "Initializing CEGUI System.", "UiSubsystem::initializeUiSubsystem");
-        mGuiResourceProvider = mGuiRenderer->createResourceProvider();
+        mGuiResourceProvider = &mGuiRenderer->createOgreResourceProvider();
         
-        mGuiSystem = new System(mGuiRenderer, mGuiResourceProvider,
-            NULL, NULL, (utf8*)"cegui.config", ConfigurationManager::getSingleton().getCeguiLogFile());
+		mGuiSystem = &System::create(*mGuiRenderer, mGuiResourceProvider,
+            NULL, NULL, NULL, (utf8*)"cegui.config", ConfigurationManager::getSingleton().getCeguiLogFile());
         CEGUI::Logger::getSingleton().setLoggingLevel(
             rl::Logger::getSingleton().getCeGuiLogDetail());
         LOG_MESSAGE2(Logger::UI,
@@ -169,7 +169,7 @@
         LOG_MESSAGE2(Logger::UI, "WindowFactory initialized.", "UiSubsystem::initializeUiSubsystem");
     }
 
-    CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()
+    CEGUI::OgreRenderer* UiSubsystem::getGUIRenderer()
     {
         return mGuiRenderer;
     }

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2009-11-07 19:49:41 UTC (rev 4962)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2009-11-07 20:30:04 UTC (rev 4963)
@@ -451,15 +451,7 @@
             LOG_MESSAGE(
                 Logger::UI,
                 wnd->getName()
-                + (wnd->isVisible() ? " vis" : " nvis")
-                + " @"
-                + StringConverter::toString(wnd->getPixelRect().getPosition().d_x)
-                + ", "
-                + StringConverter::toString(wnd->getPixelRect().getPosition().d_y)
-                + " "
-                + StringConverter::toString(wnd->getPixelSize().d_width)
-                + ", "
-                + StringConverter::toString(wnd->getPixelSize().d_height));
+                + (wnd->isVisible() ? " vis" : " nvis"));
         }
     }
 



From blakharaz at mail.berlios.de  Sat Nov  7 21:32:10 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 21:32:10 +0100
Subject: [Dsa-hl-svn] r4964 - rl/trunk/engine/core/lib/Debug
Message-ID: <200911072032.nA7KWADq007149@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 21:32:09 +0100 (Sat, 07 Nov 2009)
New Revision: 4964

Modified:
   rl/trunk/engine/core/lib/Debug/
Log:



Property changes on: rl/trunk/engine/core/lib/Debug
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm

   + *.asm
*.dll
*.exp
*.htm
*.idb
*.ilk
*.lib
*.ncb
*.obj
*.pdb
*.suo
RlCore.map
dependencies
logs
rl_dist




From blakharaz at mail.berlios.de  Sat Nov  7 21:36:29 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 21:36:29 +0100
Subject: [Dsa-hl-svn] r4965 - in rl/trunk/engine: common core rules script
	startup ui
Message-ID: <200911072036.nA7KaTWE008524@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 21:36:27 +0100 (Sat, 07 Nov 2009)
New Revision: 4965

Removed:
   rl/trunk/engine/common/lib/
   rl/trunk/engine/common/obj/
   rl/trunk/engine/core/lib/
   rl/trunk/engine/core/obj/
   rl/trunk/engine/rules/lib/
   rl/trunk/engine/rules/obj/
   rl/trunk/engine/script/lib/
   rl/trunk/engine/script/obj/
   rl/trunk/engine/startup/bin/
   rl/trunk/engine/startup/obj/
   rl/trunk/engine/ui/lib/
   rl/trunk/engine/ui/obj/
Log:
Removed generated or local files



From blakharaz at mail.berlios.de  Sat Nov  7 21:38:04 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 21:38:04 +0100
Subject: [Dsa-hl-svn] r4966 - rl/trunk/engine/ai
Message-ID: <200911072038.nA7Kc42h008581@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 21:38:03 +0100 (Sat, 07 Nov 2009)
New Revision: 4966

Modified:
   rl/trunk/engine/ai/
Log:
Removed generated or local files


Property changes on: rl/trunk/engine/ai
___________________________________________________________________
Name: svn:ignore
   - Makefile.in
Makefile
obj
lib

CMakeFiles

libRlAi.so*

cmake_install.cmake

   + Makefile.in
Makefile
obj
lib

CMakeFiles

libRlAi.so*

cmake_install.cmake
*.user




From blakharaz at mail.berlios.de  Sat Nov  7 21:38:29 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 21:38:29 +0100
Subject: [Dsa-hl-svn] r4967 - in rl/trunk/engine: common core rules script
	startup ui
Message-ID: <200911072038.nA7KcTnc008596@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 21:38:28 +0100 (Sat, 07 Nov 2009)
New Revision: 4967

Modified:
   rl/trunk/engine/common/
   rl/trunk/engine/core/
   rl/trunk/engine/rules/
   rl/trunk/engine/script/
   rl/trunk/engine/startup/
   rl/trunk/engine/ui/
Log:
Removed generated or local files


Property changes on: rl/trunk/engine/common
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log

libRlCommon.so*

CMakeFiles

cmake_install.cmake

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log

libRlCommon.so*

CMakeFiles

cmake_install.cmake
*.user



Property changes on: rl/trunk/engine/core
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlCore.so*

CMakeFiles

cmake_install.cmake

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlCore.so*

CMakeFiles

cmake_install.cmake
*.user



Property changes on: rl/trunk/engine/rules
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlRules.so*

CMakeFiles

cmake_install.cmake

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlRules.so*

CMakeFiles

cmake_install.cmake
*.user



Property changes on: rl/trunk/engine/script
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlScript.so*

RlExportsRUBY_wrap.*

CMakeFiles

cmake_install.cmake

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlScript.so*

RlExportsRUBY_wrap.*

CMakeFiles

cmake_install.cmake
*.user



Property changes on: rl/trunk/engine/startup
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

rastullah

CMakeFiles

cmake_install.cmake

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

rastullah

CMakeFiles

cmake_install.cmake
*.user



Property changes on: rl/trunk/engine/ui
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

libRlUi.so*

CMakeFiles

cmake_install.cmake

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

libRlUi.so*

CMakeFiles

cmake_install.cmake
*.user




From blakharaz at mail.berlios.de  Sat Nov  7 21:53:29 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 7 Nov 2009 21:53:29 +0100
Subject: [Dsa-hl-svn] r4968 - in rl/trunk/engine: common core rules script
	startup ui
Message-ID: <200911072053.nA7KrTUQ009512@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-07 21:53:23 +0100 (Sat, 07 Nov 2009)
New Revision: 4968

Modified:
   rl/trunk/engine/common/
   rl/trunk/engine/core/
   rl/trunk/engine/rules/
   rl/trunk/engine/script/
   rl/trunk/engine/startup/
   rl/trunk/engine/ui/
Log:
Ignore bin, obj, lib


Property changes on: rl/trunk/engine/common
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log

libRlCommon.so*

CMakeFiles

cmake_install.cmake
*.user

   + *.asm
*.dll
*.exp
*.htm
*.idb
*.ilk
*.lib
*.log
*.ncb
*.obj
*.pdb
*.suo
*.user
CMakeFiles
Makefile
Makefile.in
cmake_install.cmake
dependencies
lib
libRlCommon.so*
logs
obj
rl_dist



Property changes on: rl/trunk/engine/core
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlCore.so*

CMakeFiles

cmake_install.cmake
*.user

   + *.asm
*.dll
*.exp
*.htm
*.idb
*.ilk
*.lib
*.ncb
*.obj
*.pdb
*.suo
*.user
CMakeFiles
Makefile
Makefile.in
cmake_install.cmake
dependencies
lib
libRlCore.so*
logs
obj
rl_dist



Property changes on: rl/trunk/engine/rules
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlRules.so*

CMakeFiles

cmake_install.cmake
*.user

   + *.asm
*.dll
*.exp
*.htm
*.idb
*.ilk
*.lib
*.ncb
*.obj
*.pdb
*.suo
*.user
CMakeFiles
Makefile
Makefile.in
cmake_install.cmake
dependencies
lib
libRlRules.so*
logs
obj
rl_dist



Property changes on: rl/trunk/engine/script
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in

libRlScript.so*

RlExportsRUBY_wrap.*

CMakeFiles

cmake_install.cmake
*.user

   + *.asm
*.dll
*.exp
*.htm
*.idb
*.ilk
*.lib
*.ncb
*.obj
*.pdb
*.suo
*.user
CMakeFiles
Makefile
Makefile.in
RlExportsRUBY_wrap.*
cmake_install.cmake
dependencies
lib
libRlScript.so*
logs
obj
rl_dist



Property changes on: rl/trunk/engine/startup
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

rastullah

CMakeFiles

cmake_install.cmake
*.user

   + *.asm
*.dll
*.exp
*.htm
*.idb
*.ilk
*.la
*.lib
*.lo
*.log
*.ncb
*.o
*.obj
*.pdb
*.suo
*.user
CMakeFiles
Makefile
Makefile.in
bin
cmake_install.cmake
dependencies
logs
obj
rastullah
rl_dist



Property changes on: rl/trunk/engine/ui
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
Makefile
Makefile.in
*.log
*.lo
*.o
*.la

libRlUi.so*

CMakeFiles

cmake_install.cmake
*.user

   + *.asm
*.dll
*.exp
*.htm
*.idb
*.ilk
*.la
*.lib
*.lo
*.log
*.ncb
*.o
*.obj
*.pdb
*.suo
*.user
CMakeFiles
Makefile
Makefile.in
cmake_install.cmake
dependencies
lib
libRlUi.so*
logs
obj
rl_dist




From blakharaz at mail.berlios.de  Sun Nov  8 00:22:20 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 8 Nov 2009 00:22:20 +0100
Subject: [Dsa-hl-svn] r4969 - modules modules/common/gui
	rl/trunk/engine/ai/src rl/trunk/engine/common/src
	rl/trunk/engine/core/include rl/trunk/engine/core/src
	rl/trunk/engine/rules/src rl/trunk/engine/script/include
	rl/trunk/engine/script/src rl/trunk/engine/startup/src
	rl/trunk/engine/ui/src
Message-ID: <200911072322.nA7NMKE6019463@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-08 00:22:12 +0100 (Sun, 08 Nov 2009)
New Revision: 4969

Modified:
   modules/
   modules/common/gui/cegui.config
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/common/src/XmlProcessor.cpp
   rl/trunk/engine/core/include/ConfigurationManager.h
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/rules/src/DsaDataLoader.cpp
   rl/trunk/engine/script/include/AbstractMapNodeProcessor.h
   rl/trunk/engine/script/include/EntityNodeProcessor.h
   rl/trunk/engine/script/include/EnvironmentProcessor.h
   rl/trunk/engine/script/include/GameObjectNodeProcessor.h
   rl/trunk/engine/script/include/LightNodeProcessor.h
   rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
   rl/trunk/engine/script/include/PlaneNodeProcessor.h
   rl/trunk/engine/script/include/SoundNodeProcessor.h
   rl/trunk/engine/script/include/WaypointProcessor.h
   rl/trunk/engine/script/include/ZoneProcessor.h
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
   rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
   rl/trunk/engine/script/src/LightNodeProcessor.cpp
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/script/src/SoundNodeProcessor.cpp
   rl/trunk/engine/script/src/WaypointProcessor.cpp
   rl/trunk/engine/script/src/ZoneProcessor.cpp
   rl/trunk/engine/startup/src/RastullahMain.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
Log:
Made RL start again (fixed some bugs in the change to newer Ogre, CEGUI and to TinyXML)


Property changes on: modules
___________________________________________________________________
Name: svn:ignore
   - logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm

.settings

.project

   + logs
dependencies
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm

.settings

.project
cache


Modified: modules/common/gui/cegui.config
===================================================================
--- modules/common/gui/cegui.config	2009-11-07 20:53:23 UTC (rev 4968)
+++ modules/common/gui/cegui.config	2009-11-07 23:22:12 UTC (rev 4969)
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<CEGUIConfig 
-    DefaultFont="DefaultFont" 
-    Scheme="common/gui/schemes/RastullahLook.scheme" 
-/>
+<CEGUIConfig>
+	<DefaultFont name="DefaultFont" />
+	<Logging level="Standard"/>
+	<AutoLoad type="Scheme" pattern="common/gui/schemes/RastullahLook.scheme"/>
+</CEGUIConfig>

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -436,43 +436,49 @@
         CeGuiString id = getAttributeValueAsString(switchOptXml, "id");
         DialogOptionSelection* option = dynamic_cast<DialogOptionSelection*>(dialogPrototype->getOption(id));
 
-        if (!option) Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
+        if (!option)
+		{
+			Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
+		}
 
-        for (const TiXmlNode* cur = switchOptXml->FirstChild(); cur != NULL; cur = cur->NextSibling())
+        for (const TiXmlNode* cur = switchOptXml->FirstChild(); cur; cur = cur->NextSibling())
         {
-            DialogVariable* variable = processVariableClasses(cur->ToElement());
-            if (variable != NULL)
-            {
-                option->setVariable(variable);
-            }
-            else if (hasNodeName(cur, "case"))
-            {
-                DialogCondition* condition = processCase(cur->ToElement());
-                for (const TiXmlNode* caseChild = cur->FirstChild(); caseChild != NULL; caseChild = caseChild->NextSibling())
-                {
-                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
-                    if (optionCase)
-                    {
-                        option->addElement(condition, optionCase);
-                        break;
-                    }
-                }
-            }
-            // process translations
-            else if (hasNodeName(cur, "t"))
-            {
-                const TiXmlElement* translation = cur->ToElement();
-                // check loca
-                if (getAttributeValueAsStdString(translation, "language") ==
-                   ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
-                {
-                    std::string label = getAttributeValueAsStdString(translation, "label");
-                    if (!label.empty())
-                    {
-                        option->setLabel(label);
-                    }
-                }
-            }
+			if (cur->Type() == TiXmlNode::ELEMENT)
+			{
+				DialogVariable* variable = processVariableClasses(cur->ToElement());
+				if (variable != NULL)
+				{
+					option->setVariable(variable);
+				}
+				else if (hasNodeName(cur, "case"))
+				{
+					DialogCondition* condition = processCase(cur->ToElement());
+					for (const TiXmlNode* caseChild = cur->FirstChild(); caseChild != NULL; caseChild = caseChild->NextSibling())
+					{
+						DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
+						if (optionCase)
+						{
+							option->addElement(condition, optionCase);
+							break;
+						}
+					}
+				}
+				// process translations
+				else if (hasNodeName(cur, "t"))
+				{
+					const TiXmlElement* translation = cur->ToElement();
+					// check loca
+					if (getAttributeValueAsStdString(translation, "language") ==
+					   ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
+					{
+						std::string label = getAttributeValueAsStdString(translation, "label");
+						if (!label.empty())
+						{
+							option->setLabel(label);
+						}
+					}
+				}
+			}
         }
 
         return option;

Modified: rl/trunk/engine/common/src/XmlProcessor.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -54,7 +54,7 @@
 
 	for (const TiXmlNode* cur = parent->FirstChild(); cur; cur = cur->NextSibling())
 	{
-		if (cur->Type() == TiXmlNode::ELEMENT && cur->Value() == name)
+		if (cur->Type() == TiXmlNode::ELEMENT && cur->ValueTStr() == name)
 		{
 			return cur->ToElement();
 		}
@@ -69,7 +69,7 @@
 
 	for (TiXmlNode* cur = parent->FirstChild(); cur; cur = cur->NextSibling())
 	{
-		if (cur->Type() == TiXmlNode::ELEMENT && cur->Value() == name)
+		if (cur->Type() == TiXmlNode::ELEMENT && cur->ValueTStr() == name)
 		{
 			return cur->ToElement();
 		}
@@ -128,7 +128,8 @@
 CeGuiString XmlProcessor::getValueAsString(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, "XmlProcessor::getValueAsString: Element must not be NULL");
-	return element->FirstChild()->Value();
+	const utf8* value = reinterpret_cast<const utf8*>(element->FirstChild()->Value());
+	return value ? CeGuiString(value) : CeGuiString();
 }
 
 std::string XmlProcessor::getValueAsStdString(const TiXmlElement* element) const
@@ -308,8 +309,8 @@
 CeGuiString XmlProcessor::getAttributeValueAsString(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsString: Element must not be NULL");
-	CeGuiString rVal(element->Attribute(name));
-	return rVal;
+	const utf8* value = reinterpret_cast<const utf8*>(element->Attribute(name));
+	return value ? CeGuiString(value) : CeGuiString();
 }
 
 void XmlProcessor::setAttributeValueAsStdString(TiXmlElement *element, const char *const name, const std::string &value) const
@@ -321,7 +322,8 @@
 std::string XmlProcessor::getAttributeValueAsStdString(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, "XmlProcessor::getAttributeValueAsStdString: Element must not be NULL");
-	return element->Attribute(name);
+	const char* value = element->Attribute(name);
+	return value ? std::string(value) : std::string("");
 }
 
 void XmlProcessor::setAttributeValueAsBool(TiXmlElement *element, const char *const name, bool value) const

Modified: rl/trunk/engine/core/include/ConfigurationManager.h
===================================================================
--- rl/trunk/engine/core/include/ConfigurationManager.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/core/include/ConfigurationManager.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -216,11 +216,18 @@
              * Loads configuration files from the configuration directories
              *
              * Loads up to four configuration files (systemwide, user, current
-             * directory, module) and sets certain settings for the game
+             * directory) and sets certain settings for the game
              */
             void loadConfig();
 
             /**
+             * Loads module configuration files 
+             *
+			 * NOTE: run loadConfig() beforehand to get the path to that configuration file
+             */
+			void loadModulesConfig();
+
+            /**
              * Saves a configuration file in OS specific directory
              */
             void saveConfig() const;

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -305,7 +305,10 @@
         addPlugin("Plugin_ParticleFX", mOgrePluginDirectory);
         addPlugin("Plugin_OctreeSceneManager", mOgrePluginDirectory);
 		addPlugin("Plugin_CgProgramManager", mOgrePluginDirectory);
+	}
 
+	void ConfigurationManager::loadModulesConfig()
+	{
         // Load the module list
         ConfigFile* configfile = new ConfigFile();
         configfile->load(fs::path(mModulesRootDirectory + "/" + mModulesCfgFile).native_directory_string());

Modified: rl/trunk/engine/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaDataLoader.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/rules/src/DsaDataLoader.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -77,6 +77,7 @@
             {
                 Talent* t = processTalent(gruppe, talenteXml[talentIdx]);
                 //numTalent++;
+				LOG_MESSAGE("DsaDataLoader", "Found talent " + t->getName());
 				DsaManager::getSingleton()._addTalent(t);
             }
 		}

Modified: rl/trunk/engine/script/include/AbstractMapNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/AbstractMapNodeProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/AbstractMapNodeProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -30,7 +30,7 @@
     public:
         virtual ~AbstractMapNodeProcessor();
         
-        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects) = 0;
+		virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects) = 0;
         
         void setRootSceneNode(Ogre::SceneNode* node);
 

Modified: rl/trunk/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -33,7 +33,7 @@
     public:
         EntityNodeProcessor(const Ogre::String& resourcegroup);
 
-        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
 
     private:
         Ogre::String mResourceGroup;

Modified: rl/trunk/engine/script/include/EnvironmentProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EnvironmentProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/EnvironmentProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
 	class EnvironmentProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+		virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
 		void processFogSettings(const TiXmlElement* fogElem);
 		void processSkySettings(const TiXmlElement* fogElem);
 	};

Modified: rl/trunk/engine/script/include/GameObjectNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/GameObjectNodeProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/GameObjectNodeProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -24,7 +24,7 @@
     class GameObjectNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/LightNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/LightNodeProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/LightNodeProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
     class LightNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
     class ParticleSystemNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/PlaneNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/PlaneNodeProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/PlaneNodeProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -36,7 +36,7 @@
     public:
         PlaneNodeProcessor();
 
-        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
 
     private:
 

Modified: rl/trunk/engine/script/include/SoundNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/SoundNodeProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/SoundNodeProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
     class SoundNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/WaypointProcessor.h
===================================================================
--- rl/trunk/engine/script/include/WaypointProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/WaypointProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
 	class WaypointProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+		virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
 	};
 }
 

Modified: rl/trunk/engine/script/include/ZoneProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ZoneProcessor.h	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/include/ZoneProcessor.h	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
 	class ZoneProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+		virtual bool processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects);
 	};
 }
 

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -31,7 +31,7 @@
     {
     }
 
-    bool EntityNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
+    bool EntityNodeProcessor::processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "entity"))
         {

Modified: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -26,7 +26,7 @@
 
 namespace rl
 {
-	bool EnvironmentProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
+	bool EnvironmentProcessor::processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
 	{
 		if (nodeElem)
 		{

Modified: rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -24,7 +24,7 @@
 
 namespace rl
 {
-    bool GameObjectNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
+    bool GameObjectNodeProcessor::processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "gameobject"))
         {

Modified: rl/trunk/engine/script/src/LightNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/LightNodeProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/LightNodeProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -24,7 +24,7 @@
 
 namespace rl
 {
-    bool LightNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
+    bool LightNodeProcessor::processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "light"))
         {

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -147,13 +147,13 @@
                 processSceneNodes(getChildNamed(dataDocumentContent, "nodes"), loadGameObjects);
 
 			    ZoneProcessor zp;
-			    zp.processNode(getChildNamed(dataDocumentContent, "zones"), loadGameObjects);
+				zp.processNode(getChildNamed(dataDocumentContent, "zones"), mResourceGroup, loadGameObjects);
 
 			    EnvironmentProcessor ep;
-			    ep.processNode(getChildNamed(dataDocumentContent, "environment"), loadGameObjects);
+			    ep.processNode(getChildNamed(dataDocumentContent, "environment"), mResourceGroup, loadGameObjects);
 
 			    WaypointProcessor wp;
-			    wp.processNode(getChildNamed(dataDocumentContent, "waypoints"), loadGameObjects);
+			    wp.processNode(getChildNamed(dataDocumentContent, "waypoints"), mResourceGroup, loadGameObjects);
 
                 LOG_MESSAGE(Logger::SCRIPT, "Map " + mapresource + " loaded");
 
@@ -271,7 +271,7 @@
             	const TiXmlElement* curElem = cur->ToElement();
 
                 std::list<AbstractMapNodeProcessor*>::iterator it = mNodeProcessors.begin();
-                while (it != mNodeProcessors.end() && !(*it)->processNode(curElem, loadGameObjects))
+                while (it != mNodeProcessors.end() && !(*it)->processNode(curElem, mResourceGroup, loadGameObjects))
                 {
                     ++it;
                 }

Modified: rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
 
 namespace rl
 {
-    bool ParticleSystemNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
+    bool ParticleSystemNodeProcessor::processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
     {
 		if (!hasNodeName(nodeElem, "particlesystem"))
 		{

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -31,7 +31,7 @@
 	{
 	}
 
-	bool PlaneNodeProcessor::processNode(const TiXmlElement *nodeElem, bool loadGameObjects)
+	bool PlaneNodeProcessor::processNode(const TiXmlElement *nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
 	{
 		if (!hasNodeName(nodeElem, "plane"))
         {
@@ -93,7 +93,7 @@
 		plane->d = 0;
 		plane->normal = Vector3::UNIT_Y;
 
-		MeshManager::getSingleton().createPlane(entName + "Mesh", "custom", *plane, scale.x, scale.y, 10, 10, true, 1, 1, 1, Vector3::UNIT_Z);
+		MeshManager::getSingleton().createPlane(entName + "Mesh", resourceGroup, *plane, scale.x, scale.y, 10, 10, true, 1, 1, 1, Vector3::UNIT_Z);
 
 		Entity* ent = CoreSubsystem::getSingleton().getWorld()->getSceneManager()->createEntity(entName, entName + "Mesh");
 

Modified: rl/trunk/engine/script/src/SoundNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -21,7 +21,7 @@
 
 namespace rl
 {
-    bool SoundNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
+    bool SoundNodeProcessor::processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, "sound"))
         {

Modified: rl/trunk/engine/script/src/WaypointProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/WaypointProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/WaypointProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -25,7 +25,7 @@
 
 namespace rl
 {
-	bool WaypointProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
+	bool WaypointProcessor::processNode(const TiXmlElement* nodeElem, const Ogre::String& resourceGroup, bool loadGameObjects)
 	{
 		if (nodeElem == NULL)
 		{

Modified: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -30,7 +30,7 @@
 namespace rl
 {
 
-	bool ZoneProcessor::processNode(const TiXmlElement* zonesElem, bool loadGameObjects)
+	bool ZoneProcessor::processNode(const TiXmlElement* zonesElem, const Ogre::String& resourceGroup, bool loadGameObjects)
 	{
 		if (zonesElem == NULL)
 		{

Modified: rl/trunk/engine/startup/src/RastullahMain.cpp
===================================================================
--- rl/trunk/engine/startup/src/RastullahMain.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/startup/src/RastullahMain.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -54,13 +54,14 @@
         Ogre::String ogreLogFile = rl::ConfigurationManager::getSingleton().getOgreLogFile();
         Ogre::String rlLogFile = rl::ConfigurationManager::getSingleton().getRastullahLogFile();
 
-
         logger = new rl::Logger(logDir, ogreLogFile, rlLogFile);
         // @todo in ConfigDatei auslagern/ oder auch Parameter
 
         rl::Logger::getSingleton().setLogDetail(
             rl::ConfigurationManager::getSingleton().getLogLevel());
 
+        rl::ConfigurationManager::getSingleton().loadModulesConfig();
+
         core = new rl::CoreSubsystem();
         core->setDeveloperMode(developerMode);
         LOG_MESSAGE_SHORT("CoreSubsystem gestartet");

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-11-07 20:53:23 UTC (rev 4968)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-11-07 23:22:12 UTC (rev 4969)
@@ -118,7 +118,7 @@
 
         LOG_MESSAGE2(Logger::UI,
             "Initializing CEGUI Renderer.", "UiSubsystem::initializeUiSubsystem");
-		mGuiRenderer = &OgreRenderer::bootstrapSystem(*CoreSubsystem::getSingleton().getRenderWindow());
+		mGuiRenderer = &OgreRenderer::create(*CoreSubsystem::getSingleton().getRenderWindow());
 
         LOG_MESSAGE2(Logger::UI,
             "Initializing CEGUI System.", "UiSubsystem::initializeUiSubsystem");



From blakharaz at mail.berlios.de  Sat Nov 14 17:42:03 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 14 Nov 2009 17:42:03 +0100
Subject: [Dsa-hl-svn] r4970 - in rl/trunk/engine: core/src ui/src
Message-ID: <200911141642.nAEGg3fg018040@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-14 17:42:02 +0100 (Sat, 14 Nov 2009)
New Revision: 4970

Modified:
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
Log:
RL compiles also with Ogre 1.6


Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-11-07 23:22:12 UTC (rev 4969)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-11-14 16:42:02 UTC (rev 4970)
@@ -194,10 +194,12 @@
         }
 
         // Find out, what Renderer plugins are available
-        RenderSystemList rsl = mOgreRoot->getAvailableRenderers();
-        RenderSystemList::iterator it;
-
-        for (it = rsl.begin(); it != rsl.end(); it++)
+#if OGRE_VERSION_MINOR == 7 || OGRE_VERSION_MINOR == 8
+        const RenderSystemList& rsl = mOgreRoot->getAvailableRenderers();
+#else 
+        RenderSystemList rsl = *mOgreRoot->getAvailableRenderers();
+#endif        
+        for (RenderSystemList::iterator it = rsl.begin(); it != rsl.end(); it++)
         {
             if ((*it)->getName() == ConfigurationManager::getSingleton().getStringSetting(
                 "Video", "Render System"))

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2009-11-07 23:22:12 UTC (rev 4969)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2009-11-14 16:42:02 UTC (rev 4970)
@@ -177,9 +177,13 @@
     {
         Root* root = Ogre::Root::getSingletonPtr();
         
+		Ogre::RenderSystem* renderer = root->getRenderSystem();
+
+#if OGRE_VERSION_MINOR == 7 || OGRE_VERSION_MINOR == 8
         const RenderSystemList& renderers = root->getAvailableRenderers();
-		Ogre::RenderSystem* renderer = root->getRenderSystem();
-        
+#else 
+        const RenderSystemList renderers = *root->getAvailableRenderers();
+#endif        
         createElements(mVideoRenderer, renderers.size());
 
         for (unsigned int i = 0; i < renderers.size(); ++i)



From blakharaz at mail.berlios.de  Mon Nov 16 22:19:28 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 16 Nov 2009 22:19:28 +0100
Subject: [Dsa-hl-svn] r4971 - in rl/trunk/engine: core/src ui ui/src
Message-ID: <200911162119.nAGLJSQK030653@sheep.berlios.de>

Author: blakharaz
Date: 2009-11-16 22:19:13 +0100 (Mon, 16 Nov 2009)
New Revision: 4971

Removed:
   rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
Modified:
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/ui/CMakeLists.txt
   rl/trunk/engine/ui/src/UiSubsystem.cpp
Log:
Some fixes for Linux and Ogre 1.7


Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-11-14 16:42:02 UTC (rev 4970)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-11-16 21:19:13 UTC (rev 4971)
@@ -199,7 +199,7 @@
 #else 
         RenderSystemList rsl = *mOgreRoot->getAvailableRenderers();
 #endif        
-        for (RenderSystemList::iterator it = rsl.begin(); it != rsl.end(); it++)
+        for (RenderSystemList::const_iterator it = rsl.begin(); it != rsl.end(); it++)
         {
             if ((*it)->getName() == ConfigurationManager::getSingleton().getStringSetting(
                 "Video", "Render System"))

Modified: rl/trunk/engine/ui/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ui/CMakeLists.txt	2009-11-14 16:42:02 UTC (rev 4970)
+++ rl/trunk/engine/ui/CMakeLists.txt	2009-11-16 21:19:13 UTC (rev 4971)
@@ -47,7 +47,6 @@
 src/ItemDescriptionDragContainer.cpp
 src/ItemIconDragContainer.cpp
 src/JournalWindow.cpp
-src/ListboxWrappedTextItem.cpp
 src/LogWindow.cpp
 src/MainMenuWindow.cpp
 src/MainMenuEngineWindow.cpp

Deleted: rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
===================================================================
--- rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2009-11-14 16:42:02 UTC (rev 4970)
+++ rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2009-11-16 21:19:13 UTC (rev 4971)
@@ -1,222 +0,0 @@
-/************************************************************************
-	filename: 	ListboxWrappedTextItem.cpp
-	created:	01/8/2006
-	author:		Paul D Turner & The CEGUI Development Team, Philipp Walser
-
-	purpose:	Implementation of List box text items with WordWrapping
-*************************************************************************/
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "ListboxWrappedTextItem.h"
-#include "CEGUIFontManager.h"
-#include "CEGUIFont.h"
-#include "CEGUIWindow.h"
-#include "CEGUIImage.h"
-
-// Start of CEGUI namespace section
-namespace CEGUI
-{
-    /*************************************************************************
-    Constants
-    *************************************************************************/
-    const colour    ListboxWrappedTextItem::DefaultTextColour   = 0xFFFFFFFF;
-    const String    ListboxWrappedTextItem::ds_bullet           = " - ";
-
-
-    /*************************************************************************
-    Constructor
-    *************************************************************************/
-    ListboxWrappedTextItem::ListboxWrappedTextItem(const String& text, int padding,
-        bool draw_bullet, uint item_id,
-        void* item_data, bool disabled, bool auto_delete) :
-    ListboxTextItem(text, item_id, item_data, disabled, auto_delete),
-        d_textCols(DefaultTextColour, DefaultTextColour, DefaultTextColour, DefaultTextColour),
-        d_padding(padding), d_draw_bullet(draw_bullet),
-        d_font(0), d_textFormatting(WordWrapLeftAligned)
-    {
-    }
-
-    /*************************************************************************
-    Destructor
-    *************************************************************************/
-    ListboxWrappedTextItem::~ListboxWrappedTextItem()
-    {
-    }
-
-
-    /*************************************************************************
-    Return a pointer to the font being used by this ListboxWrappedTextItem
-    *************************************************************************/
-    const Font* ListboxWrappedTextItem::getFont(void) const
-    {
-        // prefer out own font
-        if (d_font)
-        {
-            return d_font;
-        }
-        // try our owner window's font setting (may be null if owner uses no existant default font)
-        else if (d_owner)
-        {
-            return d_owner->getFont();
-        }
-        // no owner, just use the default (which may be NULL anyway)
-        else
-        {
-            return System::getSingleton().getDefaultFont();
-        }
-
-    }
-
-
-    /*************************************************************************
-    Set the font to be used by this ListboxWrappedTextItem
-    *************************************************************************/
-    void ListboxWrappedTextItem::setFont(const String& font_name)
-    {
-        setFont(FontManager::getSingleton().getFont(font_name));
-    }
-
-    /*************************************************************************
-    Return the rendered pixel size of this list box item.
-    *************************************************************************/
-    Size ListboxWrappedTextItem::getPixelSize(void) const
-    {
-        Size size(0,0);
-
-        if (d_owner != NULL)
-        {
-            size.d_width = d_owner->getPixelSize().d_width - 25.0f;
-        }
-
-        Font* font = const_cast<Font*>(getFont());
-
-        if (font != NULL)
-        {
-            size.d_height = PixelAligned(font->getLineSpacing());
-            if(size.d_width == 0)
-            {
-                size.d_width = PixelAligned(font->getTextExtent(d_itemText));
-            }
-
-            Rect formatRect;
-
-            formatRect.setPosition(CEGUI::Point(0,0));
-            if (d_draw_bullet)
-            {
-                formatRect.d_left = font->getTextExtent(ds_bullet);
-            }
-            formatRect.setSize(size);
-            uint lines = font->getFormattedLineCount(d_itemText, formatRect, d_textFormatting);
-            size.d_height *= lines;
-            size.d_height += d_padding;
-        }
-
-        return size;
-    }
-
-
-    /*************************************************************************
-    Draw the list box item in its current state.
-    *************************************************************************/
-    void ListboxWrappedTextItem::draw(const Vector3& position, float alpha, const Rect& clipper) const
-    {
-        if (d_selected && (d_selectBrush != 0))
-        {
-            d_selectBrush->draw(clipper, position.d_z, clipper,
-                getModulateAlphaColourRect(d_selectCols, alpha));
-        }
-
-        Font* font = const_cast<Font*>(getFont());
-
-        if (font)
-        {
-            float left_offset = 0;
-            if (d_draw_bullet)
-            {
-                left_offset = font->getTextExtent(ds_bullet);
-            }
-
-            Vector3 finalPos = position;
-            finalPos.d_y -= PixelAligned((font->getLineSpacing() - font->getBaseline()) * 0.5f);
-            Rect draw_area = Rect(finalPos.d_x, finalPos.d_y,
-                clipper.d_right, finalPos.d_y);
-            font->drawText(ds_bullet, draw_area, finalPos.d_z, clipper, d_textFormatting,
-                getModulateAlphaColourRect(d_textCols, alpha));
-            draw_area.d_left += left_offset;
-            font->drawText(d_itemText, draw_area, finalPos.d_z, clipper, d_textFormatting,
-                getModulateAlphaColourRect(d_textCols, alpha));
-        }
-
-    }
-
-    void ListboxWrappedTextItem::draw(RenderCache& cache,const Rect& targetRect,
-        float zBase, float alpha, const Rect* clipper) const
-    {
-        if (d_selected && d_selectBrush != 0)
-        {
-            cache.cacheImage(*d_selectBrush, targetRect, zBase,
-                getModulateAlphaColourRect(d_selectCols, alpha), clipper);
-        }
-
-        Font* font = const_cast<Font*>(getFont());
-
-        if (font)
-        {
-            float left_offset = 0;
-            if (d_draw_bullet)
-            {
-                left_offset = font->getTextExtent(ds_bullet);
-            }
-
-            Rect finalPos = targetRect;
-            finalPos.d_top -= (font->getLineSpacing() - font->getBaseline()) * 0.5f;
-            cache.cacheText(ds_bullet, font, d_textFormatting, finalPos, zBase,
-                getModulateAlphaColourRect(d_textCols, alpha), clipper);
-            finalPos.d_left += left_offset;
-            cache.cacheText(d_itemText, font, d_textFormatting, finalPos, zBase,
-                getModulateAlphaColourRect(d_textCols, alpha), clipper);
-        }
-    }
-
-
-    /*************************************************************************
-    Set the colours used for text rendering.
-    *************************************************************************/
-    void ListboxWrappedTextItem::setTextColours(colour top_left_colour,
-        colour top_right_colour,
-        colour bottom_left_colour,
-        colour bottom_right_colour)
-    {
-        d_textCols.d_top_left		= top_left_colour;
-        d_textCols.d_top_right		= top_right_colour;
-        d_textCols.d_bottom_left	= bottom_left_colour;
-        d_textCols.d_bottom_right	= bottom_right_colour;
-    }
-
-    void ListboxWrappedTextItem::setTextFormatting(TextFormatting fmt)
-    {
-        d_textFormatting = fmt;
-    }
-
-    const TextFormatting& ListboxWrappedTextItem::getTextFormatting() const
-    {
-        return d_textFormatting;
-    }
-
-
-} // End of  CEGUI namespace section

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-11-14 16:42:02 UTC (rev 4970)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-11-16 21:19:13 UTC (rev 4971)
@@ -22,8 +22,8 @@
 #ifdef __APPLE__
 #   include <OgreCEGUIRenderer/OgreCEGUIRenderer.h>
 #else
-#   include <CEGUIOgreRenderer.h>
-#   include <CEGUIOgreResourceProvider.h>
+#   include <RendererModules/Ogre/CEGUIOgreRenderer.h>
+#   include <RendererModules/Ogre/CEGUIOgreResourceProvider.h>
 #endif
 
 #include "Actor.h"



From melven at mail.berlios.de  Fri Nov 27 22:56:42 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 27 Nov 2009 22:56:42 +0100
Subject: [Dsa-hl-svn] r4972 - in dependencies/OgreNewt:
	demos/Demo09_PlayerController inc src
Message-ID: <200911272156.nARLugW8000634@sheep.berlios.de>

Author: melven
Date: 2009-11-27 22:56:39 +0100 (Fri, 27 Nov 2009)
New Revision: 4972

Modified:
   dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h
   dependencies/OgreNewt/inc/OgreNewt.h
   dependencies/OgreNewt/inc/OgreNewt_Body.h
   dependencies/OgreNewt/inc/OgreNewt_Joint.h
   dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h
   dependencies/OgreNewt/inc/OgreNewt_Vehicle.h
   dependencies/OgreNewt/src/OgreNewt_Body.cpp
   dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
Log:
added a destructor callback for OgreNewt::Joint and OgreNewt::Body (because these can be destroyed indirectly through newton callbacks!)


Modified: dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp	2009-11-27 21:56:39 UTC (rev 4972)
@@ -134,6 +134,25 @@
 		OgreNewt::Body* bod = makeSimpleBox( size, pos, orient );
 	}
 
+
+    // player playground
+
+    bod = NULL;
+    for( int i = 0; i < 20; i++ )
+    {
+        bod = makeSimpleBox( Ogre::Vector3(4.0, 0.4, 1.0), Ogre::Vector3(15.0, -10.0+i*0.4, -2.0-i*0.4), Ogre::Quaternion::IDENTITY);
+        bod->setMassMatrix(0, Ogre::Vector3::ZERO);
+    }
+
+    bod = makeSimpleBox( Ogre::Vector3(10.0, 0.4, 10.0), Ogre::Vector3(-17.0, -8.0, -15.0), Ogre::Quaternion(Ogre::Degree(60), Ogre::Vector3::UNIT_X));
+    bod->setMassMatrix(0, Ogre::Vector3::ZERO);
+
+    bod = makeSimpleBox( Ogre::Vector3(10.0, 0.4, 10.0), Ogre::Vector3(-27.0, -8.5, -15.0), Ogre::Quaternion(Ogre::Degree(20), Ogre::Vector3::UNIT_X));
+    bod->setMassMatrix(0, Ogre::Vector3::ZERO);
+    
+    bod = makeSimpleBox( Ogre::Vector3(10.0, 0.4, 10.0), Ogre::Vector3(-37.0, -8.0, -15.0), Ogre::Quaternion(Ogre::Degree(80), Ogre::Vector3::UNIT_Y) * Ogre::Quaternion(Ogre::Degree(50), Ogre::Vector3::UNIT_X));
+    bod->setMassMatrix(0, Ogre::Vector3::ZERO);
+
     makePlayer();
 
 	
@@ -171,7 +190,7 @@
 }
 
 
-OgreNewt::Body* OgreNewtonApplication::makeSimpleBox( Ogre::Vector3& size, Ogre::Vector3& pos, Ogre::Quaternion& orient )
+OgreNewt::Body* OgreNewtonApplication::makeSimpleBox( const Ogre::Vector3& size, const Ogre::Vector3& pos, const Ogre::Quaternion& orient )
 {
 	Entity* box1;
 	SceneNode* box1node;

Modified: dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h	2009-11-27 21:56:39 UTC (rev 4972)
@@ -30,7 +30,7 @@
 	void destroyScene();
 
 	// our custom function to simplify making simpe dynamics rigid body boxes.
-	OgreNewt::Body* makeSimpleBox( Ogre::Vector3& size, Ogre::Vector3& pos, Ogre::Quaternion& orient );
+	OgreNewt::Body* makeSimpleBox( const Ogre::Vector3& size, const Ogre::Vector3& pos, const Ogre::Quaternion& orient );
 
     void makePlayer();
 

Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-11-27 21:56:39 UTC (rev 4972)
@@ -66,6 +66,7 @@
     \section new New in this version
 
     New in this version
+        - added a destructor callback for OgreNewt::Joint and OgreNewt::Body (because these can be destroyed indirectly through newton callbacks!)
         - removed CollisionTools::CollisionCalculateAABB (because there's col->getAABB() ) and added a function to calculate the correct AABB
           CollisionTools::CollisionCalculateFittingAABB
         - ConvexCast:

Modified: dependencies/OgreNewt/inc/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-11-27 21:56:39 UTC (rev 4972)
@@ -35,7 +35,7 @@
         this class represents a NewtonBody rigid body!
 */
 //! main class for all Rigid Bodies in the system.
-class _OgreNewtExport Body
+class _OgreNewtExport Body : public _DestructorCallback<Body>
 {
 public:
     //! custom force callback.

Modified: dependencies/OgreNewt/inc/OgreNewt_Joint.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-11-27 21:56:39 UTC (rev 4972)
@@ -25,7 +25,7 @@
 /*!
     this class is inherited by all other specific joint types.
 */
-class _OgreNewtExport Joint
+class _OgreNewtExport Joint : public _DestructorCallback<Joint>
 {
 public:
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h	2009-11-27 21:56:39 UTC (rev 4972)
@@ -79,6 +79,64 @@
     class CollisionSerializer;
     class ConvexCollision;
     class Debugger;
+
+
+    //! helper class: OgreNewt-classes can derive from this class to implement a destructor-callback
+    /*!
+     * Consider the following example:
+     * You delete a body thats part of joint, so newton deletes the joint, then you could still have a pointer to that joint. Using this pointer will fail,
+     * thats why you need a way to get to know, when an object gets deleted...
+     */
+    template<class DerivedClass>
+    class _DestructorCallback
+    {
+        public:
+            //! destructor callback
+            /*!
+             * This function is called, when the object is destroyed. It's only argument is a pointer to the instance currently destroyed
+             * @warning the pointer to the destroyed class instance is already invalid (the class is already destroyed!)
+             */
+            typedef boost::function<void(DerivedClass*)> DestructorCallbackFunction;
+
+            //! constructor
+            _DestructorCallback() : m_callback(NULL) {}
+
+            //! destructor
+            virtual ~_DestructorCallback()
+            {
+                if( m_callback )
+                    m_callback((DerivedClass*)(this));
+            }
+
+            //! remove any destructor callback
+            void removeDestructorCallback() {m_callback = NULL;}
+
+            //! set the destructor callback
+            /*!
+             *
+             * This specifies a custom callback that's called when this class is destroyed. If you are using a standard non-member function,
+             * or a static member function, you can simply pass a pointer to the function here.. like this:
+             *      setDestructorCallback( &myCallbackFunction );
+             *
+             * If you want to bind to a class member, you also need to pass a pointer to the class itself, using the boost::bind system, like so:
+             *      setDestructorCallback( boost::bind( &MyClass::myCallback, (MyClass*)classInstance, _1 ) );  (from outside the class) or:
+             *      setDestructorCallback( boost::bind( &MyClass::myCallback, this, _1 ) );  (from inside the class).
+             *
+             * You can also use:
+             *      setDestructorCallback<>( &MyClass::myCallback, (MyClass*)classInstance );  (from outside the class) or:
+             *      setDestructorCallback<>( &MyClass::myCallback, this );  (from inside the class).
+             * Note: Notice the "<>" after the function name.
+             *
+             */
+            void setDestructorCallback( DestructorCallbackFunction fun ) { m_callback = fun; }
+            template<class c> void setDestructorCallback( boost::function<void(c*, DerivedClass*)> callback, c *instancedClassPointer )
+            {
+                setDestructorCallback( boost::bind(callback, instancedClassPointer, _1) );
+            }
+        private:
+            DestructorCallbackFunction m_callback;
+
+    };
 }
 
 #endif 

Modified: dependencies/OgreNewt/inc/OgreNewt_Vehicle.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Vehicle.h	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/inc/OgreNewt_Vehicle.h	2009-11-27 21:56:39 UTC (rev 4972)
@@ -25,7 +25,7 @@
 /*!
     this class represents a basic vehicle, meant to be inherited by the user, with functionality added.
 */
-    class _OgreNewtExport Vehicle
+    class _OgreNewtExport Vehicle : public _DestructorCallback<Vehicle>
     {
     public:
 

Modified: dependencies/OgreNewt/src/OgreNewt_Body.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-11-27 21:56:39 UTC (rev 4972)
@@ -351,9 +351,9 @@
     getPositionOrientation( bodypos, bodyorient );
 
     Ogre::Vector3 localMassCenter = getCenterOfMass();
-    Ogre::Vector3 globalMassCenter = bodyorient * localMassCenter;
+    Ogre::Vector3 globalMassCenter = bodypos + bodyorient * localMassCenter;
 
-    Ogre::Vector3 topoint = pos - bodypos - globalMassCenter;
+    Ogre::Vector3 topoint = pos - globalMassCenter;
     Ogre::Vector3 torque = topoint.crossProduct( force );
 
     addForce( force );

Modified: dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-11-16 21:19:13 UTC (rev 4971)
+++ dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-11-27 21:56:39 UTC (rev 4972)
@@ -265,15 +265,18 @@
     Ogre::Quaternion ori;
     Ogre::Real invMass;
     Ogre::Vector3 invInertia;
-    Ogre::Vector3 frontDir, upDir, strafeDir;
+    Ogre::Vector3 localFrontDir, localUpDir, localStrafeDir, globalFrontDir, globalUpDir, globalStrafeDir;
 
     m_body->getInvMass(invMass, invInertia);
     m_body->getPositionOrientation(pos,ori);
 
     Ogre::Quaternion localFrameRotation = m_localFrame.extractQuaternion();
-    frontDir = localFrameRotation * Ogre::Vector3::NEGATIVE_UNIT_Z;
-    upDir = localFrameRotation * Ogre::Vector3::UNIT_Y;
-    strafeDir = localFrameRotation * Ogre::Vector3::UNIT_X;
+    localFrontDir = localFrameRotation * Ogre::Vector3::NEGATIVE_UNIT_Z;
+    localUpDir = localFrameRotation * Ogre::Vector3::UNIT_Y;
+    localStrafeDir = localFrameRotation * Ogre::Vector3::UNIT_X;
+    globalFrontDir = ori*localFrontDir;
+    globalUpDir = ori*localUpDir;
+    globalStrafeDir = ori*localStrafeDir;
 
 
 
@@ -283,8 +286,7 @@
 
 
     // if the body has rotated by some amount, there will be a plane of rotation
-    Ogre::Vector3 realUp = ori*(localFrameRotation*Ogre::Vector3::UNIT_Y);
-    Ogre::Vector3 lateralDir = realUp.crossProduct(upDir);
+    Ogre::Vector3 lateralDir = globalUpDir.crossProduct(localUpDir);
     Ogre::Real mag = lateralDir.length();
     if( mag > 1.0e-3f)
     {
@@ -297,14 +299,14 @@
 
         // in theory only one correction is needed, but this produces instability as the body may move sideway.
         // a lateral correction prevent this from happening.
-        Ogre::Vector3 frontDir = lateralDir.crossProduct(upDir);
+        Ogre::Vector3 frontDir = lateralDir.crossProduct(globalUpDir);
         addAngularRow(Ogre::Radian(0), lateralDir);
     }
     else
     {
         // if the angle error is very small then two angular correction along the plane axis do the trick
-        addAngularRow( Ogre::Radian(0), strafeDir );
-        addAngularRow( Ogre::Radian(0), frontDir );
+        addAngularRow( Ogre::Radian(0), globalStrafeDir );
+        addAngularRow( Ogre::Radian(0), globalFrontDir );
     }
 
 
@@ -313,7 +315,7 @@
     if( m_playerState == PS_ONLAND )
     {
         Ogre::Vector3 vel = m_body->getVelocity();
-        Ogre::Vector3 desiredVel = frontDir* m_forwardSpeed + upDir * (vel.dotProduct(upDir)) + strafeDir * m_sideSpeed;
+        Ogre::Vector3 desiredVel = globalFrontDir* m_forwardSpeed + globalUpDir * (vel.dotProduct(globalUpDir)) + globalStrafeDir * m_sideSpeed;
         
         m_body->setVelocity(desiredVel);
     }
@@ -525,7 +527,7 @@
             Ogre::Vector3 newPos;
             
             newPos = castStart + (castTarget - castStart)*dist - step + upDir * m_kinematicCushion;
-            m_body->setPositionOrientation(pos, ori);
+            m_body->setPositionOrientation(newPos, ori);
 
             Ogre::Vector3 floorNormal = allBodyConvexCast.getInfoAt(0).mContactNormal;
 
@@ -596,7 +598,7 @@
                 
                 allBodyConvexCast2.go(m_bodyFloorSensorShape, castStart2, ori, castTarget2, 1, threadIndex, filterBodies);
 
-                if( distanceToFirstHit >= allBodyConvexCast2.getDistanceToFirstHit() && allBodyConvexCast2.getContactsCount() > 0 )
+                if( distanceToFirstHit >= allBodyConvexCast2.getDistanceToFirstHit() || allBodyConvexCast2.getContactsCount() == 0 )
                 {
                     setPlayerState(PS_ONILLEGALRAMP);
                 }
@@ -623,7 +625,7 @@
                         castStart3 = pos + step + upDir*(m_stairHeight - m_kinematicCushion);
                         castTarget3 = castStart3 - upDir*2.0f * m_stairHeight;
 
-                        allBodyConvexCast3.go(m_bodyFloorSensorShape, castStart3, ori, castTarget3, 1, threadIndex, filterBodies);
+                        allBodyConvexCast3.go(m_bodyFloorSensorShape, castStart3, ori, castTarget3, 1, threadIndex);
                         contactCount = allBodyConvexCast3.getContactsCount();
                         if( contactCount > 0 )
                         {



From melven at mail.berlios.de  Fri Nov 27 23:01:04 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 27 Nov 2009 23:01:04 +0100
Subject: [Dsa-hl-svn] r4973 - dependencies/OgreNewt/inc
Message-ID: <200911272201.nARM14lx001092@sheep.berlios.de>

Author: melven
Date: 2009-11-27 23:01:03 +0100 (Fri, 27 Nov 2009)
New Revision: 4973

Modified:
   dependencies/OgreNewt/inc/OgreNewt.h
Log:
updated some comments (version number)


Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-11-27 21:56:39 UTC (rev 4972)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-11-27 22:01:03 UTC (rev 4973)
@@ -9,9 +9,9 @@
 
     main header file.
 
-    current version:  2.07.0
+    current version:  2.07.1
 
-        Newton version: 2.07 (beta)
+        Newton version: at least 2.07 (beta)
 
         Ogre version: Shoggoth (1.6.x)
 



