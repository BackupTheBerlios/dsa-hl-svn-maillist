<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4828 - rl/trunk/editors/Lockenwickler/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4828%20-%20rl/trunk/editors/Lockenwickler/src&In-Reply-To=%3C200903141032.n2EAWVlM008181%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001884.html">
   <LINK REL="Next"  HREF="001886.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4828 - rl/trunk/editors/Lockenwickler/src</H1>
    <B>fusion2 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4828%20-%20rl/trunk/editors/Lockenwickler/src&In-Reply-To=%3C200903141032.n2EAWVlM008181%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4828 - rl/trunk/editors/Lockenwickler/src">fusion2 at mail.berlios.de
       </A><BR>
    <I>Sat Mar 14 11:32:31 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001884.html">[Dsa-hl-svn] r4827 - dependencies/OgreNewt
</A></li>
        <LI>Next message: <A HREF="001886.html">[Dsa-hl-svn] r4829 - rl/trunk/editors/Lockenwickler/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1885">[ date ]</a>
              <a href="thread.html#1885">[ thread ]</a>
              <a href="subject.html#1885">[ subject ]</a>
              <a href="author.html#1885">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fusion2
Date: 2009-03-14 11:32:22 +0100 (Sat, 14 Mar 2009)
New Revision: 4828

Modified:
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py
Log:
- adjusted the content margins of all windows to waste much less space now
- fixed lots of bugs in the map loading and saving code
- exposed some more properties to the ObjectPropertyWindow when having an entity selected

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -1,531 +1,533 @@
- #################################################
- #################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import os
-import sys
-import platform
-import subprocess
-
-sys.path.insert(0,'..')
-import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from MaterialSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from ModuleExplorer import *
-from NewModuleWizard import *
-from PivotRenderQueueListener import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-#        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
-#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-#        splash.setMask(pixmap.mask())
-#        splash.showMessage(&quot;Starting...&quot;)
-#        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
-        self.moduleExplorerWin = ModuleExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
-
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
-        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
-            self.prefDialog.show()
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        else:
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        
-        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
-        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
-        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
-        
-        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
-        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
-        
-        self.editorSetupFinished = False
-        
-#        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName(&quot;MainWindow&quot;)
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName(&quot;menubar&quot;)
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName(&quot;menuFile&quot;)
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName(&quot;menuView&quot;)
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName(&quot;statusbar&quot;)
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
-        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
-
-        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;fileopen.png&quot;,  &quot;Open Module&quot;)
-        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
-        
-        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filesave.png&quot;,  &quot;Save Module&quot;)
-        self.actionSave.setObjectName(&quot;actionSave&quot;)
-        
-        self.actionRunModule = self.createAction(&quot;&amp;Save and Run&quot;,  self.actionRunModuleSlot,  &quot;Alt+R&quot;,  &quot;fileexport.png&quot;,  &quot;Save And Run Module&quot;)
-        self.actionRunModule.setObjectName(&quot;actionRunModule&quot;)
-
-        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt+Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
-        self.actionClose.setObjectName(&quot;actionQuit&quot;)
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
-        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
-
-        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
-        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
-
-        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
-        self.actionCut.setObjectName(&quot;actionCut&quot;)
-
-        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
-        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
-
-        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
-        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
-
-        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
-        self.actionMove.setObjectName(&quot;actionMove&quot;)
-
-        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
-        self.actionScale.setObjectName(&quot;actionScale&quot;)
-
-        self.actionOneClickEntityPlacement = self.createAction(&quot;&amp;OneClickEntityPlacement&quot;,  self.actionOneClickEntityPlacementSlot,  &quot;&quot;,  &quot;resizecol.png&quot;,  &quot;Add an Entity just by a click&quot;)
-        self.actionOneClickEntityPlacement.setObjectName(&quot;actionOneClickEntityPlacement&quot;)
-        self.actionOneClickEntityPlacement.setCheckable(True)
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleModuleExplorer,  &quot;Alt+E&quot;,  &quot;view_tree.png&quot;,  &quot;Module Explorer&quot;,  False)
-        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
-        
-        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt+P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
-        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
-
-        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt+P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
-        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
-
-        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt+O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
-        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-        
-        self.actionMaterial_Selection = self.createAction(&quot;Material &amp;Preview Window&quot;,  self.toggleMaterialPreviewWindow,  &quot;Alt+M&quot;,  &quot;colors.png&quot;,  &quot;Material Preview&quot;)
-        self.actionMaterial_Selection.setObjectName(&quot;actionMaterial_Selection&quot;)
-
-        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt+G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
-        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt+C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
-        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionSave)
-        self.menuFile.addAction(self.actionRunModule)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
-        
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionMaterial_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Module Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
-        if platform.system() == &quot;Windows&quot;:
-            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
-        else:
-            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.pivotRenderQueueListener = PivotRenderQueueListener()
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
-        
-        self.moduleName = &quot;&quot;
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-        self.gocManager = self.moduleManager.gocManager
-        
-        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-        
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def finishEditorSetup(self):
-        if not self.editorSetupFinished:
-            og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-            self.moduleManager.pivot.hide()
-            self.editorSetupFinished = True
-        
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-        if platform.system() == &quot;Linux&quot;:
-            self.ogreMainWindow.updateRenderWindow()
-            self.modelSelectionDialog.updateRenderWindow()
-            self.materialSelectionDialog.updateRenderWindow()
-
-    def actionOpenSlot(self):
-        self.finishEditorSetup()
-        self.moduleManager.openLoadModuleDialog()
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self.moduleManager, self)
-        newModuleWiz.exec_()
-        return
-        
-    def actionSaveSlot(self):
-        self.moduleManager.save()
-        
-    def actionRunModuleSlot(self):
-        self.moduleManager.save()
-        if platform.system() == &quot;Windows&quot;:
-            workingDir = self.prefDialog.moduleCfgPath.replace(&quot;/modules/modules.cfg&quot;, &quot;&quot;)
-            executable = os.path.join(workingDir, &quot;Rastullah.exe&quot;)
-            executable = executable.replace(&quot;/&quot;,  &quot;\\&quot;)
-            if os.path.isfile(executable):
+ #################################################
+ #################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import os
+import sys
+import platform
+import subprocess
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from MaterialSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import *
+from ModuleExplorer import *
+from NewModuleWizard import *
+from PivotRenderQueueListener import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage(&quot;Starting...&quot;)
+#        splash.show()
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
+
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
+        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
+            self.prefDialog.show()
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
+        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
+        
+        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
+        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
+        
+        self.editorSetupFinished = False
+        
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName(&quot;MainWindow&quot;)
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setContentsMargins(0, 0, 0, 0)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName(&quot;menubar&quot;)
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName(&quot;menuFile&quot;)
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName(&quot;menuView&quot;)
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName(&quot;statusbar&quot;)
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
+        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
+
+        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;fileopen.png&quot;,  &quot;Open Module&quot;)
+        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
+        
+        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filesave.png&quot;,  &quot;Save Module&quot;)
+        self.actionSave.setObjectName(&quot;actionSave&quot;)
+        
+        self.actionRunModule = self.createAction(&quot;&amp;Save and Run&quot;,  self.actionRunModuleSlot,  &quot;Alt+R&quot;,  &quot;fileexport.png&quot;,  &quot;Save And Run Module&quot;)
+        self.actionRunModule.setObjectName(&quot;actionRunModule&quot;)
+
+        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt+Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
+        self.actionClose.setObjectName(&quot;actionQuit&quot;)
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
+        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
+
+        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
+        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
+
+        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
+        self.actionCut.setObjectName(&quot;actionCut&quot;)
+
+        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
+        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
+
+        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
+        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
+
+        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
+        self.actionMove.setObjectName(&quot;actionMove&quot;)
+
+        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
+        self.actionScale.setObjectName(&quot;actionScale&quot;)
+
+        self.actionOneClickEntityPlacement = self.createAction(&quot;&amp;OneClickEntityPlacement&quot;,  self.actionOneClickEntityPlacementSlot,  &quot;&quot;,  &quot;resizecol.png&quot;,  &quot;Add an Entity just by a click&quot;)
+        self.actionOneClickEntityPlacement.setObjectName(&quot;actionOneClickEntityPlacement&quot;)
+        self.actionOneClickEntityPlacement.setCheckable(True)
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleModuleExplorer,  &quot;Alt+E&quot;,  &quot;view_tree.png&quot;,  &quot;Module Explorer&quot;,  False)
+        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
+        
+        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt+P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
+        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
+
+        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt+P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
+        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
+
+        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt+O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
+        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+        
+        self.actionMaterial_Selection = self.createAction(&quot;Material &amp;Preview Window&quot;,  self.toggleMaterialPreviewWindow,  &quot;Alt+M&quot;,  &quot;colors.png&quot;,  &quot;Material Preview&quot;)
+        self.actionMaterial_Selection.setObjectName(&quot;actionMaterial_Selection&quot;)
+
+        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt+G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
+        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt+C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
+        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
+        self.menuFile.addAction(self.actionRunModule)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
+        
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionMaterial_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Module Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
+        if platform.system() == &quot;Windows&quot;:
+            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
+        else:
+            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.pivotRenderQueueListener = PivotRenderQueueListener()
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
+        
+        self.moduleName = &quot;&quot;
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+        self.gocManager = self.moduleManager.gocManager
+        
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+        
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+        if platform.system() == &quot;Linux&quot;:
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+            self.materialSelectionDialog.updateRenderWindow()
+
+    def actionOpenSlot(self):
+        self.finishEditorSetup()
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
+    def actionRunModuleSlot(self):
+        self.moduleManager.save()
+        if platform.system() == &quot;Windows&quot;:
+            workingDir = self.prefDialog.moduleCfgPath.replace(&quot;/modules/modules.cfg&quot;, &quot;&quot;)
+            executable = os.path.join(workingDir, &quot;Rastullah.exe&quot;)
+            executable = executable.replace(&quot;/&quot;,  &quot;\\&quot;)
+            if os.path.isfile(executable):
                 subprocess.Popen([executable, &quot;--module&quot;, self.moduleManager.mainModule.name], 0, None, None, None, None, None, False, False, workingDir)
-
-        
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def actionOneClickEntityPlacementSlot(self):
-        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-    
-    def toggleMaterialPreviewWindow(self):
-        if self.materialSelectionDock.isHidden():
-            self.materialSelectionDock.show()
-        else:
-            self.materialSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleModuleExplorer(self):
-        if self.moduleExplorerDock.isHidden():
-            self.moduleExplorerDock.show()
-        else:
-            self.moduleExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
-        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
-        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-        
-        self.materialSelectionDock = QtGui.QDockWidget(self.tr(&quot;Materials&quot;), self)
-        self.materialSelectionDock.setObjectName(&quot;MaterialSelectionDockWindow&quot;)
-        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
-        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.moduleExplorerDock = QtGui.QDockWidget(self.tr(&quot;Module Explorer&quot;), self)
-        self.moduleExplorerDock.setObjectName(&quot;ModuleExplorerDockWindow&quot;)
-        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
-        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
-        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionOpen)
-        self.fileToolBar.addAction(self.actionSave)
-        self.fileToolBar.addAction(self.actionRunModule)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
-        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyReleaseEvent(event)
-        pass
-
-    def onContextMenuCallback(self, actions):
-        menu = QMenu(&quot;My Menu!!&quot;)
-        menu.addAction(self.actionDelete)
-        menu.addAction(self.actionCopy)
-        menu.addAction(self.actionCut)
-        menu.addAction(self.actionPaste)
-        menu.addSeparator()
-        for a in actions:
-            menu.addAction(a)
-            
-        menu.exec_(QCursor.pos())
-        
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print&quot;&quot;
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == &quot;__main__&quot;:
-#    # Import Psyco if available
-#    try:
-##        import psyco
-##        psyco.full(0.02)
-#        #psyco.log()
-#        #psyco.profile()
-#    except ImportError:
-#        pass
-    
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName(&quot;Team Pantheon&quot;)
-    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
-    app.setApplicationName(&quot;Lockenwickler&quot;)
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+
+        
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def actionOneClickEntityPlacementSlot(self):
+        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+    
+    def toggleMaterialPreviewWindow(self):
+        if self.materialSelectionDock.isHidden():
+            self.materialSelectionDock.show()
+        else:
+            self.materialSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
+        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
+        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+        
+        self.materialSelectionDock = QtGui.QDockWidget(self.tr(&quot;Materials&quot;), self)
+        self.materialSelectionDock.setObjectName(&quot;MaterialSelectionDockWindow&quot;)
+        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
+
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
+        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr(&quot;Module Explorer&quot;), self)
+        self.moduleExplorerDock.setObjectName(&quot;ModuleExplorerDockWindow&quot;)
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
+        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
+        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionOpen)
+        self.fileToolBar.addAction(self.actionSave)
+        self.fileToolBar.addAction(self.actionRunModule)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
+        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyReleaseEvent(event)
+        pass
+
+    def onContextMenuCallback(self, actions):
+        menu = QMenu(&quot;My Menu!!&quot;)
+        menu.addAction(self.actionDelete)
+        menu.addAction(self.actionCopy)
+        menu.addAction(self.actionCut)
+        menu.addAction(self.actionPaste)
+        menu.addSeparator()
+        for a in actions:
+            menu.addAction(a)
+            
+        menu.exec_(QCursor.pos())
+        
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print&quot;&quot;
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
+if __name__ == &quot;__main__&quot;:
+#    # Import Psyco if available
+#    try:
+##        import psyco
+##        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName(&quot;Team Pantheon&quot;)
+    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
+    app.setApplicationName(&quot;Lockenwickler&quot;)
+
+    form = Lockenwickler()
+    form.show()
+
+    sys.exit(app.exec_())
+

Modified: rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -1,185 +1,186 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MaterialListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MaterialListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream &lt;&lt; self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData(&quot;application/x-material&quot;, data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class MaterialSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.materialSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
-                               self.updateMaterialList)
-
-        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
-                               self.setPreviewedMaterial)
-
-        self.materialList = []
-
-        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreMaterialPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName(&quot;materialPreviewDialog&quot;)
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.materialSearchBox = QLineEdit(self)
-        self.materialSearchBox.setObjectName(&quot;materialSearchBox&quot;)
-        self.gridlayout.addWidget(self.materialSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName(&quot;splitter&quot;)
-
-        self.listWidget = MaterialListWidget(self.splitter)
-        self.listWidget.setObjectName(&quot;listWidget&quot;)
-
-        self.ogreMaterialPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreMaterialPrevWindowSceneMgr&quot;)
-        self.ogreMaterialPrevWindow = OgreWidget.OgreWidget(&quot;MaterialPrevWin&quot;, self.ogreRoot, self.ogreMaterialPrevWindowSceneMgr, &quot;MaterialPrevCam&quot;,
-                                                         self.splitter)
-        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(1.0, 1.0, 1.0, 1.0))
-        self.ogreMaterialPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
-        
-        
-        self.ogreMaterialPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreMaterialPrevWindow.setObjectName(&quot;materialPreviewWindow&quot;)
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-    def ogreViewportCreatedCallback(self):
-        self.ogreMaterialPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
-        
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate(&quot;materialPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
-
-    def setPreviewedMaterial(self):
-        if self.ent == None:
-            self.ent = self.ogreMaterialPrevWindowSceneMgr.createEntity(&quot;MaterialPrevEntity9993944&quot;, &quot;UniCube.mesh&quot;)
-            self.nodeScale = og.Vector3(1,1,1)
-
-            self.node.attachObject(self.ent)
-            self.node.setScale(og.Vector3(6,6,6))
-        self.ent.setMaterialName(str(self.listWidget.currentItem().text()))
-
-    def scanDirForMaterials(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForMaterials(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(&quot;.material&quot;):
-                    f = open(curFile, &quot;r&quot;)
-                    for line in f:
-                        if line.startswith(&quot;material &quot;):
-                            l = line.replace(&quot;material &quot;, &quot;&quot;).lstrip().rstrip()
-                            l2 = l.split(&quot;:&quot;)
-                            self.materialList.append(l2[0])
-                            self.listWidget.addItem(l2[0])
-                        
-                    f.close()
-        self.listWidget.sortItems()
-
-    def updateMaterialList(self, text):
-        self.listWidget.clear()
-        for material in self.materialList:
-            if material.find(text) != -1:
-               self.listWidget.addItem(material)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() &lt; 0:
-                self.ogreMaterialPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreMaterialPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
-                self.ogreMaterialPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
-    def updateRenderWindow(self):
-        self.ogreMaterialPrevWindow.update()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MaterialListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MaterialListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream &lt;&lt; self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData(&quot;application/x-material&quot;, data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class MaterialSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.materialSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
+                               self.updateMaterialList)
+
+        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
+                               self.setPreviewedMaterial)
+
+        self.materialList = []
+
+        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreMaterialPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName(&quot;materialPreviewDialog&quot;)
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName(&quot;materialSelectionLayout&quot;)
+        self.gridlayout.setContentsMargins(2, 2, 2, 2)
+        
+        self.materialSearchBox = QLineEdit(self)
+        self.materialSearchBox.setObjectName(&quot;materialSearchBox&quot;)
+        self.gridlayout.addWidget(self.materialSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName(&quot;splitter&quot;)
+
+        self.listWidget = MaterialListWidget(self.splitter)
+        self.listWidget.setObjectName(&quot;listWidget&quot;)
+
+        self.ogreMaterialPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreMaterialPrevWindowSceneMgr&quot;)
+        self.ogreMaterialPrevWindow = OgreWidget.OgreWidget(&quot;MaterialPrevWin&quot;, self.ogreRoot, self.ogreMaterialPrevWindowSceneMgr, &quot;MaterialPrevCam&quot;,
+                                                         self.splitter)
+        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(1.0, 1.0, 1.0, 1.0))
+        self.ogreMaterialPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
+        
+        
+        self.ogreMaterialPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreMaterialPrevWindow.setObjectName(&quot;materialPreviewWindow&quot;)
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+    def ogreViewportCreatedCallback(self):
+        self.ogreMaterialPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate(&quot;materialPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
+
+    def setPreviewedMaterial(self):
+        if self.ent == None:
+            self.ent = self.ogreMaterialPrevWindowSceneMgr.createEntity(&quot;MaterialPrevEntity9993944&quot;, &quot;UniCube.mesh&quot;)
+            self.nodeScale = og.Vector3(1,1,1)
+
+            self.node.attachObject(self.ent)
+            self.node.setScale(og.Vector3(6,6,6))
+        self.ent.setMaterialName(str(self.listWidget.currentItem().text()))
+
+    def scanDirForMaterials(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForMaterials(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(&quot;.material&quot;):
+                    f = open(curFile, &quot;r&quot;)
+                    for line in f:
+                        if line.startswith(&quot;material &quot;):
+                            l = line.replace(&quot;material &quot;, &quot;&quot;).lstrip().rstrip()
+                            l2 = l.split(&quot;:&quot;)
+                            self.materialList.append(l2[0])
+                            self.listWidget.addItem(l2[0])
+                        
+                    f.close()
+        self.listWidget.sortItems()
+
+    def updateMaterialList(self, text):
+        self.listWidget.clear()
+        for material in self.materialList:
+            if material.find(text) != -1:
+               self.listWidget.addItem(material)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() &lt; 0:
+                self.ogreMaterialPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreMaterialPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
+                self.ogreMaterialPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+
+    def updateRenderWindow(self):
+        self.ogreMaterialPrevWindow.update()

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -77,6 +77,7 @@
 
         self.gridlayout = QGridLayout(self)
         self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+        self.gridlayout.setContentsMargins(2, 2, 2, 2)
 
         self.modelSearchBox = QLineEdit(self)
         self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -31,6 +31,7 @@
         layout = QVBoxLayout()
         layout.addWidget(self.nameInput)
         layout.addWidget(buttonBox)
+        layout.setContentsMargins(2, 2, 2, 2)
         self.setLayout(layout)
         
         self.connect(buttonBox, SIGNAL(&quot;accepted()&quot;), self, SLOT(&quot;accept()&quot;))        
@@ -69,7 +70,8 @@
         
         vBoxLayout = QVBoxLayout()
         vBoxLayout.addWidget(self.sceneTreeView)
-
+        vBoxLayout.setContentsMargins(0, 0, 0, 0)
+        
         self.setLayout(vBoxLayout)
         
         self.nodeDict = {}

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -165,11 +165,9 @@
             
             eco = EntityCustomOptions()
             
+            if nodes.attrib[&quot;receivesShadow&quot;] == &quot;False&quot; or nodes.attrib[&quot;receivesShadow&quot;] == &quot;false&quot;:
+                eco.receivesShadow = &quot;False&quot;
             try:
-                eco.receivesShadow = bool(nodes.attrib[&quot;receivesShadow&quot;])
-            except:
-                pass
-            try:
                 eco.staticgeometrygroup = int(nodes.attrib[&quot;staticgeometrygroup&quot;])
             except:
                 pass
@@ -349,6 +347,7 @@
                 go = GameObjectRepresentation(id, classid, dropNode, meshFile)
                 self.gocManager.addGameObjectRepresentation(go)
                 go.inWorldId = id
+                go.state = state
                 ent.setUserObject(go)
 
 

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -1,277 +1,400 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from Property import *
-
-class ObjectPropertyWin(QDialog):
-    def __init__(self, sceneManager, gocManager, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setupUi()
-        self.sceneManager = sceneManager
-        self.valueBeforeEdit = None
-        self.gocManager = gocManager
-        
-        self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
-                               self.onItemClicked)
-        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
-                               self.onItemChanged)
-
-    def setupUi(self):
-        self.setObjectName(&quot;ObjectPropertys&quot;)
-        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
-
-        self.treeWidget = QTreeWidget(self)
-        self.treeWidget.setGeometry(QRect(0,0,901,721))
-        self.treeWidget.setMinimumSize(QSize(400,400))
-        self.treeWidget.setObjectName(&quot;treeWidget&quot;)
-        self.treeWidget.setAlternatingRowColors(True)
-        self.treeWidget.setAnimated(True)
-        
-        self.retranslateUi()
-        QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.treeWidget.headerItem().setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Property&quot;, None, QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(1,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Value&quot;, None, QApplication.UnicodeUTF8))
-        self.treeWidget.clear()
-
-
-    def onItemClicked(self, item, column):
-        if column == 1:
-            self.valueBeforeEdit = item.text(column)
-            
-            if item.text(0) == &quot;State&quot;:
-                rect = self.treeWidget.visualItemRect(item)
-                
-                combo = QComboBox(self.treeWidget)
-                combo.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
-                combo.addItem(&quot;IN_SCENE&quot;)
-                combo.addItem(&quot;BLUBB&quot;)
-                combo.show()
-            else:
-                self.treeWidget.editItem(item, column)
-
-    def onItemChanged(self, item, column):
-        if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
-            parent = item.parent()
-            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
-                if item.text(0) == &quot;Name&quot;:
-                    if not self.sceneManager.hasEntity(str(item.text(column))):
-                        newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
-                        oldEnt = self.node.getAttachedObject(0)
-                        self.node.detachObject(oldEnt)
-                        self.sceneManager.destroyEntity(oldEnt)
-                        self.node.attachObject(newEnt)
-                        
-                        # update the selection object since it still has references to the deleted entity
-                        self.so.entity = newEnt
-                        self.so.entityName = newEnt.getName()
-                    else:
-                        item.setText(column, self.valueBeforeEdit)
-                        print &quot;Error: Name already exists!&quot;
-                elif item.text(0) == &quot;GameObject Id&quot;:
-                    if not self.gocManager.inWorldIdExists(str(item.text(column))):
-                        val = None
-                        try:
-                            val = int(item.text(1))
-                        except ValueError, e:
-                            item.setText(column, self.valueBeforeEdit)
-                            print &quot;ValueError: &quot; + str(e)
-                            return
-                            
-                        self.node.getAttachedObject(0).getUserObject().inWorldId = str(val)
-                    else:
-                        item.setText(column, self.valueBeforeEdit)
-                        print &quot;Error: Id exists already!&quot;
-                elif item.text(0) == &quot;State&quot;:
-                    rect = self.treeWidget.visualItemRect()
-                    combo = QComboBox(self.treeWidget)
-                    combo.setGeometry(rect)
-                    
-            else:
-                val = None
-                try:
-                    val = float(item.text(1))
-                except ValueError, e:
-                    item.setText(column, self.valueBeforeEdit)
-                    print &quot;ValueError: &quot; + str(e)
-                    return
-                    
-                if parent.text(0) == &quot;Position&quot;:
-                    if item.text(0) == &quot;X&quot;:
-                        self.node.setPosition(val, self.node.getPosition().y, self.node.getPosition().z)
-                    elif item.text(0) == &quot;Y&quot;:
-                        self.node.setPosition(self.node.getPosition().x, val, self.node.getPosition().z)
-                    elif item.text(0) == &quot;Z&quot;:
-                        self.node.setPosition(self.node.getPosition().x, self.node.getPosition().y, val)
-                elif parent.text(0) == &quot;Orientation&quot;:
-                    if item.text(0) == &quot;W&quot;:
-                        self.node.setOrientation(val, self.node.getOrientation().x, self.node.getOrientation().y, self.node.getOrientation().z)
-                    elif item.text(0) == &quot;X&quot;:
-                        self.node.setOrientation(self.node.getOrientation().w, val, self.node.getOrientation().y, self.node.getOrientation().z)
-                    elif item.text(0) == &quot;Y&quot;:
-                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, val, self.node.getOrientation().z)
-                    elif item.text(0) == &quot;Z&quot;:
-                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, self.node.getOrientation().y, val)
-                elif parent.text(0) == &quot;Scale&quot;:
-                    if item.text(0) == &quot;X&quot;:
-                        self.node.setScale(val, self.node.getScale().y, self.node.getScale().z)
-                    elif item.text(0) == &quot;Y&quot;:
-                        self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
-                    elif item.text(0) == &quot;Z&quot;:
-                        self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
-                        
-    def showProperties(self, so):
-        # onItemChanged should only be called when the user changes values not when they change by code
-        self.disconnect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
-                       self.onItemChanged)
-                       
-        self.so=so
-        self.treeWidget.clear()
-        
-        name = so.entity.getParentNode().getName()
-        self.node = so.entity.getParentNode()
-        
-        if name.startswith(&quot;entity_&quot;):
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Name&quot;)
-            n = self.node.getAttachedObject(0).getName()
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            itemMat = QTreeWidgetItem(self.treeWidget)
-            itemMat.setText(0, &quot;Materials&quot;)
-            
-            i = 0
-            while i &lt; self.node.getAttachedObject(0).getNumSubEntities():
-                it = QTreeWidgetItem(itemMat)
-                it.setFlags(item.flags() | Qt.ItemIsEditable)
-                it.setText(0, &quot;SubMesh&quot; + str(i))
-                it.setText(1, self.node.getAttachedObject(0).getSubEntity(i).getMaterialName())
-                i += 1
-                
-            
-            #item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            self.parsePosition(self.node)
-            self.parseOrientation(self.node)
-            self.parseScale(self.node)
-            
-        elif name.startswith(&quot;gameobject_&quot;):
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;ClassName&quot;)
-            n = str(self.node.getAttachedObject(0).getUserObject().gocName)
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;GameObject Id&quot;)
-            n = str(self.node.getAttachedObject(0).getUserObject().inWorldId)
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;State&quot;)
-            n = str(self.node.getAttachedObject(0).getUserObject().state)
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            
-            self.parsePosition(self.node)
-            self.parseOrientation(self.node)
-            self.parseScale(self.node)
-            
-        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
-                       self.onItemChanged)
-                       
-                       
-    def parsePosition(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Position&quot;)
-        item.setText(1, str(node.getPosition().x) + &quot;; &quot; + str(node.getPosition().y) + &quot;; &quot; + str(node.getPosition().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getPosition().x))
-        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getPosition().y))
-        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getPosition().z))
-        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
-        
-    def parseOrientation(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Orientation&quot;)
-        item.setText(1, str(node.getOrientation().w) + &quot;; &quot; + str(node.getOrientation().x) + &quot;; &quot; + str(node.getOrientation().y) + &quot;; &quot; + str(node.getOrientation().z))
-        
-        itemW = QTreeWidgetItem(item)
-        itemW.setText(0, &quot;W&quot;)
-        itemW.setText(1, str(node.getOrientation().w))
-        itemW.setFlags(itemW.flags() | Qt.ItemIsEditable)
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getOrientation().x))
-        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getOrientation().y))
-        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getOrientation().z))
-        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
-        
-    def parseScale(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Scale&quot;)
-        item.setText(1, str(node.getScale().x) + &quot;; &quot; + str(node.getScale().y) + &quot;; &quot; + str(node.getScale().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getScale().x))
-        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getScale().y))
-        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getScale().z))
-        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
-        
-    def updateProperties(self):
-        if self.so is not None:
-            self.showProperties(self.so)
-            
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from Property import *
+
+class BoolEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        currentSelected = False
+        if currentSelectedText == &quot;True&quot; or currentSelectedText == &quot;true&quot;:
+            currentSelected = True
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;True&quot;)
+        self.combo.addItem(&quot;False&quot;)
+        
+        if not currentSelected:
+            self.combo.setCurrentIndex(1)
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+    
+class GameObjectStateEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;IN_SCENE&quot;)
+        self.combo.addItem(&quot;LOADED&quot;)
+        self.combo.addItem(&quot;HELD&quot;)
+        self.combo.addItem(&quot;IN_POSSESSION&quot;)
+        self.combo.addItem(&quot;READIED&quot;)
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+        
+class EntityPhysicsProxyEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;none&quot;)
+        self.combo.addItem(&quot;box&quot;)
+        self.combo.addItem(&quot;sphere&quot;)
+        self.combo.addItem(&quot;ellipsoid&quot;)
+        self.combo.addItem(&quot;pyramid&quot;)
+        self.combo.addItem(&quot;mesh&quot;)
+        self.combo.addItem(&quot;convexhull&quot;)
+        self.combo.addItem(&quot;custom - Not supported by editor yet!&quot;)
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+    
+class ObjectPropertyWin(QDialog):
+    def __init__(self, sceneManager, gocManager, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setupUi()
+        self.sceneManager = sceneManager
+        self.valueBeforeEdit = None
+        self.gocManager = gocManager
+        
+        self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
+                               self.onItemClicked)
+        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                               self.onItemChanged)
+
+    def setupUi(self):
+        self.setObjectName(&quot;ObjectPropertys&quot;)
+        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
+
+        self.treeWidget = QTreeWidget(self)
+        self.treeWidget.setGeometry(QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QSize(400,400))
+        self.treeWidget.setObjectName(&quot;treeWidget&quot;)
+        self.treeWidget.setAlternatingRowColors(True)
+        self.treeWidget.setAnimated(True)
+        
+        self.retranslateUi()
+        QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.treeWidget.headerItem().setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Property&quot;, None, QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Value&quot;, None, QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+
+    def onItemClicked(self, item, column):
+        if column == 1:
+            self.valueBeforeEdit = str(item.text(column))
+            
+            if item.text(0) == &quot;State&quot;:
+                ed = GameObjectStateEditor(item.text(column), self)
+                ed.exec_()
+                item.setText(column, ed.getValue())
+                self.node.getAttachedObject(0).getUserObject().state = ed.getValue()
+                
+            elif item.text(0) == &quot;Receives Shadows&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().receivesShadow = bedit.getValue()
+            elif item.text(0) == &quot;Physics Proxy Type&quot;:
+                bedit = EntityPhysicsProxyEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().physicsproxytype = bedit.getValue()
+                
+            else:
+                self.treeWidget.editItem(item, column)
+
+    def onItemChanged(self, item, column):
+        if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
+            parent = item.parent()
+            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
+                if item.text(0) == &quot;Name&quot;:
+                    if not self.sceneManager.hasEntity(str(item.text(column))):
+                        newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
+                        oldEnt = self.node.getAttachedObject(0)
+                        self.node.detachObject(oldEnt)
+                        self.sceneManager.destroyEntity(oldEnt)
+                        self.node.attachObject(newEnt)
+                        
+                        # update the selection object since it still has references to the deleted entity
+                        self.so.entity = newEnt
+                        self.so.entityName = newEnt.getName()
+                    else:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;Error: Name already exists!&quot;
+                elif item.text(0) == &quot;GameObject Id&quot;:
+                    if not self.gocManager.inWorldIdExists(str(item.text(column))):
+                        val = None
+                        try:
+                            val = int(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;ValueError: &quot; + str(e)
+                            return
+                            
+                        self.node.getAttachedObject(0).getUserObject().inWorldId = str(val)
+                    else:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;Error: Id exists already!&quot;
+                elif item.text(0) == &quot;Static Geometry Group&quot;:                        
+                    val = None
+                    try:
+                        val = int(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;ValueError: &quot; + str(e)
+                        return
+                elif item.text(0) == &quot;Rendering Distance&quot;:                        
+                    val = None
+                    try:
+                        val = float(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;ValueError: &quot; + str(e)
+                        return
+                        
+                    self.node.getAttachedObject(0).getUserObject().renderingdistance = val
+            else:
+                val = None
+                try:
+                    val = float(item.text(1))
+                except ValueError, e:
+                    item.setText(column, self.valueBeforeEdit)
+                    print &quot;ValueError: &quot; + str(e)
+                    return
+                    
+                if parent.text(0) == &quot;Position&quot;:
+                    if item.text(0) == &quot;X&quot;:
+                        self.node.setPosition(val, self.node.getPosition().y, self.node.getPosition().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setPosition(self.node.getPosition().x, val, self.node.getPosition().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setPosition(self.node.getPosition().x, self.node.getPosition().y, val)
+                elif parent.text(0) == &quot;Orientation&quot;:
+                    if item.text(0) == &quot;W&quot;:
+                        self.node.setOrientation(val, self.node.getOrientation().x, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;X&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, val, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, val, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, self.node.getOrientation().y, val)
+                elif parent.text(0) == &quot;Scale&quot;:
+                    if item.text(0) == &quot;X&quot;:
+                        self.node.setScale(val, self.node.getScale().y, self.node.getScale().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
+
+                    
+    def showProperties(self, so):
+        # onItemChanged should only be called when the user changes values not when they change by code
+        self.disconnect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                       self.onItemChanged)
+                       
+        self.so=so
+        self.treeWidget.clear()
+        
+        name = so.entity.getParentNode().getName()
+        self.node = so.entity.getParentNode()
+        
+        if name.startswith(&quot;entity_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Name&quot;)
+            n = self.node.getAttachedObject(0).getName()
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            itemMat = QTreeWidgetItem(self.treeWidget)
+            itemMat.setText(0, &quot;Materials&quot;)
+            
+            i = 0
+            while i &lt; self.node.getAttachedObject(0).getNumSubEntities():
+                it = QTreeWidgetItem(itemMat)
+                it.setFlags(item.flags() | Qt.ItemIsEditable)
+                it.setText(0, &quot;SubMesh&quot; + str(i))
+                it.setText(1, self.node.getAttachedObject(0).getSubEntity(i).getMaterialName())
+                i += 1
+                
+                        
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
+            self.parseEntityOptions(self.node)
+            
+        elif name.startswith(&quot;gameobject_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;ClassName&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().gocName)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;GameObject Id&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().inWorldId)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;State&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().state)
+            item.setText(1, n)            
+            
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
+            
+        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                       self.onItemChanged)
+                       
+                       
+    def parsePosition(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Position&quot;)
+        item.setText(1, str(node.getPosition().x) + &quot;; &quot; + str(node.getPosition().y) + &quot;; &quot; + str(node.getPosition().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getPosition().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getPosition().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getPosition().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseOrientation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Orientation&quot;)
+        item.setText(1, str(node.getOrientation().w) + &quot;; &quot; + str(node.getOrientation().x) + &quot;; &quot; + str(node.getOrientation().y) + &quot;; &quot; + str(node.getOrientation().z))
+        
+        itemW = QTreeWidgetItem(item)
+        itemW.setText(0, &quot;W&quot;)
+        itemW.setText(1, str(node.getOrientation().w))
+        itemW.setFlags(itemW.flags() | Qt.ItemIsEditable)
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getOrientation().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getOrientation().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getOrientation().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseScale(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Scale&quot;)
+        item.setText(1, str(node.getScale().x) + &quot;; &quot; + str(node.getScale().y) + &quot;; &quot; + str(node.getScale().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getScale().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getScale().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getScale().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseEntityOptions(self, node):
+        uo = node.getAttachedObject(0).getUserObject()
+
+        if uo is not None:
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Receives Shadows&quot;)
+            item.setText(1, str(uo.receivesShadow))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Static Geometry Group&quot;)
+            item.setText(1, str(uo.staticgeometrygroup))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Physics Proxy Type&quot;)
+            item.setText(1, str(uo.physicsproxytype))  
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Rendering Distance&quot;)
+            item.setText(1, str(uo.renderingdistance))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+    def updateProperties(self):
+        if self.so is not None:
+            self.showProperties(self.so)
+            

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -1,339 +1,340 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-        
-        self.setupUi(self)
-
-    def setupUi(self, Form):
-        Form.setObjectName(&quot;Form&quot;)
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName(&quot;splitter&quot;)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-        
-        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
-        
-    def ogreViewportCreatedCallback(self):
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-        
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-                QTimer.singleShot(50, self.onContextMenuTimer)
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-                
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-#        if event.type() == 62:
-#            self.finishDropEvent(event)
-        if event.type() == 63:
-            self.finishDropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            data = event.mimeData().data(&quot;application/x-static_model&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropModelAction(str(text), self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            data = event.mimeData().data(&quot;application/x-game_object&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropGameObjectAction(str(text), self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
-            data = event.mimeData().data(&quot;application/x-material&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropMaterialAction(str(text)) #start the material draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
-            self.moduleManager.moveDropMaterialAction(event) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def finishDropEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.finishDropModelAction(self.getCameraToViewportRay())
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.finishDropGameObjectAction(self.getCameraToViewportRay()) 
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
-            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-            self.moduleManager.finishDropMaterialAction(relMousePos.x(), relMousePos.y()) 
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        if self.moduleManager.pivot:
-            self.moduleManager.pivot.update()
-            
-    def updateRenderWindow(self):
-        self.ogreWidget.update()
-        
-    def onContextMenuTimer(self):
-        if not self.rightMouseDown:
-            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos()) # get the mose position relative to the ogre window
-            self.moduleManager.onContextMenu(relMousePos.x(), relMousePos.y())
-        
-        
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName(&quot;Form&quot;)
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setContentsMargins(0, 2, 0, 0)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName(&quot;splitter&quot;)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+                QTimer.singleShot(50, self.onContextMenuTimer)
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+                
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+#        if event.type() == 62:
+#            self.finishDropEvent(event)
+        if event.type() == 63:
+            self.finishDropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            data = event.mimeData().data(&quot;application/x-static_model&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropModelAction(str(text), self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            data = event.mimeData().data(&quot;application/x-game_object&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropGameObjectAction(str(text), self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            data = event.mimeData().data(&quot;application/x-material&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropMaterialAction(str(text)) #start the material draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            self.moduleManager.moveDropMaterialAction(event) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def finishDropEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.finishDropModelAction(self.getCameraToViewportRay())
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.finishDropGameObjectAction(self.getCameraToViewportRay()) 
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+            self.moduleManager.finishDropMaterialAction(relMousePos.x(), relMousePos.y()) 
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()
+            
+    def updateRenderWindow(self):
+        self.ogreWidget.update()
+        
+    def onContextMenuTimer(self):
+        if not self.rightMouseDown:
+            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos()) # get the mose position relative to the ogre window
+            self.moduleManager.onContextMenu(relMousePos.x(), relMousePos.y())
+        
+        

Modified: rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-03-10 23:27:05 UTC (rev 4827)
+++ rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-03-14 10:32:22 UTC (rev 4828)
@@ -16,7 +16,8 @@
 
         self.gridlayout = QtGui.QGridLayout(ConsoleWindow)
         self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
         self.textEdit = QtGui.QTextEdit(ConsoleWindow)
         self.textEdit.setObjectName(&quot;textEdit&quot;)
         self.gridlayout.addWidget(self.textEdit,0,0,1,1)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001884.html">[Dsa-hl-svn] r4827 - dependencies/OgreNewt
</A></li>
	<LI>Next message: <A HREF="001886.html">[Dsa-hl-svn] r4829 - rl/trunk/editors/Lockenwickler/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1885">[ date ]</a>
              <a href="thread.html#1885">[ thread ]</a>
              <a href="subject.html#1885">[ subject ]</a>
              <a href="author.html#1885">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
