<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4787 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai/include	engine/ai/src engine/core/src engine/script	engine/script/swig engine/ui engine/ui/include engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4787%20-%20in%20rl/branches/persistence2%3A%0A%09editors/Lockenwickler%20editors/Lockenwickler/_eric4project%0A%09editors/Lockenwickler/src%20editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/media/icons%20engine/ai/include%0A%09engine/ai/src%20engine/core/src%20engine/script%0A%09engine/script/swig%20engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200903031946.n23Jk7Nq031051%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001843.html">
   <LINK REL="Next"  HREF="001845.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4787 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai/include	engine/ai/src engine/core/src engine/script	engine/script/swig engine/ui engine/ui/include engine/ui/src</H1>
    <B>timm at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4787%20-%20in%20rl/branches/persistence2%3A%0A%09editors/Lockenwickler%20editors/Lockenwickler/_eric4project%0A%09editors/Lockenwickler/src%20editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/media/icons%20engine/ai/include%0A%09engine/ai/src%20engine/core/src%20engine/script%0A%09engine/script/swig%20engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200903031946.n23Jk7Nq031051%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4787 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai/include	engine/ai/src engine/core/src engine/script	engine/script/swig engine/ui engine/ui/include engine/ui/src">timm at mail.berlios.de
       </A><BR>
    <I>Tue Mar  3 20:46:07 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001843.html">[Dsa-hl-svn] r4786 - in dependencies/OgreNewt: . inc
</A></li>
        <LI>Next message: <A HREF="001845.html">[Dsa-hl-svn] r4788 - dependencies/OgreNewt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1844">[ date ]</a>
              <a href="thread.html#1844">[ thread ]</a>
              <a href="subject.html#1844">[ subject ]</a>
              <a href="author.html#1844">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: timm
Date: 2009-03-03 20:45:40 +0100 (Tue, 03 Mar 2009)
New Revision: 4787

Added:
   rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/PivotRenderQueueListener.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorFP.glsl
   rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/colors.png
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/fileopen.png
   rl/branches/persistence2/engine/ui/include/DialogController.h
   rl/branches/persistence2/engine/ui/src/DialogController.cpp
Modified:
   rl/branches/persistence2/editors/Lockenwickler/
   rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
   rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
   rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
   rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py
   rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColor.cg
   rl/branches/persistence2/editors/Lockenwickler/src/media/UniCube.mesh
   rl/branches/persistence2/editors/Lockenwickler/src/media/pivots.blend
   rl/branches/persistence2/engine/ai/include/Dialog.h
   rl/branches/persistence2/engine/ai/include/DialogElement.h
   rl/branches/persistence2/engine/ai/include/DialogLoader.h
   rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h
   rl/branches/persistence2/engine/ai/include/DialogManager.h
   rl/branches/persistence2/engine/ai/include/DialogOption.h
   rl/branches/persistence2/engine/ai/include/DialogParagraph.h
   rl/branches/persistence2/engine/ai/include/DialogResponse.h
   rl/branches/persistence2/engine/ai/src/Dialog.cpp
   rl/branches/persistence2/engine/ai/src/DialogElement.cpp
   rl/branches/persistence2/engine/ai/src/DialogImplication.cpp
   rl/branches/persistence2/engine/ai/src/DialogLoader.cpp
   rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp
   rl/branches/persistence2/engine/ai/src/DialogManager.cpp
   rl/branches/persistence2/engine/ai/src/DialogOption.cpp
   rl/branches/persistence2/engine/ai/src/DialogParagraph.cpp
   rl/branches/persistence2/engine/ai/src/DialogResponse.cpp
   rl/branches/persistence2/engine/ai/src/DialogVariable.cpp
   rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp
   rl/branches/persistence2/engine/core/src/GameLoop.cpp
   rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp
   rl/branches/persistence2/engine/script/CMakeLists.txt
   rl/branches/persistence2/engine/script/swig/RlAi.swig
   rl/branches/persistence2/engine/ui/CMakeLists.txt
   rl/branches/persistence2/engine/ui/include/CutsceneControlState.h
   rl/branches/persistence2/engine/ui/include/DialogControlState.h
   rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp
   rl/branches/persistence2/engine/ui/src/DialogControlState.cpp
Log:
merged from trunk



Property changes on: rl/branches/persistence2/editors/Lockenwickler
___________________________________________________________________
Name: svn:ignore
   + .ropeproject


Modified: rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
 &lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-02-10, 21:36:41 --&gt;
+&lt;!-- Saved: 2009-03-01, 22:49:19 --&gt;
 &lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;Project version=&quot;4.6&quot;&gt;
   &lt;Language&gt;en&lt;/Language&gt;
@@ -38,6 +38,7 @@
     &lt;Source&gt;src/Ui_NewModuleWizard.py&lt;/Source&gt;
     &lt;Source&gt;src/ModuleExplorer.py&lt;/Source&gt;
     &lt;Source&gt;src/SelectionBuffer.py&lt;/Source&gt;
+    &lt;Source&gt;src/MaterialSelectionDialog.py&lt;/Source&gt;
   &lt;/Sources&gt;
   &lt;Forms&gt;
     &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE UserProject SYSTEM &quot;UserProject-4.0.dtd&quot;&gt;
 &lt;!-- eric4 user project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-02-10, 21:36:41 --&gt;
+&lt;!-- Saved: 2009-03-01, 22:49:19 --&gt;
 &lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;UserProject version=&quot;4.0&quot;&gt;
 &lt;/UserProject&gt;
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Tasks SYSTEM &quot;Tasks-4.2.dtd&quot;&gt;
 &lt;!-- eric4 tasks file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-02-10, 21:36:41 --&gt;
+&lt;!-- Saved: 2009-03-01, 22:49:19 --&gt;
 &lt;Tasks version=&quot;4.2&quot;&gt;
   &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
     &lt;Summary&gt;TODO: not implemented yet&lt;/Summary&gt;
@@ -24,10 +24,10 @@
   &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
     &lt;Summary&gt;TODO: implement save here&lt;/Summary&gt;
     &lt;Description&gt;&lt;/Description&gt;
-    &lt;Created&gt;2009-02-10, 12:40:21&lt;/Created&gt;
+    &lt;Created&gt;2009-03-01, 21:50:14&lt;/Created&gt;
     &lt;Resource&gt;
       &lt;Filename&gt;src/Lockenwickler.py&lt;/Filename&gt;
-      &lt;Linenumber&gt;426&lt;/Linenumber&gt;
+      &lt;Linenumber&gt;458&lt;/Linenumber&gt;
     &lt;/Resource&gt;
   &lt;/Task&gt;
 &lt;/Tasks&gt;
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -28,7 +28,8 @@
     def __init__(self, parent = None):
         super(GoTreeWidget, self).__init__(parent)
         self.setDragEnabled(True)
-
+        self.setAnimated(True)
+        
     def startDrag(self,  dropActions):
         data = QByteArray()
         stream = QDataStream(data,  QIODevice.WriteOnly)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -31,11 +31,13 @@
 from PreferencesDialog import *
 from ObjectPropertyWin import *
 from ModelSelectionDialog import *
+from MaterialSelectionDialog import *
 from GameObjectClassView import *
 from ConsoleWindow import *
 from ModuleManager import *
 from ModuleExplorer import *
 from NewModuleWizard import *
+from PivotRenderQueueListener import *
 
 import OgreMainWindow
 import ogre.renderer.OGRE as og
@@ -57,10 +59,12 @@
         self.setupOgre()
 
         self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self)
         self.moduleExplorerWin = ModuleExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
         self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
 
         self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
 
@@ -75,14 +79,18 @@
         self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
         if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
             self.prefDialog.show()
-
-        self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
         self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
         self.moduleManager.setPropertyWindow(self.objectPropertyWin)
         
         self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
         self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
-
+        
+        self.editorSetupFinished = False
+        
 #        splash.finish(self)
 
     def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
@@ -142,10 +150,10 @@
         self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
         self.actionNeu.setObjectName(&quot;actionNeu&quot;)
 
-        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;filenew.png&quot;,  &quot;Open Module&quot;)
+        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;fileopen.png&quot;,  &quot;Open Module&quot;)
         self.actionOpen.setObjectName(&quot;actionOpen&quot;)
         
-        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filenew.png&quot;,  &quot;Save Module&quot;)
+        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filesave.png&quot;,  &quot;Save Module&quot;)
         self.actionSave.setObjectName(&quot;actionSave&quot;)
 
         self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
@@ -176,8 +184,11 @@
         self.actionRotate.setObjectName(&quot;actionRotate&quot;)
 
         self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+        self.actionScale.setObjectName(&quot;actionScale&quot;)
 
+        self.actionOneClickEntityPlacement = self.createAction(&quot;&amp;OneClickEntityPlacement&quot;,  self.actionOneClickEntityPlacementSlot,  &quot;&quot;,  &quot;resizecol.png&quot;,  &quot;Add an Entity just by a click&quot;)
+        self.actionOneClickEntityPlacement.setObjectName(&quot;actionOneClickEntityPlacement&quot;)
+        self.actionOneClickEntityPlacement.setCheckable(True)
 
 #####################################
 #####################################
@@ -192,6 +203,9 @@
 
         self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
         self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+        
+        self.actionMaterial_Selection = self.createAction(&quot;Material &amp;Preview Window&quot;,  self.toggleMaterialPreviewWindow,  &quot;Alt + M&quot;,  &quot;colors.png&quot;,  &quot;Material Preview&quot;)
+        self.actionMaterial_Selection.setObjectName(&quot;actionMaterial_Selection&quot;)
 
         self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
         self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
@@ -217,11 +231,15 @@
         self.menuEdit.addAction(self.actionCopy)
         self.menuEdit.addAction(self.actionCut)
         self.menuEdit.addAction(self.actionPaste)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
+        
 
         self.menuView.addAction(self.actionSceneExplorer)
         self.menuView.addAction(self.actionPreferences)
         self.menuView.addAction(self.actionProperty_Window)
         self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionMaterial_Selection)
         self.menuView.addAction(self.actionGameObjectClass_Selection)
         self.menuView.addAction(self.actionConsole_Window)
         self.menubar.addAction(self.menuFile.menuAction())
@@ -260,8 +278,10 @@
 
         root.initialise(False)
 
+        self.pivotRenderQueueListener = PivotRenderQueueListener()
         self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
         self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
 
         self.moduleName = &quot;&quot;
         self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
@@ -271,19 +291,27 @@
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
         
-        og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-        self.moduleManager.pivot.hide()
-
         oglog = og.LogManager.getSingleton().getDefaultLog()
         oglog.addListener(self.consoleWindow.lockenLog)
 
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
     def update(self):
         self.ogreRoot.renderOneFrame()
+        if platform.system() == &quot;Linux&quot;:
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+            self.materialSelectionDialog.updateRenderWindow()
 
     def actionOpenSlot(self):
+        self.finishEditorSetup()
         self.moduleManager.openLoadModuleDialog()
 
     def actionNewSlot(self):
@@ -321,6 +349,9 @@
     def actionScaleSlot(self):
         self.moduleManager.pivot.setScaleMode()
 
+    def actionOneClickEntityPlacementSlot(self):
+        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
+
     def togglePreferencesWindow(self):
         if self.prefDialog.isHidden():
             self.prefDialog.show()
@@ -332,6 +363,12 @@
             self.modelSelectionDock.show()
         else:
             self.modelSelectionDock.hide()
+    
+    def toggleMaterialPreviewWindow(self):
+        if self.materialSelectionDock.isHidden():
+            self.materialSelectionDock.show()
+        else:
+            self.materialSelectionDock.hide()
 
     def toggleGameObjectViewWindow(self):
         if self.gameObjectClassViewDock.isHidden():
@@ -369,6 +406,12 @@
         self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
         self.modelSelectionDock.setWidget(self.modelSelectionDialog)
         self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+        
+        self.materialSelectionDock = QtGui.QDockWidget(self.tr(&quot;Materials&quot;), self)
+        self.materialSelectionDock.setObjectName(&quot;MaterialSelectionDockWindow&quot;)
+        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
 
         self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
         self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
@@ -392,6 +435,7 @@
         self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
         self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
         self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionOpen)
         self.fileToolBar.addAction(self.actionSave)
         self.fileToolBar.addAction(self.actionClose)
         self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py (from rev 4784, rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,176 +1,181 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MyListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MyListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream &lt;&lt; self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData(&quot;application/x-static_model&quot;, data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class ModelSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.modelSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
-                               self.updateModelList)
-
-        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
-                               self.setPreviewedModel)
-
-        self.modelList = []
-
-        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName(&quot;modelPreviewDialog&quot;)
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.modelSearchBox = QLineEdit(self)
-        self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName(&quot;splitter&quot;)
-
-        self.listWidget = MyListWidget(self.splitter)
-        self.listWidget.setObjectName(&quot;listWidget&quot;)
-
-        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
-        self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
-                                                         self.splitter)
-        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
-        
-        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
-
-    def setPreviewedModel(self):
-        if self.ent != None:
-            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
-
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
-                                                                 str(self.listWidget.currentItem().text()))
-        self.node.attachObject(self.ent)
-        self.node.setScale(og.Vector3(1,1,1))
-        bb = self.ent.getBoundingBox()
-
-    def scanDirForModels(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForModels(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(&quot;.mesh&quot;):
-                    self.modelList.append(file)
-                    self.listWidget.addItem(file)
-
-        self.listWidget.sortItems()
-
-    def updateModelList(self, text):
-        self.listWidget.clear()
-        for model in self.modelList:
-            if model.find(text) != -1:
-               self.listWidget.addItem(model)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() &lt; 0:
-                self.ogreModelPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreModelPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
-                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class ModelListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(ModelListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream &lt;&lt; self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData(&quot;application/x-static_model&quot;, data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.modelSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
+                               self.updateModelList)
+
+        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName(&quot;modelPreviewDialog&quot;)
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        self.modelSearchBox = QLineEdit(self)
+        self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName(&quot;splitter&quot;)
+
+        self.listWidget = ModelListWidget(self.splitter)
+        self.listWidget.setObjectName(&quot;listWidget&quot;)
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
+                                                         self.splitter)
+        self.ogreModelPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
+        
+        
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+    def ogreViewportCreatedCallback(self):
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(&quot;.mesh&quot;):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() &lt; 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+
+    def updateRenderWindow(self):
+        self.ogreModelPrevWindow.update()

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,158 +1,181 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#dienstag 24.03 15.50
-import sys
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-import ogre.renderer.OGRE as og
-
-class NameInputDlg(QDialog):
-    def __init__(self, parent = None):
-        super(NameInputDlg, self).__init__(parent)
-        
-        self.nameInput = QLineEdit(self)
-        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        layout = QVBoxLayout()
-        layout.addWidget(self.nameInput)
-        layout.addWidget(buttonBox)
-        self.setLayout(layout)
-        
-        self.connect(buttonBox, SIGNAL(&quot;accepted()&quot;), self, SLOT(&quot;accept()&quot;))        
-        self.connect(buttonBox, SIGNAL(&quot;rejected()&quot;), self, SLOT(&quot;reject()&quot;))
-        
-        
-class ModuleTreeWidget(QTreeWidget):
-    def __init__(self, parent = None):
-        super(ModuleTreeWidget, self).__init__(parent)
-        
-        self.setContextMenuPolicy(Qt.CustomContextMenu)        
-        self.connect(self, SIGNAL(&quot;customContextMenuRequested(const QPoint &amp;)&quot;), self.doMenu)
-
-        self.onMenuCallback = None
-
-
-#        clearAction= QAction(&quot;Clear Window&quot;,  self)
-#        self.consoleWindow.textEdit.addAction(clearAction)
-#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-#        clearAction.setShortcut(&quot;Ctrl + R&quot;)
-#        self.connect(clearAction, SIGNAL(&quot;triggered()&quot;), self.consoleWindow.textEdit.clear)
-
-    def setMenuCallback(self, callback):
-        self.onMenuCallback = callback
-        
-    def doMenu(self, point):
-        self.onMenuCallback(self.mapToGlobal(point))
-
-class ModuleExplorer(QWidget):
-    def __init__(self, parent=None):
-        QWidget.__init__(self, parent)
-        self.sceneTreeView = ModuleTreeWidget()
-        
-        self.sceneTreeView.setMenuCallback(self.onMenu)
-        self.connect(self.sceneTreeView, SIGNAL(&quot;itemClicked (QTreeWidgetItem *,int)&quot;), self.onClick)
-        
-        vBoxLayout = QVBoxLayout()
-        vBoxLayout.addWidget(self.sceneTreeView)
-
-        self.setLayout(vBoxLayout)
-        
-        self.nodeDict = {}
-        
-        self.moduleManager = None
-        self.mapSelectedCallback = None
-        
-    def onClick(self, item, column):
-        if self.mapSelectedCallback is None:
-            return
-        
-        name = str(item.text(0))
-        if name.startswith(&quot;Map: &quot;):
-            self.mapSelectedCallback(str(item.parent().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;), name.replace(&quot;Map: &quot;, &quot;&quot;))
-        elif name.startswith(&quot;Scene: &quot;):
-            if item.childCount &gt; 0:
-                self.mapSelectedCallback(name.replace(&quot;Scene: &quot;, &quot;&quot;), None)
-                return
-                
-            self.mapSelectedCallback(name.replace(&quot;Scene: &quot;, &quot;&quot;), str(item.child(0).text(0)).replace(&quot;Map: &quot;, &quot;&quot;))
-        
-    def onMenu(self, point):
-        if self.moduleManager is not None:
-            menu = QMenu(self)
-            
-            newSceneAction= QAction(&quot;New Scene&quot;,  self)
-            menu.addAction(newSceneAction)
-            self.connect(newSceneAction, SIGNAL(&quot;triggered()&quot;), self.onNewScene)
-
-            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith(&quot;Scene:&quot;):
-                newMapAction= QAction(&quot;New Map&quot;,  self)
-                menu.addAction(newMapAction)
-                self.connect(newMapAction, SIGNAL(&quot;triggered()&quot;), self.onNewMap)
-
-            deleteAction= QAction(&quot;Delete&quot;,  self)
-            menu.addAction(deleteAction)
-            self.connect(deleteAction, SIGNAL(&quot;triggered()&quot;), self.onDelete)
-            
-            menu.exec_(point)
-      
-    def onNewScene(self):
-        dlg = NameInputDlg(self)
-        if dlg.exec_():
-            self.moduleManager.addSceneToModule(str(dlg.nameInput.text()))
-            self.updateView()
-            self.onNewMap()
-            
-    def onNewMap(self):
-        dlg = NameInputDlg(self)
-        if dlg.exec_():
-            sceneName = str(self.sceneTreeView.currentItem().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;)
-            self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
-            self.updateView()
-        
-    def onDelete(self):
-        print &quot;delete&quot;
-      
-    def updateView(self):
-        self.sceneTreeView.clear()
-        
-        for s in self.module.scenes:
-            sceneRootItem = QTreeWidgetItem(self.sceneTreeView)
-            sceneRootItem.setText(0, &quot;Scene: &quot; + s.name)
-            
-            for m in s.mapFiles:
-                self.parseMap(m, sceneRootItem)
-
-                
-    def parseMap(self, map, sceneRootItem):
-        childItem =  QTreeWidgetItem(sceneRootItem)
-        childItem.setText(0, &quot;Map: &quot; + map.mapName)
-        
-        iter = map.mapNode.getChildIterator()
-        while iter.hasMoreElements():
-            childItem2 = QTreeWidgetItem(childItem) 
-            childItem2.setText(0, iter.getNext().getName())
-        
-    def setCurrentModule(self, module):
-        self.module = module
-        self.updateView()
-
-    def setModuleManager(self, moduleManager):
-        self.moduleManager = moduleManager
-        
-    def setMapSelectedCallback(self, callback):
-        self.mapSelectedCallback = callback
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+#dienstag 24.03 15.50
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+import ogre.renderer.OGRE as og
+
+class NameInputDlg(QDialog):
+    def __init__(self, parent = None):
+        super(NameInputDlg, self).__init__(parent)
+        
+        self.nameInput = QLineEdit(self)
+        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        layout = QVBoxLayout()
+        layout.addWidget(self.nameInput)
+        layout.addWidget(buttonBox)
+        self.setLayout(layout)
+        
+        self.connect(buttonBox, SIGNAL(&quot;accepted()&quot;), self, SLOT(&quot;accept()&quot;))        
+        self.connect(buttonBox, SIGNAL(&quot;rejected()&quot;), self, SLOT(&quot;reject()&quot;))
+        
+        
+class ModuleTreeWidget(QTreeWidget):
+    def __init__(self, parent = None):
+        super(ModuleTreeWidget, self).__init__(parent)
+        
+        self.setContextMenuPolicy(Qt.CustomContextMenu)        
+        self.connect(self, SIGNAL(&quot;customContextMenuRequested(const QPoint &amp;)&quot;), self.doMenu)
+
+        self.onMenuCallback = None
+        self.setAnimated(True)
+
+#        clearAction= QAction(&quot;Clear Window&quot;,  self)
+#        self.consoleWindow.textEdit.addAction(clearAction)
+#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+#        clearAction.setShortcut(&quot;Ctrl + R&quot;)
+#        self.connect(clearAction, SIGNAL(&quot;triggered()&quot;), self.consoleWindow.textEdit.clear)
+
+    def setMenuCallback(self, callback):
+        self.onMenuCallback = callback
+        
+    def doMenu(self, point):
+        self.onMenuCallback(self.mapToGlobal(point))
+
+class ModuleExplorer(QWidget):
+    def __init__(self, parent=None):
+        QWidget.__init__(self, parent)
+        self.sceneTreeView = ModuleTreeWidget()
+        
+        self.sceneTreeView.setMenuCallback(self.onMenu)
+        self.connect(self.sceneTreeView, SIGNAL(&quot;itemClicked (QTreeWidgetItem *,int)&quot;), self.onClick)
+        
+        vBoxLayout = QVBoxLayout()
+        vBoxLayout.addWidget(self.sceneTreeView)
+
+        self.setLayout(vBoxLayout)
+        
+        self.nodeDict = {}
+        
+        self.moduleManager = None
+        self.mapSelectedCallback = None
+        
+        self.lastSelectedMap = None
+        
+    def onClick(self, item, column):
+        if self.mapSelectedCallback is None:
+            return
+        
+        name = str(item.text(0))
+        if name.startswith(&quot;Map: &quot;):
+            self.mapSelectedCallback(str(item.parent().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;), name.replace(&quot;Map: &quot;, &quot;&quot;))
+            self.lastSelectedMap = name
+        elif name.startswith(&quot;Scene: &quot;):
+            if item.childCount &gt; 0:
+                self.mapSelectedCallback(name.replace(&quot;Scene: &quot;, &quot;&quot;), None)
+                return
+            self.mapSelectedCallback(name.replace(&quot;Scene: &quot;, &quot;&quot;), str(item.child(0).text(0)).replace(&quot;Map: &quot;, &quot;&quot;))
+            self.lastSelectedMap = name
+        else:
+            self.mapSelectedCallback(str(item.parent().parent().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;), str(item.parent().text(0)).replace(&quot;Map: &quot;, &quot;&quot;))
+            self.lastSelectedMap = name
+            
+
+        
+    def onMenu(self, point):
+        if self.moduleManager is not None:
+            menu = QMenu(self)
+            
+            newSceneAction= QAction(&quot;New Scene&quot;,  self)
+            menu.addAction(newSceneAction)
+            self.connect(newSceneAction, SIGNAL(&quot;triggered()&quot;), self.onNewScene)
+
+            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith(&quot;Scene:&quot;):
+                newMapAction= QAction(&quot;New Map&quot;,  self)
+                menu.addAction(newMapAction)
+                self.connect(newMapAction, SIGNAL(&quot;triggered()&quot;), self.onNewMap)
+
+            deleteAction= QAction(&quot;Delete&quot;,  self)
+            menu.addAction(deleteAction)
+            self.connect(deleteAction, SIGNAL(&quot;triggered()&quot;), self.onDelete)
+            
+            menu.exec_(point)
+      
+    def onNewScene(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            self.moduleManager.addSceneToModule(str(dlg.nameInput.text()))
+            self.updateView()
+            self.onNewMap()
+            
+    def onNewMap(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            sceneName = str(self.sceneTreeView.currentItem().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;)
+            self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
+            self.updateView()
+        
+    def onDelete(self):
+        print &quot;delete&quot;
+      
+    def updateView(self):
+        self.sceneTreeView.clear()
+        
+        for s in self.module.scenes:
+            sceneRootItem = QTreeWidgetItem(self.sceneTreeView)
+            sceneRootItem.setText(0, &quot;Scene: &quot; + s.name)
+            
+            for m in s.mapFiles:
+                self.parseMap(m, sceneRootItem)
+
+
+    def parseMap(self, map, sceneRootItem):
+        childItem =  QTreeWidgetItem(sceneRootItem)
+        mn = &quot;Map: &quot; + map.mapName
+        childItem.setText(0, mn)
+        if mn == self.lastSelectedMap:
+            childItem.setSelected(True)
+            childItem.parent().setExpanded(True)
+        
+        i = 0
+        while i &lt; map.mapNode.numChildren():
+            childItem2 = QTreeWidgetItem(childItem) 
+            childItem2.setText(0, map.mapNode.getChild(i).getName())
+            i = i+1
+
+
+# this crashed in linux
+#        iter = map.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            childItem2 = QTreeWidgetItem(childItem) 
+#            val = iter.getNext()
+#            if  val is not None:
+#                childItem2.setText(0, val.getName())
+
+        
+    def setCurrentModule(self, module):
+        self.module = module
+        self.updateView()
+
+    def setModuleManager(self, moduleManager):
+        self.moduleManager = moduleManager
+        
+    def setMapSelectedCallback(self, callback):
+        self.mapSelectedCallback = callback

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -75,7 +75,6 @@
         if level and (not elem.tail or not elem.tail.strip()):
             elem.tail = i
 
-
 class Map():
     def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
         self.pathToMapFile = pathToFile
@@ -123,6 +122,12 @@
     def createEntites(self, entityNodes):
         for nodes in entityNodes:
             entityName = nodes.attrib[&quot;name&quot;]
+            
+            if entityName.startswith(&quot;dropMesh&quot;):
+                num = int(entityName.replace(&quot;dropMesh&quot;,  &quot;&quot;))
+                if ModuleManager.dropCount &lt; num:
+                    ModuleManager.dropCount = num
+                    
             meshFile = nodes.attrib[&quot;meshfile&quot;]
             nodePosition = None
             nodeScale = None
@@ -274,10 +279,40 @@
         
         nodesElem = xml.SubElement(root, &quot;nodes&quot;)
         
-        iter = self.mapNode.getChildIterator()
-        while iter.hasMoreElements():
-            name = iter.getNext().getName()
-            print name
+        i = 0
+        while i &lt; self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.numAttachedObjects() &gt; 0:
+                if n.name.startswith(&quot;entity_&quot;):
+                    entElem = xml.SubElement(nodesElem, &quot;entity&quot;)
+                    entElem.attrib[&quot;name&quot;] = n.getAttachedObject(0).getName()
+                    entElem.attrib[&quot;meshfile&quot;] = n.getAttachedObject(0).getMesh().getName()
+                    
+                    posElem = xml.SubElement(entElem, &quot;position&quot;)
+                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(entElem, &quot;rotation&quot;)
+                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
+                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
+                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
+                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
+                    
+                    scaleElem = xml.SubElement(entElem, &quot;scale&quot;)
+                    scaleElem.attrib[&quot;x&quot;] = str(n.getScale().x)
+                    scaleElem.attrib[&quot;y&quot;] = str(n.getScale().y)
+                    scaleElem.attrib[&quot;z&quot;] = str(n.getScale().z)
+                
+            i = i+1
+            
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
 
 class Scene():
     def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
@@ -358,7 +393,7 @@
         if isfile(modConfig): # is the modconfig existing?
             f = codecs.open(modConfig, 'r', 'utf-8')
         else:
-            print (&quot;Error: couldn't find module config&quot;)
+            print (&quot;Module.isCommon() Error: couldn't find module config&quot;)
             return
         isDependencieLine = False
         for i, line in enumerate(f):
@@ -391,7 +426,7 @@
         if isfile(modConfig): # is the modconfig existing?
             f = codecs.open(modConfig, 'r', 'utf-8')
         else:
-            print (&quot;Error: couldn't find module config&quot;)
+            print (&quot;Module.load: Error: couldn't find module config&quot;)
             return
 
         #for i, line in enumerate(f):
@@ -404,6 +439,7 @@
         except og.OgreException, e:
             print e
         
+        
         cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
         self.gofFiles = glob.glob(cmd)
         self.gocManager.parseGOFFiles(self.gofFiles)
@@ -430,15 +466,16 @@
 
         for file in os.listdir(rootFolder):
             curFile = join(rootFolder, file)
+            if file == &quot;WindyGrass.program&quot;:
+                print &quot;yes!&quot;
 
-
             if file.startswith('.'): #ignore dot files (hidden)
                 continue
-            if os.path.isdir(curFile):
+            elif os.path.isdir(curFile):
                 og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
                 self.setResourcePaths(curFile)
-            if os.path.isfile(curFile):
-                pass
+            elif os.path.isfile(curFile):
+                continue
                 
     def getMap(self, mapName, sceneName = None):
         if sceneName is not None:
@@ -454,14 +491,18 @@
                             return m
                             
 class ModuleManager():
+    dropCount = 0
+        
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
         self.modelSelectionDialog = None
+        self.materialSelectionDialog = None
 
         self.moduleCfgPath = &quot;&quot;
 
         self.gocManager = GameObjectClassManager()
+        
         # we need to hold a reference to the game object representaions ourself
         # python does not recognize the a reference to a c++ object (Entity in our case) is passed
         # and deletes the object
@@ -487,17 +528,20 @@
         self.middleMouseDown = False
         self.rightMouseDown = False
 
-        self.dropCount = 0
+       
         self.dropNode = None
         self.dropEntity = None
         self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-
+        self.dropMat = None
+        
         self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
         self.moduleConfigIsParsed = False
 
         self.selectionBuffer = None
         self.propertyWindow = None
     
+        self.oneClickEntityPlacement = False
+    
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
         self.moduleList = []
@@ -520,7 +564,6 @@
 
         self.moduleConfigIsParsed = True
 
-
     def moduleExists(self, name):
         lowerA = str(name).lower()
         
@@ -563,17 +606,20 @@
                             if m2.name == moduleDependencie:
                                 m2.load()
                                 self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
                                 self.mainModuledependencieList.append(m2)
 
                 m.load()
                 self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 
         self.moduleExplorer.updateView()
+        ModuleManager.dropCount += 1
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
-#        e.setMaterialName(&quot;PlainColor&quot;)
+#        e.setMaterialName(&quot;PlainColorGLSL&quot;)
 #        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
 #
 #        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
@@ -582,7 +628,7 @@
 #        n.attachObject(e)
 #        n.attachObject(e2)
 #        n.setScale(og.Vector3(10, 5, 20))
-#        
+        
         if self.selectionBuffer is None:
             self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
 
@@ -610,6 +656,11 @@
         
     # called when a click into Main Ogre Window occurs
     def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        if self.oneClickEntityPlacement:
+            meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+            self.startDropModelAction(meshFile, ray)
+            return
+            
         so = None
         if self.selectionBuffer is not None:
             so = self.selectionBuffer.onSelectionClick(screenX, screenY)
@@ -648,26 +699,26 @@
             if self.pivot is not None:
                 self.pivot.hide()
 
-        if self.rayLine == None:
-            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
-            self.rayLine.setDynamic(True)
-            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+#
+#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
 
-            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-        else:
-            self.rayLine.beginUpdate(0)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
     def deleteObjects(self):
         if len(self.userSelectionList) &lt; 1:
             return
@@ -675,7 +726,10 @@
         self.pivot.hide()
 
         for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            node = so.entity.getParentNode()
+            node.detachAllObjects()
+            self.sceneManager.destroySceneNode(node)
+            self.sceneManager.destroyEntity(so.entity)
             del so
 
         self.userSelectionList = []
@@ -711,12 +765,12 @@
                     meshFile = go.getMeshFileName()
 
                     if go is not None:
-                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-                        newNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(ModuleManager.dropCount), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild(&quot;gameObject_dropNode&quot; + str(ModuleManager.dropCount))
                         newNode.attachObject(newEntity)
                         newNode.setPosition(so.entity.getParentNode().getPosition())
 
-                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
                         self.gameObjectRepresentationDict.append(newGO)
                         newEntity.setUserObject(newGO)
                         newGO.setPosition(og.Vector3(0, 0, 0))
@@ -724,12 +778,12 @@
                         newSO = SelectionObject(newEntity, so.distance)
                         newSO.setSelected(True)
                         newSelectionList.append(newSO)
-                        self.dropCount += 1
+                        ModuleManager.dropCount += 1
             else:
-                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+                nodeName = &quot;entity_dropNode&quot; + str(ModuleManager.dropCount)
+                newNode = self.currentMap.mapNode.createChild(nodeName)
 
-                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                entityName = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
                 newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
 
                 newNode.attachObject(newEntity)
@@ -737,9 +791,10 @@
                 newNode.setOrientation(so.entity.getParentNode().getOrientation())
                 newNode.setScale(so.entity.getParentNode().getScale())
 
-                newSO = SelectionObject(newEntity, so.distance)
+                newSO = SelectionObject(newEntity)
                 newSO.setSelected(True)
                 newSelectionList.append(newSO)
+                ModuleManager.dropCount += 1
 
         self.resetSelection()
         self.userSelectionList = newSelectionList
@@ -790,8 +845,6 @@
 
         self.userSelectionList = []
 
-
-
     def updatePivots(self):
         newPivotPosition = og.Vector3(0, 0, 0)
 
@@ -811,8 +864,8 @@
 
         if go is not None:
             meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(self.dropCount))
+            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(ModuleManager.dropCount), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
             dropNode.attachObject(dropEntity)
 
             result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -821,10 +874,10 @@
             else:
                 dropNode.setPosition(ray.getPoint(50))
 
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
             dropEntity.setUserObject(self.dropGO)
 
-        self.dropCount += 1
+        ModuleManager.dropCount += 1
 
     def moveDropGameObjectAction(self, ray):
         result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -833,12 +886,17 @@
         else:
             self.dropGO.setPosition(ray.getPoint(50))
 
-    def stopDropGameObjectAction(self, ray):
-        print &quot;sd&quot;
+    def finishDropGameObjectAction(self, ray):
+        return
 
     def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(self.dropCount))
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(ModuleManager.dropCount), meshFile)
+
+        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(ModuleManager.dropCount))
         self.dropNode.attachObject(self.dropEntity)
 
         result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -847,16 +905,45 @@
         else:
             self.dropNode.setPosition(ray.getPoint(50))
 
-        self.dropCount += 1
+        ModuleManager.dropCount += 1
 
     def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
         result = og.Math.intersects(ray, self.dropCollisionPlane)
         if result.first == True:
             self.dropNode.setPosition(ray.getPoint(result.second))
         else:
             self.dropNode.setPosition(ray.getPoint(50))
+    
+    def finishDropModelAction(self, ray):
+        return
 
+    def startDropMaterialAction(self, text):
+        self.dropMat = text
+        
+    def moveDropMaterialAction(self, event):
+        return
 
-    def stopDropModelAction(self, ray):
-        pass
-
+    def finishDropMaterialAction(self, screenX, screenY):
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        if so is not None:
+            if not so.entity.getNumSubEntities() &gt; 1:
+                so.entity.setMaterialName(self.dropMat)
+            else:
+                i = 0
+                text = &quot;Warning this Entity has more than one SubEntities with the folloing materials: \n\n&quot;
+                while i &lt; so.entity.getNumSubEntities():
+                    text += &quot;SubMesh&quot; + str(i) + &quot;:  &quot; + so.entity.getSubEntity(i).getMaterialName() + &quot;\n&quot;
+                    i += 1
+                
+                text += &quot;\n Replace the materials?&quot;
+                reply = QMessageBox.question(None, &quot;Warning: multiple materials&quot;,  text,  QMessageBox.Yes|QMessageBox.No)
+                if reply == QMessageBox.Cancel:
+                    return
+                if reply == QMessageBox.Yes:
+                    so.entity.setMaterialName(self.dropMat)
+        
+    def setOneClickEntityPlacement(self, state):
+        self.oneClickEntityPlacement = state

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -31,6 +31,7 @@
         self.meshManager = og.MeshManager.getSingleton ()
 
         self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode(&quot;pivotNode&quot;)
+
         self.__createMovePivot()
         self.__createRotatePivot()
         self.__createScalePivot()
@@ -44,60 +45,33 @@
     def __createMovePivot(self):
         self.xMoveEntity = self.sceneManager.createEntity(&quot;EditorXArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
         self.xMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthCheckEnabled(False)
-#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthWriteEnabled(False)
-        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
         self.xMoveNode = self.pivotNode.createChildSceneNode()
         self.xMoveNode.attachObject(self.xMoveEntity)
         self.xMoveNode.translate(og.Vector3(2, 0, 0))
         self.xMoveNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
-
-#        plane = og.Plane (og.Vector3.UNIT_X, 0)
-#        self.meshManager.createPlane ('EditorXArrowSelectionPlane', 'General', plane, 5, 14, 1, 1, False, 1, 5, 5, (0, 0, 1))
-#        self.xMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorXArrowSelectionPlane', 'EditorXArrowSelectionPlane')
-#        self.xMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
-#        self.xMoveNodeSelectionPlane.attachObject (self.xMoveEntitySelectionPlane)
-#        self.xMoveNodeSelectionPlane.translate(og.Vector3(0, 0, 5))
-#        self.xMoveEntitySelectionPlane.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-
-
-
+        
         self.yMoveEntity = self.sceneManager.createEntity(&quot;EditorYArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
         self.yMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
         self.yMoveNode = self.pivotNode.createChildSceneNode()
         self.yMoveNode.attachObject(self.yMoveEntity)
         self.yMoveNode.translate(og.Vector3(0, 2, 0))
         self.yMoveNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
-        #self.yNode.showBoundingBox(True)
 
-#        plane = og.Plane (og.Vector3().UNIT_X, 0)
-#        self.meshManager.createPlane ('EditorYArrowSelectionPlane', 'General', plane, 14, 0, 1, 1, False, 1, 5, 5, (0, 0, 1))
-#        self.yMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorYArrowSelectionPlane', 'EditorYArrowSelectionPlane')
-#        self.yMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
-#        self.yMoveNodeSelectionPlane.attachObject (self.yMoveEntitySelectionPlane)
-#        self.yMoveNodeSelectionPlane.translate(og.Vector3(0, 5, 0))
-#        self.yMoveEntitySelectionPlane.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
 
-
         self.zMoveEntity = self.sceneManager.createEntity(&quot;EditorZArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
         self.zMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
-        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
         self.zMoveNode = self.pivotNode.createChildSceneNode()
         self.zMoveNode.attachObject(self.zMoveEntity)
         self.zMoveNode.translate(og.Vector3(0, 0, 2))
-        #self.zNode.showBoundingBox(True)
 
-        self.freeMoveEntity = self.sceneManager.createEntity(&quot;EditorFreeMoveArrow&quot;,  &quot;Pivot_FreeMover.mesh&quot;)
-        self.freeMoveEntity.setMaterialName(&quot;Lockenwickler_FreeMover&quot;)
-        self.freeMoveNode = self.pivotNode.createChildSceneNode()
-        self.freeMoveNode.attachObject(self.freeMoveEntity)
 
-
     def __createRotatePivot(self):
         self.xRotateEntity = self.sceneManager.createEntity(&quot;EditorXRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
         self.xRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
         self.xRotateNode = self.pivotNode.createChildSceneNode()
         self.xRotateNode.attachObject(self.xRotateEntity)
         #self.xRotateNode.translate(0, 0, -5)
@@ -105,7 +79,7 @@
 
         self.yRotateEntity = self.sceneManager.createEntity(&quot;EditorYRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
         self.yRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
         self.yRotateNode = self.pivotNode.createChildSceneNode()
         self.yRotateNode.attachObject(self.yRotateEntity)
         #self.yRotateNode.translate(0, 0, -10)
@@ -113,14 +87,36 @@
 
         self.zRotateEntity = self.sceneManager.createEntity(&quot;EditorZRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
         self.zRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
-        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
         self.zRotateNode = self.pivotNode.createChildSceneNode()
         self.zRotateNode.attachObject(self.zRotateEntity)
 
 
     def __createScalePivot(self):
-        pass
+        self.xScaleEntity = self.sceneManager.createEntity(&quot;EditorXScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.xScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+        self.xScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.xScaleNode = self.pivotNode.createChildSceneNode()
+        self.xScaleNode.attachObject(self.xScaleEntity)
+        self.xScaleNode.translate(og.Vector3(2, 0, 0))
+        self.xScaleNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+        
+        self.yScaleEntity = self.sceneManager.createEntity(&quot;EditorYScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.yScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.yScaleNode = self.pivotNode.createChildSceneNode()
+        self.yScaleNode.attachObject(self.yScaleEntity)
+        self.yScaleNode.translate(og.Vector3(0, 2, 0))
+        self.yScaleNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
 
+
+        self.zScaleEntity = self.sceneManager.createEntity(&quot;EditorZScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.zScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.zScaleNode = self.pivotNode.createChildSceneNode()
+        self.zScaleNode.attachObject(self.zScaleEntity)
+        self.zScaleNode.translate(og.Vector3(0, 0, 2))
+
     def setPosition(self,  pos):
         self.pivotNode.setPosition(pos)
 
@@ -128,7 +124,6 @@
         return self.pivotNode.getPosition()
 
     def startTransforming(self, dirEntity, soList):
-        print &quot;dbg: transforming.....&quot;
         self.moveDirection = dirEntity.getName()
         self.selectionList = soList
         self.isTransforming = True
@@ -162,19 +157,21 @@
         self.pivotNode.addChild(self.xMoveNode)
         self.pivotNode.addChild(self.yMoveNode)
         self.pivotNode.addChild(self.zMoveNode)
-        pass
-
+    
     def setRotateMode(self):
         self.hide()
         self.mode = 2
         self.pivotNode.addChild(self.xRotateNode)
         self.pivotNode.addChild(self.yRotateNode)
         self.pivotNode.addChild(self.zRotateNode)
-        pass
-
-    def settScaleMode(self):
-        pass
-
+    
+    def setScaleMode(self):
+        self.hide()
+        self.mode = 3
+        self.pivotNode.addChild(self.xScaleNode)
+        self.pivotNode.addChild(self.yScaleNode)
+        self.pivotNode.addChild(self.zScaleNode)
+        
     def onMouseMoved(self, globalX, globalY, incX, incY):
         # move mode
         if self.isTransforming:
@@ -207,15 +204,31 @@
                 if self.moveDirection == &quot;EditorZRotator&quot;:
                     for so in self.selectionList:
                         so.entity.getParentNode().roll(rotValue)
-
+            
+            # scale mode
+            elif self.mode == 3:
+                scaleFactor = 0.3
+                if self.moveDirection == &quot;EditorXScaler&quot;:
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(incX * scaleFactor, 0, 0)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == &quot;EditorYScaler&quot;:
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, incY * scaleFactor, 0)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == &quot;EditorZScaler&quot;:
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, 0, incX * scaleFactor)
+                        so.entity.getParentNode().setScale(scale)
+        
         self.update()
 
     def update(self):
-        vSize = og.Vector3(1.0,1.0,1.0)
-        vScale = og.Vector3(1.0,1.0,1.0)
-
+        vSize = og.Vector3(1.0,1.0,1.0)
+        vScale = og.Vector3(1.0,1.0,1.0)
+
         dist = (self.camera.getDerivedPosition() - self.pivotNode._getDerivedPosition()).length()
-        vScale *= dist / 90.0
+        vScale *= dist / 90.0
 
         self.pivotNode.setScale(vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z)
         #print vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z

Modified: rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,146 +1,148 @@
-# -*- coding: utf-8 -*-
-
-&quot;&quot;&quot;
-Module implementing NewModuleWizard.
-&quot;&quot;&quot;
-
-import os
-import glob
-
-from PyQt4.QtGui import QDialog
-from PyQt4.QtCore import pyqtSignature
-
-from Ui_NewModuleWizard import Ui_Dialog
-
-class NewModuleWizard(QDialog, Ui_Dialog):
-    &quot;&quot;&quot;
-    Class documentation goes here.
-    &quot;&quot;&quot;
-    def __init__(self, moduleManager, parent = None):
-       
-        QDialog.__init__(self, parent)
-        self.setupUi(self)
-
-        self.moduleManager = moduleManager
-        self.moduleManager.parseModuleConfig()
-        
-        for m in self.moduleManager.moduleList:
-            self.moduleDependenciesList.addItem(m.name)
-
-    @pyqtSignature(&quot;QString&quot;)
-    def on_moduleNameLineEdit_textChanged(self, p0):
-        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
-            self.sceneNameLineEdit.setEnabled(True)
-            self.mapNameLineEdit.setEnabled(True)
-            self.moduleDependenciesList.setEnabled(True)
-            self.scriptDependenciesList.setEnabled(True)
-            self.okButton.setEnabled(True)
-        else:
-            self.sceneNameLineEdit.setEnabled(False)
-            self.mapNameLineEdit.setEnabled(False)
-            self.moduleDependenciesList.setEnabled(False)
-            self.scriptDependenciesList.setEnabled(False)
-            self.okButton.setEnabled(False)
-    
-    def scanDirForScripts(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                self.scanDirForScripts(curFile)
-                continue
-            if os.path.isfile(curFile):
-                if file.endswith(&quot;.rb&quot;):
-                    self.scriptDependenciesList.addItem(dir + &quot;/&quot; + file)
-    
-    @pyqtSignature(&quot;&quot;)
-    def on_moduleDependenciesList_itemSelectionChanged(self):
-        self.scriptDependenciesList.clear()
-        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
-        
-        for m in self.moduleDependenciesList.selectedItems():
-            path = os.path.join(modulePath, str(m.text()))
-            cmd = os.path.join(path + &quot;/scripts&quot;)
-            self.scanDirForScripts(cmd)
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_moduleNameLineEdit_returnPressed(self):
-        return
-            
-    @pyqtSignature(&quot;&quot;)
-    def on_mapNameLineEdit_returnPressed(self):
-        return
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_okButton_clicked(self):
-        f = open(self.moduleManager.moduleCfgPath, &quot;a&quot;)
-        f.write(&quot;module=&quot; + str(self.moduleNameLineEdit.text()) + &quot;\n&quot;)
-        f.close()
-        
-        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
-        modulePath = str(modulePath + self.moduleNameLineEdit.text())
-        os.mkdir(modulePath)
-        os.mkdir(os.path.join(modulePath, &quot;dialogs&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;dsa&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;gui&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;maps&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;materials&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;materials/textures&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;models&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;quests&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;scripts&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;scripts/maps&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;sound&quot;))
-        
-        mname = str(self.moduleNameLineEdit.text())
-        mdeps = &quot;&quot;
-        for m in self.moduleDependenciesList.selectedItems():
-            mdeps = mdeps + str(&quot;\&quot;&quot; + m.text() + &quot;\&quot;, &quot;)
-        mdeps = mdeps.strip(&quot;, &quot;)
-        
-        sdeps = &quot;&quot;
-        for s in self.scriptDependenciesList.selectedItems():
-            script = str(str(s.text()).replace(&quot;\\&quot;, &quot;/&quot;))
-            script = script.split(&quot;/&quot;)
-            script = script[len(script) - 1]
-            sdeps = sdeps + str(&quot;       require &quot; + script + &quot;\n&quot;)
-        
-        
-        f = open(os.path.join(modulePath, &quot;scripts\\&quot;) + &quot;moduleconfig.rb&quot;, &quot;w&quot;)
-        f.write(&quot;include RlScript\n&quot;)
-        f.write(&quot;\n\n&quot;)
-        f.write(&quot;class &quot; + mname.capitalize() + &quot;Module &lt; ContentModule\n&quot;)
-        f.write(&quot;    def initialize()\n&quot;)
-        f.write(&quot;        super(\&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, \&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, false, 200608012)\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getDependencies()\n&quot;)
-        f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getTextureLocation()\n&quot;)
-        f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getModelLocation()\n&quot;)
-        f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getSoundLocation()\n&quot;)
-        f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def start()\n&quot;)
-        f.write(sdeps)
-        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n&quot;)
-        f.write(&quot;       $World = $CORE.getWorld();\n&quot;)
-        f.write(&quot;    end\n&quot;)
-        f.write(&quot;end\n\n&quot;)
-
-        f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
-        
-        self.moduleManager.resetParsedModuleConfig()
-        self.moduleManager.openLoadModuleDialog()
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_cancelButton_pressed(self):
-        self.close()
-
-
+# -*- coding: utf-8 -*-
+
+&quot;&quot;&quot;
+Module implementing NewModuleWizard.
+&quot;&quot;&quot;
+
+import os
+import glob
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_NewModuleWizard import Ui_Dialog
+
+class NewModuleWizard(QDialog, Ui_Dialog):
+    &quot;&quot;&quot;
+    Class documentation goes here.
+    &quot;&quot;&quot;
+    def __init__(self, moduleManager, parent = None):
+       
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+
+        self.moduleManager = moduleManager
+        self.moduleManager.parseModuleConfig()
+        
+        for m in self.moduleManager.moduleList:
+            self.moduleDependenciesList.addItem(m.name)
+
+    @pyqtSignature(&quot;QString&quot;)
+    def on_moduleNameLineEdit_textChanged(self, p0):
+        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
+            self.sceneNameLineEdit.setEnabled(True)
+            self.mapNameLineEdit.setEnabled(True)
+            self.moduleDependenciesList.setEnabled(True)
+            self.scriptDependenciesList.setEnabled(True)
+            self.okButton.setEnabled(True)
+        else:
+            self.sceneNameLineEdit.setEnabled(False)
+            self.mapNameLineEdit.setEnabled(False)
+            self.moduleDependenciesList.setEnabled(False)
+            self.scriptDependenciesList.setEnabled(False)
+            self.okButton.setEnabled(False)
+    
+    def scanDirForScripts(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                self.scanDirForScripts(curFile)
+                continue
+            if os.path.isfile(curFile):
+                if file.endswith(&quot;.rb&quot;):
+                    self.scriptDependenciesList.addItem(dir + &quot;/&quot; + file)
+    
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleDependenciesList_itemSelectionChanged(self):
+        self.scriptDependenciesList.clear()
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        
+        for m in self.moduleDependenciesList.selectedItems():
+            path = os.path.join(modulePath, str(m.text()))
+            cmd = os.path.join(path + &quot;/scripts&quot;)
+            self.scanDirForScripts(cmd)
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleNameLineEdit_returnPressed(self):
+        return
+            
+    @pyqtSignature(&quot;&quot;)
+    def on_mapNameLineEdit_returnPressed(self):
+        return
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_okButton_clicked(self):
+        f = open(self.moduleManager.moduleCfgPath, &quot;a&quot;)
+        f.write(&quot;module=&quot; + str(self.moduleNameLineEdit.text()) + &quot;\n&quot;)
+        f.close()
+        
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        modulePath = str(modulePath + self.moduleNameLineEdit.text())
+        os.mkdir(modulePath)
+        os.mkdir(os.path.join(modulePath, &quot;dialogs&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;dsa&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;gui&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials/textures&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;models&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;quests&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts/maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;sound&quot;))
+        
+        mname = str(self.moduleNameLineEdit.text())
+        mdeps = &quot;&quot;
+        for m in self.moduleDependenciesList.selectedItems():
+            mdeps = mdeps + str(&quot;\&quot;&quot; + m.text() + &quot;\&quot;, &quot;)
+        mdeps = mdeps.strip(&quot;, &quot;)
+        
+        sdeps = &quot;&quot;
+        for s in self.scriptDependenciesList.selectedItems():
+            script = str(str(s.text()).replace(&quot;\\&quot;, &quot;/&quot;))
+            script = script.split(&quot;/&quot;)
+            script = script[len(script) - 1]
+            sdeps = sdeps + str(&quot;       require &quot; + script + &quot;\n&quot;)
+        
+        p = os.path.join(modulePath, &quot;scripts&quot;)
+        p = os.path.join(p, &quot;moduleconfig.rb&quot;)
+        f = open(p, &quot;w&quot;)
+        f.write(&quot;include RlScript\n&quot;)
+        f.write(&quot;\n\n&quot;)
+        f.write(&quot;class &quot; + mname.capitalize() + &quot;Module &lt; ContentModule\n&quot;)
+        f.write(&quot;    def initialize()\n&quot;)
+        f.write(&quot;        super(\&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, \&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, false, 200608012)\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getDependencies()\n&quot;)
+        f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getTextureLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getModelLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getSoundLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def start()\n&quot;)
+        f.write(sdeps)
+        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n&quot;)
+        f.write(&quot;       $World = $CORE.getWorld();\n&quot;)
+        f.write(&quot;    end\n&quot;)
+        f.write(&quot;end\n\n&quot;)
+
+        f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
+        f.close()
+        
+        self.moduleManager.resetParsedModuleConfig()
+        self.moduleManager.openLoadModuleDialog()
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_cancelButton_pressed(self):
+        self.close()
+
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,129 +1,223 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from Property import *
-
-class ObjectPropertyWin(QDialog):
-    def __init__(self, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setupUi()
-
-        self.so = None
-
-        self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
-                               self.onItemClicked)
-
-    def setupUi(self):
-        self.setObjectName(&quot;ObjectPropertys&quot;)
-        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
-
-        self.treeWidget = QTreeWidget(self)
-        self.treeWidget.setGeometry(QRect(0,0,901,721))
-        self.treeWidget.setMinimumSize(QSize(400,400))
-        self.treeWidget.setObjectName(&quot;treeWidget&quot;)
-        self.treeWidget.setAlternatingRowColors(True)
-        
-        self.retranslateUi()
-        QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.treeWidget.headerItem().setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Property&quot;, None, QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(1,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Value&quot;, None, QApplication.UnicodeUTF8))
-        self.treeWidget.clear()
-
-
-    def onItemClicked(self, item, column):
-        pass
-        
-    def showProperties(self, so):
-        self.so=so
-        self.treeWidget.clear()
-        
-        name = so.entity.getParentNode().getName()
-        node = so.entity.getParentNode()
-        
-        if name.startswith(&quot;entity_&quot;):
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Name&quot;)
-            item.setText(1, name.replace(&quot;entity_&quot;, &quot;&quot;))
-            
-            self.parsePosition(node)
-            self.parseOrientation(node)
-            self.parseScale(node)
-            
-    def parsePosition(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Position&quot;)
-        item.setText(1, str(node.getPosition().x) + &quot; &quot; + str(node.getPosition().y) + &quot; &quot; + str(node.getPosition().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getPosition().x))
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getPosition().y))
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getPosition().z))
-        
-    def parseOrientation(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Orientation&quot;)
-        item.setText(1, str(node.getOrientation().x) + &quot; &quot; + str(node.getOrientation().y) + &quot; &quot; + str(node.getOrientation().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getOrientation().x))
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getOrientation().y))
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getOrientation().z))
-    
-    def parseScale(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Scale&quot;)
-        item.setText(1, str(node.getScale().x) + &quot; &quot; + str(node.getScale().y) + &quot; &quot; + str(node.getScale().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getScale().x))
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getScale().y))
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getScale().z))
-            
-    def updateProperties(self):
-        if self.so is not None:
-            self.showProperties(self.so)
-            
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from Property import *
+
+class ObjectPropertyWin(QDialog):
+    def __init__(self, sceneManager, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setupUi()
+        self.sceneManager = sceneManager
+        self.valueBeforeEdit = None
+        
+        self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
+                               self.onItemClicked)
+        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                               self.onItemChanged)
+
+    def setupUi(self):
+        self.setObjectName(&quot;ObjectPropertys&quot;)
+        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
+
+        self.treeWidget = QTreeWidget(self)
+        self.treeWidget.setGeometry(QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QSize(400,400))
+        self.treeWidget.setObjectName(&quot;treeWidget&quot;)
+        self.treeWidget.setAlternatingRowColors(True)
+        self.treeWidget.setAnimated(True)
+        
+        self.retranslateUi()
+        QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.treeWidget.headerItem().setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Property&quot;, None, QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Value&quot;, None, QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+
+    def onItemClicked(self, item, column):
+        if column == 1:
+            self.valueBeforeEdit = item.text(column)
+            self.treeWidget.editItem(item, column)
+
+    def onItemChanged(self, item, column):
+        if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
+            parent = item.parent()
+            if parent is None:
+                if item.text(0) == &quot;Name&quot;:
+                    if not self.sceneManager.hasEntity(str(item.text(column))):
+                        newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
+                        oldEnt = self.node.getAttachedObject(0)
+                        self.node.detachObject(oldEnt)
+                        self.sceneManager.destroyEntity(oldEnt)
+                        self.node.attachObject(newEnt)
+                        
+                        # update the selection object since it still has references to the deleted entity
+                        self.so.entity = newEnt
+                        self.so.entityName = newEnt.getName()
+                    else:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;Error: Name already exists!&quot;
+            else:
+                val = None
+                try:
+                    val = float(item.text(1))
+                except ValueError, e:
+                    item.setText(column, self.valueBeforeEdit)
+                    print &quot;ValueError: &quot; + str(e)
+                    return
+                    
+                if parent.text(0) == &quot;Position&quot;:
+                    if item.text(0) == &quot;X&quot;:
+                        self.node.setPosition(val, self.node.getPosition().y, self.node.getPosition().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setPosition(self.node.getPosition().x, val, self.node.getPosition().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setPosition(self.node.getPosition().x, self.node.getPosition().y, val)
+                elif parent.text(0) == &quot;Orientation&quot;:
+                    if item.text(0) == &quot;W&quot;:
+                        self.node.setOrientation(val, self.node.getOrientation().x, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;X&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, val, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, val, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, self.node.getOrientation().y, val)
+                elif parent.text(0) == &quot;Scale&quot;:
+                    if item.text(0) == &quot;X&quot;:
+                        self.node.setScale(val, self.node.getScale().y, self.node.getScale().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
+                        
+    def showProperties(self, so):
+        # onItemChanged should only be called when the user changes values not when they change by code
+        self.disconnect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                       self.onItemChanged)
+                       
+        self.so=so
+        self.treeWidget.clear()
+        
+        name = so.entity.getParentNode().getName()
+        self.node = so.entity.getParentNode()
+        
+        if name.startswith(&quot;entity_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Name&quot;)
+            n = self.node.getAttachedObject(0).getName()
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            itemMat = QTreeWidgetItem(self.treeWidget)
+            itemMat.setText(0, &quot;Materials&quot;)
+            
+            i = 0
+            while i &lt; self.node.getAttachedObject(0).getNumSubEntities():
+                it = QTreeWidgetItem(itemMat)
+                it.setFlags(item.flags() | Qt.ItemIsEditable)
+                it.setText(0, &quot;SubMesh&quot; + str(i))
+                it.setText(1, self.node.getAttachedObject(0).getSubEntity(i).getMaterialName())
+                i += 1
+                
+            
+            #item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
+            
+        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                       self.onItemChanged)
+                       
+                       
+    def parsePosition(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Position&quot;)
+        item.setText(1, str(node.getPosition().x) + &quot;; &quot; + str(node.getPosition().y) + &quot;; &quot; + str(node.getPosition().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getPosition().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getPosition().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getPosition().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseOrientation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Orientation&quot;)
+        item.setText(1, str(node.getOrientation().w) + &quot;; &quot; + str(node.getOrientation().x) + &quot;; &quot; + str(node.getOrientation().y) + &quot;; &quot; + str(node.getOrientation().z))
+        
+        itemW = QTreeWidgetItem(item)
+        itemW.setText(0, &quot;W&quot;)
+        itemW.setText(1, str(node.getOrientation().w))
+        itemW.setFlags(itemW.flags() | Qt.ItemIsEditable)
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getOrientation().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getOrientation().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getOrientation().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseScale(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Scale&quot;)
+        item.setText(1, str(node.getScale().x) + &quot;; &quot; + str(node.getScale().y) + &quot;; &quot; + str(node.getScale().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getScale().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getScale().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getScale().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def updateProperties(self):
+        if self.so is not None:
+            self.showProperties(self.so)
+            

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -55,10 +55,9 @@
         self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
 
         self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-
+        
         self.setupUi(self)
 
-
     def setupUi(self, Form):
         Form.setObjectName(&quot;Form&quot;)
         Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
@@ -118,9 +117,13 @@
 
         self.retranslateUi(Form)
         QMetaObject.connectSlotsByName(Form)
-
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
         self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
         self.viewportGrid.enable()
+        
     def retranslateUi(self, Form):
         Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
         self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
@@ -220,10 +223,10 @@
             self.dragEnterEvent(event)
         if event.type() == 61: #drag move
             self.dragMoveEvent(event)
-        if event.type() == 62:
-            print &quot;dbg: DragLeave&quot;
+#        if event.type() == 62:
+#            self.finishDropEvent(event)
         if event.type() == 63:
-            self.dropEvent(event)
+            self.finishDropEvent(event)
 
         return False
 
@@ -234,7 +237,7 @@
             text = QString()
             stream &gt;&gt; text
 
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+            self.moduleManager.startDropModelAction(str(text), self.getCameraToViewportRay()) #start the model draging
 
             event.setDropAction(Qt.CopyAction)
             event.accept()
@@ -245,10 +248,20 @@
             text = QString()
             stream &gt;&gt; text
 
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+            self.moduleManager.startDropGameObjectAction(str(text), self.getCameraToViewportRay()) #start the model draging
 
             event.setDropAction(Qt.CopyAction)
             event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            data = event.mimeData().data(&quot;application/x-material&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropMaterialAction(str(text)) #start the material draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
         else:
             event.ignore()
 
@@ -260,16 +273,23 @@
         elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
             self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
             event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            self.moduleManager.moveDropMaterialAction(event) #move it with the mouse
+            event.accept()
         else:
             event.ignore()
 
-    def dropEvent(self, event):
+    def finishDropEvent(self, event):
         if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            self.moduleManager.finishDropModelAction(self.getCameraToViewportRay())
             event.accept()
         elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            self.moduleManager.finishDropGameObjectAction(self.getCameraToViewportRay()) 
             event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+            self.moduleManager.finishDropMaterialAction(relMousePos.x(), relMousePos.y()) 
+            event.accept()
         else:
             event.ignore()
 
@@ -299,11 +319,11 @@
         mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
 
         if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(mouseRay,  True,  False)
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
         elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(mouseRay,  False,  True)
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
         else:
-            self.moduleManager.selectionClick(mouseRay)
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
 
     def getWidth():
         return self.ogreWidget.getWidth()
@@ -311,7 +331,6 @@
     def getHeight():
         return self.ogreWidget.getHeight()
 
-
     def updateCamera(self):        
         if self.moveCamForward:
             self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
@@ -322,4 +341,8 @@
         if self.strafeCamRight:
             self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
         
-        self.moduleManager.pivot.update()
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()
+            
+    def updateRenderWindow(self):
+        self.ogreWidget.update()

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -27,67 +27,93 @@
 class OgreWidget(QtGui.QWidget):
     def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
         QtGui.QWidget.__init__(self, parent)
+        self.painted = False
         self.renderWindowName = renderWindowName
         self.parent = parent
         self.ogreRoot = ogreRoot
         self.sceneManager = sceneManager
+        self.cameraName = cameraName
         self.camDistFromFocusNode = camDistFromFocusNode
         self.initOgreWindow(renderWindowName,cameraName)
         self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
 
     def initOgreWindow(self, renderWindowName, cameraName):
         self.renderParameters = og.NameValuePairList()
+        
 
         if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
             hwnd = int(self.winId())
             self.renderParameters['externalWindowHandle'] = str(hwnd)
         else:
-            import sip
-            info = self.x11Info()
-            disp =  str(sip.unwrapinstance(info.display()))
-            scr = str(info.screen())
             win = str(int(self.winId()))
-            winHandle = disp + ':' + scr + ':' + win
-            self.renderParameters['parentWindowHandle'] = winHandle
+            self.renderParameters['parentWindowHandle'] = win
 
-        renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
-                                                        False, self.renderParameters)
+#        else:
+#            import sip
+#            info = self.x11Info()
+#            disp =  str(sip.unwrapinstance(info.display()))
+#            scr = str(info.screen())
+#            win = str(int(self.winId()))
+#            winHandle = disp + ':' + scr + ':' + win
+#            
+#            self.renderParameters['parentWindowHandle'] = win
 
-        renderWindow.active = True
-        self.renderWindow = renderWindow
 
-        self.camera = self.sceneManager.createCamera(cameraName)
-        self.camera.NearClipDistance = 0.1
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
 
-        # Create focus node (camera always points at this)
-        self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-        self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-        # camera node is offset a ways along the Z axis of focus node
-        self.camNode = self.camFocusNode.createChildSceneNode()
-        # fix yaw on this one too for when we manipulate it directly
-        self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-        self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-        self.camNode.attachObject(self.camera)
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
 
-        self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-        self.viewport.setClearEveryFrame(True)
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.1
 
-    def setBackgroundColor(self, colorValue):
-        self.viewport.BackgroundColour = colorValue
-
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+        
     def resizeEvent(self, event):
-        self.renderWindow.resize(event.size().width(), event.size().height())
-        self.renderWindow.windowMovedOrResized()
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
 
-        if platform.system() == &quot;Linux&quot;:
-            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+            if platform.system() == &quot;Linux&quot;:
+                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
 
-        self.renderWindow.update(True)
-        self.ogreRoot.renderOneFrame()
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
 
-        if self.camera:
-            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-            
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
         for listener in self.resizeEventListener:
             listener(event.size().width(), event.size().height())
 
@@ -131,3 +157,8 @@
     def panCamera( self, horz, vert):
         self.camNode.yaw(horz, og.Node.TS_WORLD)
         self.camNode.pitch(vert, og.Node.TS_LOCAL)
+        
+    def update(self):
+        if self.renderWindow is not None:
+            self.renderWindow.update(True)
+

Copied: rl/branches/persistence2/editors/Lockenwickler/src/PivotRenderQueueListener.py (from rev 4784, rl/trunk/editors/Lockenwickler/src/PivotRenderQueueListener.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,8 +1,8 @@
 # Defines plugins to load
 
 # Define plugin folder
-#PluginFolder=/home/stefan/development/root/usr/lib/OGRE/
-PluginFolder=/usr/lib/OGRE
+PluginFolder=/home/fusion/development/root/usr/lib/OGRE/
+#PluginFolder=/usr/lib/OGRE
 
 # default plugins installed with the libogre14 package
 Plugin=RenderSystem_GL.so

Modified: rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -40,7 +40,9 @@
         layout.addWidget(self.modulConfigSelector, 1, 1)
 
         self.setLayout(layout)
-
+        
+        self.moduleCfgPath = None
+        
         QObject.connect(self.modulConfigSelector, SIGNAL(&quot;clicked()&quot;),
                                self.openModulConfigSelector)
 
@@ -70,7 +72,6 @@
             self.lineEdit.setText(self.moduleCfgPath)
 
 
-
     def onLoadSelectedModule(self):
         item = self.prefDialog.listWidget.currentItem()
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -26,7 +26,7 @@
 #########################################################################
 ### Override this setting if you are using non standard locations
 
-libpath = &quot;/home/stefan/development/root/usr/lib/&quot;
+libpath = &quot;/home/fusion/development/root/usr/lib/&quot;
 
 #########################################################################
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,5 +1,6 @@
 import ctypes as ctypes
 import random
+import platform
 
 import ogre.renderer.OGRE as og
 
@@ -36,22 +37,28 @@
       
         self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
         self.currentColorAsVector3 = og.Vector3()
-        
+
         self.lastEntity = &quot;&quot;
         self.lastTechnique = None
+ 
+
+        if platform.system() == &quot;Windows&quot;:
+            self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColor&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+        else:
+            self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColorGLSL&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
         
         self.colorDict = {}
        
     # takes into account that one Entity can have multiple SubEntities
     def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+
         temp = str(type(subEntity))
         if temp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.SubEntity'&gt;&quot;:
             if self.lastEntity == subEntity.getParent().getName():
                 subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                #print str(subEntity.getParent().getRenderQueueGroup())
                 return self.lastTechnique
             else:
-                self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColor&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-                
                 self.randomizeColor()
                 subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
                 
@@ -122,7 +129,7 @@
         self.renderTexture.addListener( self.selectionTargetListener )
         self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
         
-        #self.createRTTOverlays()
+#        self.createRTTOverlays()
 
     def update(self):
         self.updateBufferSize()
@@ -206,11 +213,12 @@
                     so = SelectionObject(self.sceneMgr.getEntity(key))
                     so.isPivot = True
                     return so
-                elif key == &quot;EditorFreeMover&quot;:
-                    return None
                 elif key == &quot;EditorXRotator&quot; or key == &quot;EditorYRotator&quot; or key == &quot;EditorZRotator&quot;:
                     so = SelectionObject(self.sceneMgr.getEntity(key))
                     so.isPivot = True
+                elif key == &quot;EditorXScaler&quot; or key == &quot;EditorYScaler&quot; or key == &quot;EditorZScaler&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
                     return so
                 else:
                     so = SelectionObject(self.sceneMgr.getEntity(key))

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-03-03 19:45:40 UTC (rev 4787)
@@ -19,8 +19,6 @@
 
 		pass
 		{
-			lighting off
-
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -48,7 +46,7 @@
 	technique
 	{
 		pass
-		{
+		{	
 			ambient 0.0 0.0 0.0 0.5
 			diffuse 0.0 0.0 0.0 0.5
 			specular 0.0 0.0 0.0 0.5 12.5
@@ -141,3 +139,35 @@
 		}
 	}
 }
+
+vertex_program PlainColorGLSL_VP glsl
+{
+	source PlainColorVP.glsl
+}
+
+fragment_program PlainColorGLSL_FP glsl
+{
+	source PlainColorFP.glsl
+	
+	default_params
+	{
+	      param_named_auto inColor custom 1
+	}
+}
+
+material PlainColorGLSL glsl
+{
+	technique
+	{
+		pass
+		{
+			vertex_program_ref PlainColorGLSL_VP	
+			{
+			}
+			
+			fragment_program_ref PlainColorGLSL_FP
+			{
+			}
+		}
+	}
+}

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColor.cg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColor.cg	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColor.cg	2009-03-03 19:45:40 UTC (rev 4787)
@@ -25,8 +25,5 @@
 		uniform float4 inColor
 		)
 {	 
-	// Just sample texture using supplied UV
-	//color = float4(0, 1, 0, 1);
-	//color = float4(inColor.r, inColor.g, inColor.b, 1);
 	color = inColor;
 }

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorFP.glsl (from rev 4779, rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl (from rev 4779, rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/UniCube.mesh
===================================================================
(Binary files differ)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/colors.png (from rev 4784, rl/trunk/editors/Lockenwickler/src/media/icons/colors.png)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/fileopen.png (from rev 4780, rl/trunk/editors/Lockenwickler/src/media/icons/fileopen.png)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/pivots.blend
===================================================================
(Binary files differ)

Modified: rl/branches/persistence2/engine/ai/include/Dialog.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/Dialog.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/Dialog.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,27 +22,23 @@
 
 namespace rl
 {
+    class Creature;
     class DialogOption;
     class DialogResponse;
     class DialogVariable;
-    class Creature;
 
     class _RlAiExport Dialog : public PropertyHolder
     {
     public:
 		static const Ogre::String PROP_EXIT_REQUESTED;
 
-        Dialog(const std::vector&lt;Creature*&gt;&amp; pc, const std::vector&lt;Creature*&gt;&amp; npc);
+        Dialog();
         ~Dialog();
 
         DialogResponse* getDialogStart() const;
         void setStartResponse(DialogResponse* start);
         void addVariable(DialogVariable* variable);
         void initialize();
-        Creature* getNpc(int id) const;
-        Creature* getPc(int id) const;
-        std::vector&lt;Creature*&gt; getNonPlayerCharacters() const;
-        std::vector&lt;Creature*&gt; getPlayerCharacters() const;
 		bool isExitRequested() const;
         CeGuiString getVariableValue(const Ogre::String&amp; variableName) const;
 
@@ -50,10 +46,14 @@
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
         virtual PropertyKeys getAllPropertyKeys() const;
 
+        void addParticipant(const CeGuiString&amp; personId, Creature* person);
+        std::list&lt;Creature*&gt; getParticipants() const;
+        Creature* getParticipant(const CeGuiString&amp; id) const;
+
     private:
         DialogResponse* mDialogStart;
-        std::vector&lt;Creature*&gt; mNonPlayerCharacters;
-        std::vector&lt;Creature*&gt; mPlayerCharacters;
+        std::list&lt;Creature*&gt; mAllParticipants;
+        std::map&lt;CeGuiString, Creature*&gt; mParticipantMap;
         std::map&lt;Ogre::String, DialogVariable*&gt; mVariables;
         PropertyRecord mPropertyVariables;
 		bool mExitRequested;

Modified: rl/branches/persistence2/engine/ai/include/DialogElement.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogElement.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/DialogElement.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -33,13 +33,17 @@
         void addParagraph(DialogParagraph* paragraph);
         virtual std::list&lt;DialogParagraph*&gt; getParagraphs(Dialog* dialog);
 		virtual bool isSelection() const;
+		const CeGuiString&amp; getPerson() const;
 
     protected:
-        DialogElement(const CeGuiString&amp; id);
+        DialogElement(const CeGuiString&amp; id, const CeGuiString&amp; person = &quot;&quot;);
         virtual ~DialogElement();
 
+        virtual const CeGuiString&amp; getDefaultPerson() const = 0;
+
     private:
         CeGuiString mId;
+        CeGuiString mPerson;
         std::list&lt;DialogParagraph*&gt; mParagraphs;
     };
 
@@ -66,10 +70,10 @@
         {
             return (mVariable != NULL);
         }
-            
+
         virtual const CeGuiString&amp; getConditionVariableType()
         {
-            RlAssert(mVariable, CeGuiString(&quot;No variable found for option with id: &quot; + DialogElementType::getId()).c_str()); 
+            RlAssert(mVariable, CeGuiString(&quot;No variable found for option with id: &quot; + DialogElementType::getId()).c_str());
             return mVariable-&gt;getType();
         }
 

Modified: rl/branches/persistence2/engine/ai/include/DialogLoader.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogLoader.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/DialogLoader.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,7 +18,9 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
-namespace rl 
+#include &lt;list&gt;
+
+namespace rl
 {
 	class Creature;
     class Dialog;
@@ -29,14 +31,14 @@
 	public:
 		DialogLoader();
 		~DialogLoader();
-	
+
 		virtual const Ogre::StringVector&amp; getScriptPatterns() const;
         virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
 		virtual Ogre::Real getLoadingOrder() const;
-		
-		Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const;
 
-	private: 
+		Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const;
+
+	private:
         Ogre::StringVector mScriptPatterns;
         DialogLoaderImpl* mLoaderImplementation;
     };

Modified: rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -9,6 +9,8 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
+#include &lt;list&gt;
+
 #include &quot;Properties.h&quot;
 #include &quot;XmlProcessor.h&quot;
 
@@ -24,17 +26,33 @@
     class DialogResponse;
     class DialogVariable;
 	class Property;
-    
+
     class DialogLoaderImpl : private XmlProcessor
     {
     public:
         DialogLoaderImpl();
         ~DialogLoaderImpl();
-        
-        Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const;
+
+        Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const;
         void parseDialog(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
 
     private:
+        class DialogParticipant
+        {
+        public:
+            DialogParticipant(const CeGuiString&amp; personId,
+                    int goId, const CeGuiString&amp; goClass, const CeGuiString&amp; name);
+
+            bool isMatching(Creature* go) const;
+            const CeGuiString&amp; getPersonId() const;
+
+        private:
+            const CeGuiString&amp; mPersonId;
+            int mGoId;
+            const CeGuiString&amp; mGoClass;
+            const CeGuiString&amp; mName;
+        };
+
         class DialogPrototype
         {
         public:
@@ -44,14 +62,17 @@
             DialogOption* getOption(const CeGuiString&amp; id) const;
             void addResponse(DialogResponse* option);
             DialogResponse* getResponse(const CeGuiString&amp; id) const;
-            
+
             void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
+            Dialog* createDialog(const std::list&lt;Creature*&gt;&amp; participants);
             void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-            
+
+            void addParticipant(DialogParticipant* participant);
+
         private:
             std::map&lt;CeGuiString, DialogOption*&gt; mOptionCache;
             std::map&lt;CeGuiString, DialogResponse*&gt; mResponseCache;
+            std::list&lt;DialogParticipant*&gt; mParticipantFilter;
             DialogResponse* mDialogStart;
             PropertyRecord mPropertyVariables;
         };
@@ -69,6 +90,7 @@
         DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
         DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
         DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
+        DialogParticipant* processPerson(XERCES_CPP_NAMESPACE::DOMElement* personXml);
         void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
         void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
         void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
@@ -77,4 +99,3 @@
 
     };
 }
-

Modified: rl/branches/persistence2/engine/ai/include/DialogManager.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogManager.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/DialogManager.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,6 +18,8 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
+#include &lt;list&gt;
+
 #include &quot;Properties.h&quot;
 #include &quot;SaveGameData.h&quot;
 #include &quot;XmlProcessor.h&quot;
@@ -28,8 +30,8 @@
 	class Dialog;
 	class DialogLoader;
 
-    class _RlAiExport DialogManager 
-        : public Ogre::Singleton&lt;DialogManager&gt;, 
+    class _RlAiExport DialogManager
+        : public Ogre::Singleton&lt;DialogManager&gt;,
         public PropertyHolder,
         public SaveGameData
     {
@@ -42,8 +44,8 @@
         DialogManager();
         ~DialogManager();
 
-        Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc, rl::Creature* pc);
-        Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
+        Dialog* createDialog(const Ogre::String&amp; name, Creature* npc);
+        Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; npcs);
 
         virtual const Property getProperty(const CeGuiString&amp; key) const;
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
@@ -54,20 +56,20 @@
         virtual int getPriority() const;
 
     private:
- 
+
         class DialogConfiguration
         {
         public:
-            DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs);
+            DialogConfiguration(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants);
 
             const Ogre::String&amp; getName() const;
-            const std::vector&lt;Creature*&gt;&amp; getNpcs() const;
-            
+            const std::list&lt;Creature*&gt;&amp; getParticipants() const;
+
             bool operator==(const DialogConfiguration&amp;) const;
             bool operator&lt;(const DialogConfiguration&amp;) const;
         private:
             Ogre::String mDialogName;
-            std::vector&lt;Creature*&gt; mNpcs;
+            std::list&lt;Creature*&gt; mParticipants;
         };
 
 

Modified: rl/branches/persistence2/engine/ai/include/DialogOption.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogOption.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/DialogOption.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -36,14 +36,12 @@
         DialogOption(const CeGuiString&amp; id, bool isAutoSelected);
         ~DialogOption();
 
-
         const CeGuiString&amp; getLabel() const;
         void setLabel(const CeGuiString&amp; label);
 
+        DialogResponse* getResponse() const;
         void setResponse(DialogResponse* response);
-        DialogResponse* getResponse() const;
 
-
         void setPrecondition(DialogCondition* precondition);
         virtual const CeGuiString&amp; getConditionVariableType();
         virtual bool isConditional();
@@ -51,13 +49,16 @@
         bool isAutoSelected() const;
         bool isAvailable(Dialog* dialog) const;
 
+    protected:
+        virtual const CeGuiString&amp; getDefaultPerson() const;
+
     private:
         DialogResponse* mResponse;
         DialogCondition* mPrecondition;
         CeGuiString mLabel;
         bool mIsAutoSelected;
     };
-    
+
     typedef DialogSelection&lt;DialogOption&gt; DialogOptionSelection;
 }
 

Modified: rl/branches/persistence2/engine/ai/include/DialogParagraph.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogParagraph.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/DialogParagraph.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -21,21 +21,31 @@
 
 namespace rl
 {
+    class Creature;
+    class Dialog;
+    class DialogElement;
     class DialogResponse;
 
     class _RlAiExport DialogParagraph
     {
     public:
-        DialogParagraph(const CeGuiString&amp; text, const Ogre::String&amp; voicefile = &quot;&quot;);
+        DialogParagraph(const CeGuiString&amp; text, const CeGuiString&amp; person = &quot;&quot;, const Ogre::String&amp; voicefile = &quot;&quot;);
         virtual ~DialogParagraph();
 
         const CeGuiString&amp; getText() const;
+        const CeGuiString&amp; getPerson() const;
         const Ogre::String&amp; getVoiceFile() const;
+        DialogElement* getParent() const;
+        void _setParent(DialogElement* parent);
         virtual DialogResponse* getResponse() const;
+        Creature* getSpeaker(Dialog* dialog) const;
+        std::list&lt;Creature*&gt; getListeners(Dialog* dialog) const;
 
     private:
         CeGuiString mText;
+        CeGuiString mPerson;
         Ogre::String mVoiceFile;
+        DialogElement* mParent;
     };
 
     class _RlAiExport DialogGotoResponse : public DialogParagraph

Modified: rl/branches/persistence2/engine/ai/include/DialogResponse.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogResponse.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/include/DialogResponse.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -24,11 +24,11 @@
 {
     class Dialog;
     class DialogImplication;
-	class DialogOption;   
+	class DialogOption;
     class Creature;
 
     /**
-     * The reponse a DialogCharacter can give in a Dialog
+     * The response a DialogCharacter can give in a Dialog
      */
     class _RlAiExport DialogResponse : public DialogElement
     {
@@ -39,7 +39,6 @@
         DialogResponse(const CeGuiString&amp; id, int npcId = 0);
         virtual ~DialogResponse();
 
-
         void addOption(DialogOption* option);
         void addImplication(DialogImplication* effect);
         virtual const Options&amp; getOptions(Dialog* dialog) const;
@@ -47,14 +46,15 @@
 
         void applyImplications(Dialog* dialog);
 
-        Creature* getNpc(Dialog* dialog) const;
+    protected:
+        virtual const CeGuiString&amp; getDefaultPerson() const;
 
     private:
         Options mOptions;
         Implications mEffects;
         int mNpcId;
     };
-    
+
     class DialogResponseSelection : public DialogSelection&lt;DialogResponse&gt;
     {
     public:

Modified: rl/branches/persistence2/engine/ai/src/Dialog.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/Dialog.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/Dialog.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,14 +18,14 @@
 #include &quot;Dialog.h&quot;
 #include &quot;DialogResponse.h&quot;
 
+using namespace std;
+
 namespace rl
 {
 	const Ogre::String Dialog::PROP_EXIT_REQUESTED = &quot;exit_requested&quot;;
 
-    Dialog::Dialog(const std::vector&lt;Creature*&gt;&amp; npc, const std::vector&lt;Creature*&gt;&amp; pc)
+    Dialog::Dialog()
     {
-        mNonPlayerCharacters = npc;
-        mPlayerCharacters = pc;
     }
 
     Dialog::~Dialog()
@@ -52,16 +52,6 @@
         //mVariables[vkey] = variable;
     }
 
-    Creature* Dialog::getNpc(int id) const
-    {
-        return mNonPlayerCharacters[id];
-    }
-
-    Creature* Dialog::getPc(int id) const
-    {
-        return mPlayerCharacters[id];
-    }
-
     const Property Dialog::getProperty(const CeGuiString&amp; key) const
     {
         ///@todo dialog's state
@@ -104,14 +94,27 @@
         return getProperty(key).getAsString();
     }
 
-    std::vector&lt;Creature*&gt; Dialog::getNonPlayerCharacters() const
+    void Dialog::addParticipant(const CeGuiString&amp; personId, Creature* person)
     {
-        return mNonPlayerCharacters;
+        mParticipantMap[personId] = person;
+        mAllParticipants.push_back(person);
     }
 
-    std::vector&lt;Creature*&gt; Dialog::getPlayerCharacters() const
+    list&lt;Creature*&gt; Dialog::getParticipants() const
     {
-        return mPlayerCharacters;
+        return mAllParticipants;
     }
 
+    Creature* Dialog::getParticipant(const CeGuiString&amp; personId) const
+    {
+        map&lt;CeGuiString, Creature*&gt;::const_iterator it = mParticipantMap.find(personId);
+
+        if (it == mParticipantMap.end())
+        {
+            LOG_ERROR(&quot;Dialog&quot;, &quot;Could not find participant with ID '&quot; + personId + &quot;'&quot;);
+            return NULL;
+        }
+
+        return it-&gt;second;
+    }
 }

Modified: rl/branches/persistence2/engine/ai/src/DialogElement.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogElement.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogElement.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -22,8 +22,8 @@
 
 namespace rl
 {
-    DialogElement::DialogElement(const CeGuiString&amp; id)
-        : mId(id)
+    DialogElement::DialogElement(const CeGuiString&amp; id, const CeGuiString&amp; person)
+        : mId(id), mPerson(person)
     {
     }
 
@@ -41,9 +41,20 @@
         return mId;
     }
 
+    const CeGuiString&amp; DialogElement::getPerson() const
+    {
+        if (mPerson.empty())
+        {
+            return getDefaultPerson();
+        }
+
+        return mPerson;
+    }
+
     void DialogElement::addParagraph(DialogParagraph* paragraph)
     {
         mParagraphs.push_back(paragraph);
+        paragraph-&gt;_setParent(this);
     }
 
     std::list&lt;DialogParagraph*&gt; DialogElement::getParagraphs(Dialog* dialog)
@@ -55,5 +66,4 @@
 	{
 		return false;
 	}
-
 }

Modified: rl/branches/persistence2/engine/ai/src/DialogImplication.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogImplication.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogImplication.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -37,7 +37,7 @@
     {
     }
 
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName, 
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName,
                                                        const CeGuiString&amp; value)
         : mVariableName(variableName), mValue(value)
     {
@@ -50,7 +50,7 @@
         dialog-&gt;setProperty(mVariableName, prop);
     }
 
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName, 
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName,
                                                    const CeGuiString&amp; value)
         : DialogVariableAssignment(variableName, value)
     {
@@ -69,13 +69,13 @@
         }
         else
         {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot; 
+            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot;
                                       + mVariableName
                                       + &quot;'. The variable's type is not a number&quot;);
         }
     }
 
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName, 
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName,
                                                    const CeGuiString&amp; value)
         : DialogVariableAssignment(variableName, value)
     {
@@ -94,13 +94,13 @@
         }
         else
         {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot; 
+            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot;
                                       + mVariableName
                                       + &quot;'. The variable's type is not a number&quot;);
         }
     }
 
-    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id, 
+    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id,
                                                      bool value,
                                                      bool isOption)
         : mElementId(id), mValue(value), mIsOption(isOption)
@@ -135,24 +135,25 @@
         Quest* quest = RulesSubsystem::getSingleton().getQuestBook()-&gt;getQuest(mQuestId);
         quest-&gt;setPropertyAsString(mProperty, mNewValue);
     }
-    
+
     CombatStart::CombatStart()
     {
     }
-    
+
     void CombatStart::apply(Dialog* dialog)
     {
         Combat* combat = CombatManager::getSingleton().startCombat();
-        std::vector&lt;Creature*&gt; allies = dialog-&gt;getPlayerCharacters();
+        ///@FIXME: fix starting combat from dialog
+/*        std::vector&lt;Creature*&gt; allies = dialog-&gt;getPlayerCharacters();
         for (std::vector&lt;Creature*&gt;::iterator it = allies.begin(); it != allies.end(); ++it)
         {
-            combat-&gt;addAlly(*it);            
+            combat-&gt;addAlly(*it);
         }
         std::vector&lt;Creature*&gt; enemies = dialog-&gt;getNonPlayerCharacters();
         for (std::vector&lt;Creature*&gt;::iterator it = enemies.begin(); it != enemies.end(); ++it)
         {
             combat-&gt;addOpponent(*it);
-        }
+        }*/
         combat-&gt;start();
     }
 

Modified: rl/branches/persistence2/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogLoader.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogLoader.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -29,30 +29,30 @@
         mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back(&quot;*.dialog&quot;);
   	}
-	
+
     DialogLoader::~DialogLoader()
     {
         delete mLoaderImplementation;
 	}
- 
+
     const StringVector&amp; DialogLoader::getScriptPatterns() const
     {
         return mScriptPatterns;
     }
-    
+
 	Ogre::Real DialogLoader::getLoadingOrder() const
     {
         return 1000;
     }
-    
+
     void DialogLoader::parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
     {
         mLoaderImplementation-&gt;parseDialog(stream, groupName);
     }
-    
-    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const
+
+    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const
     {
-        return mLoaderImplementation-&gt;createDialog(name, pcs, npcs);
+        return mLoaderImplementation-&gt;createDialog(name, participants);
     }
 
 }

Modified: rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -13,6 +13,7 @@
 #include &quot;DialogLoaderImpl.h&quot;
 
 #include &quot;ConfigurationManager.h&quot;
+#include &quot;Creature.h&quot;
 #include &quot;Dialog.h&quot;
 #include &quot;DialogCondition.h&quot;
 #include &quot;DialogElement.h&quot;
@@ -21,9 +22,11 @@
 #include &quot;DialogParagraph.h&quot;
 #include &quot;DialogResponse.h&quot;
 #include &quot;DialogVariable.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;XmlPropertyReader.h&quot;
 
 using namespace Ogre;
+using namespace std;
 using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
@@ -32,51 +35,50 @@
     : XmlProcessor()
     {
     }
-    
+
     DialogLoaderImpl::~DialogLoaderImpl()
     {
 		std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator itr = mDialogs.begin();
         std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
+        for (; itr != end; ++itr)
         {
 			DialogPrototype* p = itr-&gt;second;
 			delete p;
 		}
         mDialogs.clear();
 	}
-    
 
+
     void DialogLoaderImpl::parseDialog(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
     {
         initializeXml();
-        
+
         DOMDocument* doc = loadDocument(stream);
         if (doc)
         {
             DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
-            
+
             for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
             {
                 DOMNode* cur = dialogNodes-&gt;item(i);
                 processDialog(static_cast&lt;DOMElement*&gt;(cur));
             }
         }
-        
+
         shutdownXml();
     }
 
-    Dialog* DialogLoaderImpl::createDialog(const String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, 
-                                       const std::vector&lt;Creature*&gt;&amp; npcs) const
+    Dialog* DialogLoaderImpl::createDialog(const String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const
     {
         std::map&lt;Ogre::String, DialogPrototype*&gt;::const_iterator it =
         mDialogs.find(name);
-        
+
         if (it == mDialogs.end())
         {
             return NULL;
         }
-        
-        return it-&gt;second-&gt;createDialog(pcs, npcs);
+
+        return it-&gt;second-&gt;createDialog(participants);
     }
 
     void DialogLoaderImpl::processDialog(DOMElement* dialogElem)
@@ -84,13 +86,13 @@
         DialogPrototype* dialogPrototype = new DialogPrototype();
         Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
         mDialogs[name] = dialogPrototype;
-        
+
         // first step: process all possible references
         processElementNodes(dialogElem, &quot;option&quot;, dialogPrototype);
         processElementNodes(dialogElem, &quot;switchoption&quot;, dialogPrototype);
         processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
         processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
-        
+
         for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
         {
             if (hasNodeName(curChild, &quot;variable&quot;))
@@ -115,16 +117,27 @@
             }
             else if (hasNodeName(curChild, &quot;start&quot;))
             {
-                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL; 
+                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL;
                      curChildChild = curChildChild-&gt;getNextSibling())
                 {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
+                    DialogResponse* response = processResponseClasses(curChildChild, dialogPrototype);
                     if (response)
                     {
                         dialogPrototype-&gt;setStartResponse(response);
                     }
                 }
             }
+            else if (hasNodeName(curChild, &quot;persons&quot;))
+            {
+                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL;
+                                     curChildChild = curChildChild-&gt;getNextSibling())
+                {
+                    if (hasNodeName(curChildChild, &quot;person&quot;))
+                    {
+                        dialogPrototype-&gt;addParticipant(processPerson(static_cast&lt;DOMElement*&gt;(curChildChild)));
+                    }
+                }
+            }
         }
         LOG_MESSAGE(Logger::AI, &quot;Processed Dialog &quot;+ name);
     }
@@ -141,7 +154,7 @@
             }
             CeGuiString id = getAttributeValueAsString(dialogElemXml, &quot;id&quot;);
             CeGuiString text = getValueAsString(dialogElemXml);
-            
+
             if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
             {
                 DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
@@ -171,7 +184,7 @@
                 dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
             }
         }
-        
+
     }
 
     DialogResponse* DialogLoaderImpl::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
@@ -195,17 +208,17 @@
     DialogResponse* DialogLoaderImpl::processResponse(DOMElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(responseXml, &quot;id&quot;);
-        
+
         DialogResponse* response = dialogPrototype-&gt;getResponse(id);
-        
+
         if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No response with ID &quot;+ id).c_str());
-        
+
         bool languageDefined = false;
         DOMElement* defaultLanguage = NULL;
         if (subelements)
         {
             bool paragraphsDefined = false;
-            
+
             for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
             {
                 DialogOption* option = processOptionClasses(cur, dialogPrototype);
@@ -214,14 +227,14 @@
                     response-&gt;addOption(option);
                     continue;
                 }
-                
+
                 DialogImplication* implication = processImplicationClasses(cur);
                 if (implication)
                 {
                     response-&gt;addImplication(implication);
                     continue;
                 }
-                
+
                 if (hasNodeName(cur, &quot;p&quot;))
                 {
                     response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
@@ -232,14 +245,14 @@
                 {
                     DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
                     // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;)
                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
                     {
                         processTranslation(response, translation);
                         languageDefined = true;
                     }
                     // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
                     {
                         defaultLanguage = translation;
                     }
@@ -251,22 +264,22 @@
                     response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
                 }
             }
-            
+
             if (!paragraphsDefined)
             {
                 CeGuiString responseXmlText = getValueAsString(responseXml);
                 response-&gt;addParagraph(new DialogParagraph(responseXmlText));
             }
-        }            
+        }
         // use german as the default language if german is not set as
         // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
+        if (!languageDefined &amp;&amp; defaultLanguage != NULL
            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
         {
             processTranslation(response, defaultLanguage);
             languageDefined = true;
         }
-        
+
         return response;
     }
 
@@ -274,9 +287,9 @@
     {
         CeGuiString id = getAttributeValueAsString(switchRespXml, &quot;id&quot;);
         DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
-        
+
         if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No switchresponse with ID &quot;+ id).c_str());
-        
+
         for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
@@ -295,11 +308,11 @@
                         response-&gt;addElement(condition, responseCase);
                         break;
                     }
-                }               
+                }
             }
         }
-        
-        
+
+
         return response;
     }
 
@@ -324,18 +337,18 @@
     DialogOption* DialogLoaderImpl::processOption(DOMElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(optionXml, &quot;id&quot;);
-        
+
         DialogOption* option = dialogPrototype-&gt;getOption(id);
-        
+
         if (!option)    Throw(IllegalArgumentException, CeGuiString(&quot;No option with ID &quot;+ id).c_str());
-        
+
         bool languageDefined = false;
         DOMElement* defaultLanguage = NULL;
-        
+
         if (subelements)
         {
             bool paragraphsDefined = false;
-            
+
             for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
             {
                 DialogResponse* response = processResponseClasses(cur, dialogPrototype);
@@ -356,28 +369,28 @@
                 else if (hasNodeName(cur, &quot;t&quot;))
                 {
                     DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
+                    // check locale
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;)
                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
                     {
                         defaultLanguage = translation;
                         processTranslation(option, translation);
                         std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                        if(!label.empty())
+                        if (!label.empty())
                         {
                             option-&gt;setLabel(label);
                         }
                         languageDefined = true;
                     }
                     // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
                     {
                         defaultLanguage = translation;
                     }
                     paragraphsDefined = true;
                 }
             }
-            
+
             if (!paragraphsDefined)
             {
                 CeGuiString optionXmlText = getValueAsString(optionXml);
@@ -386,18 +399,18 @@
         }
         // use german as the default language if german is not set as
         // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
+        if (!languageDefined &amp;&amp; defaultLanguage != NULL
            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
         {
             processTranslation(option, defaultLanguage);
             std::string label = getAttributeValueAsStdString(defaultLanguage, &quot;label&quot;);
-            if(!label.empty())
+            if (!label.empty())
             {
                 option-&gt;setLabel(label);
             }
             languageDefined = true;
         }
-        
+
         return option;
     }
 
@@ -405,9 +418,9 @@
     {
         CeGuiString id = getAttributeValueAsString(switchOptXml, &quot;id&quot;);
         DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
-        
+
         if (!option) Throw(IllegalArgumentException, CeGuiString(&quot;No switchoption with ID &quot;+ id).c_str());
-        
+
         for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
@@ -426,25 +439,25 @@
                         option-&gt;addElement(condition, optionCase);
                         break;
                     }
-                }               
+                }
             }
             // process translations
             else if (hasNodeName(cur, &quot;t&quot;))
             {
                 DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
                 // check loca
-                if(getAttributeValueAsStdString(translation, &quot;language&quot;) == 
+                if (getAttributeValueAsStdString(translation, &quot;language&quot;) ==
                    ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
                 {
                     std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                    if(!label.empty())
+                    if (!label.empty())
                     {
                         option-&gt;setLabel(label);
                     }
-                } 
+                }
             }
         }
-        
+
         return option;
     }
 
@@ -459,19 +472,19 @@
     {
         DialogCondition* cond = NULL;
         DialogVariable* var = NULL;
-        
+
         for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
             {
                 DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
-                
+
                 DialogCondition* curCond = processConditionClasses(curElem);
                 if (curCond)
                 {
                     cond = curCond;
                 }
-                
+
                 DialogVariable* curVar = processVariableClasses(curElem);
                 if (curVar)
                 {
@@ -479,7 +492,7 @@
                 }
             }
         }
-        
+
         cond-&gt;setVariable(var);
         return cond;
     }
@@ -497,7 +510,7 @@
     DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
     {
         DialogCondition* cond = NULL;
-        
+
         for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
@@ -509,7 +522,7 @@
                 }
             }
         }
-        
+
         return cond;
     }
 
@@ -520,13 +533,13 @@
     DialogLoaderImpl::DialogPrototype::~DialogPrototype()
     {
         std::map&lt;CeGuiString, DialogOption*&gt;::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it-&gt;second != NULL )
+        for (it = mOptionCache.begin(); it != mOptionCache.end(); it++)
+            if (it-&gt;second != NULL)
                 delete it-&gt;second;
-        
+
         std::map&lt;CeGuiString, DialogResponse*&gt;::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1-&gt;second != NULL )
+        for (it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++)
+            if (it1-&gt;second != NULL)
                 delete it1-&gt;second;
     }
 
@@ -534,7 +547,7 @@
     {
         if (mOptionCache.find(option-&gt;getId()) != mOptionCache.end())
         {
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
                   CeGuiString(&quot;Duplicate option/switchoption ID &quot;+ option-&gt;getId()).c_str());
         }
         mOptionCache[option-&gt;getId()] = option;
@@ -554,7 +567,7 @@
     {
         if (mResponseCache.find(response-&gt;getId()) != mResponseCache.end())
         {
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
                   CeGuiString(&quot;Duplicate Response/switchResponse ID &quot;+ response-&gt;getId()).c_str());
         }
         mResponseCache[response-&gt;getId()] = response;
@@ -570,17 +583,58 @@
         return it-&gt;second;
     }
 
-    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
+    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const list&lt;Creature*&gt;&amp; participants)
     {
-        Dialog* dialog = new Dialog(pcs, npcs);
+        Dialog* dialog = new Dialog();
+
+        // for easy 1pc-1nsc dialogs (active player is &quot;player&quot;, one NSC is &quot;nsc&quot;)
+        Creature* player = PartyManager::getSingleton().getActiveCharacter();
+        dialog-&gt;addParticipant(&quot;player&quot;, player);
+
+        bool found1stNpc = false;
+        Party playerChars = PartyManager::getSingleton().getCharacters();
+
+        for (list&lt;Creature*&gt;::const_iterator itPart = participants.begin(); itPart != participants.end(); ++itPart)
+        {
+            Creature* curCr = *itPart;
+
+            if (!found1stNpc)
+            {
+                bool isInParty = false;
+                for (Party::iterator itParty = playerChars.begin(); itParty != playerChars.end(); ++itParty)
+                {
+                    if (*itParty == curCr)
+                    {
+                        isInParty = true;
+                        break;
+                    }
+                }
+
+                if (!isInParty)
+                {
+                    dialog-&gt;addParticipant(&quot;nsc&quot;, curCr);
+                    found1stNpc = true;
+                }
+            }
+
+
+            for (list&lt;DialogLoaderImpl::DialogParticipant*&gt;::iterator it = mParticipantFilter.begin();
+                    it != mParticipantFilter.end(); ++it)
+            {
+                if ((*it)-&gt;isMatching(curCr))
+                {
+                    dialog-&gt;addParticipant((*it)-&gt;getPersonId(), curCr);
+                }
+            }
+        }
         dialog-&gt;setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
+
+        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin();
              it != mPropertyVariables.end(); ++it)
         {
             dialog-&gt;setProperty(it-&gt;first, it-&gt;second);
         }
-        
+
         return dialog;
     }
 
@@ -594,7 +648,29 @@
         mDialogStart = start;
     }
 
+    void DialogLoaderImpl::DialogPrototype::addParticipant(DialogLoaderImpl::DialogParticipant* participant)
+    {
+        mParticipantFilter.push_back(participant);
+    }
 
+    DialogLoaderImpl::DialogParticipant::DialogParticipant(const CeGuiString&amp; personId, int goId,
+            const CeGuiString&amp; goClass, const CeGuiString&amp; name)
+        : mPersonId(personId), mGoId(goId), mGoClass(goClass), mName(name)
+    {
+    }
+
+    const CeGuiString&amp; DialogLoaderImpl::DialogParticipant::getPersonId() const
+    {
+        return mPersonId;
+    }
+
+    bool DialogLoaderImpl::DialogParticipant::isMatching(Creature* creature) const
+    {
+        return (mGoId == -1 || creature-&gt;getId() == mGoId)
+            &amp;&amp; (mGoClass.empty() || creature-&gt;getClassId() == mGoClass)
+            &amp;&amp; (mName.empty() || creature-&gt;getName() == mName);
+    }
+
     DialogCondition* DialogLoaderImpl::processConditionClasses(DOMElement* conditionXml)
     {
         if (hasNodeName(conditionXml, &quot;equals&quot;))
@@ -628,7 +704,7 @@
             return new DialogConditionGreaterOrEquals(
                                                       getAttributeValueAsReal(conditionXml, &quot;value&quot;));
         }
-        
+
         return NULL;
     }
 
@@ -671,7 +747,7 @@
             int maximum = getAttributeValueAsInteger(variableXml, &quot;maximum&quot;);
             return new RandomVariable(maximum);
         }
-        
+
         return NULL;
     }
 
@@ -681,7 +757,7 @@
         if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
         {
             DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
-            
+
             if (hasNodeName(implicationElem, &quot;setvariable&quot;))
             {
                 Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
@@ -722,7 +798,7 @@
                 return new CombatStart();
             }
         }
-        
+
         return NULL;
     }
 
@@ -736,6 +812,36 @@
             }
         }
     }
-    
+
+    DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(DOMElement* personXml)
+    {
+        CeGuiString personId(&quot;&quot;), goClass(&quot;&quot;), name(&quot;&quot;);
+        int goId = -1;
+
+        if (hasAttribute(personXml, &quot;id&quot;))
+        {
+            personId = getAttributeValueAsString(personXml, &quot;id&quot;);
+        }
+        else
+        {
+            LOG_ERROR(&quot;DialogLoader&quot;, &quot;person node without id found&quot;);
+        }
+
+        if (hasAttribute(personXml, &quot;goId&quot;))
+        {
+            goId = getAttributeValueAsInteger(personXml, &quot;goId&quot;);
+        }
+        if (hasAttribute(personXml, &quot;goClass&quot;))
+        {
+            goClass = getAttributeValueAsString(personXml, &quot;goClass&quot;);
+        }
+        if (hasAttribute(personXml, &quot;name&quot;))
+        {
+            name = getAttributeValueAsString(personXml, &quot;name&quot;);
+        }
+
+        return new DialogParticipant(personId, goId, goClass, name);
+    }
+
 }
 

Modified: rl/branches/persistence2/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogManager.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogManager.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,9 +22,11 @@
 #include &quot;Dialog.h&quot;
 #include &quot;DialogLoader.h&quot;
 #include &quot;GameObjectManager.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;SaveGameManager.h&quot;
 
 using namespace Ogre;
+using namespace std;
 using namespace XERCES_CPP_NAMESPACE;
 
 template&lt;&gt;
@@ -51,8 +53,8 @@
 			mDialogLoader);
 		delete mDialogLoader;
         SaveGameManager::getSingleton().unregisterSaveGameData(this);
-		std::map&lt;DialogConfiguration, Dialog*&gt;::iterator itr = mDialogStates.begin();
-		std::map&lt;DialogConfiguration, Dialog*&gt;::iterator end = mDialogStates.end();
+		map&lt;DialogConfiguration, Dialog*&gt;::iterator itr = mDialogStates.begin();
+		map&lt;DialogConfiguration, Dialog*&gt;::iterator end = mDialogStates.end();
 		for(; itr != end; ++itr)
 		{
 			delete itr-&gt;second;
@@ -66,7 +68,7 @@
         if (key == DialogManager::PROPERTY_DIALOGS)
         {
             PropertyArray vec;
-            for (std::map&lt;DialogConfiguration, Dialog*&gt;::const_iterator it
+            for (map&lt;DialogConfiguration, Dialog*&gt;::const_iterator it
                 = mDialogStates.begin(); it != mDialogStates.end(); ++it)
             {
                 PropertyMap curDialogProp;
@@ -76,8 +78,8 @@
 
                 PropertyArray npcs;
 
-                for (std::vector&lt;Creature*&gt;::const_iterator itNpc = it-&gt;first.getNpcs().begin();
-                    itNpc != it-&gt;first.getNpcs().end(); ++itNpc)
+                for (list&lt;Creature*&gt;::const_iterator itNpc = it-&gt;first.getParticipants().begin();
+                    itNpc != it-&gt;first.getParticipants().end(); ++itNpc)
                 {
                     npcs.push_back(GameObjectManager::getSingleton().toProperty(*itNpc));
                 }
@@ -90,7 +92,7 @@
 
         Throw(IllegalArgumentException, key + &quot; is not a property of DialogManager&quot;);
     }
-	
+
 	int DialogManager::getPriority() const
 	{
 		return 50;
@@ -129,43 +131,55 @@
         return &quot;dialogs&quot;;
     }
 
-    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, Creature* npc, Creature* pc)
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, Creature* npc)
     {
-        std::vector&lt;Creature*&gt; npcs;
+        list&lt;Creature*&gt; npcs;
         npcs.push_back(npc);
-        std::vector&lt;Creature*&gt; pcs;
-        pcs.push_back(pc);
 
-        return createDialog(name, npcs, pcs);
+        return createDialog(name, npcs);
     }
 
-    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const list&lt;Creature*&gt;&amp; npcs)
     {
-        std::map&lt;DialogConfiguration, Dialog*&gt;::iterator it 
-            = mDialogStates.find(DialogConfiguration(name, npcs));
+        list&lt;Creature*&gt; participants;
 
+        Party party = PartyManager::getSingleton().getCharacters();
+        for (Party::const_iterator it = party.begin(); it != party.end(); ++it)
+        {
+            participants.push_back(*it);
+        }
+
+        for (list&lt;Creature*&gt;::const_iterator it = npcs.begin(); it != npcs.end(); ++it)
+        {
+            participants.push_back(*it);
+        }
+
+        map&lt;DialogConfiguration, Dialog*&gt;::iterator it
+            = mDialogStates.find(DialogConfiguration(name, participants));
+
         Dialog* dialog;
         if (it != mDialogStates.end())
         {
             dialog = (*it).second;
         }
-        else 
+        else
         {
-			dialog = mDialogLoader-&gt;createDialog(name, pcs, npcs); ///@todo save dialogs
-			
-			if (!dialog) 
+			dialog = mDialogLoader-&gt;createDialog(name, participants); ///@todo save dialogs
+
+			if (!dialog)
 			{
 				return NULL;
 			}
-			
+
             dialog-&gt;initialize();
-            mDialogStates[DialogConfiguration(name, npcs)] = dialog;
+            mDialogStates[DialogConfiguration(name, participants)] = dialog;
         }
 		return dialog;
     }
-	
-    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs)
-        : mDialogName(name), mNpcs(npcs)
+
+    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String&amp; name,
+            const list&lt;Creature*&gt;&amp; participants)
+        : mDialogName(name), mParticipants(participants)
     {
     }
 
@@ -174,9 +188,9 @@
         return mDialogName;
     }
 
-    const std::vector&lt;Creature*&gt;&amp; DialogManager::DialogConfiguration::getNpcs() const
+    const list&lt;Creature*&gt;&amp; DialogManager::DialogConfiguration::getParticipants() const
     {
-        return mNpcs;
+        return mParticipants;
     }
 
     bool DialogManager::DialogConfiguration::operator &lt;(const rl::DialogManager::DialogConfiguration &amp; other) const
@@ -186,8 +200,8 @@
 
     bool DialogManager::DialogConfiguration::operator ==(const rl::DialogManager::DialogConfiguration &amp; other) const
     {
-        return (mDialogName == other.mDialogName) 
-            &amp;&amp; (mNpcs == other.mNpcs);
+        return (mDialogName == other.mDialogName)
+            &amp;&amp; (mParticipants == other.mParticipants);
     }
 
 

Modified: rl/branches/persistence2/engine/ai/src/DialogOption.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogOption.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogOption.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -48,7 +48,7 @@
 
     const CeGuiString&amp; DialogOption::getConditionVariableType()
     {
-        RlAssert(mPrecondition, CeGuiString(&quot;No precondition found for option with id: &quot; 
+        RlAssert(mPrecondition, CeGuiString(&quot;No precondition found for option with id: &quot;
                                 + getId()
                                 + &quot;\nA precondition must be set to get its variable type&quot;).c_str());
         return mPrecondition-&gt;getVariableType();
@@ -67,7 +67,7 @@
     bool DialogOption::isAvailable(Dialog* dialog) const
     {
         bool isActive = true;
-        
+
         if(dialog-&gt;getAllProperties()-&gt;hasProperty(&quot;option&quot; + getId() + &quot;isActive&quot;))
         {
             isActive = dialog-&gt;getProperty(&quot;option&quot; + getId() + &quot;isActive&quot;);
@@ -97,4 +97,9 @@
         return mLabel;
     }
 
+    const CeGuiString&amp; DialogOption::getDefaultPerson() const
+    {
+        static CeGuiString PLAYER = &quot;player&quot;;
+        return PLAYER;
+    }
 }

Modified: rl/branches/persistence2/engine/ai/src/DialogParagraph.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogParagraph.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogParagraph.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -17,12 +17,17 @@
 
 #include &quot;DialogParagraph.h&quot;
 
+#include &quot;Dialog.h&quot;
+#include &quot;DialogElement.h&quot;
+
+using namespace std;
+
 namespace rl
 {
 
     DialogParagraph::DialogParagraph(
-        const CeGuiString&amp; text, const Ogre::String&amp; voicefile)
-    : mText(text), mVoiceFile(voicefile)
+        const CeGuiString&amp; text, const CeGuiString&amp; person, const Ogre::String&amp; voicefile)
+    : mText(text), mPerson(person), mVoiceFile(voicefile), mParent(NULL)
     {
         // for debug information
         mText.c_str();
@@ -37,6 +42,15 @@
         return mText;
     }
 
+    const CeGuiString&amp; DialogParagraph::getPerson() const
+    {
+        if (mPerson.empty())
+        {
+            return mParent-&gt;getPerson();
+        }
+        return mPerson;
+    }
+
     const Ogre::String&amp; DialogParagraph::getVoiceFile() const
     {
         return mVoiceFile;
@@ -47,8 +61,41 @@
         return NULL;
     }
 
+    DialogElement* DialogParagraph::getParent() const
+    {
+        return mParent;
+    }
+
+    void DialogParagraph::_setParent(DialogElement* parent)
+    {
+        mParent = parent;
+    }
+
+    Creature* DialogParagraph::getSpeaker(Dialog* dialog) const
+    {
+        return dialog-&gt;getParticipant(getPerson());
+    }
+
+    list&lt;Creature*&gt; DialogParagraph::getListeners(Dialog* dialog) const
+    {
+        Creature* speaker = getSpeaker(dialog);
+
+        list&lt;Creature*&gt; listeners;
+
+        list&lt;Creature*&gt; participants = dialog-&gt;getParticipants();
+        for (list&lt;Creature*&gt;::iterator it = participants.begin(), end = participants.end(); it != end; ++it)
+        {
+            if (*it != speaker)
+            {
+                listeners.push_back(*it);
+            }
+        }
+
+        return listeners;
+    }
+
     DialogGotoResponse::DialogGotoResponse(rl::DialogResponse *response)
-        : DialogParagraph(&quot;&quot;, &quot;&quot;), mResponse(response)
+        : DialogParagraph(&quot;&quot;, &quot;&quot;, &quot;&quot;), mResponse(response)
     {
     }
 
@@ -57,4 +104,3 @@
         return mResponse;
     }
 }
-

Modified: rl/branches/persistence2/engine/ai/src/DialogResponse.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogResponse.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogResponse.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -31,8 +31,8 @@
     DialogResponse::~DialogResponse()
     {
     }
-    
 
+
     void DialogResponse::addOption(rl::DialogOption *option)
     {
         mOptions.push_back(option);
@@ -77,9 +77,10 @@
         }
     }
 
-    Creature* DialogResponse::getNpc(rl::Dialog *dialog) const
+    const CeGuiString&amp; DialogResponse::getDefaultPerson() const
     {
-        return dialog-&gt;getNpc(mNpcId);
+        static CeGuiString PERSON = &quot;npc&quot;;
+        return PERSON;
     }
 
     DialogResponseSelection::DialogResponseSelection(const CeGuiString&amp; id)

Modified: rl/branches/persistence2/engine/ai/src/DialogVariable.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogVariable.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ai/src/DialogVariable.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -81,19 +81,16 @@
 
     Property TalentProbeVariable::calculateValue(Dialog* dialog)
     {
-        Creature* cr = NULL;
-        if(mTarget == &quot;pc&quot;)
+        Creature* cr = dialog-&gt;getParticipant(mTarget);
+        if (cr == NULL)
         {
-            cr = dialog-&gt;getPc(0); ///@todo allow multiple PCs
+            LOG_ERROR(&quot;Dialog&quot;, &quot;No or wrong target for talent check ' &quot; + mTalent + &quot;'&quot;);
+            return Property(-1);
         }
-        else if (mTarget == &quot;npc&quot;)
+        else
         {
-            cr = dialog-&gt;getNpc(0);
+            return Property(cr-&gt;doTalentprobe(mTalent, mModifier));
         }
-        // if no target was given, use the player character. 
-        // @todo: remove this, target should be required!
-        if(cr == NULL) { cr = dialog-&gt;getPc(0);}
-        return Property(cr-&gt;doTalentprobe(mTalent, mModifier));
     }
 
     EigenschaftsProbeVariable::EigenschaftsProbeVariable(const rl::CeGuiString &amp;eigenschaft, int modifier, const rl::CeGuiString&amp; target)
@@ -103,26 +100,25 @@
 
     Property EigenschaftsProbeVariable::calculateValue(Dialog* dialog)
     {
-        Creature* cr = NULL;
-        if(mTarget == &quot;pc&quot;)
+        Creature* cr = dialog-&gt;getParticipant(mTarget);
+        // if no target was given, use the player character.
+        // @todo: remove this, target should be required!
+        if (cr == NULL)
         {
-            cr = dialog-&gt;getPc(0); ///@todo allow multiple PCs
+            LOG_ERROR(&quot;Dialog&quot;, &quot;No or wrong target for attribute check ' &quot; + mEigenschaft + &quot;'&quot;);
+            return Property(-1);
         }
-        else if (mTarget == &quot;npc&quot;)
+        else
         {
-            cr = dialog-&gt;getNpc(0);
+            return Property(cr-&gt;doEigenschaftsprobe(mEigenschaft, mModifier));
         }
-        // if no target was given, use the player character. 
-        // @todo: remove this, target should be required!
-        if(cr == NULL) { cr = dialog-&gt;getPc(0);}
-        return Property(cr-&gt;doEigenschaftsprobe(mEigenschaft, mModifier));
     }
-	
+
 	RandomVariable::RandomVariable(int maximum)
 		: DialogVariable(&quot;random&quot;), mMaximum(maximum)
 	{
 	}
-	
+
 	Property RandomVariable::calculateValue(Dialog* dialog)
 	{
 		double d = std::rand();

Modified: rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,584 +1,584 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;XmlResourceManager.h&quot;
-
-#include &quot;CoreSubsystem.h&quot;
-
-#include &lt;OgreEnvironment.h&gt;
-
-#include &quot;ActorManager.h&quot;
-#include &quot;AnimationManager.h&quot;
-#include &quot;ContentModule.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;DebugVisualsManager.h&quot;
-#include &quot;DotSceneOctreeWorld.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameEventManager.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;JobScheduler.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &quot;SaveGameManager.h&quot;
-#include &quot;SaveAbleSerializer.h&quot;
-#include &quot;ScriptWrapper.h&quot;
-#include &quot;SoundManager.h&quot;
-#include &quot;TimeSource.h&quot;
-#include &quot;WriteableFileSystemArchiv.h&quot;
-#include &quot;ZoneManager.h&quot;
-
-#include &lt;ctime&gt;
-
-using namespace Ogre;
-
-template&lt;&gt; rl::CoreSubsystem* Singleton&lt;rl::CoreSubsystem&gt;::ms_Singleton = 0;
-
-namespace rl
-{
-    CoreSubsystem::CoreSubsystem()
-        : Singleton&lt;CoreSubsystem&gt;(),
-        mWorld(NULL),
-        mRubyInterpreter(NULL),
-        mModules(),
-        mActiveAdventureModule(NULL),
-        mDefaultActiveModule(&quot;&quot;),
-        mClockStartTime(),
-        mDeveloperMode(false),
-        mInitialized(false),
-        mDefaultTechniques(),
-        mOgreRoot(NULL),
-        mScriptWrapper(NULL),
-        mXmlResourceManager(NULL),
-        mPhysicsManager(NULL),
-        mMessagePump(NULL),
-        mGameLoop(NULL),
-        mAnimationManager(NULL),
-        mActorManager(NULL),
-        mGameEventManager(NULL),
-        mSoundManager(NULL),
-        mDebugVisualsManager(NULL),
-        mJobScheduler(NULL),
-        mRenderWindow(NULL),
-        mZoneManager(NULL),
-        mCurrentScene(&quot;&quot;)
-    {
-        initializeCoreSubsystem();
-    }
-
-    CoreSubsystem::~CoreSubsystem()
-    {
-        delete meshmagick::OgreEnvironment::getSingletonPtr();
-        delete mWorld;
-        delete mZoneManager;
-        delete mGameEventManager;
-        delete mMessagePump;
-        delete mJobScheduler;
-        delete mAnimationManager;
-        delete mActorManager;
-        delete mPhysicsManager;
-        delete mScriptWrapper;
-        delete mDebugVisualsManager;
-        delete ConfigurationManager::getSingletonPtr();
-        delete mSoundManager;
-        mRenderWindow-&gt;destroy();
-        delete mOgreRoot;
-        delete mRubyInterpreter;
-        delete mTimeSourceManager;
-        delete mSaveGameManager;
-        delete mSaveAbleManager;
-		delete mSaveAbleSerializer;
-        delete mGameLoop;
-        //mXmlResourceManager-&gt;unloadAll();
-        //delete mXmlResourceManager;
-    }
-
-    void CoreSubsystem::startCore()
-    {
-        loadPlugins();
-
-        mInitialized = true;
-
-        if (mDefaultActiveModule == &quot;&quot;)
-        {
-            mDefaultActiveModule = &quot;intro&quot;; ///@fixme replace by last active
-        }
-
-
-        ContentModule* mod = getModule(mDefaultActiveModule);
-        if (mod == NULL)
-        {
-            Throw(rl::RuntimeException, &quot;Module &quot;+mDefaultActiveModule+&quot; not found&quot;);
-        }
-        else
-        {
-            startAdventureModule(mod);
-        }
-
-        mGameLoop-&gt;loop();
-
-        mWorld-&gt;clearScene();
-        unloadPlugins();
-
-        //mRubyInterpreter-&gt;finalizeInterpreter();
-    }
-
-    void CoreSubsystem::renderOneFrame(bool executeTasks)
-    {
-        mGameLoop-&gt;_executeOneRenderLoop(executeTasks);
-    }
-
-    void CoreSubsystem::setDeveloperMode(bool developerMode)
-    {
-        mDeveloperMode = developerMode;
-    }
-
-    bool CoreSubsystem::getDeveloperMode() const
-    {
-        return mDeveloperMode;
-    }
-
-    bool CoreSubsystem::isInitialized() const
-    {
-        return mInitialized;
-    }
-
-    Ogre::RenderWindow* CoreSubsystem::getRenderWindow() const
-    {
-        return mRenderWindow;
-    }
-
-	void CoreSubsystem::setPaused(bool paused)
-	{
-       // mAnimationManager-&gt;setPaused(paused);
-       // mPhysicsManager-&gt;setPaused(paused);
-        mTimeSourceManager-&gt;setPaused(paused);
-        mGameLoop-&gt;setPaused(paused);
-	}
-
-    void CoreSubsystem::setTimeFactor(const Ogre::Real &amp;factor)
-    {
-        mTimeSourceManager-&gt;setTimeFactor(factor);
-        mPhysicsManager-&gt;setTimeFactor(factor);
-        mGameLoop-&gt;setTimeFactor(factor);
-    }
-
-    bool CoreSubsystem::initializeCoreSubsystem()
-    {
-        // set default queryflags to zero
-        Ogre::MovableObject::setDefaultQueryFlags(0);
-        // By not specifying the first two parameters, OGRE will not try
-        // to load plugins.cfg and ogre.cfg
-        mOgreRoot = new Root(&quot;&quot;, &quot;&quot;, ConfigurationManager::getSingleton().getOgreLogFile());
-
-        WriteableFileSystemArchiveFactory* factory = new WriteableFileSystemArchiveFactory();
-        ArchiveManager::getSingleton().addArchiveFactory(factory);
-
-        // Load Ogre plugins
-        Ogre::StringVector pluginList = ConfigurationManager::getSingleton().getPluginList();
-        for (Ogre::StringVector::const_iterator it = pluginList.begin(); it &lt; pluginList.end(); it++)
-        {
-            mOgreRoot-&gt;loadPlugin(*it);
-        }
-
-        // Find out, what Renderer plugins are available
-        RenderSystemList* rsl = mOgreRoot-&gt;getAvailableRenderers();
-        RenderSystemList::iterator it;
-
-        for (it = rsl-&gt;begin(); it &lt; rsl-&gt;end(); it++)
-        {
-            if ((*it)-&gt;getName() == ConfigurationManager::getSingleton().getStringSetting(
-                &quot;Video&quot;, &quot;Render System&quot;))
-            {
-                // Select and initialise the render system
-                mOgreRoot-&gt;setRenderSystem(*it);
-                mOgreRoot-&gt;initialise(false, &quot;&quot;);
-            }
-        }
-
-        //Root::getSingleton().setFrameSmoothingPeriod(0.5f);
-
-        // Muss vor dem Laden der Ressourcen geschehen,
-        // weil es sonst sofort angewandt wird.
-        MeshManager::getSingleton().setBoundsPaddingFactor(0.0);
-
-        // EDIT:
-        LOG_MESSAGE(Logger::CORE,&quot;init&quot;);
-
-        std::stringstream name;
-        name &lt;&lt; &quot;Rastullahs Lockenpracht - &quot;;
-        name &lt;&lt; getEngineVersionString() &lt;&lt; &quot; &quot;;
-        name &lt;&lt; getEngineVersionName() &lt;&lt; &quot; [&quot;;
-        name &lt;&lt; getEngineBuildNumber() &lt;&lt; &quot;]&quot;;
-
-        // Get width and height of the RenderWindow from the &quot;Video Mode&quot; setting
-        Ogre::String VideoMode = ConfigurationManager::getSingleton().getStringSetting(
-            &quot;Video&quot;, &quot;Video Mode&quot;);
-        int temp = VideoMode.find(&quot;x&quot;);
-        int width = Ogre::StringConverter::parseInt(VideoMode.substr(0, temp));
-        int height = Ogre::StringConverter::parseInt(VideoMode.substr(temp + 1, VideoMode.size()));
-
-        mRenderWindow = mOgreRoot-&gt;createRenderWindow(
-            name.str(), width, height,
-            ConfigurationManager::getSingleton().getBoolSetting(
-                &quot;Video&quot;, &quot;Fullscreen&quot;),
-            ConfigurationManager::getSingleton().getVideoSettings());
-
-        if (!mRenderWindow)
-            return false;
-
-        mGameLoop = new GameLoop();
-        LOG_MESSAGE(Logger::CORE,&quot;GameLoopmanager erzeugt&quot;);
-
-        mSaveGameManager = new SaveGameManager();
-        LOG_MESSAGE(Logger::RULES, &quot;SaveGameManager erzeugt&quot;);
-
-        mSaveAbleManager = new SaveAbleManager();
-
-		mSaveAbleSerializer = new SaveAbleSerializer();
-        LOG_MESSAGE(Logger::RULES, &quot;SaveAbleSerializer erzeugt&quot;);
-		
-		mTimeSourceManager = new TimeSourceManager();
-        mTimeSourceManager-&gt;registerTimeSource(new RealTimeContinuous());
-        mTimeSourceManager-&gt;registerTimeSource(new RealTimeInterruptable());
-        LOG_MESSAGE(Logger::CORE,&quot;Time sources (realtime) created&quot;);
-
-        mScriptWrapper = new ScriptWrapper();
-        LOG_MESSAGE(Logger::CORE,&quot;Skriptwrapper erzeugt&quot;);
-        ///@todo: muss loeschbar werden.
-        mRubyInterpreter = new RubyInterpreter();
-        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter erzeugt&quot;);
-        mRubyInterpreter-&gt;initializeInterpreter();
-        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter initialisiert&quot;);
-
-        mMessagePump = new MessagePump();
-        GameLoop::getSingleton().addTask(mMessagePump, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,&quot;MessagePump erzeugt&quot;);
-
-        mActorManager = new ActorManager();
-        LOG_MESSAGE(Logger::CORE,&quot;Aktormanager erzeugt&quot;);
-
-        mSoundManager = new SoundManager();
-        GameLoop::getSingleton().addTask(mSoundManager, GameLoop::TG_SOUND);
-        LOG_MESSAGE(Logger::CORE,&quot;SoundManager erzeugt&quot;);
-
-        initializeResources();
-
-        // Set default mipmap level (NB some APIs ignore this)
-        ///@todo: In Config-Datei verlagern
-        TextureManager::getSingleton().setDefaultNumMipmaps(5);
-        MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_TRILINEAR);
-        MaterialManager::getSingleton().setDefaultAnisotropy(
-            ConfigurationManager::getSingleton().getIntSetting(
-                &quot;Video&quot;, &quot;Max Anisotropy&quot;));
-
-
-        mWorld = new DotSceneOctreeWorld();
-        mActorManager-&gt;setWorld(mWorld);
-
-        mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
-        GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
-        LOG_MESSAGE(Logger::CORE,&quot;PhysicsManager erzeugt&quot;);
-
-        mAnimationManager = new AnimationManager();
-        GameLoop::getSingleton().addTask(mAnimationManager, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,&quot;AnimationManager erzeugt&quot;);
-
-        mGameEventManager = new GameEventManager();
-        GameLoop::getSingleton().addTask(mGameEventManager, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,&quot;GameEventManager erzeugt&quot;);
-
-        mDebugVisualsManager = new DebugVisualsManager();
-        GameLoop::getSingleton().addTask(mDebugVisualsManager, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,&quot;DebugVisualsManager erzeugt&quot;);
-
-        mJobScheduler = new JobScheduler();
-        GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,&quot;JobScheduler erzeugt&quot;);
-
-		mZoneManager = new ZoneManager();
-        GameLoop::getSingleton().addTask(mZoneManager, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,&quot;ZoneManager erzeugt&quot;);
-
-		new meshmagick::OgreEnvironment();
-		meshmagick::OgreEnvironment::getSingleton().initialize(false, Logger::getSingleton()._getLog());
-
-        return true;
-    }
-
-    void CoreSubsystem::initializeResources()
-    {
-        mXmlResourceManager = new XmlResourceManager();
-
-        // Fuer Configs die keinem Typ zugeordnet sind,
-        // und die per kompletten Verezeichnis erfragt werden
-        ResourceGroupManager::getSingleton().addResourceLocation(
-            ConfigurationManager::getSingleton().
-                getModulesRootDirectory(),
-            &quot;FileSystem&quot;,
-            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-
-
-        // Initialise the modules
-        Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
-
-        Ogre::StringVector brokenModules;
-
-        for (size_t i = 0; i &lt; modulesList.size(); i++)
-        {
-            mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(modulesList[i]));
-
-            ContentModule* module = getModule(modulesList[i]);
-
-            if (module == NULL)
-            {
-                LOG_WARNING(&quot;CoreSubsystem&quot;,
-                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;', removed.&quot;);
-                brokenModules.push_back(modulesList[i]);
-            }
-            //else
-            //{
-            //    if (module-&gt;isCommon())
-            //    {
-            //        module-&gt;initializeTextures();
-            //        module-&gt;initialize();
-            //    }
-            //}
-        }
-
-        ConfigurationManager::getSingleton().removeModules(brokenModules);
-    }
-
-    ContentModule* CoreSubsystem::getModule(const Ogre::String&amp; moduleId) const
-    {
-        ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
-
-        if (moduleIt != mModules.end())
-        {
-            return (*moduleIt).second;
-        }
-        else
-        {
-            return NULL;
-        }
-    }
-
-    void CoreSubsystem::registerModule(ContentModule* module)
-    {
-        mModules[module-&gt;getId()] = module;
-    }
-
-    void CoreSubsystem::updateDefaultScheme()
-    {
-        int numTu = mOgreRoot-&gt;getRenderSystem()-&gt;getCapabilities()-&gt;getNumTextureUnits();
-
-        Ogre::String tuScheme;
-
-        if (numTu &gt;= 6)
-            tuScheme = &quot;tu6&quot;;
-        else if (numTu &gt;= 2)
-            tuScheme = &quot;tu2&quot;;
-        else
-            tuScheme = &quot;tu1&quot;;
-
-        LOG_MESSAGE(Logger::CORE,
-            &quot;Found &quot; + Ogre::StringConverter::toString(numTu) + &quot; Texture Units, using &quot;+
-            &quot;alphablending scheme &quot; + tuScheme);
-
-        for (ResourceManager::ResourceMapIterator itMat =
-            MaterialManager::getSingleton().getResourceIterator();
-            itMat.hasMoreElements();)
-        {
-            MaterialPtr mat = itMat.getNext();
-            for (Material::TechniqueIterator itTech =
-                mat-&gt;getTechniqueIterator();
-                itTech.hasMoreElements();)
-            {
-                Technique* tech = itTech.getNext();
-                if (tech-&gt;getSchemeName() == tuScheme)
-                {
-                    tech-&gt;setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
-                    mDefaultTechniques.push_back(tech);
-                }
-                else if (tech-&gt;getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
-                {
-                    mDefaultTechniques.push_back(tech);
-                }
-            }
-        }
-    }
-
-    void CoreSubsystem::setScheme(const Ogre::String&amp; schemeName)
-    {
-        if (schemeName != MaterialManager::getSingleton().getActiveScheme())
-        {
-            /*for (std::vector&lt;Technique*&gt;::iterator iter = mDefaultTechniques.begin();
-                iter != mDefaultTechniques.end(); ++iter)
-            {
-                Technique* cur = *iter;
-                cur-&gt;setSchemeName(schemeName);
-            }*/
-
-            MaterialManager::getSingleton().setActiveScheme(schemeName);
-        }
-    }
-
-    void CoreSubsystem::startAdventureModule(ContentModule* module)
-    {
-        if (mActiveAdventureModule != NULL)
-        {
-            mActiveAdventureModule-&gt;unload();
-        }
-
-        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(0.0));
-
-        updateDefaultScheme();
-        loadModule(module);
-        mActiveAdventureModule = module;
-
-        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(100.0));
-        
-        module-&gt;start();
-    }
-
-    void CoreSubsystem::loadModule(ContentModule* module)
-    {
-        if (module-&gt;getMinimumEngineVersion() &gt; getEngineBuildNumber())
-        {
-            Throw(
-                rl::RuntimeException,
-                &quot;Module &quot;
-                + Ogre::String(module-&gt;getName().c_str())
-                + &quot; needs engine &gt;=&quot;
-                + StringConverter::toString(module-&gt;getMinimumEngineVersion())
-                + &quot; but engine is &quot;
-                + StringConverter::toString(getEngineBuildNumber()));
-        }
-
-        StringVector deps = module-&gt;getDependencies();
-        for (StringVector::const_iterator depsIt = deps.begin(); depsIt != deps.end(); depsIt++)
-        {
-            Ogre::String depName = *depsIt;
-            ModuleMap::iterator modIt = mModules.find(depName);
-            if (modIt == mModules.end())
-            {
-                Throw(
-                    rl::RuntimeException,
-                    &quot;Depedency Module &quot; + depName
-                    + &quot; needed by &quot; + Ogre::String(module-&gt;getName().c_str())
-                    + &quot; not found.&quot;);
-            }
-
-            ContentModule* depMod = (*modIt).second;
-
-            if (!depMod-&gt;isLoaded())
-            {
-                loadModule(depMod);
-            }
-        }
-
-        LOG_MESSAGE(
-            Logger::CORE,
-            &quot;Start initializing module &quot; + module-&gt;getName());
-        module-&gt;initializeTextures();
-        module-&gt;initialize();
-
-        ResourceGroupManager::getSingleton().initialiseResourceGroup(module-&gt;getId());
-        module-&gt;precreateMeshes();
-
-        if (module-&gt;isCommon())
-        {
-            module-&gt;start();
-        }
-
-        LOG_MESSAGE(
-            Logger::CORE,
-            &quot;Module &quot; + module-&gt;getName() + &quot; initialized.&quot;);
-    }
-
-    void CoreSubsystem::setDefaultActiveModule(const Ogre::String&amp; module)
-    {
-        mDefaultActiveModule = module;
-    }
-
-    const Ogre::String&amp; CoreSubsystem::getDefaultActiveModule() const
-    {
-        return mDefaultActiveModule;
-    }
-
-    World* CoreSubsystem::getWorld()
-    {
-        return mWorld;
-    }
-
-    const Ogre::String CoreSubsystem::getEngineVersionString() const
-    {
-        static Ogre::String version = &quot;0.3.0&quot;;
-        return version;
-    }
-
-    const Ogre::String CoreSubsystem::getEngineVersionName() const
-    {
-        static Ogre::String version = &quot;Internal Build&quot;;
-        return version;
-    }
-
-    long CoreSubsystem::getEngineBuildNumber() const
-    {
-        static const Ogre::String sMonths[] =
-        {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;,
-         &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
-
-        Ogre::String dateStr = Ogre::String(__DATE__);
-        Ogre::String monthStr = dateStr.substr(0,3);
-        int day = Ogre::StringConverter::parseInt(dateStr.substr(4,2));
-        int year = Ogre::StringConverter::parseInt(dateStr.substr(7,4));
-        int month = 0;
-
-        while( month &lt; 12 &amp;&amp; monthStr.compare(sMonths[month]) != 0 )
-            month++;
-
-        return /* Jahr */          year * 100000 +
-               /* Monat */         (month+1) * 1000 +
-               /* Tag */           day * 10 +
-               /* Sub-Version */   0;
-    }
-
-    RubyInterpreter* CoreSubsystem::getRubyInterpreter()
-    {
-        return mRubyInterpreter;
-    }
-
-    void CoreSubsystem::makeScreenshot( const Ogre::String&amp; sName )
-    {
-        mRenderWindow-&gt;writeContentsToTimestampedFile(sName, &quot;.png&quot;);
-    }
-
-    ContentModule* CoreSubsystem::getActiveAdventureModule() const
-    {
-        return mActiveAdventureModule;
-    }
-
-    const ModuleMap&amp; CoreSubsystem::getAllModules() const
-    {
-        return mModules;
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;XmlResourceManager.h&quot;
+
+#include &quot;CoreSubsystem.h&quot;
+
+#include &lt;OgreEnvironment.h&gt;
+
+#include &quot;ActorManager.h&quot;
+#include &quot;AnimationManager.h&quot;
+#include &quot;ContentModule.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;DebugVisualsManager.h&quot;
+#include &quot;DotSceneOctreeWorld.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameEventManager.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;JobScheduler.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;RubyInterpreter.h&quot;
+#include &quot;SaveGameManager.h&quot;
+#include &quot;SaveAbleSerializer.h&quot;
+#include &quot;ScriptWrapper.h&quot;
+#include &quot;SoundManager.h&quot;
+#include &quot;TimeSource.h&quot;
+#include &quot;WriteableFileSystemArchiv.h&quot;
+#include &quot;ZoneManager.h&quot;
+
+#include &lt;ctime&gt;
+
+using namespace Ogre;
+
+template&lt;&gt; rl::CoreSubsystem* Singleton&lt;rl::CoreSubsystem&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    CoreSubsystem::CoreSubsystem()
+        : Singleton&lt;CoreSubsystem&gt;(),
+        mWorld(NULL),
+        mRubyInterpreter(NULL),
+        mModules(),
+        mActiveAdventureModule(NULL),
+        mDefaultActiveModule(&quot;&quot;),
+        mClockStartTime(),
+        mDeveloperMode(false),
+        mInitialized(false),
+        mDefaultTechniques(),
+        mOgreRoot(NULL),
+        mScriptWrapper(NULL),
+        mXmlResourceManager(NULL),
+        mPhysicsManager(NULL),
+        mMessagePump(NULL),
+        mGameLoop(NULL),
+        mAnimationManager(NULL),
+        mActorManager(NULL),
+        mGameEventManager(NULL),
+        mSoundManager(NULL),
+        mDebugVisualsManager(NULL),
+        mJobScheduler(NULL),
+        mRenderWindow(NULL),
+        mZoneManager(NULL),
+        mCurrentScene(&quot;&quot;)
+    {
+        initializeCoreSubsystem();
+    }
+
+    CoreSubsystem::~CoreSubsystem()
+    {
+        delete meshmagick::OgreEnvironment::getSingletonPtr();
+        delete mWorld;
+        delete mZoneManager;
+        delete mGameEventManager;
+        delete mMessagePump;
+        delete mJobScheduler;
+        delete mAnimationManager;
+        delete mActorManager;
+        delete mPhysicsManager;
+        delete mScriptWrapper;
+        delete mDebugVisualsManager;
+        delete ConfigurationManager::getSingletonPtr();
+        delete mSoundManager;
+        mRenderWindow-&gt;destroy();
+        delete mOgreRoot;
+        delete mRubyInterpreter;
+        delete mTimeSourceManager;
+        delete mSaveGameManager;
+        delete mSaveAbleManager;
+		delete mSaveAbleSerializer;
+        delete mGameLoop;
+        //mXmlResourceManager-&gt;unloadAll();
+        //delete mXmlResourceManager;
+    }
+
+    void CoreSubsystem::startCore()
+    {
+        loadPlugins();
+
+        mInitialized = true;
+
+        if (mDefaultActiveModule == &quot;&quot;)
+        {
+            mDefaultActiveModule = &quot;intro&quot;; ///@fixme replace by last active
+        }
+
+
+        ContentModule* mod = getModule(mDefaultActiveModule);
+        if (mod == NULL)
+        {
+            Throw(rl::RuntimeException, &quot;Module &quot;+mDefaultActiveModule+&quot; not found&quot;);
+        }
+        else
+        {
+            startAdventureModule(mod);
+        }
+
+        mGameLoop-&gt;loop();
+
+        mWorld-&gt;clearScene();
+        unloadPlugins();
+
+        //mRubyInterpreter-&gt;finalizeInterpreter();
+    }
+
+    void CoreSubsystem::renderOneFrame(bool executeTasks)
+    {
+        mGameLoop-&gt;_executeOneRenderLoop(executeTasks);
+    }
+
+    void CoreSubsystem::setDeveloperMode(bool developerMode)
+    {
+        mDeveloperMode = developerMode;
+    }
+
+    bool CoreSubsystem::getDeveloperMode() const
+    {
+        return mDeveloperMode;
+    }
+
+    bool CoreSubsystem::isInitialized() const
+    {
+        return mInitialized;
+    }
+
+    Ogre::RenderWindow* CoreSubsystem::getRenderWindow() const
+    {
+        return mRenderWindow;
+    }
+
+	void CoreSubsystem::setPaused(bool paused)
+	{
+       // mAnimationManager-&gt;setPaused(paused);
+       // mPhysicsManager-&gt;setPaused(paused);
+        mTimeSourceManager-&gt;setPaused(paused);
+        mGameLoop-&gt;setPaused(paused);
+	}
+
+    void CoreSubsystem::setTimeFactor(const Ogre::Real &amp;factor)
+    {
+        mTimeSourceManager-&gt;setTimeFactor(factor);
+        mPhysicsManager-&gt;setTimeFactor(factor);
+        mGameLoop-&gt;setTimeFactor(factor);
+    }
+
+    bool CoreSubsystem::initializeCoreSubsystem()
+    {
+        // set default queryflags to zero
+        Ogre::MovableObject::setDefaultQueryFlags(0);
+        // By not specifying the first two parameters, OGRE will not try
+        // to load plugins.cfg and ogre.cfg
+        mOgreRoot = new Root(&quot;&quot;, &quot;&quot;, ConfigurationManager::getSingleton().getOgreLogFile());
+
+        WriteableFileSystemArchiveFactory* factory = new WriteableFileSystemArchiveFactory();
+        ArchiveManager::getSingleton().addArchiveFactory(factory);
+
+        // Load Ogre plugins
+        Ogre::StringVector pluginList = ConfigurationManager::getSingleton().getPluginList();
+        for (Ogre::StringVector::const_iterator it = pluginList.begin(); it &lt; pluginList.end(); it++)
+        {
+            mOgreRoot-&gt;loadPlugin(*it);
+        }
+
+        // Find out, what Renderer plugins are available
+        RenderSystemList* rsl = mOgreRoot-&gt;getAvailableRenderers();
+        RenderSystemList::iterator it;
+
+        for (it = rsl-&gt;begin(); it &lt; rsl-&gt;end(); it++)
+        {
+            if ((*it)-&gt;getName() == ConfigurationManager::getSingleton().getStringSetting(
+                &quot;Video&quot;, &quot;Render System&quot;))
+            {
+                // Select and initialise the render system
+                mOgreRoot-&gt;setRenderSystem(*it);
+                mOgreRoot-&gt;initialise(false, &quot;&quot;);
+            }
+        }
+
+        //Root::getSingleton().setFrameSmoothingPeriod(0.5f);
+
+        // Muss vor dem Laden der Ressourcen geschehen,
+        // weil es sonst sofort angewandt wird.
+        MeshManager::getSingleton().setBoundsPaddingFactor(0.0);
+
+        // EDIT:
+        LOG_MESSAGE(Logger::CORE,&quot;init&quot;);
+
+        std::stringstream name;
+        name &lt;&lt; &quot;Rastullahs Lockenpracht - &quot;;
+        name &lt;&lt; getEngineVersionString() &lt;&lt; &quot; &quot;;
+        name &lt;&lt; getEngineVersionName() &lt;&lt; &quot; [&quot;;
+        name &lt;&lt; getEngineBuildNumber() &lt;&lt; &quot;]&quot;;
+
+        // Get width and height of the RenderWindow from the &quot;Video Mode&quot; setting
+        Ogre::String VideoMode = ConfigurationManager::getSingleton().getStringSetting(
+            &quot;Video&quot;, &quot;Video Mode&quot;);
+        int temp = VideoMode.find(&quot;x&quot;);
+        int width = Ogre::StringConverter::parseInt(VideoMode.substr(0, temp));
+        int height = Ogre::StringConverter::parseInt(VideoMode.substr(temp + 1, VideoMode.size()));
+
+        mRenderWindow = mOgreRoot-&gt;createRenderWindow(
+            name.str(), width, height,
+            ConfigurationManager::getSingleton().getBoolSetting(
+                &quot;Video&quot;, &quot;Fullscreen&quot;),
+            ConfigurationManager::getSingleton().getVideoSettings());
+
+        if (!mRenderWindow)
+            return false;
+
+        mGameLoop = new GameLoop();
+        LOG_MESSAGE(Logger::CORE,&quot;GameLoopmanager erzeugt&quot;);
+
+        mSaveGameManager = new SaveGameManager();
+        LOG_MESSAGE(Logger::RULES, &quot;SaveGameManager erzeugt&quot;);
+
+        mSaveAbleManager = new SaveAbleManager();
+
+		mSaveAbleSerializer = new SaveAbleSerializer();
+        LOG_MESSAGE(Logger::RULES, &quot;SaveAbleSerializer erzeugt&quot;);
+		
+		mTimeSourceManager = new TimeSourceManager();
+        mTimeSourceManager-&gt;registerTimeSource(new RealTimeContinuous());
+        mTimeSourceManager-&gt;registerTimeSource(new RealTimeInterruptable());
+        LOG_MESSAGE(Logger::CORE,&quot;Time sources (realtime) created&quot;);
+
+        mScriptWrapper = new ScriptWrapper();
+        LOG_MESSAGE(Logger::CORE,&quot;Skriptwrapper erzeugt&quot;);
+        ///@todo: muss loeschbar werden.
+        mRubyInterpreter = new RubyInterpreter();
+        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter erzeugt&quot;);
+        mRubyInterpreter-&gt;initializeInterpreter();
+        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter initialisiert&quot;);
+
+        mMessagePump = new MessagePump();
+        GameLoop::getSingleton().addTask(mMessagePump, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,&quot;MessagePump erzeugt&quot;);
+
+        mActorManager = new ActorManager();
+        LOG_MESSAGE(Logger::CORE,&quot;Aktormanager erzeugt&quot;);
+
+        mSoundManager = new SoundManager();
+        GameLoop::getSingleton().addTask(mSoundManager, GameLoop::TG_SOUND);
+        LOG_MESSAGE(Logger::CORE,&quot;SoundManager erzeugt&quot;);
+
+        initializeResources();
+
+        // Set default mipmap level (NB some APIs ignore this)
+        ///@todo: In Config-Datei verlagern
+        TextureManager::getSingleton().setDefaultNumMipmaps(5);
+        MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_TRILINEAR);
+        MaterialManager::getSingleton().setDefaultAnisotropy(
+            ConfigurationManager::getSingleton().getIntSetting(
+                &quot;Video&quot;, &quot;Max Anisotropy&quot;));
+
+
+        mWorld = new DotSceneOctreeWorld();
+        mActorManager-&gt;setWorld(mWorld);
+
+        mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
+        GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
+        LOG_MESSAGE(Logger::CORE,&quot;PhysicsManager erzeugt&quot;);
+
+        mAnimationManager = new AnimationManager();
+        GameLoop::getSingleton().addTask(mAnimationManager, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,&quot;AnimationManager erzeugt&quot;);
+
+        mGameEventManager = new GameEventManager();
+        GameLoop::getSingleton().addTask(mGameEventManager, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,&quot;GameEventManager erzeugt&quot;);
+
+        mDebugVisualsManager = new DebugVisualsManager();
+        GameLoop::getSingleton().addTask(mDebugVisualsManager, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,&quot;DebugVisualsManager erzeugt&quot;);
+
+        mJobScheduler = new JobScheduler();
+        GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,&quot;JobScheduler erzeugt&quot;);
+
+		mZoneManager = new ZoneManager();
+        GameLoop::getSingleton().addTask(mZoneManager, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,&quot;ZoneManager erzeugt&quot;);
+
+		new meshmagick::OgreEnvironment();
+		meshmagick::OgreEnvironment::getSingleton().initialize(false, Logger::getSingleton()._getLog());
+
+        return true;
+    }
+
+    void CoreSubsystem::initializeResources()
+    {
+        mXmlResourceManager = new XmlResourceManager();
+
+        // Fuer Configs die keinem Typ zugeordnet sind,
+        // und die per kompletten Verezeichnis erfragt werden
+        ResourceGroupManager::getSingleton().addResourceLocation(
+            ConfigurationManager::getSingleton().
+                getModulesRootDirectory(),
+            &quot;FileSystem&quot;,
+            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+
+
+        // Initialise the modules
+        Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
+
+        Ogre::StringVector brokenModules;
+
+        for (size_t i = 0; i &lt; modulesList.size(); i++)
+        {
+            mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(modulesList[i]));
+
+            ContentModule* module = getModule(modulesList[i]);
+
+            if (module == NULL)
+            {
+                LOG_WARNING(&quot;CoreSubsystem&quot;,
+                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;', removed.&quot;);
+                brokenModules.push_back(modulesList[i]);
+            }
+            //else
+            //{
+            //    if (module-&gt;isCommon())
+            //    {
+            //        module-&gt;initializeTextures();
+            //        module-&gt;initialize();
+            //    }
+            //}
+        }
+
+        ConfigurationManager::getSingleton().removeModules(brokenModules);
+    }
+
+    ContentModule* CoreSubsystem::getModule(const Ogre::String&amp; moduleId) const
+    {
+        ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
+
+        if (moduleIt != mModules.end())
+        {
+            return (*moduleIt).second;
+        }
+        else
+        {
+            return NULL;
+        }
+    }
+
+    void CoreSubsystem::registerModule(ContentModule* module)
+    {
+        mModules[module-&gt;getId()] = module;
+    }
+
+    void CoreSubsystem::updateDefaultScheme()
+    {
+        int numTu = mOgreRoot-&gt;getRenderSystem()-&gt;getCapabilities()-&gt;getNumTextureUnits();
+
+        Ogre::String tuScheme;
+
+        if (numTu &gt;= 6)
+            tuScheme = &quot;tu6&quot;;
+        else if (numTu &gt;= 2)
+            tuScheme = &quot;tu2&quot;;
+        else
+            tuScheme = &quot;tu1&quot;;
+
+        LOG_MESSAGE(Logger::CORE,
+            &quot;Found &quot; + Ogre::StringConverter::toString(numTu) + &quot; Texture Units, using &quot;+
+            &quot;alphablending scheme &quot; + tuScheme);
+
+        for (ResourceManager::ResourceMapIterator itMat =
+            MaterialManager::getSingleton().getResourceIterator();
+            itMat.hasMoreElements();)
+        {
+            MaterialPtr mat = itMat.getNext();
+            for (Material::TechniqueIterator itTech =
+                mat-&gt;getTechniqueIterator();
+                itTech.hasMoreElements();)
+            {
+                Technique* tech = itTech.getNext();
+                if (tech-&gt;getSchemeName() == tuScheme)
+                {
+                    tech-&gt;setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
+                    mDefaultTechniques.push_back(tech);
+                }
+                else if (tech-&gt;getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
+                {
+                    mDefaultTechniques.push_back(tech);
+                }
+            }
+        }
+    }
+
+    void CoreSubsystem::setScheme(const Ogre::String&amp; schemeName)
+    {
+        if (schemeName != MaterialManager::getSingleton().getActiveScheme())
+        {
+            /*for (std::vector&lt;Technique*&gt;::iterator iter = mDefaultTechniques.begin();
+                iter != mDefaultTechniques.end(); ++iter)
+            {
+                Technique* cur = *iter;
+                cur-&gt;setSchemeName(schemeName);
+            }*/
+
+            MaterialManager::getSingleton().setActiveScheme(schemeName);
+        }
+    }
+
+    void CoreSubsystem::startAdventureModule(ContentModule* module)
+    {
+        if (mActiveAdventureModule != NULL)
+        {
+            mActiveAdventureModule-&gt;unload();
+        }
+
+        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(0.0));
+
+        updateDefaultScheme();
+        loadModule(module);
+        mActiveAdventureModule = module;
+
+        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(100.0));
+        
+        module-&gt;start();
+    }
+
+    void CoreSubsystem::loadModule(ContentModule* module)
+    {
+        if (module-&gt;getMinimumEngineVersion() &gt; getEngineBuildNumber())
+        {
+            Throw(
+                rl::RuntimeException,
+                &quot;Module &quot;
+                + Ogre::String(module-&gt;getName().c_str())
+                + &quot; needs engine &gt;=&quot;
+                + StringConverter::toString(module-&gt;getMinimumEngineVersion())
+                + &quot; but engine is &quot;
+                + StringConverter::toString(getEngineBuildNumber()));
+        }
+
+        StringVector deps = module-&gt;getDependencies();
+        for (StringVector::const_iterator depsIt = deps.begin(); depsIt != deps.end(); depsIt++)
+        {
+            Ogre::String depName = *depsIt;
+            ModuleMap::iterator modIt = mModules.find(depName);
+            if (modIt == mModules.end())
+            {
+                Throw(
+                    rl::RuntimeException,
+                    &quot;Depedency Module &quot; + depName
+                    + &quot; needed by &quot; + Ogre::String(module-&gt;getName().c_str())
+                    + &quot; not found.&quot;);
+            }
+
+            ContentModule* depMod = (*modIt).second;
+
+            if (!depMod-&gt;isLoaded())
+            {
+                loadModule(depMod);
+            }
+        }
+
+        LOG_MESSAGE(
+            Logger::CORE,
+            &quot;Start initializing module &quot; + module-&gt;getName());
+        module-&gt;initializeTextures();
+        module-&gt;initialize();
+
+        ResourceGroupManager::getSingleton().initialiseResourceGroup(module-&gt;getId());
+        module-&gt;precreateMeshes();
+
+        if (module-&gt;isCommon())
+        {
+            module-&gt;start();
+        }
+
+        LOG_MESSAGE(
+            Logger::CORE,
+            &quot;Module &quot; + module-&gt;getName() + &quot; initialized.&quot;);
+    }
+
+    void CoreSubsystem::setDefaultActiveModule(const Ogre::String&amp; module)
+    {
+        mDefaultActiveModule = module;
+    }
+
+    const Ogre::String&amp; CoreSubsystem::getDefaultActiveModule() const
+    {
+        return mDefaultActiveModule;
+    }
+
+    World* CoreSubsystem::getWorld()
+    {
+        return mWorld;
+    }
+
+    const Ogre::String CoreSubsystem::getEngineVersionString() const
+    {
+        static Ogre::String version = &quot;0.3.0&quot;;
+        return version;
+    }
+
+    const Ogre::String CoreSubsystem::getEngineVersionName() const
+    {
+        static Ogre::String version = &quot;Internal Build&quot;;
+        return version;
+    }
+
+    long CoreSubsystem::getEngineBuildNumber() const
+    {
+        static const Ogre::String sMonths[] =
+        {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;,
+         &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
+
+        Ogre::String dateStr = Ogre::String(__DATE__);
+        Ogre::String monthStr = dateStr.substr(0,3);
+        int day = Ogre::StringConverter::parseInt(dateStr.substr(4,2));
+        int year = Ogre::StringConverter::parseInt(dateStr.substr(7,4));
+        int month = 0;
+
+        while( month &lt; 12 &amp;&amp; monthStr.compare(sMonths[month]) != 0 )
+            month++;
+
+        return /* Jahr */          year * 100000 +
+               /* Monat */         (month+1) * 1000 +
+               /* Tag */           day * 10 +
+               /* Sub-Version */   0;
+    }
+
+    RubyInterpreter* CoreSubsystem::getRubyInterpreter()
+    {
+        return mRubyInterpreter;
+    }
+
+    void CoreSubsystem::makeScreenshot( const Ogre::String&amp; sName )
+    {
+        mRenderWindow-&gt;writeContentsToTimestampedFile(sName, &quot;.png&quot;);
+    }
+
+    ContentModule* CoreSubsystem::getActiveAdventureModule() const
+    {
+        return mActiveAdventureModule;
+    }
+
+    const ModuleMap&amp; CoreSubsystem::getAllModules() const
+    {
+        return mModules;
+    }
+
     void CoreSubsystem::loadPlugin(const Ogre::String&amp; plugin)
     {
         Ogre::String pluginFile;
@@ -590,27 +590,27 @@
 #endif
         
         Ogre::Root::getSingleton().loadPlugin(pluginFile);
-    }
-
-    void CoreSubsystem::loadPlugins()
-    {
-        mSoundManager-&gt;applySettings(rl::ConfigurationManager::getSingleton().getSettings(&quot;Sound&quot;));
-        LOG_MESSAGE(Logger::CORE, &quot;Soundeinstellungen geladen&quot;);
-    }
-
-    void CoreSubsystem::unloadPlugins()
-    {
-        mSoundManager-&gt;unloadAllDrivers();
-        LOG_MESSAGE(Logger::CORE, &quot;Soundtreiber entladen&quot;);
-    }
-
-    void CoreSubsystem::_setCurrentScene(const CeGuiString&amp; scene)
-    {
-        mCurrentScene = scene;
-    }
-
-    const CeGuiString&amp; CoreSubsystem::getCurrentScene() const
-    {
-        return mCurrentScene;
-    }
-}
+    }
+
+    void CoreSubsystem::loadPlugins()
+    {
+        mSoundManager-&gt;applySettings(rl::ConfigurationManager::getSingleton().getSettings(&quot;Sound&quot;));
+        LOG_MESSAGE(Logger::CORE, &quot;Soundeinstellungen geladen&quot;);
+    }
+
+    void CoreSubsystem::unloadPlugins()
+    {
+        mSoundManager-&gt;unloadAllDrivers();
+        LOG_MESSAGE(Logger::CORE, &quot;Soundtreiber entladen&quot;);
+    }
+
+    void CoreSubsystem::_setCurrentScene(const CeGuiString&amp; scene)
+    {
+        mCurrentScene = scene;
+    }
+
+    const CeGuiString&amp; CoreSubsystem::getCurrentScene() const
+    {
+        return mCurrentScene;
+    }
+}

Modified: rl/branches/persistence2/engine/core/src/GameLoop.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameLoop.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/core/src/GameLoop.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -22,6 +22,7 @@
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;FixRubyHeaders.h&quot;
 #include &quot;Exception.h&quot;
+#include &quot;Sleep.h&quot;
 
 #include &lt;numeric&gt;
 
@@ -141,7 +142,7 @@
 
         if( unsmoothedFrameTime &lt; mMinFrameTime*1000 )
         {
-            //usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            msleep(floor((mMinFrameTime*1000 - unsmoothedFrameTime)));
             elapsedTime = mTimer-&gt;getMilliseconds();
             unsmoothedFrameTime = elapsedTime - mGameTime;
             if( elapsedTime &lt; mGameTime )

Modified: rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -66,7 +66,14 @@
 		setAttributeValueAsString(mDocument-&gt;getDocumentElement(), &quot;SaveGameFormatVersion&quot;, &quot;0.8&quot;);
 		setAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;, CoreSubsystem::getSingleton().getEngineBuildNumber());
 
+        DOMElement* header = appendChildElement(mDocument, mDocument-&gt;getDocumentElement(), &quot;header&quot;);
+        PropertyRecordPtr headerSet = file-&gt;getAllProperties();
+        for (PropertyRecord::PropertyRecordMap::const_iterator it_header = headerSet-&gt;begin(); it_header != headerSet-&gt;end(); it_header++)
+        {
+            this-&gt;processProperty(header, PropertyEntry(it_header-&gt;first.c_str(), it_header-&gt;second));
+        }
 
+
         mWriter-&gt;writeNode(mTarget, *mDocument);
 
         mWriter-&gt;release();

Modified: rl/branches/persistence2/engine/script/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/script/CMakeLists.txt	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/script/CMakeLists.txt	2009-03-03 19:45:40 UTC (rev 4787)
@@ -15,8 +15,8 @@
 ${RUBY_INCLUDE_PATH})
 
 SET_SOURCE_FILES_PROPERTIES(swig/RlExports.i PROPERTIES 
-        CPLUSPLUS ON
-        SWIG_FLAGS -minherit)
+	CPLUSPLUS ON
+	SWIG_FLAGS -minherit)
 
 SWIG_ADD_MODULE(RlScript RUBY
 swig/RlExports.i

Modified: rl/branches/persistence2/engine/script/swig/RlAi.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlAi.swig	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/script/swig/RlAi.swig	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -20,7 +20,7 @@
 	%template(Ogrevec3Vector) vector&lt;Ogre::Vector3 &gt;;
 };
 
-namespace rl 
+namespace rl
 {
 	// Before first use
 	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
@@ -44,7 +44,7 @@
 		bool isAhead(rl::Agent* agent, const float threshold);
 		bool needAvoidance(const float minTimeToCollision);
 	};
-	
+
 	%feature(&quot;director&quot;) SteeringBehaviour;
 	class SteeringBehaviour
 	{
@@ -58,28 +58,28 @@
 		virtual void update(const float elapsedTime)=0;
 
 		virtual float calculateActivation()=0;
-		
+
 		float getActivationLevel();
 		void setActivationLevel(float activationLevel);
 
 		rl::SteeringBehaviour* getParent();
 		rl::SteeringVehicle* getController();
 	};
-	
+
 	%feature(&quot;director&quot;) AgentState;
     class AgentState
     {
     private:
         AgentState(rl::Agent* agent);
     };
-    
-    
+
+
     class AgentSteeringState : public rl::AgentState
     {
     public:
         void addSteeringBehaviour(SteeringBehaviour* behaviour);
     };
-   
+
     class AgentDialogState : public rl::AgentState
     {
     public:
@@ -90,7 +90,7 @@
     };
 
     typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
-	
+
 	class Agent
 	{
 	public:
@@ -101,12 +101,12 @@
         void pushState(rl::AgentStateType type);
 	};
 
-	class AiSubsystem 
+	class AiSubsystem
 	{
 	public:
 		static AiSubsystem&amp; getSingleton(void);
 	};
-	
+
 	%feature(&quot;director&quot;) BehaviourFactory;
     class BehaviourFactory
     {
@@ -116,16 +116,16 @@
 
         virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String&amp; classname) = 0;
     };
-    
+
 	class AgentManager
 	{
-	public:		
+	public:
 		static AgentManager&amp; getSingleton(void);
 		rl::Agent* createAgent(rl::Creature* character);
-		
+
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};
-	
+
 	class AStarHeuristic
 	{
 	public:
@@ -133,7 +133,7 @@
 		virtual ~AStarHeuristic();
 		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const = 0;
 	};
-	
+
 	class ManhattanDistance
 		: public rl::AStarHeuristic
 	{
@@ -168,26 +168,26 @@
 		EuclideanDistanceSquared();
 		virtual ~EuclideanDistanceSquared();
 		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
-	}; 
-	
+	};
+
 	class AStarCosts
 	{
 	public:
-		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
+		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
 		virtual ~AStarCosts();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const = 0;
 	};
-	
+
 	class AStarCostsDefault : public AStarCosts
 	{
 	public:
-		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
+		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
 		~AStarCostsDefault();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const;
 	};
-	
+
 	class AStar
 	{
 	public:
@@ -195,40 +195,40 @@
 		//AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
 		//	const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
 		virtual ~AStar();
-		
+
 		void search(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath);
 		void searchFromTo(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath,
 			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
 		void reset();
 	};
-	
+
     class PhysicalObstacle {
-        
+
         public:
             PhysicalObstacle(rl::PhysicalThing *thing);
             virtual ~PhysicalObstacle();
-            
+
             OpenSteer::Obstacle *getObstacle() const;
-            
+
             rl::PhysicalThing *getPhysicalThing() const;
             void setPhysicalThing(rl::PhysicalThing *thing);
     };
-    
+
     class WayPointNode
 	{
 	public:
-		enum WayPointNodeType 
+		enum WayPointNodeType
 		{
 			WP_UNKNOWN = 0,
 			WP_EXTERIOR = 1,
 			WP_INTERIOR = 2
 		};
-		
+
 		WayPointNode(const Ogre::Vector3&amp; pos, const rl::WayPointNode::WayPointNodeType type);
 		Ogre::Vector3 getPosition() const;
 	};
-	
-	class WayPointGraph 
+
+	class WayPointGraph
 	{
 	public:
 		WayPointNode* addWayPoint(const Ogre::Vector3&amp; position, const WayPointNode::WayPointNodeType type);
@@ -238,14 +238,14 @@
 		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3&amp; position) const;
 		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
 	};
-	
-	class WayPointGraphManager 
+
+	class WayPointGraphManager
 	{
 	public:
 		static WayPointGraphManager&amp; getSingleton(void);
 		rl::WayPointGraph* createWayPointGraph();
 	};
-	
+
 	class Landmark
 	{
 	public:
@@ -253,7 +253,7 @@
 		const Ogre::String&amp; getName() const;
 		const Ogre::Vector3&amp; getPosition() const;
 	};
-	
+
 	class LandmarkPath
 	{
 	public:
@@ -264,7 +264,7 @@
 		void addPoint(rl::Landmark* lm);
         rl::LandmarkPath::LandmarkList getPoints();
 	};
-	
+
     class WalkPathBehaviour : public rl::SteeringBehaviour
 	{
 	public:
@@ -280,7 +280,7 @@
 
 		virtual float calculateActivation();
 	};
-	
+
 	class CreatureWalkPathJob : public Job
     {
     public:
@@ -301,8 +301,8 @@
     {
     public:
         static rl::DialogManager&amp; getSingleton();
-        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc, rl::Creature* pc);
-        rl::Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;rl::Creature*&gt;&amp; npcs, const std::vector&lt;rl::Creature*&gt;&amp; pcs);
+        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc);
+        rl::Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;rl::Creature*&gt;&amp; npcs);
     private:
         DialogManager();
     };
@@ -337,7 +337,7 @@
         *ptr=pEuclideanDistanceSquared;
         return SWIGTYPE_p_rl__EuclideanDistanceSquared;
     }
-   
+
     return 0;
 }
 %}
@@ -355,7 +355,7 @@
         *ptr=pAStarCostsDefault;
         return SWIGTYPE_p_rl__AStarCostsDefault;
     }
-   
+
     return 0;
 }
 %}
@@ -373,14 +373,14 @@
         *ptr=pAgentDialogState;
         return SWIGTYPE_p_rl__AgentDialogState;
     }
-    
+
     rl::AgentSteeringState *pAgentSteeringState = dynamic_cast&lt;rl::AgentSteeringState*&gt;(pAgentState);
     if (pAgentSteeringState)
     {
         *ptr=pAgentSteeringState;
         return SWIGTYPE_p_rl__AgentSteeringState;
     }
-   
+
     return 0;
 }
 %}

Modified: rl/branches/persistence2/engine/ui/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/ui/CMakeLists.txt	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ui/CMakeLists.txt	2009-03-03 19:45:40 UTC (rev 4787)
@@ -29,6 +29,7 @@
 src/Console.cpp
 src/CutsceneControlState.cpp
 src/DebugWindow.cpp
+src/DialogController.cpp
 src/DialogControlState.cpp
 src/DialogWindow.cpp
 src/FreeflightControlState.cpp

Modified: rl/branches/persistence2/engine/ui/include/CutsceneControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/CutsceneControlState.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ui/include/CutsceneControlState.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -61,6 +61,7 @@
         void addCamera(const Ogre::Vector3&amp; position, const Ogre::Quaternion&amp; orientation);
         void addCamera(const Ogre::Vector3&amp; position, const Ogre::Quaternion&amp; orientation1,
                        const Ogre::Quaternion&amp; orientation2);
+        void clearCameras();
 
 	private:
 	    std::vector&lt;CameraPosition&gt; mPositions;

Modified: rl/branches/persistence2/engine/ui/include/DialogControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/DialogControlState.h	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ui/include/DialogControlState.h	2009-03-03 19:45:40 UTC (rev 4787)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,33 +18,29 @@
 #define __DialogCharacterController_H__
 
 #include &quot;UiPrerequisites.h&quot;
-#include &quot;ControlState.h&quot;
+#include &quot;DialogController.h&quot;
 
-
 namespace rl {
 
 	class Actor;
+    class Creature;
 	class Dialog;
     class DialogElement;
-	class DialogOption;
-	class DialogParagraph;
-	class DialogResponse;
 	class DialogWindow;
 	class GameLoggerWindow;
-    class GameObject;
 	class MeshAnimation;
 	class SoundObject;
 	class SubtitleWindow;
 
-	/** Diese Klasse 
-	  *  
+	/** Diese Klasse
+	  *
 	  */
-	class _RlUiExport DialogControlState : public ControlState
+	class _RlUiExport DialogControlState : public DialogController
 	{
 	public:
         enum DialogMode
-		{ 
-            // Frontperspektive auf Augenh&#246;he, ausgehend von der Mitte zwischen den Redenden
+		{
+            // Frontperspektive auf Augenh&#239;&#191;&#189;he, ausgehend von der Mitte zwischen den Redenden
 			DM_FRONT = 1,
 		};
 
@@ -54,7 +50,7 @@
 		*  @throw InvalidArgumentException if character is not placed in the scene.
 		*/
 		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Creature* character);
-		/// Dtor 
+		/// Dtor
 		virtual ~DialogControlState();
 
         virtual void pause();
@@ -65,71 +61,40 @@
 
 		void start(Dialog* dialog);
 
-		/// Antwort eines der Dialogf&#252;hrenden
+		/// Antwort eines der Dialogf&#239;&#191;&#189;hrenden
 		void response(Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile = &quot;&quot;);
 
-        virtual bool mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled);
-
-		bool handleDialogSelectOption(DialogOption* option);	
-		bool handleDialogClose();
+		bool handleDialogSelectOption(DialogOption* option);
+		virtual void handleDialogEnd();
 		bool requestDialogClose();
+	    virtual bool textFinished();
 
 	private:
+        enum DialogState
+        {
+            CHOOSING_OPTION = 1,
+            TALKING_PARTNER_CHARACTER,
+            TALKING_PLAYER_CHARACTER,
+            CLOSING_DIALOG
+        };
+
 		/// Die Zielkameraposition in lokalen Koordinaten
 		Ogre::Vector3 mTargetCameraPosition;
-		/// Die ben&#246;tigte lokale Drehung der Kamera
+		/// Die ben&#239;&#191;&#189;tigte lokale Drehung der Kamera
 		Ogre::Vector3 mTargetCameraDirection;
 
-		/// Die aktuelle Zeit f&#252;r die Textanzeige
-		Ogre::Real mCurrFadeTextTime;
-        /// Die Zeit bis der Text ausgeblendet wird
-        Ogre::Real mTotalFadeTextTime;
 
-        Ogre::Real mSubtitleSpeed;
-
-		/// Der Untertitel-Text
-		CeGuiString mText;
-		/// Es wird gerade Text angezeigt
-		bool mTextShown;
-
-		GameObject* mCurrentSpeaker;
-		GameObject* mCurrentListener;
-        DialogResponse* mCurrentResponse;
-        DialogOption* mCurrentOption;
-        std::list&lt;DialogParagraph*&gt; mCurrentParagraphs;
-
-        /// Die Art der Kamerapositinierung
+        /// Die Art der Kamerapositionierung
         DialogMode mDialogMode;
 
-		MeshAnimation* mTalkAnimation;
+        DialogState mDialogState;
 
+
 		DialogWindow* mDialogWindow;
-		SubtitleWindow* mSubtitleWindow;
-		SoundObject* mSoundObject;
-	
-		float getShowTextLength(const CeGuiString&amp; text) const;
-        void recalculateCamera(GameObject* speaker, GameObject* listener);
-        void processTextVariables(CeGuiString&amp; text);
 
-		enum DialogState
-		{
-			CHOOSING_OPTION = 1,
-			TALKING_PARTNER_CHARACTER,
-			TALKING_PLAYER_CHARACTER,
-			CLOSING_DIALOG
-		};
+        virtual void recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners);
 
-		Dialog* mDialog;
-		GameLoggerWindow* mGameLogger;
-		DialogState mState;
-		CeGuiString mCurrentResponseText;
-				
-        void showResponse(DialogResponse* response);
         void showOptions(const std::list&lt;DialogOption*&gt;&amp; options);
-        void doTalk(DialogParagraph* paragraph);
-        Ogre::Vector3 getParticipantPosition(GameObject* participant);
-
-		void textFinished();
 	};
 }
 #endif

Copied: rl/branches/persistence2/engine/ui/include/DialogController.h (from rev 4779, rl/trunk/engine/ui/include/DialogController.h)

Modified: rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -110,4 +110,9 @@
         CameraPosition cpos = {CPT_ROTATING, position, orientation1, orientation2};
         mPositions.push_back(cpos);
     }
+
+    void CutsceneControlState::clearCameras()
+    {
+        mPositions.clear();
+    }
 }

Modified: rl/branches/persistence2/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/DialogControlState.cpp	2009-03-03 19:27:03 UTC (rev 4786)
+++ rl/branches/persistence2/engine/ui/src/DialogControlState.cpp	2009-03-03 19:45:40 UTC (rev 4787)
@@ -53,40 +53,26 @@
 #endif
 
 using namespace Ogre;
+using namespace std;
 
 namespace rl {
 
     DialogControlState::DialogControlState(CommandMapper* cmdMapper,
         Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_DIALOG),
+        : DialogController(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
-        mCurrFadeTextTime(0),
-        mTotalFadeTextTime(0),
-        mText(),
-        mDialogMode(DM_FRONT),
-        mTextShown(false),
-        mDialogWindow(NULL),
-        mSubtitleWindow(NULL),
-        mSoundObject(NULL),
-        mTalkAnimation(NULL),
-        mSubtitleSpeed(1.0f),
-		mCurrentResponseText(&quot;&quot;),
-		mGameLogger(NULL),
-        mCurrentSpeaker(NULL),
-        mCurrentListener(NULL)
+        mDialogMode(DM_FRONT)
     {
-        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
-            &quot;General&quot;, &quot;Subtitle Speed&quot;);
     }
 
     DialogControlState::~DialogControlState()
     {
-        delete mSoundObject;
     }
 
     void DialogControlState::pause()
     {
+        DialogController::pause();
         /*
         if (mDialogPartner)
         {
@@ -95,7 +81,7 @@
             {
                 mesh-&gt;stopAllAnimations();
                 if (mesh-&gt;hasAnimation(&quot;idle&quot;))
-                { 
+                {
                     mTalkAnimation = mesh-&gt;startAnimation(&quot;idle&quot;);
                 }
             }
@@ -103,8 +89,6 @@
         */
         //mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
         //mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
-        mDialogWindow-&gt;setVisible(false, false);
-        mSubtitleWindow-&gt;setVisible(false, false);
     }
 
     void DialogControlState::resume()
@@ -127,6 +111,8 @@
         {
             mSubtitleWindow = new SubtitleWindow();
         }
+
+
         mDialogWindow-&gt;setVisible(true);
         mSubtitleWindow-&gt;setVisible(true);
 
@@ -155,12 +141,10 @@
 		if (!mDialog || !mDialogWindow)
 		{
             LOG_ERROR(Logger::UI, &quot;DialogControlState not properly initialized.&quot;);
-            handleDialogClose();
+            handleDialogEnd();
             return;
 		}
         mDialog-&gt;setProperty(Dialog::PROP_EXIT_REQUESTED, false);
-        mCurrentSpeaker = mDialog-&gt;getNpc(0);
-        mCurrentListener = mDialog-&gt;getPc(0);
         showResponse(mDialog-&gt;getDialogStart());
 	}
 
@@ -211,11 +195,11 @@
                 + StringConverter::toString(mCurrFadeTextTime));
     }
 
-    void DialogControlState::recalculateCamera(GameObject* speaker, GameObject* listener)
+    void DialogControlState::recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners)
     {
         // Position camera at position between char and dialog partner
         Vector3 speakerEyes = getParticipantPosition(speaker);
-        Vector3 listenerEyes = getParticipantPosition(listener);
+        Vector3 listenerEyes = getParticipantPosition(listeners.front()); ///@FIXME, this is just using the 1st listener
         Vector3 globalCameraPosition = (speakerEyes + listenerEyes) / 2.0f;
 
         // Weltkoordinaten in lokale umwandeln
@@ -226,335 +210,95 @@
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }
 
-    Vector3 DialogControlState::getParticipantPosition(GameObject* participant)
-    {
-        Vector3 eyesPosition = participant-&gt;getPosition();
 
-        // Modify by MeshBounds
-        if (participant-&gt;getActor() &amp;&amp; participant-&gt;getActor()-&gt;getControlledObject()-&gt;isMeshObject())
+	void DialogControlState::handleDialogEnd()
+	{
+		InputManager::getSingleton().popControlState();
+		mDialogWindow-&gt;setVisible(false, true);
+		mSubtitleWindow-&gt;setVisible(false, true);
+        mDialogWindow = NULL;
+        mSubtitleWindow = NULL;
+        if (mDialog != NULL)
         {
-            MeshObject* mo = static_cast&lt;MeshObject*&gt;(participant-&gt;getActor()-&gt;getControlledObject());
-            Ogre::AxisAlignedBox aab = mo-&gt;getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y * 0.933,
-                aab.getCenter().z);
-            eyesPosition += participant-&gt;getOrientation() * offset;
-        }
-
-        return eyesPosition;
-    }
-
-    float DialogControlState::getShowTextLength(const CeGuiString&amp; text) const
-    {
-        return 0.019f * text.length() + // Zeit f&#195;&#188;rs Text lesen
-               0.25f;                   // Fade in
-    }
-
-    void DialogControlState::processTextVariables(CeGuiString&amp; text)
-    {
-        CeGuiString newText = text;
-        CeGuiString::size_type pos = CeGuiString::npos;
-        do
-        {
-            pos = newText.find(&quot;{$&quot;);
-            if (pos != CeGuiString::npos)
+            const list&lt;Creature*&gt; list = mDialog-&gt;getParticipants();
+            for (std::list&lt;Creature*&gt;::const_iterator it = list.begin(); it != list.end(); ++it)
             {
-                CeGuiString::size_type endpos = newText.find(&quot;}&quot;, pos);
-                if (endpos != CeGuiString::npos)
+                Actor* actor = (*it)-&gt;getActor();
+                if (actor != NULL)
                 {
-                    CeGuiString varName = newText.substr(pos+2, endpos - pos - 2);
-                    CeGuiString varValue = mDialog-&gt;getVariableValue(varName.c_str());
-                    newText = newText.replace(pos, endpos - pos + 1, varValue);
+                    MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
+                    if (mesh != NULL &amp;&amp; mesh-&gt;hasAnimation(&quot;reden&quot;))
+                    {
+                        mesh-&gt;stopAnimation(&quot;reden&quot;);
+                    }
                 }
             }
         }
-        while (pos != CeGuiString::npos);
-        text.assign(newText);
-    }
-
-    void DialogControlState::doTalk(DialogParagraph* paragraph)
-    {
-        mDialogWindow-&gt;setVisible(false);
-        Ogre::String soundFile = paragraph-&gt;getVoiceFile();
-        CeGuiString text = paragraph-&gt;getText();
-        // if there is no text in the paragraph, go directly to the next entry!
-        if(text.empty())
-        {
-            textFinished();
-            return;
-        }
-        processTextVariables(text);
-
-        recalculateCamera(mCurrentListener, mCurrentSpeaker);
-
-        Actor* actor = mCurrentSpeaker-&gt;getActor();
-        // @todo: find out why we don't here anything if the sound is attached to the player
-        // atm, we attach it everytime to the npc to here at least anything
-        actor = mDialog-&gt;getNpc(0)-&gt;getActor();
-        // Ungef&#195;&#164;hre Lesedauer bestimmen
-        float fadeTime = getShowTextLength(text);
-        if (soundFile.length() == 0)
-        {
-            float speed = mSubtitleSpeed;
-
-            if (mSubtitleSpeed == 0.0)
-                speed = 1.0;
-
-            mCurrFadeTextTime = fadeTime*speed;
-            mTotalFadeTextTime = fadeTime*speed;
-        }
         else
         {
-            if (mSoundObject != NULL)
-            {
-                mSoundObject-&gt;getMovableObject()-&gt;getParentSceneNode()-&gt;detachObject(
-                    mSoundObject-&gt;getMovableObject());
-                delete mSoundObject;
-            }
-
-            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()-&gt;
-                    createSound(soundFile, ST_SAMPLE), soundFile);
-
-            // An Sprecher h&#195;&#164;ngen
-            actor-&gt;_getSceneNode()-&gt;attachObject(mSoundObject-&gt;getMovableObject());
-            actor-&gt;_getSceneNode()-&gt;_update(true, false);
-            mSoundObject-&gt;_setActor(actor);
-            mSoundObject-&gt;set3d(true);
-            mSoundObject-&gt;play();
-            mSoundObject-&gt;_update();
-
-
-            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject-&gt;getLength());
-            mTotalFadeTextTime = mCurrFadeTextTime;
+            LOG_ERROR(Logger::UI, &quot;There is no Dialog to be closed!&quot;);
         }
+	}
 
-        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
-        if (mesh != NULL)
-        {
-            if (mesh-&gt;hasAnimation(&quot;reden&quot;))
-            {
-                mesh-&gt;stopAllAnimations();
-                mTalkAnimation = mesh-&gt;startAnimation(&quot;reden&quot;);
-            }
-        }
-
-        LOG_DEBUG(Logger::UI,
-            &quot;Response: &quot;
-                + actor-&gt;getName()
-                + &quot; File: '&quot;
-                + soundFile
-                + &quot;', Text: '&quot; + text + &quot;', Time: &quot;
-                + StringConverter::toString(mCurrFadeTextTime));
-
-
-        mTextShown = true;
-
-        if (mSubtitleWindow != NULL &amp;&amp; !text.empty())
-        {
-            mSubtitleWindow-&gt;show(text);
-        }
-    }
-
-    bool DialogControlState::mouseReleased(const OIS::MouseEvent&amp; evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        bool retval = false;
-        if (ControlState::mouseReleased(evt, id, handled))
-            retval = true;
-
-        if (!handled &amp;&amp; !retval)
-        {
-            if (mTextShown &amp;&amp; 
-                (mCurrFadeTextTime + 0.25 &lt; mTotalFadeTextTime))
-            {
-                mCurrFadeTextTime = -1;
-                retval = true;
-            }
-        }
-
-        return retval;
-    }
-
-    void DialogControlState::showResponse(DialogResponse* response)
+	bool DialogControlState::requestDialogClose()
 	{
-        if (!response)
-		{
-            LOG_MESSAGE(Logger::UI, &quot;No response found! Close Dialog!&quot;);
-			mDialogWindow-&gt;setDialogEnd();
-			mState = CLOSING_DIALOG;
-			handleDialogClose();
-			return;
-		}
-
-		if (response-&gt;isSelection())
-		{
-			DialogResponseSelection* sel = static_cast&lt;DialogResponseSelection*&gt;(response);
-			mCurrentResponse = sel-&gt;getSelectedElement(mDialog);
-		}
-		else
-		{
-			mCurrentResponse = response;
-		}
-	
-        mState = TALKING_PARTNER_CHARACTER;
-        mCurrentOption = NULL;
-
-		mDialogWindow-&gt;setVisible(false);
-
-        mCurrentListener = mDialog-&gt;getPc(0);
-        mCurrentSpeaker = mCurrentResponse-&gt;getNpc(mDialog);
-        mCurrentParagraphs = mCurrentResponse-&gt;getParagraphs(mDialog);
-        if(!mCurrentParagraphs.empty())
-        {
-            DialogParagraph* firstParagraph = mCurrentParagraphs.front();
-            mCurrentResponse-&gt;applyImplications(mDialog);
-            // does this paragraph contain a response?
-            if (!firstParagraph-&gt;getResponse())
-            {
-                // no, so directly start with the first paragraph
-                doTalk(firstParagraph);
-            }
-            else if(mCurrentParagraphs.size() &gt; 1)
-            {
-                // yes, but there are other paragraphs in the list.
-                // the response should be executed at last, so we put it back to the end
-                mCurrentParagraphs.pop_front();
-                mCurrentParagraphs.push_back(firstParagraph);
-                firstParagraph = mCurrentParagraphs.front();
-                // we don't allow more than one goto per response
-                if(firstParagraph-&gt;getResponse())
-                {
-                    LOG_ERROR(Logger::UI, &quot;To many gotoresponses in response with id: &quot; 
-                        + mCurrentResponse-&gt;getId()); 
-                    handleDialogClose();
-                }
-                else
-                {
-                    doTalk(firstParagraph);
-                }
-            }
-            else
-            {
-                // we only have a response as paragraph, execute it!
-                showResponse(firstParagraph-&gt;getResponse());
-            }
-        }
-        else
-        {
-            handleDialogClose();
-        }
+	//	handleClose is called automatically
+        handleDialogEnd();
+		//@todo
+		return true;
 	}
 
-	void DialogControlState::textFinished()
+
+	bool DialogControlState::textFinished()
 	{
-		if (mDialog-&gt;isExitRequested())
-		{
-			handleDialogClose();
-			return;
-		}
 
-        mCurrentParagraphs.pop_front();
-        if (!mCurrentParagraphs.empty())
+        if (!DialogController::textFinished())
         {
-            DialogParagraph* curParagraph = mCurrentParagraphs.front();
-            if (curParagraph-&gt;getResponse() == NULL)
+            if (mDialogState == TALKING_PARTNER_CHARACTER)
             {
-                doTalk(curParagraph);
-            }
-            else
-            {
-                showResponse(curParagraph-&gt;getResponse());
-            }
-        }
-        else
-        {
-		    if (mState == TALKING_PARTNER_CHARACTER)
-		    {
-                mCurrentListener = mCurrentResponse-&gt;getNpc(mDialog);
-                mCurrentSpeaker = mDialog-&gt;getPc(0);
 
                 DialogResponse::Options options = mCurrentResponse-&gt;getAvailableOptions(mDialog);
                 // if there is just one option and it is an auto selected one,
                 // display it.
-                if(options.size() == 1 &amp;&amp;  options.front()-&gt;isAutoSelected())
+                if (options.size() == 1 &amp;&amp;  options.front()-&gt;isAutoSelected())
                 {
                     handleDialogSelectOption(options.front());
-                    return;
+                    return true;
                 }
                 mDialogWindow-&gt;setAvailableOptions(options);
-		        mDialogWindow-&gt;setVisible(true);
-		        mState = CHOOSING_OPTION;
-		    }
-            else if (mState == TALKING_PLAYER_CHARACTER)
+                mDialogWindow-&gt;setVisible(true);
+                mDialogState = CHOOSING_OPTION;
+            }
+            else if (mDialogState == TALKING_PLAYER_CHARACTER)
             {
                 showResponse(mCurrentOption-&gt;getResponse());
             }
         }
 
-		LOG_DEBUG(Logger::UI,
-					StringConverter::toString(mState)
-					+ &quot; bei textFinished&quot;);
-	}
+        LOG_DEBUG(Logger::UI,
+                    StringConverter::toString(mDialogState)
+                    + &quot; bei textFinished&quot;);
 
-	bool DialogControlState::handleDialogSelectOption(DialogOption* option)
-	{
-		if (option-&gt;isSelection())
-		{
-			DialogOptionSelection* sel = static_cast&lt;DialogOptionSelection*&gt;(option);
-			mCurrentOption = sel-&gt;getSelectedElement(mDialog);
-		}
-		else
-		{
-			mCurrentOption = option;
-		}
-        mState = TALKING_PLAYER_CHARACTER;
-        mCurrentListener = mDialog-&gt;getNpc(0);
-        mCurrentSpeaker = mDialog-&gt;getPc(0); ///@todo allow char switch 
-        mCurrentParagraphs = mCurrentOption-&gt;getParagraphs(mDialog);
-        doTalk(mCurrentParagraphs.front());
-
-		return true;
+        return true;
 	}
 
-	bool DialogControlState::handleDialogClose()
-	{
-		InputManager::getSingleton().popControlState();
-		mDialogWindow-&gt;setVisible(false, true);
-		mSubtitleWindow-&gt;setVisible(false, true);
-        mDialogWindow = NULL;
-        mSubtitleWindow = NULL;
-        if (mDialog != NULL)
+    bool DialogControlState::handleDialogSelectOption(DialogOption* option)
+    {
+        if (option-&gt;isSelection())
         {
-            const std::vector&lt;Creature*&gt; list = mDialog-&gt;getPlayerCharacters();
-            for (std::vector&lt;Creature*&gt;::const_iterator it = list.begin(); it != list.end(); ++it)
-            {
-                Actor* actor = (*it)-&gt;getActor();
-                if (actor != NULL)
-                {
-                    MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
-                    if (mesh != NULL &amp;&amp; mesh-&gt;hasAnimation(&quot;reden&quot;))
-                    {
-                        mesh-&gt;stopAnimation(&quot;reden&quot;);
-                    }
-                }        
-            }
-            return true;
+            DialogOptionSelection* sel = static_cast&lt;DialogOptionSelection*&gt;(option);
+            mCurrentOption = sel-&gt;getSelectedElement(mDialog);
         }
         else
         {
-            LOG_ERROR(Logger::UI, &quot;There is no Dialog to be closed!&quot;);
-            return false;
+            mCurrentOption = option;
         }
-	}
 
-	bool DialogControlState::requestDialogClose()
-	{
-	//	handleClose is called automatically
-        handleDialogClose();
-		//@todo
-		return true;
-	}
+        mDialogState = TALKING_PLAYER_CHARACTER;
+        mCurrentParagraphs = mCurrentOption-&gt;getParagraphs(mDialog);
+        doTalk(mCurrentParagraphs.front());
 
+        return true;
+    }
 
 }

Copied: rl/branches/persistence2/engine/ui/src/DialogController.cpp (from rev 4779, rl/trunk/engine/ui/src/DialogController.cpp)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001843.html">[Dsa-hl-svn] r4786 - in dependencies/OgreNewt: . inc
</A></li>
	<LI>Next message: <A HREF="001845.html">[Dsa-hl-svn] r4788 - dependencies/OgreNewt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1844">[ date ]</a>
              <a href="thread.html#1844">[ thread ]</a>
              <a href="subject.html#1844">[ subject ]</a>
              <a href="author.html#1844">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
