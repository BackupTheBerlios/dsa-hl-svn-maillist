<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4842 - in rl/trunk: . engine/ai engine/ai/include	engine/ai/include/OpenSteer engine/ai/src engine/ai/src/OpenSteer
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4842%20-%20in%20rl/trunk%3A%20.%20engine/ai%20engine/ai/include%0A%09engine/ai/include/OpenSteer%20engine/ai/src%20engine/ai/src/OpenSteer&In-Reply-To=%3C200903182131.n2ILV7FN022398%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001898.html">
   <LINK REL="Next"  HREF="001900.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4842 - in rl/trunk: . engine/ai engine/ai/include	engine/ai/include/OpenSteer engine/ai/src engine/ai/src/OpenSteer</H1>
    <B>chrber at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4842%20-%20in%20rl/trunk%3A%20.%20engine/ai%20engine/ai/include%0A%09engine/ai/include/OpenSteer%20engine/ai/src%20engine/ai/src/OpenSteer&In-Reply-To=%3C200903182131.n2ILV7FN022398%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4842 - in rl/trunk: . engine/ai engine/ai/include	engine/ai/include/OpenSteer engine/ai/src engine/ai/src/OpenSteer">chrber at mail.berlios.de
       </A><BR>
    <I>Wed Mar 18 22:31:07 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001898.html">[Dsa-hl-svn] r4841 - in rl/trunk/editors/Lockenwickler/src: . media
</A></li>
        <LI>Next message: <A HREF="001900.html">[Dsa-hl-svn] r4843 - in rl/trunk/engine/ai: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1899">[ date ]</a>
              <a href="thread.html#1899">[ thread ]</a>
              <a href="subject.html#1899">[ subject ]</a>
              <a href="author.html#1899">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chrber
Date: 2009-03-18 22:30:59 +0100 (Wed, 18 Mar 2009)
New Revision: 4842

Added:
   rl/trunk/engine/ai/include/OpenSteer/
   rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h
   rl/trunk/engine/ai/include/OpenSteer/Color.h
   rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h
   rl/trunk/engine/ai/include/OpenSteer/Obstacle.h
   rl/trunk/engine/ai/include/OpenSteer/Path.h
   rl/trunk/engine/ai/include/OpenSteer/Pathway.h
   rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
   rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
   rl/trunk/engine/ai/include/OpenSteer/Proximity.h
   rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h
   rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
   rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
   rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
   rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h
   rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h
   rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h
   rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h
   rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h
   rl/trunk/engine/ai/include/OpenSteer/Utilities.h
   rl/trunk/engine/ai/include/OpenSteer/Vec3.h
   rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h
   rl/trunk/engine/ai/include/OpenSteer/lq.h
   rl/trunk/engine/ai/src/OpenSteer/
   rl/trunk/engine/ai/src/OpenSteer/Color.cpp
   rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp
   rl/trunk/engine/ai/src/OpenSteer/Path.cpp
   rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp
   rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
   rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
   rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp
   rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp
   rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp
   rl/trunk/engine/ai/src/OpenSteer/lq.c
Modified:
   rl/trunk/CMakeLists.txt
   rl/trunk/engine/ai/CMakeLists.txt
Log:
Removed check for OpenSteer as it is now bundled with Rastullah
Added portions of OpenSteer being required to build/use Rastullah


Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/CMakeLists.txt	2009-03-18 21:30:59 UTC (rev 4842)
@@ -30,7 +30,6 @@
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
 FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
-FIND_PACKAGE(OpenSteer REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(Ruby REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)

Modified: rl/trunk/engine/ai/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ai/CMakeLists.txt	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/CMakeLists.txt	2009-03-18 21:30:59 UTC (rev 4842)
@@ -43,7 +43,17 @@
 src/WalkPathBehaviour.cpp
 src/WayPointNode.cpp
 src/WayPointGraph.cpp
-src/WayPointGraphManager.cpp)
+src/WayPointGraphManager.cpp
+src/OpenSteer/Color.cpp
+src/OpenSteer/lq.c
+src/OpenSteer/Obstacle.cpp
+src/OpenSteer/Path.cpp
+src/OpenSteer/Pathway.cpp
+src/OpenSteer/PolylineSegmentedPath.cpp
+src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
+src/OpenSteer/SegmentedPath.cpp
+src/OpenSteer/SegmentedPathway.cpp
+src/OpenSteer/Vec3.cpp)
 
 ADD_LIBRARY(RlAi SHARED ${RlAi_LIB_SRCS})
 

Added: rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,107 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// AbstractVehicle: pure virtual base class for generic steerable vehicles
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 01-30-03 cwr: created 
+//
+//
+// ----------------------------------------------------------------------------
+
+#ifndef OPENSTEER_ABSTRACTVEHICLE_H
+#define OPENSTEER_ABSTRACTVEHICLE_H
+
+
+#include &quot;OpenSteer/LocalSpace.h&quot;
+
+
+// STL vector containers
+#include &lt;vector&gt;
+
+
+// ----------------------------------------------------------------------------
+
+namespace OpenSteer {
+
+    class AbstractVehicle : public AbstractLocalSpace 
+    {
+    public:
+        virtual ~AbstractVehicle() { /* Nothing to do. */ }
+        
+        // mass (defaults to unity so acceleration=force)
+        virtual float getMass (void) const = 0;
+        virtual float setMass (float) = 0;
+
+        // size of bounding sphere, for obstacle avoidance, etc.
+        virtual float getRadius (void) const = 0;
+        virtual float setRadius (float) = 0;
+
+        // velocity of vehicle
+        virtual Vector3 getVelocity (void) const = 0;
+
+        // speed of vehicle  (may be faster than taking magnitude of velocity)
+        virtual float getSpeed (void) const = 0;
+        virtual float setSpeed (float) = 0;
+
+        // groups of (pointers to) abstract vehicles, and iterators over them
+        typedef std::vector&lt;AbstractVehicle*&gt; group;
+        typedef group::const_iterator iterator;    
+
+        // predict position of this vehicle at some time in the future
+        // (assumes velocity remains constant)
+        virtual Vector3 predictFuturePosition (const float predictionTime) const = 0;
+
+        // ----------------------------------------------------------------------
+        // XXX this vehicle-model-specific functionality functionality seems out
+        // XXX of place on the abstract base class, but for now it is expedient
+
+        // the maximum steering force this vehicle can apply
+        virtual float getMaxForce (void) const = 0;
+        virtual float setMaxForce (float) = 0;
+
+        // the maximum speed this vehicle is allowed to move
+        virtual float getMaxSpeed (void) const = 0;
+        virtual float setMaxSpeed (float) = 0;
+
+		// dp - added to support heterogeneous flocks
+		virtual void update(const float currentTime, const float elapsedTime) = 0;
+    };
+
+
+    // more convenient short names for AbstractVehicle group and iterator
+    typedef AbstractVehicle::group AVGroup;
+    typedef AbstractVehicle::iterator AVIterator;
+
+} // namespace OpenSteer
+
+
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_ABSTRACTVEHICLE_H

Added: rl/trunk/engine/ai/include/OpenSteer/Color.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Color.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Color.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,153 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// Color class and predefined colors.
+//
+// May 05, 2005 bk:  created 
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_COLOR_H
+#define OPENSTEER_COLOR_H
+
+#include &quot;OpenSteer/Vec3.h&quot;
+
+
+namespace OpenSteer {
+    
+    class Color {
+    public:
+        Color();
+        explicit Color( float greyValue );
+        Color( float rValue, float gValue, float bValue, float aValue = 1.0f );
+        explicit Color( Vector3 const&amp; vector );
+        
+        float r() const;
+        float g() const;
+        float b() const;
+        float a() const;
+        
+        void setR( float value );
+        void setG( float value );
+        void setB( float value );
+		void setA( float value );
+        void set( float rValue, float gValue, float bValue, float aValue = 1.0f );
+        
+        Vector3 convertToVec3() const;
+    
+		// this is necessary so that graphics API's such as DirectX
+		// requiring a pointer to colors can do their conversion
+		// without a lot of copying.
+		float const*const colorFloatArray() const { return &amp;r_; }
+
+        Color&amp; operator+=( Color const&amp; other );
+        
+        /**
+         * @todo What happens if color components become negative?
+         */
+        Color&amp; operator-=( Color const&amp; other );
+        
+        /**
+         * @todo What happens if color components become negative?
+         */
+        Color&amp; operator*=( float factor );
+        
+        /**
+         * @todo What happens if color components become negative?
+         */
+        Color&amp; operator/=( float factor );
+        
+        
+    private:
+        float r_;
+        float g_;
+        float b_;
+		 float a_;	// provided for API's which require four components        
+    }; // class Color
+    
+    
+    Color operator+( Color const&amp; lhs, Color const&amp; rhs );
+    
+    /**
+     * @todo What happens if color components become negative?
+     */
+    Color operator-( Color const&amp; lhs, Color const&amp; rhs );
+    
+    /**
+     * @todo What happens if color components become negative?
+     */
+    Color operator*( Color const&amp; lhs, float rhs );
+    
+    /**
+     * @todo What happens if color components become negative?
+     */
+    Color operator*( float lhs, Color const&amp; rhs );
+    
+    /**
+     * @todo What happens if color components become negative?
+     */
+    Color operator/( Color const&amp; lhs, float rhs );
+    
+    
+    Color grayColor( float value );
+    
+    extern Color const gBlack;
+    extern Color const gWhite; 
+    extern Color const gRed; 
+    extern Color const gGreen;
+    extern Color const gBlue;
+    extern Color const gYellow;
+    extern Color const gCyan;
+    extern Color const gMagenta;
+    extern Color const gOrange;
+    extern Color const gDarkRed;
+    extern Color const gDarkGreen;
+    extern Color const gDarkBlue;
+    extern Color const gDarkYellow;
+    extern Color const gDarkCyan;
+    extern Color const gDarkMagenta;
+    extern Color const gDarkOrange;
+    
+    extern Color const gGray10;
+    extern Color const gGray20;
+    extern Color const gGray30;
+    extern Color const gGray40;
+    extern Color const gGray50;
+    extern Color const gGray60;
+    extern Color const gGray70;
+    extern Color const gGray80;
+    extern Color const gGray90;
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_COLOR_H

Added: rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,360 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// LocalSpace: a local coordinate system for 3d space
+//
+// Provide functionality such as transforming from local space to global
+// space and vice versa.  Also regenerates a valid space from a perturbed
+// &quot;forward vector&quot; which is the basis of abnstract vehicle turning.
+//
+// These are comparable to a 4x4 homogeneous transformation matrix where the
+// 3x3 (R) portion is constrained to be a pure rotation (no shear or scale).
+// The rows of the 3x3 R matrix are the basis vectors of the space.  They are
+// all constrained to be mutually perpendicular and of unit length.  The top
+// (&quot;x&quot;) row is called &quot;side&quot;, the middle (&quot;y&quot;) row is called &quot;up&quot; and the
+// bottom (&quot;z&quot;) row is called forward.  The translation vector is called
+// &quot;position&quot;.  Finally the &quot;homogeneous column&quot; is always [0 0 0 1].
+//
+//     [ R R R  0 ]      [ Sx Sy Sz  0 ]
+//     [ R R R  0 ]      [ Ux Uy Uz  0 ]
+//     [ R R R  0 ]  -&gt;  [ Fx Fy Fz  0 ]
+//     [          ]      [             ]
+//     [ T T T  1 ]      [ Tx Ty Tz  1 ]
+//
+// This file defines three classes:
+//   AbstractLocalSpace:  pure virtual interface
+//   LocalSpaceMixin:     mixin to layer LocalSpace functionality on any base
+//   LocalSpace:          a concrete object (can be instantiated)
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 06-05-02 cwr: created 
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_LOCALSPACE_H
+#define OPENSTEER_LOCALSPACE_H
+
+
+#include &quot;OpenSteer/Vec3.h&quot;
+
+
+// ----------------------------------------------------------------------------
+
+
+namespace OpenSteer {
+
+
+    class AbstractLocalSpace
+    {
+    public:
+        virtual ~AbstractLocalSpace() { /* Nothing to do. */ }
+        
+
+        // accessors (get and set) for side, up, forward and position
+        virtual Vector3 getSide (void) const = 0;
+        virtual Vector3 setSide (Vector3 s) = 0;
+        virtual Vector3 getUp (void) const = 0;
+        virtual Vector3 setUp (Vector3 u) = 0;
+        virtual Vector3 getForward (void) const = 0;
+        virtual Vector3 setForward (Vector3 f) = 0;
+        virtual Vector3 getPosition (void) const = 0;
+        virtual Vector3 setPosition (Vector3 p) = 0;
+
+        // use right-(or left-)handed coordinate space
+        virtual bool isRightHanded(void) const = 0;
+
+        // reset transform to identity
+        virtual void resetLocalSpace (void) = 0;
+
+        // transform a direction in global space to its equivalent in local space
+        virtual Vector3 localizeDirection (const Vector3&amp; globalDirection) const = 0;
+
+        // transform a point in global space to its equivalent in local space
+        virtual Vector3 localizePosition (const Vector3&amp; globalPosition) const = 0;
+
+        // transform a point in local space to its equivalent in global space
+        virtual Vector3 globalizePosition (const Vector3&amp; localPosition) const = 0;
+
+        // transform a direction in local space to its equivalent in global space
+        virtual Vector3 globalizeDirection (const Vector3&amp; localDirection) const = 0;
+
+        // set &quot;side&quot; basis vector to normalized cross product of forward and up
+        virtual void setUnitSideFromForwardAndUp (void) = 0;
+
+        // regenerate the orthonormal basis vectors given a new forward
+        // (which is expected to have unit length)
+        virtual void regenerateOrthonormalBasisUF (const Vector3&amp; newUnitForward) = 0;
+
+        // for when the new forward is NOT of unit length
+        virtual void regenerateOrthonormalBasis (const Vector3&amp; newForward) = 0;
+
+        // for supplying both a new forward and and new up
+        virtual void regenerateOrthonormalBasis (const Vector3&amp; newForward,
+                                                 const Vector3&amp; newUp) = 0;
+
+        // rotate 90 degrees in the direction implied by isRightHanded()
+        virtual Vector3 localRotateForwardToSide (const Vector3&amp; v) const = 0;
+        virtual Vector3 globalRotateForwardToSide (const Vector3&amp; globalForward) const=0;
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // LocalSpaceMixin is a mixin layer, a class template with a paramterized base
+    // class.  Allows &quot;LocalSpace-ness&quot; to be layered on any class.
+
+
+    template &lt;class Super&gt;
+    class LocalSpaceMixin : public Super
+    {
+        // transformation as three orthonormal unit basis vectors and the
+        // origin of the local space.  These correspond to the &quot;rows&quot; of
+        // a 3x4 transformation matrix with [0 0 0 1] as the final column
+
+    private:
+
+        Vector3 _side;     //    side-pointing unit basis vector
+        Vector3 _up;       //  upward-pointing unit basis vector
+        Vector3 _forward;  // forward-pointing unit basis vector
+        Vector3 _position; // origin of local space
+
+    public:
+
+        // accessors (get and set) for side, up, forward and position
+        Vector3 getSide     (void) const {return _side;}
+        Vector3 getUp       (void) const {return _up;}
+        Vector3 getForward  (void) const {return _forward;}
+        Vector3 getPosition (void) const {return _position;}
+        Vector3 setSide     (Vector3 s) {return _side = s;}
+        Vector3 setUp       (Vector3 u) {return _up = u;}
+        Vector3 setForward  (Vector3 f) {return _forward = f;}
+        Vector3 setPosition (Vector3 p) {return _position = p;}
+        Vector3 setSide     (float x, float y, float z){return _side = Vector3(x,y,z);}
+        Vector3 setUp       (float x, float y, float z){return _up = Vector3(x,y,z);}
+        Vector3 setForward  (float x, float y, float z){return _forward = Vector3(x,y,z);}
+        Vector3 setPosition (float x, float y, float z){return _position = Vector3(x,y,z);}
+
+
+        // ------------------------------------------------------------------------
+        // Global compile-time switch to control handedness/chirality: should
+        // LocalSpace use a left- or right-handed coordinate system?  This can be
+        // overloaded in derived types (e.g. vehicles) to change handedness.
+
+        bool isRightHanded(void) const {return true;}
+
+
+        // ------------------------------------------------------------------------
+        // constructors
+
+
+        LocalSpaceMixin (void)
+        {
+            resetLocalSpace ();
+        };
+
+        LocalSpaceMixin (const Vector3&amp; Side,
+                         const Vector3&amp; Up,
+                         const Vector3&amp; Forward,
+                         const Vector3&amp; Position)
+            : _side( Side ), _up( Up ), _forward( Forward ), _position( Position ) {}
+
+
+        LocalSpaceMixin (const Vector3&amp; Up,
+                         const Vector3&amp; Forward,
+                         const Vector3&amp; Position)
+            : _side(), _up( Up ), _forward( Forward ), _position( Position )
+        {
+            setUnitSideFromForwardAndUp();
+        }
+
+        
+        virtual ~LocalSpaceMixin() { /* Nothing to do. */ }
+        
+
+        // ------------------------------------------------------------------------
+        // reset transform: set local space to its identity state, equivalent to a
+        // 4x4 homogeneous transform like this:
+        //
+        //     [ X 0 0 0 ]
+        //     [ 0 1 0 0 ]
+        //     [ 0 0 1 0 ]
+        //     [ 0 0 0 1 ]
+        //
+        // where X is 1 for a left-handed system and -1 for a right-handed system.
+
+        void resetLocalSpace (void)
+        {
+            _forward = Vector3(0, 0, 1);
+            _side = localRotateForwardToSide (_forward);
+            _up = Vector3(0, 1, 0);
+            _position = Vector3(0, 0, 0);
+        };
+
+
+        // ------------------------------------------------------------------------
+        // transform a direction in global space to its equivalent in local space
+
+
+        Vector3 localizeDirection (const Vector3&amp; globalDirection) const
+        {
+            // dot offset with local basis vectors to obtain local coordiantes
+            return Vector3 (globalDirection.dotProduct(_side),
+                         globalDirection.dotProduct(_up),
+                         globalDirection.dotProduct(_forward));
+        };
+
+
+        // ------------------------------------------------------------------------
+        // transform a point in global space to its equivalent in local space
+
+
+        Vector3 localizePosition (const Vector3&amp; globalPosition) const
+        {
+            // global offset from local origin
+            Vector3 globalOffset = globalPosition - _position;
+
+            // dot offset with local basis vectors to obtain local coordiantes
+            return localizeDirection (globalOffset);
+        };
+
+
+        // ------------------------------------------------------------------------
+        // transform a point in local space to its equivalent in global space
+
+
+        Vector3 globalizePosition (const Vector3&amp; localPosition) const
+        {
+            return _position + globalizeDirection (localPosition);
+        };
+
+
+        // ------------------------------------------------------------------------
+        // transform a direction in local space to its equivalent in global space
+
+
+        Vector3 globalizeDirection (const Vector3&amp; localDirection) const
+        {
+            return ((_side    * localDirection.x) +
+                    (_up      * localDirection.y) +
+                    (_forward * localDirection.z));
+        };
+
+
+        // ------------------------------------------------------------------------
+        // set &quot;side&quot; basis vector to normalized cross product of forward and up
+
+
+        void setUnitSideFromForwardAndUp (void)
+        {
+            // derive new unit side basis vector from forward and up
+            if (isRightHanded())
+                _side = _forward.crossProduct(_up);
+            else
+                _side = _up.crossProduct(_forward);
+            _side = _side.normalisedCopy();
+        }
+
+
+        // ------------------------------------------------------------------------
+        // regenerate the orthonormal basis vectors given a new forward
+        // (which is expected to have unit length)
+
+
+        void regenerateOrthonormalBasisUF (const Vector3&amp; newUnitForward)
+        {
+            _forward = newUnitForward;
+
+            // derive new side basis vector from NEW forward and OLD up
+            setUnitSideFromForwardAndUp();
+
+            // derive new Up basis vector from new Side and new Forward
+            // (should have unit length since Side and Forward are
+            // perpendicular and unit length)
+            if (isRightHanded())
+                _up = _side.crossProduct(_forward);
+            else
+                _up = _forward.crossProduct(_side);
+        }
+
+
+        // for when the new forward is NOT know to have unit length
+
+        void regenerateOrthonormalBasis (const Vector3&amp; newForward)
+        {
+            regenerateOrthonormalBasisUF (newForward.normalisedCopy());
+        }
+
+
+        // for supplying both a new forward and and new up
+
+        void regenerateOrthonormalBasis (const Vector3&amp; newForward,
+                                         const Vector3&amp; newUp)
+        {
+            _up = newUp;
+            regenerateOrthonormalBasis (newForward.normalisedCopy());
+        }
+
+
+        // ------------------------------------------------------------------------
+        // rotate, in the canonical direction, a vector pointing in the
+        // &quot;forward&quot; (+Z) direction to the &quot;side&quot; (+/-X) direction
+
+
+        Vector3 localRotateForwardToSide (const Vector3&amp; v) const
+        {
+            return Vector3 (isRightHanded() ? -v.z : +v.z,
+                         v.y,
+                         v.x);
+        }
+
+        // not currently used, just added for completeness
+
+        Vector3 globalRotateForwardToSide (const Vector3&amp; globalForward) const
+        {
+            const Vector3 localForward = localizeDirection (globalForward);
+            const Vector3 localSide = localRotateForwardToSide (localForward);
+            return globalizeDirection (localSide);
+        }
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // Concrete LocalSpace class, and a global constant for the identity transform
+
+
+    typedef LocalSpaceMixin&lt;AbstractLocalSpace&gt; LocalSpace;
+
+    const LocalSpace gGlobalSpace;
+
+} // namespace OpenSteer
+
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_LOCALSPACE_H

Added: rl/trunk/engine/ai/include/OpenSteer/Obstacle.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Obstacle.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Obstacle.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,306 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// Obstacles for use with obstacle avoidance
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 09-05-02 cwr: created
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_OBSTACLE_H
+#define OPENSTEER_OBSTACLE_H
+
+
+#include &quot;OpenSteer/Vec3.h&quot;
+#include &quot;OpenSteer/LocalSpace.h&quot;
+#include &quot;OpenSteer/AbstractVehicle.h&quot;
+
+
+namespace OpenSteer {
+
+    
+    // Forward declaration.
+    class Color;
+    
+
+    // ----------------------------------------------------------------------------
+    // AbstractObstacle: a pure virtual base class for an abstract shape in
+    // space, to be used with obstacle avoidance.  (Oops, its not &quot;pure&quot; since
+    // I added a concrete method to PathIntersection 11-04-04 -cwr).
+
+
+    class AbstractObstacle
+    {
+    public:
+
+        virtual ~AbstractObstacle() { /* Nothing to do. */ }
+        
+        
+        // compute steering for a vehicle to avoid this obstacle, if needed
+        virtual Vector3 steerToAvoid (const AbstractVehicle&amp; v,
+                                   const float minTimeToCollision) const = 0;
+
+        // PathIntersection object: used internally to analyze and store
+        // information about intersections of vehicle paths and obstacles.
+        class PathIntersection
+        {
+        public:
+            bool intersect; // was an intersection found?
+            float distance; // how far was intersection point from vehicle?
+            Vector3 surfacePoint; // position of intersection
+            Vector3 surfaceNormal; // unit normal at point of intersection
+            Vector3 steerHint; // where to steer away from intersection
+            bool vehicleOutside; // is the vehicle outside the obstacle?
+            const AbstractObstacle* obstacle; // obstacle the path intersects
+
+            // determine steering based on path intersection tests
+            Vector3 steerToAvoidIfNeeded (const AbstractVehicle&amp; vehicle,
+                                       const float minTimeToCollision) const;
+
+        };
+
+        // find first intersection of a vehicle's path with this obstacle
+        // (this must be specialized for each new obstacle shape class)
+        virtual void
+        findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
+                                         PathIntersection&amp; pi)
+            const
+            = 0 ;
+
+        // virtual function for drawing -- normally does nothing, can be
+        // specialized by derived types to provide graphics for obstacles
+        virtual void draw (const bool filled,
+                           const Color&amp; color,
+                           const Vector3&amp; viewpoint)
+            const
+            = 0 ;
+
+        // seenFrom (eversion): does this obstacle contrain vehicle to stay
+        // inside it or outside it (or both)?  &quot;Inside&quot; describes a clear space
+        // within a solid (for example, the interior of a room inside its
+        // walls). &quot;Ouitside&quot; describes a solid chunk in the midst of clear
+        // space.
+        enum seenFromState {outside, inside, both};
+        virtual seenFromState seenFrom (void) const = 0;
+        virtual void setSeenFrom (seenFromState s) = 0;
+    };
+
+
+    // an STL vector of AbstractObstacle pointers and an iterator for it:
+    typedef std::vector&lt;AbstractObstacle*&gt; ObstacleGroup;
+    typedef ObstacleGroup::const_iterator ObstacleIterator;
+
+
+    // ----------------------------------------------------------------------------
+    // Obstacle is a utility base class providing some shared functionality
+
+
+    class Obstacle : public AbstractObstacle
+    {
+    public:
+
+        Obstacle (void) : _seenFrom (outside) {}
+
+        virtual ~Obstacle() { /* Nothing to do. */ }
+        
+        // compute steering for a vehicle to avoid this obstacle, if needed 
+        Vector3 steerToAvoid (const AbstractVehicle&amp; v,
+                           const float minTimeToCollision)
+            const;
+
+        // static method to apply steerToAvoid to nearest obstacle in an
+        // ObstacleGroup
+        static Vector3 steerToAvoidObstacles (const AbstractVehicle&amp; vehicle,
+                                           const float minTimeToCollision,
+                                           const ObstacleGroup&amp; obstacles);
+
+        // static method to find first vehicle path intersection in an
+        // ObstacleGroup
+        static void
+        firstPathIntersectionWithObstacleGroup (const AbstractVehicle&amp; vehicle,
+                                                const ObstacleGroup&amp; obstacles,
+                                                PathIntersection&amp; nearest,
+                                                PathIntersection&amp; next);
+
+        // default do-nothing draw function (derived class can overload this)
+        void draw (const bool, const Color&amp;, const Vector3&amp;) const {}
+
+        seenFromState seenFrom (void) const {return _seenFrom;}
+        void setSeenFrom (seenFromState s) {_seenFrom = s;}
+    private:
+        seenFromState _seenFrom;
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // SphereObstacle a simple ball-shaped obstacle
+
+
+    class SphereObstacle : public Obstacle
+    {
+    public:
+        float radius;
+        Vector3 center;
+
+        // constructors
+        SphereObstacle (float r, Vector3 c) : radius(r), center (c) {}
+        SphereObstacle (void) : radius(1), center (Vector3::ZERO) {}
+
+        virtual ~SphereObstacle() { /* Nothing to do. */ }
+        
+        // find first intersection of a vehicle's path with this obstacle
+        void findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
+                                              PathIntersection&amp; pi)
+            const;
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // LocalSpaceObstacle: a mixture of LocalSpace and Obstacle methods
+
+
+     typedef LocalSpaceMixin&lt;Obstacle&gt; LocalSpaceObstacle;
+
+
+    // ----------------------------------------------------------------------------
+    // BoxObstacle: a box-shaped (cuboid) obstacle of a given height, width,
+    // depth, position and orientation.  The box is centered on and aligned
+    // with a local space.
+
+
+    class BoxObstacle : public LocalSpaceObstacle
+    {
+    public:
+        float width;  // width  of box centered on local X (side)    axis
+        float height; // height of box centered on local Y (up)      axis
+        float depth;  // depth  of box centered on local Z (forward) axis
+
+        // constructors
+        BoxObstacle (float w, float h, float d) : width(w), height(h), depth(d) {}
+        BoxObstacle (void) :  width(1.0f), height(1.0f), depth(1.0f) {}
+
+        virtual ~BoxObstacle() { /* Nothing to do. */ }
+        
+        
+        // find first intersection of a vehicle's path with this obstacle
+        void findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
+                                              PathIntersection&amp; pi)
+            const;
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // PlaneObstacle: a planar obstacle of a given position and orientation.
+    // The plane is defined as the XY (aka side/up) plane of a local space.
+    // The +Z (forward) half-space is considered &quot;outside&quot; the obstacle.  
+    //
+    // This is also the base class for several other obstacles which represent
+    // 2d shapes (rectangle, triangle, ...) arbitarily oriented and positioned
+    // in 2d space.  They specialize this class via xyPointInsideShape which
+    // tests if a given point on the XZ plane is inside the obstacle's shape.
+
+
+    class PlaneObstacle : public LocalSpaceObstacle
+    {
+    public:
+        // constructors
+        PlaneObstacle (void) {}
+        PlaneObstacle (const Vector3&amp; s,
+                       const Vector3&amp; u,
+                       const Vector3&amp; f,
+                       const Vector3&amp; p)
+        : LocalSpaceObstacle( s, u, f, p )
+        {
+            /*
+            setSide (s);
+            setUp (u);
+            setForward (f);
+            setPosition (p);
+             */
+        }
+
+        // find first intersection of a vehicle's path with this obstacle
+        void findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
+                                              PathIntersection&amp; pi)
+            const;
+
+        // determines if a given point on XY plane is inside obstacle shape
+        virtual bool xyPointInsideShape (const Vector3&amp; /*point*/,
+                                         float /*radius*/) const
+        {
+            return true; // always true for PlaneObstacle
+        }
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // RectangleObstacle: a rectangular obstacle of a given height, width,
+    // position and orientation.  It is a rectangle centered on the XY (aka
+    // side/up) plane of a local space.
+
+
+    class RectangleObstacle : public PlaneObstacle
+    {
+    public:
+        float width;  // width  of rectangle centered on local X (side) axis
+        float height; // height of rectangle centered on local Y (up)   axis
+
+        // constructors
+        RectangleObstacle (float w, float h) : width(w), height(h) {}
+        RectangleObstacle (void) :  width(1.0f), height(1.0f) {}
+        RectangleObstacle (float w, float h, const Vector3&amp; s,
+                           const Vector3&amp; u, const Vector3&amp; f, const Vector3&amp; p,
+                           seenFromState sf) 
+            : PlaneObstacle( s, u, f, p ), width(w), height(h)
+        {
+            /*
+            setSide (s);
+            setUp (u);
+            setForward (f);
+            setPosition (p);
+             */
+            setSeenFrom (sf);
+        }
+        
+        virtual ~RectangleObstacle() { /* Nothing to do. */ }
+
+        // determines if a given point on XY plane is inside obstacle shape
+        bool xyPointInsideShape (const Vector3&amp; point, float radius) const;
+    };
+
+
+} // namespace OpenSteer
+    
+    
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_OBSTACLE_H

Added: rl/trunk/engine/ai/include/OpenSteer/Path.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Path.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Path.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,106 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original authors: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * Abstract interface for paths.
+ */
+#ifndef OPENSTEER_PATH_H
+#define OPENSTEER_PATH_H
+
+
+#include &quot;OpenSteer/Vec3.h&quot;
+
+
+namespace OpenSteer {
+
+    
+    /**
+     * Path in space that might be cyclic.
+     *
+     * Paths are infinitesimal thin.
+     */
+    class Path {
+    public:
+        
+        
+        virtual ~Path() = 0;
+        
+        
+        /**
+         * Returns @c true if the path is valid, @c false otherwise.
+         */
+        virtual bool isValid() const = 0;
+        
+        /**
+         * Given an arbitrary point (&quot;A&quot;), returns the nearest point (&quot;P&quot;) on
+		 * this path center line.  Also returns, via output arguments, the path
+         * tangent at P and a measure of how far A is outside the Pathway's 
+         * &quot;tube&quot;.  Note that a negative distance indicates A is inside the 
+         * Pathway.
+         *
+         * If @c isValid is @c false the behavior is undefined.
+         */
+		virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
+                                     float&amp; outside) const = 0;
+        
+		/**
+         * Given a distance along the path, convert it to a point on the path.
+         * If @c isValid is @c false the behavior is undefined.
+         */
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
+        
+		/**
+         * Given an arbitrary point, convert it to a distance along the path.
+         * If @c isValid is @c false the behavior is undefined.
+         */
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const = 0;
+        
+        /**
+         * Returns @c true f the path is closed, otherwise @c false.
+         */
+        virtual bool isCyclic() const = 0;
+        
+        /**
+         * Returns the length of the path.
+         */
+        virtual float length() const = 0;
+        
+    protected:
+        /**
+         * Protected to disable assigning instances of different inherited 
+         * classes to each other.
+         *
+         * @todo Should this be added or not? Have to read a bit...
+         */
+        // Path&amp; operator=( Path const&amp; );
+        
+    }; // class Path
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_PATH_H

Added: rl/trunk/engine/ai/include/OpenSteer/Pathway.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Pathway.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Pathway.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,100 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * Abstract base class for pathways - paths with associated radii.
+ */
+#ifndef OPENSTEER_PATHWAY_H
+#define OPENSTEER_PATHWAY_H
+
+#include &quot;OpenSteer/Vec3.h&quot;
+
+namespace OpenSteer {
+    
+    
+    /**
+     * Pure virtual base class representing an abstract pathway in space.
+     * Could be used for example in path following.
+     */
+    class Pathway {
+    public:
+        virtual ~Pathway() = 0;
+        
+        /**
+         * Returns @c true if the path is valid, @c false otherwise.
+         */
+        virtual bool isValid() const = 0;
+        
+        /**
+         * Given an arbitrary point (&quot;A&quot;), returns the nearest point (&quot;P&quot;) on
+		 * this path center line.  Also returns, via output arguments, the path
+         * tangent at P and a measure of how far A is outside the Pathway's 
+         * &quot;tube&quot;.  Note that a negative distance indicates A is inside the 
+         * Pathway.
+         *
+         * If @c isValid is @c false the behavior is undefined.
+         */
+		virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
+                                     float&amp; outside) const = 0;
+        
+		/**
+         * Given a distance along the path, convert it to a point on the path.
+         * If @c isValid is @c false the behavior is undefined.
+         */
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
+        
+		/**
+         * Given an arbitrary point, convert it to a distance along the path.
+         * If @c isValid is @c false the behavior is undefined.
+         */
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const = 0;
+        
+        /**
+         * Returns @c true f the path is closed, otherwise @c false.
+         */
+        virtual bool isCyclic() const = 0;
+        
+        /**
+         * Returns the length of the path.
+         */
+        virtual float length() const = 0;
+        
+    protected:
+        /**
+         * Protected to disable assigning instances of different inherited 
+         * classes to each other.
+         *
+         * @todo Should this be added or not? Have to read a bit...
+         */
+        // Pathway&amp; operator=( Pathway const&amp; );    
+        
+    }; // class Pathway
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_PATHWAY_H

Added: rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,234 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Segmented path build of polylines.
+ */
+#ifndef OPENSTEER_POLYLINESEGMENTEDPATH_H
+#define OPENSTEER_POLYLINESEGMENTEDPATH_H
+
+// Include std::vector
+#include &lt;vector&gt;
+
+
+
+// Include OpenSteer::SegmentedPath
+#include &quot;OpenSteer/SegmentedPath.h&quot;
+
+// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
+#include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
+
+// Include Vector3
+#include &quot;OpenSteer/Vec3.h&quot;
+
+// Include OpenSteer::distance
+#include &quot;OpenSteer/Vec3Utilities.h&quot;
+
+
+
+namespace OpenSteer {
+    
+    
+    /**
+     * Segmented path build by polylines. The last point of the path might be 
+     * connected to the first point building a closed cycle.
+     *
+     * 
+     */
+    class PolylineSegmentedPath : public SegmentedPath {
+    public:
+        typedef std::vector&lt; Vector3 &gt; PathPoints;
+        /**
+         * Constructs an invalid path. Behavior of most member functions is
+         * undefined if a path has less than two distinct points.
+         */
+        PolylineSegmentedPath();
+        
+        /**
+         * Constructs a new path.
+         *
+         * @param numOfPoints Number of points. Must be at least two.
+         * @param newPoints As many points as indicated by @a numOfPoints. Two
+         *                  adjacent points mustn't be identical and the first
+         *                  the last point mustn't be identical.
+         * @param closedCycle If @c true the first point of @a newPoints is
+         *                    copied to the end of the path to represent the 
+         *                    cycle closing segment.
+         */
+        PolylineSegmentedPath( size_type numOfPoints,
+                               Vector3 const newPoints[],
+                               bool closedCycle );
+
+        PolylineSegmentedPath( const PathPoints&amp; newPoints,
+                               bool closedCycle );
+        
+        PolylineSegmentedPath( PolylineSegmentedPath const&amp; other );
+        
+        virtual ~PolylineSegmentedPath();
+        
+        PolylineSegmentedPath&amp; operator=( PolylineSegmentedPath other );
+        
+        void swap( PolylineSegmentedPath&amp; other );
+        
+        
+        /**
+         * Replaces all path information by the given ones.
+         *
+         * @param numOfPoints Number of points. Must be at least two.
+         * @param newPoints As many points as indicated by @a numOfPoints. Two
+         *                  adjacent points mustn't be identical and the first
+         *                  the last point mustn't be identical.
+         * @param closedCycle If @c true the first point of @a newPoints is
+         *                    copied to the end of the path to represent the 
+         *                    cycle closing segment.
+         */
+        void setPath( size_type numOfPoints,
+                      Vector3 const newPoints[],
+                      bool closedCycle );
+
+        void setPath( const PathPoints&amp; newPoints, bool closedCycle);
+        /**
+         * Replaces @a numOfPoints points starting at @a startIndex.
+         *
+         * In the resulting sequence of points there mustn't be two adjacent 
+         * ones that are equal. The first and last point mustn't be identical,
+         * too.
+         *
+         * If the first point is changed and the path is cyclic the duplication
+         * of the first point at the end of the sequence representing the
+         * path closing segment is updated automatically.
+         *
+         * @param startIndex First point to be moved or replaced.
+         * @param numOfPoints Number of points to move or replace. 
+         *                    &lt;code&gt; numOfPoints + startIndex &lt;/code&gt; must be
+         *                    lesser or equal to @c pointCount.
+         * @param newPoints Moved points to replace the old ones.
+         */
+        void movePoints( size_type startIndex,
+                         size_type numOfPoints,
+                         Vector3 const newPoints[]);
+        
+        
+        
+        virtual bool isValid() const;
+        virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
+                                     float&amp; outside) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const;
+        virtual bool isCyclic() const;
+        virtual float length() const;
+        
+        
+        virtual size_type pointCount() const;
+        virtual Vector3 point( size_type pointIndex ) const;        
+        
+        
+        virtual size_type segmentCount() const;
+        virtual float segmentLength( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
+        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
+                                                 Vector3 const&amp; point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                float segmentDistance ) const;
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+                                                  float segmentDistance ) const;
+        
+        virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
+                                                          float distance,
+                                                          Vector3&amp; pointOnPath,
+                                                          Vector3&amp; tangent ) const;
+        
+        virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
+                                                                  Vector3 const&amp; point,
+                                                                  float&amp; distance,
+                                                                  Vector3&amp; pointOnPath,
+                                                                  Vector3&amp; tangent ) const;
+        
+    private:
+        std::vector&lt; Vector3 &gt; points_;
+        std::vector&lt; Vector3 &gt; segmentTangents_;
+        std::vector&lt; float &gt; segmentLengths_;
+        bool closedCycle_;
+    }; // class PolylineSegmentedPath
+    
+    
+    /**
+     * Swaps the content of @a lhs and @a rhs.
+     */
+    inline void swap( PolylineSegmentedPath&amp; lhs, PolylineSegmentedPath&amp; rhs ) {
+        lhs.swap( rhs );
+    }
+    
+    
+    /**
+     * Extracts the base data of @c PolylineSegmentedPath.
+     */
+    template&lt;&gt;
+    class PointToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPath &gt; {
+    public:
+        
+        static void extract( PolylineSegmentedPath const&amp; pathAlike,
+                             PolylineSegmentedPath::size_type segmentIndex,
+                             Vector3 const&amp; point, 
+                             float&amp; segmentDistance, 
+                             float&amp;, 
+                             float&amp; distancePointToPath, 
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent ) {
+            pathAlike.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent );
+            distancePointToPath = distance( point, pointOnPathCenterLine );
+        }
+        
+    }; // class PointToPathAlikeBaseDataExtractionPolicy
+    
+    /**
+     * Extracts the base data of @c PolylineSegmentedPath.
+     */
+    template&lt;&gt;
+    class DistanceToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPath &gt; {
+    public:
+        static void extract( PolylineSegmentedPath const&amp; pathAlike,
+                             PolylineSegmentedPath::size_type segmentIndex,
+                             float segmentDistance, 
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent, 
+                             float&amp;  )  {
+            pathAlike.mapDistanceToSegmentPointAndTangent( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent );     
+        }
+        
+        
+    }; // DistanceToPathAlikeBaseDataExtractionPolicy
+    
+    
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_POLYLINESEGMENTEDPATH_H

Added: rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,228 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Segmented pathway build of polylines. The whole path has one associated 
+ * radius.
+ */
+#ifndef OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H
+#define OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H
+
+// Include OpenSteer::SegmentedPathway
+#include &quot;OpenSteer/SegmentedPathway.h&quot;
+
+// Include OpenSteer::PolylineSegmentedPath
+#include &quot;OpenSteer/PolylineSegmentedPath.h&quot;
+
+// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
+#include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
+
+// Include Vector3
+#include &quot;OpenSteer/Vec3.h&quot;
+
+// Include OpenSteer::distance
+#include &quot;OpenSteer/Vec3Utilities.h&quot;
+
+
+
+namespace OpenSteer {
+    
+    /**
+     * Segmented pathway build by polylines with a single radius for the whole
+     * pathway.
+     */
+    class PolylineSegmentedPathwaySingleRadius : public SegmentedPathway {
+    public:
+        PolylineSegmentedPathwaySingleRadius();
+        explicit PolylineSegmentedPathwaySingleRadius( float r );
+        PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
+                                              Vector3 const points[],
+                                              float r,
+                                              bool closeCycle );
+        PolylineSegmentedPathwaySingleRadius( const PolylineSegmentedPath::PathPoints&amp; points,
+                                              float r,
+                                              bool closeCycle );
+        PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const&amp; other );
+        virtual ~PolylineSegmentedPathwaySingleRadius();
+        PolylineSegmentedPathwaySingleRadius&amp; operator=( PolylineSegmentedPathwaySingleRadius other );
+        
+        /**
+         * Swaps the content with @a other.
+         */
+        void swap( PolylineSegmentedPathwaySingleRadius&amp; other );
+        
+        /**
+         * Replaces @a numOfPoints points starting at @a startIndex.
+         *
+         * In the resulting sequence of points there mustn't be two adjacent 
+         * ones that are equal. The first and last point mustn't be identical,
+         * too.
+         *
+         * If the first point is changed and the path is cyclic the duplication
+         * of the first point at the end of the sequence representing the
+         * path closing segment is updated automatically.
+         *
+         * @param startIndex First point to be moved or replaced.
+         * @param numOfPoints Number of points to move or replace. 
+         *                    &lt;code&gt; numOfPoints + startIndex &lt;/code&gt; must be
+         *                    lesser or equal to @c pointCount.
+         * @param newPointValues Moved points to replace the old ones.
+         */
+        void movePoints( size_type startIndex,
+                         size_type numOfPoints,
+                         Vector3 const newPointValues[] );
+        /**
+         * Replaces the pathway information completely.
+         *
+         * If @a closedCycle is @c true then the pathway has @a numOfPoints
+         * segments and the first point is duplicated and added as the last
+         * point to represent the end point of the segment closing the pathway
+         * cycle. If @a closedCycle is false the pathway has 
+         * &lt;code&gt;numOfPoints - 1&lt;/code&gt; segments.
+         *
+         * @param numOfPoints Number of points defining the pathway.
+         * @param points The actual points.
+         * @param r Radius of the whole pathway.
+         * @param closedCycle @c true if the pathway is cyclic, @a false 
+         *        otherwise.
+         */
+        void setPathway( size_type numOfPoints,
+                         Vector3 const points[],
+                         float r,
+                         bool closedCycle );
+        
+        /**
+         * Sets the radius of the whole pathway to @a r.
+         */
+        void setRadius( float r );
+        
+        /**
+         * Returns the pathway radius.
+         */
+        float radius() const;
+        
+        
+        virtual bool isValid() const;
+		virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
+                                     float&amp; outside) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const;
+        virtual bool isCyclic() const;
+        virtual float length() const;
+        
+        
+        virtual size_type pointCount() const;
+        virtual Vector3 point( size_type pointIndex ) const;
+        
+        
+        virtual size_type segmentCount() const;
+        virtual float segmentLength( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
+        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
+                                                 Vector3 const&amp; point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                float segmentDistance ) const;
+        virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
+                                                 float distanceOnSegment ) const;
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+                                                  float segmentDistance ) const;
+        
+        virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
+                                                                   float segmentDistance,
+                                                                   Vector3&amp; pointOnPath,
+                                                                   Vector3&amp; tangent,
+                                                                   float&amp; radius ) const;
+        
+        virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
+                                                                           Vector3 const&amp; point,
+                                                                           float&amp; distance,
+                                                                           Vector3&amp; pointOnPath,
+                                                                           Vector3&amp; tangent,
+                                                                           float&amp; radius) const;
+         
+    private:
+        PolylineSegmentedPath path_;
+        float radius_;
+    }; // class PolylineSegmentedPathwaySingleRadius
+    
+    
+    /**
+     * Swaps the content of @a lhs and @a rhs.
+     */
+    inline void swap( PolylineSegmentedPathwaySingleRadius&amp; lhs, 
+               PolylineSegmentedPathwaySingleRadius&amp; rhs ) {
+        lhs.swap( rhs );
+    }
+    
+    
+    /**
+     * Extracts the base data of @c PolylineSegmentedPathwaySingleRadius.
+     */
+    template&lt;&gt;
+    class PointToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPathwaySingleRadius &gt; {
+    public:
+            
+        static void extract( PolylineSegmentedPathwaySingleRadius const&amp; pathAlike,
+                             PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
+                             Vector3 const&amp; point, 
+                             float&amp; segmentDistance, 
+                             float&amp; radius, 
+                             float&amp; distancePointToPath, 
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent ) {
+            pathAlike.mapPointToSegmentDistanceAndPointAndTangentAndRadius( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent, radius );
+            distancePointToPath = distance( point, pointOnPathCenterLine ) - radius;
+        }
+            
+    }; // class PointToPathAlikeBaseDataExtractionPolicy
+    
+    
+    /**
+     * Extracts the base data of @c PolylineSegmentedPathwaySingleRadius.
+     */
+    template&lt;&gt;
+    class DistanceToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPathwaySingleRadius &gt; {
+    public:
+        static void extract( PolylineSegmentedPathwaySingleRadius const&amp; pathAlike,
+                             PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
+                             float segmentDistance, 
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent, 
+                             float&amp; radius )  {
+            pathAlike.mapDistanceToSegmentPointAndTangentAndRadius( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent, radius );     
+        }
+        
+        
+    }; // DistanceToPathAlikeBaseDataExtractionPolicy 
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H

Added: rl/trunk/engine/ai/include/OpenSteer/Proximity.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Proximity.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Proximity.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,337 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// Proximity 
+//
+// Data structures for accelerating proximity/locality/neighborhood queries
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 06-20-01 cwr: created
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_PROXIMITY_H
+#define OPENSTEER_PROXIMITY_H
+
+
+#include &lt;algorithm&gt;
+#include &lt;vector&gt;
+#include &quot;OpenSteer/Vec3.h&quot;
+#include &quot;OpenSteer/lq.h&quot;   // XXX temp?
+
+
+namespace OpenSteer {
+
+
+    // ----------------------------------------------------------------------------
+    // &quot;tokens&quot; are the objects manipulated by the spatial database
+
+
+    template &lt;class ContentType&gt;
+    class AbstractTokenForProximityDatabase
+    {
+    public:
+
+        virtual ~AbstractTokenForProximityDatabase () {}
+
+        // the client object calls this each time its position changes
+        virtual void updateForNewPosition (const Vector3&amp; position) = 0;
+
+        // find all neighbors within the given sphere (as center and radius)
+        virtual void findNeighbors (const Vector3&amp; center,
+                                    const float radius,
+                                    std::vector&lt;ContentType&gt;&amp; results) = 0;
+
+#ifndef NO_LQ_BIN_STATS
+        // only meaningful for LQProximityDatabase, provide dummy default
+        virtual void getBinPopulationStats (int&amp; min, int&amp; max, float&amp; average)
+        {min=max=0; average=0.0;}
+#endif // NO_LQ_BIN_STATS
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // abstract type for all kinds of proximity databases
+
+
+    template &lt;class ContentType&gt;
+    class AbstractProximityDatabase
+    {
+    public:
+
+        // type for the &quot;tokens&quot; manipulated by this spatial database
+        typedef AbstractTokenForProximityDatabase&lt;ContentType&gt; tokenType;
+
+        
+        virtual ~AbstractProximityDatabase() { /* Nothing to do? */ }
+        
+        // allocate a token to represent a given client object in this database
+        virtual tokenType* allocateToken (ContentType parentObject) = 0;
+
+        // insert
+        // XXX maybe this should return an iterator?
+        // XXX see <A HREF="http://www.sgi.com/tech/stl/set.html">http://www.sgi.com/tech/stl/set.html</A>
+        // virtual void insert (const ContentType&amp; x) = 0;
+
+        // XXX name?
+        // returns the number of tokens in the proximity database
+        virtual int getPopulation (void) = 0;
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // This is the &quot;brute force&quot; O(n^2) approach implemented in terms of the
+    // AbstractProximityDatabase protocol so it can be compared directly to other
+    // approaches.  (e.g. the Boids plugin allows switching at runtime.)
+
+
+    template &lt;class ContentType&gt;
+    class BruteForceProximityDatabase
+        : public AbstractProximityDatabase&lt;ContentType&gt;
+    {
+    public:
+
+        // constructor
+        BruteForceProximityDatabase (void)
+        {
+        }
+
+        // destructor
+        virtual ~BruteForceProximityDatabase ()
+        {
+        }
+
+        // &quot;token&quot; to represent objects stored in the database
+        class tokenType : public AbstractTokenForProximityDatabase&lt;ContentType&gt;
+        {
+        public:
+
+            // constructor
+            tokenType (ContentType parentObject, BruteForceProximityDatabase&amp; pd)
+            {
+                // store pointer to our associated database and the object this
+                // token represents, and store this token on the database's vector
+                bfpd = &pd;
+                object = parentObject;
+                bfpd-&gt;group.push_back (this);
+            }
+
+            // destructor
+            virtual ~tokenType ()
+            {
+                // remove this token from the database's vector
+                bfpd-&gt;group.erase (std::find (bfpd-&gt;group.begin(),
+                                              bfpd-&gt;group.end(),
+                                              this));
+            }
+
+            // the client object calls this each time its position changes
+            void updateForNewPosition (const Vector3&amp; newPosition)
+            {
+                position = newPosition;
+            }
+
+            // find all neighbors within the given sphere (as center and radius)
+            void findNeighbors (const Vector3&amp; center,
+                                const float radius,
+                                std::vector&lt;ContentType&gt;&amp; results)
+            {
+                // loop over all tokens
+                const float r2 = radius * radius;
+                for (tokenIterator i = bfpd-&gt;group.begin();
+                     i != bfpd-&gt;group.end();
+                     i++)
+                {
+                    const Vector3 offset = center - (**i).position;
+                    const float d2 = offset.squaredLength();
+
+                    // push onto result vector when within given radius
+                    if (d2 &lt; r2) results.push_back ((**i).object);
+                }
+            }
+
+        private:
+            BruteForceProximityDatabase* bfpd;
+            ContentType object;
+            Vector3 position;
+        };
+
+        typedef std::vector&lt;tokenType*&gt; tokenVector;
+        typedef typename tokenVector::const_iterator tokenIterator;    
+
+        // allocate a token to represent a given client object in this database
+        tokenType* allocateToken (ContentType parentObject)
+        {
+            return new tokenType (parentObject, *this);
+        }
+
+        // return the number of tokens currently in the database
+        int getPopulation (void)
+        {
+            return (int) group.size();
+        }
+        
+    private:
+        // STL vector containing all tokens in database
+        tokenVector group;
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // A AbstractProximityDatabase-style wrapper for the LQ bin lattice system
+
+
+    template &lt;class ContentType&gt;
+    class LQProximityDatabase : public AbstractProximityDatabase&lt;ContentType&gt;
+    {
+    public:
+
+        // constructor
+        LQProximityDatabase (const Vector3&amp; center,
+                             const Vector3&amp; dimensions,
+                             const Vector3&amp; divisions)
+        {
+            const Vector3 halfsize (dimensions * 0.5f);
+            const Vector3 origin (center - halfsize);
+
+            lq = lqCreateDatabase (origin.x, origin.y, origin.z, 
+                                   dimensions.x, dimensions.y, dimensions.z,  
+                                   (int) round (divisions.x),
+                                   (int) round (divisions.y),
+                                   (int) round (divisions.z));
+        }
+
+        // destructor
+        virtual ~LQProximityDatabase ()
+        {
+            lqDeleteDatabase (lq);
+            lq = NULL;
+        }
+
+        // &quot;token&quot; to represent objects stored in the database
+        class tokenType : public AbstractTokenForProximityDatabase&lt;ContentType&gt;
+        {
+        public:
+
+            // constructor
+            tokenType (ContentType parentObject, LQProximityDatabase&amp; lqsd)
+            {
+                lqInitClientProxy (&amp;proxy, parentObject);
+                lq = lqsd.lq;
+            }
+
+            // destructor
+            virtual ~tokenType (void)
+            {
+                lqRemoveFromBin (&amp;proxy);
+            }
+
+            // the client object calls this each time its position changes
+            void updateForNewPosition (const Vector3&amp; p)
+            {
+                lqUpdateForNewLocation (lq, &amp;proxy, p.x, p.y, p.z);
+            }
+
+            // find all neighbors within the given sphere (as center and radius)
+            void findNeighbors (const Vector3&amp; center,
+                                const float radius,
+                                std::vector&lt;ContentType&gt;&amp; results)
+            {
+                lqMapOverAllObjectsInLocality (lq, 
+                                               center.x, center.y, center.z,
+                                               radius,
+                                               perNeighborCallBackFunction,
+                                               (void*)&amp;results);
+            }
+
+            // called by LQ for each clientObject in the specified neighborhood:
+            // push that clientObject onto the ContentType vector in void*
+            // clientQueryState
+            // (parameter names commented out to prevent compiler warning from &quot;-W&quot;)
+            static void perNeighborCallBackFunction  (void* clientObject,
+                                                      float /*distanceSquared*/,
+                                                      void* clientQueryState)
+            {
+                typedef std::vector&lt;ContentType&gt; ctv;
+                ctv&amp; results = *((ctv*) clientQueryState);
+                results.push_back ((ContentType) clientObject);
+            }
+
+#ifndef NO_LQ_BIN_STATS
+            // Get statistics about bin populations: min, max and
+            // average of non-empty bins.
+            void getBinPopulationStats (int&amp; min, int&amp; max, float&amp; average)
+            {
+                lqGetBinPopulationStats (lq, &amp;min, &amp;max, &amp;average);
+            }
+#endif // NO_LQ_BIN_STATS
+
+        private:
+            lqClientProxy proxy;
+            lqDB* lq;
+        };
+
+
+        // allocate a token to represent a given client object in this database
+        tokenType* allocateToken (ContentType parentObject)
+        {
+            return new tokenType (parentObject, *this);
+        }
+
+        // count the number of tokens currently in the database
+        int getPopulation (void)
+        {
+            int count = 0;
+            lqMapOverAllObjects (lq, counterCallBackFunction, &amp;count);
+            return count;
+        }
+        
+        // (parameter names commented out to prevent compiler warning from &quot;-W&quot;)
+        static void counterCallBackFunction  (void* /*clientObject*/,
+                                              float /*distanceSquared*/,
+                                              void* clientQueryState)
+        {
+            int&amp; counter = *(int*)clientQueryState;
+            counter++;
+        }
+
+
+    private:
+        lqDB* lq;
+    };
+
+} // namespace OpenSteer
+
+
+
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_PROXIMITY_H

Added: rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,229 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Functionality to map points or distances to path alikes and to extract
+ * the assocaited information.
+ */
+#ifndef OPENSTEER_QUERYPATHALIKE_H
+#define OPENSTEER_QUERYPATHALIKE_H
+
+
+// Include std::numeric_limits&lt; float &gt;::max
+#include &lt;limits&gt;
+
+
+
+// Include Vector3
+#include &quot;OpenSteer/Vec3.h&quot;
+
+// Include OpenSteer::distance
+#include &quot;OpenSteer/Vec3Utilities.h&quot;
+
+// Include OpenSteer::clamp, OpenSteer::modulo
+#include &quot;OpenSteer/Utilities.h&quot;
+
+// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy, OpenSteer::DistanceToPathAlikeBaseDataExtractionPolicy
+#include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
+
+#ifdef _MSC_VER
+#undef min
+#undef max
+#endif
+
+
+namespace OpenSteer {
+
+    /**
+     * Provides functionality to map points or distances to path alikes and
+     * to extract associated information.
+     */
+    template&lt; class PathAlike, class Mapping, class BaseDataExtractionPolicy = PointToPathAlikeBaseDataExtractionPolicy&lt; PathAlike &gt; &gt;
+    class PointToPathAlikeMapping {
+    public:
+        
+        /**
+         * Maps @a queryPoint to a path alike @a pathAlike and returns the  
+         * queried data in @a mapping.
+         *
+         * @c Mapping must provide the following member functions to
+         * set queried values. Member functions might be empty if the specific 
+         * data isn't needed. A good compiler should optimize the
+         * empty member function calls and the associated calculations for its
+         * parameters away.
+         *
+         * &lt;code&gt; void setPointOnPathCenterLine( Vector3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setPointOnPathBoundary( Vector3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setRadius( float ) &lt;/code&gt;
+         * &lt;code&gt; void setTangent( Vector3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setSegmentIndex( typename SegmentedPathAlike::size_type ) &lt;/code&gt;
+         * &lt;code&gt; void setDistancePointToPath( float ) &lt;/code&gt;
+         * &lt;code&gt; void setDistancePointToPathCenterLine( float ) &lt;/code&gt;
+         * &lt;code&gt; void setDistanceOnPath( float ) &lt;/code&gt;
+         * &lt;code&gt; void setDistanceOnSegment( float ) &lt;/code&gt;
+         *
+         * To query for the distance on the path the two following member functions
+         * of @c Mapping must be provided too:
+         *
+         * &lt;code&gt; void setDistanceOnPathFlag( float ) &lt;/code&gt; and
+         * &lt;code&gt; float distanceOnPathFlag() const &lt;/code&gt;.
+         *
+         * If the distance along the path shouldn't be extracted empty 
+         * versions of these member functions are possible.
+         *
+         * @c QueryPathAlikeUtilities.h provides some base classes to inherit
+         * from to automatically get some of the functionality described above.
+         */
+        static void map( PathAlike const&amp; pathAlike, Vector3 const&amp; queryPoint, Mapping&amp; mapping ) {
+            float minDistancePointToPath = std::numeric_limits&lt; float &gt;::max();
+            mapping.setDistanceOnPathFlag( 0.0f );
+            
+            typedef typename PathAlike::size_type size_type;
+            size_type const segmentCount = pathAlike.segmentCount();
+            for ( size_type segmentIndex = 0; segmentIndex &lt; segmentCount; ++segmentIndex ) {
+                
+                float segmentDistance = 0.0f;
+                float radius = 0.0f;
+                float distancePointToPath = 0.0f;
+                Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
+                Vector3 tangent( 0.0f, 0.0f, 0.0f );
+                
+                BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, queryPoint, segmentDistance, radius, distancePointToPath, pointOnPathCenterLine, tangent );
+                
+                if ( distancePointToPath &lt; minDistancePointToPath ) {
+                    minDistancePointToPath = distancePointToPath;
+                    mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
+                    mapping.setPointOnPathBoundary( pointOnPathCenterLine + ( ( queryPoint - pointOnPathCenterLine ).normalisedCopy() * radius ) );
+                    mapping.setRadius( radius );
+                    mapping.setTangent( tangent );
+                    mapping.setSegmentIndex( segmentIndex );
+                    mapping.setDistancePointToPath( distancePointToPath );
+                    mapping.setDistancePointToPathCenterLine( distancePointToPath + radius );
+                    mapping.setDistanceOnPath( mapping.distanceOnPathFlag() + segmentDistance );
+                    mapping.setDistanceOnSegment( segmentDistance );
+                }
+                
+                mapping.setDistanceOnPathFlag( mapping.distanceOnPathFlag() + pathAlike.segmentLength( segmentIndex ) );
+            }
+        }
+        
+    }; // class PointToPathAlikeMapping
+    
+    /**
+     * Maps @a point to @a pathAlike and returns the data extracted in 
+     * @a mapping.
+     *
+     * See @c MapPointToPathAlike::map for further information.
+     */
+    template&lt; class PathAlike, class Mapping &gt;
+    void mapPointToPathAlike( PathAlike const&amp; pathAlike, Vector3 const&amp; point, Mapping&amp; mapping ) {
+        PointToPathAlikeMapping&lt; PathAlike, Mapping &gt;::map( pathAlike, point, mapping );
+    }
+    
+        
+    
+    /**
+     * Provides functionality to map distances to path alikes and to extract
+     * the associated data.
+     */
+    template&lt; class PathAlike, class Mapping, class BaseDataExtractionPolicy = DistanceToPathAlikeBaseDataExtractionPolicy&lt; PathAlike &gt; &gt; 
+    class DistanceToPathAlikeMapping {
+    public:
+    
+        /**
+         * Maps @a distanceOnPath to a path alike @a pathAlike and returns the 
+         * queried data in @a mapping.
+         *
+         * @c Mapping must provide the following member functions 
+         * to set queried values. Member functions might be empty if the  
+         * specific data isn't needed. A good compiler should optimize the
+         * empty member function calls and the associated calculations for its
+         * parameters away.
+         *
+         * &lt;code&gt; void setPointOnPathCenterLine( Vector3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setRadius( float ) &lt;/code&gt;
+         * &lt;code&gt; void setTangent( Vector3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setSegmentIndex( typename SegmentedPathAlike::size_type ) &lt;/code&gt;
+         * &lt;code&gt; void setDistanceOnPath( float ) &lt;/code&gt;
+         * &lt;code&gt; void setDistanceOnSegment( float ) &lt;/code&gt;
+         */
+        static void map( PathAlike const&amp; pathAlike, float distanceOnPath, Mapping&amp; mapping ) {
+            float const pathLength = pathAlike.length();
+            
+            // Modify @c distanceOnPath to applicable values.
+            if ( pathAlike.isCyclic() ) {
+                distanceOnPath = modulo( distanceOnPath, pathLength );       
+            }
+            distanceOnPath = clamp( distanceOnPath, 0.0f, pathLength );
+            
+            // Which path alike segment is reached by @c distanceOnPath?
+            float remainingDistance = distanceOnPath;
+            typedef typename PathAlike::size_type size_type;
+            size_type segmentIndex = 0;        
+            size_type const maxSegmentIndex = pathAlike.segmentCount() - 1;
+            while( ( segmentIndex &lt; maxSegmentIndex ) &amp;&amp; 
+                   ( remainingDistance &gt; pathAlike.segmentLength( segmentIndex ) ) ) {
+                remainingDistance -= pathAlike.segmentLength( segmentIndex );
+                ++segmentIndex;
+            }
+            
+            // Extract the path related data associated with the segment reached
+            // by @c distanceOnPath.
+            Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
+            Vector3 tangent( 0.0f, 0.0f, 0.0f );
+            float radius = 0.0f;
+            BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, remainingDistance, pointOnPathCenterLine, tangent, radius );
+            
+            // Store the extracted data in @c mapping to return it to the caller.
+            mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
+            mapping.setRadius( radius );
+            mapping.setTangent( tangent );
+            mapping.setSegmentIndex( segmentIndex );
+            mapping.setDistanceOnPath( distanceOnPath );
+            mapping.setDistanceOnSegment( remainingDistance );            
+        }
+        
+    }; // class DistanceToPathAlikeMapping
+    
+    
+    
+    /**
+     * Maps @a distance to @a pathAlike and stores the data queried in
+     * @a mapping.
+     *
+     * See @c DistanceToPathAlikeMapping::map for further information.
+     */
+    template&lt; class PathAlike, class Mapping &gt;
+    void mapDistanceToPathAlike( PathAlike const&amp; pathAlike, float distance, Mapping&amp; mapping ) {
+        DistanceToPathAlikeMapping&lt; PathAlike, Mapping &gt;::map( pathAlike, distance, mapping );
+    }
+    
+    
+} // namespace OpenSteer
+
+#endif // OPENSTEER_QUERYPATHALIKE_H

Added: rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,71 @@
+/**
+* OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Declarations of policies used by @c OpenSteer::mapPointToPathAlike and
+ * @c OpenSteer::mapDistanceToPathAlike to extract informations of path alikes.
+ */
+#ifndef OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H
+#define OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H
+
+namespace OpenSteer {
+    
+    /**
+     * Extracts the base data like the segment distance, the radius, the
+     * distance of the query point to the path alike, the point on the path
+     * alike center line and the tangent at that point.
+     *
+     * Specialize it for the path alike to use and provide a static member
+     * function with the following signature:
+     *
+     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, Vector3 const&amp; point, float&amp; segmentDistance, float&amp; radius, float&amp; distancePointToPath, Vector3&amp; pointOnPathCenterLine, Vector3&amp; tangent )&lt;/code&gt;
+     *
+     * @attention Be aware of the references that are passed in.
+     */
+    template&lt; class PathAlike &gt;
+    class PointToPathAlikeBaseDataExtractionPolicy;
+    
+    
+    /**
+     * Extracts the base data like the radius, the point on the path
+     * alike center line and the tangent at that point.
+     *
+     * Specialize it for the path alike to use and provide a static member
+     * function with the following signature:
+     *
+     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, float segmentDistance, Vector3&amp; pointOnPathCenterLine, Vector3&amp; tangent, float&amp; radius )&lt;/code&gt;
+     *
+     * @attention Be aware of the references that are passed in.
+     */    
+    template&lt; class PathAlike &gt;
+    class DistanceToPathAlikeBaseDataExtractionPolicy;
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H

Added: rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,144 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Predefined mappings used by @c OpenSteer::mapPointToPathAlike and 
+ * @c OpenSteer::mapDistanceToPathAlike used by implementations of segmented
+ * paths and pathways.
+ */
+#ifndef OPENSTEER_QUERYPATHALIKEMAPPINGS_H
+#define OPENSTEER_QUERYPATHALIKEMAPPINGS_H
+
+
+// Include OpenSteer::HasNoRadius, OpenSteer::ExtractPathDistance, OpenSteer::DontExtractPathDistance
+#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
+
+// Include Vector3
+#include &quot;OpenSteer/Vec3.h&quot;
+
+// Include OpenSteer::size_t
+#include &quot;OpenSteer/StandardTypes.h&quot;
+
+
+
+namespace OpenSteer {
+    
+    /**
+     * Stores the point on a pathway boundary, the tangent at the associated
+     * path center line and the distance of a query point to the point on the 
+     * path boundary - used by @c OpenSteer::mapPointToPathAlike.
+     */
+    class PointToPathMapping 
+        : public DontExtractPathDistance {
+        
+    public:
+        PointToPathMapping() : pointOnPathCenterLine( 0.0f, 0.0f, 0.0f ), tangent( 0.0f, 0.0f, 0.0f ), distancePointToPath( 0.0f ) {}
+            
+        void setPointOnPathCenterLine( Vector3 const&amp; point ) {
+            pointOnPathCenterLine = point;
+        }
+        void setPointOnPathBoundary( Vector3 const&amp; ) {
+            // pointOnPathBoundary = point;
+        }
+        void setRadius( float ) {}
+        void setTangent( Vector3 const&amp; t) {
+            tangent = t;
+        }
+        void setSegmentIndex( size_t ) {}
+        void setDistancePointToPath( float distance ) {
+            distancePointToPath = distance;
+        }
+        void setDistancePointToPathCenterLine( float ) {}
+        void setDistanceOnPath( float ) {}
+        void setDistanceOnSegment( float ) {}
+            
+        Vector3 pointOnPathCenterLine;
+        // Vector3 pointOnPathBoundary; 
+        Vector3 tangent;
+        float distancePointToPath;
+            
+            
+    }; // class PointToPathMapping
+    
+    
+    /**
+     * Stores the point on a path center line for a given distance from the
+     * start of the path - used by @c OpenSteer::mapDistanceToPathAlike.
+     */
+    class PathDistanceToPointMapping 
+        :  public DontExtractPathDistance {
+            
+    public:
+        
+        void setPointOnPathCenterLine( Vector3 const&amp; vec ){
+            pointOnPathCenterLine = vec;
+        }
+        void setRadius( float ) {}
+        void setTangent( Vector3 const&amp; ){}
+        void setSegmentIndex( size_t ){}
+        void setDistanceOnPath( float ){}
+        void setDistanceOnSegment( float ){}
+            
+            
+        Vector3 pointOnPathCenterLine; 
+            
+            
+    }; // class PathDistanceToPointMapping
+    
+    
+    
+    /**
+     * Stores the distance of from the start of a path to a point on the 
+     * center line of the path - used by @c OpenSteer::mapPointToPathAlike.
+     */
+    class PointToPathDistanceMapping
+        : public ExtractPathDistance {
+    public:
+        PointToPathDistanceMapping() : distanceOnPath( 0.0f ) {}
+            
+        void setPointOnPathCenterLine( Vector3 const&amp; ) {}
+        void setPointOnPathBoundary( Vector3 const&amp;  ) {}
+        void setRadius( float ) {}
+        void setTangent( Vector3 const&amp; ) {}
+        void setSegmentIndex( size_t ) {}
+        void setDistancePointToPath( float  ) {}
+        void setDistancePointToPathCenterLine( float ) {}
+        void setDistanceOnPath( float distance ) {
+            distanceOnPath = distance;
+        }
+        void setDistanceOnSegment( float ) {}
+            
+        float distanceOnPath;
+    }; // class PointToPathDistanceMapping
+    
+    
+} // namespace OpenSteer
+
+
+
+#endif // OPENSTEER_QUERYPATHALIKEMAPPINGS_H

Added: rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,102 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Collection of helper classes to inherit from to create mappings as used by  
+ * @c OpenSteer::mapDistanceToPathAlike and 
+ * @c OpenSteer::mapPointToPathAlike.
+ */
+
+#ifndef OPENSTEER_QUERYPATHALIKEUTILITIES_H
+#define OPENSTEER_QUERYPATHALIKEUTILITIES_H
+
+
+namespace OpenSteer {
+
+    /**
+     * Inherit from it to create a mapping class used by 
+     * @c OpenSteer::mapDistanceToPathAlike and 
+     * @c OpenSteer::mapPointToPathAlike that calculates and extracts the
+     * distance along the path alike.
+     */    
+    class ExtractPathDistance {
+    public:
+        void setDistanceOnPathFlag( float distance ) {
+            distanceOnPathFlag_ = distance;
+        }
+        
+        
+        float distanceOnPathFlag() const {
+            return distanceOnPathFlag_;
+        }
+        
+    protected:
+        ExtractPathDistance() : distanceOnPathFlag_( 0.0f ) {
+            // Nothing to do.
+        }
+        
+        explicit ExtractPathDistance( float distance ) : distanceOnPathFlag_( distance ) {
+            // Nothing to do.
+        }
+        
+        ~ExtractPathDistance() {
+            // Nothing to do.
+        }
+        
+    private:
+        float distanceOnPathFlag_;
+    }; // class ExtractPathDistance
+    
+    
+    /**
+     * Inherit from it to create a mapping class used by 
+     * @c OpenSteer::mapDistanceToPathAlike and 
+     * @c OpenSteer::mapPointToPathAlike that shouldn't calculate and extract the
+     * distance along the path alike.
+     */
+    class DontExtractPathDistance {
+    public:
+        void setDistanceOnPathFlag( float ) {
+            // Nothing to do.
+        }
+        
+        float distanceOnPathFlag() const {
+            return 0.0f;
+        };
+        
+    protected:
+        ~DontExtractPathDistance() {
+            // Nothing to do.
+        }
+    }; // class DontExtractPathDistance
+    
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_QUERYPATHALIKEUTILITIES_H

Added: rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,157 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Abstract segmented path class for paths build of segments between waypoints.
+ */
+#ifndef OPENSTEER_SEGMENTEDPATH_H
+#define OPENSTEER_SEGMENTEDPATH_H
+
+// Include OpenSteer::Path
+#include &quot;OpenSteer/Path.h&quot;
+
+// Include OpenSteer::size_t
+#include &quot;OpenSteer/StandardTypes.h&quot;
+
+namespace OpenSteer {
+    
+    /**
+     * Path build by segments between points on the path.
+     */
+    class SegmentedPath : public Path {
+    public:
+        typedef size_t size_type;
+        
+        virtual ~SegmentedPath() = 0;
+        
+        
+        /**
+         * Returns the number of points defining the segments.
+         *
+         * This also includes the duplicated first point if the path is cyclic.
+         */
+        virtual size_type pointCount() const = 0;
+        
+        /**
+         * Returns the point @a pointIndex.
+         *
+         * If the path is cyclic also the last point that is the duplicated
+         * first one is accessible.
+         */
+        virtual Vector3 point( size_type pointIndex ) const = 0;
+        
+        
+        
+        /**
+         * Returns the number of segments that build the pathway.
+         */
+        virtual size_type segmentCount() const = 0;
+        
+        /**
+         * Returns the length of segment @a segmentIndex.
+         */
+        virtual float segmentLength( size_type segmentIndex ) const = 0;
+        
+        /**
+         * Returns the start point of the segment @a segmentIndex.
+         */
+        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
+        
+        /**
+         * Returns the end point of segment @a segmentIndex.
+         */
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
+        
+        
+        /**
+         * Maps @a point to the nearest point on the center line of segment
+         * @a segmentIndex and returns the distance from the segment start to 
+         * this point.
+         */
+        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
+                                                 Vector3 const&amp; point ) const = 0;
+        
+        
+        /**
+         * Maps @a segmentDistance to the center line of segment @a segmentIndex
+         * and returns the reached point.
+         *
+         * If @a segmentDistance is greater or smaller than the segment length
+         * is is clamped to @c 0.0f or @c segmentLength().
+         */
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                float segmentDistance ) const = 0;
+        
+        /**
+         * Maps @a segmentDistance to the centerline of the segment 
+         * @a segmentIndex and returns the tangent of the pathway at the reached
+         * point.
+         *
+         * If @a segmentDistance is greater or smaller than the segment length
+         * is is clamped to @c 0.0f or @c segmentLength().
+         */
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+                                                  float segmentDistance ) const = 0;
+        
+        
+        /**
+         * Combines @c mapSegmentDistanceToPoint and 
+         * @c mapSegmentDistanceToTangent.
+         */
+        virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
+                                                          float distance,
+                                                          Vector3&amp; pointOnPath,
+                                                          Vector3&amp; tangent ) const = 0;
+        
+        
+        /**
+         * Combines @c mapPointToSegmentDistance, @c mapSegmentDistanceToPoint, 
+         * and @c mapSegmentDistanceToTangent.
+         */
+        virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
+                                                                  Vector3 const&amp; point,
+                                                                  float&amp; distance,
+                                                                  Vector3&amp; pointOnPath,
+                                                                  Vector3&amp; tangent ) const = 0;
+
+    protected:
+        /**
+         * Protected to disable assigning instances of different inherited 
+         * classes to each other.
+         *
+         * @todo Should this be added or not? Have to read a bit...
+         */
+        // SegmentedPath&amp; operator=( SegmentedPath const&amp; );
+        
+    }; // class SegmentedPath
+    
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_SEGMENTEDPATH_H

Added: rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,173 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ *
+ * Abstract pathway build of segments between waypoints.
+ */
+#ifndef OPENSTEER_SEGMENTEDPATHWAY_H
+#define OPENSTEER_SEGMENTEDPATHWAY_H
+
+
+// Include OpenSteer::Pathway
+#include &quot;OpenSteer/Pathway.h&quot;
+
+// Include OpenSteer::size_t
+#include &quot;OpenSteer/StandardTypes.h&quot;
+
+
+namespace OpenSteer {
+
+    /**
+     * Path defined by path segments.
+     *
+     * Look at @c QueryPathAlikes.h for functionality to query paths and
+     * pathways for information not provided here.
+     */
+    class SegmentedPathway: public Pathway {
+    public:
+        typedef size_t size_type;
+        
+        
+        virtual ~SegmentedPathway() = 0;
+        
+        /**
+         * Returns the number of points defining the segments.
+         *
+         * This also includes the duplicated first point if the path is cyclic.
+         */
+        virtual size_type pointCount() const = 0;
+        
+        /**
+         * Returns the point @a pointIndex.
+         *
+         * If the path is cyclic also the last point that is the duplicated
+         * first one is accessible.
+         */
+        virtual Vector3 point( size_type pointIndex ) const = 0;
+        
+        
+        /**
+         * Returns the number of segments that build the pathway.
+         */
+        virtual size_type segmentCount() const = 0;
+        
+        /**
+         * Returns the length of segment @a segmentIndex.
+         */
+        virtual float segmentLength( size_type segmentIndex ) const = 0;
+        
+        /**
+         * Returns the start point of the segment @a segmentIndex.
+         */
+        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
+        
+        /**
+         * Returns the end point of segment @a segmentIndex.
+         */
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
+        
+        
+        
+        /**
+         * Maps @a point to the nearest point on the center line of segment
+         * @a segmentIndex and returns the distance from the segment start to 
+         * this point.
+         */
+        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
+                                                 Vector3 const&amp; point ) const = 0;
+        
+        
+        /**
+         * Maps @a segmentDistance to the center line of segment @a segmentIndex
+         * and returns the reached point.
+         *
+         * If @a segmentDistance is greater or smaller than the segment length
+         * is is clamped to @c 0.0f or @c segmentLength().
+         */
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                float segmentDistance ) const = 0;
+        
+        /**
+         * Maps @a segmentDistance to the center line of segment @a segmentIndex
+         * and returns the radius at the reached point.
+         *
+         * If @a segmentDistance is greater or smaller than the segment length
+         * is is clamped to @c 0.0f or @c segmentLength().
+         */
+        virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
+                                                 float distanceOnSegment ) const = 0;
+        
+        /**
+         * Maps @a segmentDistance to the centerline of the segment 
+         * @a segmentIndex and returns the tangent of the pathway at the reached
+         * point.
+         *
+         * If @a segmentDistance is greater or smaller than the segment length
+         * is is clamped to @c 0.0f or @c segmentLength().
+         */
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+                                                  float segmentDistance ) const = 0;
+        
+        /**
+         * Combines @c mapSegmentDistanceToPoint and 
+         * @c mapSegmentDistanceToTangent and @c mapSegmentDistanceToRadius.
+         */
+        virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
+                                                                   float segmentDistance,
+                                                                   Vector3&amp; pointOnPath,
+                                                                   Vector3&amp; tangent,
+                                                                   float&amp; radius ) const = 0;        
+        
+        /**
+         * Combines @c mapPointToSegmentDistance, @c mapSegmentDistanceToPoint,
+         * @c mapSegmentDistanceToRadius, and @c mapSegmentDistanceToTangent.
+         */
+        virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
+                                                                           Vector3 const&amp; point,
+                                                                           float&amp; distance,
+                                                                           Vector3&amp; pointOnPath,
+                                                                           Vector3&amp; tangent,
+                                                                           float&amp; radius) const = 0;
+        
+       
+    protected:
+        /**
+         * Protected to disable assigning instances of different inherited 
+         * classes to each other.
+         *
+         * @todo Should this be added or not? Have to read a bit...
+         */
+        // SegmentedPathway&amp; operator=( SegmentedPathway const&amp; );    
+    }; // class SegmentedPathway
+    
+    
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_SEGMENTEDPATHWAY_H

Added: rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,46 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original authors: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @file
+ *
+ * Primitive standard types.
+ */
+#ifndef OPENSTEER_STANDARDTYPES_H
+#define OPENSTEER_STANDARDTYPES_H
+
+// Include std::size_t, std::ptrdiff_t
+#include &lt;cstddef&gt;
+
+
+namespace OpenSteer {
+    
+    
+    typedef std::size_t size_t;
+    typedef std::ptrdiff_t ptrdiff_t;
+    
+} // namespace OpenSteer
+
+
+#endif // OPENSTEER_STANDARDTYPES_H

Added: rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,1076 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// SteerLibraryMixin
+//
+// This mixin (class with templated superclass) adds the &quot;steering library&quot;
+// functionality to a given base class.  SteerLibraryMixin assumes its base
+// class supports the AbstractVehicle interface.
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 02-06-03 cwr: create mixin (from &quot;SteerMass&quot;)
+// 06-03-02 cwr: removed TS dependencies
+// 11-21-01 cwr: created
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_STEERLIBRARY_H
+#define OPENSTEER_STEERLIBRARY_H
+
+
+#include &quot;OpenSteer/AbstractVehicle.h&quot;
+#include &quot;OpenSteer/Pathway.h&quot;
+#include &quot;OpenSteer/Obstacle.h&quot;
+#include &quot;OpenSteer/Utilities.h&quot;
+
+// Include OpenSteer::Color, OpenSteer::gBlack, ...
+#include &quot;Color.h&quot;
+
+namespace OpenSteer {
+
+    // ----------------------------------------------------------------------------
+
+
+    template &lt;class Super&gt;
+    class SteerLibraryMixin : public Super
+    {
+    public:
+        using Super::getVelocity;
+        using Super::getMaxSpeed;
+        using Super::getSpeed;
+        using Super::getRadius;
+        using Super::getMaxForce;
+        using Super::getForward;
+        using Super::getPosition;
+        using Super::getSide;
+        using Super::getUp;
+        using Super::predictFuturePosition;
+        
+    public:
+
+        // Constructor: initializes state
+        SteerLibraryMixin ()
+        {
+            // set inital state
+            reset ();
+        }
+
+        // reset state
+        void reset (void)
+        {
+            // initial state of wander behavior
+            WanderSide = 0;
+            WanderUp = 0;
+
+            // default to non-gaudyPursuitAnnotation
+            gaudyPursuitAnnotation = false;
+        }
+
+        // -------------------------------------------------- steering behaviors
+
+        // Wander behavior
+        float WanderSide;
+        float WanderUp;
+        Vector3 steerForWander (float dt);
+
+        // Seek behavior
+        Vector3 steerForSeek (const Vector3&amp; target);
+
+        // Flee behavior
+        Vector3 steerForFlee (const Vector3&amp; target);
+
+        // xxx proposed, experimental new seek/flee [cwr 9-16-02]
+        Vector3 xxxsteerForFlee (const Vector3&amp; target);
+        Vector3 xxxsteerForSeek (const Vector3&amp; target);
+
+        // Path Following behaviors
+        Vector3 steerToFollowPath (const int direction,
+                                const float predictionTime,
+                                Pathway&amp; path);
+        Vector3 steerToStayOnPath (const float predictionTime, Pathway&amp; path);
+
+        // ------------------------------------------------------------------------
+        // Obstacle Avoidance behavior
+        //
+        // Returns a steering force to avoid a given obstacle.  The purely
+        // lateral steering force will turn our vehicle towards a silhouette edge
+        // of the obstacle.  Avoidance is required when (1) the obstacle
+        // intersects the vehicle's current path, (2) it is in front of the
+        // vehicle, and (3) is within minTimeToCollision seconds of travel at the
+        // vehicle's current velocity.  Returns a zero vector value (Vector3::ZERO)
+        // when no avoidance is required.
+
+
+        Vector3 steerToAvoidObstacle (const float minTimeToCollision,
+                                   const Obstacle&amp; obstacle);
+
+
+        // avoids all obstacles in an ObstacleGroup
+
+        Vector3 steerToAvoidObstacles (const float minTimeToCollision,
+                                    const ObstacleGroup&amp; obstacles);
+
+
+        // ------------------------------------------------------------------------
+        // Unaligned collision avoidance behavior: avoid colliding with other
+        // nearby vehicles moving in unconstrained directions.  Determine which
+        // (if any) other other vehicle we would collide with first, then steers
+        // to avoid the site of that potential collision.  Returns a steering
+        // force vector, which is zero length if there is no impending collision.
+
+
+        Vector3 steerToAvoidNeighbors (const float minTimeToCollision,
+                                    const AVGroup&amp; others);
+
+
+        // Given two vehicles, based on their current positions and velocities,
+        // determine the time until nearest approach
+        float predictNearestApproachTime (AbstractVehicle&amp; otherVehicle);
+
+        // Given the time until nearest approach (predictNearestApproachTime)
+        // determine position of each vehicle at that time, and the distance
+        // between them
+        float computeNearestApproachPositions (AbstractVehicle&amp; otherVehicle,
+                                               float time);
+
+
+        /// XXX globals only for the sake of graphical annotation
+        Vector3 hisPositionAtNearestApproach;
+        Vector3 ourPositionAtNearestApproach;
+
+
+        // ------------------------------------------------------------------------
+        // avoidance of &quot;close neighbors&quot; -- used only by steerToAvoidNeighbors
+        //
+        // XXX  Does a hard steer away from any other agent who comes withing a
+        // XXX  critical distance.  Ideally this should be replaced with a call
+        // XXX  to steerForSeparation.
+
+
+        Vector3 steerToAvoidCloseNeighbors (const float minSeparationDistance,
+                                         const AVGroup&amp; others);
+
+
+        // ------------------------------------------------------------------------
+        // used by boid behaviors
+
+
+        bool inBoidNeighborhood (const AbstractVehicle&amp; otherVehicle,
+                                 const float minDistance,
+                                 const float maxDistance,
+                                 const float cosMaxAngle);
+
+
+        // ------------------------------------------------------------------------
+        // Separation behavior -- determines the direction away from nearby boids
+
+
+        Vector3 steerForSeparation (const float maxDistance,
+                                 const float cosMaxAngle,
+                                 const AVGroup&amp; flock);
+
+
+        // ------------------------------------------------------------------------
+        // Alignment behavior
+
+        Vector3 steerForAlignment (const float maxDistance,
+                                const float cosMaxAngle,
+                                const AVGroup&amp; flock);
+
+
+        // ------------------------------------------------------------------------
+        // Cohesion behavior
+
+
+        Vector3 steerForCohesion (const float maxDistance,
+                               const float cosMaxAngle,
+                               const AVGroup&amp; flock);
+
+
+        // ------------------------------------------------------------------------
+        // pursuit of another vehicle (&amp; version with ceiling on prediction time)
+
+
+        Vector3 steerForPursuit (const AbstractVehicle&amp; quarry);
+
+        Vector3 steerForPursuit (const AbstractVehicle&amp; quarry,
+                              const float maxPredictionTime);
+
+        // for annotation
+        bool gaudyPursuitAnnotation;
+
+
+        // ------------------------------------------------------------------------
+        // evasion of another vehicle
+
+
+        Vector3 steerForEvasion (const AbstractVehicle&amp; menace,
+                              const float maxPredictionTime);
+
+
+        // ------------------------------------------------------------------------
+        // tries to maintain a given speed, returns a maxForce-clipped steering
+        // force along the forward/backward axis
+
+
+        Vector3 steerForTargetSpeed (const float targetSpeed);
+
+
+        // ----------------------------------------------------------- utilities
+        // XXX these belong somewhere besides the steering library
+        // XXX above AbstractVehicle, below SimpleVehicle
+        // XXX (&quot;utility vehicle&quot;?)
+
+        // xxx cwr experimental 9-9-02 -- names OK?
+        bool isAhead (const Vector3&amp; target) const {return isAhead (target, 0.707f);};
+        bool isAside (const Vector3&amp; target) const {return isAside (target, 0.707f);};
+        bool isBehind (const Vector3&amp; target) const {return isBehind (target, -0.707f);};
+
+        bool isAhead (const Vector3&amp; target, float cosThreshold) const
+        {
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            return getForward().dotProduct(targetDirection) &gt; cosThreshold;
+        };
+        bool isAside (const Vector3&amp; target, float cosThreshold) const
+        {
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            const float dp = getForward().dotProduct(targetDirection);
+            return (dp &lt; cosThreshold) &amp;&amp; (dp &gt; -cosThreshold);
+        };
+        bool isBehind (const Vector3&amp; target, float cosThreshold) const
+        {
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            return getForward().dotProduct(targetDirection) &lt; cosThreshold;
+        };
+
+
+        // ------------------------------------------------ graphical annotation
+        // (parameter names commented out to prevent compiler warning from &quot;-W&quot;)
+
+
+        // called when steerToAvoidObstacles decides steering is required
+        // (default action is to do nothing, layered classes can overload it)
+        virtual void annotateAvoidObstacle (const float /*minDistanceToCollision*/)
+        {
+        }
+
+        // called when steerToFollowPath decides steering is required
+        // (default action is to do nothing, layered classes can overload it)
+        virtual void annotatePathFollowing (const Vector3&amp; /*future*/,
+                                            const Vector3&amp; /*onPath*/,
+                                            const Vector3&amp; /*target*/,
+                                            const float /*outside*/)
+        {
+        }
+
+        // called when steerToAvoidCloseNeighbors decides steering is required
+        // (default action is to do nothing, layered classes can overload it)
+        virtual void annotateAvoidCloseNeighbor (const AbstractVehicle&amp; /*other*/,
+                                                 const float /*additionalDistance*/)
+        {
+        }
+
+        // called when steerToAvoidNeighbors decides steering is required
+        // (default action is to do nothing, layered classes can overload it)
+        virtual void annotateAvoidNeighbor (const AbstractVehicle&amp; /*threat*/,
+                                            const float /*steer*/,
+                                            const Vector3&amp; /*ourFuture*/,
+                                            const Vector3&amp; /*threatFuture*/)
+        {
+        }
+    };
+
+    
+} // namespace OpenSteer
+
+// ----------------------------------------------------------------------------
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForWander (float dt)
+{
+    // random walk WanderSide and WanderUp between -1 and +1
+    const float speed = 12.0f * dt; // maybe this (12) should be an argument?
+    WanderSide = scalarRandomWalk (WanderSide, speed, -1, +1);
+    WanderUp   = scalarRandomWalk (WanderUp,   speed, -1, +1);
+
+    // return a pure lateral steering vector: (+/-Side) + (+/-Up)
+    return (getSide() * WanderSide) + (getUp() * WanderUp);
+}
+
+
+// ----------------------------------------------------------------------------
+// Seek behavior
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForSeek (const Vector3&amp; target)
+{
+    const Vector3 desiredVelocity = target - getPosition();
+    return desiredVelocity - getVelocity();
+}
+
+
+// ----------------------------------------------------------------------------
+// Flee behavior
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForFlee (const Vector3&amp; target)
+{
+    const Vector3 desiredVelocity = getPosition() - target;
+    return desiredVelocity - getVelocity();
+}
+
+
+// ----------------------------------------------------------------------------
+// xxx proposed, experimental new seek/flee [cwr 9-16-02]
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+xxxsteerForFlee (const Vector3&amp; target)
+{
+//  const Vector3 offset = position - target;
+    const Vector3 offset = getPosition() - target;
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
+    return desiredVelocity - getVelocity();
+}
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+xxxsteerForSeek (const Vector3&amp; target)
+{
+//  const Vector3 offset = target - position;
+    const Vector3 offset = target - getPosition();
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
+    return desiredVelocity - getVelocity();
+}
+
+
+// ----------------------------------------------------------------------------
+// Path Following behaviors
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerToStayOnPath (const float predictionTime, Pathway&amp; path)
+{
+    // predict our future position
+    const Vector3 futurePosition = predictFuturePosition (predictionTime);
+
+    // find the point on the path nearest the predicted future position
+    Vector3 tangent;
+    float outside;
+    const Vector3 onPath = path.mapPointToPath (futurePosition,
+                                             tangent,     // output argument
+                                             outside);    // output argument
+
+    if (outside &lt; 0)
+    {
+        // our predicted future position was in the path,
+        // return zero steering.
+        return Vector3::ZERO;
+    }
+    else
+    {
+        // our predicted future position was outside the path, need to
+        // steer towards it.  Use onPath projection of futurePosition
+        // as seek target
+        annotatePathFollowing (futurePosition, onPath, onPath, outside);
+        return steerForSeek (onPath);
+    }
+}
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerToFollowPath (const int direction,
+                   const float predictionTime,
+                   Pathway&amp; path)
+{
+    // our goal will be offset from our path distance by this amount
+    const float pathDistanceOffset = direction * predictionTime * getSpeed();
+
+    // predict our future position
+    const Vector3 futurePosition = predictFuturePosition (predictionTime);
+
+    // measure distance along path of our current and predicted positions
+    const float nowPathDistance =
+        path.mapPointToPathDistance (getPosition());
+    const float futurePathDistance =
+        path.mapPointToPathDistance (futurePosition);
+
+    // are we facing in the correction direction?
+    const bool rightway = ((pathDistanceOffset &gt; 0) ?
+                           (nowPathDistance &lt; futurePathDistance) :
+                           (nowPathDistance &gt; futurePathDistance));
+
+    // find the point on the path nearest the predicted future position
+    // XXX need to improve calling sequence, maybe change to return a
+    // XXX special path-defined object which includes two Vec3s and a 
+    // XXX bool (onPath,tangent (ignored), withinPath)
+    Vector3 tangent;
+    float outside;
+    const Vector3 onPath = path.mapPointToPath (futurePosition,
+                                             // output arguments:
+                                             tangent,
+                                             outside);
+
+    // no steering is required if (a) our future position is inside
+    // the path tube and (b) we are facing in the correct direction
+    if ((outside &lt; 0) &amp;&amp; rightway)
+    {
+        // all is well, return zero steering
+        return Vector3::ZERO;
+    }
+    else
+    {
+        // otherwise we need to steer towards a target point obtained
+        // by adding pathDistanceOffset to our current path position
+
+        float const targetPathDistance = nowPathDistance + pathDistanceOffset;
+        Vector3 const target = path.mapPathDistanceToPoint (targetPathDistance);
+
+        annotatePathFollowing (futurePosition, onPath, target, outside);
+
+        // return steering to seek target on path
+        return steerForSeek (target);
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// Obstacle Avoidance behavior
+//
+// Returns a steering force to avoid a given obstacle.  The purely lateral
+// steering force will turn our vehicle towards a silhouette edge of the
+// obstacle.  Avoidance is required when (1) the obstacle intersects the
+// vehicle's current path, (2) it is in front of the vehicle, and (3) is
+// within minTimeToCollision seconds of travel at the vehicle's current
+// velocity.  Returns a zero vector value (Vector3::ZERO) when no avoidance is
+// required.
+//
+// XXX The current (4-23-03) scheme is to dump all the work on the various
+// XXX Obstacle classes, making them provide a &quot;steer vehicle to avoid me&quot;
+// XXX method.  This may well change.
+//
+// XXX 9-12-03: this routine is probably obsolete: its name is too close to
+// XXX the new steerToAvoidObstacles and the arguments are reversed
+// XXX (perhaps there should be another version of steerToAvoidObstacles
+// XXX whose second arg is &quot;const Obstacle&amp; obstacle&quot; just in case we want
+// XXX to avoid a non-grouped obstacle)
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerToAvoidObstacle (const float minTimeToCollision,
+                      const Obstacle&amp; obstacle)
+{
+    const Vector3 avoidance = obstacle.steerToAvoid (*this, minTimeToCollision);
+
+    // XXX more annotation modularity problems (assumes spherical obstacle)
+    if (avoidance != Vector3::ZERO)
+        annotateAvoidObstacle (minTimeToCollision * getSpeed());
+
+    return avoidance;
+}
+
+
+// this version avoids all of the obstacles in an ObstacleGroup
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerToAvoidObstacles (const float minTimeToCollision,
+                       const ObstacleGroup&amp; obstacles)
+{
+    const Vector3 avoidance = Obstacle::steerToAvoidObstacles (*this,
+                                                            minTimeToCollision,
+                                                            obstacles);
+
+    // XXX more annotation modularity problems (assumes spherical obstacle)
+    if (avoidance != Vector3::ZERO)
+        annotateAvoidObstacle (minTimeToCollision * getSpeed());
+
+    return avoidance;
+}
+
+
+// ----------------------------------------------------------------------------
+// Unaligned collision avoidance behavior: avoid colliding with other nearby
+// vehicles moving in unconstrained directions.  Determine which (if any)
+// other other vehicle we would collide with first, then steers to avoid the
+// site of that potential collision.  Returns a steering force vector, which
+// is zero length if there is no impending collision.
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerToAvoidNeighbors (const float minTimeToCollision,
+                       const AVGroup&amp; others)
+{
+    // first priority is to prevent immediate interpenetration
+    const Vector3 separation = steerToAvoidCloseNeighbors (0, others);
+    if (separation != Vector3::ZERO) return separation;
+
+    // otherwise, go on to consider potential future collisions
+    float steer = 0;
+    AbstractVehicle* threat = NULL;
+
+    // Time (in seconds) until the most immediate collision threat found
+    // so far.  Initial value is a threshold: don't look more than this
+    // many frames into the future.
+    float minTime = minTimeToCollision;
+
+    // xxx solely for annotation
+    Vector3 xxxThreatPositionAtNearestApproach;
+    Vector3 xxxOurPositionAtNearestApproach;
+
+    // for each of the other vehicles, determine which (if any)
+    // pose the most immediate threat of collision.
+    for (AVIterator i = others.begin(); i != others.end(); i++)
+    {
+        AbstractVehicle&amp; other = **i;
+        if (&amp;other != this)
+        {	
+            // avoid when future positions are this close (or less)
+            const float collisionDangerThreshold = getRadius() * 2;
+
+            // predicted time until nearest approach of &quot;this&quot; and &quot;other&quot;
+            const float time = predictNearestApproachTime (other);
+
+            // If the time is in the future, sooner than any other
+            // threatened collision...
+            if ((time &gt;= 0) &amp;&amp; (time &lt; minTime))
+            {
+                // if the two will be close enough to collide,
+                // make a note of it
+                if (computeNearestApproachPositions (other, time)
+                    &lt; collisionDangerThreshold)
+                {
+                    minTime = time;
+                    threat = &other;
+                    xxxThreatPositionAtNearestApproach
+                        = hisPositionAtNearestApproach;
+                    xxxOurPositionAtNearestApproach
+                        = ourPositionAtNearestApproach;
+                }
+            }
+        }
+    }
+
+    // if a potential collision was found, compute steering to avoid
+    if (threat != NULL)
+    {
+        // parallel: +1, perpendicular: 0, anti-parallel: -1
+        float parallelness = getForward().dotProduct(threat-&gt;getForward());
+        float angle = 0.707f;
+
+        if (parallelness &lt; -angle)
+        {
+            // anti-parallel &quot;head on&quot; paths:
+            // steer away from future threat position
+            Vector3 offset = xxxThreatPositionAtNearestApproach - getPosition();
+            float sideDot = offset.dotProduct(getSide());
+            steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
+        }
+        else
+        {
+            if (parallelness &gt; angle)
+            {
+                // parallel paths: steer away from threat
+                Vector3 offset = threat-&gt;getPosition() - getPosition();
+                float sideDot = offset.dotProduct(getSide());
+                steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
+            }
+            else
+            {
+                // perpendicular paths: steer behind threat
+                // (only the slower of the two does this)
+                if (threat-&gt;getSpeed() &lt;= getSpeed())
+                {
+                    float sideDot = getSide().dotProduct(threat-&gt;getVelocity());
+                    steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
+                }
+            }
+        }
+
+        annotateAvoidNeighbor (*threat,
+                               steer,
+                               xxxOurPositionAtNearestApproach,
+                               xxxThreatPositionAtNearestApproach);
+    }
+
+    return getSide() * steer;
+}
+
+
+
+// Given two vehicles, based on their current positions and velocities,
+// determine the time until nearest approach
+//
+// XXX should this return zero if they are already in contact?
+
+template&lt;class Super&gt;
+float
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+predictNearestApproachTime (AbstractVehicle&amp; otherVehicle)
+{
+    // imagine we are at the origin with no velocity,
+    // compute the relative velocity of the other vehicle
+    const Vector3 myVelocity = getVelocity();
+    const Vector3 otherVelocity = otherVehicle.getVelocity();
+    const Vector3 relVelocity = otherVelocity - myVelocity;
+    const float relSpeed = relVelocity.length();
+
+    // for parallel paths, the vehicles will always be at the same distance,
+    // so return 0 (aka &quot;now&quot;) since &quot;there is no time like the present&quot;
+    if (relSpeed == 0) return 0;
+
+    // Now consider the path of the other vehicle in this relative
+    // space, a line defined by the relative position and velocity.
+    // The distance from the origin (our vehicle) to that line is
+    // the nearest approach.
+
+    // Take the unit tangent along the other vehicle's path
+    const Vector3 relTangent = relVelocity / relSpeed;
+
+    // find distance from its path to origin (compute offset from
+    // other to us, find length of projection onto path)
+    const Vector3 relPosition = getPosition() - otherVehicle.getPosition();
+    const float projection = relTangent.dotProduct(relPosition);
+
+    return projection / relSpeed;
+}
+
+
+// Given the time until nearest approach (predictNearestApproachTime)
+// determine position of each vehicle at that time, and the distance
+// between them
+
+
+template&lt;class Super&gt;
+float
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+computeNearestApproachPositions (AbstractVehicle&amp; otherVehicle,
+                                 float time)
+{
+    const Vector3    myTravel =       getForward() *       getSpeed() * time;
+    const Vector3 otherTravel = otherVehicle.getForward() * otherVehicle.getSpeed () * time;
+
+    const Vector3    myFinal =       getPosition() +    myTravel;
+    const Vector3 otherFinal = otherVehicle.getPosition() + otherTravel;
+
+    // xxx for annotation
+    ourPositionAtNearestApproach = myFinal;
+    hisPositionAtNearestApproach = otherFinal;
+
+    return myFinal.distance(otherFinal);
+}
+
+
+
+// ----------------------------------------------------------------------------
+// avoidance of &quot;close neighbors&quot; -- used only by steerToAvoidNeighbors
+//
+// XXX  Does a hard steer away from any other agent who comes withing a
+// XXX  critical distance.  Ideally this should be replaced with a call
+// XXX  to steerForSeparation.
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerToAvoidCloseNeighbors (const float minSeparationDistance,
+                            const AVGroup&amp; others)
+{
+    // for each of the other vehicles...
+    for (AVIterator i = others.begin(); i != others.end(); i++)    
+    {
+        AbstractVehicle&amp; other = **i;
+        if (&amp;other != this)
+        {
+            const float sumOfRadii = getRadius() + other.getRadius();
+            const float minCenterToCenter = minSeparationDistance + sumOfRadii;
+            const Vector3 offset = other.getPosition() - getPosition();
+            const float currentDistance = offset.length();
+
+            if (currentDistance &lt; minCenterToCenter)
+            {
+                annotateAvoidCloseNeighbor (other, minSeparationDistance);
+                return Vec3Utils::perpendicularComponent(-offset, getForward());
+            }
+        }
+    }
+
+    // otherwise return zero
+    return Vector3::ZERO;
+}
+
+
+// ----------------------------------------------------------------------------
+// used by boid behaviors: is a given vehicle within this boid's neighborhood?
+
+
+template&lt;class Super&gt;
+bool
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+inBoidNeighborhood (const AbstractVehicle&amp; otherVehicle,
+                    const float minDistance,
+                    const float maxDistance,
+                    const float cosMaxAngle)
+{
+    if (&amp;otherVehicle == this)
+    {
+        return false;
+    }
+    else
+    {
+        const Vector3 offset = otherVehicle.getPosition() - getPosition();
+        const float distanceSquared = offset.squaredLength();
+
+        // definitely in neighborhood if inside minDistance sphere
+        if (distanceSquared &lt; (minDistance * minDistance))
+        {
+            return true;
+        }
+        else
+        {
+            // definitely not in neighborhood if outside maxDistance sphere
+            if (distanceSquared &gt; (maxDistance * maxDistance))
+            {
+                return false;
+            }
+            else
+            {
+                // otherwise, test angular offset from forward axis
+                const Vector3 unitOffset = offset / sqrt (distanceSquared);
+                const float forwardness = getForward().dotProduct(unitOffset);
+                return forwardness &gt; cosMaxAngle;
+            }
+        }
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// Separation behavior: steer away from neighbors
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForSeparation (const float maxDistance,
+                    const float cosMaxAngle,
+                    const AVGroup&amp; flock)
+{
+    // steering accumulator and count of neighbors, both initially zero
+    Vector3 steering;
+    int neighbors = 0;
+
+    // for each of the other vehicles...
+    AVIterator flockEndIter = flock.end();
+    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flockEndIter; ++otherVehicle )
+    {
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
+        {
+            // add in steering contribution
+            // (opposite of the offset direction, divided once by distance
+            // to normalize, divided another time to get 1/d falloff)
+            const Vector3 offset = (**otherVehicle).getPosition() - getPosition();
+            const float distanceSquared = offset.dotProduct(offset);
+            steering += (offset / -distanceSquared);
+
+            // count neighbors
+            ++neighbors;
+        }
+    }
+
+    // divide by neighbors, then normalize to pure direction
+    // bk: Why dividing if you normalize afterwards?
+    //     As long as normilization tests for @c 0 we can just call normalize
+    //     and safe the branching if.
+    /*
+    if (neighbors &gt; 0) {
+        steering /= neighbors;
+        steering = steering.normalisedCopy();
+    }
+    */
+    steering = steering.normalisedCopy();
+    
+    return steering;
+}
+
+
+// ----------------------------------------------------------------------------
+// Alignment behavior: steer to head in same direction as neighbors
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForAlignment (const float maxDistance,
+                   const float cosMaxAngle,
+                   const AVGroup&amp; flock)
+{
+    // steering accumulator and count of neighbors, both initially zero
+    Vector3 steering;
+    int neighbors = 0;
+
+    // for each of the other vehicles...
+    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
+    {
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
+        {
+            // accumulate sum of neighbor's heading
+            steering += (**otherVehicle).getForward();
+
+            // count neighbors
+            neighbors++;
+        }
+    }
+
+    // divide by neighbors, subtract off current heading to get error-
+    // correcting direction, then normalize to pure direction
+    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - getForward()).normalisedCopy();
+
+    return steering;
+}
+
+
+// ----------------------------------------------------------------------------
+// Cohesion behavior: to to move toward center of neighbors
+
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForCohesion (const float maxDistance,
+                  const float cosMaxAngle,
+                  const AVGroup&amp; flock)
+{
+    // steering accumulator and count of neighbors, both initially zero
+    Vector3 steering;
+    int neighbors = 0;
+
+    // for each of the other vehicles...
+    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
+    {
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
+        {
+            // accumulate sum of neighbor's positions
+            steering += (**otherVehicle).getPosition();
+
+            // count neighbors
+            neighbors++;
+        }
+    }
+
+    // divide by neighbors, subtract off current position to get error-
+    // correcting direction, then normalize to pure direction
+    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - getPosition()).normalisedCopy();
+
+    return steering;
+}
+
+
+// ----------------------------------------------------------------------------
+// pursuit of another vehicle (&amp; version with ceiling on prediction time)
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForPursuit (const AbstractVehicle&amp; quarry)
+{
+    return steerForPursuit (quarry, FLT_MAX);
+}
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForPursuit (const AbstractVehicle&amp; quarry,
+                 const float maxPredictionTime)
+{
+    // offset from this to quarry, that distance, unit vector toward quarry
+    const Vector3 offset = quarry.getPosition() - getPosition();
+    const float distance = offset.length ();
+    const Vector3 unitOffset = offset / distance;
+
+    // how parallel are the paths of &quot;this&quot; and the quarry
+    // (1 means parallel, 0 is pependicular, -1 is anti-parallel)
+    const float parallelness = getForward().dotProduct(quarry.getForward());
+
+    // how &quot;forward&quot; is the direction to the quarry
+    // (1 means dead ahead, 0 is directly to the side, -1 is straight back)
+    const float forwardness = getForward().dotProduct(unitOffset);
+
+    const float directTravelTime = distance / getSpeed();
+    const int f = intervalComparison (forwardness,  -0.707f, 0.707f);
+    const int p = intervalComparison (parallelness, -0.707f, 0.707f);
+
+    float timeFactor = 0; // to be filled in below
+    Color color;           // to be filled in below (xxx just for debugging)
+
+    // Break the pursuit into nine cases, the cross product of the
+    // quarry being [ahead, aside, or behind] us and heading
+    // [parallel, perpendicular, or anti-parallel] to us.
+    switch (f)
+    {
+    case +1:
+        switch (p)
+        {
+        case +1:          // ahead, parallel
+            timeFactor = 4;
+            color = gBlack;
+            break;
+        case 0:           // ahead, perpendicular
+            timeFactor = 1.8f;
+            color = gGray50;
+            break;
+        case -1:          // ahead, anti-parallel
+            timeFactor = 0.85f;
+            color = gWhite;
+            break;
+        }
+        break;
+    case 0:
+        switch (p)
+        {
+        case +1:          // aside, parallel
+            timeFactor = 1;
+            color = gRed;
+            break;
+        case 0:           // aside, perpendicular
+            timeFactor = 0.8f;
+            color = gYellow;
+            break;
+        case -1:          // aside, anti-parallel
+            timeFactor = 4;
+            color = gGreen;
+            break;
+        }
+        break;
+    case -1:
+        switch (p)
+        {
+        case +1:          // behind, parallel
+            timeFactor = 0.5f;
+            color= gCyan;
+            break;
+        case 0:           // behind, perpendicular
+            timeFactor = 2;
+            color= gBlue;
+            break;
+        case -1:          // behind, anti-parallel
+            timeFactor = 2;
+            color = gMagenta;
+            break;
+        }
+        break;
+    }
+
+    // estimated time until intercept of quarry
+    const float et = directTravelTime * timeFactor;
+
+    // xxx experiment, if kept, this limit should be an argument
+    const float etl = (et &gt; maxPredictionTime) ? maxPredictionTime : et;
+
+    // estimated position of quarry at intercept
+    const Vector3 target = quarry.predictFuturePosition (etl);
+
+    // annotation
+/*    annotationLine (getPosition(),
+                    target,
+                    gaudyPursuitAnnotation ? color : gGray40);
+*/
+    return steerForSeek (target);
+}
+
+// ----------------------------------------------------------------------------
+// evasion of another vehicle
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForEvasion (const AbstractVehicle&amp; menace,
+                 const float maxPredictionTime)
+{
+    // offset from this to menace, that distance, unit vector toward menace
+    const Vector3 offset = menace.getPosition() - getPosition();
+    const float distance = offset.length ();
+
+    const float roughTime = distance / menace.getSpeed();
+    const float predictionTime = ((roughTime &gt; maxPredictionTime) ?
+                                  maxPredictionTime :
+                                  roughTime);
+
+    const Vector3 target = menace.predictFuturePosition(predictionTime);
+
+    return steerForFlee(target);
+}
+
+
+// ----------------------------------------------------------------------------
+// tries to maintain a given speed, returns a maxForce-clipped steering
+// force along the forward/backward axis
+
+
+template&lt;class Super&gt;
+Vector3
+OpenSteer::SteerLibraryMixin&lt;Super&gt;::
+steerForTargetSpeed (const float targetSpeed)
+{
+    const float mf = getMaxForce();
+    const float speedError = targetSpeed - getSpeed();
+    return getForward() * clip (speedError, -mf, +mf);
+}
+
+
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_STEERLIBRARY_H

Added: rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,47 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// Macro to surpress warnings that parameters aren't used.
+//
+// May 09, 2005 bk:  created 
+//
+//
+// ----------------------------------------------------------------------------
+
+#ifndef OPENSTEER_UNUSEDPARAMETER_H
+#define OPENSTEER_UNUSEDPARAMETER_H
+
+/**
+ * Macro to surpress warning that parameters aren't used.
+ */
+#define OPENSTEER_UNUSED_PARAMETER(expr) (void)expr
+
+
+#endif // OPENSTEER_UNUSEDPARAMETER_H

Added: rl/trunk/engine/ai/include/OpenSteer/Utilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Utilities.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Utilities.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,514 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// Utilities for OpenSteering
+//
+// 08-06-05 bk:  added functions to clamp values to a certain value range, to 
+//               compare values using a tolerance, and so on.
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 07-09-02 cwr: created 
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_UTILITIES_H
+#define OPENSTEER_UTILITIES_H
+
+
+#include &lt;iostream&gt;  // for ostream, &lt;&lt;, etc.
+#include &lt;cstdlib&gt;   // for rand, etc.
+#include &lt;cfloat&gt;    // for FLT_MAX, etc.
+#include &lt;cmath&gt;     // for sqrt, etc.
+#include &lt;vector&gt;    // for std::vector
+#include &lt;cassert&gt;   // for assert
+#include &lt;limits&gt;    // for numeric_limits
+
+// ----------------------------------------------------------------------------
+// For the sake of Windows, apparently this is a &quot;Linux/Unix thing&quot;
+
+
+#ifndef OPENSTEER_M_PI
+#define OPENSTEER_M_PI 3.14159265358979323846f
+#endif
+
+#ifdef _MSC_VER
+#undef min
+#undef max
+#endif
+
+
+namespace OpenSteer {
+
+    // ----------------------------------------------------------------------------
+    // Generic interpolation
+
+
+    template&lt;class T&gt; inline T interpolate (float alpha, const T&amp; x0, const T&amp; x1)
+    {
+        return x0 + ((x1 - x0) * alpha);
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Random number utilities
+
+
+    // Returns a float randomly distributed between 0 and 1
+
+    inline float frandom01 (void)
+    {
+        return (((float) rand ()) / ((float) RAND_MAX));
+    }
+
+
+    // Returns a float randomly distributed between lowerBound and upperBound
+
+    inline float frandom2 (float lowerBound, float upperBound)
+    {
+        return lowerBound + (frandom01 () * (upperBound - lowerBound));
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Constrain a given value (x) to be between two (ordered) bounds: min
+    // and max.  Returns x if it is between the bounds, otherwise returns
+    // the nearer bound.
+
+
+    inline float clip (const float x, const float min, const float max)
+    {
+        if (x &lt; min) return min;
+        if (x &gt; max) return max;
+        return x;
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // remap a value specified relative to a pair of bounding values
+    // to the corresponding value relative to another pair of bounds.
+    // Inspired by (dyna:remap-interval y y0 y1 z0 z1)
+
+
+    inline float remapInterval (float x,
+                                float in0, float in1,
+                                float out0, float out1)
+    {
+        // uninterpolate: what is x relative to the interval in0:in1?
+        float relative = (x - in0) / (in1 - in0);
+
+        // now interpolate between output interval based on relative x
+        return interpolate (relative, out0, out1);
+    }
+
+
+    // Like remapInterval but the result is clipped to remain between
+    // out0 and out1
+
+
+    inline float remapIntervalClip (float x,
+                                    float in0, float in1,
+                                    float out0, float out1)
+    {
+        // uninterpolate: what is x relative to the interval in0:in1?
+        float relative = (x - in0) / (in1 - in0);
+
+        // now interpolate between output interval based on relative x
+        return interpolate (clip (relative, 0, 1), out0, out1);
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // classify a value relative to the interval between two bounds:
+    //     returns -1 when below the lower bound
+    //     returns  0 when between the bounds (inside the interval)
+    //     returns +1 when above the upper bound
+
+
+    inline int intervalComparison (float x, float lowerBound, float upperBound)
+    {
+        if (x &lt; lowerBound) return -1;
+        if (x &gt; upperBound) return +1;
+        return 0;
+    }
+
+
+
+    // ----------------------------------------------------------------------------
+
+
+    inline float scalarRandomWalk (const float initial, 
+                                   const float walkspeed,
+                                   const float min,
+                                   const float max)
+    {
+        const float next = initial + (((frandom01() * 2) - 1) * walkspeed);
+        if (next &lt; min) return min;
+        if (next &gt; max) return max;
+        return next;
+    }
+
+
+    // ----------------------------------------------------------------------------
+
+
+    inline float square (float x)
+    {
+        return x * x;
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // for debugging: prints one line with a given C expression, an equals sign,
+    // and the value of the expression.  For example &quot;angle = 35.6&quot;
+
+
+    #define debugPrint(e) (std::cout &lt;&lt; #e&quot; = &quot; &lt;&lt; (e) &lt;&lt; std::endl &lt;&lt; std::flush)
+
+
+    // ----------------------------------------------------------------------------
+    // blends new values into an accumulator to produce a smoothed time series
+    //
+    // Modifies its third argument, a reference to the float accumulator holding
+    // the &quot;smoothed time series.&quot;
+    //
+    // The first argument (smoothRate) is typically made proportional to &quot;dt&quot; the
+    // simulation time step.  If smoothRate is 0 the accumulator will not change,
+    // if smoothRate is 1 the accumulator will be set to the new value with no
+    // smoothing.  Useful values are &quot;near zero&quot;.
+    //
+    // Usage:
+    //         blendIntoAccumulator (dt * 0.4f, currentFPS, smoothedFPS);
+
+
+    template&lt;class T&gt;
+    inline void blendIntoAccumulator (const float smoothRate,
+                                      const T&amp; newValue,
+                                      T&amp; smoothedAccumulator)
+    {
+        smoothedAccumulator = interpolate (clip (smoothRate, 0, 1),
+                                           smoothedAccumulator,
+                                           newValue);
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // given a new Angle and an old angle, adjust the new for angle wraparound (the
+    // 0-&gt;360 flip), returning a value equivalent to newAngle, but closest in
+    // absolute value to oldAngle.  For radians fullCircle = OPENSTEER_M_PI*2, for degrees
+    // fullCircle = 360.  Based on code in stuart/bird/fish demo's camera.cc
+    //
+    // (not currently used)
+
+    /*
+      inline float distance1D (const float a, const float b)
+      {
+          const float d = a - b;
+          return (d &gt; 0) ? d : -d;
+      }
+
+
+      float adjustForAngleWraparound (float newAngle,
+                                      float oldAngle,
+                                      float fullCircle)
+      {
+          // adjust newAngle for angle wraparound: consider its current value (a)
+          // as well as the angle 2pi larger (b) and 2pi smaller (c).  Select the
+          // one closer (magnitude of difference) to the current value of oldAngle.
+          const float a = newAngle;
+          const float b = newAngle + fullCircle;
+          const float c = newAngle - fullCircle;
+          const float ad = distance1D (a, oldAngle);
+          const float bd = distance1D (b, oldAngle);
+          const float cd = distance1D (c, oldAngle);
+
+          if ((bd &lt; ad) &amp;&amp; (bd &lt; cd)) return b;
+          if ((cd &lt; ad) &amp;&amp; (cd &lt; bd)) return c;
+          return a;
+      }
+    */
+
+
+    // ----------------------------------------------------------------------------
+    // Functions to encapsulate cross-platform differences for several &lt;cmath&gt;
+    // functions.  Specifically, the C++ standard says that these functions are
+    // in the std namespace (std::sqrt, etc.)  Apparently the MS VC6 compiler (or
+    // its header files) do not implement this correctly and the function names
+    // are in the global namespace.  We hope these -XXX versions are a temporary
+    // expedient, to be removed later.
+
+
+    #ifdef _WIN32
+
+    inline float floorXXX (float x)          {return ::floor (x);}
+    inline float  sqrtXXX (float x)          {return ::sqrt (x);}
+    inline float   sinXXX (float x)          {return ::sin (x);}
+    inline float   cosXXX (float x)          {return ::cos (x);}
+    inline float   absXXX (float x)          {return ::abs (x);}
+    inline int     absXXX (int x)            {return ::abs (x);}
+    inline float   maxXXX (float x, float y) {if (x &gt; y) return x; else return y;}
+    inline float   minXXX (float x, float y) {if (x &lt; y) return x; else return y;}
+
+    #else
+
+    inline float floorXXX (float x)          {return std::floor (x);}
+    inline float  sqrtXXX (float x)          {return std::sqrt (x);}
+    inline float   sinXXX (float x)          {return std::sin (x);}
+    inline float   cosXXX (float x)          {return std::cos (x);}
+    inline float   absXXX (float x)          {return std::abs (x);}
+    inline int     absXXX (int x)            {return std::abs (x);}
+    inline float   maxXXX (float x, float y) {return std::max (x, y);}
+    inline float   minXXX (float x, float y) {return std::min (x, y);}
+
+    #endif
+
+
+    // ----------------------------------------------------------------------------
+    // round (x)  &quot;round off&quot; x to the nearest integer (as a float value)
+    //
+    // This is a Gnu-sanctioned(?) post-ANSI-Standard(?) extension (as in
+    // <A HREF="http://www.opengroup.org/onlinepubs/007904975/basedefs/math.h.html">http://www.opengroup.org/onlinepubs/007904975/basedefs/math.h.html</A>)
+    // which may not be present in all C++ environments.  It is defined in
+    // math.h headers in Linux and Mac OS X, but apparently not in Win32:
+
+
+    #ifdef _WIN32
+
+    inline float round (float x)
+    {
+      if (x &lt; 0)
+          return -floorXXX (0.5f - x);
+      else
+          return  floorXXX (0.5f + x);
+    }
+
+    #else 
+    
+    inline float round( float x )
+    {
+        return ::round( x );
+    }
+    
+    #endif
+
+    
+    /**
+     * Returns @a valueToClamp clamped to the range @a minValue - @a maxValue.
+     */
+    template&lt; typename T &gt;
+    T
+    clamp( T const&amp; valueToClamp, T const&amp; minValue, T const&amp; maxValue) {
+        assert( minValue &lt;= maxValue &amp;&amp; &quot;minValue must be lesser or equal to maxValue.&quot;  );
+        
+        if ( valueToClamp &lt; minValue ) {
+            return minValue;
+        } else if ( valueToClamp &gt; maxValue ) {
+            return maxValue;
+        }
+        
+        return valueToClamp;
+    }
+    
+    
+    /**
+     * Returns the floating point remainder of the division of @a x by @a y.
+     * If @a y is @c 0 the behavior is undefined.
+     */
+    inline float modulo( float x, float y ) {
+        assert( 0.0f != y &amp;&amp; &quot;Division by zero.&quot; );
+        return std::fmod( x, y );
+    }
+    
+    /**
+     * Returns the floating point remainder of the division of @a x by @a y.
+     * If @a y is @c 0 the behavior is undefined.
+     */
+    inline double modulo( double x, double y ) {
+        assert( 0.0 != y &amp;&amp; &quot;Division by zero.&quot; );
+        return std::fmod( x, y );
+    }    
+    
+    /**
+     * Returns the floating point remainder of the division of @a x by @a y.
+     * If @a y is @c 0 the behavior is undefined.
+     */
+    inline long double modulo( long double x, long double y ) {
+        assert( 0.0 != y &amp;&amp; &quot;Division by zero.&quot; );
+        return std::fmod( x, y );
+    }
+    
+    /**
+     * Returns the floating point remainder of the division of @a x by @a y.
+     * If @a y is @c 0 the behavior is undefined.
+     */
+    inline short modulo( short x, short y ) {
+        assert( 0 != y &amp;&amp; &quot;Division by zero.&quot; );
+        return x % y;
+    }
+    
+    /**
+     * Returns the floating point remainder of the division of @a x by @a y.
+     * If @a y is @c 0 the behavior is undefined.
+     */
+    inline int modulo( int x, int y ) {
+        assert( 0 != y &amp;&amp; &quot;Division by zero.&quot; );
+        return x % y;
+    }
+    
+    /**
+     * Returns the floating point remainder of the division of @a x by @a y.
+     * If @a y is @c 0 the behavior is undefined.
+     */
+    inline long modulo( long x, long y ) {
+        assert( 0 != y &amp;&amp; &quot;Division by zero.&quot; );
+        return x % y;
+    }
+    
+    
+    /**
+     * Returns &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;value &gt;= 0 &lt;/code&gt;, otherwise
+     * &lt;code&gt;-value&lt;/code&gt;.
+     */
+    template&lt; typename T &gt;
+    T abs( T const&amp; value ) {
+        return absXXX( value );
+    }
+    
+    /**
+     * Returns the maximum of the three values @a v0, @a v1, and @a v2.
+     *
+     * @todo Write a unit test.
+     */
+    template&lt; typename T &gt;
+    T
+    max( T const&amp; v0, T const&amp; v1, T const&amp; v2 ) {
+        return maxXXX( v0, maxXXX( v1, v2 ) );
+    }
+    
+    
+    /**
+     * Returns the minimum of the three values @a v0, @a v1, and @a v2.
+     *
+     * @todo Write a unit test.
+     */
+    template&lt; typename T &gt;
+    T
+    min( T const&amp; v0, T const&amp; v1, T const&amp; v2 ) {
+        return minXXX( v0, minXXX( v1, v2 ) );
+    }
+    
+    
+    /**
+     * Compares the absolute value of @a v with @a tolerance.
+     *
+     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
+     * 2005, pp. 441--443.
+     *
+     * @todo Write a unit test.
+     */
+    template&lt; typename T &gt;
+    bool
+    isZero( T const&amp; v, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon() ) {
+        return abs( v ) &lt;= tolerance;
+    }
+    
+    
+    /**
+     * Compares @a lhs with @a rhs given a specific @a tolerance.
+     *
+     * @attention Adapt @a tolerance to the range of values of @a lhs and 
+     * @a rhs.
+     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
+     * 2005, pp. 441--443.
+     *
+     * @return &lt;code&gt;abs( lhs - rhs ) &lt;= tolerance&lt;/code&gt;
+     *
+     * @todo Write a unit test.
+     */
+    template&lt; typename T &gt;
+    bool
+    equalsAbsolute( T const&amp; lhs, T const&amp; rhs, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon()  ) {
+        return isZero( lhs - rhs, tolerance );
+    }
+    
+    
+    /**
+     * Compares @a lhs with @a rhs given a specific @a tolerance taking the 
+     * range of values into account.
+     *
+     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
+     * 2005, pp. 441--443.
+     *
+     * @return &lt;code&gt;abs( lhs - rhs ) &lt;= tolerance * max( abs( lhs ), abs( rhs ), 1 )&lt;/code&gt;
+     *
+     * @todo Write a unit test.
+     */
+    template&lt; typename T &gt;
+    bool
+    equalsRelative( T const&amp; lhs, T const&amp; rhs, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon()  ) {
+        return isZero( lhs - rhs, tolerance * max( abs( lhs ), abs( rhs ), T( 1 ) ) );
+    }
+    
+    
+    /**
+     * Approximately compares @a lhs with @a rhs given a specific @a tolerance  
+     * taking the range of values into account.
+     *
+     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
+     * 2005, pp. 441--443.
+     *
+     * @return &lt;code&gt;abs( lhs - rhs ) &lt;= tolerance * ( abs( lhs ) + abs( rhs ) + 1 )&lt;/code&gt;
+     *
+     * @todo Write a unit test.
+     */
+    template&lt; typename T &gt;
+    bool
+    equalsRelativeApproximately( T const&amp; lhs, T const&amp; rhs, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon()  ) {
+        return isZero( lhs - rhs, tolerance * ( abs( lhs ) + abs( rhs ) + T( 1 ) ) );
+    }    
+    
+    
+    /**
+     * Shrinks the capacity of a std::vector to fit its content.
+     *
+     * See Scott Meyer, Effective STL, Addison-Wesley, 2001, pp. 77--79.
+     */
+    template&lt; typename T &gt;
+    void shrinkToFit( std::vector&lt; T &gt;&amp; v ) {
+        std::vector&lt; T &gt;( v ).swap( v );
+    }
+    
+
+    
+} // namespace OpenSteer
+    
+    
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_UTILITIES_H

Added: rl/trunk/engine/ai/include/OpenSteer/Vec3.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Vec3.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Vec3.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,289 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+// Vector3: OpenSteer's generic type for 3d vectors
+//
+// This file defines the class Vector3, which is used throughout OpenSteer to
+// manipulate 3d geometric data.  It includes standard vector operations (like
+// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
+// utility functions.
+//
+// When integrating OpenSteer into a preexisting 3d application, it may be
+// important to use the 3d vector type of that application.  In that case Vector3
+// can be changed to inherit from the preexisting application' vector type and
+// to match the interface used by OpenSteer to the interface provided by the
+// preexisting 3d vector type.
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
+//               vecmath package (<A HREF="http://objectclub.esm.co.jp/vecmath/">http://objectclub.esm.co.jp/vecmath/</A>)
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_Vector3_H
+#define OPENSTEER_Vector3_H
+
+
+#include &quot;OpenSteer/Utilities.h&quot;  // for interpolate, etc.
+#ifdef __APPLE__
+	#include &lt;Carbon/Carbon.h&gt;
+    #include &lt;Ogre/Ogre.h&gt;
+#else
+    #include &lt;Ogre.h&gt;
+#endif
+
+using Ogre::Vector3;
+
+namespace OpenSteer {
+
+    // ----------------------------------------------------------------------------
+    class Vec3Utils
+    {
+    public:
+        // return component of vector parallel to a unit basis vector
+        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
+
+        static Vector3 parallelComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
+        {
+            const float projection = vector.dotProduct(unitBasis);
+            return unitBasis * projection;
+        }
+
+        // return component of vector perpendicular to a unit basis vector
+        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
+
+        static Vector3 perpendicularComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
+        {
+            return vector - parallelComponent(vector, unitBasis);
+        }
+
+        // clamps the length of a given vector to maxLength.  If the vector is
+        // shorter its value is returned unaltered, if the vector is longer
+        // the value returned has length of maxLength and is paralle to the
+        // original input.
+
+        static Vector3 truncateLength (const Vector3&amp; vector, const float maxLength)
+        {
+            const float vecLength = vector.length();
+            if (vecLength &lt;= maxLength)
+                return vector;
+            else
+                return vector * (maxLength / vecLength);
+        }
+
+        // forces a 3d position onto the XZ (aka y=0) plane
+
+        static Vector3 setYtoZero (const Vector3&amp; vector)
+        {
+            return Vector3 (vector.x, 0, vector.z);
+        }
+
+        // rotate this vector about the global Y (up) axis by the given angle
+
+        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle)
+        {
+            const float s = sinXXX (angle);
+            const float c = cosXXX (angle);
+            return Vector3 ((vector.x * c) + (vector.z * s),
+                         (vector.y),
+                         (vector.z * c) - (vector.x * s));
+        }
+
+        // version for caching sin/cos computation
+        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle, float&amp; sin, float&amp; cos)
+        {
+            // is both are zero, they have not be initialized yet
+            if (sin==0 &amp;&amp; cos==0)
+            {
+                sin = sinXXX (angle);
+                cos = cosXXX (angle);
+            }
+            return Vector3 ((vector.x * cos) + (vector.z * sin),
+                         (vector.y),
+                         (vector.z * cos) - (vector.x * sin));
+        }
+
+        // if this position is outside sphere, push it back in by one diameter
+
+        static Vector3 sphericalWrapAround (const Vector3&amp; vector, const Vector3&amp; center, float radius)
+        {
+            const Vector3 offset = vector - center;
+            const float r = offset.length();
+            if (r &gt; radius)
+                return vector + ((offset/r) * radius * -2);
+            else
+                return vector;
+        }
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // scalar times vector product (&quot;float * Vector3&quot;)
+
+
+    inline Vector3 operator* (float s, const Vector3&amp; v) {return v*s;}
+
+
+	// return cross product a x b
+	inline Vector3 crossProduct(const Vector3&amp; a, const Vector3&amp; b)
+	{
+		Vector3 result((a.y * b.z) - (a.z * b.y),
+					(a.z * b.x) - (a.x * b.z),
+					(a.x * b.y) - (a.y * b.x));
+		return result;
+	}
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed inside a sphere of unit radius
+    // centered at the origin.  Orientation will be random and length will range
+    // between 0 and 1
+
+
+    Vector3 RandomVectorInUnitRadiusSphere (void);
+
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed on a disk of unit radius
+    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
+    // random and length will range between 0 and 1
+
+
+    Vector3 randomVectorOnUnitRadiusXZDisk (void);
+
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed on the surface of a sphere
+    // of unit radius centered at the origin.  Orientation will be random
+    // and length will be 1
+
+
+    inline Vector3 RandomUnitVector (void)
+    {
+        return RandomVectorInUnitRadiusSphere().normalisedCopy();
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed on a circle of unit radius
+    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
+    // random and length will be 1
+
+
+    inline Vector3 RandomUnitVectorOnXZPlane (void)
+    {
+        return Vec3Utils::setYtoZero(RandomVectorInUnitRadiusSphere()).normalisedCopy();
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // used by limitMaxDeviationAngle / limitMinDeviationAngle below
+
+
+    Vector3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
+                                        const Vector3&amp; source,
+                                        const float cosineOfConeAngle,
+                                        const Vector3&amp; basis);
+
+
+    // ----------------------------------------------------------------------------
+    // Enforce an upper bound on the angle by which a given arbitrary vector
+    // diviates from a given reference direction (specified by a unit basis
+    // vector).  The effect is to clip the &quot;source&quot; vector to be inside a cone
+    // defined by the basis and an angle.
+
+
+    inline Vector3 limitMaxDeviationAngle (const Vector3&amp; source,
+                                        const float cosineOfConeAngle,
+                                        const Vector3&amp; basis)
+    {
+        return vecLimitDeviationAngleUtility (true, // force source INSIDE cone
+                                              source,
+                                              cosineOfConeAngle,
+                                              basis);
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Enforce a lower bound on the angle by which a given arbitrary vector
+    // diviates from a given reference direction (specified by a unit basis
+    // vector).  The effect is to clip the &quot;source&quot; vector to be outside a cone
+    // defined by the basis and an angle.
+
+
+    inline Vector3 limitMinDeviationAngle (const Vector3&amp; source,
+                                        const float cosineOfConeAngle,
+                                        const Vector3&amp; basis)
+    {    
+        return vecLimitDeviationAngleUtility (false, // force source OUTSIDE cone
+                                              source,
+                                              cosineOfConeAngle,
+                                              basis);
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Returns the distance between a point and a line.  The line is defined in
+    // terms of a point on the line (&quot;lineOrigin&quot;) and a UNIT vector parallel to
+    // the line (&quot;lineUnitTangent&quot;)
+
+
+    inline float distanceFromLine (const Vector3&amp; point,
+                                   const Vector3&amp; lineOrigin,
+                                   const Vector3&amp; lineUnitTangent)
+    {
+        const Vector3 offset = point - lineOrigin;
+        const Vector3 perp = Vec3Utils::perpendicularComponent(offset, lineUnitTangent);
+        return perp.length();
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // given a vector, return a vector perpendicular to it (note that this
+    // arbitrarily selects one of the infinitude of perpendicular vectors)
+
+
+    Vector3 findPerpendicularIn3d (const Vector3&amp; direction);
+
+
+    // ----------------------------------------------------------------------------
+    // candidates for global utility functions
+    //
+    // dot
+    // cross
+    // length
+    // distance
+    // normalized
+
+    
+} // namespace OpenSteer
+    
+
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_Vector3_H

Added: rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,96 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+// Utilities to work with Vector3.
+//
+// 05-12-05 bk:  Created based on code of PolylinePathway.
+//
+// ----------------------------------------------------------------------------
+
+#ifndef OPENSTEER_VEC3UTILITIES_H
+#define OPENSTEER_VEC3UTILITIES_H
+
+
+// Include Vector3
+#include &quot;OpenSteer/Vec3.h&quot;
+
+// Include OpenSteer::size_t
+#include &quot;OpenSteer/StandardTypes.h&quot;
+
+// Include OpenSteer::equalsRelative
+#include &quot;OpenSteer/Utilities.h&quot;
+
+
+
+namespace OpenSteer {
+
+    /**
+     * Returns the nearest point on the segment @a segmentPoint0 to 
+     * @a segmentPoint1 from @a point.
+     */
+    Vector3  nearestPointOnSegment( const Vector3&amp; point,
+                                            const Vector3&amp; segmentPoint0,
+                                            const Vector3&amp; segmentPoint1 );
+    
+    /**
+     * Computes minimum distance from @a point to the line segment defined by
+     * @a segmentPoint0 and @a segmentPoint1.
+     */
+    float pointToSegmentDistance( const Vector3&amp; point,
+                                  const Vector3&amp; segmentPoint0,
+                                  const Vector3&amp; segmentPoint1);
+        
+    /**
+     * Retuns distance between @a a and @a b.
+     */
+    inline float distance (const Vector3&amp; a, const Vector3&amp; b) {
+        return (a-b).length();
+    } 
+    
+    
+    /**
+     * Elementwise relative tolerance comparison of @a lhs and @a rhs taking
+     * the range of the elements into account.
+     *
+     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
+     * 2005, pp. 441--443.
+     *
+     * @todo Rewrite using the stl or providing an own range based function.
+     */
+    inline
+    bool
+    equalsRelative( Vector3 const&amp; lhs, 
+                     Vector3 const&amp; rhs, 
+                     float const&amp; tolerance = std::numeric_limits&lt; float &gt;::epsilon()  ) {
+        return equalsRelative( lhs.x, rhs.x, tolerance ) &amp;&amp; equalsRelative( lhs.y, rhs.y ) &amp;&amp; equalsRelative( lhs.z, rhs.z );
+    }
+    
+} // namespace OpenSteer
+
+#endif // OPENSTEER_VEC3UTILITIES_H

Added: rl/trunk/engine/ai/include/OpenSteer/lq.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/lq.h	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/include/OpenSteer/lq.h	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,323 @@
+/*
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+// ----------------------------------------------------------------------------
+*/
+
+/* ------------------------------------------------------------------ */
+/*                                                                    */
+/*                   Locality Query (LQ) Facility                     */
+/*                                                                    */
+/* ------------------------------------------------------------------ */
+/*
+
+    This utility is a spatial database which stores objects each of
+    which is associated with a 3d point (a location in a 3d space).
+    The points serve as the &quot;search key&quot; for the associated object.
+    It is intended to efficiently answer &quot;sphere inclusion&quot; queries,
+    also known as range queries: basically questions like:
+
+        Which objects are within a radius R of the location L?
+
+    In this context, &quot;efficiently&quot; means significantly faster than the
+    naive, brute force O(n) testing of all known points.  Additionally
+    it is assumed that the objects move along unpredictable paths, so
+    that extensive preprocessing (for example, constructing a Delaunay
+    triangulation of the point set) may not be practical.
+
+    The implementation is a &quot;bin lattice&quot;: a 3d rectangular array of
+    brick-shaped (rectangular parallelepipeds) regions of space.  Each
+    region is represented by a pointer to a (possibly empty) doubly-
+    linked list of objects.  All of these sub-bricks are the same
+    size.  All bricks are aligned with the global coordinate axes.
+
+    Terminology used here: the region of space associated with a bin
+    is called a sub-brick.  The collection of all sub-bricks is called
+    the super-brick.  The super-brick should be specified to surround
+    the region of space in which (almost) all the key-points will
+    exist.  If key-points move outside the super-brick everything will
+    continue to work, but without the speed advantage provided by the
+    spatial subdivision.  For more details about how to specify the
+    super-brick's position, size and subdivisions see lqCreateDatabase
+    below.
+
+    Overview of usage: an application using this facility would first
+    create a database with lqCreateDatabase.  For each client object
+    the application wants to put in the database it creates a
+    lqClientProxy and initializes it with lqInitClientProxy.  When a
+    client object moves, the application calls lqUpdateForNewLocation.
+    To perform a query lqMapOverAllObjectsInLocality is passed an
+    application-supplied call-back function to be applied to all
+    client objects in the locality.  See lqCallBackFunction below for
+    more detail.  The lqFindNearestNeighborWithinRadius function can
+    be used to find a single nearest neighbor using the database.
+
+    Note that &quot;locality query&quot; is also known as neighborhood query,
+    neighborhood search, near neighbor search, and range query.  For
+    additional information on this and related topics see:
+    <A HREF="http://www.red3d.com/cwr/boids/ips.html">http://www.red3d.com/cwr/boids/ips.html</A>
+
+    For some description and illustrations of this database in use,
+    see this paper: <A HREF="http://www.red3d.com/cwr/papers/2000/pip.html">http://www.red3d.com/cwr/papers/2000/pip.html</A>
+
+*/
+
+#ifndef	_lq_h
+#define	_lq_h
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+
+/* ------------------------------------------------------------------ */
+/*                                                                    */
+/*                       Data types use by LQ                         */
+/*                                                                    */
+/* ------------------------------------------------------------------ */
+/* This structure represents the spatial database.  Typically one of
+   these would be created (by a call to lqCreateDatabase) for a given
+   application.  */
+
+
+typedef struct lqInternalDB lqDB;
+
+
+/* ------------------------------------------------------------------ */
+/* This structure is a proxy for (and contains a pointer to) a client
+   (application) object in the spatial database.  One of these exists
+   for each client object.  This might be included within the
+   structure of a client object, or could be allocated separately.  */
+
+
+typedef struct lqClientProxy
+{
+    /* previous object in this bin, or NULL */
+    struct lqClientProxy*  prev;
+
+    /* next object in this bin, or NULL */
+    struct lqClientProxy*  next;
+
+    /* bin ID (pointer to pointer to bin contents list) */
+    struct lqClientProxy** bin;
+
+    /* pointer to client object */
+    void* object;
+
+    /* the object's location (&quot;key point&quot;) used for spatial sorting */
+    float x;
+    float y;
+    float z;
+} lqClientProxy;
+
+
+/* ------------------------------------------------------------------ */
+/*                                                                    */
+/*                            Basic API                               */
+/*                                                                    */
+/* ------------------------------------------------------------------ */
+/* Allocate and initialize an LQ database, returns a pointer to it.
+   The application needs to call this before using the LQ facility.
+   The nine parameters define the properties of the &quot;super-brick&quot;:
+      (1) origin: coordinates of one corner of the super-brick, its
+          minimum x, y and z extent.
+      (2) size: the width, height and depth of the super-brick.
+      (3) the number of subdivisions (sub-bricks) along each axis.
+   This routine also allocates the bin array, and initialize its
+   contents. */
+
+
+lqDB* lqCreateDatabase (float originx, float originy, float originz,
+			float sizex,   float sizey,   float sizez,
+			int   divx,    int   divy,    int   divz);
+
+
+/* ------------------------------------------------------------------ */
+/* Deallocates the LQ database */
+
+
+void lqDeleteDatabase (lqDB*);
+
+
+/* ------------------------------------------------------------------ */
+/* The application needs to call this once on each lqClientProxy at
+   setup time to initialize its list pointers and associate the proxy
+   with its client object. */ 
+
+
+void lqInitClientProxy (lqClientProxy* proxy, void* clientObject);
+
+
+/* ------------------------------------------------------------------ */
+/* Call for each client object every time its location changes.  For
+   example, in an animation application, this would be called each
+   frame for every moving object.  */
+
+
+void lqUpdateForNewLocation (lqDB* lq, 
+			     lqClientProxy* object, 
+			     float x, float y, float z);
+
+
+/* ------------------------------------------------------------------ */
+/* Apply an application-specific function to all objects in a certain
+   locality.  The locality is specified as a sphere with a given
+   center and radius.  All objects whose location (key-point) is
+   within this sphere are identified and the function is applied to
+   them.  The application-supplied function takes three arguments:
+
+     (1) a void* pointer to an lqClientProxy's &quot;object&quot;.
+     (2) the square of the distance from the center of the search
+         locality sphere (x,y,z) to object's key-point.
+     (3) a void* pointer to the caller-supplied &quot;client query state&quot;
+         object -- typically NULL, but can be used to store state
+         between calls to the lqCallBackFunction.
+
+   This routine uses the LQ database to quickly reject any objects in
+   bins which do not overlap with the sphere of interest.  Incremental
+   calculation of index values is used to efficiently traverse the
+   bins of interest. */
+
+
+/* type for a pointer to a function used to map over client objects */
+typedef void (* lqCallBackFunction)  (void* clientObject,
+				      float distanceSquared,
+				      void* clientQueryState);
+
+
+void lqMapOverAllObjectsInLocality (lqDB* lq, 
+				    float x, float y, float z,
+				    float radius,
+				    lqCallBackFunction func,
+				    void* clientQueryState);
+
+
+/* ------------------------------------------------------------------ */
+/*                                                                    */
+/*                            Other API                               */
+/*                                                                    */
+/* ------------------------------------------------------------------ */
+/* Search the database to find the object whose key-point is nearest
+   to a given location yet within a given radius.  That is, it finds
+   the object (if any) within a given search sphere which is nearest
+   to the sphere's center.  The ignoreObject argument can be used to
+   exclude an object from consideration (or it can be NULL).  This is
+   useful when looking for the nearest neighbor of an object in the
+   database, since otherwise it would be its own nearest neighbor.
+   The function returns a void* pointer to the nearest object, or
+   NULL if none is found.  */
+
+
+void* lqFindNearestNeighborWithinRadius (lqDB* lq, 
+					 float x, float y, float z,
+					 float radius,
+					 void* ignoreObject);
+
+
+/* ------------------------------------------------------------------ */
+/* Adds a given client object to a given bin, linking it into the bin
+   contents list. */
+
+
+void lqAddToBin (lqClientProxy* object, lqClientProxy** bin);
+
+
+/* ------------------------------------------------------------------ */
+/* Removes a given client object from its current bin, unlinking it
+   from the bin contents list. */
+
+
+void lqRemoveFromBin (lqClientProxy* object);
+
+
+/* ------------------------------------------------------------------ */
+/* Given an LQ database object and the nine basic parameters: fill in
+   the object's slots, allocate the bin array, and initialize its
+   contents.  Normally the application does NOT call this directly, it
+   is called by lqCreateDatabase.  */
+
+
+void lqInitDatabase (lqDB* lq,
+		     float originx, float originy, float originz,
+		     float sizex, float sizey, float sizez,
+		     int divx, int divy, int divz);
+
+
+/* ------------------------------------------------------------------ */
+/* Find the bin ID for a location in space.  The location is given in
+   terms of its XYZ coordinates.  The bin ID is a pointer to a pointer
+   to the bin contents list.  */
+
+
+lqClientProxy** lqBinForLocation (lqDB* lq, float x, float y, float z);
+
+
+/* ------------------------------------------------------------------ */
+/* Apply a user-supplied function to all objects in the database,
+   regardless of locality (cf lqMapOverAllObjectsInLocality) */
+
+
+void lqMapOverAllObjects (lqDB* lq, 
+			  lqCallBackFunction func,
+			  void* clientQueryState);
+
+
+/* ------------------------------------------------------------------ */
+/* Removes (all proxies for) all objects from all bins */
+
+
+void lqRemoveAllObjects (lqDB* lq);
+
+
+/* ------------------------------------------------------------------ */
+/* Get statistics about bin populations: min, max and average of
+   non-empty bins. */
+
+
+#ifndef NO_LQ_BIN_STATS
+void lqGetBinPopulationStats (lqDB* lq,
+                              int* min,
+                              int* max,
+                              float* average);
+#endif /* NO_LQ_BIN_STATS */
+
+/* ------------------------------------------------------------------ */
+
+
+#ifndef	NULL
+#define NULL 0
+#endif
+
+
+/* ------------------------------------------------------------------ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _lq_h */

Added: rl/trunk/engine/ai/src/OpenSteer/Color.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Color.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/Color.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,262 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+
+#include &quot;OpenSteer/Color.h&quot;
+
+// Include Vector3
+#include &quot;OpenSteer/Vec3.h&quot;
+
+// Include assert
+#include &lt;cassert&gt;
+
+
+OpenSteer::Color::Color()
+    : r_(1.0f), g_(1.0f), b_(1.0f), a_ (1.0f)
+{
+    
+}
+
+
+OpenSteer::Color::Color( float greyValue )
+    : r_( greyValue ), g_( greyValue ), b_( greyValue ), a_ (1.0f)
+{
+    
+}
+
+
+OpenSteer::Color::Color( float rValue, float gValue, float bValue, float aValue )
+    : r_( rValue ), g_( gValue ), b_( bValue ), a_( aValue )
+{
+    
+}
+
+
+OpenSteer::Color::Color( Vector3 const&amp; vector )
+    : r_( vector.x ), g_( vector.y ), b_( vector.z ), a_ (1.0f)
+{
+    
+}
+
+
+
+float 
+OpenSteer::Color::r() const
+{
+    return r_;
+}
+
+
+float 
+OpenSteer::Color::g() const
+{
+    return g_;
+}
+
+
+float 
+OpenSteer::Color::b() const
+{
+    return b_;
+}
+
+
+float 
+OpenSteer::Color::a() const
+{
+    return a_;
+}
+
+
+
+void 
+OpenSteer::Color::setR( float value )
+{
+    r_ = value;
+}
+
+
+void 
+OpenSteer::Color::setG( float value )
+{
+    g_ = value;
+}
+
+
+void 
+OpenSteer::Color::setB( float value )
+{
+    b_ = value;
+}
+
+void 
+OpenSteer::Color::setA( float value )
+{
+	a_ = value;
+}
+
+void
+OpenSteer::Color::set( float rValue, float gValue, float bValue, float aValue )
+{
+    r_ = rValue;
+    g_ = gValue;
+    b_ = bValue;
+	a_ = aValue;
+}
+
+
+Vector3 
+OpenSteer::Color::convertToVec3() const
+{
+    return Vector3( r_, g_, b_ );
+}
+
+
+OpenSteer::Color&amp; 
+OpenSteer::Color::operator+=( Color const&amp; other )
+{
+    r_ += other.r_;
+    g_ += other.g_;
+    b_ += other.b_;
+    return *this;
+}
+
+
+OpenSteer::Color&amp; 
+OpenSteer::Color::operator-=( Color const&amp; other )
+{
+    r_ -= other.r_;
+    g_ -= other.g_;
+    b_ -= other.b_;
+    return *this;    
+}
+
+
+OpenSteer::Color&amp; 
+OpenSteer::Color::operator*=( float factor )
+{
+    r_ *= factor;
+    g_ *= factor;
+    b_ *= factor;
+    return *this;    
+}
+
+
+OpenSteer::Color&amp; 
+OpenSteer::Color::operator/=( float factor )
+{
+    assert( 0.0f != factor &amp;&amp; &quot;Division by zero.&quot; );
+    return operator*=( 1.0f / factor );
+}
+
+
+
+
+
+
+OpenSteer::Color 
+OpenSteer::grayColor( float value )
+{
+    return Color( value );
+}
+
+
+
+OpenSteer::Color 
+OpenSteer::operator+( Color const&amp; lhs, Color const&amp; rhs )
+{
+    Color result( lhs );
+    return result += rhs;
+}
+
+
+OpenSteer::Color 
+OpenSteer::operator-( Color const&amp; lhs, Color const&amp; rhs )
+{
+    Color result( lhs );
+    return result -= rhs;    
+}
+
+
+OpenSteer::Color 
+OpenSteer::operator*( Color const&amp; lhs, float rhs )
+{
+    Color result( lhs );
+    return result *= rhs;
+}
+
+
+OpenSteer::Color 
+OpenSteer::operator*( float lhs, Color const&amp; rhs )
+{
+    return operator*( rhs, lhs );
+}
+
+
+OpenSteer::Color 
+OpenSteer::operator/( Color const&amp; lhs, float rhs )
+{
+    Color result( lhs );
+    return result /= rhs;
+}
+
+
+
+
+
+
+
+OpenSteer::Color const OpenSteer::gBlack(0.0f, 0.0f, 0.0f);
+OpenSteer::Color const OpenSteer::gWhite(1.0f, 1.0f, 1.0f);
+
+OpenSteer::Color const OpenSteer::gRed(1.0f, 0.0f, 0.0f); 
+OpenSteer::Color const OpenSteer::gGreen(0.0f, 1.0f, 0.0f);
+OpenSteer::Color const OpenSteer::gBlue(0.0f, 0.0f, 1.0f);
+OpenSteer::Color const OpenSteer::gYellow(1.0f, 1.0f, 0.0f);
+OpenSteer::Color const OpenSteer::gCyan(0.0f, 1.0f, 1.0f);
+OpenSteer::Color const OpenSteer::gMagenta(1.0f, 0.0f, 1.0f);
+OpenSteer::Color const OpenSteer::gOrange(1.0f, 0.5f, 0.0f);
+
+OpenSteer::Color const OpenSteer::gDarkRed(0.5f, 0.0f, 0.0f);
+OpenSteer::Color const OpenSteer::gDarkGreen(0.0f, 0.5f, 0.0f);
+OpenSteer::Color const OpenSteer::gDarkBlue(0.0f, 0.0f, 0.5f);
+OpenSteer::Color const OpenSteer::gDarkYellow(0.5f, 0.5f, 0.0f);
+OpenSteer::Color const OpenSteer::gDarkCyan(0.0f, 0.5f, 0.5f);
+OpenSteer::Color const OpenSteer::gDarkMagenta(0.5f, 0.0f, 0.5f);
+OpenSteer::Color const OpenSteer::gDarkOrange(0.5f, 0.25f, 0.0f);
+
+OpenSteer::Color const OpenSteer::gGray10(0.1f);
+OpenSteer::Color const OpenSteer::gGray20(0.2f);
+OpenSteer::Color const OpenSteer::gGray30(0.3f);
+OpenSteer::Color const OpenSteer::gGray40(0.4f);
+OpenSteer::Color const OpenSteer::gGray50(0.5f);
+OpenSteer::Color const OpenSteer::gGray60(0.6f);
+OpenSteer::Color const OpenSteer::gGray70(0.7f);
+OpenSteer::Color const OpenSteer::gGray80(0.8f);
+OpenSteer::Color const OpenSteer::gGray90(0.9f);
+

Added: rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,347 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2004, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer Obstacle classes
+// 
+// 10-28-04 cwr: split off from Obstacle.h 
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#include &quot;OpenSteer/Obstacle.h&quot;
+
+
+// ----------------------------------------------------------------------------
+// Obstacle
+// compute steering for a vehicle to avoid this obstacle, if needed 
+
+
+Vector3 
+OpenSteer::Obstacle::steerToAvoid (const AbstractVehicle&amp; vehicle,
+                                   const float minTimeToCollision) const
+{
+    // find nearest intersection with this obstacle along vehicle's path
+    PathIntersection pi;
+    findIntersectionWithVehiclePath (vehicle, pi);
+
+    // return steering for vehicle to avoid intersection, or zero if non found
+    return pi.steerToAvoidIfNeeded (vehicle, minTimeToCollision);
+}
+
+
+// ----------------------------------------------------------------------------
+// Obstacle
+// static method to apply steerToAvoid to nearest obstacle in an ObstacleGroup
+
+
+Vector3
+OpenSteer::Obstacle::
+steerToAvoidObstacles (const AbstractVehicle&amp; vehicle,
+                       const float minTimeToCollision,
+                       const ObstacleGroup&amp; obstacles)
+{
+    PathIntersection nearest, next;
+
+    // test all obstacles in group for an intersection with the vehicle's
+    // future path, select the one whose point of intersection is nearest
+    firstPathIntersectionWithObstacleGroup (vehicle, obstacles, nearest, next);
+
+    // if nearby intersection found, steer away from it, otherwise no steering
+    return nearest.steerToAvoidIfNeeded (vehicle, minTimeToCollision);
+}
+
+
+// ----------------------------------------------------------------------------
+// Obstacle
+// static method to find first vehicle path intersection in an ObstacleGroup
+//
+// returns its results in the PathIntersection argument &quot;nearest&quot;,
+// &quot;next&quot; is used to store internal state.
+
+
+void
+OpenSteer::Obstacle::
+firstPathIntersectionWithObstacleGroup (const AbstractVehicle&amp; vehicle,
+                                        const ObstacleGroup&amp; obstacles,
+                                        PathIntersection&amp; nearest,
+                                        PathIntersection&amp; next)
+{
+    // test all obstacles in group for an intersection with the vehicle's
+    // future path, select the one whose point of intersection is nearest
+    next.intersect = false;
+    nearest.intersect = false;
+    ObstacleIterator o;
+    for (o = obstacles.begin(); o != obstacles.end(); o++)
+    {
+        // find nearest point (if any) where vehicle path intersects obstacle
+        // o, storing the results in PathIntersection object &quot;next&quot;
+        (**o).findIntersectionWithVehiclePath (vehicle, next);
+
+        // if this is the first intersection found, or it is the nearest found
+        // so far, store it in PathIntersection object &quot;nearest&quot;
+        const bool firstFound = !nearest.intersect;
+        const bool nearestFound = (next.intersect &amp;&amp;
+                                   (next.distance &lt; nearest.distance));
+        if (firstFound || nearestFound) nearest = next;
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// PathIntersection
+// determine steering once path intersections have been found
+
+
+Vector3 
+OpenSteer::Obstacle::PathIntersection::
+steerToAvoidIfNeeded (const AbstractVehicle&amp; vehicle,
+                      const float minTimeToCollision) const
+{
+    // if nearby intersection found, steer away from it, otherwise no steering
+    const float minDistanceToCollision = minTimeToCollision * vehicle.getSpeed();
+    if (intersect &amp;&amp; (distance &lt; minDistanceToCollision))
+    {
+        // compute avoidance steering force: take the component of
+        // steerHint which is lateral (perpendicular to vehicle's
+        // forward direction), set its length to vehicle's maxForce
+        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.getForward());
+        return lateral.normalisedCopy() * vehicle.getMaxForce();
+    }
+    else
+    {
+        return Vector3::ZERO;
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// SphereObstacle
+// find first intersection of a vehicle's path with this obstacle
+
+
+void 
+OpenSteer::
+SphereObstacle::
+findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
+                                 PathIntersection&amp; pi) const
+{
+    // This routine is based on the Paul Bourke's derivation in:
+    //   Intersection of a Line and a Sphere (or circle)
+    //   <A HREF="http://www.swin.edu.au/astronomy/pbourke/geometry/sphereline/">http://www.swin.edu.au/astronomy/pbourke/geometry/sphereline/</A>
+    // But the computation is done in the vehicle's local space, so
+    // the line in question is the Z (Forward) axis of the space which
+    // simplifies some of the calculations.
+
+    float b, c, d, p, q, s;
+    Vector3 lc;
+
+    // initialize pathIntersection object to &quot;no intersection found&quot;
+    pi.intersect = false;
+
+    // find sphere's &quot;local center&quot; (lc) in the vehicle's coordinate space
+    lc = vehicle.localizePosition (center);
+
+    // compute line-sphere intersection parameters
+    const float r = radius + vehicle.getRadius();
+    b = -2 * lc.z;
+    c = square (lc.x) + square (lc.y) + square (lc.z) - square (r);
+    d = (b * b) - (4 * c);
+
+    // when the path does not intersect the sphere
+    if (d &lt; 0) return;
+
+    // otherwise, the path intersects the sphere in two points with
+    // parametric coordinates of &quot;p&quot; and &quot;q&quot;.  (If &quot;d&quot; is zero the two
+    // points are coincident, the path is tangent)
+    s = sqrtXXX (d);
+    p = (-b + s) / 2;
+    q = (-b - s) / 2;
+
+    // both intersections are behind us, so no potential collisions
+    if ((p &lt; 0) &amp;&amp; (q &lt; 0)) return; 
+
+    // at least one intersection is in front, so intersects our forward
+    // path
+    pi.intersect = true;
+    pi.obstacle = this;
+    pi.distance =
+        ((p &gt; 0) &amp;&amp; (q &gt; 0)) ?
+        // both intersections are in front of us, find nearest one
+        ((p &lt; q) ? p : q) :
+        // otherwise one is ahead and one is behind: we are INSIDE obstacle
+        (seenFrom () == outside ?
+         // inside a solid obstacle, so distance to obstacle is zero
+         0.0f :
+         // hollow obstacle (or &quot;both&quot;), pick point that is in front
+         ((p &gt; 0) ? p : q));
+    pi.surfacePoint =
+        vehicle.getPosition() + (vehicle.getForward() * pi.distance);
+    pi.surfaceNormal = (pi.surfacePoint-center).normalisedCopy();
+    // hmm, note that this was actually determined already in pi.distance calc
+    pi.vehicleOutside = lc.length () &gt; radius;
+    switch (seenFrom ())
+    {
+    case outside:
+        pi.steerHint = pi.surfaceNormal;
+        break;
+    case inside:
+        pi.steerHint = -pi.surfaceNormal;
+        break;
+    case both:
+        pi.steerHint = pi.surfaceNormal * (pi.vehicleOutside ? 1.0f : -1.0f);
+        break;
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// BoxObstacle
+// find first intersection of a vehicle's path with this obstacle
+
+
+void 
+OpenSteer::
+BoxObstacle::
+findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
+                                 PathIntersection&amp; pi) const
+{
+    // abbreviations
+    const float w = width; // dimensions
+    const float h = height;
+    const float d = depth;
+    const Vector3 s = getSide(); // local space
+    const Vector3 u = getUp();
+    const Vector3 f = getForward();
+    const Vector3 p = getPosition();
+    const Vector3 hw = s * (0.5f * width); // offsets for face centers
+    const Vector3 hh = u * (0.5f * height);
+    const Vector3 hd = f * (0.5f * depth);
+    const seenFromState sf = seenFrom ();
+
+    // the box's six rectangular faces
+    RectangleObstacle r1 (w, h,  s,  u,  f, p + hd, sf); // front
+    RectangleObstacle r2 (w, h, -s,  u, -f, p - hd, sf); // back
+    RectangleObstacle r3 (d, h, -f,  u,  s, p + hw, sf); // side
+    RectangleObstacle r4 (d, h,  f,  u, -s, p - hw, sf); // other side
+    RectangleObstacle r5 (w, d,  s, -f,  u, p + hh, sf); // top
+    RectangleObstacle r6 (w, d, -s, -f, -u, p - hh, sf); // bottom
+
+    // group the six RectangleObstacle faces together
+    ObstacleGroup faces;
+    faces.push_back (&amp;r1);
+    faces.push_back (&amp;r2);
+    faces.push_back (&amp;r3);
+    faces.push_back (&amp;r4);
+    faces.push_back (&amp;r5);
+    faces.push_back (&amp;r6);
+
+    // find first intersection of vehicle path with group of six faces
+    PathIntersection next;
+    firstPathIntersectionWithObstacleGroup (vehicle, faces, pi, next);
+
+    // when intersection found, adjust PathIntersection for the box case
+    if (pi.intersect)
+    {
+        pi.obstacle = this;
+        pi.steerHint = ((pi.surfacePoint - getPosition()).normalisedCopy() *
+                        (pi.vehicleOutside ? 1.0f : -1.0f));
+    }
+}
+
+
+// ----------------------------------------------------------------------------
+// PlaneObstacle
+// find first intersection of a vehicle's path with this obstacle
+
+
+void 
+OpenSteer::
+PlaneObstacle::
+findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
+                                 PathIntersection&amp; pi) const
+{
+    // initialize pathIntersection object to &quot;no intersection found&quot;
+    pi.intersect = false;
+
+    const Vector3 lp =  localizePosition (vehicle.getPosition());
+    const Vector3 ld = localizeDirection (vehicle.getForward());
+
+    // no obstacle intersection if path is parallel to XY (side/up) plane
+    if (ld.dotProduct(Vector3::NEGATIVE_UNIT_Z) == 0.0f) return;
+
+    // no obstacle intersection if vehicle is heading away from the XY plane
+    if ((lp.z &gt; 0.0f) &amp;&amp; (ld.z &gt; 0.0f)) return;
+    if ((lp.z &lt; 0.0f) &amp;&amp; (ld.z &lt; 0.0f)) return;
+
+    // no obstacle intersection if obstacle &quot;not seen&quot; from vehicle's side
+    if ((seenFrom () == outside) &amp;&amp; (lp.z &lt; 0.0f)) return;
+    if ((seenFrom () == inside)  &amp;&amp; (lp.z &gt; 0.0f)) return;
+
+    // find intersection of path with rectangle's plane (XY plane)
+    const float ix = lp.x - (ld.x * lp.z / ld.z);
+    const float iy = lp.y - (ld.y * lp.z / ld.z);
+    const Vector3 planeIntersection (ix, iy, 0.0f);
+
+    // no obstacle intersection if plane intersection is outside 2d shape
+    if (!xyPointInsideShape (planeIntersection, vehicle.getRadius())) return;
+
+    // otherwise, the vehicle path DOES intersect this rectangle
+    const Vector3 localXYradial = planeIntersection.normalisedCopy();
+    const Vector3 radial = globalizeDirection (localXYradial);
+    const float sideSign = (lp.z &gt; 0.0f) ? +1.0f : -1.0f;
+    const Vector3 opposingNormal = getForward() * sideSign;
+    pi.intersect = true;
+    pi.obstacle = this;
+    pi.distance = (lp - planeIntersection).length ();
+    pi.steerHint = opposingNormal + radial; // should have &quot;toward edge&quot; term?
+    pi.surfacePoint = globalizePosition (planeIntersection);
+    pi.surfaceNormal = opposingNormal;
+    pi.vehicleOutside = lp.z &gt; 0.0f;
+}
+
+
+// ----------------------------------------------------------------------------
+// RectangleObstacle
+// determines if a given point on XY plane is inside obstacle shape
+
+
+bool 
+OpenSteer::
+RectangleObstacle::
+xyPointInsideShape (const Vector3&amp; point, float radius) const
+{
+    const float w = radius + (width * 0.5f);
+    const float h = radius + (height * 0.5f);
+    return !((point.x &gt;  w) || (point.x &lt; -w) || (point.y &gt;  h) || (point.y &lt; -h));
+}
+
+
+// ----------------------------------------------------------------------------

Added: rl/trunk/engine/ai/src/OpenSteer/Path.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Path.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/Path.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,40 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ */
+#include &quot;OpenSteer/Path.h&quot;
+
+OpenSteer::Path::~Path()
+{
+    // Nothing to do.
+}
+
+/*
+OpenSteer::Path&amp; OpenSteer::Path::operator=( Path const&amp; )
+{
+    return *this;
+}
+*/

Added: rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,40 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ */
+#include &quot;OpenSteer/Pathway.h&quot;
+
+OpenSteer::Pathway::~Pathway()
+{
+    // Nothing to do.
+}
+
+/*
+OpenSteer::Pathway&amp; OpenSteer::Pathway::operator=( Pathway const&amp; )
+{
+    return *this;
+}
+*/

Added: rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,556 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ */
+#include &quot;OpenSteer/PolylineSegmentedPath.h&quot;
+
+// Include std::accumulate
+#include &lt;numeric&gt;
+
+// Include std::swap, std::adjacent_find
+#include &lt;algorithm&gt;
+
+// Include assert
+#include &lt;cassert&gt;
+
+
+
+// Include Vector3
+#include &quot;OpenSteer/Vec3.h&quot;
+
+// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
+#include &quot;OpenSteer/QueryPathAlike.h&quot;
+
+// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
+#include &quot;OpenSteer/QueryPathAlikeMappings.h&quot;
+
+// Include OpenSteer::HasNoRadius
+#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
+
+// Include OpenSteer::clamp, OpenSteer::shrinkToFit
+#include &quot;OpenSteer/Utilities.h&quot;
+
+
+
+namespace {
+    
+    typedef OpenSteer::SegmentedPath::size_type size_type;
+    typedef std::vector&lt; Vector3 &gt; Vec3Container;
+    typedef std::vector&lt; float &gt; FloatContainer;
+    
+    /**
+     * Recalculates the segment tangent and length for segment @a segmentIndex.
+     *
+     * @attention @a segmentTangents and @a segmentLengths must have the right
+     *            size.
+     */
+    void
+    updateSegmentTangentAndLength( size_type segmentIndex,
+                                   Vec3Container const&amp; points , 
+                                   Vec3Container&amp; segmentTangents, 
+                                   FloatContainer&amp; segmentLengths ) 
+    {
+        assert( ( ( segmentIndex + 1 ) &lt; points.size() ) &amp;&amp; 
+                &quot;Not enough points for segment segmentIndex.&quot; );
+        assert( segmentIndex &lt; segmentTangents.size() &amp;&amp;
+                &quot;segmentIndex out of range.&quot; );
+        assert( segmentTangents.size() == segmentLengths.size() &amp;&amp; &quot;segmentTangents and segmentLengths must have the same size.&quot; );
+        
+        Vector3 tangent = points[ segmentIndex + 1 ] - points[ segmentIndex ];
+        float const length = tangent.length();
+        assert( ! OpenSteer::isZero( length ) &amp;&amp; 
+                &quot;Segments must have lengths greater than 0.&quot; );
+        
+        tangent /= length;
+        
+        segmentTangents[ segmentIndex ] = tangent;
+        segmentLengths[ segmentIndex] = length;        
+    }
+    
+    
+    /**
+     * Helper function to calucate the segment tangent and lengths
+     * in the given range.
+     *
+     * @param points points defining the path.
+     * @param segmentTangents container to store the calculated segment 
+     *                        tangents. Must have the right size.
+     * @param segmentLengths container to store the calculated segment lengths.
+     *                       Must have the right size.
+     * @param firstChangedPointIndex the first point that changed. Segments have 
+     *        to be updated starting with it.
+     * @param numOfPoints number of points that changed beginning with 
+     *        @a startIndex.
+     * @param isCyclic Is the path cyclic or not.
+     *
+     */
+    void 
+    updateTangentsAndLengths( Vec3Container const&amp; points , 
+                              Vec3Container&amp; segmentTangents, 
+                              FloatContainer&amp; segmentLengths, 
+                              size_type firstChangedPointIndex, 
+                              size_type numOfPoints,
+                              bool isCyclic )
+    {
+        assert( 0 &lt; numOfPoints &amp;&amp; &quot;Only call if points have really changed.&quot; );
+        assert( 1 &lt; points.size() &amp;&amp; &quot;Two points are needed for a segment.&quot; );
+        assert( points.size() == segmentTangents.size() + 1 &amp;&amp; 
+                &quot;Two points are needed for one segment, therefore there must be one segment less than points.&quot; );
+        assert( segmentTangents.size() == segmentLengths.size() &amp;&amp; &quot;segmentTangents and segmentLengths must have the same size.&quot; );
+        // Other assertions aren't tested because the function should only be
+        // called by other functions that guarantee correctness of the 
+        // parameters.
+        
+        
+        // The segment with end point @a firstChangedPointIndex has also 
+        // changed. Beware from range underflow by subtraction.      
+        size_type firstSegmentIndex = firstChangedPointIndex;
+        if ( 0 &lt; firstSegmentIndex ) {
+            firstSegmentIndex -= 1;
+        }
+        
+        // The last segment to update has the last changed point as its start
+        // point. This only holds true if the last changed point isn't the last
+        // point.
+        // lastSegmentIndex is one greater than the real last segment to update
+        // like the last iterators in the stl.
+        size_type lastSegmentIndex = firstChangedPointIndex + numOfPoints;
+        lastSegmentIndex = OpenSteer::clamp( lastSegmentIndex, static_cast&lt; size_t &gt;( 0 ), segmentTangents.size() );
+        
+        for ( size_type i = firstSegmentIndex; i &lt; lastSegmentIndex; ++i ) {
+            updateSegmentTangentAndLength( i, points, segmentTangents, segmentLengths );
+        }
+        
+        // If path is cyclic and the first point changed and the cycle closing
+        // segment hasn't been updated update it now.
+        if ( isCyclic &amp;&amp; 
+             ( 0 == firstSegmentIndex ) &amp;&amp; 
+             ! ( lastSegmentIndex == segmentTangents.size() ) ) {
+            
+            updateSegmentTangentAndLength( segmentTangents.size() - 1, 
+                                           points, 
+                                           segmentTangents, 
+                                           segmentLengths );
+        }
+        
+    }
+    
+    
+    /**
+     * Checks that no adjacent points are equal. Checks the first and last
+     * point if the path is cyclic, too.
+     */
+    template&lt; typename Iterator &gt;
+    bool adjacentPathPointsDifferent( Iterator first, Iterator last, bool closedCycle  ) {
+        
+        assert( last - first &gt; 1 &amp;&amp; &quot;A path needs at least two waypoints.&quot; );
+        
+        if ( last != std::adjacent_find( first, last ) ) {
+            return false;
+        }
+    
+        if ( closedCycle ) {
+            Iterator before_last( first );
+            std::advance( before_last, last - first - 1  );
+            
+            return *first == *before_last;
+        }
+        
+        return true;
+    }
+    
+    
+        
+} // anonymous namespace
+
+
+
+
+
+
+
+OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath()
+    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( false )
+{
+    
+}
+
+
+OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( size_type numOfPoints,
+                                                         Vector3 const newPoints[],
+                                                         bool closedCycle )
+    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
+{
+        setPath( numOfPoints, newPoints, closedCycle );
+}
+
+OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( const PathPoints&amp; newPoints,
+                                                         bool closedCycle )
+    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
+{
+        setPath( newPoints, closedCycle );
+}
+
+OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( PolylineSegmentedPath const&amp; other )
+    : SegmentedPath( other ), points_( other.points_ ), segmentTangents_( other.segmentTangents_ ), segmentLengths_( other.segmentLengths_ ), closedCycle_( other.closedCycle_ )
+{
+    // Nothing to do.
+}
+
+
+
+OpenSteer::PolylineSegmentedPath::~PolylineSegmentedPath()
+{
+    // Nothing to do.
+}
+
+
+
+OpenSteer::PolylineSegmentedPath&amp; 
+OpenSteer::PolylineSegmentedPath::operator=( PolylineSegmentedPath other )
+{
+    swap( other ); 
+    return *this;
+}
+
+
+
+void 
+OpenSteer::PolylineSegmentedPath::swap( PolylineSegmentedPath&amp; other )
+{
+    points_.swap( other.points_ );
+    segmentTangents_.swap( other.segmentTangents_ );
+    segmentLengths_.swap( other.segmentLengths_ );
+    std::swap( closedCycle_, other.closedCycle_ );
+}
+
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPath::setPath( size_type numOfPoints,
+                                           Vector3 const newPoints[],
+                                           bool closedCycle )
+{
+    assert( 1 &lt; numOfPoints &amp;&amp; &quot;Path must have at least two distinct points.&quot; );
+    // While testing say that no cyclus is used because the first point hasn't 
+    // been copied to the back.
+    assert( adjacentPathPointsDifferent( newPoints, newPoints + numOfPoints, false ) &amp;&amp; &quot;Adjacent path points must be different.&quot; );
+    
+    closedCycle_ = closedCycle;
+    
+    size_type numberOfPoints = numOfPoints;
+    if ( closedCycle_ ) {
+        ++numberOfPoints;
+    }
+    
+    points_.reserve( numberOfPoints );
+    segmentTangents_.resize( numberOfPoints - 1 );
+    segmentLengths_.resize( numberOfPoints - 1 );
+    
+    points_.assign( newPoints, newPoints + numOfPoints );
+    
+    if ( closedCycle_ ) {
+        points_.push_back( points_[ 0 ] );
+    }
+    
+    updateTangentsAndLengths( points_ , 
+                              segmentTangents_, 
+                              segmentLengths_, 
+                              0, 
+                              numOfPoints,
+                              closedCycle_ );
+    
+    shrinkToFit( points_ );
+    shrinkToFit( segmentTangents_ );
+    shrinkToFit( segmentLengths_ );
+}
+
+void 
+OpenSteer::PolylineSegmentedPath::setPath( const PathPoints&amp; newPoints,
+                                           bool closedCycle )
+{
+    size_type numberOfPoints = newPoints.size();
+    assert( 1 &lt; numberOfPoints &amp;&amp; &quot;Path must have at least two distinct points.&quot; );
+    // While testing say that no cyclus is used because the first point hasn't 
+    // been copied to the back.
+    assert( adjacentPathPointsDifferent( newPoints.begin(), newPoints.end(), false ) &amp;&amp; &quot;Adjacent path points must be different.&quot; );
+    
+    closedCycle_ = closedCycle;
+    
+    
+    if ( closedCycle_ ) {
+        ++numberOfPoints;
+    }
+    
+    points_ = newPoints;
+    segmentTangents_.resize( numberOfPoints - 1 );
+    segmentLengths_.resize( numberOfPoints - 1 );
+    
+    if ( closedCycle_ ) {
+        points_.push_back( points_[ 0 ] );
+    }
+    
+    updateTangentsAndLengths( points_ , 
+                              segmentTangents_, 
+                              segmentLengths_, 
+                              0, 
+                              numberOfPoints,
+                              closedCycle_ );
+    
+    shrinkToFit( points_ );
+    shrinkToFit( segmentTangents_ );
+    shrinkToFit( segmentLengths_ );
+}
+
+
+void 
+OpenSteer::PolylineSegmentedPath::movePoints( size_type startIndex,
+                                              size_type numOfPoints,
+                                              Vector3 const newPoints[] )
+{
+    assert( ( startIndex &lt; ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) &amp;&amp; 
+            &quot;startIndex must be inside index range.&quot; );
+    assert( ( ( startIndex + numOfPoints ) &lt;= ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) &amp;&amp; 
+            &quot;The max. index of a point to set must be inside the index range.&quot; ); 
+    
+    // Update the point positions.
+    // @todo Remove this line size_type const pathPointCount = pointCount();
+    for ( size_type i = 0; i &lt; numOfPoints; ++i ) {
+        points_[ startIndex + i ] = newPoints[ i ];
+    }
+    
+    // If the first point is changed and the path is cyclic also change the
+    // last point, which is just a copy of the first point.
+    if ( isCyclic() &amp;&amp; ( 0 == startIndex ) ) {
+        points_.back() = points_.front();
+    }
+    
+    // Recalculate the tangents and lengths.
+    updateTangentsAndLengths( points_, 
+                              segmentTangents_, 
+                              segmentLengths_, 
+                              startIndex, 
+                              numOfPoints, 
+                              isCyclic() );
+    
+    
+    assert( adjacentPathPointsDifferent( points_.begin(), points_.end(), isCyclic() ) &amp;&amp; &quot;Adjacent path points must be different.&quot; );
+}
+
+
+bool
+OpenSteer::PolylineSegmentedPath::isValid() const 
+{
+    return pointCount() &gt; 1;
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPath::mapPointToPath (const Vector3&amp; point,
+                                                  Vector3&amp; tangent,
+                                                  float&amp; outside) const
+{
+    PointToPathMapping mapping;
+    mapPointToPathAlike( *this, point, mapping );
+    tangent = mapping.tangent;
+    outside = mapping.distancePointToPath;
+    return mapping.pointOnPathCenterLine;
+}
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPath::mapPathDistanceToPoint (float pathDistance) const
+{
+    PathDistanceToPointMapping mapping;
+    mapDistanceToPathAlike( *this, pathDistance, mapping );
+    return mapping.pointOnPathCenterLine;
+}
+
+
+float 
+OpenSteer::PolylineSegmentedPath::mapPointToPathDistance (const Vector3&amp; point) const
+{
+    PointToPathDistanceMapping mapping;
+    mapPointToPathAlike( *this, point, mapping );
+    return mapping.distanceOnPath;
+}
+
+
+bool 
+OpenSteer::PolylineSegmentedPath::isCyclic() const
+{
+    return closedCycle_;
+}
+
+
+float 
+OpenSteer::PolylineSegmentedPath::length() const
+{
+    return std::accumulate( segmentLengths_.begin(), segmentLengths_.end(), 0.0f );
+}
+
+
+OpenSteer::SegmentedPath::size_type 
+OpenSteer::PolylineSegmentedPath::pointCount() const
+{
+    return points_.size();
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPath::point( size_type pointIndex ) const
+{
+    assert( pointIndex &lt; pointCount() &amp;&amp; &quot;pointIndex out of range.&quot; );
+    return points_[ pointIndex ];
+}
+
+
+
+
+OpenSteer::PolylineSegmentedPath::size_type 
+OpenSteer::PolylineSegmentedPath::segmentCount() const
+{
+    return segmentTangents_.size();
+}
+
+
+float 
+OpenSteer::PolylineSegmentedPath::segmentLength( size_type segmentIndex ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
+    return segmentLengths_[ segmentIndex ];
+}
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPath::segmentStart( size_type segmentIndex ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
+    assert( segmentIndex &lt; pointCount() &amp;&amp; &quot;The max. index of a point must be inside range.&quot; );
+    return points_[ segmentIndex ];
+}
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPath::segmentEnd( size_type segmentIndex ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
+    assert( segmentIndex + 1&lt; pointCount() &amp;&amp; &quot;The max. index of a point must be inside range.&quot; );
+
+    return points_[ segmentIndex + 1 ];
+}
+
+
+float 
+OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistance( size_type segmentIndex, 
+                                                             Vector3 const&amp; point ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
+    
+    Vector3 const segmentStartToPoint( point - points_[ segmentIndex ] );
+    float const distance = segmentStartToPoint.dotProduct( segmentTangents_[ segmentIndex ] );
+    
+    return clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
+}
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                             float segmentDistance ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
+    
+    float const segmentLength = segmentLengths_[ segmentIndex ];
+    /*
+     * bk: remove behavior that treats negative numbers as distances beginning 
+     * from the end of the segment
+    if ( 0.0f &gt; segmentDistance ) {
+        segmentDistance += segmentLength;
+    }
+    */
+    segmentDistance = clamp( segmentDistance, 0.0f, segmentLength );
+    
+    return segmentTangents_[ segmentIndex ] * segmentDistance + points_[ segmentIndex ];
+}
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToTangent( size_type segmentIndex, 
+                                                               float ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
+    return segmentTangents_[ segmentIndex ];
+}
+
+
+void 
+OpenSteer::PolylineSegmentedPath::mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
+                                                                       float segmentDistance,
+                                                                       Vector3&amp; pointOnPath,
+                                                                       Vector3&amp; tangent ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
+    
+    float const segmentLength = segmentLengths_[ segmentIndex ];
+    
+    /* 
+     * bk: remove behavior that treats negative numbers as distances beginning 
+     * from the end of the segment
+    if ( 0.0f &gt; segmentDistance ) {
+        segmentDistance += segmentLength;
+    }
+    */
+    segmentDistance = clamp( segmentDistance, 0.0f, segmentLength );
+    
+    pointOnPath = segmentTangents_[ segmentIndex ] * segmentDistance + points_[ segmentIndex ];
+    tangent = segmentTangents_[ segmentIndex ];
+}
+
+
+void 
+OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
+                                                                               Vector3 const&amp; point,
+                                                                               float&amp; distance,
+                                                                               Vector3&amp; pointOnPath,
+                                                                               Vector3&amp; tangent ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
+    
+    Vector3 const segmentStartPoint = points_[ segmentIndex ];
+    Vector3 const segmentStartToPoint( point - segmentStartPoint );
+    tangent = segmentTangents_[ segmentIndex ];
+    distance = segmentStartToPoint.dotProduct( tangent );
+    distance =  clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
+    pointOnPath = tangent * distance + segmentStartPoint;
+}
+
+
+
+

Added: rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,327 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ */
+#include &quot;OpenSteer/PolylineSegmentedPathwaySingleRadius.h&quot;
+
+
+// Include std::swap
+#include &lt;algorithm&gt;
+
+
+// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
+#include &quot;OpenSteer/QueryPathAlike.h&quot;
+
+// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
+#include &quot;OpenSteer/QueryPathAlikeMappings.h&quot;
+
+// Include OpenSteer::HasSingleRadius
+#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
+
+// Include OPENSTEER_UNUSED_PARAMETER
+#include &quot;OpenSteer/UnusedParameter.h&quot;
+
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius()
+    : path_(), radius_ ( 0.0f )
+{
+    
+}
+
+
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( float r )
+    : path_(), radius_( r )
+{
+    
+}
+
+
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
+                                                                                       Vector3 const points[],
+                                                                                       float r,
+                                                                                       bool closeCycle )
+    : path_( numOfPoints, points, closeCycle ), radius_( r )
+{
+    
+}
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( const PolylineSegmentedPath::PathPoints&amp; points,
+                                                                                       float r,
+                                                                                       bool closeCycle )
+    : path_( points, closeCycle ), radius_( r )
+{
+    
+}
+
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const&amp; other )
+    : SegmentedPathway( other ), path_( other.path_ ), radius_( other.radius_ )
+{
+    
+}
+
+
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius::~PolylineSegmentedPathwaySingleRadius()
+{
+    // Nothing to do.
+}
+
+
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius&amp; 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::operator=( PolylineSegmentedPathwaySingleRadius other )
+{
+    swap( other );
+    return *this;
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::swap( PolylineSegmentedPathwaySingleRadius&amp; other )
+{
+    path_.swap( other.path_ );
+    std::swap( radius_, other.radius_ );
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::movePoints( size_type startIndex,
+                                                             size_type numOfPoints,
+                                                             Vector3 const newPointValues[] )
+{
+    path_.movePoints( startIndex, numOfPoints, newPointValues );
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::setPathway( size_type numOfPoints,
+                                                             Vector3 const points[],
+                                                             float r,
+                                                             bool closedCycle )
+{
+    path_.setPath( numOfPoints, points, closedCycle );
+    setRadius( r );
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::setRadius( float r )
+{
+    radius_ = r;
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::radius() const
+{
+    return radius_;
+}
+
+
+
+bool
+OpenSteer::PolylineSegmentedPathwaySingleRadius::isValid() const 
+{
+    return pointCount() &gt; 1;
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPath (const Vector3&amp; point,
+                                                                 Vector3&amp; tangent,
+                                                                 float&amp; outside) const
+{
+    PointToPathMapping mapping;
+    mapPointToPathAlike( *this, point, mapping );
+    tangent = mapping.tangent;
+    outside = mapping.distancePointToPath;
+    return mapping.pointOnPathCenterLine;
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPathDistanceToPoint (float pathDistance) const
+{
+    PathDistanceToPointMapping mapping;
+    mapDistanceToPathAlike( *this, pathDistance, mapping );
+    return mapping.pointOnPathCenterLine;
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPathDistance (const Vector3&amp; point) const
+{
+    PointToPathDistanceMapping mapping;
+    mapPointToPathAlike( *this, point, mapping );
+    return mapping.distanceOnPath;
+}
+
+
+
+bool 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::isCyclic() const
+{
+    return path_.isCyclic();
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::length() const
+{
+    return path_.length();
+}
+
+
+
+OpenSteer::SegmentedPathway::size_type 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::pointCount() const 
+{
+    return path_.pointCount();
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::point( size_type pointIndex ) const
+{
+    return path_.point( pointIndex );
+}
+
+
+
+
+OpenSteer::PolylineSegmentedPathwaySingleRadius::size_type 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentCount() const
+{
+    return path_.segmentCount();
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentLength( size_type segmentIndex ) const
+{
+    return path_.segmentLength( segmentIndex );
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentStart( size_type segmentIndex ) const
+{
+    return path_.segmentStart( segmentIndex );
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentEnd( size_type segmentIndex ) const
+{
+    return path_.segmentEnd( segmentIndex );
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistance( size_type segmentIndex, 
+                                                                            Vector3 const&amp; point ) const
+{
+    return path_.mapPointToSegmentDistance( segmentIndex, point );
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                                            float segmentDistance ) const
+{
+    return path_.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToRadius( size_type segmentIndex, 
+                                                                             float distanceOnSegment ) const
+{
+    OPENSTEER_UNUSED_PARAMETER(segmentIndex);
+    OPENSTEER_UNUSED_PARAMETER(distanceOnSegment);
+    return radius_;
+}
+
+
+
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToTangent( size_type segmentIndex, 
+                                                                              float segmentDistance ) const
+{
+    return path_.mapSegmentDistanceToTangent( segmentIndex, segmentDistance );
+}
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
+                                                                                               float distance,
+                                                                                               Vector3&amp; pointOnPath,
+                                                                                               Vector3&amp; tangent,
+                                                                                               float&amp; radius ) const
+{
+    path_.mapDistanceToSegmentPointAndTangent( segmentIndex, distance, pointOnPath, tangent );
+    radius = radius_;
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
+                                                                                              Vector3 const&amp; point,
+                                                                                              float&amp; distance,
+                                                                                              Vector3&amp; pointOnPath,
+                                                                                              Vector3&amp; tangent,
+                                                                                              float&amp; radius) const
+{
+    path_.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, distance, pointOnPath, tangent );
+    radius = radius_;
+}
+
+

Added: rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,40 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ */
+#include &quot;OpenSteer/SegmentedPath.h&quot;
+
+OpenSteer::SegmentedPath::~SegmentedPath()
+{
+    // Nothing to do.
+}
+
+/*
+OpenSteer::SegmentedPath&amp; OpenSteer::SegmentedPath::operator=( SegmentedPath const&amp; )
+{
+    return *this;
+}
+*/

Added: rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,40 @@
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ */
+#include &quot;OpenSteer/SegmentedPathway.h&quot;
+
+OpenSteer::SegmentedPathway::~SegmentedPathway()
+{
+    // Nothing to do.
+}
+
+/*
+OpenSteer::SegmentedPathway&amp; OpenSteer::SegmentedPathway::operator=( SegmentedPathway const&amp; )
+{
+    return *this;
+}
+*/

Added: rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,192 @@
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+//
+// Vector3: OpenSteer's generic type for 3d vectors
+//
+// This file defines the class Vector3, which is used throughout OpenSteer to
+// manipulate 3d geometric data.  It includes standard vector operations (like
+// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
+// utility functions.
+//
+// When integrating OpenSteer into a preexisting 3d application, it may be
+// important to use the 3d vector type of that application.  In that case Vector3
+// can be changed to inherit from the preexisting application' vector type and
+// to match the interface used by OpenSteer to the interface provided by the
+// preexisting 3d vector type.
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
+//               vecmath package (<A HREF="http://objectclub.esm.co.jp/vecmath/">http://objectclub.esm.co.jp/vecmath/</A>)
+//
+//
+// ----------------------------------------------------------------------------
+
+
+#include &quot;OpenSteer/Vec3.h&quot;
+
+
+Vector3 
+OpenSteer::RandomVectorInUnitRadiusSphere (void)
+{
+    Vector3 v;
+
+    do
+    {
+        v.x = (frandom01()*2) - 1;
+        v.y = (frandom01()*2) - 1;
+        v.z = (frandom01()*2) - 1;
+    }
+    while (v.length() &gt;= 1);
+
+    return v;
+}
+
+
+// ----------------------------------------------------------------------------
+// Returns a position randomly distributed on a disk of unit radius
+// on the XZ (Y=0) plane, centered at the origin.  Orientation will be
+// random and length will range between 0 and 1
+
+
+Vector3 
+OpenSteer::randomVectorOnUnitRadiusXZDisk (void)
+{
+    Vector3 v;
+
+    do
+    {
+        v.x = (frandom01()*2) - 1;
+        v.y = 0;
+        v.z = (frandom01()*2) - 1;
+    }
+    while (v.length() &gt;= 1);
+
+    return v;
+}
+
+
+// ----------------------------------------------------------------------------
+// Does a &quot;ceiling&quot; or &quot;floor&quot; operation on the angle by which a given vector
+// deviates from a given reference basis vector.  Consider a cone with &quot;basis&quot;
+// as its axis and slope of &quot;cosineOfConeAngle&quot;.  The first argument controls
+// whether the &quot;source&quot; vector is forced to remain inside or outside of this
+// cone.  Called by vecLimitMaxDeviationAngle and vecLimitMinDeviationAngle.
+
+
+Vector3 
+OpenSteer::vecLimitDeviationAngleUtility (const bool insideOrOutside,
+                                          const Vector3&amp; source,
+                                          const float cosineOfConeAngle,
+                                          const Vector3&amp; basis)
+{
+    // immediately return zero length input vectors
+    float sourceLength = source.length();
+    if (sourceLength == 0) return source;
+
+    // measure the angular diviation of &quot;source&quot; from &quot;basis&quot;
+    const Vector3 direction = source / sourceLength;
+    float cosineOfSourceAngle = direction.dotProduct(basis);
+
+    // Simply return &quot;source&quot; if it already meets the angle criteria.
+    // (note: we hope this top &quot;if&quot; gets compiled out since the flag
+    // is a constant when the function is inlined into its caller)
+    if (insideOrOutside)
+    {
+	// source vector is already inside the cone, just return it
+	if (cosineOfSourceAngle &gt;= cosineOfConeAngle) return source;
+    }
+    else
+    {
+	// source vector is already outside the cone, just return it
+	if (cosineOfSourceAngle &lt;= cosineOfConeAngle) return source;
+    }
+
+    // find the portion of &quot;source&quot; that is perpendicular to &quot;basis&quot;
+    const Vector3 perp = Vec3Utils::perpendicularComponent(source, basis);
+
+    // normalize that perpendicular
+    const Vector3 unitPerp = perp.normalisedCopy();
+
+    // construct a new vector whose length equals the source vector,
+    // and lies on the intersection of a plane (formed the source and
+    // basis vectors) and a cone (whose axis is &quot;basis&quot; and whose
+    // angle corresponds to cosineOfConeAngle)
+    float perpDist = sqrtXXX (1 - (cosineOfConeAngle * cosineOfConeAngle));
+    const Vector3 c0 = basis * cosineOfConeAngle;
+    const Vector3 c1 = unitPerp * perpDist;
+    return (c0 + c1) * sourceLength;
+}
+
+
+// ----------------------------------------------------------------------------
+// given a vector, return a vector perpendicular to it.  arbitrarily selects
+// one of the infinitely many perpendicular vectors.  a zero vector maps to
+// itself, otherwise length is irrelevant (empirically, output length seems to
+// remain within 20% of input length).
+
+
+Vector3 
+OpenSteer::findPerpendicularIn3d (const Vector3&amp; direction)
+{
+    // to be filled in:
+    Vector3 quasiPerp;  // a direction which is &quot;almost perpendicular&quot;
+    Vector3 result;     // the computed perpendicular to be returned
+
+    // three mutually perpendicular basis vectors
+    const Vector3 i (1, 0, 0);
+    const Vector3 j (0, 1, 0);
+    const Vector3 k (0, 0, 1);
+
+    // measure the projection of &quot;direction&quot; onto each of the axes
+    const float id = i.dotProduct(direction);
+    const float jd = j.dotProduct(direction);
+    const float kd = k.dotProduct(direction);
+
+    // set quasiPerp to the basis which is least parallel to &quot;direction&quot;
+    if ((id &lt;= jd) &amp;&amp; (id &lt;= kd))
+    {
+        quasiPerp = i;               // projection onto i was the smallest
+    }
+    else
+    {
+        if ((jd &lt;= id) &amp;&amp; (jd &lt;= kd))
+            quasiPerp = j;           // projection onto j was the smallest
+        else
+            quasiPerp = k;           // projection onto k was the smallest
+    }
+
+    // return the cross product (direction x quasiPerp)
+    // which is guaranteed to be perpendicular to both of them
+    result = crossProduct(direction, quasiPerp);
+    return result;
+}
+
+
+// ----------------------------------------------------------------------------

Added: rl/trunk/engine/ai/src/OpenSteer/lq.c
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/lq.c	2009-03-18 20:54:57 UTC (rev 4841)
+++ rl/trunk/engine/ai/src/OpenSteer/lq.c	2009-03-18 21:30:59 UTC (rev 4842)
@@ -0,0 +1,712 @@
+/*
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+// ----------------------------------------------------------------------------
+*/
+/* ------------------------------------------------------------------ */
+/*                                                                    */
+/* Locality Query facility                                            */
+/*                                                                    */
+/* (by Craig Reynolds, see lq.h file for documentation)               */
+/*                                                                    */
+/*  5-17-99: created                                                  */
+/*  5-20-99: found elusive &quot;allocate 0 bins&quot; bug                      */
+/*  5-28-99: lqMapOverAllObjectsInLocality: clipped, incremental      */
+/*  6- 7-99: clean up, split off annotation stuff into debuglq.c      */
+/*  6- 8-99: tried screening by sum of coords (&quot;first mean&quot;?) but     */
+/*           it was slightly slower, moved unused code to debuglq     */
+/* 10-19-99: Change lqClientObject, lqObject from: &quot;struct x {};&quot; to  */
+/*           &quot;typedef struct x {} x;&quot; for EE compiler.                */
+/* 12- 2-00: Make lqObject &quot;private&quot; using lqInternalDB.              */
+/* 12- 5-00: Rename lqObject to lqDB, lqClientObject to lqClientProxy */
+/* 12- 6-00: Change lqCallBackFunction from arglist of (void*) to:    */
+/*           (void* clientObject, float distanceSquared, void*        */
+/*           clientQueryState).  Add void* clientQueryState arg to    */
+/*           lqMapOverAllObjectsInLocality and its helper functions   */
+/*           lqMapOverAllObjectsInLocalityClipped and                 */
+/*           lqMapOverAllOutsideObjects. Change macro                 */
+/*           lqTraverseBinClientObjectList to invoke callback         */
+/*           function with three arguments, add &quot;state&quot; to its        */
+/*           arglist.  Remove extern lqDistanceSquared.               */
+/* 12- 7-00: Rename lqInitClientObject to lqInitClientProxy, make     */
+/*           &quot;func&quot; be an argument to lqTraverseBinClientObjectList,  */
+/*           add comments.                                            */
+/* 12- 8-00: Add lqFindNearestNeighborWithinRadius and related        */
+/*           definitions: lqFindNearestHelper lqFindNearestState      */
+/*           Add lqMapOverAllObjects and lqRemoveAllObjects (plus:    */
+/*           lqMapOverAllObjectsInBin and lqRemoveAllObjectsInBin)    */
+/*                                                                    */
+/* ------------------------------------------------------------------ */
+
+
+#include &lt;stdlib.h&gt;
+#include &lt;float.h&gt;
+#include &lt;limits.h&gt; /* for INT_MAX */
+#include &quot;OpenSteer/lq.h&quot;
+
+/* for debugging and graphical annotation (normally unused) */
+#ifdef BOIDS_LQ_DEBUG
+#include &quot;OpenSteer/debuglq.c&quot;
+#endif
+
+#ifndef WIN32
+#define USUSED_PARAM __attribute__ ((unused))
+#else
+#define USUSED_PARAM
+#endif
+
+
+/* ------------------------------------------------------------------ */
+/* This structure represents the spatial database.  Typically one of
+   these would be created, by a call to lqCreateDatabase, for a given
+   application.  */
+
+
+typedef struct lqInternalDB
+{
+
+    /* the origin is the super-brick corner minimum coordinates */
+    float originx, originy, originz;
+
+    /* length of the edges of the super-brick */
+    float sizex, sizey, sizez;
+
+    /* number of sub-brick divisions in each direction */
+    int divx, divy, divz;
+
+    /* pointer to an array of pointers, one for each bin */
+    lqClientProxy** bins;
+
+    /* extra bin for &quot;everything else&quot; (points outside super-brick) */
+    lqClientProxy* other;
+
+} lqInternalDB;
+
+
+/* ------------------------------------------------------------------ */
+/* Allocate and initialize an LQ database, return a pointer to it.
+   The application needs to call this before using the LQ facility.
+   The nine parameters define the properties of the &quot;super-brick&quot;:
+      (1) origin: coordinates of one corner of the super-brick, its
+          minimum x, y and z extent.
+      (2) size: the width, height and depth of the super-brick.
+      (3) the number of subdivisions (sub-bricks) along each axis.
+   This routine also allocates the bin array, and initialize its
+   contents. */
+
+
+lqInternalDB* lqCreateDatabase (float originx, float originy, float originz,
+				float sizex, float sizey, float sizez,
+				int divx, int divy, int divz)
+{
+    lqInternalDB* lq = ((lqInternalDB*) malloc (sizeof (lqInternalDB)));
+
+    lqInitDatabase (lq,
+		    originx, originy, originz,
+		    sizex, sizey, sizez,
+		    divx, divy, divz);
+    return lq;
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Deallocate the memory used by the LQ database */
+
+
+void lqDeleteDatabase(lqDB* lq)
+{
+    free (lq-&gt;bins);
+    free (lq);
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Given an LQ database object and the nine basic parameters: fill in
+   the object's slots, allocate the bin array, and initialize its
+   contents. */
+
+
+void lqInitDatabase (lqInternalDB* lq,
+		     float originx, float originy, float originz,
+		     float sizex, float sizey, float sizez,
+		     int divx, int divy, int divz)
+{
+    lq-&gt;originx = originx;
+    lq-&gt;originy = originy;
+    lq-&gt;originz = originz;
+    lq-&gt;sizex = sizex;
+    lq-&gt;sizey = sizey;
+    lq-&gt;sizez = sizez;
+    lq-&gt;divx = divx;
+    lq-&gt;divy = divy;
+    lq-&gt;divz = divz;
+    {
+	int i;
+	int bincount = divx * divy * divz;
+	int arraysize = sizeof (lqClientProxy*) * bincount;
+	lq-&gt;bins = (lqClientProxy**) malloc (arraysize);
+	for (i=0; i&lt;bincount; i++) lq-&gt;bins[i] = NULL;
+    }
+    lq-&gt;other = NULL;
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Determine index into linear bin array given 3D bin indices */
+
+
+#define lqBinCoordsToBinIndex(lq, ix, iy, iz) \
+    ((ix * (lq)-&gt;divy * (lq)-&gt;divz) + (iy * (lq)-&gt;divz) + iz)
+
+
+/* ------------------------------------------------------------------ */
+/* Find the bin ID for a location in space.  The location is given in
+   terms of its XYZ coordinates.  The bin ID is a pointer to a pointer
+   to the bin contents list.  */
+
+
+lqClientProxy** lqBinForLocation (lqInternalDB* lq, 
+				  float x, float y, float z)
+{
+    int i, ix, iy, iz;
+
+    /* if point outside super-brick, return the &quot;other&quot; bin */
+    if (x &lt; lq-&gt;originx)              return &amp;(lq-&gt;other);
+    if (y &lt; lq-&gt;originy)              return &amp;(lq-&gt;other);
+    if (z &lt; lq-&gt;originz)              return &amp;(lq-&gt;other);
+    if (x &gt;= lq-&gt;originx + lq-&gt;sizex) return &amp;(lq-&gt;other);
+    if (y &gt;= lq-&gt;originy + lq-&gt;sizey) return &amp;(lq-&gt;other);
+    if (z &gt;= lq-&gt;originz + lq-&gt;sizez) return &amp;(lq-&gt;other);
+
+    /* if point inside super-brick, compute the bin coordinates */
+    ix = (int) (((x - lq-&gt;originx) / lq-&gt;sizex) * lq-&gt;divx);
+    iy = (int) (((y - lq-&gt;originy) / lq-&gt;sizey) * lq-&gt;divy);
+    iz = (int) (((z - lq-&gt;originz) / lq-&gt;sizez) * lq-&gt;divz);
+
+    /* convert to linear bin number */
+    i = lqBinCoordsToBinIndex (lq, ix, iy, iz);
+
+    /* return pointer to that bin */
+    return &amp;(lq-&gt;bins[i]);
+}
+
+
+/* ------------------------------------------------------------------ */
+/* The application needs to call this once on each lqClientProxy at
+   setup time to initialize its list pointers and associate the proxy
+   with its client object. */ 
+
+
+void lqInitClientProxy (lqClientProxy* proxy, void* clientObject)
+{
+    proxy-&gt;prev   = NULL;
+    proxy-&gt;next   = NULL;
+    proxy-&gt;bin    = NULL;
+    proxy-&gt;object = clientObject;
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Adds a given client object to a given bin, linking it into the bin
+   contents list. */
+
+
+void lqAddToBin (lqClientProxy* object, lqClientProxy** bin)
+{
+    /* if bin is currently empty */    
+    if (*bin == NULL)
+    {
+	object-&gt;prev = NULL;
+	object-&gt;next = NULL;
+	*bin = object;
+    }
+    else
+    {
+	object-&gt;prev = NULL;
+	object-&gt;next = *bin;
+	(*bin)-&gt;prev = object;
+	*bin = object;
+    }
+
+    /* record bin ID in proxy object */
+    object-&gt;bin = bin;
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Removes a given client object from its current bin, unlinking it
+   from the bin contents list. */
+
+
+void lqRemoveFromBin (lqClientProxy* object)
+{
+    /* adjust pointers if object is currently in a bin */
+    if (object-&gt;bin != NULL)
+    {
+	/* If this object is at the head of the list, move the bin
+	   pointer to the next item in the list (might be NULL). */
+	if (*(object-&gt;bin) == object) *(object-&gt;bin) = object-&gt;next;
+
+	/* If there is a prev object, link its &quot;next&quot; pointer to the
+	   object after this one. */
+	if (object-&gt;prev != NULL) object-&gt;prev-&gt;next = object-&gt;next;
+
+	/* If there is a next object, link its &quot;prev&quot; pointer to the
+	   object before this one. */
+	if (object-&gt;next != NULL) object-&gt;next-&gt;prev = object-&gt;prev;
+    }
+
+    /* Null out prev, next and bin pointers of this object. */
+    object-&gt;prev = NULL;
+    object-&gt;next = NULL;
+    object-&gt;bin = NULL;
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Call for each client object every time its location changes.  For
+   example, in an animation application, this would be called each
+   frame for every moving object.  */
+
+
+void lqUpdateForNewLocation  (lqInternalDB* lq, 
+			      lqClientProxy* object, 
+			      float x, float y, float z)
+{
+    /* find bin for new location */
+    lqClientProxy** newBin = lqBinForLocation (lq, x, y, z);
+
+    /* store location in client object, for future reference */
+    object-&gt;x = x;
+    object-&gt;y = y;
+    object-&gt;z = z;
+
+    /* has object moved into a new bin? */
+    if (newBin != object-&gt;bin)
+    {
+	lqRemoveFromBin (object);
+ 	lqAddToBin (object, newBin);
+    }
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Given a bin's list of client proxies, traverse the list and invoke
+   the given lqCallBackFunction on each object that falls within the
+   search radius.  */
+
+
+#define lqTraverseBinClientObjectList(co, radiusSquared, func, state) \
+    while (co != NULL)                                                \
+    {                                                                 \
+	/* compute distance (squared) from this client   */           \
+	/* object to given locality sphere's centerpoint */           \
+	float dx = x - co-&gt;x;                                         \
+	float dy = y - co-&gt;y;                                         \
+	float dz = z - co-&gt;z;                                         \
+	float distanceSquared = (dx * dx) + (dy * dy) + (dz * dz);    \
+                                                                      \
+	/* apply function if client object within sphere */           \
+	if (distanceSquared &lt; radiusSquared)                          \
+	    (*func) (co-&gt;object, distanceSquared, state);             \
+                                                                      \
+	/* consider next client object in bin list */                 \
+	co = co-&gt;next;                                                \
+    }
+
+
+/* ------------------------------------------------------------------ */
+/* This subroutine of lqMapOverAllObjectsInLocality efficiently
+   traverses of subset of bins specified by max and min bin
+   coordinates. */
+
+void lqMapOverAllObjectsInLocalityClipped (lqInternalDB* lq, 
+                                           float x, float y, float z,
+                                           float radius,
+                                           lqCallBackFunction func,
+                                           void* clientQueryState,
+                                           int minBinX,
+                                           int minBinY, 
+                                           int minBinZ,
+                                           int maxBinX,
+                                           int maxBinY,
+                                           int maxBinZ);
+
+void lqMapOverAllObjectsInLocalityClipped (lqInternalDB* lq, 
+					   float x, float y, float z,
+					   float radius,
+					   lqCallBackFunction func,
+					   void* clientQueryState,
+					   int minBinX,
+					   int minBinY, 
+					   int minBinZ,
+					   int maxBinX,
+					   int maxBinY,
+					   int maxBinZ)
+{
+    int i, j, k;
+    int iindex, jindex, kindex;
+    int slab = lq-&gt;divy * lq-&gt;divz;
+    int row = lq-&gt;divz;
+    int istart = minBinX * slab;
+    int jstart = minBinY * row;
+    int kstart = minBinZ;
+    lqClientProxy* co;
+    lqClientProxy** bin;
+    float radiusSquared = radius * radius;
+
+#ifdef BOIDS_LQ_DEBUG
+    if (lqAnnoteEnable) drawBallGL (x, y, z, radius);
+#endif
+
+    /* loop for x bins across diameter of sphere */
+    iindex = istart;
+    for (i = minBinX; i &lt;= maxBinX; i++)
+    {
+	/* loop for y bins across diameter of sphere */
+	jindex = jstart;
+	for (j = minBinY; j &lt;= maxBinY; j++)
+	{
+	    /* loop for z bins across diameter of sphere */
+	    kindex = kstart;
+	    for (k = minBinZ; k &lt;= maxBinZ; k++)
+	    {
+		/* get current bin's client object list */
+		bin = &amp;lq-&gt;bins[iindex + jindex + kindex];
+		co = *bin;
+
+#ifdef BOIDS_LQ_DEBUG
+		if (lqAnnoteEnable) drawBin (lq, bin);
+#endif
+		/* traverse current bin's client object list */
+		lqTraverseBinClientObjectList (co,
+					       radiusSquared,
+					       func,
+					       clientQueryState);
+		kindex += 1;
+	    }
+	    jindex += row;
+	}
+	iindex += slab;
+    }
+}
+
+
+/* ------------------------------------------------------------------ */
+/* If the query region (sphere) extends outside of the &quot;super-brick&quot;
+   we need to check for objects in the catch-all &quot;other&quot; bin which
+   holds any object which are not inside the regular sub-bricks  */
+
+void lqMapOverAllOutsideObjects (lqInternalDB* lq, 
+                                 float x, float y, float z,
+                                 float radius,
+                                 lqCallBackFunction func,
+                                 void* clientQueryState);
+
+void lqMapOverAllOutsideObjects (lqInternalDB* lq, 
+				 float x, float y, float z,
+				 float radius,
+				 lqCallBackFunction func,
+				 void* clientQueryState)
+{
+    lqClientProxy* co = lq-&gt;other;
+    float radiusSquared = radius * radius;
+
+    /* traverse the &quot;other&quot; bin's client object list */
+    lqTraverseBinClientObjectList (co,
+				   radiusSquared,
+				   func,
+				   clientQueryState);
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Apply an application-specific function to all objects in a certain
+   locality.  The locality is specified as a sphere with a given
+   center and radius.  All objects whose location (key-point) is
+   within this sphere are identified and the function is applied to
+   them.  The application-supplied function takes three arguments:
+
+     (1) a void* pointer to an lqClientProxy's &quot;object&quot;.
+     (2) the square of the distance from the center of the search
+         locality sphere (x,y,z) to object's key-point.
+     (3) a void* pointer to the caller-supplied &quot;client query state&quot;
+         object -- typically NULL, but can be used to store state
+         between calls to the lqCallBackFunction.
+
+   This routine uses the LQ database to quickly reject any objects in
+   bins which do not overlap with the sphere of interest.  Incremental
+   calculation of index values is used to efficiently traverse the
+   bins of interest. */
+
+
+void lqMapOverAllObjectsInLocality (lqInternalDB* lq, 
+				    float x, float y, float z,
+				    float radius,
+				    lqCallBackFunction func,
+				    void* clientQueryState)
+{
+    int partlyOut = 0;
+    int completelyOutside = 
+	(((x + radius) &lt; lq-&gt;originx) ||
+	 ((y + radius) &lt; lq-&gt;originy) ||
+	 ((z + radius) &lt; lq-&gt;originz) ||
+	 ((x - radius) &gt;= lq-&gt;originx + lq-&gt;sizex) ||
+	 ((y - radius) &gt;= lq-&gt;originy + lq-&gt;sizey) ||
+	 ((z - radius) &gt;= lq-&gt;originz + lq-&gt;sizez));
+    int minBinX, minBinY, minBinZ, maxBinX, maxBinY, maxBinZ;
+
+    /* is the sphere completely outside the &quot;super brick&quot;? */
+    if (completelyOutside)
+    {
+	lqMapOverAllOutsideObjects (lq, x, y, z, radius, func,
+				    clientQueryState);
+	return;
+    }
+
+    /* compute min and max bin coordinates for each dimension */
+    minBinX = (int) ((((x - radius) - lq-&gt;originx) / lq-&gt;sizex) * lq-&gt;divx);
+    minBinY = (int) ((((y - radius) - lq-&gt;originy) / lq-&gt;sizey) * lq-&gt;divy);
+    minBinZ = (int) ((((z - radius) - lq-&gt;originz) / lq-&gt;sizez) * lq-&gt;divz);
+    maxBinX = (int) ((((x + radius) - lq-&gt;originx) / lq-&gt;sizex) * lq-&gt;divx);
+    maxBinY = (int) ((((y + radius) - lq-&gt;originy) / lq-&gt;sizey) * lq-&gt;divy);
+    maxBinZ = (int) ((((z + radius) - lq-&gt;originz) / lq-&gt;sizez) * lq-&gt;divz);
+
+    /* clip bin coordinates */
+    if (minBinX &lt; 0)         {partlyOut = 1; minBinX = 0;}
+    if (minBinY &lt; 0)         {partlyOut = 1; minBinY = 0;}
+    if (minBinZ &lt; 0)         {partlyOut = 1; minBinZ = 0;}
+    if (maxBinX &gt;= lq-&gt;divx) {partlyOut = 1; maxBinX = lq-&gt;divx - 1;}
+    if (maxBinY &gt;= lq-&gt;divy) {partlyOut = 1; maxBinY = lq-&gt;divy - 1;}
+    if (maxBinZ &gt;= lq-&gt;divz) {partlyOut = 1; maxBinZ = lq-&gt;divz - 1;}
+
+    /* map function over outside objects if necessary (if clipped) */
+    if (partlyOut) 
+	lqMapOverAllOutsideObjects (lq, x, y, z, radius, func,
+				    clientQueryState);
+    
+    /* map function over objects in bins */
+    lqMapOverAllObjectsInLocalityClipped (lq,
+					  x, y, z,
+					  radius,
+					  func,
+					  clientQueryState,
+					  minBinX, minBinY, minBinZ,
+					  maxBinX, maxBinY, maxBinZ);
+}
+
+
+/* ------------------------------------------------------------------ */
+/* internal helper function */
+
+
+typedef struct lqFindNearestState
+{
+    void* ignoreObject;
+    void* nearestObject;
+    float minDistanceSquared;
+
+} lqFindNearestState;
+
+
+void lqFindNearestHelper (void* clientObject,
+                          float distanceSquared,
+                          void* clientQueryState);
+
+void lqFindNearestHelper (void* clientObject,
+			  float distanceSquared,
+			  void* clientQueryState)
+{
+    lqFindNearestState* fns = (lqFindNearestState*) clientQueryState;
+
+    /* do nothing if this is the &quot;ignoreObject&quot; */
+    if (fns-&gt;ignoreObject != clientObject)
+    {
+	/* record this object if it is the nearest one so far */
+	if (fns-&gt;minDistanceSquared &gt; distanceSquared)
+	{
+	    fns-&gt;nearestObject = clientObject;
+	    fns-&gt;minDistanceSquared = distanceSquared;
+	}
+    }
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Search the database to find the object whose key-point is nearest
+   to a given location yet within a given radius.  That is, it finds
+   the object (if any) within a given search sphere which is nearest
+   to the sphere's center.  The ignoreObject argument can be used to
+   exclude an object from consideration (or it can be NULL).  This is
+   useful when looking for the nearest neighbor of an object in the
+   database, since otherwise it would be its own nearest neighbor.
+   The function returns a void* pointer to the nearest object, or
+   NULL if none is found.  */
+
+
+void* lqFindNearestNeighborWithinRadius (lqInternalDB* lq, 
+					 float x, float y, float z,
+					 float radius,
+					 void* ignoreObject)
+{
+    /* initialize search state */
+    lqFindNearestState lqFNS;
+    lqFNS.nearestObject = NULL;
+    lqFNS.ignoreObject = ignoreObject;
+    lqFNS.minDistanceSquared = FLT_MAX;
+
+    /* map search helper function over all objects within radius */
+    lqMapOverAllObjectsInLocality (lq, 
+				   x, y, z,
+				   radius,
+				   lqFindNearestHelper,
+				   &amp;lqFNS);
+
+    /* return nearest object found, if any */
+    return lqFNS.nearestObject;
+}
+
+
+/* ------------------------------------------------------------------ */
+/* internal helper function */
+
+void lqMapOverAllObjectsInBin (lqClientProxy* binProxyList, 
+                               lqCallBackFunction func,
+                               void* clientQueryState);
+
+void lqMapOverAllObjectsInBin (lqClientProxy* binProxyList, 
+			       lqCallBackFunction func,
+			       void* clientQueryState)
+{
+    /* walk down proxy list, applying call-back function to each one */
+    while (binProxyList != NULL)
+    {
+	(*func) (binProxyList-&gt;object, 0, clientQueryState);
+	binProxyList = binProxyList-&gt;next;
+    }
+}
+
+
+/* ------------------------------------------------------------------ */
+/* Apply a user-supplied function to all objects in the database,
+   regardless of locality (cf lqMapOverAllObjectsInLocality) */
+
+void lqMapOverAllObjects (lqInternalDB* lq, 
+			  lqCallBackFunction func,
+			  void* clientQueryState)
+{
+    int i;
+    int bincount = lq-&gt;divx * lq-&gt;divy * lq-&gt;divz;
+    for (i=0; i&lt;bincount; i++)
+    {
+	lqMapOverAllObjectsInBin (lq-&gt;bins[i], func, clientQueryState);
+    }
+    lqMapOverAllObjectsInBin (lq-&gt;other, func, clientQueryState);
+}
+
+/* ------------------------------------------------------------------ */
+/* looks at all bins (except &quot;other&quot;) finding the min and max bin
+   populations and the average of NON-EMPTY bin populations.  (The
+   average over all bins is a constant (population/bincount))  */
+
+#ifndef NO_LQ_BIN_STATS
+
+void lqgbpsCounter (void* clientObject    USUSED_PARAM,
+                    float distanceSquared USUSED_PARAM,
+                    void* clientQueryState);
+
+void lqgbpsCounter (void* clientObject    USUSED_PARAM,
+                    float distanceSquared USUSED_PARAM,
+                    void* clientQueryState)
+{
+    (*(int*)clientQueryState)++;
+}
+
+void lqGetBinPopulationStats (lqInternalDB* lq,
+                              int* min,
+                              int* max,
+                              float* average)
+{
+    int minPop = INT_MAX;
+    int maxPop = 0;
+    int totalCount = 0;
+    int nonEmptyBinCount = 0;
+    int bincount = lq-&gt;divx * lq-&gt;divy * lq-&gt;divz;
+    int i;
+
+    for (i=0; i&lt;bincount; i++)
+    {
+        /* clear the counter */
+        int objectCount = 0;
+
+        /* apply counting function to each object in bin[i] */
+	lqMapOverAllObjectsInBin (lq-&gt;bins[i], lqgbpsCounter, &amp;objectCount);
+
+        /* collect data: max and min population, count objects and non-empty bins */
+        if (objectCount &gt; 0)
+        {
+            nonEmptyBinCount++;
+            if (maxPop &lt; objectCount) maxPop = objectCount;
+            if (minPop &gt; objectCount) minPop = objectCount;
+            totalCount += objectCount;
+        }
+    }
+
+    /* set return values */
+    *min = minPop;
+    *max = maxPop;
+    *average = ((float) totalCount) / ((float) nonEmptyBinCount);
+}
+
+#endif /* NO_LQ_BIN_STATS */
+
+
+/* ------------------------------------------------------------------ */
+/* internal helper function */
+
+
+#define lqRemoveAllObjectsInBin(bin) \
+    while ((bin) != NULL) lqRemoveFromBin ((bin));
+
+
+/* ------------------------------------------------------------------ */
+/* Removes (all proxies for) all objects from all bins */
+
+
+void lqRemoveAllObjects (lqInternalDB* lq)
+{
+    int i;
+    int bincount = lq-&gt;divx * lq-&gt;divy * lq-&gt;divz;
+    for (i=0; i&lt;bincount; i++)
+    {
+	lqRemoveAllObjectsInBin (lq-&gt;bins[i]);
+    }
+    lqRemoveAllObjectsInBin (lq-&gt;other);
+}
+
+
+/* ------------------------------------------------------------------ */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001898.html">[Dsa-hl-svn] r4841 - in rl/trunk/editors/Lockenwickler/src: . media
</A></li>
	<LI>Next message: <A HREF="001900.html">[Dsa-hl-svn] r4843 - in rl/trunk/engine/ai: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1899">[ date ]</a>
              <a href="thread.html#1899">[ thread ]</a>
              <a href="subject.html#1899">[ subject ]</a>
              <a href="author.html#1899">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
