<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4855 - rl/trunk/editors/Lockenwickler/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4855%20-%20rl/trunk/editors/Lockenwickler/src&In-Reply-To=%3C200903201948.n2KJmeYs026350%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001911.html">
   <LINK REL="Next"  HREF="001913.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4855 - rl/trunk/editors/Lockenwickler/src</H1>
    <B>fusion2 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4855%20-%20rl/trunk/editors/Lockenwickler/src&In-Reply-To=%3C200903201948.n2KJmeYs026350%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4855 - rl/trunk/editors/Lockenwickler/src">fusion2 at mail.berlios.de
       </A><BR>
    <I>Fri Mar 20 20:48:40 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001911.html">[Dsa-hl-svn] r4854 - rl/trunk/editors/Lockenwickler/src
</A></li>
        <LI>Next message: <A HREF="001913.html">[Dsa-hl-svn] r4856 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1912">[ date ]</a>
              <a href="thread.html#1912">[ thread ]</a>
              <a href="subject.html#1912">[ subject ]</a>
              <a href="author.html#1912">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fusion2
Date: 2009-03-20 20:48:23 +0100 (Fri, 20 Mar 2009)
New Revision: 4855

Modified:
   rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
   rl/trunk/editors/Lockenwickler/src/DepthBuffer.py
   rl/trunk/editors/Lockenwickler/src/GOIntEditor.py
   rl/trunk/editors/Lockenwickler/src/GOStringEditor.py
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MovePivot.py
   rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
   rl/trunk/editors/Lockenwickler/src/Property.py
   rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
   rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py
   rl/trunk/editors/Lockenwickler/src/setup.py
   rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py
Log:
- Lockenwickler license headers changed to be GPL now

Modified: rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Modified: rl/trunk/editors/Lockenwickler/src/DepthBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/DepthBuffer.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/DepthBuffer.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,3 +1,22 @@
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
 import ctypes as ctypes
 import random
 import platform

Modified: rl/trunk/editors/Lockenwickler/src/GOIntEditor.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GOIntEditor.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/GOIntEditor.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,4 +1,21 @@
-# -*- coding: utf-8 -*-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 &quot;&quot;&quot;
 Module implementing GOIntEditor.

Modified: rl/trunk/editors/Lockenwickler/src/GOStringEditor.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GOStringEditor.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/GOStringEditor.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,5 +1,21 @@
-# -*- coding: utf-8 -*-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 &quot;&quot;&quot;
 Module implementing GOStringEditor.
 &quot;&quot;&quot;

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,209 +1,210 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#from elementtree.ElementTree import *
-from xml.etree.cElementTree import *
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-import ogre.renderer.OGRE as og
-
-from GOStringEditor import *
-from GOIntEditor import *
-
-class GOCStringProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;STRING&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCRealProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;REAL&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCBoolProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;BOOL&quot;
-
-class GOCIntProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INT&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOIntEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCIntPairProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTPAIR&quot;
-
-class GOCIntTripleProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTTRIPPLE&quot;
-
-class GOCMapProperty():
-    def __init__(self, name):
-        self.name = name
-        self.childProperties = []
-
-    def getType(self):
-        return &quot;MAP&quot;
-
-# gameObjectClass is the id of the class itself
-# since a game object can be ingame more than once there is also a id for those
-class GameObjectRepresentation(og.UserDefinedObject):
-    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
-        og.UserDefinedObject.__init__(self)
-        self.inWorldId = inWorldId
-        self.gocName = str(gameObjectClass)
-        self.node = node
-        self.meshFile = meshFile
-        self.state = &quot;IN_SCENE&quot;
-
-    def getType(self):
-        return &quot;GAME_OBJECT_REPRESENTATION&quot;
-
-    def setPosition(self, pos):
-        self.node.setPosition(pos)
-
-
-class GameObjectClass():
-    def __init__(self,  parentElement):
-        self.classid = parentElement.get(&quot;classid&quot;)
-        self.baseclass = parentElement.get(&quot;baseclass&quot;)
-
-        self.meshFile = None
-
-        self.properties = []
-
-        for property in parentElement:#.getiterator(&quot;property&quot;):
-            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
-                pass
-            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
-                self.properties.append(self.createPropertyMap(property))
-            else:
-                self.properties.append(self.createProperty(property))
-
-    def getType(self):
-        return &quot;GAME_OBJECT&quot;
-
-    def createPropertyMap(self, property):
-        propMap = GOCMapProperty(property.get(&quot;name&quot;))
-        for subProperty in property:
-            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
-                propMap.childProperties.append(self.createPropertyMap(property))
-            else:
-                for subProperty1 in property:
-                    propMap.childProperties.append(self.createProperty(subProperty1))
-
-        return propMap
-
-    def getMeshFileName(self):
-        if self.meshFile is None:
-            for prop in self.properties:
-                if prop.getType() == &quot;STRING&quot;:
-                    if prop.name == &quot;meshfile&quot;:
-                        self.meshFile = prop.data
-                        return self.meshFile
-            return None
-        else:
-            return self.meshFile
-
-
-    def createProperty(self, property):
-        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCStringProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCRealProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCBoolProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntPairProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntTripleProperty(name, data)
-        else:
-            print property.get(&quot;type&quot;)
-
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+#from elementtree.ElementTree import *
+from xml.etree.cElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from GOStringEditor import *
+from GOIntEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;STRING&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;REAL&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;BOOL&quot;
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INT&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOIntEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTPAIR&quot;
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTTRIPPLE&quot;
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return &quot;MAP&quot;
+
+# gameObjectClass is the id of the class itself
+# since a game object can be ingame more than once there is also a id for those
+class GameObjectRepresentation(og.UserDefinedObject):
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        og.UserDefinedObject.__init__(self)
+        self.inWorldId = inWorldId
+        self.gocName = str(gameObjectClass)
+        self.node = node
+        self.meshFile = meshFile
+        self.state = &quot;IN_SCENE&quot;
+
+    def getType(self):
+        return &quot;GAME_OBJECT_REPRESENTATION&quot;
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get(&quot;classid&quot;)
+        self.baseclass = parentElement.get(&quot;baseclass&quot;)
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator(&quot;property&quot;):
+            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
+                pass
+            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return &quot;GAME_OBJECT&quot;
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get(&quot;name&quot;))
+        for subProperty in property:
+            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == &quot;STRING&quot;:
+                    if prop.name == &quot;meshfile&quot;:
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCStringProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCRealProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCBoolProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntPairProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get(&quot;type&quot;)
+
+
+

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,68 +1,69 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#from elementtree.ElementTree import parse
-from xml.etree.cElementTree import parse
-
-from GameObjectClass import *
-
-class GameObjectClassManager():
-    def __init__(self):
-        self.fileDict = {}
-        self.callback = None
-
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
-    def inWorldIdExists(self, id):
-        for rep in self.gameObjectRepresentationDict:
-            if str(rep.inWorldId) == str(id):
-                return True
-        
-        return False
-
-    def addGameObjectRepresentation(self, gocRep):
-        self.gameObjectRepresentationDict.append(gocRep)
-
-    def parseGOFFiles(self, filePaths):
-        for filePath in filePaths:
-            tree = parse(filePath)
-            gocList = []
-            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
-                go = GameObjectClass(parent)
-                gocList.append(go)
-
-            self.fileDict[filePath] = gocList
-
-        if self.callback is not None:
-            self.callback(self.fileDict)
-
-    def getGameObjectWithClassId(self, id):
-        for key in self.fileDict:
-            for go in self.fileDict[key]:
-                if go.classid == id:
-                    return go
-
-        return None
-
-        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
-    def setGameObjectsViewUpdateCallback(self, callback):
-        self.callback = callback
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+#from elementtree.ElementTree import parse
+from xml.etree.cElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+    def inWorldIdExists(self, id):
+        for rep in self.gameObjectRepresentationDict:
+            if str(rep.inWorldId) == str(id):
+                return True
+        
+        return False
+
+    def addGameObjectRepresentation(self, gocRep):
+        self.gameObjectRepresentationDict.append(gocRep)
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 from PyQt4.QtCore import *

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,21 +1,21 @@
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
  #################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
 
 import os
 import sys

Modified: rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 import sys
 from PyQt4.QtCore import *

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,1347 +1,1348 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from DepthBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-
-
-#                &lt;zone name=&quot;Testzone&quot;&gt;
-#                        &lt;area type=&quot;sphere&quot;&gt;
-#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
-#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
-#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
-#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
-#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
-#                        &lt;/area&gt;
-#                        &lt;light name=&quot;red pointlight&quot;/&gt;
-#                        &lt;light name=&quot;green spotlight&quot;/&gt;
-#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
-#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
-#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
-#                        &lt;/trigger&gt;
-#                &lt;/zone&gt;
-
-# get the light out of a light node
-def extractLight(node):
-        i = 0
-        num = node.numAttachedObjects()
-        while i &lt; node.numAttachedObjects():
-            c = node.getAttachedObject(i)
-            tp = str(type(c))
-            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Light'&gt;&quot;:
-                return c
-            
-            i += 1
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = &quot;\n&quot; + level*&quot;  &quot;
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + &quot;  &quot;
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-# creates unique names for new entities
-def createUniqueEntityName(sceneManager, name = None):
-    n = &quot;&quot;
-    if name is None:
-        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
-    else:
-        n = name
-        
-    while sceneManager.hasEntity(n):
-        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-    return n
-        
-def printVector3(vec):
-    print str(vec.x) + &quot;;&quot; + str(vec.y) + &quot;;&quot; + str(vec.z)
-    
-class EntityCustomOptions(og.UserDefinedObject):
-    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = &quot;none&quot;, renderingdistance = &quot;20000&quot;):
-        og.UserDefinedObject.__init__(self)
-        self.receivesShadow = receivesShadow
-        self.staticgeometrygroup = staticgeometrygroup
-        self.physicsproxytype = physicsproxytype
-        self.renderingdistance = renderingdistance
-        self.materialName = &quot;NotChanged&quot;
-        
-        ModuleManager.entityCustomOptionsDict.append(self)
-        
-    def copy(self):
-            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
-        
-    def getType(self):
-            return &quot;EntityCustomOptions&quot;
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
-        mapName = mapName.split(&quot;/&quot;)
-        mapName = mapName[len(mapName) - 1].split(&quot;.&quot;)
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + &quot;.rlmap.xml&quot;
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.isHidden = False
-        
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
-                self.parseMapNodes(root.find(&quot;nodes&quot;))
-                #self.parseMapZones(root.find(&quot;zones&quot;))
-            else:
-                print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
-                return
-
-    def hide(self):
-        try:
-            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
-        except:
-            print &quot;Error: map is already hidden!&quot;
-            return
-        
-        self.isHidden = True
-        
-    def show(self):
-        try:
-            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
-        except:
-            print &quot;Error: map is already shown!&quot;
-            return
-        
-        self.isHidden = False
-    
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
-        self.createGameObjects(nodes)
-        
-        nodes = nodeElement.getiterator(&quot;entity&quot;)
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator(&quot;light&quot;)
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator(&quot;sound&quot;)
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib[&quot;name&quot;]
-            
-            if entityName.startswith(&quot;dropMesh&quot;):
-                num = int(entityName.replace(&quot;dropMesh&quot;,  &quot;&quot;))
-                if ModuleManager.dropCount &lt; num:
-                    ModuleManager.dropCount = num
-                elif ModuleManager.dropCount &lt; num:
-                    ModuleManager.dropCount = num + 1
-                    
-            meshFile = nodes.attrib[&quot;meshfile&quot;]
-            
-            eco = EntityCustomOptions()
-            
-            try:
-                if nodes.attrib[&quot;receivesShadow&quot;] == &quot;False&quot; or nodes.attrib[&quot;receivesShadow&quot;] == &quot;false&quot;:
-                    eco.receivesShadow = &quot;False&quot;
-            except:
-                pass
-            try:
-                eco.staticgeometrygroup = int(nodes.attrib[&quot;staticgeometrygroup&quot;])
-            except:
-                pass
-            try:
-                eco.physicsproxy = nodes.attrib[&quot;physicsproxy&quot;]
-            except:
-                pass
-            try:
-                eco.renderingdistance = float(nodes.attrib[&quot;renderingdistance&quot;])
-            except:
-                pass
-            try:
-                eco.renderingdistance
-                nodes.attrib[&quot;materialName&quot;]
-            except:
-                pass
-                
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    posx = float(t.attrib[&quot;x&quot;])
-                    posy = float(t.attrib[&quot;y&quot;])
-                    posz = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                elif t.tag == &quot;scale&quot;:
-                    scalex = float(t.attrib[&quot;x&quot;])
-                    scaley = float(t.attrib[&quot;y&quot;])
-                    scalez = float(t.attrib[&quot;z&quot;])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
-            except:
-                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                return
-            
-
-            e.setUserObject(eco)
-            n = self.mapNode.createChild(&quot;entity_&quot; + entityName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib[&quot;name&quot;]
-            lightType = l.attrib[&quot;type&quot;]
-            lightVisible = bool(l.attrib[&quot;visible&quot;])
-            castShadows = bool(l.attrib[&quot;castShadows&quot;])
-            lightPosition = None
-            lightDirection = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-            spotlightinner = None
-            spotlightouter = None
-            falloff = None 
-            
-
-                
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;colourDiffuse&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == &quot;colourSpecular&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == &quot;lightAttenuation&quot;:
-                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
-                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
-                    lightAttenuationLinear = float(t.attrib[&quot;linear&quot;])
-                    lightAttenuationQuadric  = float(t.attrib[&quot;quadratic&quot;])
-                elif t.tag == &quot;spotlightrange&quot;:
-                    spotlightinner = float(t.attrib[&quot;inner&quot;])
-                    spotlightouter = float(t.attrib[&quot;outer&quot;])
-                    falloff = float(t.attrib[&quot;falloff&quot;])
-                    
-            light = self.sceneManager.createLight(lightName)
-            
-            if lightType == &quot;point&quot;:
-                light.setType(og.Light.LT_POINT)            
-            elif lightType == &quot;spot&quot;:
-                light.setType(og.Light.LT_SPOTLIGHT)
-            elif lightType == &quot;directional&quot;:
-                light.setType(og.Light.LT_DIRECTIONAL)
-            
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
-                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
-            if colourDiffuse:
-                light.setDiffuseColour(colourDiffuse)
-            if colourSpecular:
-                light.setSpecularColour(colourSpecular)
-            if spotlightinner and spotlightouter and spotlightouter: 
-                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
-            
-
-                
-            e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
-            n = self.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
-            n.attachObject(light)
-            n.attachObject(e)
-            if lightPosition:
-                n.setPosition(lightPosition)
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib[&quot;class&quot;]
-            
-            id = int(g.attrib[&quot;id&quot;])
-            if ModuleManager.dropCount &lt; id:
-                ModuleManager.dropCount = id
-            elif ModuleManager.dropCount &lt; id:
-                ModuleManager.dropCount = id + 1
-                
-            state = g.attrib[&quot;state&quot;]
-            nodePosition = None
-            nodeRotation = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                
-                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                dropNode = self.mapNode.createChild(&quot;gameobject_&quot; + &quot;dropNode&quot; + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                self.gocManager.addGameObjectRepresentation(go)
-                go.inWorldId = id
-                go.state = state
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element(&quot;rastullahmap&quot;)
-        root.attrib[&quot;formatVersion&quot;] = &quot;0.4.0&quot;
-        
-        nodesElem = xml.SubElement(root, &quot;nodes&quot;)
-        
-        i = 0
-        while i &lt; self.mapNode.numChildren():
-            n = self.mapNode.getChild(i)
-            if n.numAttachedObjects() &gt; 0:
-                if n.name.startswith(&quot;entity_&quot;):
-                    entElem = xml.SubElement(nodesElem, &quot;entity&quot;)
-                    entElem.attrib[&quot;name&quot;] = n.getAttachedObject(0).getName()
-                    entElem.attrib[&quot;meshfile&quot;] = n.getAttachedObject(0).getMesh().getName()
-   
-                    entElem.attrib[&quot;receivesShadow&quot;] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
-                    entElem.attrib[&quot;staticgeometrygroup&quot;] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
-                    entElem.attrib[&quot;physicsproxytype&quot;] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
-                    entElem.attrib[&quot;renderingdistance&quot;] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
-                    
-                    posElem = xml.SubElement(entElem, &quot;position&quot;)
-                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
-                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
-                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(entElem, &quot;rotation&quot;)
-                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
-                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
-                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
-                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
-                    
-                    scaleElem = xml.SubElement(entElem, &quot;scale&quot;)
-                    scaleElem.attrib[&quot;x&quot;] = str(n.getScale().x)
-                    scaleElem.attrib[&quot;y&quot;] = str(n.getScale().y)
-                    scaleElem.attrib[&quot;z&quot;] = str(n.getScale().z)
-                    
-                elif n.name.startswith(&quot;gameobject_&quot;):
-                    goElem = xml.SubElement(nodesElem, &quot;gameobject&quot;)
-                    mname = n.name
-
-                    goElem.attrib[&quot;class&quot;] = str(n.getAttachedObject(0).getUserObject().gocName)
-                    goElem.attrib[&quot;state&quot;] = str(n.getAttachedObject(0).getUserObject().state)
-                    goElem.attrib[&quot;id&quot;] = str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    
-                    posElem = xml.SubElement(goElem, &quot;position&quot;)
-                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
-                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
-                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(goElem, &quot;rotation&quot;)
-                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
-                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
-                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
-                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
-                    
-                elif n.name.startswith(&quot;light_&quot;):
-                    light = extractLight(n)
-                    lightName = light.getName()
-                    lightType = light.getType()
-                    isVisible = &quot;true&quot;
-                    if not light.getVisible():
-                        isVisible = &quot;false&quot;
-                    
-                    castShadows = &quot;false&quot;
-                    if light.getCastShadows():
-                        castShadows = &quot;true&quot;
-                    
-                    if lightType == og.Light.LT_POINT:
-                        lightType = &quot;point&quot;
-                    elif lightType == og.Light.LT_SPOTLIGHT:
-                        lightType = &quot;spot&quot;
-                    elif lightType == og.Light.LT_DIRECTIONAL:
-                        lightType = &quot;directional&quot;
-                    
-                    
-                    lightElem = xml.SubElement(nodesElem, &quot;light&quot;)
-                    lightElem.attrib[&quot;name&quot;] = lightName
-                    lightElem.attrib[&quot;type&quot;] = lightType
-                    lightElem.attrib[&quot;visible&quot;] = isVisible
-                    lightElem.attrib[&quot;castShadows&quot;] = castShadows
-                    
-                    if lightType == &quot;point&quot; or lightType == &quot;spot&quot;:
-                        posElem = xml.SubElement(lightElem, &quot;position&quot;)
-                        posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
-                        posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
-                        posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
-                    
-                    colDiffuseElem = xml.SubElement(lightElem, &quot;colourDiffuse&quot;)
-                    colDiffuseElem.attrib[&quot;r&quot;] = str(light.getDiffuseColour().r)
-                    colDiffuseElem.attrib[&quot;g&quot;] = str(light.getDiffuseColour().g)
-                    colDiffuseElem.attrib[&quot;b&quot;] = str(light.getDiffuseColour().b)
-
-                    colSpecularElem = xml.SubElement(lightElem, &quot;colourSpecular&quot;)
-                    colSpecularElem.attrib[&quot;r&quot;] = str(light.getSpecularColour().r)
-                    colSpecularElem.attrib[&quot;g&quot;] = str(light.getSpecularColour().g)
-                    colSpecularElem.attrib[&quot;b&quot;] = str(light.getSpecularColour().b)
-                    
-                    lightAttenuationElem = xml.SubElement(lightElem, &quot;lightAttenuation&quot;)
-                    lightAttenuationElem.attrib[&quot;range&quot;] = str(light.getAttenuationRange())
-                    lightAttenuationElem.attrib[&quot;constant&quot;] = str(light.getAttenuationConstant())
-                    lightAttenuationElem.attrib[&quot;linear&quot;] = str(light.getAttenuationLinear())
-                    lightAttenuationElem.attrib[&quot;quadratic&quot;] = str(light.getAttenuationQuadric())
-                    
-                    if lightType == &quot;spot&quot;:
-                        spotligthRangeElem = xml.SubElement(lightElem, &quot;spotlightrange&quot;)
-                        spotligthRangeElem.attrib[&quot;inner&quot;] = str(light.getSpotlightInnerAngle().valueDegrees())
-                        spotligthRangeElem.attrib[&quot;outer&quot;] = str(light.getSpotlightOuterAngle().valueDegrees())
-                        spotligthRangeElem.attrib[&quot;falloff&quot;] = str(light.getSpotlightFalloff())
-                        
-                    if lightType == &quot;spot&quot; or lightType == &quot;directional&quot;:
-                        directionElem = xml.SubElement(lightElem, &quot;direction&quot;)
-                        dir = og.Vector3()
-                        n.getOrientation().ToAxes(dir)
-                        directionElem.attrib[&quot;x&quot;] = str(dir.x)
-                        directionElem.attrib[&quot;y&quot;] = str(dir.y)
-                        directionElem.attrib[&quot;z&quot;] = str(dir.z)
-                        
-            i = i+1
-            
-        indent(root)
-        xml.ElementTree(root).write(self.pathToMapFile)
-        
-# caused a linux crash
-#        iter = self.mapNode.getChildIterator()
-#        while iter.hasMoreElements():
-#            name = iter.getNext().getName()
-#            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib[&quot;name&quot;]
-        
-            maps = root.getiterator(&quot;map&quot;)
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join(&quot;maps&quot;, name + &quot;.rlmap.xml&quot;))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
-        
-    def save(self):
-        root = xml.Element(&quot;scene&quot;)
-        root.attrib[&quot;name&quot;] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, &quot;map&quot;)
-            sub.attrib[&quot;file&quot;] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-        
-        self.playerStart = None
-        
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print &quot;ERROR: could not find scene: &quot; + sceneName
-        
-    
-    def isCommon(self):
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Module.isCommon() Error: couldn't find module config&quot;)
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith(&quot;super(&quot;):
-                split = lStripped.split(&quot;,&quot;)
-                if split[2].strip() == unicode(&quot;true&quot;):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == &quot;end&quot;:
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    pl = lStripped.split('&quot;')
-                    i = 1
-                    while i &lt; 100: 
-                        try:
-                            self.moduleDependencies.append(pl[i])
-                            i += 2
-                        except IndexError, e:
-                            break
-
-            elif lStripped == &quot;def getDependencies()&quot;:
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-
-        self.isLoaded = True
-        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Module.load: Error: couldn't find module config&quot;)
-            return
-
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith(&quot;hero = $GOM.getGameObject(&quot;):
-                try:
-                    self.playerStart = int(line.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0])
-                except ValueError, e:
-                    print self.modConfig + &quot; ValueError: &quot; + str(e)
-                    self.playerStart = None
-                    continue
-                    
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        
-        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-            
-        
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-            
-        self.saveModuleConfig()
-
-    def saveModuleConfig(self):
-        if self.playerStart is not None:
-            f = open(self.modConfig, &quot;r&quot;)
-            
-            newconfig = &quot;&quot;
-            for line in f:
-                if line.startswith(&quot;       hero = $GOM.getGameObject(&quot;):
-                    newconfig += &quot;       hero = $GOM.getGameObject(&quot; + str(self.playerStart) + &quot;);\n&quot;
-                else:
-                    newconfig += line
-            f.close()
-            
-            f = open(self.modConfig, &quot;w&quot;)
-            f.write(newconfig)
-            f.close()
-
-    def setResourcePaths(self, recurseFolder = &quot;&quot;):
-        if recurseFolder == &quot;&quot;:
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            elif os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
-                self.setResourcePaths(curFile)
-            elif os.path.isfile(curFile):
-                continue
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-                            
-class ModuleManager():
-    dropCount = 0
-    entityCustomOptionsDict = []
-    
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-        self.materialSelectionDialog = None
-
-        self.moduleCfgPath = &quot;&quot;
-
-        self.gocManager = GameObjectClassManager()
-        
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-       
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-        self.dropMat = None
-        
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.depthBuffer = None
-        self.propertyWindow = None
-    
-        self.oneClickEntityPlacement = False
-        
-        self.onContextMenuCallback = None
-        self.contextMenuClickPosition = None
-        self.contextMenuRay = None
-        
-        self.playerStartGameObjectId = None
-        
-        self.entityCustomOptionsDict = []
-        
-        self.raySceneQueryListener = MyRaySceneQueryListener()
-        
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
-
-        self.moduleConfigIsParsed = True
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog()
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
-        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-                m.load()
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-                
-#        self.moduleExplorer.updateView()
-#        ModuleManager.dropCount += 1
-#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-#        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
-#        e.setMaterialName(&quot;DepthMap&quot;)
-#
-#        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
-#        e2.setMaterialName(&quot;PlainColor&quot;)
-#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
-#        n.attachObject(e)
-#        n.attachObject(e2)
-#        n.setScale(og.Vector3(10, 5, 20))
-        
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
-
-#        if self.depthBuffer is None:
-#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        if self.currentMap is None:
-            print &quot;Don't forget to select a map&quot;
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        if self.oneClickEntityPlacement:
-            if self.modelSelectionDialog.listWidget.currentItem() is not None:
-                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-                self.startDropModelAction(meshFile, ray)
-                return
-            else:
-                print &quot;Warning: OneClickEntityPlacement still runed on without any selected mesh!&quot;
-                return
-                
-        #self.depthBuffer.onSelectionClick(screenX, screenY)
-        
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:
-                self.propertyWindow.showProperties(so)
-                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            self.propertyWindow.clear()
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
-#
-#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            node = so.entity.getParentNode()
-
-            if node.getName().startswith(&quot;light_&quot;):
-                light = extractLight(node)
-                self.sceneManager.destroyLight(light)
-                
-            node.detachAllObjects()
-            self.sceneManager.destroySceneNode(node)
-            self.sceneManager.destroyEntity(so.entity)
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = &quot;&quot;
-        split = name.split(&quot;_&quot;)
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + &quot;_1&quot;
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) &lt; 1 or self.currentMap is None:
-            print &quot;Warning: No map selected!&quot;
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if str(so.entity.getParentNode().getName()).startswith(&quot;gameobject_&quot;):
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gocManager.addGameObjectRepresentation(newGO)
-                        newEntity.setUserObject(newGO)
-                        #newGO.setPosition(og.Vector3(0, 0, 0))
-
-                        newSO = SelectionObject(newEntity)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith(&quot;entity_&quot;):
-                    nodeName = &quot;entity_dropNode&quot; + str(ModuleManager.dropCount)
-                    newNode = self.currentMap.mapNode.createChild(nodeName)
-
-                    entityName = createUniqueEntityName(self.sceneManager)
-                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                    eco = so.entity.getUserObject().copy()
-                    newEntity.setUserObject(eco)
-
-                    newNode.attachObject(newEntity)
-                    newNode.setPosition(so.entity.getParentNode().getPosition())
-                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                    newNode.setScale(so.entity.getParentNode().getScale())
-
-                    newSO = SelectionObject(newEntity)
-                    newSO.setSelected(True)
-                    newSelectionList.append(newSO)
-                    ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith(&quot;light_&quot;):
-                    print &quot;Can't copy lights yet :)&quot;
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) &lt; 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
-            self.gocManager.addGameObjectRepresentation(self.dropGO)
-            dropEntity.setUserObject(self.dropGO)
-
-        ModuleManager.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        if self.currentMap is None:
-            return
-        
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def finishDropGameObjectAction(self, ray):
-        self.dropGO = None
-        return
-
-    def startDropModelAction(self, meshFile, ray):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
-        
-        eco = EntityCustomOptions()
-        self.dropEntity.setUserObject(eco)
-        
-        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(ModuleManager.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        ModuleManager.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        if self.currentMap is None:
-            return
-            
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-    
-    def finishDropModelAction(self, ray):
-        return
-
-    def startDropMaterialAction(self, text):
-        self.dropMat = text
-        
-    def moveDropMaterialAction(self, event):
-        return
-
-    def finishDropMaterialAction(self, screenX, screenY):
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        if so is not None:
-            if not so.entity.getNumSubEntities() &gt; 1:
-                so.entity.setMaterialName(self.dropMat)
-                so.entity.getUserObject().materialName = self.dropMat
-            else:
-                i = 0
-                text = &quot;Warning this Entity has more than one SubEntities with the folloing materials: \n\n&quot;
-                while i &lt; so.entity.getNumSubEntities():
-                    text += &quot;SubMesh&quot; + str(i) + &quot;:  &quot; + so.entity.getSubEntity(i).getMaterialName() + &quot;\n&quot;
-                    i += 1
-                
-                text += &quot;\n Replace the materials?&quot;
-                reply = QMessageBox.question(None, &quot;Warning: multiple materials&quot;,  text,  QMessageBox.Yes|QMessageBox.No)
-                if reply == QMessageBox.Cancel:
-                    return
-                if reply == QMessageBox.Yes:
-                    so.entity.setMaterialName(self.dropMat)
-                    so.entity.getUserObject().materialName = self.dropMat
-        
-    def setOneClickEntityPlacement(self, state):
-        self.oneClickEntityPlacement = state
-    
-    def createLight(self, name):
-        pos = og.Vector3()
-        
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist &lt; 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-            
-#        so = self.selectionBuffer.onSelectionClick(int(self.contextMenuClickPosition.x), int(self.contextMenuClickPosition.y))
-#        if so is not None:
-#            result = og.Math.intersects(self.contextMenuRay, so.entity.getBoundingBox())
-#            
-#            if result.first:
-#                pos = self.contextMenuRay.getPoint(result.second)
-#                pos += so.entity.getParentNode().getPosition()
-        
-        light = None
-        if not self.sceneManager.hasLight(name):
-            light = self.sceneManager.createLight(name)
-            
-        return light,  pos
-        
-    def addPointLight(self):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        lightName = &quot;pointLight&quot; + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print &quot;Error while creating light&quot;
-            return
-            
-        light.setType(og.Light.LT_POINT)
-        
-        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
-        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        
-    def addSpotLight(self):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        lightName = &quot;spotLight&quot; + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print &quot;Error while creating light&quot;
-            return
-            
-        light.setType(og.Light.LT_SPOTLIGHT)
-        
-        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
-        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        
-    def createZone(self):
-        print &quot;creating zone here...&quot;
-    
-    def setPlayerStart(self):
-        self.mainModule.playerStart = str(self.playerStartGameObjectId)
-        print &quot;setting Player Start to &quot; + str(self.playerStartGameObjectId)
-    
-    def onContextMenu(self, screenX, screenY, ray):
-        menus = []
-        actions = []
-        actions.append(self.createAction(&quot;Create Zone here&quot;, self.createZone))
-        pla = self.createAction(&quot;Pointlight&quot;, self.addPointLight, None, &quot;idea.png&quot;)
-        pls = self.createAction(&quot;Spotlight&quot;, self.addSpotLight, None, &quot;idea.png&quot;)
-        
-        lightMenu = QMenu(&quot;Add Light&quot;)
-        lightMenu.addAction(pla)
-        lightMenu.addAction(pls)
-        menus.append(lightMenu)
-        
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
-        self.contextMenuRay = ray
-        
-        if so is not None and so.entity.getParentNode().getName().startswith(&quot;gameobject_&quot;):
-            actions.append(self.createAction(&quot;Set Player Starterpoint&quot;, self.setPlayerStart))
-            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
-        
-        if self.onContextMenuCallback is not None:
-            self.onContextMenuCallback(actions,  menus)
-
-    def setContextMenuCallback(self, callback):
-        self.onContextMenuCallback = callback
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from DepthBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+
+
+#                &lt;zone name=&quot;Testzone&quot;&gt;
+#                        &lt;area type=&quot;sphere&quot;&gt;
+#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
+#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
+#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
+#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
+#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
+#                        &lt;/area&gt;
+#                        &lt;light name=&quot;red pointlight&quot;/&gt;
+#                        &lt;light name=&quot;green spotlight&quot;/&gt;
+#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
+#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
+#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
+#                        &lt;/trigger&gt;
+#                &lt;/zone&gt;
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i &lt; node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Light'&gt;&quot;:
+                return c
+            
+            i += 1
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = &quot;\n&quot; + level*&quot;  &quot;
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + &quot;  &quot;
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = &quot;&quot;
+    if name is None:
+        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + &quot;;&quot; + str(vec.y) + &quot;;&quot; + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = &quot;none&quot;, renderingdistance = &quot;20000&quot;):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = &quot;NotChanged&quot;
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return &quot;EntityCustomOptions&quot;
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
+        mapName = mapName.split(&quot;/&quot;)
+        mapName = mapName[len(mapName) - 1].split(&quot;.&quot;)
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + &quot;.rlmap.xml&quot;
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.isHidden = False
+        
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
+                self.parseMapNodes(root.find(&quot;nodes&quot;))
+                #self.parseMapZones(root.find(&quot;zones&quot;))
+            else:
+                print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
+                return
+
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print &quot;Error: map is already hidden!&quot;
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print &quot;Error: map is already shown!&quot;
+            return
+        
+        self.isHidden = False
+    
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
+        self.createGameObjects(nodes)
+        
+        nodes = nodeElement.getiterator(&quot;entity&quot;)
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator(&quot;light&quot;)
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator(&quot;sound&quot;)
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib[&quot;name&quot;]
+            
+            if entityName.startswith(&quot;dropMesh&quot;):
+                num = int(entityName.replace(&quot;dropMesh&quot;,  &quot;&quot;))
+                if ModuleManager.dropCount &lt; num:
+                    ModuleManager.dropCount = num
+                elif ModuleManager.dropCount &lt; num:
+                    ModuleManager.dropCount = num + 1
+                    
+            meshFile = nodes.attrib[&quot;meshfile&quot;]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib[&quot;receivesShadow&quot;] == &quot;False&quot; or nodes.attrib[&quot;receivesShadow&quot;] == &quot;false&quot;:
+                    eco.receivesShadow = &quot;False&quot;
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib[&quot;staticgeometrygroup&quot;])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib[&quot;physicsproxy&quot;]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib[&quot;renderingdistance&quot;])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib[&quot;materialName&quot;]
+            except:
+                pass
+                
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    posx = float(t.attrib[&quot;x&quot;])
+                    posy = float(t.attrib[&quot;y&quot;])
+                    posz = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                elif t.tag == &quot;scale&quot;:
+                    scalex = float(t.attrib[&quot;x&quot;])
+                    scaley = float(t.attrib[&quot;y&quot;])
+                    scalez = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
+            except:
+                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
+                return
+            
+
+            e.setUserObject(eco)
+            n = self.mapNode.createChild(&quot;entity_&quot; + entityName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib[&quot;name&quot;]
+            lightType = l.attrib[&quot;type&quot;]
+            lightVisible = bool(l.attrib[&quot;visible&quot;])
+            castShadows = bool(l.attrib[&quot;castShadows&quot;])
+            lightPosition = None
+            lightDirection = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+            
+
+                
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;colourDiffuse&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == &quot;colourSpecular&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == &quot;lightAttenuation&quot;:
+                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
+                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
+                    lightAttenuationLinear = float(t.attrib[&quot;linear&quot;])
+                    lightAttenuationQuadric  = float(t.attrib[&quot;quadratic&quot;])
+                elif t.tag == &quot;spotlightrange&quot;:
+                    spotlightinner = float(t.attrib[&quot;inner&quot;])
+                    spotlightouter = float(t.attrib[&quot;outer&quot;])
+                    falloff = float(t.attrib[&quot;falloff&quot;])
+                    
+            light = self.sceneManager.createLight(lightName)
+            
+            if lightType == &quot;point&quot;:
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == &quot;spot&quot;:
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == &quot;directional&quot;:
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
+            
+
+                
+            e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+            n = self.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+            n.attachObject(light)
+            n.attachObject(e)
+            if lightPosition:
+                n.setPosition(lightPosition)
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib[&quot;class&quot;]
+            
+            id = int(g.attrib[&quot;id&quot;])
+            if ModuleManager.dropCount &lt; id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount &lt; id:
+                ModuleManager.dropCount = id + 1
+                
+            state = g.attrib[&quot;state&quot;]
+            nodePosition = None
+            nodeRotation = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                dropNode = self.mapNode.createChild(&quot;gameobject_&quot; + &quot;dropNode&quot; + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
+                go.inWorldId = id
+                go.state = state
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element(&quot;rastullahmap&quot;)
+        root.attrib[&quot;formatVersion&quot;] = &quot;0.4.0&quot;
+        
+        nodesElem = xml.SubElement(root, &quot;nodes&quot;)
+        
+        i = 0
+        while i &lt; self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.numAttachedObjects() &gt; 0:
+                if n.name.startswith(&quot;entity_&quot;):
+                    entElem = xml.SubElement(nodesElem, &quot;entity&quot;)
+                    entElem.attrib[&quot;name&quot;] = n.getAttachedObject(0).getName()
+                    entElem.attrib[&quot;meshfile&quot;] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib[&quot;receivesShadow&quot;] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib[&quot;staticgeometrygroup&quot;] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib[&quot;physicsproxytype&quot;] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib[&quot;renderingdistance&quot;] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
+                    
+                    posElem = xml.SubElement(entElem, &quot;position&quot;)
+                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(entElem, &quot;rotation&quot;)
+                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
+                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
+                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
+                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
+                    
+                    scaleElem = xml.SubElement(entElem, &quot;scale&quot;)
+                    scaleElem.attrib[&quot;x&quot;] = str(n.getScale().x)
+                    scaleElem.attrib[&quot;y&quot;] = str(n.getScale().y)
+                    scaleElem.attrib[&quot;z&quot;] = str(n.getScale().z)
+                    
+                elif n.name.startswith(&quot;gameobject_&quot;):
+                    goElem = xml.SubElement(nodesElem, &quot;gameobject&quot;)
+                    mname = n.name
+
+                    goElem.attrib[&quot;class&quot;] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib[&quot;state&quot;] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib[&quot;id&quot;] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, &quot;position&quot;)
+                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, &quot;rotation&quot;)
+                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
+                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
+                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
+                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
+                    
+                elif n.name.startswith(&quot;light_&quot;):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    lightType = light.getType()
+                    isVisible = &quot;true&quot;
+                    if not light.getVisible():
+                        isVisible = &quot;false&quot;
+                    
+                    castShadows = &quot;false&quot;
+                    if light.getCastShadows():
+                        castShadows = &quot;true&quot;
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = &quot;point&quot;
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = &quot;spot&quot;
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = &quot;directional&quot;
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, &quot;light&quot;)
+                    lightElem.attrib[&quot;name&quot;] = lightName
+                    lightElem.attrib[&quot;type&quot;] = lightType
+                    lightElem.attrib[&quot;visible&quot;] = isVisible
+                    lightElem.attrib[&quot;castShadows&quot;] = castShadows
+                    
+                    if lightType == &quot;point&quot; or lightType == &quot;spot&quot;:
+                        posElem = xml.SubElement(lightElem, &quot;position&quot;)
+                        posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                        posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                        posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, &quot;colourDiffuse&quot;)
+                    colDiffuseElem.attrib[&quot;r&quot;] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib[&quot;g&quot;] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib[&quot;b&quot;] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, &quot;colourSpecular&quot;)
+                    colSpecularElem.attrib[&quot;r&quot;] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib[&quot;g&quot;] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib[&quot;b&quot;] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, &quot;lightAttenuation&quot;)
+                    lightAttenuationElem.attrib[&quot;range&quot;] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib[&quot;constant&quot;] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib[&quot;linear&quot;] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib[&quot;quadratic&quot;] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == &quot;spot&quot;:
+                        spotligthRangeElem = xml.SubElement(lightElem, &quot;spotlightrange&quot;)
+                        spotligthRangeElem.attrib[&quot;inner&quot;] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib[&quot;outer&quot;] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib[&quot;falloff&quot;] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == &quot;spot&quot; or lightType == &quot;directional&quot;:
+                        directionElem = xml.SubElement(lightElem, &quot;direction&quot;)
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib[&quot;x&quot;] = str(dir.x)
+                        directionElem.attrib[&quot;y&quot;] = str(dir.y)
+                        directionElem.attrib[&quot;z&quot;] = str(dir.z)
+                        
+            i = i+1
+            
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+        
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib[&quot;name&quot;]
+        
+            maps = root.getiterator(&quot;map&quot;)
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join(&quot;maps&quot;, name + &quot;.rlmap.xml&quot;))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        
+    def save(self):
+        root = xml.Element(&quot;scene&quot;)
+        root.attrib[&quot;name&quot;] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, &quot;map&quot;)
+            sub.attrib[&quot;file&quot;] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+        
+        self.playerStart = None
+        
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print &quot;ERROR: could not find scene: &quot; + sceneName
+        
+    
+    def isCommon(self):
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Module.isCommon() Error: couldn't find module config&quot;)
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;super(&quot;):
+                split = lStripped.split(&quot;,&quot;)
+                if split[2].strip() == unicode(&quot;true&quot;):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == &quot;end&quot;:
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    pl = lStripped.split('&quot;')
+                    i = 1
+                    while i &lt; 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
+
+            elif lStripped == &quot;def getDependencies()&quot;:
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Module.load: Error: couldn't find module config&quot;)
+            return
+
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;hero = $GOM.getGameObject(&quot;):
+                try:
+                    self.playerStart = int(line.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0])
+                except ValueError, e:
+                    print self.modConfig + &quot; ValueError: &quot; + str(e)
+                    self.playerStart = None
+                    continue
+                    
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        
+        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+            
+        
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+            
+        self.saveModuleConfig()
+
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, &quot;r&quot;)
+            
+            newconfig = &quot;&quot;
+            for line in f:
+                if line.startswith(&quot;       hero = $GOM.getGameObject(&quot;):
+                    newconfig += &quot;       hero = $GOM.getGameObject(&quot; + str(self.playerStart) + &quot;);\n&quot;
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, &quot;w&quot;)
+            f.write(newconfig)
+            f.close()
+
+    def setResourcePaths(self, recurseFolder = &quot;&quot;):
+        if recurseFolder == &quot;&quot;:
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            elif os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
+                self.setResourcePaths(curFile)
+            elif os.path.isfile(curFile):
+                continue
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+                            
+class ModuleManager():
+    dropCount = 0
+    entityCustomOptionsDict = []
+    
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+        self.materialSelectionDialog = None
+
+        self.moduleCfgPath = &quot;&quot;
+
+        self.gocManager = GameObjectClassManager()
+        
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+       
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+        self.dropMat = None
+        
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.depthBuffer = None
+        self.propertyWindow = None
+    
+        self.oneClickEntityPlacement = False
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
+
+        self.moduleConfigIsParsed = True
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
+        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                
+#        self.moduleExplorer.updateView()
+#        ModuleManager.dropCount += 1
+#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+#        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
+#        e.setMaterialName(&quot;DepthMap&quot;)
+#
+#        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
+#        e2.setMaterialName(&quot;PlainColor&quot;)
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
+#        n.attachObject(e)
+#        n.attachObject(e2)
+#        n.setScale(og.Vector3(10, 5, 20))
+        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
+
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        if self.currentMap is None:
+            print &quot;Don't forget to select a map&quot;
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        if self.oneClickEntityPlacement:
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                return
+            else:
+                print &quot;Warning: OneClickEntityPlacement still runed on without any selected mesh!&quot;
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:
+                self.propertyWindow.showProperties(so)
+                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            self.propertyWindow.clear()
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+#
+#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            node = so.entity.getParentNode()
+
+            if node.getName().startswith(&quot;light_&quot;):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
+            node.detachAllObjects()
+            self.sceneManager.destroySceneNode(node)
+            self.sceneManager.destroyEntity(so.entity)
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = &quot;&quot;
+        split = name.split(&quot;_&quot;)
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + &quot;_1&quot;
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) &lt; 1 or self.currentMap is None:
+            print &quot;Warning: No map selected!&quot;
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if str(so.entity.getParentNode().getName()).startswith(&quot;gameobject_&quot;):
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gocManager.addGameObjectRepresentation(newGO)
+                        newEntity.setUserObject(newGO)
+                        #newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith(&quot;entity_&quot;):
+                    nodeName = &quot;entity_dropNode&quot; + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
+
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
+
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
+
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith(&quot;light_&quot;):
+                    print &quot;Can't copy lights yet :)&quot;
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) &lt; 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.moduleExplorer.updateView()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
+            dropEntity.setUserObject(self.dropGO)
+
+        ModuleManager.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def finishDropGameObjectAction(self, ray):
+        self.dropGO = None
+        return
+
+    def startDropModelAction(self, meshFile, ray):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
+        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(ModuleManager.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        ModuleManager.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+    
+    def finishDropModelAction(self, ray):
+        return
+
+    def startDropMaterialAction(self, text):
+        self.dropMat = text
+        
+    def moveDropMaterialAction(self, event):
+        return
+
+    def finishDropMaterialAction(self, screenX, screenY):
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        if so is not None:
+            if not so.entity.getNumSubEntities() &gt; 1:
+                so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
+            else:
+                i = 0
+                text = &quot;Warning this Entity has more than one SubEntities with the folloing materials: \n\n&quot;
+                while i &lt; so.entity.getNumSubEntities():
+                    text += &quot;SubMesh&quot; + str(i) + &quot;:  &quot; + so.entity.getSubEntity(i).getMaterialName() + &quot;\n&quot;
+                    i += 1
+                
+                text += &quot;\n Replace the materials?&quot;
+                reply = QMessageBox.question(None, &quot;Warning: multiple materials&quot;,  text,  QMessageBox.Yes|QMessageBox.No)
+                if reply == QMessageBox.Cancel:
+                    return
+                if reply == QMessageBox.Yes:
+                    so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
+        
+    def setOneClickEntityPlacement(self, state):
+        self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist &lt; 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+#        so = self.selectionBuffer.onSelectionClick(int(self.contextMenuClickPosition.x), int(self.contextMenuClickPosition.y))
+#        if so is not None:
+#            result = og.Math.intersects(self.contextMenuRay, so.entity.getBoundingBox())
+#            
+#            if result.first:
+#                pos = self.contextMenuRay.getPoint(result.second)
+#                pos += so.entity.getParentNode().getPosition()
+        
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        lightName = &quot;pointLight&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print &quot;Error while creating light&quot;
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        lightName = &quot;spotLight&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print &quot;Error while creating light&quot;
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        
+    def createZone(self):
+        print &quot;creating zone here...&quot;
+    
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print &quot;setting Player Start to &quot; + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        actions.append(self.createAction(&quot;Create Zone here&quot;, self.createZone))
+        pla = self.createAction(&quot;Pointlight&quot;, self.addPointLight, None, &quot;idea.png&quot;)
+        pls = self.createAction(&quot;Spotlight&quot;, self.addSpotLight, None, &quot;idea.png&quot;)
+        
+        lightMenu = QMenu(&quot;Add Light&quot;)
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        if so is not None and so.entity.getParentNode().getName().startswith(&quot;gameobject_&quot;):
+            actions.append(self.createAction(&quot;Set Player Starterpoint&quot;, self.setPlayerStart))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+        
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action

Modified: rl/trunk/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MovePivot.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/MovePivot.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Modified: rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 import ctypes
 import ogre.renderer.OGRE as og

Modified: rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,173 +1,189 @@
-# -*- coding: utf-8 -*-
-
-&quot;&quot;&quot;
-Module implementing NewModuleWizard.
-&quot;&quot;&quot;
-
-import os
-import glob
-
-from PyQt4.QtGui import QDialog
-from PyQt4.QtCore import pyqtSignature
-
-from Ui_NewModuleWizard import Ui_Dialog
-
-class NewModuleWizard(QDialog, Ui_Dialog):
-    &quot;&quot;&quot;
-    Class documentation goes here.
-    &quot;&quot;&quot;
-    def __init__(self, moduleManager, parent = None):
-       
-        QDialog.__init__(self, parent)
-        self.setupUi(self)
-
-        self.moduleManager = moduleManager
-        self.moduleManager.parseModuleConfig()
-        
-        for m in self.moduleManager.moduleList:
-            self.moduleDependenciesList.addItem(m.name)
-
-    @pyqtSignature(&quot;QString&quot;)
-    def on_moduleNameLineEdit_textChanged(self, p0):
-        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
-            self.sceneNameLineEdit.setEnabled(True)
-            self.mapNameLineEdit.setEnabled(True)
-            self.moduleDependenciesList.setEnabled(True)
-            self.scriptDependenciesList.setEnabled(True)
-            self.okButton.setEnabled(True)
-        else:
-            self.sceneNameLineEdit.setEnabled(False)
-            self.mapNameLineEdit.setEnabled(False)
-            self.moduleDependenciesList.setEnabled(False)
-            self.scriptDependenciesList.setEnabled(False)
-            self.okButton.setEnabled(False)
-    
-    def scanDirForScripts(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                self.scanDirForScripts(curFile)
-                continue
-            if os.path.isfile(curFile):
-                if file.endswith(&quot;.rb&quot;):
-                    self.scriptDependenciesList.addItem(dir + &quot;/&quot; + file)
-    
-    @pyqtSignature(&quot;&quot;)
-    def on_moduleDependenciesList_itemSelectionChanged(self):
-        self.scriptDependenciesList.clear()
-        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
-        
-        for m in self.moduleDependenciesList.selectedItems():
-            path = os.path.join(modulePath, str(m.text()))
-            cmd = os.path.join(path + &quot;/scripts&quot;)
-            self.scanDirForScripts(cmd)
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_moduleNameLineEdit_returnPressed(self):
-        return
-            
-    @pyqtSignature(&quot;&quot;)
-    def on_mapNameLineEdit_returnPressed(self):
-        return
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_okButton_clicked(self):
-        f = open(self.moduleManager.moduleCfgPath, &quot;a&quot;)
-        f.write(&quot;module=&quot; + str(self.moduleNameLineEdit.text()) + &quot;\n&quot;)
-        f.close()
-        
-        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
-        modulePath = str(modulePath + self.moduleNameLineEdit.text())
-        os.mkdir(modulePath)
-        os.mkdir(os.path.join(modulePath, &quot;dialogs&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;dsa&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;gui&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;maps&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;materials&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;materials/textures&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;models&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;quests&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;scripts&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;scripts/maps&quot;))
-        os.mkdir(os.path.join(modulePath, &quot;sound&quot;))
-        
-        mname = str(self.moduleNameLineEdit.text())
-        mdeps = &quot;&quot;
-        for m in self.moduleDependenciesList.selectedItems():
-            mdeps = mdeps + str(&quot;\&quot;&quot; + m.text() + &quot;\&quot;, &quot;)
-        mdeps = mdeps.strip(&quot;, &quot;)
-        
-        sdeps = &quot;&quot;
-        for s in self.scriptDependenciesList.selectedItems():
-            script = str(str(s.text()).replace(&quot;\\&quot;, &quot;/&quot;))
-            script = script.split(&quot;/&quot;)
-            script = script[len(script) - 1]
-            sdeps = sdeps + str(&quot;       require &quot; + script + &quot;\n&quot;)
-        
-        p = os.path.join(modulePath, &quot;scripts&quot;)
-        p = os.path.join(p, &quot;moduleconfig.rb&quot;)
-        f = open(p, &quot;w&quot;)
-        f.write(&quot;include RlScript\n&quot;)
-        f.write(&quot;\n\n&quot;)
-        f.write(&quot;class &quot; + mname.capitalize() + &quot;Module &lt; ContentModule\n&quot;)
-        f.write(&quot;    def initialize()\n&quot;)
-        f.write(&quot;        super(\&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, \&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, false, 200608012)\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getDependencies()\n&quot;)
-        f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getTextureLocations()\n&quot;)
-        f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getModelLocations()\n&quot;)
-        f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getSoundLocations()\n&quot;)
-        f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
-        f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def start()\n&quot;)
-        f.write(sdeps + &quot;\n&quot;)
-        f.write(&quot;       require 'player.rb'\n&quot;)
-        f.write(&quot;       require 'mckhero.rb'\n&quot;)
-        f.write(&quot;       $PM.setEnabled(true);\n\n&quot;)
-        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n\n&quot;)
-        f.write(&quot;       hero = $GOM.getGameObject(XXXXXX);\n&quot;)
-        f.write(&quot;       PlayerSettings.preparePlayer(hero)\n&quot;)
-        f.write(&quot;       PartyManager.getSingleton().setActiveCharacter(hero)\n\n&quot;)
-        f.write(&quot;    end\n&quot;)
-        f.write(&quot;end\n\n&quot;)
-        f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
-        f.close()
-        
-        
-        
-        p = os.path.join(modulePath, &quot;maps&quot;)
-        p = os.path.join(p, str(self.sceneNameLineEdit.text()) + &quot;.rlscene&quot;)
-        
-        f = open(p, &quot;w&quot;)
-        f.write(&quot;&lt;scene name=\&quot;&quot; + str(self.sceneNameLineEdit.text()) + &quot;\&quot;&gt;\n&quot;)
-        f.write(&quot;    &lt;map file=\&quot;&quot; + str(self.mapNameLineEdit.text()) + &quot;.rlmap.xml\&quot;&quot; +  &quot;/&gt;\n&quot;)
-        f.write(&quot;&lt;/scene&gt;\n&quot;)
-        f.close()
-        
-        p = os.path.join(modulePath, &quot;maps&quot;)
-        p = os.path.join(p, str(self.mapNameLineEdit.text()) + &quot;.rlmap.xml&quot;)
-        
-        f = open(p, &quot;w&quot;)
-        f.write(&quot;&lt;rastullahmap formatVersion=\&quot;0.4.0\&quot;&gt;\n&quot;)
-        f.write(&quot;    &lt;nodes&gt;\n&quot;)
-        f.write(&quot;    &lt;/nodes&gt;\n&quot;)
-        f.write(&quot;&lt;/rastullahmap&gt;\n&quot;)
-        f.close()
-        
-        self.moduleManager.resetParsedModuleConfig()
-        self.moduleManager.openLoadModuleDialog()
-        
-    @pyqtSignature(&quot;&quot;)
-    def on_cancelButton_pressed(self):
-        self.close()
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+&quot;&quot;&quot;
+Module implementing NewModuleWizard.
+&quot;&quot;&quot;
+
+import os
+import glob
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_NewModuleWizard import Ui_Dialog
+
+class NewModuleWizard(QDialog, Ui_Dialog):
+    &quot;&quot;&quot;
+    Class documentation goes here.
+    &quot;&quot;&quot;
+    def __init__(self, moduleManager, parent = None):
+       
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+
+        self.moduleManager = moduleManager
+        self.moduleManager.parseModuleConfig()
+        
+        for m in self.moduleManager.moduleList:
+            self.moduleDependenciesList.addItem(m.name)
+
+    @pyqtSignature(&quot;QString&quot;)
+    def on_moduleNameLineEdit_textChanged(self, p0):
+        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
+            self.sceneNameLineEdit.setEnabled(True)
+            self.mapNameLineEdit.setEnabled(True)
+            self.moduleDependenciesList.setEnabled(True)
+            self.scriptDependenciesList.setEnabled(True)
+            self.okButton.setEnabled(True)
+        else:
+            self.sceneNameLineEdit.setEnabled(False)
+            self.mapNameLineEdit.setEnabled(False)
+            self.moduleDependenciesList.setEnabled(False)
+            self.scriptDependenciesList.setEnabled(False)
+            self.okButton.setEnabled(False)
+    
+    def scanDirForScripts(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                self.scanDirForScripts(curFile)
+                continue
+            if os.path.isfile(curFile):
+                if file.endswith(&quot;.rb&quot;):
+                    self.scriptDependenciesList.addItem(dir + &quot;/&quot; + file)
+    
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleDependenciesList_itemSelectionChanged(self):
+        self.scriptDependenciesList.clear()
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        
+        for m in self.moduleDependenciesList.selectedItems():
+            path = os.path.join(modulePath, str(m.text()))
+            cmd = os.path.join(path + &quot;/scripts&quot;)
+            self.scanDirForScripts(cmd)
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleNameLineEdit_returnPressed(self):
+        return
+            
+    @pyqtSignature(&quot;&quot;)
+    def on_mapNameLineEdit_returnPressed(self):
+        return
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_okButton_clicked(self):
+        f = open(self.moduleManager.moduleCfgPath, &quot;a&quot;)
+        f.write(&quot;module=&quot; + str(self.moduleNameLineEdit.text()) + &quot;\n&quot;)
+        f.close()
+        
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        modulePath = str(modulePath + self.moduleNameLineEdit.text())
+        os.mkdir(modulePath)
+        os.mkdir(os.path.join(modulePath, &quot;dialogs&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;dsa&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;gui&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials/textures&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;models&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;quests&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts/maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;sound&quot;))
+        
+        mname = str(self.moduleNameLineEdit.text())
+        mdeps = &quot;&quot;
+        for m in self.moduleDependenciesList.selectedItems():
+            mdeps = mdeps + str(&quot;\&quot;&quot; + m.text() + &quot;\&quot;, &quot;)
+        mdeps = mdeps.strip(&quot;, &quot;)
+        
+        sdeps = &quot;&quot;
+        for s in self.scriptDependenciesList.selectedItems():
+            script = str(str(s.text()).replace(&quot;\\&quot;, &quot;/&quot;))
+            script = script.split(&quot;/&quot;)
+            script = script[len(script) - 1]
+            sdeps = sdeps + str(&quot;       require &quot; + script + &quot;\n&quot;)
+        
+        p = os.path.join(modulePath, &quot;scripts&quot;)
+        p = os.path.join(p, &quot;moduleconfig.rb&quot;)
+        f = open(p, &quot;w&quot;)
+        f.write(&quot;include RlScript\n&quot;)
+        f.write(&quot;\n\n&quot;)
+        f.write(&quot;class &quot; + mname.capitalize() + &quot;Module &lt; ContentModule\n&quot;)
+        f.write(&quot;    def initialize()\n&quot;)
+        f.write(&quot;        super(\&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, \&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, false, 200608012)\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getDependencies()\n&quot;)
+        f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getTextureLocations()\n&quot;)
+        f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getModelLocations()\n&quot;)
+        f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getSoundLocations()\n&quot;)
+        f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def start()\n&quot;)
+        f.write(sdeps + &quot;\n&quot;)
+        f.write(&quot;       require 'player.rb'\n&quot;)
+        f.write(&quot;       require 'mckhero.rb'\n&quot;)
+        f.write(&quot;       $PM.setEnabled(true);\n\n&quot;)
+        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n\n&quot;)
+        f.write(&quot;       hero = $GOM.getGameObject(XXXXXX);\n&quot;)
+        f.write(&quot;       PlayerSettings.preparePlayer(hero)\n&quot;)
+        f.write(&quot;       PartyManager.getSingleton().setActiveCharacter(hero)\n\n&quot;)
+        f.write(&quot;    end\n&quot;)
+        f.write(&quot;end\n\n&quot;)
+        f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
+        f.close()
+        
+        
+        
+        p = os.path.join(modulePath, &quot;maps&quot;)
+        p = os.path.join(p, str(self.sceneNameLineEdit.text()) + &quot;.rlscene&quot;)
+        
+        f = open(p, &quot;w&quot;)
+        f.write(&quot;&lt;scene name=\&quot;&quot; + str(self.sceneNameLineEdit.text()) + &quot;\&quot;&gt;\n&quot;)
+        f.write(&quot;    &lt;map file=\&quot;&quot; + str(self.mapNameLineEdit.text()) + &quot;.rlmap.xml\&quot;&quot; +  &quot;/&gt;\n&quot;)
+        f.write(&quot;&lt;/scene&gt;\n&quot;)
+        f.close()
+        
+        p = os.path.join(modulePath, &quot;maps&quot;)
+        p = os.path.join(p, str(self.mapNameLineEdit.text()) + &quot;.rlmap.xml&quot;)
+        
+        f = open(p, &quot;w&quot;)
+        f.write(&quot;&lt;rastullahmap formatVersion=\&quot;0.4.0\&quot;&gt;\n&quot;)
+        f.write(&quot;    &lt;nodes&gt;\n&quot;)
+        f.write(&quot;    &lt;/nodes&gt;\n&quot;)
+        f.write(&quot;&lt;/rastullahmap&gt;\n&quot;)
+        f.close()
+        
+        self.moduleManager.resetParsedModuleConfig()
+        self.moduleManager.openLoadModuleDialog()
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_cancelButton_pressed(self):
+        self.close()
+
+

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 import sys
 

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,564 +1,565 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-import ogre.renderer.OGRE as og
-
-from Property import *
-import ModuleManager
-
-class BoolEditor(QDialog):
-    def __init__(self, currentSelectedText, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
-        
-        layout = QVBoxLayout()
-        layout.setContentsMargins(0, 0, 0, 0)
-        
-        currentSelected = False
-        if currentSelectedText == &quot;True&quot; or currentSelectedText == &quot;true&quot;:
-            currentSelected = True
-        
-        self.combo = QComboBox()
-        self.combo.addItem(&quot;True&quot;)
-        self.combo.addItem(&quot;False&quot;)
-        
-        if not currentSelected:
-            self.combo.setCurrentIndex(1)
-        
-        layout.addWidget(self.combo)
-        self.setLayout(layout)
-        
-        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
-    
-    def getValue(self):
-        ret = True
-        if str(self.combo.currentText()) == &quot;False&quot;:
-            ret = False
-        
-        return ret
-    
-class GameObjectStateEditor(QDialog):
-    def __init__(self, currentSelectedText, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
-        
-        layout = QVBoxLayout()
-        layout.setContentsMargins(0, 0, 0, 0)
-        
-        self.combo = QComboBox()
-        self.combo.addItem(&quot;IN_SCENE&quot;)
-        self.combo.addItem(&quot;LOADED&quot;)
-        self.combo.addItem(&quot;HELD&quot;)
-        self.combo.addItem(&quot;IN_POSSESSION&quot;)
-        self.combo.addItem(&quot;READIED&quot;)
-
-        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
-        
-
-        layout.addWidget(self.combo)
-        self.setLayout(layout)
-        
-        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
-    
-    def getValue(self):
-        return str(self.combo.currentText())
-        
-class EntityPhysicsProxyEditor(QDialog):
-    def __init__(self, currentSelectedText, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
-        
-        layout = QVBoxLayout()
-        layout.setContentsMargins(0, 0, 0, 0)
-        
-        self.combo = QComboBox()
-        self.combo.addItem(&quot;none&quot;)
-        self.combo.addItem(&quot;box&quot;)
-        self.combo.addItem(&quot;sphere&quot;)
-        self.combo.addItem(&quot;ellipsoid&quot;)
-        self.combo.addItem(&quot;pyramid&quot;)
-        self.combo.addItem(&quot;mesh&quot;)
-        self.combo.addItem(&quot;convexhull&quot;)
-        self.combo.addItem(&quot;custom - Not supported by editor yet!&quot;)
-
-        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
-        
-        layout.addWidget(self.combo)
-        self.setLayout(layout)
-        
-        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
-    
-    def getValue(self):
-        return str(self.combo.currentText())
-    
-class ObjectPropertyWin(QDialog):
-    def __init__(self, sceneManager, gocManager, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setupUi()
-        self.sceneManager = sceneManager
-        self.valueBeforeEdit = None
-        self.gocManager = gocManager
-        
-        self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
-                               self.onItemClicked)
-        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
-                               self.onItemChanged)
-
-    def setupUi(self):
-        self.setObjectName(&quot;ObjectPropertys&quot;)
-        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
-
-        self.treeWidget = QTreeWidget(self)
-        self.treeWidget.setGeometry(QRect(0,0,901,721))
-        self.treeWidget.setMinimumSize(QSize(400,400))
-        self.treeWidget.setObjectName(&quot;treeWidget&quot;)
-        self.treeWidget.setAlternatingRowColors(True)
-        self.treeWidget.setAnimated(True)
-        
-        self.retranslateUi()
-        QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.treeWidget.headerItem().setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Property&quot;, None, QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(1,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Value&quot;, None, QApplication.UnicodeUTF8))
-        self.treeWidget.clear()
-
-
-    def onItemClicked(self, item, column):
-        if column == 1:
-            self.valueBeforeEdit = str(item.text(column))
-            
-            if item.text(0) == &quot;State&quot;:
-                ed = GameObjectStateEditor(item.text(column), self)
-                ed.exec_()
-                item.setText(column, ed.getValue())
-                self.node.getAttachedObject(0).getUserObject().state = ed.getValue()
-                
-            elif item.text(0) == &quot;Receives Shadows&quot;:
-                bedit = BoolEditor(item.text(column), self)
-                bedit.exec_()
-                item.setText(column, bedit.getValue())
-                self.node.getAttachedObject(0).getUserObject().receivesShadow = str(bedit.getValue())
-            elif item.text(0) == &quot;Physics Proxy Type&quot;:
-                bedit = EntityPhysicsProxyEditor(item.text(column), self)
-                bedit.exec_()
-                item.setText(column, bedit.getValue())
-                self.node.getAttachedObject(0).getUserObject().physicsproxytype = bedit.getValue()
-            elif item.text(0) == &quot;Visibility&quot;:
-                bedit = BoolEditor(item.text(column), self)
-                bedit.exec_()
-                item.setText(column, str(bedit.getValue()))
-                ModuleManager.extractLight(self.node).setVisible(bedit.getValue())
-            elif item.text(0) == &quot;CastShadows&quot;:
-                bedit = BoolEditor(item.text(column), self)
-                bedit.exec_()
-                item.setText(column, str(bedit.getValue()))
-                ModuleManager.extractLight(self.node).setCastShadows(bedit.getValue())
-            elif item.text(0) == &quot;Diffuse Color&quot;:
-                min = 1.0 / 255.0
-                col = ModuleManager.extractLight(self.node).getDiffuseColour()
-                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
-                ModuleManager.extractLight(self.node).setDiffuseColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
-                self.showProperties(self.so)
-            elif item.text(0) == &quot;Specular Color&quot;:
-                min = 1.0 / 255.0
-                col = ModuleManager.extractLight(self.node).getSpecularColour()
-                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
-                ModuleManager.extractLight(self.node).setSpecularColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
-                self.showProperties(self.so)
-
-            else:
-                self.treeWidget.editItem(item, column)
-
-    def onItemChanged(self, item, column):
-        if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
-            parent = item.parent()
-            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
-                if item.text(0) == &quot;Name&quot;:
-                    if self.node.getName().startswith(&quot;entity_&quot;):
-                        if not self.sceneManager.hasEntity(str(item.text(column))):
-                            newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
-                            oldEnt = self.node.getAttachedObject(0)
-                            self.node.detachObject(oldEnt)
-                            self.sceneManager.destroyEntity(oldEnt)
-                            self.node.attachObject(newEnt)
-                            
-                            # update the selection object since it still has references to the deleted entity
-                            self.so.entity = newEnt
-                            self.so.entityName = newEnt.getName()
-                        else:
-                            item.setText(column, self.valueBeforeEdit)
-                            print &quot;Error: Name already exists!&quot;
-                            
-                    elif self.node.getName().startswith(&quot;light_&quot;):
-                        if not self.sceneManager.hasLight(str(item.text(column))):
-                            newLight = self.sceneManager.createLight(str(item.text(column)))
-                            oldLight = ModuleManager.extractLight(self.node)
-                            self.node.detachObject(oldLight)
-                            self.node.attachObject(newLight)
-                            newLight.setType(oldLight.getType())
-                            newLight.setVisibilityFlags(newLight.getVisibilityFlags())
-                            newLight.setCastShadows(oldLight.getCastShadows())
-                            newLight.setDiffuseColour(oldLight.getDiffuseColour())
-                            newLight.setSpecularColour(oldLight.getSpecularColour())
-                            newLight.setAttenuation(oldLight.getAttenuationRange(), oldLight.getAttenuationConstant(), oldLight.getAttenuationLinear(), oldLight.getAttenuationQuadric())
-                            if newLight.getType() == og.Light.LT_SPOTLIGHT:
-                                newLight.setSpotlightRange(oldLight.getSpotlightInnerAngle(), oldLight.getSpotlightOuterAngle(), oldLight.getSpotlightFalloff())
-                            if newLight.getType() == og.Light.LT_SPOTLIGHT or newLight.getType() == og.Light.LT_DIRECTIONAL:
-                                newLight.setDirection(oldLight.getDirection())
-                                
-                            self.sceneManager.destroyLight(oldLight)
-                        else:
-                            item.setText(column, self.valueBeforeEdit)
-                            print &quot;Error: Name already exists!&quot;
-                            
-                elif item.text(0) == &quot;GameObject Id&quot;:
-                    if not self.gocManager.inWorldIdExists(str(item.text(column))):
-                        val = None
-                        try:
-                            val = int(item.text(1))
-                        except ValueError, e:
-                            item.setText(column, self.valueBeforeEdit)
-                            print &quot;ValueError: &quot; + str(e)
-                            return
-                            
-                        self.node.getAttachedObject(0).getUserObject().inWorldId = str(val)
-                    else:
-                        item.setText(column, self.valueBeforeEdit)
-                        print &quot;Error: Id exists already!&quot;
-                elif item.text(0) == &quot;Static Geometry Group&quot;:                        
-                    val = None
-                    try:
-                        val = int(item.text(1))
-                    except ValueError, e:
-                        item.setText(column, self.valueBeforeEdit)
-                        print &quot;ValueError: &quot; + str(e)
-                        return
-                elif item.text(0) == &quot;Rendering Distance&quot;:                        
-                    val = None
-                    try:
-                        val = float(item.text(1))
-                    except ValueError, e:
-                        item.setText(column, self.valueBeforeEdit)
-                        print &quot;ValueError: &quot; + str(e)
-                        return
-                    
-                    self.node.getAttachedObject(0).getUserObject().renderingdistance = val
-            else:
-                val = None
-                try:
-                    val = float(item.text(1))
-                except ValueError, e:
-                    item.setText(column, self.valueBeforeEdit)
-                    print &quot;ValueError: &quot; + str(e)
-                    return
-                    
-                if parent.text(0) == &quot;Position&quot;:
-                    if item.text(0) == &quot;X&quot;:
-                        self.node.setPosition(val, self.node.getPosition().y, self.node.getPosition().z)
-                    elif item.text(0) == &quot;Y&quot;:
-                        self.node.setPosition(self.node.getPosition().x, val, self.node.getPosition().z)
-                    elif item.text(0) == &quot;Z&quot;:
-                        self.node.setPosition(self.node.getPosition().x, self.node.getPosition().y, val)
-                elif parent.text(0) == &quot;Orientation&quot;:
-                    if item.text(0) == &quot;W&quot;:
-                        self.node.setOrientation(val, self.node.getOrientation().x, self.node.getOrientation().y, self.node.getOrientation().z)
-                    elif item.text(0) == &quot;X&quot;:
-                        self.node.setOrientation(self.node.getOrientation().w, val, self.node.getOrientation().y, self.node.getOrientation().z)
-                    elif item.text(0) == &quot;Y&quot;:
-                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, val, self.node.getOrientation().z)
-                    elif item.text(0) == &quot;Z&quot;:
-                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, self.node.getOrientation().y, val)
-                elif parent.text(0) == &quot;Scale&quot;:
-                    if item.text(0) == &quot;X&quot;:
-                        self.node.setScale(val, self.node.getScale().y, self.node.getScale().z)
-                    elif item.text(0) == &quot;Y&quot;:
-                        self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
-                    elif item.text(0) == &quot;Z&quot;:
-                        self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
-                elif parent.text(0) == &quot;Attenuation&quot;:
-                    light = ModuleManager.extractLight(self.node)
-                    if item.text(0) == &quot;range&quot;:
-                        light.setAttenuation(val, light.getAttenuationConstant(), light.getAttenuationLinear(), light.getAttenuationQuadric())
-                    elif item.text(0) == &quot;constant&quot;:
-                        light.setAttenuation(light.getAttenuationRange(), val, light.getAttenuationLinear(), light.getAttenuationQuadric())
-                    elif item.text(0) == &quot;linear&quot;:
-                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), val, light.getAttenuationQuadric())
-                    elif item.text(0) == &quot;quadratic&quot;:
-                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), light.getAttenuationLinear(), val)
-                elif parent.text(0) == &quot;Spotlightrange&quot;:
-                    light = ModuleManager.extractLight(self.node)
-                    if item.text(0) == &quot;inner&quot;:
-                        light.setSpotlightInnerAngle(og.Degree(val))
-                    elif item.text(0) == &quot;outer&quot;:
-                        light.setSpotlightOuterAngle(og.Degree(val))
-                    elif item.text(0) == &quot;falloff&quot;:                      
-                      light.setSpotlightFalloff(val)
-                        
-    def showProperties(self, so):
-        # onItemChanged should only be called when the user changes values not when they change by code
-        self.disconnect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
-                       self.onItemChanged)
-                       
-        self.so=so
-        self.treeWidget.clear()
-        
-        name = so.entity.getParentNode().getName()
-        self.node = so.entity.getParentNode()
-        
-        if name.startswith(&quot;entity_&quot;):
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Name&quot;)
-            n = self.node.getAttachedObject(0).getName()
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            itemMat = QTreeWidgetItem(self.treeWidget)
-            itemMat.setText(0, &quot;Materials&quot;)
-            
-            i = 0
-            while i &lt; self.node.getAttachedObject(0).getNumSubEntities():
-                it = QTreeWidgetItem(itemMat)
-                it.setFlags(item.flags() | Qt.ItemIsEditable)
-                it.setText(0, &quot;SubMesh&quot; + str(i))
-                it.setText(1, self.node.getAttachedObject(0).getSubEntity(i).getMaterialName())
-                i += 1
-                
-                        
-            self.parsePosition(self.node)
-            self.parseOrientation(self.node)
-            self.parseScale(self.node)
-            self.parseEntityOptions(self.node)
-            
-        elif name.startswith(&quot;gameobject_&quot;):
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;ClassName&quot;)
-            n = str(self.node.getAttachedObject(0).getUserObject().gocName)
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;GameObject Id&quot;)
-            n = str(self.node.getAttachedObject(0).getUserObject().inWorldId)
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;State&quot;)
-            n = str(self.node.getAttachedObject(0).getUserObject().state)
-            item.setText(1, n)            
-            
-            self.parsePosition(self.node)
-            self.parseOrientation(self.node)
-            self.parseScale(self.node)
-            
-        elif name.startswith(&quot;light_&quot;):
-            item = QTreeWidgetItem(self.treeWidget)
-            light = ModuleManager.extractLight(self.node)
-            n = light.getName()
-            item.setText(0, &quot;Name&quot;)
-            item.setText(1, n)
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Type&quot;)
-            if light.getType() == og.Light.LT_POINT:
-                item.setText(1, &quot;point&quot;)
-            elif light.getType() == og.Light.LT_SPOTLIGHT:
-                item.setText(1, &quot;spot&quot;)
-            elif light.getType() == og.Light.LT_DIRECTIONAL:
-                item.setText(1, &quot;directional&quot;)
-
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Visibility&quot;)
-            item.setText(1, str(light.getVisible()))
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;CastShadows&quot;)
-            item.setText(1, str(light.getCastShadows()))
-            
-            if light.getType() == og.Light.LT_POINT or light.getType() == og.Light.LT_SPOTLIGHT:
-                self.parsePosition(self.node)
-            if light.getType() == og.Light.LT_SPOTLIGHT:
-                self.parseSpotLightProperties(self.node)
-                
-            self.parseDiffuseColor(self.node)
-            self.parseSpecularColor(self.node)
-            self.parseLightAttenuation(self.node)
-
-       
-        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
-                       self.onItemChanged)
-                       
-    
-    def parseDiffuseColor(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Diffuse Color&quot;)
-        color = ModuleManager.extractLight(self.node).getDiffuseColour()
-        item.setText(1, str(int(255 * color.r)) + &quot;; &quot; + str(int(255 * color.g)) + &quot;; &quot; + str(int(255 * color.b)))
-        
-    def parseSpecularColor(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Specular Color&quot;)
-        color = ModuleManager.extractLight(self.node).getSpecularColour()
-        item.setText(1, str(int(255 * color.r)) + &quot;; &quot; + str(int(255 * color.g)) + &quot;; &quot; + str(int(255 * color.b)))
-        
-    def parseLightAttenuation(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Attenuation&quot;)
-        light = ModuleManager.extractLight(self.node)
-        
-        range = QTreeWidgetItem(item)
-        range.setText(0, &quot;range&quot;)
-        range.setText(1, str(light.getAttenuationRange()))
-        range.setFlags(range.flags() | Qt.ItemIsEditable)
-        
-        constant = QTreeWidgetItem(item)
-        constant.setText(0, &quot;constant&quot;)
-        constant.setText(1,  str(light.getAttenuationConstant()))
-        constant.setFlags(constant.flags() | Qt.ItemIsEditable)
-        
-        linear = QTreeWidgetItem(item)
-        linear.setText(0, &quot;linear&quot;)
-        linear.setText(1, str(light.getAttenuationLinear()))
-        linear.setFlags(linear.flags() | Qt.ItemIsEditable)
-        
-        quadratic = QTreeWidgetItem(item)
-        quadratic.setText(0, &quot;quadratic&quot;)
-        quadratic.setText(1, str(light.getAttenuationQuadric()))
-        quadratic.setFlags(quadratic.flags() | Qt.ItemIsEditable)
-    
-    def parseSpotLightProperties(self,  node):
-        light = ModuleManager.extractLight(self.node)
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Spotlightrange&quot;)
-
-        inner = QTreeWidgetItem(item)
-        inner.setText(0, &quot;inner&quot;)
-        inner.setText(1, str(light.getSpotlightInnerAngle().valueDegrees()))
-        inner.setFlags(inner.flags() | Qt.ItemIsEditable)
-        
-        outer = QTreeWidgetItem(item)
-        outer.setText(0, &quot;outer&quot;)
-        outer.setText(1, str(light.getSpotlightOuterAngle().valueDegrees()))
-        outer.setFlags(outer.flags() | Qt.ItemIsEditable)
-        
-        falloff = QTreeWidgetItem(item)
-        falloff.setText(0, &quot;falloff&quot;)
-        falloff.setText(1, str(light.getSpotlightFalloff()))
-        falloff.setFlags(falloff.flags() | Qt.ItemIsEditable)
-
-    def parsePosition(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Position&quot;)
-        item.setText(1, str(node.getPosition().x) + &quot;; &quot; + str(node.getPosition().y) + &quot;; &quot; + str(node.getPosition().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getPosition().x))
-        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getPosition().y))
-        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getPosition().z))
-        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
-        
-    def parseOrientation(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Orientation&quot;)
-        item.setText(1, str(node.getOrientation().w) + &quot;; &quot; + str(node.getOrientation().x) + &quot;; &quot; + str(node.getOrientation().y) + &quot;; &quot; + str(node.getOrientation().z))
-        
-        itemW = QTreeWidgetItem(item)
-        itemW.setText(0, &quot;W&quot;)
-        itemW.setText(1, str(node.getOrientation().w))
-        itemW.setFlags(itemW.flags() | Qt.ItemIsEditable)
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getOrientation().x))
-        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getOrientation().y))
-        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getOrientation().z))
-        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
-        
-    def parseScale(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, &quot;Scale&quot;)
-        item.setText(1, str(node.getScale().x) + &quot;; &quot; + str(node.getScale().y) + &quot;; &quot; + str(node.getScale().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, &quot;X&quot;)
-        itemX.setText(1, str(node.getScale().x))
-        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, &quot;Y&quot;)
-        itemY.setText(1, str(node.getScale().y))
-        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, &quot;Z&quot;)
-        itemZ.setText(1, str(node.getScale().z))
-        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
-        
-    def parseEntityOptions(self, node):
-        uo = node.getAttachedObject(0).getUserObject()
-
-        if uo is not None:
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Receives Shadows&quot;)
-            item.setText(1, str(uo.receivesShadow))
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Static Geometry Group&quot;)
-            item.setText(1, str(uo.staticgeometrygroup))
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Physics Proxy Type&quot;)
-            item.setText(1, str(uo.physicsproxytype))  
-            
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, &quot;Rendering Distance&quot;)
-            item.setText(1, str(uo.renderingdistance))
-            item.setFlags(item.flags() | Qt.ItemIsEditable)
-            
-    def updateProperties(self):
-        if self.so is not None:
-            self.showProperties(self.so)
-    
-    def clear(self):
-        self.treeWidget.clear()
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from Property import *
+import ModuleManager
+
+class BoolEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        currentSelected = False
+        if currentSelectedText == &quot;True&quot; or currentSelectedText == &quot;true&quot;:
+            currentSelected = True
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;True&quot;)
+        self.combo.addItem(&quot;False&quot;)
+        
+        if not currentSelected:
+            self.combo.setCurrentIndex(1)
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        ret = True
+        if str(self.combo.currentText()) == &quot;False&quot;:
+            ret = False
+        
+        return ret
+    
+class GameObjectStateEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;IN_SCENE&quot;)
+        self.combo.addItem(&quot;LOADED&quot;)
+        self.combo.addItem(&quot;HELD&quot;)
+        self.combo.addItem(&quot;IN_POSSESSION&quot;)
+        self.combo.addItem(&quot;READIED&quot;)
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+        
+class EntityPhysicsProxyEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;none&quot;)
+        self.combo.addItem(&quot;box&quot;)
+        self.combo.addItem(&quot;sphere&quot;)
+        self.combo.addItem(&quot;ellipsoid&quot;)
+        self.combo.addItem(&quot;pyramid&quot;)
+        self.combo.addItem(&quot;mesh&quot;)
+        self.combo.addItem(&quot;convexhull&quot;)
+        self.combo.addItem(&quot;custom - Not supported by editor yet!&quot;)
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+    
+class ObjectPropertyWin(QDialog):
+    def __init__(self, sceneManager, gocManager, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setupUi()
+        self.sceneManager = sceneManager
+        self.valueBeforeEdit = None
+        self.gocManager = gocManager
+        
+        self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
+                               self.onItemClicked)
+        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                               self.onItemChanged)
+
+    def setupUi(self):
+        self.setObjectName(&quot;ObjectPropertys&quot;)
+        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
+
+        self.treeWidget = QTreeWidget(self)
+        self.treeWidget.setGeometry(QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QSize(400,400))
+        self.treeWidget.setObjectName(&quot;treeWidget&quot;)
+        self.treeWidget.setAlternatingRowColors(True)
+        self.treeWidget.setAnimated(True)
+        
+        self.retranslateUi()
+        QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.treeWidget.headerItem().setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Property&quot;, None, QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Value&quot;, None, QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+
+    def onItemClicked(self, item, column):
+        if column == 1:
+            self.valueBeforeEdit = str(item.text(column))
+            
+            if item.text(0) == &quot;State&quot;:
+                ed = GameObjectStateEditor(item.text(column), self)
+                ed.exec_()
+                item.setText(column, ed.getValue())
+                self.node.getAttachedObject(0).getUserObject().state = ed.getValue()
+                
+            elif item.text(0) == &quot;Receives Shadows&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().receivesShadow = str(bedit.getValue())
+            elif item.text(0) == &quot;Physics Proxy Type&quot;:
+                bedit = EntityPhysicsProxyEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().physicsproxytype = bedit.getValue()
+            elif item.text(0) == &quot;Visibility&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                ModuleManager.extractLight(self.node).setVisible(bedit.getValue())
+            elif item.text(0) == &quot;CastShadows&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                ModuleManager.extractLight(self.node).setCastShadows(bedit.getValue())
+            elif item.text(0) == &quot;Diffuse Color&quot;:
+                min = 1.0 / 255.0
+                col = ModuleManager.extractLight(self.node).getDiffuseColour()
+                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
+                ModuleManager.extractLight(self.node).setDiffuseColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
+                self.showProperties(self.so)
+            elif item.text(0) == &quot;Specular Color&quot;:
+                min = 1.0 / 255.0
+                col = ModuleManager.extractLight(self.node).getSpecularColour()
+                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
+                ModuleManager.extractLight(self.node).setSpecularColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
+                self.showProperties(self.so)
+
+            else:
+                self.treeWidget.editItem(item, column)
+
+    def onItemChanged(self, item, column):
+        if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
+            parent = item.parent()
+            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
+                if item.text(0) == &quot;Name&quot;:
+                    if self.node.getName().startswith(&quot;entity_&quot;):
+                        if not self.sceneManager.hasEntity(str(item.text(column))):
+                            newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
+                            oldEnt = self.node.getAttachedObject(0)
+                            self.node.detachObject(oldEnt)
+                            self.sceneManager.destroyEntity(oldEnt)
+                            self.node.attachObject(newEnt)
+                            
+                            # update the selection object since it still has references to the deleted entity
+                            self.so.entity = newEnt
+                            self.so.entityName = newEnt.getName()
+                        else:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;Error: Name already exists!&quot;
+                            
+                    elif self.node.getName().startswith(&quot;light_&quot;):
+                        if not self.sceneManager.hasLight(str(item.text(column))):
+                            newLight = self.sceneManager.createLight(str(item.text(column)))
+                            oldLight = ModuleManager.extractLight(self.node)
+                            self.node.detachObject(oldLight)
+                            self.node.attachObject(newLight)
+                            newLight.setType(oldLight.getType())
+                            newLight.setVisibilityFlags(newLight.getVisibilityFlags())
+                            newLight.setCastShadows(oldLight.getCastShadows())
+                            newLight.setDiffuseColour(oldLight.getDiffuseColour())
+                            newLight.setSpecularColour(oldLight.getSpecularColour())
+                            newLight.setAttenuation(oldLight.getAttenuationRange(), oldLight.getAttenuationConstant(), oldLight.getAttenuationLinear(), oldLight.getAttenuationQuadric())
+                            if newLight.getType() == og.Light.LT_SPOTLIGHT:
+                                newLight.setSpotlightRange(oldLight.getSpotlightInnerAngle(), oldLight.getSpotlightOuterAngle(), oldLight.getSpotlightFalloff())
+                            if newLight.getType() == og.Light.LT_SPOTLIGHT or newLight.getType() == og.Light.LT_DIRECTIONAL:
+                                newLight.setDirection(oldLight.getDirection())
+                                
+                            self.sceneManager.destroyLight(oldLight)
+                        else:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;Error: Name already exists!&quot;
+                            
+                elif item.text(0) == &quot;GameObject Id&quot;:
+                    if not self.gocManager.inWorldIdExists(str(item.text(column))):
+                        val = None
+                        try:
+                            val = int(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;ValueError: &quot; + str(e)
+                            return
+                            
+                        self.node.getAttachedObject(0).getUserObject().inWorldId = str(val)
+                    else:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;Error: Id exists already!&quot;
+                elif item.text(0) == &quot;Static Geometry Group&quot;:                        
+                    val = None
+                    try:
+                        val = int(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;ValueError: &quot; + str(e)
+                        return
+                elif item.text(0) == &quot;Rendering Distance&quot;:                        
+                    val = None
+                    try:
+                        val = float(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;ValueError: &quot; + str(e)
+                        return
+                    
+                    self.node.getAttachedObject(0).getUserObject().renderingdistance = val
+            else:
+                val = None
+                try:
+                    val = float(item.text(1))
+                except ValueError, e:
+                    item.setText(column, self.valueBeforeEdit)
+                    print &quot;ValueError: &quot; + str(e)
+                    return
+                    
+                if parent.text(0) == &quot;Position&quot;:
+                    if item.text(0) == &quot;X&quot;:
+                        self.node.setPosition(val, self.node.getPosition().y, self.node.getPosition().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setPosition(self.node.getPosition().x, val, self.node.getPosition().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setPosition(self.node.getPosition().x, self.node.getPosition().y, val)
+                elif parent.text(0) == &quot;Orientation&quot;:
+                    if item.text(0) == &quot;W&quot;:
+                        self.node.setOrientation(val, self.node.getOrientation().x, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;X&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, val, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, val, self.node.getOrientation().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, self.node.getOrientation().y, val)
+                elif parent.text(0) == &quot;Scale&quot;:
+                    if item.text(0) == &quot;X&quot;:
+                        self.node.setScale(val, self.node.getScale().y, self.node.getScale().z)
+                    elif item.text(0) == &quot;Y&quot;:
+                        self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
+                    elif item.text(0) == &quot;Z&quot;:
+                        self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
+                elif parent.text(0) == &quot;Attenuation&quot;:
+                    light = ModuleManager.extractLight(self.node)
+                    if item.text(0) == &quot;range&quot;:
+                        light.setAttenuation(val, light.getAttenuationConstant(), light.getAttenuationLinear(), light.getAttenuationQuadric())
+                    elif item.text(0) == &quot;constant&quot;:
+                        light.setAttenuation(light.getAttenuationRange(), val, light.getAttenuationLinear(), light.getAttenuationQuadric())
+                    elif item.text(0) == &quot;linear&quot;:
+                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), val, light.getAttenuationQuadric())
+                    elif item.text(0) == &quot;quadratic&quot;:
+                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), light.getAttenuationLinear(), val)
+                elif parent.text(0) == &quot;Spotlightrange&quot;:
+                    light = ModuleManager.extractLight(self.node)
+                    if item.text(0) == &quot;inner&quot;:
+                        light.setSpotlightInnerAngle(og.Degree(val))
+                    elif item.text(0) == &quot;outer&quot;:
+                        light.setSpotlightOuterAngle(og.Degree(val))
+                    elif item.text(0) == &quot;falloff&quot;:                      
+                      light.setSpotlightFalloff(val)
+                        
+    def showProperties(self, so):
+        # onItemChanged should only be called when the user changes values not when they change by code
+        self.disconnect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                       self.onItemChanged)
+                       
+        self.so=so
+        self.treeWidget.clear()
+        
+        name = so.entity.getParentNode().getName()
+        self.node = so.entity.getParentNode()
+        
+        if name.startswith(&quot;entity_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Name&quot;)
+            n = self.node.getAttachedObject(0).getName()
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            itemMat = QTreeWidgetItem(self.treeWidget)
+            itemMat.setText(0, &quot;Materials&quot;)
+            
+            i = 0
+            while i &lt; self.node.getAttachedObject(0).getNumSubEntities():
+                it = QTreeWidgetItem(itemMat)
+                it.setFlags(item.flags() | Qt.ItemIsEditable)
+                it.setText(0, &quot;SubMesh&quot; + str(i))
+                it.setText(1, self.node.getAttachedObject(0).getSubEntity(i).getMaterialName())
+                i += 1
+                
+                        
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
+            self.parseEntityOptions(self.node)
+            
+        elif name.startswith(&quot;gameobject_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;ClassName&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().gocName)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;GameObject Id&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().inWorldId)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;State&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().state)
+            item.setText(1, n)            
+            
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
+            
+        elif name.startswith(&quot;light_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            light = ModuleManager.extractLight(self.node)
+            n = light.getName()
+            item.setText(0, &quot;Name&quot;)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Type&quot;)
+            if light.getType() == og.Light.LT_POINT:
+                item.setText(1, &quot;point&quot;)
+            elif light.getType() == og.Light.LT_SPOTLIGHT:
+                item.setText(1, &quot;spot&quot;)
+            elif light.getType() == og.Light.LT_DIRECTIONAL:
+                item.setText(1, &quot;directional&quot;)
+
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Visibility&quot;)
+            item.setText(1, str(light.getVisible()))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;CastShadows&quot;)
+            item.setText(1, str(light.getCastShadows()))
+            
+            if light.getType() == og.Light.LT_POINT or light.getType() == og.Light.LT_SPOTLIGHT:
+                self.parsePosition(self.node)
+            if light.getType() == og.Light.LT_SPOTLIGHT:
+                self.parseSpotLightProperties(self.node)
+                
+            self.parseDiffuseColor(self.node)
+            self.parseSpecularColor(self.node)
+            self.parseLightAttenuation(self.node)
+
+       
+        self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
+                       self.onItemChanged)
+                       
+    
+    def parseDiffuseColor(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Diffuse Color&quot;)
+        color = ModuleManager.extractLight(self.node).getDiffuseColour()
+        item.setText(1, str(int(255 * color.r)) + &quot;; &quot; + str(int(255 * color.g)) + &quot;; &quot; + str(int(255 * color.b)))
+        
+    def parseSpecularColor(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Specular Color&quot;)
+        color = ModuleManager.extractLight(self.node).getSpecularColour()
+        item.setText(1, str(int(255 * color.r)) + &quot;; &quot; + str(int(255 * color.g)) + &quot;; &quot; + str(int(255 * color.b)))
+        
+    def parseLightAttenuation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Attenuation&quot;)
+        light = ModuleManager.extractLight(self.node)
+        
+        range = QTreeWidgetItem(item)
+        range.setText(0, &quot;range&quot;)
+        range.setText(1, str(light.getAttenuationRange()))
+        range.setFlags(range.flags() | Qt.ItemIsEditable)
+        
+        constant = QTreeWidgetItem(item)
+        constant.setText(0, &quot;constant&quot;)
+        constant.setText(1,  str(light.getAttenuationConstant()))
+        constant.setFlags(constant.flags() | Qt.ItemIsEditable)
+        
+        linear = QTreeWidgetItem(item)
+        linear.setText(0, &quot;linear&quot;)
+        linear.setText(1, str(light.getAttenuationLinear()))
+        linear.setFlags(linear.flags() | Qt.ItemIsEditable)
+        
+        quadratic = QTreeWidgetItem(item)
+        quadratic.setText(0, &quot;quadratic&quot;)
+        quadratic.setText(1, str(light.getAttenuationQuadric()))
+        quadratic.setFlags(quadratic.flags() | Qt.ItemIsEditable)
+    
+    def parseSpotLightProperties(self,  node):
+        light = ModuleManager.extractLight(self.node)
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Spotlightrange&quot;)
+
+        inner = QTreeWidgetItem(item)
+        inner.setText(0, &quot;inner&quot;)
+        inner.setText(1, str(light.getSpotlightInnerAngle().valueDegrees()))
+        inner.setFlags(inner.flags() | Qt.ItemIsEditable)
+        
+        outer = QTreeWidgetItem(item)
+        outer.setText(0, &quot;outer&quot;)
+        outer.setText(1, str(light.getSpotlightOuterAngle().valueDegrees()))
+        outer.setFlags(outer.flags() | Qt.ItemIsEditable)
+        
+        falloff = QTreeWidgetItem(item)
+        falloff.setText(0, &quot;falloff&quot;)
+        falloff.setText(1, str(light.getSpotlightFalloff()))
+        falloff.setFlags(falloff.flags() | Qt.ItemIsEditable)
+
+    def parsePosition(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Position&quot;)
+        item.setText(1, str(node.getPosition().x) + &quot;; &quot; + str(node.getPosition().y) + &quot;; &quot; + str(node.getPosition().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getPosition().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getPosition().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getPosition().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseOrientation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Orientation&quot;)
+        item.setText(1, str(node.getOrientation().w) + &quot;; &quot; + str(node.getOrientation().x) + &quot;; &quot; + str(node.getOrientation().y) + &quot;; &quot; + str(node.getOrientation().z))
+        
+        itemW = QTreeWidgetItem(item)
+        itemW.setText(0, &quot;W&quot;)
+        itemW.setText(1, str(node.getOrientation().w))
+        itemW.setFlags(itemW.flags() | Qt.ItemIsEditable)
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getOrientation().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getOrientation().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getOrientation().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseScale(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Scale&quot;)
+        item.setText(1, str(node.getScale().x) + &quot;; &quot; + str(node.getScale().y) + &quot;; &quot; + str(node.getScale().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, &quot;X&quot;)
+        itemX.setText(1, str(node.getScale().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, &quot;Y&quot;)
+        itemY.setText(1, str(node.getScale().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, &quot;Z&quot;)
+        itemZ.setText(1, str(node.getScale().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
+    def parseEntityOptions(self, node):
+        uo = node.getAttachedObject(0).getUserObject()
+
+        if uo is not None:
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Receives Shadows&quot;)
+            item.setText(1, str(uo.receivesShadow))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Static Geometry Group&quot;)
+            item.setText(1, str(uo.staticgeometrygroup))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Physics Proxy Type&quot;)
+            item.setText(1, str(uo.physicsproxytype))  
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Rendering Distance&quot;)
+            item.setText(1, str(uo.renderingdistance))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+    def updateProperties(self):
+        if self.so is not None:
+            self.showProperties(self.so)
+    
+    def clear(self):
+        self.treeWidget.clear()

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import os

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Modified: rl/trunk/editors/Lockenwickler/src/Property.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Property.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/Property.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *

Modified: rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 #

Modified: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,3 +1,22 @@
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
 import ctypes as ctypes
 import random
 import platform

Modified: rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,100 +1,118 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
-#
-# Created: Sun Nov  9 14:15:16 2008
-#      by: PyQt4 UI code generator 4.4.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_Dialog(object):
-    def setupUi(self, Dialog):
-        Dialog.setObjectName(&quot;Dialog&quot;)
-        Dialog.resize(675, 703)
-        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
-        self.gridLayout_3.setObjectName(&quot;gridLayout_3&quot;)
-        self.label = QtGui.QLabel(Dialog)
-        self.label.setObjectName(&quot;label&quot;)
-        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
-        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.moduleNameLineEdit.setObjectName(&quot;moduleNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
-        self.label_2 = QtGui.QLabel(Dialog)
-        self.label_2.setObjectName(&quot;label_2&quot;)
-        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
-        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.sceneNameLineEdit.setEnabled(False)
-        self.sceneNameLineEdit.setObjectName(&quot;sceneNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
-        self.label_3 = QtGui.QLabel(Dialog)
-        self.label_3.setObjectName(&quot;label_3&quot;)
-        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
-        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.mapNameLineEdit.setEnabled(False)
-        self.mapNameLineEdit.setObjectName(&quot;mapNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
-        self.groupBox = QtGui.QGroupBox(Dialog)
-        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
-        self.groupBox.setObjectName(&quot;groupBox&quot;)
-        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
-        self.gridLayout_2.setObjectName(&quot;gridLayout_2&quot;)
-        self.moduleDependenciesList = QtGui.QListWidget(self.groupBox)
-        self.moduleDependenciesList.setEnabled(False)
-        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.moduleDependenciesList.setObjectName(&quot;moduleDependenciesList&quot;)
-        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
-        self.groupBox_2 = QtGui.QGroupBox(Dialog)
-        self.groupBox_2.setObjectName(&quot;groupBox_2&quot;)
-        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
-        self.gridLayout.setObjectName(&quot;gridLayout&quot;)
-        self.scriptDependenciesList = QtGui.QListWidget(self.groupBox_2)
-        self.scriptDependenciesList.setEnabled(False)
-        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.scriptDependenciesList.setObjectName(&quot;scriptDependenciesList&quot;)
-        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
-        self.hboxlayout = QtGui.QHBoxLayout()
-        self.hboxlayout.setSpacing(6)
-        self.hboxlayout.setMargin(0)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
-        self.hboxlayout.addItem(spacerItem)
-        self.okButton = QtGui.QPushButton(Dialog)
-        self.okButton.setEnabled(False)
-        self.okButton.setObjectName(&quot;okButton&quot;)
-        self.hboxlayout.addWidget(self.okButton)
-        self.cancelButton = QtGui.QPushButton(Dialog)
-        self.cancelButton.setObjectName(&quot;cancelButton&quot;)
-        self.hboxlayout.addWidget(self.cancelButton)
-        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
-
-        self.retranslateUi(Dialog)
-        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.accept)
-        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.reject)
-        QtCore.QMetaObject.connectSlotsByName(Dialog)
-
-    def retranslateUi(self, Dialog):
-        Dialog.setWindowTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 1: Module Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label_2.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 2: Scene Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label_3.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 3: Map Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 4: Module Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox_2.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 5: Script Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.okButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;OK&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.cancelButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;Cancel&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-
-if __name__ == &quot;__main__&quot;:
-    import sys
-    app = QtGui.QApplication(sys.argv)
-    Dialog = QtGui.QDialog()
-    ui = Ui_Dialog()
-    ui.setupUi(Dialog)
-    Dialog.show()
-    sys.exit(app.exec_())
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+ 
+ 
+# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
+#
+# Created: Sun Nov  9 14:15:16 2008
+#      by: PyQt4 UI code generator 4.4.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_Dialog(object):
+    def setupUi(self, Dialog):
+        Dialog.setObjectName(&quot;Dialog&quot;)
+        Dialog.resize(675, 703)
+        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
+        self.gridLayout_3.setObjectName(&quot;gridLayout_3&quot;)
+        self.label = QtGui.QLabel(Dialog)
+        self.label.setObjectName(&quot;label&quot;)
+        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
+        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.moduleNameLineEdit.setObjectName(&quot;moduleNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
+        self.label_2 = QtGui.QLabel(Dialog)
+        self.label_2.setObjectName(&quot;label_2&quot;)
+        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
+        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.sceneNameLineEdit.setEnabled(False)
+        self.sceneNameLineEdit.setObjectName(&quot;sceneNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
+        self.label_3 = QtGui.QLabel(Dialog)
+        self.label_3.setObjectName(&quot;label_3&quot;)
+        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
+        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.mapNameLineEdit.setEnabled(False)
+        self.mapNameLineEdit.setObjectName(&quot;mapNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
+        self.groupBox = QtGui.QGroupBox(Dialog)
+        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
+        self.groupBox.setObjectName(&quot;groupBox&quot;)
+        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
+        self.gridLayout_2.setObjectName(&quot;gridLayout_2&quot;)
+        self.moduleDependenciesList = QtGui.QListWidget(self.groupBox)
+        self.moduleDependenciesList.setEnabled(False)
+        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.moduleDependenciesList.setObjectName(&quot;moduleDependenciesList&quot;)
+        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
+        self.groupBox_2 = QtGui.QGroupBox(Dialog)
+        self.groupBox_2.setObjectName(&quot;groupBox_2&quot;)
+        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
+        self.gridLayout.setObjectName(&quot;gridLayout&quot;)
+        self.scriptDependenciesList = QtGui.QListWidget(self.groupBox_2)
+        self.scriptDependenciesList.setEnabled(False)
+        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.scriptDependenciesList.setObjectName(&quot;scriptDependenciesList&quot;)
+        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
+        self.hboxlayout = QtGui.QHBoxLayout()
+        self.hboxlayout.setSpacing(6)
+        self.hboxlayout.setMargin(0)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.hboxlayout.addItem(spacerItem)
+        self.okButton = QtGui.QPushButton(Dialog)
+        self.okButton.setEnabled(False)
+        self.okButton.setObjectName(&quot;okButton&quot;)
+        self.hboxlayout.addWidget(self.okButton)
+        self.cancelButton = QtGui.QPushButton(Dialog)
+        self.cancelButton.setObjectName(&quot;cancelButton&quot;)
+        self.hboxlayout.addWidget(self.cancelButton)
+        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
+
+        self.retranslateUi(Dialog)
+        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.accept)
+        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.reject)
+        QtCore.QMetaObject.connectSlotsByName(Dialog)
+
+    def retranslateUi(self, Dialog):
+        Dialog.setWindowTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 1: Module Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label_2.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 2: Scene Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label_3.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 3: Map Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 4: Module Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox_2.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 5: Script Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.okButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;OK&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.cancelButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;Cancel&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+
+if __name__ == &quot;__main__&quot;:
+    import sys
+    app = QtGui.QApplication(sys.argv)
+    Dialog = QtGui.QDialog()
+    ui = Ui_Dialog()
+    ui.setupUi(Dialog)
+    Dialog.show()
+    sys.exit(app.exec_())
+

Modified: rl/trunk/editors/Lockenwickler/src/setup.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/setup.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/setup.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,4 +1,23 @@
-from distutils.core import setup
-import py2exe
-
-setup(windows=[&quot;Lockenwickler.py&quot;], options={&quot;py2exe&quot; : {&quot;includes&quot; : [&quot;sip&quot;, &quot;PyQt4._qt&quot;]}})
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+from distutils.core import setup
+import py2exe
+
+setup(windows=[&quot;Lockenwickler.py&quot;], options={&quot;py2exe&quot; : {&quot;includes&quot; : [&quot;sip&quot;, &quot;PyQt4._qt&quot;]}})

Modified: rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-03-20 17:02:31 UTC (rev 4854)
+++ rl/trunk/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-03-20 19:48:23 UTC (rev 4855)
@@ -1,11 +1,21 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'console_window.ui'
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
 #
-# Created: Mon May 12 15:09:24 2008
-#      by: PyQt4 UI code generator 4.3.3
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
 #
-# WARNING! All changes made in this file will be lost!
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 from PyQt4 import QtCore, QtGui
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001911.html">[Dsa-hl-svn] r4854 - rl/trunk/editors/Lockenwickler/src
</A></li>
	<LI>Next message: <A HREF="001913.html">[Dsa-hl-svn] r4856 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1912">[ date ]</a>
              <a href="thread.html#1912">[ thread ]</a>
              <a href="subject.html#1912">[ subject ]</a>
              <a href="author.html#1912">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
