<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4834 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/ai/include engine/ai/src engine/common/src	engine/rules/include engine/rules/src engine/script/swig	engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4834%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/ai/include%20engine/ai/src%20engine/common/src%0A%09engine/rules/include%20engine/rules/src%20engine/script/swig%0A%09engine/ui/src&In-Reply-To=%3C200903152221.n2FMLYV2005059%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001890.html">
   <LINK REL="Next"  HREF="001892.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4834 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/ai/include engine/ai/src engine/common/src	engine/rules/include engine/rules/src engine/script/swig	engine/ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4834%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/ai/include%20engine/ai/src%20engine/common/src%0A%09engine/rules/include%20engine/rules/src%20engine/script/swig%0A%09engine/ui/src&In-Reply-To=%3C200903152221.n2FMLYV2005059%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4834 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/ai/include engine/ai/src engine/common/src	engine/rules/include engine/rules/src engine/script/swig	engine/ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sun Mar 15 23:21:34 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001890.html">[Dsa-hl-svn] r4833 - rl/trunk/engine/common/include
</A></li>
        <LI>Next message: <A HREF="001892.html">[Dsa-hl-svn] r4835 - rl/trunk/engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1891">[ date ]</a>
              <a href="thread.html#1891">[ thread ]</a>
              <a href="subject.html#1891">[ subject ]</a>
              <a href="author.html#1891">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2009-03-15 23:21:28 +0100 (Sun, 15 Mar 2009)
New Revision: 4834

Added:
   rl/trunk/engine/script/swig/TypeRlGameObjectList.swig
Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/ai/include/AgentDialogState.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/common/src/ConfigFile.cpp
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/include/Selector.h
   rl/trunk/engine/rules/src/Selector.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/TypeDynamicDirector.swig
   rl/trunk/engine/script/swig/TypeMaps.i
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
Some changes and fixes for dialogs

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1289,6 +1289,7 @@
 		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZoneManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483373800F65EBF4005979BF /* DialogController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DialogController.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483373820F65EC01005979BF /* DialogController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DialogController.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483374130F6D275A005979BF /* TypeRlGameObjectList.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeRlGameObjectList.swig; path = script/swig/TypeRlGameObjectList.swig; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentLoader.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitching.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StartAnimationJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1947,6 +1948,7 @@
 				48389BFB0D8677EE00AFAB66 /* TypeOgreVector3.swig */,
 				48389BFC0D8677EE00AFAB66 /* TypeRlCeGuiString.swig */,
 				48389BFD0D8677EE00AFAB66 /* TypeRlCeGuiStringVector.swig */,
+				483374130F6D275A005979BF /* TypeRlGameObjectList.swig */,
 				48389BFE0D8677EE00AFAB66 /* TypeRlProperty.swig */,
 				48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */,
 				48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */,

Modified: rl/trunk/engine/ai/include/AgentDialogState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentDialogState.h	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/ai/include/AgentDialogState.h	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1,45 +1,47 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RlAI_AgentDialogState_H__
-#define __RlAI_AgentDialogState_H__
-
-#include &quot;AgentState.h&quot;
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport AgentDialogState :
-        public AgentState
-    {
-    public:
-        AgentDialogState(Agent* agent);
-        ~AgentDialogState();
-
-        virtual void update(const Ogre::Real elapsedTime);
-        void setDialogPartner(Agent* partner);
-        void setDialog(Dialog* dialog);
-
-    private:
-        Agent* mPartner;
-        Dialog* mDialog;
-        bool mTalking;
-    };
-
-}
-
-#endif // __RlAI_AgentDialogState_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RlAI_AgentDialogState_H__
+#define __RlAI_AgentDialogState_H__
+
+#include &quot;AgentState.h&quot;
+
+#include &lt;list&gt;
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport AgentDialogState :
+        public AgentState
+    {
+    public:
+        AgentDialogState(Agent* agent);
+        ~AgentDialogState();
+
+        virtual void update(const Ogre::Real elapsedTime);
+        void addDialogPartner(Agent* partner);
+        void setDialog(Dialog* dialog);
+
+    private:
+        std::list&lt;Agent*&gt; mPartners;
+        Dialog* mDialog;
+        bool mTalking;
+    };
+
+}
+
+#endif // __RlAI_AgentDialogState_H__

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2009-03-15 22:21:28 UTC (rev 4834)
@@ -131,6 +131,12 @@
 		 */
 		bool isAhead(Agent* agent, const float threshold);
 
+		/** tests if the specified position is within the threshold.
+		 * @param agent Agent to test against
+		 * @param threshold specifies maximum distance
+		 */
+		bool isAhead(const Vector3&amp; position, const float threshold);
+
 		/** tests if collision will happen within specified timeframe
 		 * @param minTimeToCollision minimum time to next collision
 		 */

Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1,83 +1,94 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#include &quot;stdinc.h&quot;
-#include &quot;AgentDialogState.h&quot;
-
-#include &quot;Agent.h&quot;
-#include &quot;AiMessages.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;MessagePump.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    AgentDialogState::AgentDialogState(Agent* agent)
-        : AgentState(agent),
-        mPartner(NULL),
-        mTalking(false)
-    {
-    }
-
-    AgentDialogState::~AgentDialogState()
-    {
-    }
-
-    void AgentDialogState::setDialogPartner(Agent* partner)
-    {
-        mPartner = partner;
-    }
-
-    void AgentDialogState::setDialog(Dialog* dialog)
-    {
-        mDialog = dialog;
-    }
-
-    void AgentDialogState::update(const Ogre::Real elapsedTime)
-    {
-        CreatureController* ctrl = 
-                CreatureControllerManager::getSingleton().getCreatureController(
-                    mAgent-&gt;getControlledCreature());
-
-        if (mAgent-&gt;getPosition().squaredDistance(mPartner-&gt;getPosition()) &gt; 1.5
-            || !mAgent-&gt;isAhead(mPartner, 0.95))
-        {		
-            mAgent-&gt;addForce(mAgent-&gt;calcSeek(mPartner-&gt;getPosition()));
-            mAgent-&gt;updateVehicle(0, elapsedTime);
-        }
-		else
-        {
-			if (!mTalking)
-            {
-                mAgent-&gt;reset();
-                ctrl-&gt;setMovement(
-                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
-
-                ctrl-&gt;setAnimation(&quot;reden&quot;);
-				mTalking = true;
-
-                MessagePump::getSingleton().sendMessage&lt;MessageType_DialogStarted&gt;(mDialog);
-                
-                mAgent-&gt;popState();
-            }			
-        }
-
-    }
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#include &quot;stdinc.h&quot;
+#include &quot;AgentDialogState.h&quot;
+
+#include &quot;Agent.h&quot;
+#include &quot;AiMessages.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;MessagePump.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    AgentDialogState::AgentDialogState(Agent* agent)
+        : AgentState(agent),
+        mTalking(false),
+        mDialog(NULL)
+    {
+    }
+
+    AgentDialogState::~AgentDialogState()
+    {
+    }
+
+    void AgentDialogState::addDialogPartner(Agent* partner)
+    {
+        mPartners.push_back(partner);
+    }
+
+    void AgentDialogState::setDialog(Dialog* dialog)
+    {
+        mDialog = dialog;
+    }
+
+    void AgentDialogState::update(const Ogre::Real elapsedTime)
+    {
+        CreatureController* ctrl = 
+                CreatureControllerManager::getSingleton().getCreatureController(
+                    mAgent-&gt;getControlledCreature());
+
+        Vector3 partnerPos(Vector3::ZERO);
+        if (!mPartners.empty())
+        {
+            for (std::list&lt;Agent*&gt;::iterator it = mPartners.begin(), end = mPartners.end(); it != end; ++it)
+            {
+                partnerPos += (*it)-&gt;getPosition();
+            }
+            partnerPos /= mPartners.size();
+        }
+
+        if (!mPartners.empty() &amp;&amp;
+            (mAgent-&gt;getPosition().squaredDistance(partnerPos) &gt; 1.5
+            || !mAgent-&gt;isAhead(partnerPos, 0.95)))
+        {		
+            mAgent-&gt;addForce(mAgent-&gt;calcSeek(partnerPos));
+            mAgent-&gt;updateVehicle(0, elapsedTime);
+        }
+		else
+        {
+			if (!mTalking &amp;&amp; mDialog)
+            {
+                mAgent-&gt;reset();
+                ctrl-&gt;setMovement(
+                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+
+                ctrl-&gt;setAnimation(&quot;reden&quot;);
+				mTalking = true;
+
+                MessagePump::getSingleton().sendMessage&lt;MessageType_DialogStarted&gt;(mDialog);
+                
+                mAgent-&gt;popState();
+            }			
+        }
+
+    }
+} // namespace rl

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-03-15 22:21:28 UTC (rev 4834)
@@ -612,7 +612,7 @@
 
                 if (!isInParty)
                 {
-                    dialog-&gt;addParticipant(&quot;nsc&quot;, curCr);
+                    dialog-&gt;addParticipant(&quot;npc&quot;, curCr);
                     found1stNpc = true;
                 }
             }

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1,346 +1,351 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright(C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot;
-
-#include &quot;SteeringVehicle.h&quot;
-
-#include &quot;AbstractMovement.h&quot;
-#include &quot;AiSubsystem.h&quot;
-#include &quot;AiWorld.h&quot; 
-#include &quot;Agent.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;RulesMessages.h&quot;
-
-using namespace Ogre;
-using namespace OpenSteer;
-
-namespace rl {
-
-SteeringVehicle::SteeringVehicle(Creature* creature)
-	: _maxForce(1.0f),
-      _maxSpeed(1.0f),
-      mSpeed(1.0f),
-	  mCurrentForce(Vector3::ZERO), 
-	  mCurrentVelocity(Vector3::ZERO),
-	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
-      mCreatureId(creature-&gt;getId()),
-      mController(NULL),
-      mDebugSteer(Vector3::ZERO),
-      mDebugWander(Vector3::ZERO),
-      mDebugAvoidObstacles(Vector3::ZERO)
-{
-    setCreature(creature);
-	initialize();
-
-    mController = CreatureControllerManager::getSingleton().getCreatureController(
-        mCreature);
-    mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
-                boost::bind(&amp;SteeringVehicle::refetchCreature, this));
-}
-
-SteeringVehicle::~SteeringVehicle()
-{
-}
-
-void SteeringVehicle::resetLocalSpace()
-{
-	setForward(mForwardVector);
-	setSide(localRotateForwardToSide(getForward()));
-    setUp(Vector3::UNIT_Y);
-	Vector3 pos = mCreature-&gt;getPosition();
-	setPosition(pos);
-	Vector3 src = mCreature-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z;
-
-    // regenerate local space(by default: align vehicle's forward axis with
-    // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF(src);
-}
-
-void SteeringVehicle::initialize()
-{
-    // reset LocalSpace state
-	resetLocalSpace();
-	
-    // reset SteerLibraryMixin state
-	SimpleVehicle_2::reset();
-
-	setMaxForce(1.0f);   // steering force is clipped to this magnitude
-	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
-}
-
-
-void SteeringVehicle::addForce(const Ogre::Vector3&amp; force)
-{
-	mCurrentForce += force;
-}
-
-void SteeringVehicle::update(const float currentTime, const float elapsedTime)
-{
-    SimpleVehicle::update(currentTime, elapsedTime);
-
-    Vector3 pos = mCreature-&gt;getPosition();
-	setPosition(pos);
-    
-    OgreNewt::Body* body = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-    //  Get the velocity vector
-	mCurrentVelocity = body-&gt;getVelocity();
-	//  enforce speed limit
-	//  newVelocity = newVelocity.truncateLength(maxSpeed());
-	//  update speed
-	setSpeed(mCurrentVelocity.length());
-	Vector3 newVelocity(mCurrentVelocity);
-
-    //  regenerate local space(by default: align vehicle's forward axis with
-    //  new velocity, but this behavior may be overridden by derived classes.)
-    // use future orientation or not??
-    Quaternion orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
-    Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
-    regenerateOrthonormalBasisUF(newUnitForward);
-
-    // only process if mMovingCreature not NULL
-    if (mController == NULL || mCreature-&gt;getQueryFlags() &amp; QUERYFLAG_PLAYER)
-    {
-        mCurrentForce = Vector3::ZERO;
-        return;
-    }
-    
-    // calculate the result of the force    
-    Vector3 result = mCurrentForce;// + mCurrentVelocity;
-    
-    mDebugSteer = mCurrentForce;
-
-    // @todo remove this
-    if (mCreature-&gt;getAu() &lt;= 6)
-        mCreature-&gt;modifyAu(20,true);
-
-    AbstractMovement* mov_drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
-    Real vel_drehen(0);
-    Radian max_drehen = Degree(0);
-    if (mov_drehen-&gt;calculateBaseVelocity(vel_drehen))
-    {
-        max_drehen = Degree(vel_drehen * 360 * elapsedTime);
-    }
-
-    Ogre::Quaternion future_orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
-    Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
-    Radian yaw(0);
-    creatureDirection.y = result.y = 0;
-    yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
-    if (yaw &gt; Radian(0) &amp;&amp; yaw &gt; max_drehen)
-        yaw = max_drehen;
-    if (yaw &lt; Radian(0) &amp;&amp; yaw &lt; -max_drehen)
-        yaw = -max_drehen;
-
-    Ogre::Vector3 direction(Ogre::Vector3::ZERO);
-    Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
-    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
-    if (result != Ogre::Vector3::ZERO)
-    {
-        direction.z = -1;
-        movement = CreatureController::MT_GEHEN;
-    }
-
-    mController-&gt;setMovement(movement, direction, rotation);
-    LOG_DEBUG(Logger::AI, &quot;SteeringVehicle: mController-&gt;setMovement &quot; + 
-        Ogre::StringConverter::toString(movement) + &quot;, &quot;
-        + Ogre::StringConverter::toString(direction) + &quot;, &quot;
-        + Ogre::StringConverter::toString(rotation));
-
-	mCurrentForce = Ogre::Vector3::ZERO;
-}
-
-Vector3 SteeringVehicle::calcWander(const float elapsedTime)
-{
-	Vector3 steering = mForwardVector;
-	
-    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
-
-    mDebugWander = steering;
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcSeek(const Vector3&amp; target)
-{
-	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcFlee(const Vector3&amp; target)
-{
-	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcPursuit(Agent* agent)
-{
-    Vector3 dir = Vec3Utils::setYtoZero(steerForPursuit(*agent));
-	return dir;
-}
-
-Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
-{
-    ObstacleGroup obstacles = getObstacles();
-    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
-    mDebugAvoidObstacles = steering;
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
-{
-    const float maxRadius = minTimeToCollision * getMaxSpeed() * 2;
-	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors(maxRadius)));
-	return steering;
-}
-		
-Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
-{
-	return Vector3();
-}
-
-bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
-{
-    Vector3 target = agent-&gt;getControlledCreature()-&gt;getPosition();
-	//target.y = position.y;
-	return SimpleVehicle_2::isAhead(target, threshold);
-}
-
-bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
-{
-	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
-	if (rVal == Vector3::ZERO)
-	{
-		return false;
-	}
-	return true;
-}
-
-AVGroup SteeringVehicle::getNeighbors(const float maxRadius) const
-{
-	AVGroup neighbors;
-    //std::vector&lt;SimpleVehicle*&gt; neighbors;
-    if(mProximityToken != NULL)
-    {
-        mProximityToken-&gt;findNeighbors(getPosition(), maxRadius, neighbors);
-    }
-	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
-	//AgentManager::VehicleList::const_iterator itr = list.begin();
-	//for(; itr != list.end(); ++itr)
-	//{
-	//	if ((*itr) != this)
-	//	{
-	//		group.push_back((*itr));
-	//	}
-	//}
-	return neighbors;
-}
-
-float SteeringVehicle::calcDistance(const Vector3&amp; vec1, const Vector3&amp; vec2)
-{
-	Vector3 vec = vec1-vec2;
-	return vec.length();
-}
-/*
-Vector3 SteeringVehicle::getPosition()
-{
-	return mCreature-&gt;getPosition();
-}
-*/
-
-
-const ObstacleGroup&amp; SteeringVehicle::getObstacles() const
-{
-	return AiSubsystem::getSingleton().getWorld()-&gt;getSteeringObstacles();
-}
-/*
-Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
-{
-	//return position() +(velocity() * predictionTime);
-	return getVelocity() * predictionTime;
-}
-*/
-Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3&amp; force)
-{
-    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
-
-    if ((getSpeed() &gt; maxAdjustedSpeed) ||(force == Vector3::ZERO))
-    {
-        return force;
-    }
-    else
-    {
-        const float range = getSpeed() / maxAdjustedSpeed;
-        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
-        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
-        return limitMaxDeviationAngle(force, cosine, getForward());
-    }
-}
-
-// methods from debugvisualisable
-DebugVisualisableFlag SteeringVehicle::getFlag() const
-{
-    return DVF_BOT;
-}
-
-void SteeringVehicle::updatePrimitive()
-{
-    if (mSceneNode-&gt;getParent() == NULL)
-    {
-        mCreature-&gt;getActor()-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
-    }
-
-    LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-    lineSet-&gt;clear();
-    
-    if (mDebugSteer != Vector3::ZERO)
-    {
-        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
-        mDebugSteer = Vector3::ZERO;
-    }
-    if (mDebugWander != Vector3::ZERO)
-    {
-        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
-        mDebugWander = Vector3::ZERO;
-    }
-    if (mDebugAvoidObstacles != Vector3::ZERO)
-    {
-        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
-        mDebugAvoidObstacles = Vector3::ZERO;
-    }
-}
-
-void SteeringVehicle::doCreatePrimitive()
-{
-    mPrimitive = new LineSetPrimitive();
-}
-
-bool SteeringVehicle::refetchCreature()
-{
-    mCreature = static_cast&lt;Creature*&gt;(GameObjectManager::getSingleton().getGameObject(mCreatureId));
-    return false;
-}
-
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright(C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;SteeringVehicle.h&quot;
+
+#include &quot;AbstractMovement.h&quot;
+#include &quot;AiSubsystem.h&quot;
+#include &quot;AiWorld.h&quot; 
+#include &quot;Agent.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;PhysicalThing.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;RulesMessages.h&quot;
+
+using namespace Ogre;
+using namespace OpenSteer;
+
+namespace rl {
+
+SteeringVehicle::SteeringVehicle(Creature* creature)
+	: _maxForce(1.0f),
+      _maxSpeed(1.0f),
+      mSpeed(1.0f),
+	  mCurrentForce(Vector3::ZERO), 
+	  mCurrentVelocity(Vector3::ZERO),
+	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
+      mCreatureId(creature-&gt;getId()),
+      mController(NULL),
+      mDebugSteer(Vector3::ZERO),
+      mDebugWander(Vector3::ZERO),
+      mDebugAvoidObstacles(Vector3::ZERO)
+{
+    setCreature(creature);
+	initialize();
+
+    mController = CreatureControllerManager::getSingleton().getCreatureController(
+        mCreature);
+    mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
+                boost::bind(&amp;SteeringVehicle::refetchCreature, this));
+}
+
+SteeringVehicle::~SteeringVehicle()
+{
+}
+
+void SteeringVehicle::resetLocalSpace()
+{
+	setForward(mForwardVector);
+	setSide(localRotateForwardToSide(getForward()));
+    setUp(Vector3::UNIT_Y);
+	Vector3 pos = mCreature-&gt;getPosition();
+	setPosition(pos);
+	Vector3 src = mCreature-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z;
+
+    // regenerate local space(by default: align vehicle's forward axis with
+    // new velocity, but this behavior may be overridden by derived classes.)
+	regenerateOrthonormalBasisUF(src);
+}
+
+void SteeringVehicle::initialize()
+{
+    // reset LocalSpace state
+	resetLocalSpace();
+	
+    // reset SteerLibraryMixin state
+	SimpleVehicle_2::reset();
+
+	setMaxForce(1.0f);   // steering force is clipped to this magnitude
+	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
+}
+
+
+void SteeringVehicle::addForce(const Ogre::Vector3&amp; force)
+{
+	mCurrentForce += force;
+}
+
+void SteeringVehicle::update(const float currentTime, const float elapsedTime)
+{
+    SimpleVehicle::update(currentTime, elapsedTime);
+
+    Vector3 pos = mCreature-&gt;getPosition();
+	setPosition(pos);
+    
+    OgreNewt::Body* body = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+    //  Get the velocity vector
+	mCurrentVelocity = body-&gt;getVelocity();
+	//  enforce speed limit
+	//  newVelocity = newVelocity.truncateLength(maxSpeed());
+	//  update speed
+	setSpeed(mCurrentVelocity.length());
+	Vector3 newVelocity(mCurrentVelocity);
+
+    //  regenerate local space(by default: align vehicle's forward axis with
+    //  new velocity, but this behavior may be overridden by derived classes.)
+    // use future orientation or not??
+    Quaternion orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
+    Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
+    regenerateOrthonormalBasisUF(newUnitForward);
+
+    // only process if mMovingCreature not NULL
+    if (mController == NULL || mCreature-&gt;getQueryFlags() &amp; QUERYFLAG_PLAYER)
+    {
+        mCurrentForce = Vector3::ZERO;
+        return;
+    }
+    
+    // calculate the result of the force    
+    Vector3 result = mCurrentForce;// + mCurrentVelocity;
+    
+    mDebugSteer = mCurrentForce;
+
+    // @todo remove this
+    if (mCreature-&gt;getAu() &lt;= 6)
+        mCreature-&gt;modifyAu(20,true);
+
+    AbstractMovement* mov_drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
+    Real vel_drehen(0);
+    Radian max_drehen = Degree(0);
+    if (mov_drehen-&gt;calculateBaseVelocity(vel_drehen))
+    {
+        max_drehen = Degree(vel_drehen * 360 * elapsedTime);
+    }
+
+    Ogre::Quaternion future_orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
+    Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
+    Radian yaw(0);
+    creatureDirection.y = result.y = 0;
+    yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
+    if (yaw &gt; Radian(0) &amp;&amp; yaw &gt; max_drehen)
+        yaw = max_drehen;
+    if (yaw &lt; Radian(0) &amp;&amp; yaw &lt; -max_drehen)
+        yaw = -max_drehen;
+
+    Ogre::Vector3 direction(Ogre::Vector3::ZERO);
+    Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
+    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
+    if (result != Ogre::Vector3::ZERO)
+    {
+        direction.z = -1;
+        movement = CreatureController::MT_GEHEN;
+    }
+
+    mController-&gt;setMovement(movement, direction, rotation);
+    LOG_DEBUG(Logger::AI, &quot;SteeringVehicle: mController-&gt;setMovement &quot; + 
+        Ogre::StringConverter::toString(movement) + &quot;, &quot;
+        + Ogre::StringConverter::toString(direction) + &quot;, &quot;
+        + Ogre::StringConverter::toString(rotation));
+
+	mCurrentForce = Ogre::Vector3::ZERO;
+}
+
+Vector3 SteeringVehicle::calcWander(const float elapsedTime)
+{
+	Vector3 steering = mForwardVector;
+	
+    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
+
+    mDebugWander = steering;
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcSeek(const Vector3&amp; target)
+{
+	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcFlee(const Vector3&amp; target)
+{
+	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcPursuit(Agent* agent)
+{
+    Vector3 dir = Vec3Utils::setYtoZero(steerForPursuit(*agent));
+	return dir;
+}
+
+Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
+{
+    ObstacleGroup obstacles = getObstacles();
+    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
+    mDebugAvoidObstacles = steering;
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
+{
+    const float maxRadius = minTimeToCollision * getMaxSpeed() * 2;
+	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors(maxRadius)));
+	return steering;
+}
+		
+Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
+{
+	return Vector3();
+}
+
+bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
+{
+    Vector3 target = agent-&gt;getControlledCreature()-&gt;getPosition();
+    //target.y = position.y;
+    return SimpleVehicle_2::isAhead(target, threshold);
+}
+
+bool SteeringVehicle::isAhead(const Vector3&amp; position, const float threshold)
+{
+    return SimpleVehicle_2::isAhead(position, threshold);
+}
+
+bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
+{
+	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
+	if (rVal == Vector3::ZERO)
+	{
+		return false;
+	}
+	return true;
+}
+
+AVGroup SteeringVehicle::getNeighbors(const float maxRadius) const
+{
+	AVGroup neighbors;
+    //std::vector&lt;SimpleVehicle*&gt; neighbors;
+    if(mProximityToken != NULL)
+    {
+        mProximityToken-&gt;findNeighbors(getPosition(), maxRadius, neighbors);
+    }
+	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
+	//AgentManager::VehicleList::const_iterator itr = list.begin();
+	//for(; itr != list.end(); ++itr)
+	//{
+	//	if ((*itr) != this)
+	//	{
+	//		group.push_back((*itr));
+	//	}
+	//}
+	return neighbors;
+}
+
+float SteeringVehicle::calcDistance(const Vector3&amp; vec1, const Vector3&amp; vec2)
+{
+	Vector3 vec = vec1-vec2;
+	return vec.length();
+}
+/*
+Vector3 SteeringVehicle::getPosition()
+{
+	return mCreature-&gt;getPosition();
+}
+*/
+
+
+const ObstacleGroup&amp; SteeringVehicle::getObstacles() const
+{
+	return AiSubsystem::getSingleton().getWorld()-&gt;getSteeringObstacles();
+}
+/*
+Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
+{
+	//return position() +(velocity() * predictionTime);
+	return getVelocity() * predictionTime;
+}
+*/
+Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3&amp; force)
+{
+    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
+
+    if ((getSpeed() &gt; maxAdjustedSpeed) ||(force == Vector3::ZERO))
+    {
+        return force;
+    }
+    else
+    {
+        const float range = getSpeed() / maxAdjustedSpeed;
+        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
+        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        return limitMaxDeviationAngle(force, cosine, getForward());
+    }
+}
+
+// methods from debugvisualisable
+DebugVisualisableFlag SteeringVehicle::getFlag() const
+{
+    return DVF_BOT;
+}
+
+void SteeringVehicle::updatePrimitive()
+{
+    if (mSceneNode-&gt;getParent() == NULL)
+    {
+        mCreature-&gt;getActor()-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
+    }
+
+    LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+    lineSet-&gt;clear();
+    
+    if (mDebugSteer != Vector3::ZERO)
+    {
+        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
+        mDebugSteer = Vector3::ZERO;
+    }
+    if (mDebugWander != Vector3::ZERO)
+    {
+        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
+        mDebugWander = Vector3::ZERO;
+    }
+    if (mDebugAvoidObstacles != Vector3::ZERO)
+    {
+        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
+        mDebugAvoidObstacles = Vector3::ZERO;
+    }
+}
+
+void SteeringVehicle::doCreatePrimitive()
+{
+    mPrimitive = new LineSetPrimitive();
+}
+
+bool SteeringVehicle::refetchCreature()
+{
+    mCreature = static_cast&lt;Creature*&gt;(GameObjectManager::getSingleton().getGameObject(mCreatureId));
+    return false;
+}
+
+} // namespace rl

Modified: rl/trunk/engine/common/src/ConfigFile.cpp
===================================================================
--- rl/trunk/engine/common/src/ConfigFile.cpp	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/common/src/ConfigFile.cpp	2009-03-15 22:21:28 UTC (rev 4834)
@@ -18,7 +18,12 @@
 
 #include &quot;ConfigFile.h&quot;
 #include &quot;Exception.h&quot;
+
+#ifdef __APPLE__
+#include &lt;Ogre/OgreMemoryAllocatorConfig.h&gt;
+#else
 #include &lt;OgreMemoryAllocatorConfig.h&gt;
+#endif
 
 using namespace Ogre;
 using namespace std;

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/rules/include/Creature.h	2009-03-15 22:21:28 UTC (rev 4834)
@@ -873,5 +873,7 @@
              **/
             void setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage);
     };
+    
+    typedef std::list&lt;Creature*&gt; CreatureList;
 }
 #endif //__CREATURE_H__

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/rules/include/GameObject.h	2009-03-15 22:21:28 UTC (rev 4834)
@@ -19,6 +19,8 @@
 
 #include &quot;RulesPrerequisites.h&quot;
 
+#include &lt;list&gt;
+
 #include &quot;Action.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;RulesConstants.h&quot;
@@ -249,6 +251,8 @@
         ActionOptionVector::iterator findAction(ActionOptionVector::iterator
             begin, ActionOptionVector::iterator end, const Action* action);    
     };
+    
+    typedef std::list&lt;GameObject*&gt; GameObjectList;
 }
 
 #endif

Modified: rl/trunk/engine/rules/include/Selector.h
===================================================================
--- rl/trunk/engine/rules/include/Selector.h	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/rules/include/Selector.h	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1,193 +1,191 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_SELECTOR_H__
-#define __RL_SELECTOR_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-#include &quot;SceneQuery.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;LineSetPrimitive.h&quot;
-#include &quot;DebugVisualisable.h&quot;
-
-namespace rl {
-
-    class _RlRulesExport SelectionFilter
-    {
-    public:
-        virtual ~SelectionFilter() {}
-        /// Return true, if the GameObject passes the filter, false else.
-        virtual bool pass(GameObject*) const = 0;
-    };
-
-    class _RlRulesExport CreatureSelectionFilter : public SelectionFilter
-    {
-    public:
-        CreatureSelectionFilter();
-
-        void setAlignmentMask(unsigned int);
-
-        /// Return true, if the GameObject is a Creature with properties as set in the filter.
-        virtual bool pass(GameObject*) const;
-    private:
-        /// Only have alignment here. Can be mademore generic, if needed later on.
-        unsigned int mAlignment;
-    };
-
-    class _RlRulesExport InSceneSelectionFilter : public SelectionFilter
-    {
-    public:
-        InSceneSelectionFilter();
-
-        /// Return true, if the GameObject is in scene with properties as set in the filter.
-        virtual bool pass(GameObject*) const;
-    };
-
-    /// Superclass for all Selectors in RL.
-    /// Selectors provide a way to query for GameObjects in a game.
-    /// Either in the scene, or inventory, or anywhere else.
-    class _RlRulesExport Selector : public DebugVisualisable
-    {
-    public:
-        typedef std::vector&lt;GameObject*&gt; GameObjectVector;
-
-        Selector(unsigned long mask = 0xffffffff);
-        virtual ~Selector();
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        /// Set an additional filter to narrow down selection. Set NULL, to unset filtering.
-        void setFilter(SelectionFilter*);
-        SelectionFilter* getFilter() const;
-
-        GameObject* getFirstSelectedObject() const;
-        const GameObjectVector&amp; getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-    protected:
-        GameObjectVector mSelection;
-        unsigned long mSelectionMask;
-        SelectionFilter* mFilter;
-
-        virtual const ActorVector&amp; doExecuteQuery() = 0;
-        /// Apply the filter if set, or just return true, if no selection filter is set.
-        virtual bool filter(GameObject*);
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class _RlRulesExport RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-		~RaySelector();
-
-        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
-
-        // Overrides from DebugVisualisable
-
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        RaySceneQuery* mQuery;
-
-        virtual const ActorVector&amp; doExecuteQuery();
-        virtual void doCreatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class _RlRulesExport HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
-		HalfSphereSelector(unsigned long mask = 0xffffffff);
-
-        virtual void updateSelection();
-
-        void setRadius(Ogre::Real radius);
-
-        void setPosition(const Ogre::Vector3&amp; pos);
-
-        void setOrientation(const Ogre::Quaternion&amp; ori);
-
-        /// Instead of using transform set with setPosition/Orientation, use the
-        /// GameObject's transform. Set to NULL to disable tracking.
-        void track(GameObject* go);
-
-        /// If check is true, visibility is checked from the POV of the GameObject reference
-        /// This is currently done by casting a ray from the GameObject to the candidate GOs
-        void setCheckVisibility(bool check, GameObject* reference = NULL);
-
-        // Overrides from DebugVisualisable
-
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        HalfSphereSceneQuery mQuery;
-        bool mCheckVisibility;
-        GameObject* mLoSReferenceGo;
-        GameObject* mTrackedGo;
-
-        virtual const ActorVector&amp; doExecuteQuery();
-
-        virtual void doCreatePrimitive();
-    };
-
-    /// Selects this GameObject within a sphere .
-    class _RlRulesExport SphereSelector : public Selector
-    {
-    public:
-        SphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
-	SphereSelector(unsigned long mask = 0xffffffff);
-
-        virtual void updateSelection();
-
-        void setRadius(Ogre::Real radius);
-
-        void setPosition(const Ogre::Vector3&amp; pos);
-
-        /// Instead of using transform set with setPosition/Orientation, use the
-        /// GameObject's transform. Set to NULL to disable tracking.
-        void track(GameObject* go);
-
-        /// If check is true, visibility is checked from the POV of the GameObject reference
-        /// This is currently done by casting a ray from the GameObject to the candidate GOs
-        void setCheckVisibility(bool check, GameObject* reference = NULL);
-
-        // Overrides from DebugVisualisable
-
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        SphereSceneQuery mQuery;
-        bool mCheckVisibility;
-        GameObject* mLoSReferenceGo;
-        GameObject* mTrackedGo;
-
-        virtual const ActorVector&amp; doExecuteQuery();
-
-        virtual void doCreatePrimitive();
-    };
-}
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_SELECTOR_H__
+#define __RL_SELECTOR_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+#include &quot;SceneQuery.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;LineSetPrimitive.h&quot;
+#include &quot;DebugVisualisable.h&quot;
+
+namespace rl {
+
+    class _RlRulesExport SelectionFilter
+    {
+    public:
+        virtual ~SelectionFilter() {}
+        /// Return true, if the GameObject passes the filter, false else.
+        virtual bool pass(GameObject*) const = 0;
+    };
+
+    class _RlRulesExport CreatureSelectionFilter : public SelectionFilter
+    {
+    public:
+        CreatureSelectionFilter();
+
+        void setAlignmentMask(unsigned int);
+
+        /// Return true, if the GameObject is a Creature with properties as set in the filter.
+        virtual bool pass(GameObject*) const;
+    private:
+        /// Only have alignment here. Can be mademore generic, if needed later on.
+        unsigned int mAlignment;
+    };
+
+    class _RlRulesExport InSceneSelectionFilter : public SelectionFilter
+    {
+    public:
+        InSceneSelectionFilter();
+
+        /// Return true, if the GameObject is in scene with properties as set in the filter.
+        virtual bool pass(GameObject*) const;
+    };
+
+    /// Superclass for all Selectors in RL.
+    /// Selectors provide a way to query for GameObjects in a game.
+    /// Either in the scene, or inventory, or anywhere else.
+    class _RlRulesExport Selector : public DebugVisualisable
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual ~Selector();
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        /// Set an additional filter to narrow down selection. Set NULL, to unset filtering.
+        void setFilter(SelectionFilter*);
+        SelectionFilter* getFilter() const;
+
+        GameObject* getFirstSelectedObject() const;
+        const GameObjectList&amp; getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+    protected:
+        GameObjectList mSelection;
+        unsigned long mSelectionMask;
+        SelectionFilter* mFilter;
+
+        virtual const ActorVector&amp; doExecuteQuery() = 0;
+        /// Apply the filter if set, or just return true, if no selection filter is set.
+        virtual bool filter(GameObject*);
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class _RlRulesExport RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+		~RaySelector();
+
+        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        RaySceneQuery* mQuery;
+
+        virtual const ActorVector&amp; doExecuteQuery();
+        virtual void doCreatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class _RlRulesExport HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
+		HalfSphereSelector(unsigned long mask = 0xffffffff);
+
+        virtual void updateSelection();
+
+        void setRadius(Ogre::Real radius);
+
+        void setPosition(const Ogre::Vector3&amp; pos);
+
+        void setOrientation(const Ogre::Quaternion&amp; ori);
+
+        /// Instead of using transform set with setPosition/Orientation, use the
+        /// GameObject's transform. Set to NULL to disable tracking.
+        void track(GameObject* go);
+
+        /// If check is true, visibility is checked from the POV of the GameObject reference
+        /// This is currently done by casting a ray from the GameObject to the candidate GOs
+        void setCheckVisibility(bool check, GameObject* reference = NULL);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        HalfSphereSceneQuery mQuery;
+        bool mCheckVisibility;
+        GameObject* mLoSReferenceGo;
+        GameObject* mTrackedGo;
+
+        virtual const ActorVector&amp; doExecuteQuery();
+
+        virtual void doCreatePrimitive();
+    };
+
+    /// Selects this GameObject within a sphere .
+    class _RlRulesExport SphereSelector : public Selector
+    {
+    public:
+        SphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
+	SphereSelector(unsigned long mask = 0xffffffff);
+
+        virtual void updateSelection();
+
+        void setRadius(Ogre::Real radius);
+
+        void setPosition(const Ogre::Vector3&amp; pos);
+
+        /// Instead of using transform set with setPosition/Orientation, use the
+        /// GameObject's transform. Set to NULL to disable tracking.
+        void track(GameObject* go);
+
+        /// If check is true, visibility is checked from the POV of the GameObject reference
+        /// This is currently done by casting a ray from the GameObject to the candidate GOs
+        void setCheckVisibility(bool check, GameObject* reference = NULL);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        SphereSceneQuery mQuery;
+        bool mCheckVisibility;
+        GameObject* mLoSReferenceGo;
+        GameObject* mTrackedGo;
+
+        virtual const ActorVector&amp; doExecuteQuery();
+
+        virtual void doCreatePrimitive();
+    };
+}
+#endif
+

Modified: rl/trunk/engine/rules/src/Selector.cpp
===================================================================
--- rl/trunk/engine/rules/src/Selector.cpp	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/rules/src/Selector.cpp	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1,422 +1,422 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Selector.h&quot;
-#include &quot;SelectionHelper.h&quot;
-
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;World.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-    CreatureSelectionFilter::CreatureSelectionFilter()
-        : mAlignment(Creature::ALIGNMENT_ALLY |
-                     Creature::ALIGNMENT_NEUTRAL |
-                     Creature::ALIGNMENT_ENEMY)
-    {
-    }
-
-    void CreatureSelectionFilter::setAlignmentMask(unsigned int mask)
-    {
-        mAlignment = mask;
-    }
-
-    bool CreatureSelectionFilter::pass(GameObject* go) const
-    {
-        Creature* creature = dynamic_cast&lt;Creature*&gt;(go);
-        if (creature != NULL)
-        {
-            return (mAlignment &amp; creature-&gt;getAlignment()) != 0;
-        }
-        return false;
-    }
-
-    InSceneSelectionFilter::InSceneSelectionFilter()
-    {
-    }
-
-    bool InSceneSelectionFilter::pass(GameObject* go) const
-    {
-        if (go-&gt;getState() == GOS_IN_SCENE)
-        {
-            return true;
-        }
-        return false;
-    }
-
-    Selector::Selector(unsigned long mask)
-		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
-    {
-    }
-
-    Selector::~Selector()
-    {
-    }
-
-    void Selector::setFilter(SelectionFilter* filter)
-    {
-        mFilter = filter;
-    }
-
-    SelectionFilter* Selector::getFilter() const
-    {
-        return mFilter;
-    }
-
-    void Selector::setSelectionMask(unsigned long mask)
-    {
-        mSelectionMask = mask;
-    }
-
-    unsigned long Selector::getSelectionMask() const
-    {
-        return mSelectionMask;
-    }
-
-    GameObject* Selector::getFirstSelectedObject() const
-    {
-        return mSelection.empty() ? NULL : mSelection[0];
-    }
-
-    const Selector::GameObjectVector&amp; Selector::getAllSelectedObjects() const
-    {
-        return mSelection;
-    }
-
-	unsigned int Selector::getSelectionCount() const
-	{
-		return mSelection.size();
-	}
-
-    void Selector::updateSelection()
-    {
-        // Remove old selection
-        mSelection.clear();
-
-        // Do the query, results are in proper order
-        const ActorVector&amp; actors = doExecuteQuery();
-
-        // Set selection to first result with a GameObject attached.
-        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
-            it != end; ++it)
-        {
-            Actor* actor = *it;
-            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
-            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask) &amp;&amp; filter(go))
-            {
-                mSelection.push_back(go);
-            }
-        }
-    }
-
-    bool Selector::filter(GameObject* go)
-    {
-        return mFilter == NULL || mFilter-&gt;pass(go);
-    }
-
-    //------------------------------------------------------------------------
-
-    RaySelector::RaySelector(unsigned long mask, bool useOgreQuery)
-        : Selector(mask)
-    {
-		if (useOgreQuery)
-		{
-			mQuery = new OgreRaySceneQuery(mask);
-		}
-		else
-		{
-			mQuery = new RaySceneQuery(mask);
-		}
-    }
-
-    void RaySelector::setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end)
-    {
-        mQuery-&gt;setRay(start, end);
-    }
-
-    // Overrides from DebugVisualisable
-    DebugVisualisableFlag RaySelector::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    void RaySelector::updatePrimitive()
-    {
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-        lineSet-&gt;addLine(mQuery-&gt;getRayStart(), mQuery-&gt;getRayEnd(), ColourValue::Red);
-    }
-
-    const ActorVector&amp; RaySelector::doExecuteQuery()
-    {
-        return mQuery-&gt;execute();
-    }
-
-    void RaySelector::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-	RaySelector::~RaySelector()
-	{
-		delete mQuery;
-	}
-
-    //////////////////////////////////////////////////////////////////////////
-
-    HalfSphereSelector::HalfSphereSelector(Ogre::SceneManager* smgr,
-        unsigned long mask)
-        : Selector(mask),
-          mQuery(smgr, mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    HalfSphereSelector::HalfSphereSelector(unsigned long mask)
-        : Selector(mask),
-		  mQuery(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(), mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    void HalfSphereSelector::updateSelection()
-    {
-        // Remove old selection
-        mSelection.clear();
-
-        // Auto tracking enabled?
-        if (mTrackedGo != NULL)
-        {
-            // If not in scene, then we're done
-            if ((mTrackedGo-&gt;getState() &amp; GOS_IN_SCENE) == 0)
-            {
-                return;
-            }
-
-            // Set query transform according to position and orientation of tracked GO.
-            setPosition(mTrackedGo-&gt;getPosition());
-            setOrientation(mTrackedGo-&gt;getOrientation());
-        }
-
-        // Do the query, results are in proper order
-        const ActorVector&amp; actors = doExecuteQuery();
-
-        // Set selection to first result with a GameObject attached.
-        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
-            it != end; ++it)
-        {
-            Actor* actor = *it;
-            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
-            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask))
-            {
-                // Is this GO seen when we need it to be seen?
-                if (mCheckVisibility &amp;&amp; mLoSReferenceGo &amp;&amp;
-                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
-                {
-                    // Nope, check next.
-                    continue;
-                }
-                else if (filter(go))
-                {
-                    // Ok, LoS either not needed or given.
-                    mSelection.push_back(go);
-                }
-            }
-        }
-    }
-
-    void HalfSphereSelector::updatePrimitive()
-    {
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-
-        Vector3 pos = mQuery.getPosition();
-        Quaternion ori = mQuery.getOrientation();
-        Real radius = mQuery.getRadius();
-
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
-            ColourValue::Blue);
-    }
-
-    void HalfSphereSelector::setRadius(Ogre::Real radius)
-    {
-        mQuery.setRadius(radius);
-    }
-
-    void HalfSphereSelector::setPosition(const Ogre::Vector3&amp; pos)
-    {
-        mQuery.setPosition(pos);
-    }
-
-    void HalfSphereSelector::setOrientation(const Ogre::Quaternion&amp; ori)
-    {
-        mQuery.setOrientation(ori);
-    }
-
-    void HalfSphereSelector::setCheckVisibility(bool check, GameObject* reference)
-    {
-        mCheckVisibility = check;
-        mLoSReferenceGo = reference;
-    }
-
-    void HalfSphereSelector::track(GameObject* go)
-    {
-        mTrackedGo = go;
-    }
-
-    DebugVisualisableFlag HalfSphereSelector::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    const ActorVector&amp; HalfSphereSelector::doExecuteQuery()
-    {
-        return mQuery.execute();
-    }
-
-    void HalfSphereSelector::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-    //////////////////////////////////////////////////////////////////////////
-
-    SphereSelector::SphereSelector(Ogre::SceneManager* smgr,
-        unsigned long mask)
-        : Selector(mask),
-          mQuery(smgr, mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    SphereSelector::SphereSelector(unsigned long mask)
-        : Selector(mask),
-		  mQuery(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(), mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    void SphereSelector::updateSelection()
-    {
-        // Remove old selection
-        mSelection.clear();
-
-        // Auto tracking enabled?
-        if (mTrackedGo != NULL)
-        {
-            // If not in scene, then we're done
-            if (!(mTrackedGo-&gt;getState() &amp; GOS_IN_SCENE))
-            {
-                return;
-            }
-
-            // Set query transform according to position and orientation of tracked GO.
-            setPosition(mTrackedGo-&gt;getPosition());
-        }
-
-        // Do the query, results are in proper order
-        const ActorVector&amp; actors = doExecuteQuery();
-
-        // Set selection to first result with a GameObject attached.
-        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
-            it != end; ++it)
-        {
-            Actor* actor = *it;
-            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
-            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask))
-            {
-                // Is this GO seen when we need it to be seen?
-                if (mCheckVisibility &amp;&amp; mLoSReferenceGo &amp;&amp;
-                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
-                {
-                    // Nope, check next.
-                    continue;
-                }
-                else if (filter(go))
-                {
-                    // Ok, LoS either not needed or given.
-                    mSelection.push_back(go);
-                }
-            }
-        }
-    }
-
-    void SphereSelector::updatePrimitive()
-    {
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-
-        Vector3 pos = mQuery.getPosition();
-        Quaternion ori = mQuery.getOrientation();
-        Real radius = mQuery.getRadius();
-
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
-            ColourValue::Blue);
-    }
-
-    void SphereSelector::setRadius(Ogre::Real radius)
-    {
-        mQuery.setRadius(radius);
-    }
-
-    void SphereSelector::setPosition(const Ogre::Vector3&amp; pos)
-    {
-        mQuery.setPosition(pos);
-    }
-
-    void SphereSelector::setCheckVisibility(bool check, GameObject* reference)
-    {
-        mCheckVisibility = check;
-        mLoSReferenceGo = reference;
-    }
-
-    void SphereSelector::track(GameObject* go)
-    {
-        mTrackedGo = go;
-    }
-
-    DebugVisualisableFlag SphereSelector::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    const ActorVector&amp; SphereSelector::doExecuteQuery()
-    {
-        return mQuery.execute();
-    }
-
-    void SphereSelector::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Selector.h&quot;
+#include &quot;SelectionHelper.h&quot;
+
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;World.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+    CreatureSelectionFilter::CreatureSelectionFilter()
+        : mAlignment(Creature::ALIGNMENT_ALLY |
+                     Creature::ALIGNMENT_NEUTRAL |
+                     Creature::ALIGNMENT_ENEMY)
+    {
+    }
+
+    void CreatureSelectionFilter::setAlignmentMask(unsigned int mask)
+    {
+        mAlignment = mask;
+    }
+
+    bool CreatureSelectionFilter::pass(GameObject* go) const
+    {
+        Creature* creature = dynamic_cast&lt;Creature*&gt;(go);
+        if (creature != NULL)
+        {
+            return (mAlignment &amp; creature-&gt;getAlignment()) != 0;
+        }
+        return false;
+    }
+
+    InSceneSelectionFilter::InSceneSelectionFilter()
+    {
+    }
+
+    bool InSceneSelectionFilter::pass(GameObject* go) const
+    {
+        if (go-&gt;getState() == GOS_IN_SCENE)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    Selector::Selector(unsigned long mask)
+		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
+    {
+    }
+
+    Selector::~Selector()
+    {
+    }
+
+    void Selector::setFilter(SelectionFilter* filter)
+    {
+        mFilter = filter;
+    }
+
+    SelectionFilter* Selector::getFilter() const
+    {
+        return mFilter;
+    }
+
+    void Selector::setSelectionMask(unsigned long mask)
+    {
+        mSelectionMask = mask;
+    }
+
+    unsigned long Selector::getSelectionMask() const
+    {
+        return mSelectionMask;
+    }
+
+    GameObject* Selector::getFirstSelectedObject() const
+    {
+        return mSelection.empty() ? NULL : *mSelection.begin();
+    }
+
+    const GameObjectList&amp; Selector::getAllSelectedObjects() const
+    {
+        return mSelection;
+    }
+
+	unsigned int Selector::getSelectionCount() const
+	{
+		return mSelection.size();
+	}
+
+    void Selector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Do the query, results are in proper order
+        const ActorVector&amp; actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
+            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask) &amp;&amp; filter(go))
+            {
+                mSelection.push_back(go);
+            }
+        }
+    }
+
+    bool Selector::filter(GameObject* go)
+    {
+        return mFilter == NULL || mFilter-&gt;pass(go);
+    }
+
+    //------------------------------------------------------------------------
+
+    RaySelector::RaySelector(unsigned long mask, bool useOgreQuery)
+        : Selector(mask)
+    {
+		if (useOgreQuery)
+		{
+			mQuery = new OgreRaySceneQuery(mask);
+		}
+		else
+		{
+			mQuery = new RaySceneQuery(mask);
+		}
+    }
+
+    void RaySelector::setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end)
+    {
+        mQuery-&gt;setRay(start, end);
+    }
+
+    // Overrides from DebugVisualisable
+    DebugVisualisableFlag RaySelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    void RaySelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+        lineSet-&gt;addLine(mQuery-&gt;getRayStart(), mQuery-&gt;getRayEnd(), ColourValue::Red);
+    }
+
+    const ActorVector&amp; RaySelector::doExecuteQuery()
+    {
+        return mQuery-&gt;execute();
+    }
+
+    void RaySelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+	RaySelector::~RaySelector()
+	{
+		delete mQuery;
+	}
+
+    //////////////////////////////////////////////////////////////////////////
+
+    HalfSphereSelector::HalfSphereSelector(Ogre::SceneManager* smgr,
+        unsigned long mask)
+        : Selector(mask),
+          mQuery(smgr, mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    HalfSphereSelector::HalfSphereSelector(unsigned long mask)
+        : Selector(mask),
+		  mQuery(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(), mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    void HalfSphereSelector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Auto tracking enabled?
+        if (mTrackedGo != NULL)
+        {
+            // If not in scene, then we're done
+            if ((mTrackedGo-&gt;getState() &amp; GOS_IN_SCENE) == 0)
+            {
+                return;
+            }
+
+            // Set query transform according to position and orientation of tracked GO.
+            setPosition(mTrackedGo-&gt;getPosition());
+            setOrientation(mTrackedGo-&gt;getOrientation());
+        }
+
+        // Do the query, results are in proper order
+        const ActorVector&amp; actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
+            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask))
+            {
+                // Is this GO seen when we need it to be seen?
+                if (mCheckVisibility &amp;&amp; mLoSReferenceGo &amp;&amp;
+                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
+                {
+                    // Nope, check next.
+                    continue;
+                }
+                else if (filter(go))
+                {
+                    // Ok, LoS either not needed or given.
+                    mSelection.push_back(go);
+                }
+            }
+        }
+    }
+
+    void HalfSphereSelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+
+        Vector3 pos = mQuery.getPosition();
+        Quaternion ori = mQuery.getOrientation();
+        Real radius = mQuery.getRadius();
+
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
+            ColourValue::Blue);
+    }
+
+    void HalfSphereSelector::setRadius(Ogre::Real radius)
+    {
+        mQuery.setRadius(radius);
+    }
+
+    void HalfSphereSelector::setPosition(const Ogre::Vector3&amp; pos)
+    {
+        mQuery.setPosition(pos);
+    }
+
+    void HalfSphereSelector::setOrientation(const Ogre::Quaternion&amp; ori)
+    {
+        mQuery.setOrientation(ori);
+    }
+
+    void HalfSphereSelector::setCheckVisibility(bool check, GameObject* reference)
+    {
+        mCheckVisibility = check;
+        mLoSReferenceGo = reference;
+    }
+
+    void HalfSphereSelector::track(GameObject* go)
+    {
+        mTrackedGo = go;
+    }
+
+    DebugVisualisableFlag HalfSphereSelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    const ActorVector&amp; HalfSphereSelector::doExecuteQuery()
+    {
+        return mQuery.execute();
+    }
+
+    void HalfSphereSelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    //////////////////////////////////////////////////////////////////////////
+
+    SphereSelector::SphereSelector(Ogre::SceneManager* smgr,
+        unsigned long mask)
+        : Selector(mask),
+          mQuery(smgr, mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    SphereSelector::SphereSelector(unsigned long mask)
+        : Selector(mask),
+		  mQuery(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(), mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    void SphereSelector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Auto tracking enabled?
+        if (mTrackedGo != NULL)
+        {
+            // If not in scene, then we're done
+            if (!(mTrackedGo-&gt;getState() &amp; GOS_IN_SCENE))
+            {
+                return;
+            }
+
+            // Set query transform according to position and orientation of tracked GO.
+            setPosition(mTrackedGo-&gt;getPosition());
+        }
+
+        // Do the query, results are in proper order
+        const ActorVector&amp; actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
+            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask))
+            {
+                // Is this GO seen when we need it to be seen?
+                if (mCheckVisibility &amp;&amp; mLoSReferenceGo &amp;&amp;
+                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
+                {
+                    // Nope, check next.
+                    continue;
+                }
+                else if (filter(go))
+                {
+                    // Ok, LoS either not needed or given.
+                    mSelection.push_back(go);
+                }
+            }
+        }
+    }
+
+    void SphereSelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+
+        Vector3 pos = mQuery.getPosition();
+        Quaternion ori = mQuery.getOrientation();
+        Real radius = mQuery.getRadius();
+
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
+            ColourValue::Blue);
+    }
+
+    void SphereSelector::setRadius(Ogre::Real radius)
+    {
+        mQuery.setRadius(radius);
+    }
+
+    void SphereSelector::setPosition(const Ogre::Vector3&amp; pos)
+    {
+        mQuery.setPosition(pos);
+    }
+
+    void SphereSelector::setCheckVisibility(bool check, GameObject* reference)
+    {
+        mCheckVisibility = check;
+        mLoSReferenceGo = reference;
+    }
+
+    void SphereSelector::track(GameObject* go)
+    {
+        mTrackedGo = go;
+    }
+
+    DebugVisualisableFlag SphereSelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    const ActorVector&amp; SphereSelector::doExecuteQuery()
+    {
+        return mQuery.execute();
+    }
+
+    void SphereSelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+}

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/script/swig/RlAi.swig	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1,389 +1,389 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%include std_vector.i
-
-namespace std {
-	%template(Ogrevec3Vector) vector&lt;Ogre::Vector3 &gt;;
-};
-
-namespace rl
-{
-	// Before first use
-	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
-	%apply SWIGTYPE *DYNAMIC { rl::AStarCosts * };
-    %apply SWIGTYPE *DYNAMIC { rl::AgentState* };
-
-	class SteeringVehicle
-	{
-	public:
-        SteeringVehicle(rl::Creature* creature);
-		void addForce(const Ogre::Vector3&amp; force);
-		Ogre::Vector3 calcWander(const float elapsedTime);
-		Ogre::Vector3 calcSeek(const Ogre::Vector3&amp; target);
-		Ogre::Vector3 calcFlee(const Ogre::Vector3&amp; target);
-		Ogre::Vector3 calcPursuit(rl::Agent* agent);
-		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
-		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
-		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
-		float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2);
-		Ogre::Vector3 getPosition();
-		bool isAhead(rl::Agent* agent, const float threshold);
-		bool needAvoidance(const float minTimeToCollision);
-	};
-
-	%feature(&quot;director&quot;) SteeringBehaviour;
-	class SteeringBehaviour
-	{
-	public:
-		SteeringBehaviour();
-		virtual ~SteeringBehaviour();
-		virtual rl::CeGuiString getType()=0;
-		virtual void init()=0;
-		virtual void activate()=0;
-		virtual void deactivate()=0;
-		virtual void update(const float elapsedTime)=0;
-
-		virtual float calculateActivation()=0;
-
-		float getActivationLevel();
-		void setActivationLevel(float activationLevel);
-
-		rl::SteeringBehaviour* getParent();
-		rl::SteeringVehicle* getController();
-	};
-
-	%feature(&quot;director&quot;) AgentState;
-    class AgentState
-    {
-    private:
-        AgentState(rl::Agent* agent);
-    };
-
-
-    class AgentSteeringState : public rl::AgentState
-    {
-    public:
-        void addSteeringBehaviour(SteeringBehaviour* behaviour);
-    };
-
-    class AgentDialogState : public rl::AgentState
-    {
-    public:
-        void setDialogPartner(rl::Agent* partner);
-        void setDialog(rl::Dialog* dialog);
-    private:
-        AgentDialogState(rl::Agent* agent);
-    };
-
-    typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
-
-	class Agent
-	{
-	public:
-		Agent(rl::Creature* character);
-		virtual ~Agent();
-        rl::Creature* getControlledCreature() const;
-        rl::AgentState* getCurrentState() const;
-        void pushState(rl::AgentStateType type);
-	};
-
-	class AiSubsystem
-	{
-	public:
-		static AiSubsystem&amp; getSingleton(void);
-	};
-
-	%feature(&quot;director&quot;) BehaviourFactory;
-    class BehaviourFactory
-    {
-    public:
-        BehaviourFactory();
-        virtual ~BehaviourFactory();
-
-        virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String&amp; classname) = 0;
-    };
-
-	class AgentManager
-	{
-	public:
-		static AgentManager&amp; getSingleton(void);
-		rl::Agent* createAgent(rl::Creature* character);
-
-        virtual void setBehaviourFactory(BehaviourFactory* factory);
-	};
-
-	class AStarHeuristic
-	{
-	public:
-		AStarHeuristic();
-		virtual ~AStarHeuristic();
-		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const = 0;
-	};
-
-	class ManhattanDistance
-		: public rl::AStarHeuristic
-	{
-	public:
-		ManhattanDistance();
-		virtual ~ManhattanDistance();
-		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
-	};
-
-	class DiagonalDistance
-		: public rl::AStarHeuristic
-	{
-	public:
-		DiagonalDistance();
-		virtual ~DiagonalDistance();
-		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
-	};
-
-	class EuclideanDistance
-		: public rl::AStarHeuristic
-	{
-	public:
-		EuclideanDistance();
-		virtual ~EuclideanDistance();
-		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
-	};
-
-	class EuclideanDistanceSquared
-		: public rl::AStarHeuristic
-	{
-	public:
-		EuclideanDistanceSquared();
-		virtual ~EuclideanDistanceSquared();
-		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
-	};
-
-	class AStarCosts
-	{
-	public:
-		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
-		virtual ~AStarCosts();
-		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
-			const rl::AStarWayPointNode* wp2) const = 0;
-	};
-
-	class AStarCostsDefault : public AStarCosts
-	{
-	public:
-		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
-		~AStarCostsDefault();
-		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
-			const rl::AStarWayPointNode* wp2) const;
-	};
-
-	class AStar
-	{
-	public:
-		AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph);
-		//AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
-		//	const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
-		virtual ~AStar();
-
-		void search(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath);
-		void searchFromTo(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath,
-			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
-		void reset();
-	};
-
-    class PhysicalObstacle {
-
-        public:
-            PhysicalObstacle(rl::PhysicalThing *thing);
-            virtual ~PhysicalObstacle();
-
-            OpenSteer::Obstacle *getObstacle() const;
-
-            rl::PhysicalThing *getPhysicalThing() const;
-            void setPhysicalThing(rl::PhysicalThing *thing);
-    };
-
-    class WayPointNode
-	{
-	public:
-		enum WayPointNodeType
-		{
-			WP_UNKNOWN = 0,
-			WP_EXTERIOR = 1,
-			WP_INTERIOR = 2
-		};
-
-		WayPointNode(const Ogre::Vector3&amp; pos, const rl::WayPointNode::WayPointNodeType type);
-		Ogre::Vector3 getPosition() const;
-	};
-
-	class WayPointGraph
-	{
-	public:
-		WayPointNode* addWayPoint(const Ogre::Vector3&amp; position, const WayPointNode::WayPointNodeType type);
-		void addConnection(rl::WayPointNode* wp1, rl::WayPointNode* wp2);
-		void addDirectedConnection(rl::WayPointNode* wp1, const rl::WayPointNode* wp2);
-		void load(const Ogre::String&amp; filename);
-		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3&amp; position) const;
-		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
-	};
-
-	class WayPointGraphManager
-	{
-	public:
-		static WayPointGraphManager&amp; getSingleton(void);
-		rl::WayPointGraph* createWayPointGraph();
-	};
-
-	class Landmark
-	{
-	public:
-		Landmark(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
-		const Ogre::String&amp; getName() const;
-		const Ogre::Vector3&amp; getPosition() const;
-	};
-
-	class LandmarkPath
-	{
-	public:
-        typedef std::deque&lt;rl::Landmark*&gt; LandmarkList;
-		LandmarkPath(const Ogre::String&amp; name);
-
-		void addPoint(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
-		void addPoint(rl::Landmark* lm);
-        rl::LandmarkPath::LandmarkList getPoints();
-	};
-
-    class WalkPathBehaviour : public rl::SteeringBehaviour
-	{
-	public:
-	    WalkPathBehaviour();
-		virtual ~WalkPathBehaviour();
-		void calcPathToLandmark(rl::Landmark* lm, const rl::WayPointGraph* wps);
-		void setLandmarkPath(LandmarkPath* lmp);
-		virtual rl::CeGuiString getType();
-		virtual void init();
-		virtual void activate();
-		virtual void deactivate();
-		virtual void update(const float elapsedTime);
-
-		virtual float calculateActivation();
-	};
-
-	class CreatureWalkPathJob : public Job
-    {
-    public:
-        CreatureWalkPathJob(const Ogre::String&amp; name, rl::Creature* movingCreature, rl::Landmark* startLandmark);
-
-        void addLandmark(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
-        void addLandmark(rl::Landmark* lm);
-        void setWayPoints(const rl::WayPointGraph* wps);
-    };
-
-    class Dialog
-    {
-    private:
-        Dialog(rl::Creature* npc, rl::Creature* pc);
-    };
-
-    class DialogManager
-    {
-    public:
-        static rl::DialogManager&amp; getSingleton();
-        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc);
-        rl::Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;rl::Creature*&gt;&amp; npcs);
-    private:
-        DialogManager();
-    };
-} // Namespace
-
-%{
-static swig_type_info *AStarHeuristic_dynamic_cast(void **ptr)
-{
-    rl::AStarHeuristic *pAStarHeuristic = static_cast&lt;rl::AStarHeuristic*&gt;(*ptr);
-
-    rl::ManhattanDistance *pManhattanDistance=dynamic_cast&lt;rl::ManhattanDistance*&gt;(pAStarHeuristic);
-    if (pManhattanDistance)
-    {
-        *ptr=pManhattanDistance;
-        return SWIGTYPE_p_rl__ManhattanDistance;
-    }
-    rl::DiagonalDistance *pDiagonalDistance=dynamic_cast&lt;rl::DiagonalDistance*&gt;(pAStarHeuristic);
-    if (pDiagonalDistance)
-    {
-        *ptr=pDiagonalDistance;
-        return SWIGTYPE_p_rl__DiagonalDistance;
-    }
-    rl::EuclideanDistance *pEuclideanDistance=dynamic_cast&lt;rl::EuclideanDistance*&gt;(pAStarHeuristic);
-    if (pEuclideanDistance)
-    {
-        *ptr=pEuclideanDistance;
-        return SWIGTYPE_p_rl__EuclideanDistance;
-    }
-    rl::EuclideanDistanceSquared *pEuclideanDistanceSquared=dynamic_cast&lt;rl::EuclideanDistanceSquared*&gt;(pAStarHeuristic);
-    if (pEuclideanDistanceSquared)
-    {
-        *ptr=pEuclideanDistanceSquared;
-        return SWIGTYPE_p_rl__EuclideanDistanceSquared;
-    }
-
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__AStarHeuristic, AStarHeuristic_dynamic_cast);
-
-
-%{
-static swig_type_info *AStarCosts_dynamic_cast(void **ptr)
-{
-    rl::AStarCosts *pAStarCosts = static_cast&lt;rl::AStarCosts*&gt;(*ptr);
-
-    rl::AStarCostsDefault *pAStarCostsDefault=dynamic_cast&lt;rl::AStarCostsDefault*&gt;(pAStarCosts);
-    if (pAStarCostsDefault)
-    {
-        *ptr=pAStarCostsDefault;
-        return SWIGTYPE_p_rl__AStarCostsDefault;
-    }
-
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__AStarCosts, AStarCosts_dynamic_cast);
-
-
-%{
-static swig_type_info *AgentState_dynamic_cast(void **ptr)
-{
-    rl::AgentState *pAgentState = static_cast&lt;rl::AgentState*&gt;(*ptr);
-
-    rl::AgentDialogState *pAgentDialogState=dynamic_cast&lt;rl::AgentDialogState*&gt;(pAgentState);
-    if (pAgentDialogState)
-    {
-        *ptr=pAgentDialogState;
-        return SWIGTYPE_p_rl__AgentDialogState;
-    }
-
-    rl::AgentSteeringState *pAgentSteeringState = dynamic_cast&lt;rl::AgentSteeringState*&gt;(pAgentState);
-    if (pAgentSteeringState)
-    {
-        *ptr=pAgentSteeringState;
-        return SWIGTYPE_p_rl__AgentSteeringState;
-    }
-
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__AgentState, AgentState_dynamic_cast);
-
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%include std_vector.i
+
+namespace std {
+	%template(Ogrevec3Vector) vector&lt;Ogre::Vector3 &gt;;
+};
+
+namespace rl
+{
+	// Before first use
+	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
+	%apply SWIGTYPE *DYNAMIC { rl::AStarCosts * };
+    %apply SWIGTYPE *DYNAMIC { rl::AgentState* };
+
+	class SteeringVehicle
+	{
+	public:
+        SteeringVehicle(rl::Creature* creature);
+		void addForce(const Ogre::Vector3&amp; force);
+		Ogre::Vector3 calcWander(const float elapsedTime);
+		Ogre::Vector3 calcSeek(const Ogre::Vector3&amp; target);
+		Ogre::Vector3 calcFlee(const Ogre::Vector3&amp; target);
+		Ogre::Vector3 calcPursuit(rl::Agent* agent);
+		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
+		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
+		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
+		float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2);
+		Ogre::Vector3 getPosition();
+		bool isAhead(rl::Agent* agent, const float threshold);
+		bool needAvoidance(const float minTimeToCollision);
+	};
+
+	%feature(&quot;director&quot;) SteeringBehaviour;
+	class SteeringBehaviour
+	{
+	public:
+		SteeringBehaviour();
+		virtual ~SteeringBehaviour();
+		virtual rl::CeGuiString getType()=0;
+		virtual void init()=0;
+		virtual void activate()=0;
+		virtual void deactivate()=0;
+		virtual void update(const float elapsedTime)=0;
+
+		virtual float calculateActivation()=0;
+
+		float getActivationLevel();
+		void setActivationLevel(float activationLevel);
+
+		rl::SteeringBehaviour* getParent();
+		rl::SteeringVehicle* getController();
+	};
+
+	%feature(&quot;director&quot;) AgentState;
+    class AgentState
+    {
+    private:
+        AgentState(rl::Agent* agent);
+    };
+
+
+    class AgentSteeringState : public rl::AgentState
+    {
+    public:
+        void addSteeringBehaviour(SteeringBehaviour* behaviour);
+    };
+
+    class AgentDialogState : public rl::AgentState
+    {
+    public:
+        void addDialogPartner(rl::Agent* partner);
+        void setDialog(rl::Dialog* dialog);
+    private:
+        AgentDialogState(rl::Agent* agent);
+    };
+
+    typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
+
+	class Agent
+	{
+	public:
+		Agent(rl::Creature* character);
+		virtual ~Agent();
+        rl::Creature* getControlledCreature() const;
+        rl::AgentState* getCurrentState() const;
+        void pushState(rl::AgentStateType type);
+	};
+
+	class AiSubsystem
+	{
+	public:
+		static AiSubsystem&amp; getSingleton(void);
+	};
+
+	%feature(&quot;director&quot;) BehaviourFactory;
+    class BehaviourFactory
+    {
+    public:
+        BehaviourFactory();
+        virtual ~BehaviourFactory();
+
+        virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String&amp; classname) = 0;
+    };
+
+	class AgentManager
+	{
+	public:
+		static AgentManager&amp; getSingleton(void);
+		rl::Agent* createAgent(rl::Creature* character);
+
+        virtual void setBehaviourFactory(BehaviourFactory* factory);
+	};
+
+	class AStarHeuristic
+	{
+	public:
+		AStarHeuristic();
+		virtual ~AStarHeuristic();
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const = 0;
+	};
+
+	class ManhattanDistance
+		: public rl::AStarHeuristic
+	{
+	public:
+		ManhattanDistance();
+		virtual ~ManhattanDistance();
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+	class DiagonalDistance
+		: public rl::AStarHeuristic
+	{
+	public:
+		DiagonalDistance();
+		virtual ~DiagonalDistance();
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+	class EuclideanDistance
+		: public rl::AStarHeuristic
+	{
+	public:
+		EuclideanDistance();
+		virtual ~EuclideanDistance();
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+	class EuclideanDistanceSquared
+		: public rl::AStarHeuristic
+	{
+	public:
+		EuclideanDistanceSquared();
+		virtual ~EuclideanDistanceSquared();
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+	class AStarCosts
+	{
+	public:
+		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
+		virtual ~AStarCosts();
+		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
+			const rl::AStarWayPointNode* wp2) const = 0;
+	};
+
+	class AStarCostsDefault : public AStarCosts
+	{
+	public:
+		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
+		~AStarCostsDefault();
+		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
+			const rl::AStarWayPointNode* wp2) const;
+	};
+
+	class AStar
+	{
+	public:
+		AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph);
+		//AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
+		//	const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
+		virtual ~AStar();
+
+		void search(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath);
+		void searchFromTo(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath,
+			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
+		void reset();
+	};
+
+    class PhysicalObstacle {
+
+        public:
+            PhysicalObstacle(rl::PhysicalThing *thing);
+            virtual ~PhysicalObstacle();
+
+            OpenSteer::Obstacle *getObstacle() const;
+
+            rl::PhysicalThing *getPhysicalThing() const;
+            void setPhysicalThing(rl::PhysicalThing *thing);
+    };
+
+    class WayPointNode
+	{
+	public:
+		enum WayPointNodeType
+		{
+			WP_UNKNOWN = 0,
+			WP_EXTERIOR = 1,
+			WP_INTERIOR = 2
+		};
+
+		WayPointNode(const Ogre::Vector3&amp; pos, const rl::WayPointNode::WayPointNodeType type);
+		Ogre::Vector3 getPosition() const;
+	};
+
+	class WayPointGraph
+	{
+	public:
+		WayPointNode* addWayPoint(const Ogre::Vector3&amp; position, const WayPointNode::WayPointNodeType type);
+		void addConnection(rl::WayPointNode* wp1, rl::WayPointNode* wp2);
+		void addDirectedConnection(rl::WayPointNode* wp1, const rl::WayPointNode* wp2);
+		void load(const Ogre::String&amp; filename);
+		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3&amp; position) const;
+		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
+	};
+
+	class WayPointGraphManager
+	{
+	public:
+		static WayPointGraphManager&amp; getSingleton(void);
+		rl::WayPointGraph* createWayPointGraph();
+	};
+
+	class Landmark
+	{
+	public:
+		Landmark(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
+		const Ogre::String&amp; getName() const;
+		const Ogre::Vector3&amp; getPosition() const;
+	};
+
+	class LandmarkPath
+	{
+	public:
+        typedef std::deque&lt;rl::Landmark*&gt; LandmarkList;
+		LandmarkPath(const Ogre::String&amp; name);
+
+		void addPoint(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
+		void addPoint(rl::Landmark* lm);
+        rl::LandmarkPath::LandmarkList getPoints();
+	};
+
+    class WalkPathBehaviour : public rl::SteeringBehaviour
+	{
+	public:
+	    WalkPathBehaviour();
+		virtual ~WalkPathBehaviour();
+		void calcPathToLandmark(rl::Landmark* lm, const rl::WayPointGraph* wps);
+		void setLandmarkPath(LandmarkPath* lmp);
+		virtual rl::CeGuiString getType();
+		virtual void init();
+		virtual void activate();
+		virtual void deactivate();
+		virtual void update(const float elapsedTime);
+
+		virtual float calculateActivation();
+	};
+
+	class CreatureWalkPathJob : public Job
+    {
+    public:
+        CreatureWalkPathJob(const Ogre::String&amp; name, rl::Creature* movingCreature, rl::Landmark* startLandmark);
+
+        void addLandmark(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
+        void addLandmark(rl::Landmark* lm);
+        void setWayPoints(const rl::WayPointGraph* wps);
+    };
+
+    class Dialog
+    {
+    private:
+        Dialog(rl::Creature* npc, rl::Creature* pc);
+    };
+
+    class DialogManager
+    {
+    public:
+        static rl::DialogManager&amp; getSingleton();
+        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc);
+        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::CreatureList&amp; npcs);
+    private:
+        DialogManager();
+    };
+} // Namespace
+
+%{
+static swig_type_info *AStarHeuristic_dynamic_cast(void **ptr)
+{
+    rl::AStarHeuristic *pAStarHeuristic = static_cast&lt;rl::AStarHeuristic*&gt;(*ptr);
+
+    rl::ManhattanDistance *pManhattanDistance=dynamic_cast&lt;rl::ManhattanDistance*&gt;(pAStarHeuristic);
+    if (pManhattanDistance)
+    {
+        *ptr=pManhattanDistance;
+        return SWIGTYPE_p_rl__ManhattanDistance;
+    }
+    rl::DiagonalDistance *pDiagonalDistance=dynamic_cast&lt;rl::DiagonalDistance*&gt;(pAStarHeuristic);
+    if (pDiagonalDistance)
+    {
+        *ptr=pDiagonalDistance;
+        return SWIGTYPE_p_rl__DiagonalDistance;
+    }
+    rl::EuclideanDistance *pEuclideanDistance=dynamic_cast&lt;rl::EuclideanDistance*&gt;(pAStarHeuristic);
+    if (pEuclideanDistance)
+    {
+        *ptr=pEuclideanDistance;
+        return SWIGTYPE_p_rl__EuclideanDistance;
+    }
+    rl::EuclideanDistanceSquared *pEuclideanDistanceSquared=dynamic_cast&lt;rl::EuclideanDistanceSquared*&gt;(pAStarHeuristic);
+    if (pEuclideanDistanceSquared)
+    {
+        *ptr=pEuclideanDistanceSquared;
+        return SWIGTYPE_p_rl__EuclideanDistanceSquared;
+    }
+
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AStarHeuristic, AStarHeuristic_dynamic_cast);
+
+
+%{
+static swig_type_info *AStarCosts_dynamic_cast(void **ptr)
+{
+    rl::AStarCosts *pAStarCosts = static_cast&lt;rl::AStarCosts*&gt;(*ptr);
+
+    rl::AStarCostsDefault *pAStarCostsDefault=dynamic_cast&lt;rl::AStarCostsDefault*&gt;(pAStarCosts);
+    if (pAStarCostsDefault)
+    {
+        *ptr=pAStarCostsDefault;
+        return SWIGTYPE_p_rl__AStarCostsDefault;
+    }
+
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AStarCosts, AStarCosts_dynamic_cast);
+
+
+%{
+static swig_type_info *AgentState_dynamic_cast(void **ptr)
+{
+    rl::AgentState *pAgentState = static_cast&lt;rl::AgentState*&gt;(*ptr);
+
+    rl::AgentDialogState *pAgentDialogState=dynamic_cast&lt;rl::AgentDialogState*&gt;(pAgentState);
+    if (pAgentDialogState)
+    {
+        *ptr=pAgentDialogState;
+        return SWIGTYPE_p_rl__AgentDialogState;
+    }
+
+    rl::AgentSteeringState *pAgentSteeringState = dynamic_cast&lt;rl::AgentSteeringState*&gt;(pAgentState);
+    if (pAgentSteeringState)
+    {
+        *ptr=pAgentSteeringState;
+        return SWIGTYPE_p_rl__AgentSteeringState;
+    }
+
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AgentState, AgentState_dynamic_cast);
+
+

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/script/swig/RlExports.i	2009-03-15 22:21:28 UTC (rev 4834)
@@ -197,13 +197,17 @@
 // da dies in allen erzeugten Exceptionhandlern auftritt
 %{
 #pragma warning( disable : 4101 )									
+#include &quot;FixRubyHeaders.h&quot;
 %}
 
 // Include bodies
 
 %include &quot;RlCommon.swig&quot;
 %include &quot;RlCore.swig&quot;
+%include &quot;RlUi.swig&quot;
 %include &quot;RlRules.swig&quot;
-%include &quot;RlUi.swig&quot;
 %include &quot;RlAi.swig&quot;
+%{
+    #include &quot;FixRubyHeaders.h&quot;
+%}
 %include &quot;RlScript.swig&quot;

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/script/swig/RlRules.swig	2009-03-15 22:21:28 UTC (rev 4834)
@@ -119,7 +119,7 @@
         GameObjectFactory();
         virtual ~GameObjectFactory();
     };
-
+    
     class GameObjectManager
     {
     public:
@@ -127,7 +127,7 @@
         rl::GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
         rl::GameObject* getGameObject(unsigned int id) const;
         void setGameObjectFactory(rl::GameObjectFactory* gof);
-        std::list&lt;rl::GameObject*&gt; getAllGameObjects();
+        rl::GameObjectList getAllGameObjects();
 
     private:
         GameObjectManager();
@@ -877,7 +877,7 @@
         unsigned long getSelectionMask() const;
 
         GameObject* getFirstSelectedObject() const;
-		const std::vector&lt;GameObject*&gt;&amp; getAllSelectedObjects() const;
+		const rl::GameObjectList&amp; getAllSelectedObjects() const;
 		unsigned int getSelectionCount() const;
 
 		virtual void updatePrimitive() = 0;

Modified: rl/trunk/engine/script/swig/TypeDynamicDirector.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeDynamicDirector.swig	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/script/swig/TypeDynamicDirector.swig	2009-03-15 22:21:28 UTC (rev 4834)
@@ -1,90 +1,90 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Typemaps for all Dynamic or Director Types
- * These typemaps ensure no C++ object 
- * will have links to more than one Ruby objecz
- * 
- */
-
-%{
-static VALUE getInScriptObject( void* ptr, swig_type_info *type )
-{
-    VALUE val = SWIG_RubyInstanceFor( ptr );
-	
-	// Es gab das SkriptObjekt noch nicht
-	if( NIL_P(val) ) 
-		return SWIG_NewPointerObj(ptr, type, 0);			
-	else	
-		return val;
-}
-%}
-
-/// @todo unbenutzt???
-// Actor* getActor oder andere OUTPUT Parameter
-%typemap(out) SWIGTYPE*
-&quot;   $result = getInScriptObject((void *) $1, $1_descriptor );&quot; 
-
-%{
-static VALUE getDirectorInScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
-{
-    // Auf Director testen
-    if ( dir ) 
-        return dir-&gt;swig_get_self();
-
-	return getInScriptObject( ptr, type );
-}
-%}
-
-/// @todo unbenutzt???
-// doWithActor( Actor* ) oder andere Director-Methoden Parameter
-%typemap(directorin) SWIGTYPE*
-&quot;   $input = getDirectorInScriptObject(dynamic_cast&lt; Swig::Director * &gt;($1), (void *)$1, $1_descriptor);&quot; 
-
-%{
-static VALUE getOutScriptObject( void* ptr, swig_type_info *type )
-{
-	VALUE val = SWIG_RubyInstanceFor( ptr );
-	
-	// Es gab das SkriptObjekt noch nicht
-	if (NIL_P(val))
-	{
-		// Dynamic Cast ausfhren
-		swig_type_info *ty = SWIG_TypeDynamicCast(type, &amp;ptr);
-		return SWIG_NewPointerObj( ptr, ty, 0);		
-	}
-	else	
-		return val;
-}
-%}
-
-// Animation* getActor oder andere OUTPUT Parameter f&#252;r DYNAMICs
-%typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
-&quot;   $result = getOutScriptObject((void *) $1, $1_descriptor );&quot;
-
-%{
-static VALUE getDirectorOutScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
-{
-	if (dir) 
-        return dir-&gt;swig_get_self();        	
-
-	return getOutScriptObject( ptr, type );
-}
-%}
-
-// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
-%typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Typemaps for all Dynamic or Director Types
+ * These typemaps ensure no C++ object 
+ * will have links to more than one Ruby objecz
+ * 
+ */
+
+%{
+static VALUE getInScriptObject( void* ptr, swig_type_info *type )
+{
+    VALUE val = SWIG_RubyInstanceFor( ptr );
+	
+	// Es gab das SkriptObjekt noch nicht
+	if( NIL_P(val) ) 
+		return SWIG_NewPointerObj(ptr, type, 0);			
+	else	
+		return val;
+}
+%}
+
+/// @todo unbenutzt???
+// Actor* getActor oder andere OUTPUT Parameter
+%typemap(out) SWIGTYPE*
+&quot;   $result = getInScriptObject((void *) $1, $1_descriptor );&quot; 
+
+%{
+static VALUE getDirectorInScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
+{
+    // Auf Director testen
+    if ( dir ) 
+        return dir-&gt;swig_get_self();
+
+	return getInScriptObject( ptr, type );
+}
+%}
+
+/// @todo unbenutzt???
+// doWithActor( Actor* ) oder andere Director-Methoden Parameter
+%typemap(directorin) SWIGTYPE*
+&quot;   $input = getDirectorInScriptObject(dynamic_cast&lt; Swig::Director * &gt;($1), (void *)$1, $1_descriptor);&quot; 
+
+%{
+static VALUE getOutScriptObject( void* ptr, swig_type_info *type )
+{
+	VALUE val = SWIG_RubyInstanceFor( ptr );
+	
+	// Es gab das SkriptObjekt noch nicht
+	if (NIL_P(val))
+	{
+		// Dynamic Cast ausfhren
+		swig_type_info *ty = SWIG_TypeDynamicCast(type, &amp;ptr);
+		return SWIG_NewPointerObj( ptr, ty, 0);		
+	}
+	else	
+		return val;
+}
+%}
+
+// Animation* getActor oder andere OUTPUT Parameter f&#194;&#184;r DYNAMICs
+%typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
+&quot;   $result = getOutScriptObject((void *) $1, $1_descriptor );&quot;
+
+%{
+static VALUE getDirectorOutScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
+{
+	if (dir) 
+        return dir-&gt;swig_get_self();        	
+
+	return getOutScriptObject( ptr, type );
+}
+%}
+
+// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
+%typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
 &quot;   $input = getDirectorOutScriptObject(dynamic_cast&lt; Swig::Director * &gt;($1), (void *) $1, $1_descriptor );&quot; 
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/TypeMaps.i
===================================================================
--- rl/trunk/engine/script/swig/TypeMaps.i	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/script/swig/TypeMaps.i	2009-03-15 22:21:28 UTC (rev 4834)
@@ -17,6 +17,7 @@
 #ifndef __RL_DYNAMICCAST_I__
 #define __RL_DYNAMICCAST_I__
 
+%include &quot;TypeDynamicDirector.swig&quot;
 %include &quot;TypeOgreColourValue.swig&quot;
 %include &quot;TypeOgreQuaternion.swig&quot;
 %include &quot;TypeOgreRadian.swig&quot;
@@ -26,9 +27,9 @@
 %include &quot;TypeOgreVector3.swig&quot;
 %include &quot;TypeRlCeGuiString.swig&quot;
 %include &quot;TypeRlCeGuiStringVector.swig&quot;
+%include &quot;TypeRlGameObjectList.swig&quot;
 %include &quot;TypeRlProperty.swig&quot;
 %include &quot;TypeRlPropertyKeys.swig&quot;
 %include &quot;TypeStdPairIntInt.swig&quot;
-%include &quot;TypeDynamicDirector.swig&quot;
 
 #endif

Added: rl/trunk/engine/script/swig/TypeRlGameObjectList.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlGameObjectList.swig	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/script/swig/TypeRlGameObjectList.swig	2009-03-15 22:21:28 UTC (rev 4834)
@@ -0,0 +1,185 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+void convertRubyToRlGameObjectList(VALUE input, rl::GameObjectList&amp; vec)
+{
+  Check_Type(input, T_ARRAY);
+  int len = RARRAY(input)-&gt;len;
+  for (int i=0; i!=len; i++) 
+  {
+    VALUE inst = rb_ary_entry(input, i);
+    void* go = NULL;
+    int result = SWIG_ConvertPtr(inst, &amp;go, SWIGTYPE_p_rl__GameObject, 0 |  0 );
+    if (SWIG_IsOK(result)) {
+        vec.push_back(static_cast&lt;rl::GameObject*&gt;(go));
+    }
+  }
+}
+
+VALUE convertGameObjectListToRuby(const rl::GameObjectList&amp; vec)
+{
+  VALUE arr = rb_ary_new2(vec.size()); 
+  for (rl::GameObjectList::const_iterator i = vec.begin(), iend = vec.end() ; i!=iend; i++ )
+  {
+    rl::GameObject* go = *i;
+    VALUE goVal = getDirectorInScriptObject(dynamic_cast&lt;Swig::Director*&gt;(go), go, SWIGTYPE_p_rl__GameObject);
+    rb_ary_push(arr, goVal);
+  }
+  return arr;
+}
+
+static int checkRubyGameObjectList( VALUE input ) 
+{
+	bool correct = false;
+
+	if (TYPE(input) == T_ARRAY)
+	{
+        correct = true;
+	}
+	
+    return (correct ? 1 : 0);
+}
+
+void convertRubyToCreatureList(VALUE input, rl::CreatureList&amp; vec)
+{
+  Check_Type(input, T_ARRAY);
+  int len = RARRAY(input)-&gt;len;
+  for (int i=0; i!=len; i++) 
+  {
+    VALUE inst = rb_ary_entry(input, i);
+    void* go = NULL;
+    int result = SWIG_ConvertPtr(inst, &amp;go, SWIGTYPE_p_rl__Creature, 0 |  0 );
+    if (SWIG_IsOK(result)) {
+        vec.push_back(static_cast&lt;rl::Creature*&gt;(go));
+    }
+  }
+}
+
+VALUE convertCreatureListToRuby(const rl::CreatureList&amp; vec)
+{
+  VALUE arr = rb_ary_new2(vec.size()); 
+  for (rl::CreatureList::const_iterator i = vec.begin(), iend = vec.end() ; i!=iend; i++ )
+  {
+    rl::Creature* go = *i;
+    VALUE goVal = getDirectorInScriptObject(dynamic_cast&lt;Swig::Director*&gt;(go), go, SWIGTYPE_p_rl__Creature);
+    rb_ary_push(arr, goVal);
+  }
+  return arr;
+}
+
+%}
+
+
+%typemap(typecheck)  
+   rl::GameObjectList, const rl::GameObjectList, 
+   rl::GameObjectList*, rl::GameObjectList&amp;,
+   const rl::GameObjectList*, const rl::GameObjectList&amp; 
+%{
+	$1 = checkRubyGameObjectList($input);	
+%}
+
+%typemap(freearg) rl::GameObjectList &amp;, const rl::GameObjectList &amp; 
+    &quot;delete $1;&quot;
+
+%typemap(out) rl::GameObjectList, const rl::GameObjectList 
+%{
+  $result = convertGameObjectListToRuby($1); 
+%}
+%typemap(out) rl::GameObjectList&amp;, const rl::GameObjectList&amp;, rl::GameObjectList*, const rl::GameObjectList* 
+%{
+  $result = convertGameObjectListToRuby(*$1); 
+%}
+
+%typemap(in) rl::GameObjectList , const rl::GameObjectList 
+%{
+  convertRubyToGameObjectList($input, $1);
+%}
+%typemap(in) rl::GameObjectList&amp;, const rl::GameObjectList&amp;, rl::GameObjectList*, const rl::GameObjectList*
+%{
+    $1 = new rl::GameObjectList();
+    convertRubyToGameObjectList($input, *$1);
+%}
+
+%typemap(directorin) rl::GameObjectList &amp;, const rl::GameObjectList &amp;
+%{
+  $result = convertGameObjectListToRuby(*$1); 
+%}
+%typemap(directorin) rl::GameObjectList, const rl::GameObjectList 
+%{
+  $result = convertGameObjectListToRuby($1);
+%}
+
+%typemap(directorout) rl::GameObjectList , const rl::GameObjectList 
+%{
+  convertRubyToGameObjectList($input, $result);
+%}
+
+%typemap(directorout) rl::GameObjectList *, const rl::GameObjectList* , rl::GameObjectList &amp;, const rl::GameObjectList&amp; 
+%{
+  $result = new rl::GameObjectList();
+  convertRubyToGameObjectList($input, *$result);
+%}
+
+%typemap(typecheck)  
+   rl::CreatureList, const rl::CreatureList, 
+   rl::CreatureList*, rl::CreatureList&amp;,
+   const rl::CreatureList*, const rl::CreatureList&amp; 
+%{
+	$1 = checkRubyGameObjectList($input);	
+%}
+
+%typemap(freearg) rl::CreatureList &amp;, const rl::CreatureList &amp; 
+    &quot;delete $1;&quot;
+
+%typemap(out) rl::CreatureList, const rl::CreatureList 
+%{
+  $result = convertCreatureListToRuby($1); 
+%}
+%typemap(out) rl::CreatureList&amp;, const rl::CreatureList&amp;, rl::CreatureList*, const rl::CreatureList* 
+%{
+  $result = convertCreatureListToRuby(*$1); 
+%}
+
+%typemap(in) rl::CreatureList , const rl::CreatureList 
+%{
+  convertRubyToCreatureList($input, $1);
+%}
+%typemap(in) rl::CreatureList&amp;, const rl::CreatureList&amp;, rl::CreatureList*, const rl::CreatureList*
+%{
+    $1 = new rl::CreatureList();
+    convertRubyToCreatureList($input, *$1);
+%}
+
+%typemap(directorin) rl::CreatureList &amp;, const rl::CreatureList &amp;
+%{
+  $result = convertCreatureListToRuby(*$1); 
+%}
+%typemap(directorin) rl::CreatureList, const rl::CreatureList 
+%{
+  $result = convertCreatureListToRuby($1);
+%}
+
+%typemap(directorout) rl::CreatureList , const rl::CreatureList 
+%{
+  convertRubyToCreatureList($input, $result);
+%}
+
+%typemap(directorout) rl::CreatureList *, const rl::CreatureList* , rl::CreatureList &amp;, const rl::CreatureList&amp; 
+%{
+  $result = new rl::CreatureList();
+  convertRubyToCreatureList($input, *$result);
+%}

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2009-03-15 22:21:28 UTC (rev 4834)
@@ -62,7 +62,8 @@
         : DialogController(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
-        mDialogMode(DM_FRONT)
+        mDialogMode(DM_FRONT),
+        mDialogWindow(NULL)
     {
     }
 

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-03-15 22:16:34 UTC (rev 4833)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-03-15 22:21:28 UTC (rev 4834)
@@ -458,14 +458,14 @@
 
 		mMouseSelector-&gt;setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
 		mMouseSelector-&gt;updateSelection();
-		Selector::GameObjectVector objs = mMouseSelector-&gt;getAllSelectedObjects();
+		GameObjectList objs = mMouseSelector-&gt;getAllSelectedObjects();
 
 		///@todo select, ...
 		if (!objs.empty())
 		{
 			LOG_MESSAGE(Logger::UI,
 				&quot;Selected &quot;+Ogre::StringConverter::toString(objs.size())+&quot; items.&quot;);
-			for (Selector::GameObjectVector::const_iterator it = objs.begin();
+			for (GameObjectList::const_iterator it = objs.begin();
 				it != objs.end(); ++it)
 			{
                 if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )
@@ -528,8 +528,8 @@
 				sel.setRadius(10.0);
 
 				sel.updateSelection();
-				Selector::GameObjectVector v = sel.getAllSelectedObjects();
-				for (Selector::GameObjectVector::iterator
+				GameObjectList v = sel.getAllSelectedObjects();
+				for (GameObjectList::iterator
 					it = v.begin(); it != v.end(); ++it)
 				{
                     if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001890.html">[Dsa-hl-svn] r4833 - rl/trunk/engine/common/include
</A></li>
	<LI>Next message: <A HREF="001892.html">[Dsa-hl-svn] r4835 - rl/trunk/engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1891">[ date ]</a>
              <a href="thread.html#1891">[ thread ]</a>
              <a href="subject.html#1891">[ subject ]</a>
              <a href="author.html#1891">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
