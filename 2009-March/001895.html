<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4838 - in dependencies/OgreNewt: inc src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4838%20-%20in%20dependencies/OgreNewt%3A%20inc%20src&In-Reply-To=%3C200903171336.n2HDaJYB009497%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001894.html">
   <LINK REL="Next"  HREF="001896.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4838 - in dependencies/OgreNewt: inc src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4838%20-%20in%20dependencies/OgreNewt%3A%20inc%20src&In-Reply-To=%3C200903171336.n2HDaJYB009497%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4838 - in dependencies/OgreNewt: inc src">melven at mail.berlios.de
       </A><BR>
    <I>Tue Mar 17 14:36:19 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001894.html">[Dsa-hl-svn] r4837 - in rl/trunk/editors/Lockenwickler/src: .	media/icons
</A></li>
        <LI>Next message: <A HREF="001896.html">[Dsa-hl-svn] r4839 - rl/trunk/editors/Lockenwickler/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1895">[ date ]</a>
              <a href="thread.html#1895">[ thread ]</a>
              <a href="subject.html#1895">[ subject ]</a>
              <a href="author.html#1895">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2009-03-17 14:36:05 +0100 (Tue, 17 Mar 2009)
New Revision: 4838

Modified:
   dependencies/OgreNewt/inc/OgreNewt.h
   dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h
   dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h
   dependencies/OgreNewt/inc/OgreNewt_Body.h
   dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h
   dependencies/OgreNewt/inc/OgreNewt_Collision.h
   dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h
   dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h
   dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h
   dependencies/OgreNewt/inc/OgreNewt_Debugger.h
   dependencies/OgreNewt/inc/OgreNewt_Joint.h
   dependencies/OgreNewt/inc/OgreNewt_MaterialID.h
   dependencies/OgreNewt/inc/OgreNewt_MaterialPair.h
   dependencies/OgreNewt/inc/OgreNewt_PlayerController.h
   dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h
   dependencies/OgreNewt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt/inc/OgreNewt_Tools.h
   dependencies/OgreNewt/inc/OgreNewt_Vehicle.h
   dependencies/OgreNewt/inc/OgreNewt_World.h
   dependencies/OgreNewt/src/OgreNewt_BasicFrameListener.cpp
   dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp
   dependencies/OgreNewt/src/OgreNewt_Body.cpp
   dependencies/OgreNewt/src/OgreNewt_Collision.cpp
   dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp
   dependencies/OgreNewt/src/OgreNewt_ContactJoint.cpp
   dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
   dependencies/OgreNewt/src/OgreNewt_Joint.cpp
   dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp
   dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp
   dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
   dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
   dependencies/OgreNewt/src/OgreNewt_Tools.cpp
   dependencies/OgreNewt/src/OgreNewt_Vehicle.cpp
   dependencies/OgreNewt/src/OgreNewt_World.cpp
Log:
- only include Ogre-headers that are necessary
- fixed typo (collisionUpdate instead of CollisionUpdate)
- replaced tabs by spaces...


Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,18 +1,19 @@
 /*
-	OgreNewt library
+    OgreNewt library
 
-	connects Ogre with the Newton Game Dynamics physics library
+    connects Ogre with the Newton Game Dynamics physics library
 
 
-		by Walaber (<A HREF="http://walaber.com">http://walaber.com</A>)
+        by Walaber (<A HREF="http://walaber.com">http://walaber.com</A>)
+        some changes by melven
 
-	main header file.
+    main header file.
 
-	current version:  2.00  ( I only raised the version number to indicate that this is for Newton2.0! )
+    current version:  2.00  ( I only raised the version number to indicate that this is for Newton2.0! )
 
-		Newton version: 2.0 beta (31.01.2009)
+        Newton version: 2.0 beta (31.01.2009)
 
-		Ogre version: Shoggoth (1.6.x)
+        Ogre version: Shoggoth (1.6.x)
 
 */
 
@@ -42,16 +43,16 @@
 
 /*! \mainpage OgreNewt Library version 2.00
 
-	\section into_sec Introduction
+    \section into_sec Introduction
 
-	OgreNewt is an OOP wrapper for integrating the Newton Dynamics Physics SDK with OGRE.
+    OgreNewt is an OOP wrapper for integrating the Newton Dynamics Physics SDK with OGRE.
 
     \section problems Problems and missing features in this version
 
     Problems and missing features in this version
         - PlayerController not finished
         - the convexcast seems to have difficulties with more than one contact (I've segfault when debugging it with the OgreNewt::Debugger...)
-          I added a hack, it only creates one contact at the maximum at the moment!
+          I added a hack, it only creates one contact at the maximum at the moment! &lt;-- this is probably due to an error in newton
         - this library supports the newton functions for multithreading but there are several functions/classes in this
           library itself, that are not thread safe (I don't need multiple threads)
           especially the world-updates are not threadsafe in ogre (see newton forum, someone posted a solution there!)
@@ -60,12 +61,12 @@
         - I didn't test several features:
             - vehicle
             - joints
-            - collsions-serializer
+            - collision-serializer
             - treecollision raycastcallback 
         - shared pointers for collisions (atm CollisionPtr := Collision*, but should be Ogre::SharedPtr&lt;Collision&gt;, but there was some problem...)
 
 
-	\section new New in this version
+    \section new New in this version
 
     New in this version
         - this version uses cmake &gt; 2.6.2!
@@ -86,77 +87,77 @@
         - a lot of minor changes and functions added and renamed
 
 
-	previous changes...
-		- updated to Newton version 2.0!!  Many big improvements and changes to the library, and OgreNewt now supports it.
-		- several interface-breaking changes:
-			- updated to support multithreading support now native to Newton.
-			- MomentOfInertia namespace and helper functions removed entirely.  Newton can now calculate inertia and center of
-			  mass automatically, use ConvexCollision::calculateInertialMatrix, and multiply by objects Mass.
-			- Body::attachToNode has been renamed to attachNode, better implying the relationship between the body and the Ogre::Node.
-			- BodyIterator class has been upgraded to use boost::function, allowing the same callback flexibility as other callbacks.
+    previous changes...
+        - updated to Newton version 2.0!!  Many big improvements and changes to the library, and OgreNewt now supports it.
+        - several interface-breaking changes:
+            - updated to support multithreading support now native to Newton.
+            - MomentOfInertia namespace and helper functions removed entirely.  Newton can now calculate inertia and center of
+              mass automatically, use ConvexCollision::calculateInertialMatrix, and multiply by objects Mass.
+            - Body::attachToNode has been renamed to attachNode, better implying the relationship between the body and the Ogre::Node.
+            - BodyIterator class has been upgraded to use boost::function, allowing the same callback flexibility as other callbacks.
 
-		- bug fix - fixed problem with TreeCollisionSceneParser that wasn't adjusting to different scales properly.
-		- optimization - fixed several classes to only write debug data to the LOG when compiled in DEBUG mode:
-			- Custom2DJonit
-			- BasicFrameListener
-		- added the concept of &quot;face-winding&quot; to all TreeCollision classes.  should not cause any breaking changes to code, but allows more flexibility to change the &quot;direction&quot; of a face in treecollisions.
-		- OgreNewt and it's demos are now fully compatible with Ogre 1.4.x (Eihort).
-		- Addition of script files for compiling under linux (Scons)
-		- slight modification to the ContactCallback class to allow access to Newton structures from the outside.
-		- some cosmetic changes to make the wrapper compile more easily under Linux and other non-windows platforms.
-		- updated to work with the release version of Ogre dagon (1.2)
-		- updated to work with version 1.53 of Newton
-		- raycast now has an optional pre-filter to ignore specific bodies from the raycast.
-		- various other clean-up!
-		- moved callback system to much more OOP-friendly &quot;boost::function&quot; system.  callbacks can now be instance-specific member functions!
-		- several other small fixes to project files, etc.
-		- automatic convex hull generation system added to supplementary ragdoll class (see demo08).
-		- documentation updated.
-		- updated to Newton version 1.5
-		- added this documentation!
-		- added buoyancy functionality.
-		- New Buoyancy demo.
-		- New Ragdoll demo, using a seperate class to implement ragdoll functionality.
-		- added basic classes for CustomJoints, and a simple demo showing how they work.
-		- added several prebuilt custom joints, including pulleys and gears, and a general 2D joint.
-		- added calculateInertialMatrix to ConvexCollision class.
-		- added set/getCenterOfMass to Body class
-		- changed angle-related functions in BasicJoint classes to use Ogre::Radian instead of Ogre::Real.
-		- added ConvexModifierCollision class, which allows for arbitrarily scaled collision primitives.
-		- added several low-level collision functions, see the CollisionTools namespace.
-		- fixed errors causing run-time crash on Slider and Universal joints.
-		- added LeaveWorldCallback functionality to World class.
+        - bug fix - fixed problem with TreeCollisionSceneParser that wasn't adjusting to different scales properly.
+        - optimization - fixed several classes to only write debug data to the LOG when compiled in DEBUG mode:
+            - Custom2DJonit
+            - BasicFrameListener
+        - added the concept of &quot;face-winding&quot; to all TreeCollision classes.  should not cause any breaking changes to code, but allows more flexibility to change the &quot;direction&quot; of a face in treecollisions.
+        - OgreNewt and it's demos are now fully compatible with Ogre 1.4.x (Eihort).
+        - Addition of script files for compiling under linux (Scons)
+        - slight modification to the ContactCallback class to allow access to Newton structures from the outside.
+        - some cosmetic changes to make the wrapper compile more easily under Linux and other non-windows platforms.
+        - updated to work with the release version of Ogre dagon (1.2)
+        - updated to work with version 1.53 of Newton
+        - raycast now has an optional pre-filter to ignore specific bodies from the raycast.
+        - various other clean-up!
+        - moved callback system to much more OOP-friendly &quot;boost::function&quot; system.  callbacks can now be instance-specific member functions!
+        - several other small fixes to project files, etc.
+        - automatic convex hull generation system added to supplementary ragdoll class (see demo08).
+        - documentation updated.
+        - updated to Newton version 1.5
+        - added this documentation!
+        - added buoyancy functionality.
+        - New Buoyancy demo.
+        - New Ragdoll demo, using a seperate class to implement ragdoll functionality.
+        - added basic classes for CustomJoints, and a simple demo showing how they work.
+        - added several prebuilt custom joints, including pulleys and gears, and a general 2D joint.
+        - added calculateInertialMatrix to ConvexCollision class.
+        - added set/getCenterOfMass to Body class
+        - changed angle-related functions in BasicJoint classes to use Ogre::Radian instead of Ogre::Real.
+        - added ConvexModifierCollision class, which allows for arbitrarily scaled collision primitives.
+        - added several low-level collision functions, see the CollisionTools namespace.
+        - fixed errors causing run-time crash on Slider and Universal joints.
+        - added LeaveWorldCallback functionality to World class.
 
-	\section install Installation
+    \section install Installation
 
-	OgreNewt comes with a project for MSVC++ 7.1 and MSVC++ 8.0 (2005).  unfortunately I have no other IDE's or compilers setup on my system, so I
-	cannot provide any other projects.  the MSVC solution should build out of the box, assuming you take a few things into
-	consideration.
+    OgreNewt comes with a project for MSVC++ 7.1 and MSVC++ 8.0 (2005).  unfortunately I have no other IDE's or compilers setup on my system, so I
+    cannot provide any other projects.  the MSVC solution should build out of the box, assuming you take a few things into
+    consideration.
 
-	unzip this in the ogreaddons directory alongside your &quot;ogrenew&quot; directory.  to compile correctly, it also assumes you have the Newton SDK installed in another
-	directory alongside this one called &quot;NewtonSDK&quot;.
+    unzip this in the ogreaddons directory alongside your &quot;ogrenew&quot; directory.  to compile correctly, it also assumes you have the Newton SDK installed in another
+    directory alongside this one called &quot;NewtonSDK&quot;.
 
-	for example something like this:
+    for example something like this:
 
-	- c:/programming/Ogre/ogrenew						&lt;- ogre installation
-	- c:/programming/Ogre/ogreaddons/OgreNewt			&lt;- OgreNewt main directory.
-	- c:/programming/NewtonSDK							&lt;- Newton SDK.
-	- c:/programming/tinyxml							&lt;- tinyxml library (needed for ragdoll demo only)
+    - c:/programming/Ogre/ogrenew                       &lt;- ogre installation
+    - c:/programming/Ogre/ogreaddons/OgreNewt           &lt;- OgreNewt main directory.
+    - c:/programming/NewtonSDK                          &lt;- Newton SDK.
+    - c:/programming/tinyxml                            &lt;- tinyxml library (needed for ragdoll demo only)
 
-	\section compiling Compiling
+    \section compiling Compiling
 
-	OgreNewt compiles by default to a static library for linking to your project.  However you can also compile OgreNewt into a dynamic DLL on the 
-	Windows platform by using the Debug_DLL and Release_DLL solution build configurations in the MSVC solutions.
+    OgreNewt compiles by default to a static library for linking to your project.  However you can also compile OgreNewt into a dynamic DLL on the 
+    Windows platform by using the Debug_DLL and Release_DLL solution build configurations in the MSVC solutions.
 
-	\section license License
+    \section license License
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
 
-	well, that's about it!
-	have fun!
+    well, that's about it!
+    have fun!
 
-	-walaber
+    -walaber
 
 */
 

Modified: dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,23 +1,24 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 
 
-		&quot;BasicFrameListener&quot;
+        &quot;BasicFrameListener&quot;
 
-		this is a simple Ogre FrameListener that will update the Newton world you supply it
-		with, at a desired framerate, using a simple time-slicer.  this means the simulation
-		should run at the same speed regardless of the actual framerate.  set the update_framerate
-		to a higher value for a more accurate simluation.
+        this is a simple Ogre FrameListener that will update the Newton world you supply it
+        with, at a desired framerate, using a simple time-slicer.  this means the simulation
+        should run at the same speed regardless of the actual framerate.  set the update_framerate
+        to a higher value for a more accurate simluation.
 
-		NOTE: update_framerate must be a value between [60,600]
+        NOTE: update_framerate must be a value between [60,600]
 */
 
 #ifndef _INCLUDE_OGRENEWT_BASICFRAMELISTENER
@@ -25,7 +26,7 @@
 
 #include &quot;OgreNewt_Prerequisites.h&quot;
 
-// using OIS (an Ogre 1.4.x dependency) for input.
+// using OIS (an Ogre dependency) for input.
 #define OIS_DYNAMIC_LIB
 #include &lt;OIS/OIS.h&gt;
 
@@ -37,34 +38,34 @@
 
 //! simple frame listener to update the physics.
 /*!
-	updates the Newton World at the specified rate, with time-slicing, and
-	also implements a simple debug view, press F3 to render Newto world with lines in 3D view.
+    updates the Newton World at the specified rate, with time-slicing, and
+    also implements a simple debug view, press F3 to render Newto world with lines in 3D view.
 */
-	class _OgreNewtExport BasicFrameListener : public Ogre::FrameListener
+    class _OgreNewtExport BasicFrameListener : public Ogre::FrameListener
 {
 protected:
-	OgreNewt::World* m_World;
+    OgreNewt::World* m_World;
 
-	int desired_framerate;
-	Ogre::Real m_update, m_elapsed;
+    int desired_framerate;
+    Ogre::Real m_update, m_elapsed;
 
 
 public:
-	BasicFrameListener(Ogre::RenderWindow* win, Ogre::SceneManager* mgr, OgreNewt::World* W, int update_framerate = 60);
-	~BasicFrameListener(void);
+    BasicFrameListener(Ogre::RenderWindow* win, Ogre::SceneManager* mgr, OgreNewt::World* W, int update_framerate = 60);
+    ~BasicFrameListener(void);
 
-	bool frameStarted(const Ogre::FrameEvent &amp;evt);
+    bool frameStarted(const Ogre::FrameEvent &amp;evt);
 
 private:
 
-	OIS::InputManager* mInputManager;
-	OIS::Keyboard* mKeyboard;
+    OIS::InputManager* mInputManager;
+    OIS::Keyboard* mKeyboard;
 
 };
 
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif /* _INCLUDE_OGRENEWT_BASICFRAMELISTENER */
 

Modified: dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_BASICJOINTS
@@ -25,49 +26,49 @@
 
 //! Ball and Socket joint.
 /*!
-	simple ball and socket joint, with limits.
+    simple ball and socket joint, with limits.
 */
 class _OgreNewtExport BallAndSocket : public Joint
 {
  
 public:
-	//! custom ballandsocket callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*BallAndSocketCallback)( BallAndSocket* me, Ogre::Real timestep );
+    //! custom ballandsocket callback function.
+    /*!
+         use the setCallback() function to assign your custom function to the joint.
+     */
+    typedef void(*BallAndSocketCallback)( BallAndSocket* me, Ogre::Real timestep );
 
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pos position of the joint in global space
-	*/
-	BallAndSocket( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos );
-	
-	//! destructor.
-	~BallAndSocket();					
+    //! constructor
+    /*!
+        \param world pointer to the OgreNewt::World
+        \param child pointer to the child rigid body.
+        \param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+        \param pos position of the joint in global space
+    */
+    BallAndSocket( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos );
+    
+    //! destructor.
+    ~BallAndSocket();
 
-	//! retrieve the current joint angle
-	Ogre::Vector3 getJointAngle() const;
+    //! retrieve the current joint angle
+    Ogre::Vector3 getJointAngle() const;
 
-	//! retrieve the current joint omega
-	Ogre::Vector3 getJointOmega() const;
+    //! retrieve the current joint omega
+    Ogre::Vector3 getJointOmega() const;
 
-	//! retrieve the current joint force.
-	/*!
-		This can be used to find the &quot;stress&quot; on the joint.  you can do special effects like break the joint if the force exceedes some value, etc.
-	*/
-	Ogre::Vector3 getJointForce() const;
+    //! retrieve the current joint force.
+    /*!
+        This can be used to find the &quot;stress&quot; on the joint.  you can do special effects like break the joint if the force exceedes some value, etc.
+    */
+    Ogre::Vector3 getJointForce() const;
 
-	//! set limits for the joints rotation
-	/*!
-		\param pin pin direction in global space
-		\param maxCone max angle for &quot;swing&quot; (in radians)
-		\param maxTwist max angle for &quot;twist&quot;  (in radians)
-	*/
-	void setLimits( const Ogre::Vector3&amp; pin, Ogre::Radian maxCone, Ogre::Radian maxTwist ) const { NewtonBallSetConeLimits( m_joint, &amp;pin.x, (float)maxCone.valueRadians(), (float)maxTwist.valueRadians() ); }
+    //! set limits for the joints rotation
+    /*!
+        \param pin pin direction in global space
+        \param maxCone max angle for &quot;swing&quot; (in radians)
+        \param maxTwist max angle for &quot;twist&quot;  (in radians)
+    */
+    void setLimits( const Ogre::Vector3&amp; pin, Ogre::Radian maxCone, Ogre::Radian maxTwist ) const { NewtonBallSetConeLimits( m_joint, &amp;pin.x, (float)maxCone.valueRadians(), (float)maxTwist.valueRadians() ); }
 
     //! set callback function
     void setCallback(BallAndSocketCallback *callback) {m_callback = callback;}
@@ -84,423 +85,415 @@
 
 //! hinge joint.
 /*!
-	simple hinge joint.  implement motors/limits through a callback.
+    simple hinge joint.  implement motors/limits through a callback.
 */
 class _OgreNewtExport Hinge : public Joint
 {
  
 public:
 
-	//! custom hinge callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*HingeCallback)( Hinge* me );
+    //! custom hinge callback function.
+    /*!
+         use the setCallback() function to assign your custom function to the joint.
+     */
+    typedef void(*HingeCallback)( Hinge* me );
 
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pin direction of the joint pin in global space
-	*/
-	Hinge( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
+    //! constructor
+    /*!
+        \param world pointer to the OgreNewt::World
+        \param child pointer to the child rigid body.
+        \param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+        \param pin direction of the joint pin in global space
+    */
+    Hinge( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
 
-	//! destructor
-	~Hinge();	
+    //! destructor
+    ~Hinge();
 
-	//! retrieve the angle around the pin.
-	Ogre::Radian getJointAngle() const { return Ogre::Radian(NewtonHingeGetJointAngle( m_joint )); }
+    //! retrieve the angle around the pin.
+    Ogre::Radian getJointAngle() const { return Ogre::Radian(NewtonHingeGetJointAngle( m_joint )); }
 
-	//! retrieve the rotational velocity around the pin.
-	Ogre::Real getJointOmega() const { return (Ogre::Real)NewtonHingeGetJointOmega( m_joint ); }
+    //! retrieve the rotational velocity around the pin.
+    Ogre::Real getJointOmega() const { return (Ogre::Real)NewtonHingeGetJointOmega( m_joint ); }
 
-	//! get the force on the joint.
-	Ogre::Vector3 getJointForce() const;
+    //! get the force on the joint.
+    Ogre::Vector3 getJointForce() const;
 
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Hinge as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( HingeCallback callback ) { m_callback = callback; }
+    //! set a custom callback for controlling this joint.
+    /*!
+        Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
+        accepts a pointer to a OgreNewt::BasicJoints::Hinge as the single parameter.  this function will be called automatically every
+        time you upate the World.
+    */
+    void setCallback( HingeCallback callback ) { m_callback = callback; }
 
 
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
+    ////////// CALLBACK COMMANDS ///////////
+    // the following commands are only valid from inside a hinge callback function
 
-	//! set acceleration around the joint pin
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackAccel( Ogre::Real accel );
+    //! set acceleration around the joint pin
+    /*!
+        This command is only valid when used inside a custom Hinge callback.
+    */
+    void setCallbackAccel( Ogre::Real accel );
 
-	//! set minimum joint friction.
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackFrictionMin( Ogre::Real min );
+    //! set minimum joint friction.
+    /*!
+        This command is only valid when used inside a custom Hinge callback.
+    */
+    void setCallbackFrictionMin( Ogre::Real min );
 
-	//! set maximum joint friction
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackFrictionMax( Ogre::Real max );
+    //! set maximum joint friction
+    /*!
+        This command is only valid when used inside a custom Hinge callback.
+    */
+    void setCallbackFrictionMax( Ogre::Real max );
 
-	//! get the current physics timestep.
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
+    //! get the current physics timestep.
+    /*!
+        This command is only valid when used inside a custom Hinge callback.
+    */
+    Ogre::Real getCallbackTimestep() const;
 
-	//! calculate the acceleration neccesary to stop the joint at the specified angle.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	Ogre::Real calculateStopAlpha( Ogre::Radian angle ) const;
+    //! calculate the acceleration neccesary to stop the joint at the specified angle.
+    /*!
+        For implementing joint limits.
+        This command is only valid when used inside a custom Hinge callback.
+    */
+    Ogre::Real calculateStopAlpha( Ogre::Radian angle ) const;
 
 protected:
 
-	//! newton callback, used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* hinge, NewtonHingeSliderUpdateDesc* desc );
+    //! newton callback, used internally.
+    static unsigned _CDECL newtonCallback( const NewtonJoint* hinge, NewtonHingeSliderUpdateDesc* desc );
 
-	HingeCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
+    HingeCallback m_callback;
+    NewtonHingeSliderUpdateDesc* m_desc;
 
-	unsigned m_retval;
-
-
+    unsigned m_retval;
 };
 
 
 //! slider joint.
 /*!
-	simple slider joint.  implement motors/limits through a callback.
+    simple slider joint.  implement motors/limits through a callback.
 */
 class _OgreNewtExport Slider : public Joint
 {
  
 public:
 
-	//! custom slider callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*SliderCallback)( Slider* me );
+    //! custom slider callback function.
+    /*!
+         use the setCallback() function to assign your custom function to the joint.
+     */
+    typedef void(*SliderCallback)( Slider* me );
 
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pin direction of the joint pin in global space
-	*/
-	Slider( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
+    //! constructor
+    /*!
+        \param world pointer to the OgreNewt::World
+        \param child pointer to the child rigid body.
+        \param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+        \param pin direction of the joint pin in global space
+    */
+    Slider( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
 
-	//! destructor.
-	~Slider();
+    //! destructor.
+    ~Slider();
 
-	//! get position of child along the pin
-	Ogre::Real getJointPosit() const { return (Ogre::Real)NewtonSliderGetJointPosit( m_joint ); }
+    //! get position of child along the pin
+    Ogre::Real getJointPosit() const { return (Ogre::Real)NewtonSliderGetJointPosit( m_joint ); }
 
-	//! get rotational velocity along the pin
-	Ogre::Real getJointVeloc() const { return (Ogre::Real)NewtonSliderGetJointVeloc( m_joint ); }
+    //! get rotational velocity along the pin
+    Ogre::Real getJointVeloc() const { return (Ogre::Real)NewtonSliderGetJointVeloc( m_joint ); }
 
-	//! get force on the joint.
-	Ogre::Vector3 getJointForce() const;
+    //! get force on the joint.
+    Ogre::Vector3 getJointForce() const;
 
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Slider as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( SliderCallback callback ) { m_callback = callback; }
+    //! set a custom callback for controlling this joint.
+    /*!
+        Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
+        accepts a pointer to a OgreNewt::BasicJoints::Slider as the single parameter.  this function will be called automatically every
+        time you upate the World.
+    */
+    void setCallback( SliderCallback callback ) { m_callback = callback; }
 
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
+    ////////// CALLBACK COMMANDS ///////////
+    // the following commands are only valid from inside a hinge callback function
 
-	//! set the acceleration along the pin.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackAccel( Ogre::Real accel );
+    //! set the acceleration along the pin.
+    /*!
+        This command is only valid when used inside a custom Slider callback.
+    */
+    void setCallbackAccel( Ogre::Real accel );
 
-	//! set minimum friction for the joint
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackFrictionMin( Ogre::Real min );
+    //! set minimum friction for the joint
+    /*!
+        This command is only valid when used inside a custom Slider callback.
+    */
+    void setCallbackFrictionMin( Ogre::Real min );
 
-	//! set maximum friction for the joint.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackFrictionMax( Ogre::Real max );
+    //! set maximum friction for the joint.
+    /*!
+        This command is only valid when used inside a custom Slider callback.
+    */
+    void setCallbackFrictionMax( Ogre::Real max );
 
-	//! get current physics timestep.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
+    //! get current physics timestep.
+    /*!
+        This command is only valid when used inside a custom Slider callback.
+    */
+    Ogre::Real getCallbackTimestep() const;
 
-	//! calculate the acceleration neccesary to stop the joint at the specified distance.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	Ogre::Real calculateStopAccel( Ogre::Real dist ) const;
+    //! calculate the acceleration neccesary to stop the joint at the specified distance.
+    /*!
+        For implementing joint limits.
+        This command is only valid when used inside a custom Slider callback.
+    */
+    Ogre::Real calculateStopAccel( Ogre::Real dist ) const;
 
 protected:
 
-	//! newton callback.  used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* slider, NewtonHingeSliderUpdateDesc* desc );
+    //! newton callback.  used internally.
+    static unsigned _CDECL newtonCallback( const NewtonJoint* slider, NewtonHingeSliderUpdateDesc* desc );
 
-	SliderCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
+    SliderCallback m_callback;
+    NewtonHingeSliderUpdateDesc* m_desc;
 
-	unsigned m_retval;
-
+    unsigned m_retval;
 };
 
 
 
-//!	this class represents a Universal joint.
+//! this class represents a Universal joint.
 /*!
-	simple universal joint.  implement motors/limits through a callback.
+    simple universal joint.  implement motors/limits through a callback.
 */
 class _OgreNewtExport Universal : public Joint
 {
  
 public:
-	
-	//! custom universal callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*UniversalCallback)( Universal* me );
+    
+    //! custom universal callback function.
+    /*!
+         use the setCallback() function to assign your custom function to the joint.
+     */
+    typedef void(*UniversalCallback)( Universal* me );
 
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pos position of the joint in global space
-		\param pin0 direction of the first axis of rotation in global space
-		\param pin1 direction of the second axis of rotation in global space
-	*/
-	Universal( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin0, const Ogre::Vector3&amp; pin1 );
+    //! constructor
+    /*!
+        \param world pointer to the OgreNewt::World
+        \param child pointer to the child rigid body.
+        \param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+        \param pos position of the joint in global space
+        \param pin0 direction of the first axis of rotation in global space
+        \param pin1 direction of the second axis of rotation in global space
+    */
+    Universal( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin0, const Ogre::Vector3&amp; pin1 );
 
-	//! destructor
-	~Universal();
+    //! destructor
+    ~Universal();
 
-	//! get the angle around pin0.
-	Ogre::Radian getJointAngle0() const { return Ogre::Radian(NewtonUniversalGetJointAngle0( m_joint )); }
+    //! get the angle around pin0.
+    Ogre::Radian getJointAngle0() const { return Ogre::Radian(NewtonUniversalGetJointAngle0( m_joint )); }
 
-	//! get the angle around pin1.
-	Ogre::Radian getJointAngle1() const { return Ogre::Radian(NewtonUniversalGetJointAngle1( m_joint )); }
+    //! get the angle around pin1.
+    Ogre::Radian getJointAngle1() const { return Ogre::Radian(NewtonUniversalGetJointAngle1( m_joint )); }
 
-	//! get the rotational velocity around pin0.
-	Ogre::Real getJointOmega0() const { return (Ogre::Real)NewtonUniversalGetJointOmega0( m_joint ); }
+    //! get the rotational velocity around pin0.
+    Ogre::Real getJointOmega0() const { return (Ogre::Real)NewtonUniversalGetJointOmega0( m_joint ); }
 
-	//! get the rotational velocity around pin1.
-	Ogre::Real getJointOmega1() const { return (Ogre::Real)NewtonUniversalGetJointOmega1( m_joint ); }
+    //! get the rotational velocity around pin1.
+    Ogre::Real getJointOmega1() const { return (Ogre::Real)NewtonUniversalGetJointOmega1( m_joint ); }
 
-	//! get the force on the joint.
-	Ogre::Vector3 getJointForce() const;
+    //! get the force on the joint.
+    Ogre::Vector3 getJointForce() const;
 
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Universal as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( UniversalCallback callback ) { m_callback = callback; }
+    //! set a custom callback for controlling this joint.
+    /*!
+        Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
+        accepts a pointer to a OgreNewt::BasicJoints::Universal as the single parameter.  this function will be called automatically every
+        time you upate the World.
+    */
+    void setCallback( UniversalCallback callback ) { m_callback = callback; }
 
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
+    ////////// CALLBACK COMMANDS ///////////
+    // the following commands are only valid from inside a hinge callback function
 
-	//! set the acceleration around a particular pin.
-	/*
-		this function can only be called from within a custom callback.
-		\param accel desired acceleration
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackAccel( Ogre::Real accel, unsigned axis );
+    //! set the acceleration around a particular pin.
+    /*
+        this function can only be called from within a custom callback.
+        \param accel desired acceleration
+        \param axis which pin to use (0 or 1)
+    */
+    void setCallbackAccel( Ogre::Real accel, unsigned axis );
 
-	//! set the minimum friction around a particular pin
-	/*
-		this function can only be called from within a custom callback.
-		\param min minimum friction
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackFrictionMin( Ogre::Real min, unsigned axis );
+    //! set the minimum friction around a particular pin
+    /*
+        this function can only be called from within a custom callback.
+        \param min minimum friction
+        \param axis which pin to use (0 or 1)
+    */
+    void setCallbackFrictionMin( Ogre::Real min, unsigned axis );
 
-	//! set the maximum friction around a particular pin.
-	/*
-		this function can only be called from within a custom callback.
-		\param max maximum friction
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackFrictionMax( Ogre::Real max, unsigned axis );
+    //! set the maximum friction around a particular pin.
+    /*
+        this function can only be called from within a custom callback.
+        \param max maximum friction
+        \param axis which pin to use (0 or 1)
+    */
+    void setCallbackFrictionMax( Ogre::Real max, unsigned axis );
 
-	//! get the current phsics timestep.
-	/*
-		this function can only be called from within a custom callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
+    //! get the current phsics timestep.
+    /*
+        this function can only be called from within a custom callback.
+    */
+    Ogre::Real getCallbackTimestep() const;
 
-	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 0.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom  callback.
-	*/
-	Ogre::Real calculateStopAlpha0( Ogre::Real angle ) const;
+    //! calculate the acceleration neccesary to stop the joint at the specified angle on pin 0.
+    /*!
+        For implementing joint limits.
+        This command is only valid when used inside a custom  callback.
+    */
+    Ogre::Real calculateStopAlpha0( Ogre::Real angle ) const;
 
-	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 1.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom  callback.
-	*/
-	Ogre::Real calculateStopAlpha1( Ogre::Real angle ) const;
+    //! calculate the acceleration neccesary to stop the joint at the specified angle on pin 1.
+    /*!
+        For implementing joint limits.
+        This command is only valid when used inside a custom  callback.
+    */
+    Ogre::Real calculateStopAlpha1( Ogre::Real angle ) const;
 
 protected:
-	
-	//! newton callback.  used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* universal, NewtonHingeSliderUpdateDesc* desc );
+    
+    //! newton callback.  used internally.
+    static unsigned _CDECL newtonCallback( const NewtonJoint* universal, NewtonHingeSliderUpdateDesc* desc );
 
-	UniversalCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
+    UniversalCallback m_callback;
+    NewtonHingeSliderUpdateDesc* m_desc;
 
-	unsigned m_retval;
-
-
-
+    unsigned m_retval;
 };
 
 
 
 //! UpVector joint.
 /*!
-	simple upvector joint.  upvectors remove all rotation except for a single pin.  useful for character controllers, etc.
+    simple upvector joint.  upvectors remove all rotation except for a single pin.  useful for character controllers, etc.
 */
 class _OgreNewtExport UpVector : public Joint
 {
  
 public:
-	//! constructor
-	/*
-		\param world pointer to the OgreNewt::World.
-		\param body pointer to the body to apply the upvector to.
-		\param pin direction of the upvector in global space.
-	*/
-	UpVector( const World* world, const Body* body, const Ogre::Vector3&amp; pin );
+    //! constructor
+    /*
+        \param world pointer to the OgreNewt::World.
+        \param body pointer to the body to apply the upvector to.
+        \param pin direction of the upvector in global space.
+    */
+    UpVector( const World* world, const Body* body, const Ogre::Vector3&amp; pin );
 
-	//! destructor
-	~UpVector();
+    //! destructor
+    ~UpVector();
 
-	//! set the pin direction.
-	/*
-		by calling this function in realtime, you can effectively &quot;animate&quot; the pin.
-	*/
-	void setPin( const Ogre::Vector3&amp; pin ) const { NewtonUpVectorSetPin( m_joint, &amp;pin.x ); }
+    //! set the pin direction.
+    /*
+        by calling this function in realtime, you can effectively &quot;animate&quot; the pin.
+    */
+    void setPin( const Ogre::Vector3&amp; pin ) const { NewtonUpVectorSetPin( m_joint, &amp;pin.x ); }
 
-	//! get the current pin direction.
-	Ogre::Vector3 getPin() const;
-
-
+    //! get the current pin direction.
+    Ogre::Vector3 getPin() const;
 };
 
 
-}	// end NAMESPACE BasicJoints
+}   // end NAMESPACE BasicJoints
 
 
 //! namespace for pre-built custom joints
 namespace PrebuiltCustomJoints
 {
 
-	//! Custom2DJoint class
-	/*!
-		This class represents a joint that limits movement to a plane, and rotation only around the normal of that
-		plane.  This can be used to create simple 2D simulations.  it also supports limits and acceleration for spinning.
-		This joint has been used in a few projects, but is not 100% fully-tested.
-	*/
-	class _OgreNewtExport Custom2DJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		//! constructor
-		Custom2DJoint( const OgreNewt::Body* body, const Ogre::Vector3&amp; pin );
+    //! Custom2DJoint class
+    /*!
+        This class represents a joint that limits movement to a plane, and rotation only around the normal of that
+        plane.  This can be used to create simple 2D simulations.  it also supports limits and acceleration for spinning.
+        This joint has been used in a few projects, but is not 100% fully-tested.
+    */
+    class _OgreNewtExport Custom2DJoint : public OgreNewt::CustomJoint
+    {
+    public:
+        //! constructor
+        Custom2DJoint( const OgreNewt::Body* body, const Ogre::Vector3&amp; pin );
 
-		//! destructor
-		~Custom2DJoint() {}
+        //! destructor
+        ~Custom2DJoint() {}
 
-		//! overloaded function that applies the actual constraint.
-		void submitConstraint( Ogre::Real timeStep, int threadIndex );
+        //! overloaded function that applies the actual constraint.
+        void submitConstraint( Ogre::Real timeStep, int threadIndex );
 
-		//! get the current angle of the joint.
-		Ogre::Radian getAngle() const { return mAngle; }
+        //! get the current angle of the joint.
+        Ogre::Radian getAngle() const { return mAngle; }
 
-		//! set rotational limits for the joint.
-		void setLimits( Ogre::Degree min, Ogre::Degree max ) { mMin = min, mMax = max; }
-		
-		//! sets whether to enable limits or not for the joint.
-		void setLimitsOn( bool onoff ) { mLimitsOn = onoff; }
+        //! set rotational limits for the joint.
+        void setLimits( Ogre::Degree min, Ogre::Degree max ) { mMin = min, mMax = max; }
+        
+        //! sets whether to enable limits or not for the joint.
+        void setLimitsOn( bool onoff ) { mLimitsOn = onoff; }
 
-		//! returns whether limits are turned on or off for the joint.
-		bool getLimitsOn() const { return mLimitsOn; }
+        //! returns whether limits are turned on or off for the joint.
+        bool getLimitsOn() const { return mLimitsOn; }
 
-		//! adds rotational acceleration to the joint (like a motor)
-		void addAccel( Ogre::Real accel ) { mAccel = accel; }
+        //! adds rotational acceleration to the joint (like a motor)
+        void addAccel( Ogre::Real accel ) { mAccel = accel; }
 
-		//! resets the joint angle to 0.  this simply sets the internal variable to zero.
-		//! you might want to call this for example after resetting a body.
-		void resetAngle() { mAngle = Ogre::Radian(0.0f); }
+        //! resets the joint angle to 0.  this simply sets the internal variable to zero.
+        //! you might want to call this for example after resetting a body.
+        void resetAngle() { mAngle = Ogre::Radian(0.0f); }
 
-		//! get the pin.
-		Ogre::Vector3 getPin() { return mPin; }
+        //! get the pin.
+        Ogre::Vector3 getPin() { return mPin; }
 
-	private:
-		Ogre::Vector3 mPin;
-		Ogre::Quaternion mLocalOrient0, mLocalOrient1;
-		Ogre::Vector3 mLocalPos0, mLocalPos1;
+    private:
+        Ogre::Vector3 mPin;
+        Ogre::Quaternion mLocalOrient0, mLocalOrient1;
+        Ogre::Vector3 mLocalPos0, mLocalPos1;
 
-		Ogre::Radian mAngle;
+        Ogre::Radian mAngle;
 
-		Ogre::Radian mMin;
-		Ogre::Radian mMax;
+        Ogre::Radian mMin;
+        Ogre::Radian mMax;
 
-		bool mLimitsOn;
+        bool mLimitsOn;
 
-		Ogre::Real mAccel;
-	};
+        Ogre::Real mAccel;
+    };
 
-	//! CustomFixedJoint
-	/*!
-		This joint implements a fully fixed joint, which removes all DOF, creating a completely fixed connection between bodies.
-		This is probably the most expensive kind of joint, and should only be used when really needed.
-	*/
-	class _OgreNewtExport CustomRigidJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		CustomRigidJoint( OgreNewt::Body* child, OgreNewt::Body* parent, Ogre::Vector3 dir, Ogre::Vector3 pos);
-		~CustomRigidJoint();
+    //! CustomFixedJoint
+    /*!
+        This joint implements a fully fixed joint, which removes all DOF, creating a completely fixed connection between bodies.
+        This is probably the most expensive kind of joint, and should only be used when really needed.
+    */
+    class _OgreNewtExport CustomRigidJoint : public OgreNewt::CustomJoint
+    {
+    public:
+        CustomRigidJoint( OgreNewt::Body* child, OgreNewt::Body* parent, Ogre::Vector3 dir, Ogre::Vector3 pos);
+        ~CustomRigidJoint();
 
-		void submitConstraint( Ogre::Real timeStep, int threadIndex );
+        void submitConstraint( Ogre::Real timeStep, int threadIndex );
 
-	private:
-		Ogre::Vector3 mLocalPos0;
-		Ogre::Vector3 mLocalPos1;
+    private:
+        Ogre::Vector3 mLocalPos0;
+        Ogre::Vector3 mLocalPos1;
 
-		Ogre::Quaternion mLocalOrient0;
-		Ogre::Quaternion mLocalOrient1;
-	};
+        Ogre::Quaternion mLocalOrient0;
+        Ogre::Quaternion mLocalOrient1;
+    };
 
-}	// end NAMESPACE PrebuiltCustomJoints
+}   // end NAMESPACE PrebuiltCustomJoints
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_BASICJOINTS

Modified: dependencies/OgreNewt/inc/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,15 +1,16 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
 
-	please note that the &quot;boost&quot; library files included here are not of my creation, refer to those files and boost.org for information.
+    please note that the &quot;boost&quot; library files included here are not of my creation, refer to those files and boost.org for information.
 
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 
@@ -31,173 +32,173 @@
 class MaterialID;
 
 /*
-	CLASS DEFINITION:
+    CLASS DEFINITION:
 
-		Body
+        Body
 
-	USE:
-		this class represents a NewtonBody rigid body!
+    USE:
+        this class represents a NewtonBody rigid body!
 */
 //! main class for all Rigid Bodies in the system.
 class _OgreNewtExport Body
 {
 public:
-	//! custom force callback.
-	/*!
-		this function is called from within the OgreNewt::World::update() command when applying forces to Rigid Bodies, such as
-		gravity, etc.
+    //! custom force callback.
+    /*!
+        this function is called from within the OgreNewt::World::update() command when applying forces to Rigid Bodies, such as
+        gravity, etc.
 
-		You can set this as the custom force callback for a body by using the setCustomForceCallback() function.
-		Using boost::function means OgreNewt can now accept pointers to member functions of specific classes.
-	*/
-	typedef boost::function&lt;void(OgreNewt::Body*, float timeStep, int threadIndex)&gt; ForceCallback;
+        You can set this as the custom force callback for a body by using the setCustomForceCallback() function.
+        Using boost::function means OgreNewt can now accept pointers to member functions of specific classes.
+    */
+    typedef boost::function&lt;void(OgreNewt::Body*, float timeStep, int threadIndex)&gt; ForceCallback;
 
-	//! custom transform callback.
-	/*!
-		This function is called from within the OgreNewt::World::update() command for all Rigid Bodies, after all collision and
-		forces have been resolved.  this command is intended to allow the user to align a visual object with the new position and
-		orientation of the rigid body.  OgreNewt has a general transform callback built-in for use with Ogre.  however you can 
-		create your own for special cases.  you are passed a quaternion (orientation) and vector (position) of the rigid body
-		in world space.
-	*/
-	typedef boost::function&lt;void(OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, int threadIndex)&gt; TransformCallback;
-	
+    //! custom transform callback.
+    /*!
+        This function is called from within the OgreNewt::World::update() command for all Rigid Bodies, after all collision and
+        forces have been resolved.  this command is intended to allow the user to align a visual object with the new position and
+        orientation of the rigid body.  OgreNewt has a general transform callback built-in for use with Ogre.  however you can 
+        create your own for special cases.  you are passed a quaternion (orientation) and vector (position) of the rigid body
+        in world space.
+    */
+    typedef boost::function&lt;void(OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, int threadIndex)&gt; TransformCallback;
+    
 
-	//! buoyancy plane callback
-	/*!
-		this function is a user-defined function that supplies Newton with the plane equation for the surface of the liquid when
-		applying buoyancy forces.  the user should create their own function for this, that returns an Ogre::Plane based on their
-		own criteria.  you get a pointer to the OgreNewt::Body, and it's current orientation and location to boot.  note that this
-		callback will be called for each collision primitive in the body (if it is a compound collision).  if you want to
-		ignore buoyancy for this collision primitive, just return false from the function.  otherwise, fill the &quot;retPlane&quot; with your
-		liquid surface plane, and return true to apply buoyancy to the primitive.
-	*/
-	typedef boost::function&lt;bool(int, OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, Ogre::Plane&amp;)&gt; buoyancyPlaneCallback;
+    //! buoyancy plane callback
+    /*!
+        this function is a user-defined function that supplies Newton with the plane equation for the surface of the liquid when
+        applying buoyancy forces.  the user should create their own function for this, that returns an Ogre::Plane based on their
+        own criteria.  you get a pointer to the OgreNewt::Body, and it's current orientation and location to boot.  note that this
+        callback will be called for each collision primitive in the body (if it is a compound collision).  if you want to
+        ignore buoyancy for this collision primitive, just return false from the function.  otherwise, fill the &quot;retPlane&quot; with your
+        liquid surface plane, and return true to apply buoyancy to the primitive.
+    */
+    typedef boost::function&lt;bool(int, OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, Ogre::Plane&amp;)&gt; buoyancyPlaneCallback;
 
-	//! constructor.
-	/*!
-		creates a Rigid Body in an OgreNewt::World, based on a specific collision shape.
-		\param W pointer to the OgreNewt::World/
-		\param col pointer to an OgreNewt::Collision object that represents the shape of the rigid body.
-		\param bodytype simple integer value used to identify the type of rigid body, useful for determining bodies in callbacks.
-	*/
-	Body( const World* W, const OgreNewt::Collision* col, int bodytype = 0 );
+    //! constructor.
+    /*!
+        creates a Rigid Body in an OgreNewt::World, based on a specific collision shape.
+        \param W pointer to the OgreNewt::World/
+        \param col pointer to an OgreNewt::Collision object that represents the shape of the rigid body.
+        \param bodytype simple integer value used to identify the type of rigid body, useful for determining bodies in callbacks.
+    */
+    Body( const World* W, const OgreNewt::Collision* col, int bodytype = 0 );
 
-	//! destructor
-	~Body();
+    //! destructor
+    ~Body();
 
-	//! set user data to connect this class to another.
-	/*!
-		you can use this to store a pointer to a parent class, etc.  then inside one of the many callbacks, you can get the pointer
-		using this &quot;userData&quot; system.
-	*/
-	void setUserData( void* data ) { m_userdata = data; }
+    //! set user data to connect this class to another.
+    /*!
+        you can use this to store a pointer to a parent class, etc.  then inside one of the many callbacks, you can get the pointer
+        using this &quot;userData&quot; system.
+    */
+    void setUserData( void* data ) { m_userdata = data; }
 
-	//! retrieve pointer to previously set user data.
-	void* getUserData() const { return m_userdata; }
+    //! retrieve pointer to previously set user data.
+    void* getUserData() const { return m_userdata; }
 
-	//! get a pointer to the NewtonBody object
-	/*!
-		this is the NewtonBody used by the Newton SDK.  in most cases you shouldn't need to access this.
-	*/
-	NewtonBody* getNewtonBody() const { return m_body; }
+    //! get a pointer to the NewtonBody object
+    /*!
+        this is the NewtonBody used by the Newton SDK.  in most cases you shouldn't need to access this.
+    */
+    NewtonBody* getNewtonBody() const { return m_body; }
 
-	//! get a pointer to the attached Node.
-	/*!
-		if you have &quot;attached&quot; an Ogre::Node to this body, this retrieves the node.
-	*/
-	Ogre::Node* getOgreNode() const { return m_node; }
+    //! get a pointer to the attached Node.
+    /*!
+        if you have &quot;attached&quot; an Ogre::Node to this body, this retrieves the node.
+    */
+    Ogre::Node* getOgreNode() const { return m_node; }
 
-	//! get a pointer to the OgreNewt::World this body belongs to.
-	const OgreNewt::World* getWorld() const { return m_world; }
+    //! get a pointer to the OgreNewt::World this body belongs to.
+    const OgreNewt::World* getWorld() const { return m_world; }
 
-	//! set the type for this body.
-	/*!
-		this sets the &quot;type&quot; for the body, which can also be set in the constructor.
-		\param type integer value to represent the type of body, e.g. &quot;FLOOR&quot; or &quot;CANON BALL&quot;, etc. used for differentation in material callbacks.
-	*/
-	void setType( int type ) { m_type = type; }
+    //! set the type for this body.
+    /*!
+        this sets the &quot;type&quot; for the body, which can also be set in the constructor.
+        \param type integer value to represent the type of body, e.g. &quot;FLOOR&quot; or &quot;CANON BALL&quot;, etc. used for differentation in material callbacks.
+    */
+    void setType( int type ) { m_type = type; }
 
-	//! get the type set for this body.
-	int getType() const { return m_type; }
+    //! get the type set for this body.
+    int getType() const { return m_type; }
 
-	//! attach this body to an Ogre::Node*
-	/*!
-		This is an easy way to connect a Rigid Body with an Ogre::Node.  this automatically sets up a standard Transform callback when you call this.  after calling this, the Ogre::Node will have its position orientation updated to that of the Rigid Body each time you call World::update(), and the body has moved during the update.
-	*/
-	void attachNode( Ogre::Node* node );
+    //! attach this body to an Ogre::Node*
+    /*!
+        This is an easy way to connect a Rigid Body with an Ogre::Node.  this automatically sets up a standard Transform callback when you call this.  after calling this, the Ogre::Node will have its position orientation updated to that of the Rigid Body each time you call World::update(), and the body has moved during the update.
+    */
+    void attachNode( Ogre::Node* node );
 
-	//! set a standard gravity callback for this body to use.
-	/*!
-		This sets a very basic force callback for this body, that simply applies a standard 9,8m/s^2 gravity force to the body.
-		in most cases you will need more forces acting on your Rigid Bodies, which you accomplish through custom force callbacks.
-	*/
-	void setStandardForceCallback();
+    //! set a standard gravity callback for this body to use.
+    /*!
+        This sets a very basic force callback for this body, that simply applies a standard 9,8m/s^2 gravity force to the body.
+        in most cases you will need more forces acting on your Rigid Bodies, which you accomplish through custom force callbacks.
+    */
+    void setStandardForceCallback();
 
-	//! set a custom force callback for this body to use.
-	/*
-		This specifies a custom callback to use for applying forces to a body.  if you are using a standard non-member function, or a static member function, you can simply pass a pointer to the function here.. like this:
-		setCustomForceAndTorqueCallback( &amp;myCallbackFunction );
+    //! set a custom force callback for this body to use.
+    /*
+        This specifies a custom callback to use for applying forces to a body.  if you are using a standard non-member function, or a static member function, you can simply pass a pointer to the function here.. like this:
+        setCustomForceAndTorqueCallback( &amp;myCallbackFunction );
 
-		If you want to bind to a class member, you also need to pass a pointer to the class itself, using the boost::bind system, like so:
-		setCustomForceAndTorqueCallback( boost::bind( &amp;MyClass::myCallback, (MyClass*)classInstance, _1 ) );  (from outside the class) or:
-		setCustomForceAndTorqueCallback( boost::bind( &amp;MyClass::myCallback, this, _1 ) );  (from inside the class).
+        If you want to bind to a class member, you also need to pass a pointer to the class itself, using the boost::bind system, like so:
+        setCustomForceAndTorqueCallback( boost::bind( &amp;MyClass::myCallback, (MyClass*)classInstance, _1 ) );  (from outside the class) or:
+        setCustomForceAndTorqueCallback( boost::bind( &amp;MyClass::myCallback, this, _1 ) );  (from inside the class).
 
-		You can also use:
-		setCustomForceAndTorqueCallback&lt;&gt;( &amp;MyClass::myCallback, (MyClass*)classInstance );  (from outside the class) or:
-		setCustomForceAndTorqueCallback&lt;&gt;( &amp;MyClass::myCallback, this );  (from inside the class).
-		Note: Notice the &quot;&lt;&gt;&quot; after the function name.
-	*/
-	void setCustomForceAndTorqueCallback( ForceCallback callback );
-	template&lt;class c&gt; void setCustomForceAndTorqueCallback( boost::function&lt;void(c*, Body*, float, int)&gt; callback, c *instancedClassPointer )
-	{
-		setCustomForceAndTorqueCallback( boost::bind(callback, instancedClassPointer, _1, _2, _3) );
-	}
+        You can also use:
+        setCustomForceAndTorqueCallback&lt;&gt;( &amp;MyClass::myCallback, (MyClass*)classInstance );  (from outside the class) or:
+        setCustomForceAndTorqueCallback&lt;&gt;( &amp;MyClass::myCallback, this );  (from inside the class).
+        Note: Notice the &quot;&lt;&gt;&quot; after the function name.
+    */
+    void setCustomForceAndTorqueCallback( ForceCallback callback );
+    template&lt;class c&gt; void setCustomForceAndTorqueCallback( boost::function&lt;void(c*, Body*, float, int)&gt; callback, c *instancedClassPointer )
+    {
+        setCustomForceAndTorqueCallback( boost::bind(callback, instancedClassPointer, _1, _2, _3) );
+    }
 
-	//! remove any force callbacks.
-	void removeForceAndTorqueCallback() { NewtonBodySetForceAndTorqueCallback( m_body, NULL );  m_forcecallback = NULL; }
+    //! remove any force callbacks.
+    void removeForceAndTorqueCallback() { NewtonBodySetForceAndTorqueCallback( m_body, NULL );  m_forcecallback = NULL; }
 
-	//! set a custom transform callback.
-	/*
-		sets a custom transform callback for the rigid body. see the docs on setCustomForceAndTorqueCallback for a description of how to use this function.
-	*/
-	void setCustomTransformCallback( TransformCallback callback );
-	template&lt;class c&gt; void setCustomTransformCallback( boost::function&lt;void(c*, OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;)&gt; callback, c *instancedClassPointer )
-	{
-		setCustomTransformCallback( boost::bind(callback, instancedClassPointer, _1, _2, _3) );
-	}
+    //! set a custom transform callback.
+    /*
+        sets a custom transform callback for the rigid body. see the docs on setCustomForceAndTorqueCallback for a description of how to use this function.
+    */
+    void setCustomTransformCallback( TransformCallback callback );
+    template&lt;class c&gt; void setCustomTransformCallback( boost::function&lt;void(c*, OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;)&gt; callback, c *instancedClassPointer )
+    {
+        setCustomTransformCallback( boost::bind(callback, instancedClassPointer, _1, _2, _3) );
+    }
 
-	//! remove any transform callbacks.
-	void removeTransformCallback() { m_transformcallback = NULL; }
+    //! remove any transform callbacks.
+    void removeTransformCallback() { m_transformcallback = NULL; }
 
-	//! position and orient the body arbitrarily.
-	/*!
-		generally in a physics engine you shouldn't directly set the location/rotation of a Body, because this defies physics laws.  this command exists to set up bodies initially.
-		\param orient quaternion representing body orientation in world space.
-		\param pos vector representing body position in world space. 
-	*/
-	void setPositionOrientation( const Ogre::Vector3&amp; pos, const Ogre::Quaternion&amp; orient );
+    //! position and orient the body arbitrarily.
+    /*!
+        generally in a physics engine you shouldn't directly set the location/rotation of a Body, because this defies physics laws.  this command exists to set up bodies initially.
+        \param orient quaternion representing body orientation in world space.
+        \param pos vector representing body position in world space. 
+    */
+    void setPositionOrientation( const Ogre::Vector3&amp; pos, const Ogre::Quaternion&amp; orient );
 
-	//! set the mass and inertia for the body.
-	/*!
-		Set the mass of the Rigid Body.  Inertia is also set here.  Inertia represents a body's &quot;resistance&quot; to rotation around the 3 primary axis.  OgreNewt has a few utility functions that can help you calculate these values based on several primitive shapes.
-		\param mass real value for the body mass
-		\param inertia vector representing body moment of inertia
-	*/
-	void setMassMatrix( Ogre::Real mass, const Ogre::Vector3&amp; inertia );
+    //! set the mass and inertia for the body.
+    /*!
+        Set the mass of the Rigid Body.  Inertia is also set here.  Inertia represents a body's &quot;resistance&quot; to rotation around the 3 primary axis.  OgreNewt has a few utility functions that can help you calculate these values based on several primitive shapes.
+        \param mass real value for the body mass
+        \param inertia vector representing body moment of inertia
+    */
+    void setMassMatrix( Ogre::Real mass, const Ogre::Vector3&amp; inertia );
 
-	//! set the body's center of mass
-	/*!
-		Set a new center of mass for the body that is different than the current, without offsetting the body.
-		You can use this to adjust the center of mass of a body at runtime.
-	*/
-	void setCenterOfMass( const Ogre::Vector3&amp; centerOfMass ) { NewtonBodySetCentreOfMass( m_body, &amp;centerOfMass.x ); }
+    //! set the body's center of mass
+    /*!
+        Set a new center of mass for the body that is different than the current, without offsetting the body.
+        You can use this to adjust the center of mass of a body at runtime.
+    */
+    void setCenterOfMass( const Ogre::Vector3&amp; centerOfMass ) { NewtonBodySetCentreOfMass( m_body, &amp;centerOfMass.x ); }
 
-	//! get the center of mass.
-	/*!
-		returns the current center of mass, as an offset from the original origin when the body was created.
-	*/
-	Ogre::Vector3 getCenterOfMass() const;
+    //! get the center of mass.
+    /*!
+        returns the current center of mass, as an offset from the original origin when the body was created.
+    */
+    Ogre::Vector3 getCenterOfMass() const;
         //! freeze the rigid body.
         /*!
             this command &quot;freezes&quot; the Rigid Body, removing it from the active simulation list.  it will &quot;unfreeze&quot; if another body comes in contact with it, or you &quot;unfreeze&quot; it.
@@ -214,162 +215,162 @@
         //! is the body freezed?
         bool isFreezed() { return NewtonBodyGetFreezeState( m_body ) != 0; }
             
-	//! set the material for the body
-	/*!
-		Materials are an extremely powerful way to control body behavior. first create a new MaterialID object, and then pass a pointer
-		to apply that material to the body. 
-		\param ID pointer to an OgreNewt::MaterialID object to use as the material for the body.
-	*/
-	void setMaterialGroupID( const MaterialID* ID ) { m_matid = ID; NewtonBodySetMaterialGroupID( m_body, m_matid-&gt;getID() ); }
-	
-	//! prevents fast moving bodies from &quot;tunneling&quot; through other bodies.
-	/*!
-		continuous collision is an advanced feature that prevents fast moving bodies from &quot;tunneling&quot; (missing collision) with other bodies.  there 
-		is a performance hit envolved, so this feature should only be used for bodies that have a high likelyhood of tunneling.
-		
-		note that continuous collision can also be set on a per-material basis via the MaterialPair class.
-	*/
-	void setContinuousCollisionMode( unsigned state ) { NewtonBodySetContinuousCollisionMode( m_body, state ); }
+    //! set the material for the body
+    /*!
+        Materials are an extremely powerful way to control body behavior. first create a new MaterialID object, and then pass a pointer
+        to apply that material to the body. 
+        \param ID pointer to an OgreNewt::MaterialID object to use as the material for the body.
+    */
+    void setMaterialGroupID( const MaterialID* ID ) { m_matid = ID; NewtonBodySetMaterialGroupID( m_body, m_matid-&gt;getID() ); }
+    
+    //! prevents fast moving bodies from &quot;tunneling&quot; through other bodies.
+    /*!
+        continuous collision is an advanced feature that prevents fast moving bodies from &quot;tunneling&quot; (missing collision) with other bodies.  there 
+        is a performance hit envolved, so this feature should only be used for bodies that have a high likelyhood of tunneling.
+        
+        note that continuous collision can also be set on a per-material basis via the MaterialPair class.
+    */
+    void setContinuousCollisionMode( unsigned state ) { NewtonBodySetContinuousCollisionMode( m_body, state ); }
 
-	//! set whether all parent/children pairs connected to this body should be allowed to collide.
-	void setJointRecursiveCollision( unsigned state ) { NewtonBodySetJointRecursiveCollision( m_body, state ); }
+    //! set whether all parent/children pairs connected to this body should be allowed to collide.
+    void setJointRecursiveCollision( unsigned state ) { NewtonBodySetJointRecursiveCollision( m_body, state ); }
 
-	//! set an arbitrary omega for the body.
-	/*!
-		again, setting velocity/omega directly for a body in realtime is not recommended for proper physics behavior.  this function is intended to be used to setup a Body initially.
-		\param omega vector representing the desired omega (rotational velocity)
-	*/
-	void setOmega( const Ogre::Vector3&amp; omega ) { NewtonBodySetOmega( m_body, &amp;omega.x ); }
+    //! set an arbitrary omega for the body.
+    /*!
+        again, setting velocity/omega directly for a body in realtime is not recommended for proper physics behavior.  this function is intended to be used to setup a Body initially.
+        \param omega vector representing the desired omega (rotational velocity)
+    */
+    void setOmega( const Ogre::Vector3&amp; omega ) { NewtonBodySetOmega( m_body, &amp;omega.x ); }
 
-	//! set an arbitrary velocity for the body.
-	/*!
-		again, setting velocity/omega directly for a body in realtime is not recommended for proper physics behavior.  this function is intended to be used to setup a Body initially.
-		\param vel vector representing the desired velocity.
-	*/
-	void setVelocity( const Ogre::Vector3&amp; vel ) { NewtonBodySetVelocity( m_body, &amp;vel.x ); }
+    //! set an arbitrary velocity for the body.
+    /*!
+        again, setting velocity/omega directly for a body in realtime is not recommended for proper physics behavior.  this function is intended to be used to setup a Body initially.
+        \param vel vector representing the desired velocity.
+    */
+    void setVelocity( const Ogre::Vector3&amp; vel ) { NewtonBodySetVelocity( m_body, &amp;vel.x ); }
 
-	//! set the linear damping for the body.
-	void setLinearDamping( Ogre::Real damp ) { NewtonBodySetLinearDamping( m_body, (float)damp ); }
+    //! set the linear damping for the body.
+    void setLinearDamping( Ogre::Real damp ) { NewtonBodySetLinearDamping( m_body, (float)damp ); }
 
-	//! set the angular damping for the body.
-	void setAngularDamping( const Ogre::Vector3&amp; damp ) { NewtonBodySetAngularDamping( m_body, &amp;damp.x ); }
+    //! set the angular damping for the body.
+    void setAngularDamping( const Ogre::Vector3&amp; damp ) { NewtonBodySetAngularDamping( m_body, &amp;damp.x ); }
 
-	//! set the collision that represents the shape of the body
-	/*!
-		This can be used to change the collision shape of a body mid-simulation.  for example making the collision for a character smaller when crouching, etc.
-		\param col pointer to the new OgreNewt::Collision shape.
-	*/
-	void setCollision( const OgreNewt::Collision* col );
+    //! set the collision that represents the shape of the body
+    /*!
+        This can be used to change the collision shape of a body mid-simulation.  for example making the collision for a character smaller when crouching, etc.
+        \param col pointer to the new OgreNewt::Collision shape.
+    */
+    void setCollision( const OgreNewt::Collision* col );
 
-	//! set whether the body should &quot;sleep&quot; when equilibruim is reached.
-	/*!
-		user-controlled bodies should disable sleeping, because frozen bodies' callbacks are not called... so a callback that implements motion based on user input will not be called!
-	*/
-	void setAutoSleep( int flag ) { NewtonBodySetAutoSleep ( m_body, flag); }
+    //! set whether the body should &quot;sleep&quot; when equilibruim is reached.
+    /*!
+        user-controlled bodies should disable sleeping, because frozen bodies' callbacks are not called... so a callback that implements motion based on user input will not be called!
+    */
+    void setAutoSleep( int flag ) { NewtonBodySetAutoSleep ( m_body, flag); }
 
-	//! get whether the body should &quot;sleep&quot; when equilibrium is reached.
-	int getAutoSleep() { return NewtonBodyGetAutoSleep( m_body ); }
+    //! get whether the body should &quot;sleep&quot; when equilibrium is reached.
+    int getAutoSleep() { return NewtonBodyGetAutoSleep( m_body ); }
 
-	//! set the factors that cause a body to &quot;freeze&quot; when equilibrium reached.
-	//void setFreezeThreshold( Ogre::Real speed, Ogre::Real omega, int framecount ) { NewtonBodySetFreezeTreshold( m_body, (float)speed, (float)omega, framecount ); }
+    //! set the factors that cause a body to &quot;freeze&quot; when equilibrium reached.
+    //void setFreezeThreshold( Ogre::Real speed, Ogre::Real omega, int framecount ) { NewtonBodySetFreezeTreshold( m_body, (float)speed, (float)omega, framecount ); }
 
-	//! get a pointer to the OgreNewt::Collision for this body
-	const OgreNewt::Collision* getCollision() const;
+    //! get a pointer to the OgreNewt::Collision for this body
+    const OgreNewt::Collision* getCollision() const;
 
-	//! get a pointer to the Material assigned to this body.
-	const OgreNewt::MaterialID* getMaterialGroupID() const;
+    //! get a pointer to the Material assigned to this body.
+    const OgreNewt::MaterialID* getMaterialGroupID() const;
 
-	//! returns current setting for this body.
-	int getContinuousCollisionMode() const { return NewtonBodyGetContinuousCollisionMode( m_body ); }
+    //! returns current setting for this body.
+    int getContinuousCollisionMode() const { return NewtonBodyGetContinuousCollisionMode( m_body ); }
 
-	//! returns current setting for this body.
-	int getJointRecursiveCollision() const { return NewtonBodyGetJointRecursiveCollision( m_body ); }
+    //! returns current setting for this body.
+    int getJointRecursiveCollision() const { return NewtonBodyGetJointRecursiveCollision( m_body ); }
 
-	//! get position and orientation in form of an Ogre::Vector(position) and Ogre::Quaternion(orientation)
-	void getPositionOrientation( Ogre::Vector3&amp; pos, Ogre::Quaternion&amp; orient ) const;
+    //! get position and orientation in form of an Ogre::Vector(position) and Ogre::Quaternion(orientation)
+    void getPositionOrientation( Ogre::Vector3&amp; pos, Ogre::Quaternion&amp; orient ) const;
 
-	//! get the axis-aligned bounding box for this body.
-	Ogre::AxisAlignedBox getAABB() const;
+    //! get the axis-aligned bounding box for this body.
+    Ogre::AxisAlignedBox getAABB() const;
 
-	//! get Ogre::Real(mass) and Ogre::Vector3(inertia) of the body.
-	void getMassMatrix( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const;
+    //! get Ogre::Real(mass) and Ogre::Vector3(inertia) of the body.
+    void getMassMatrix( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const;
 
-	//! get invert mass + inertia for the body.
-	void getInvMass( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const;
+    //! get invert mass + inertia for the body.
+    void getInvMass( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const;
 
-	//! get omega of the body. in global space. 
-	Ogre::Vector3 getOmega() const;
+    //! get omega of the body. in global space. 
+    Ogre::Vector3 getOmega() const;
 
-	//! get velocity of the body. in global coordinates.
-	Ogre::Vector3 getVelocity() const;
+    //! get velocity of the body. in global coordinates.
+    Ogre::Vector3 getVelocity() const;
 
-	//! get the force acting on the body.
-	Ogre::Vector3 getForce() const;
+    //! get the force acting on the body.
+    Ogre::Vector3 getForce() const;
 
-	//! get the torque acting on the body.
-	Ogre::Vector3 getTorque() const;
+    //! get the torque acting on the body.
+    Ogre::Vector3 getTorque() const;
 
-	//! get the linear acceleration due to forces acting on the body.
-	Ogre::Vector3 getForceAcceleration() const;
+    //! get the linear acceleration due to forces acting on the body.
+    Ogre::Vector3 getForceAcceleration() const;
 
-	//! get the rotational acceleration due to torque acting on the body.
-	Ogre::Vector3 getTorqueAcceleration() const;
+    //! get the rotational acceleration due to torque acting on the body.
+    Ogre::Vector3 getTorqueAcceleration() const;
 
-	//! get linear damping
-	Ogre::Real getLinearDamping() const { return (Ogre::Real)NewtonBodyGetLinearDamping( m_body ); }
+    //! get linear damping
+    Ogre::Real getLinearDamping() const { return (Ogre::Real)NewtonBodyGetLinearDamping( m_body ); }
 
-	//! get angular damping
-	Ogre::Vector3 getAngularDamping() const;
+    //! get angular damping
+    Ogre::Vector3 getAngularDamping() const;
 
     //! calculate force needed for given velocity
     Ogre::Vector3 calculateInverseDynamicsForce(Ogre::Real timestep, Ogre::Vector3 desiredVelocity);
 
-	//! get the freeze threshold
-	//void getFreezeThreshold( Ogre::Real&amp; speed, Ogre::Real&amp; omega ) const { NewtonBodyGetFreezeTreshold( m_body, &amp;speed, &amp;omega ); }
+    //! get the freeze threshold
+    //void getFreezeThreshold( Ogre::Real&amp; speed, Ogre::Real&amp; omega ) const { NewtonBodyGetFreezeTreshold( m_body, &amp;speed, &amp;omega ); }
 
-	//! add an impulse (relative change in velocity) to a body.  values are in world coordinates.
-	void addImpulse( const Ogre::Vector3&amp; deltav, const Ogre::Vector3&amp; posit ) { NewtonBodyAddImpulse( m_body, &amp;deltav.x, &amp;posit.x ); }
+    //! add an impulse (relative change in velocity) to a body.  values are in world coordinates.
+    void addImpulse( const Ogre::Vector3&amp; deltav, const Ogre::Vector3&amp; posit ) { NewtonBodyAddImpulse( m_body, &amp;deltav.x, &amp;posit.x ); }
 
-	//! add force to the body.  
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void addForce( const Ogre::Vector3&amp; force ) { NewtonBodyAddForce( m_body, &amp;force.x ); }
+    //! add force to the body.  
+    /*!
+        this function is only valid inside a ForceCallback function!
+    */
+    void addForce( const Ogre::Vector3&amp; force ) { NewtonBodyAddForce( m_body, &amp;force.x ); }
 
-	//! add torque to the body.
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void addTorque( const Ogre::Vector3&amp; torque ) { NewtonBodyAddTorque( m_body, &amp;torque.x ); }
+    //! add torque to the body.
+    /*!
+        this function is only valid inside a ForceCallback function!
+    */
+    void addTorque( const Ogre::Vector3&amp; torque ) { NewtonBodyAddTorque( m_body, &amp;torque.x ); }
 
-	//! set the force for a body.
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void setForce( const Ogre::Vector3&amp; force ) { NewtonBodySetForce( m_body, &amp;force.x ); }
+    //! set the force for a body.
+    /*!
+        this function is only valid inside a ForceCallback function!
+    */
+    void setForce( const Ogre::Vector3&amp; force ) { NewtonBodySetForce( m_body, &amp;force.x ); }
 
-	//! set the torque for a body.
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void setTorque( const Ogre::Vector3&amp; torque ) { NewtonBodySetTorque( m_body, &amp;torque.x ); }
+    //! set the torque for a body.
+    /*!
+        this function is only valid inside a ForceCallback function!
+    */
+    void setTorque( const Ogre::Vector3&amp; torque ) { NewtonBodySetTorque( m_body, &amp;torque.x ); }
 
 
-	//! apply a buoyancy force to the body.
-	/*!
-		buoyancy is one of the more powerful and overlooked features of the Newton physics system.  you can of course
-		simulate floating objects, and even lighter-than-air objects like balloons, etc.
-		\param fluidDensity density of the fluid.
-		\param fluidLinearViscosity how much the fluid slows linear motion
-		\param fluidAngularViscosity how much the fluid slows rotational motion
-		\param gravity vector representing world gravity.
-		\param buoyancyPlaneCallback user function that returns the plane equation for the fluid at the current location. pass NULL to assume the body is fully immersed in fluid.  see the setCustomForceAndTorqueCallback() docs to info on how to bind class member functions.
-	*/
-	void addBouyancyForce( Ogre::Real fluidDensity, Ogre::Real fluidLinearViscosity , Ogre::Real fluidAngularViscosity , const Ogre::Vector3&amp; gravity, buoyancyPlaneCallback callback );
-	template&lt;class c&gt; void addBouyancyForce( Ogre::Real fluidDensity, Ogre::Real fluidLinearViscosity , Ogre::Real fluidAngularViscosity , const Ogre::Vector3&amp; gravity, boost::function&lt;bool(c*, int, Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, Ogre::Plane&amp;)&gt; callback, c *instancedClassPointer )
-	{
-		addBouyancyForce( fluidDensity, fluidLinearViscosity, fluidAngularViscosity, gravity, boost::bind(callback, instancedClassPointer, _1, _2, _3, _4, _5) );
-	}
+    //! apply a buoyancy force to the body.
+    /*!
+        buoyancy is one of the more powerful and overlooked features of the Newton physics system.  you can of course
+        simulate floating objects, and even lighter-than-air objects like balloons, etc.
+        \param fluidDensity density of the fluid.
+        \param fluidLinearViscosity how much the fluid slows linear motion
+        \param fluidAngularViscosity how much the fluid slows rotational motion
+        \param gravity vector representing world gravity.
+        \param buoyancyPlaneCallback user function that returns the plane equation for the fluid at the current location. pass NULL to assume the body is fully immersed in fluid.  see the setCustomForceAndTorqueCallback() docs to info on how to bind class member functions.
+    */
+    void addBouyancyForce( Ogre::Real fluidDensity, Ogre::Real fluidLinearViscosity , Ogre::Real fluidAngularViscosity , const Ogre::Vector3&amp; gravity, buoyancyPlaneCallback callback );
+    template&lt;class c&gt; void addBouyancyForce( Ogre::Real fluidDensity, Ogre::Real fluidLinearViscosity , Ogre::Real fluidAngularViscosity , const Ogre::Vector3&amp; gravity, boost::function&lt;bool(c*, int, Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, Ogre::Plane&amp;)&gt; callback, c *instancedClassPointer )
+    {
+        addBouyancyForce( fluidDensity, fluidLinearViscosity, fluidAngularViscosity, gravity, boost::bind(callback, instancedClassPointer, _1, _2, _3, _4, _5) );
+    }
 
 
     //! use this function to iterate through all bodies
@@ -377,21 +378,21 @@
 
 
 
-	//! helper function that adds a force (and resulting torque) to an object in global cordinates.
-	/*!
-		this function is only valid inside a ForceCallback function!
-		\param force vector representing force, in global space
-		\param pos vector representing location of force, in global space
-	*/
-	void addGlobalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos );
+    //! helper function that adds a force (and resulting torque) to an object in global cordinates.
+    /*!
+        this function is only valid inside a ForceCallback function!
+        \param force vector representing force, in global space
+        \param pos vector representing location of force, in global space
+    */
+    void addGlobalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos );
 
-	// helper function that adds a force (and resulting torque) to an object in local coordinates.
-	/*!
-		this function is only valid inside a ForceCallback function!
-		\param force vector representing force, in local space of the body
-		\param pos vector representing locatino of force, in local space of the body
-	*/
-	void addLocalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos );
+    // helper function that adds a force (and resulting torque) to an object in local coordinates.
+    /*!
+        this function is only valid inside a ForceCallback function!
+        \param force vector representing force, in local space of the body
+        \param pos vector representing locatino of force, in local space of the body
+    */
+    void addLocalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos );
 
     //! Returns the Collisiontype for the Collision from this Body
     /*!
@@ -407,36 +408,36 @@
 
 protected:
 
-	NewtonBody*			m_body;
-	const Collision*	m_collision;
-	const MaterialID*	m_matid;
-	const World*		m_world;
-	
+    NewtonBody*         m_body;
+    const Collision*    m_collision;
+    const MaterialID*   m_matid;
+    const World*        m_world;
+    
 
-	void*				m_userdata;
-	
-	int					m_type;
-	Ogre::Node*			m_node;
+    void*               m_userdata;
+    
+    int                 m_type;
+    Ogre::Node*         m_node;
 
-	ForceCallback			m_forcecallback;
-	TransformCallback		m_transformcallback;
-	buoyancyPlaneCallback	m_buoyancycallback;
+    ForceCallback           m_forcecallback;
+    TransformCallback       m_transformcallback;
+    buoyancyPlaneCallback   m_buoyancycallback;
 
 private:
 
-	static void _CDECL newtonDestructor( const NewtonBody* body );
+    static void _CDECL newtonDestructor( const NewtonBody* body );
 
-	static void _CDECL newtonTransformCallback( const NewtonBody* body, const float* matrix, int threadIndex );
-	static void _CDECL newtonForceTorqueCallback( const NewtonBody* body, float timestep, int threadIndex );
+    static void _CDECL newtonTransformCallback( const NewtonBody* body, const float* matrix, int threadIndex );
+    static void _CDECL newtonForceTorqueCallback( const NewtonBody* body, float timestep, int threadIndex );
 
-	static int _CDECL newtonBuoyancyCallback( const int collisionID, void* context, const float* globalSpaceMatrix, float* globalSpacePlane );
+    static int _CDECL newtonBuoyancyCallback( const int collisionID, void* context, const float* globalSpaceMatrix, float* globalSpacePlane );
 
 
-	// standard gravity force callback.
-	static void standardForceCallback( Body* me, float timeStep, int threadIndex );
+    // standard gravity force callback.
+    static void standardForceCallback( Body* me, float timeStep, int threadIndex );
 
-	// standard transform callback.
-	static void standardTransformCallback( Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos, int threadIndex );
+    // standard transform callback.
+    static void standardTransformCallback( Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos, int threadIndex );
 };
 
 

Modified: dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 
@@ -27,38 +28,38 @@
 
 //! Iterate through all bodies in a specific AABB in the world.
 /*!
-	this class is an easy way to loop through all bodies in an AABB in the world, performing some kind of action.
+    this class is an easy way to loop through all bodies in an AABB in the world, performing some kind of action.
     if you want to iterate through all bodies, use the world-&gt;getFirstBody and body-&gt;getNext functions.
     You can access this class via World::getBodyInAABBIterator()
 */
 class _OgreNewtExport BodyInAABBIterator
 {
 public:
-	//! function to be called for all bodies
-	/*!
-		This function will be called for every body iterated.  you can put any functionality you might want inside this function.
-	*/
-	typedef boost::function&lt;void(const Body*)&gt; IteratorCallback;
+    //! function to be called for all bodies
+    /*!
+        This function will be called for every body iterated.  you can put any functionality you might want inside this function.
+    */
+    typedef boost::function&lt;void(const Body*)&gt; IteratorCallback;
 
-	//! perform an iteration
-	/*!
-		will call the provided function for all bodies in the world.
-		\param callback pointer to a function to be used
+    //! perform an iteration
+    /*!
+        will call the provided function for all bodies in the world.
+        \param callback pointer to a function to be used
         \warning you cannot call this functions from different threads at the same time
-	*/
-	void go( const Ogre::AxisAlignedBox &amp;aabb, IteratorCallback callback ) const;
-	template &lt;class c&gt; void go( const Ogre::AxisAlignedBox &amp;aabb, boost::function&lt;void(c*, Body*)&gt; callback, c* instancedClassPointer ) const
-	{
-		go ( aabb, boost::bind(callback, instancedClassPointer, _1) );
-	}
+    */
+    void go( const Ogre::AxisAlignedBox &amp;aabb, IteratorCallback callback ) const;
+    template &lt;class c&gt; void go( const Ogre::AxisAlignedBox &amp;aabb, boost::function&lt;void(c*, Body*)&gt; callback, c* instancedClassPointer ) const
+    {
+        go ( aabb, boost::bind(callback, instancedClassPointer, _1) );
+    }
 
 protected:
     friend class OgreNewt::World;
     //! this function must only be used by an instance of the OgreNewt::World class
     BodyInAABBIterator(const OgreNewt::World* world);
 
-	const OgreNewt::World*			m_world;
-	mutable IteratorCallback		m_callback;
+    const OgreNewt::World*          m_world;
+    mutable IteratorCallback        m_callback;
 
 private:
     //! this function is declared private, so nobody can use it!
@@ -70,11 +71,11 @@
     //! this function is declared private, so nobody can use it!
     const BodyInAABBIterator&amp; operator=(const BodyInAABBIterator&amp; a) { return a; } // actually this function must *not* be called...
 
-	static void _CDECL newtonIterator( const NewtonBody* body );
+    static void _CDECL newtonIterator( const NewtonBody* body );
 };
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
-#endif	// _INCLUDE_OGRENEWT_BODYINAABBITERATOR
+#endif  // _INCLUDE_OGRENEWT_BODYINAABBITERATOR
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Collision.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_COLLISION
@@ -24,82 +25,82 @@
 
 enum _OgreNewtExport CollisionPrimitive
 {
-	BoxPrimitive				=	SERIALIZE_ID_BOX,
-	ConePrimitive				=	SERIALIZE_ID_CONE,
-	EllipsoidPrimitive			=	SERIALIZE_ID_SPHERE,
-	CapsulePrimitive			=	SERIALIZE_ID_CAPSULE,
-	CylinderPrimitive			=	SERIALIZE_ID_CYLINDER,
-	CompoundCollisionPrimitive	=	SERIALIZE_ID_COMPOUND,
-	ConvexHullPrimitive			=	SERIALIZE_ID_CONVEXHULL,
-	ConvexHullModifierPrimitive	=	SERIALIZE_ID_CONVEXMODIFIER,
-	ChamferCylinderPrimitive	=	SERIALIZE_ID_CHAMFERCYLINDER,
-	TreeCollisionPrimitive		=	SERIALIZE_ID_TREE,
-	NullPrimitive				=	SERIALIZE_ID_NULL,
-	HeighFieldPrimitive			=	SERIALIZE_ID_HEIGHTFIELD,
-	ScenePrimitive				=	SERIALIZE_ID_SCENE
+    BoxPrimitive                =   SERIALIZE_ID_BOX,
+    ConePrimitive               =   SERIALIZE_ID_CONE,
+    EllipsoidPrimitive          =   SERIALIZE_ID_SPHERE,
+    CapsulePrimitive            =   SERIALIZE_ID_CAPSULE,
+    CylinderPrimitive           =   SERIALIZE_ID_CYLINDER,
+    CompoundCollisionPrimitive  =   SERIALIZE_ID_COMPOUND,
+    ConvexHullPrimitive         =   SERIALIZE_ID_CONVEXHULL,
+    ConvexHullModifierPrimitive =   SERIALIZE_ID_CONVEXMODIFIER,
+    ChamferCylinderPrimitive    =   SERIALIZE_ID_CHAMFERCYLINDER,
+    TreeCollisionPrimitive      =   SERIALIZE_ID_TREE,
+    NullPrimitive               =   SERIALIZE_ID_NULL,
+    HeighFieldPrimitive         =   SERIALIZE_ID_HEIGHTFIELD,
+    ScenePrimitive              =   SERIALIZE_ID_SCENE
 };
 
 /*
-	CLASS DEFINITION:
+    CLASS DEFINITION:
 
-		Collision
+        Collision
 
-	USE:
-		this class represents a NewtonCollision, which is the newton structure
-		for collision geometry.
+    USE:
+        this class represents a NewtonCollision, which is the newton structure
+        for collision geometry.
 */
 //! represents a shape for collision detection
 class _OgreNewtExport Collision
 {
 public:
 
-	//! constructor
-	Collision( const World* world );
+    //! constructor
+    Collision( const World* world );
 
-	//! destructor
-	virtual ~Collision();
+    //! destructor
+    virtual ~Collision();
 
-	//! retrieve the Newton pointer
-	/*!
-		retrieves the pointer to the NewtonCollision object.
-	*/
-	const NewtonCollision* getNewtonCollision() const { return m_col; }
+    //! retrieve the Newton pointer
+    /*!
+        retrieves the pointer to the NewtonCollision object.
+    */
+    const NewtonCollision* getNewtonCollision() const { return m_col; }
 
-	/*!
-		Returns the Newton world this collision belongs to.
-	*/
-	const World* getWorld() const {return m_world;}
+    /*!
+        Returns the Newton world this collision belongs to.
+    */
+    const World* getWorld() const {return m_world;}
 
-	//! set a user ID for collision callback identification
-	/*!
-		you can set different IDs for each piece in a compound collision object, and then use these IDs in a collision callback to
-		determine which part is currently colliding.
-	*/
-	void setUserID( unsigned id ) const { NewtonCollisionSetUserID( m_col, id); }
+    //! set a user ID for collision callback identification
+    /*!
+        you can set different IDs for each piece in a compound collision object, and then use these IDs in a collision callback to
+        determine which part is currently colliding.
+    */
+    void setUserID( unsigned id ) const { NewtonCollisionSetUserID( m_col, id); }
 
-	//! get user ID, for collision callback identification
-	unsigned getUserID() const { return NewtonCollisionGetUserID( m_col ); }
+    //! get user ID, for collision callback identification
+    unsigned getUserID() const { return NewtonCollisionGetUserID( m_col ); }
 
-	//! make unique
-	void makeUnique() { NewtonCollisionMakeUnique( m_world-&gt;getNewtonWorld(), m_col ); }
+    //! make unique
+    void makeUnique() { NewtonCollisionMakeUnique( m_world-&gt;getNewtonWorld(), m_col ); }
 
-	//! get the Axis-Aligned Bounding Box for this collision shape.
-	Ogre::AxisAlignedBox getAABB( const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO ) const;
+    //! get the Axis-Aligned Bounding Box for this collision shape.
+    Ogre::AxisAlignedBox getAABB( const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO ) const;
 
-	//! Returns the Collisiontype for this Collision
-	CollisionPrimitive getCollisionPrimitiveType() const { return getCollisionPrimitiveType( m_col ); } 
+    //! Returns the Collisiontype for this Collision
+    CollisionPrimitive getCollisionPrimitiveType() const { return getCollisionPrimitiveType( m_col ); } 
 
-	//! Returns the Collisiontype for the given Newton-Collision
-	static CollisionPrimitive getCollisionPrimitiveType(const NewtonCollision *col);
+    //! Returns the Collisiontype for the given Newton-Collision
+    static CollisionPrimitive getCollisionPrimitiveType(const NewtonCollision *col);
 
-	//! friend functions for the Serializer
-	friend void CollisionSerializer::exportCollision(const Collision* collision, const Ogre::String&amp; filename);
-	friend void CollisionSerializer::importCollision(Ogre::DataStreamPtr&amp; stream, Collision* pDest);
+    //! friend functions for the Serializer
+    friend void CollisionSerializer::exportCollision(const Collision* collision, const Ogre::String&amp; filename);
+    friend void CollisionSerializer::importCollision(Ogre::DataStreamPtr&amp; stream, Collision* pDest);
 
 protected:
 
-	NewtonCollision* m_col;
-	const World* m_world;
+    NewtonCollision* m_col;
+    const World* m_world;
 
 };
 
@@ -110,27 +111,27 @@
 class _OgreNewtExport ConvexCollision : public Collision
 {
 public:
-	//! constructor
-	ConvexCollision( const World* world );
+    //! constructor
+    ConvexCollision( const World* world );
 
-	//! destructor
-	~ConvexCollision();
+    //! destructor
+    ~ConvexCollision();
 
-	//! calculate the volume of the collision shape, useful for buoyancy calculations.
-	Ogre::Real calculateVolume() const { return (Ogre::Real)NewtonConvexCollisionCalculateVolume( m_col ); }
+    //! calculate the volume of the collision shape, useful for buoyancy calculations.
+    Ogre::Real calculateVolume() const { return (Ogre::Real)NewtonConvexCollisionCalculateVolume( m_col ); }
 
-	//! calculate the moment of inertia for this collision primitive, along with the theoretical center-of-mass for this shape.
-	void calculateInertialMatrix( Ogre::Vector3&amp; inertia, Ogre::Vector3&amp; offset ) const { NewtonConvexCollisionCalculateInertialMatrix( m_col, &amp;inertia.x, &amp;offset.x ); }
+    //! calculate the moment of inertia for this collision primitive, along with the theoretical center-of-mass for this shape.
+    void calculateInertialMatrix( Ogre::Vector3&amp; inertia, Ogre::Vector3&amp; offset ) const { NewtonConvexCollisionCalculateInertialMatrix( m_col, &amp;inertia.x, &amp;offset.x ); }
 
-        //! returns true, if the collision is a trigger-volume
-        bool isTriggerVolume() const { return NewtonCollisionIsTriggerVolume(m_col) != 0; }
+    //! returns true, if the collision is a trigger-volume
+    bool isTriggerVolume() const { return NewtonCollisionIsTriggerVolume(m_col) != 0; }
 
-        //! set collision as trigger-volume
-        /*!
-                if a collision is marked as a trigger-volume, there's no calculation of contacts, so
-                this acts like an accurate aabb test
-        */
-        void setAsTriggerVolume(bool trigger) { NewtonCollisionSetAsTriggerVolume(m_col, (int)trigger); }
+    //! set collision as trigger-volume
+    /*!
+       if a collision is marked as a trigger-volume, there's no calculation of contacts, so
+       this acts like an accurate aabb test
+    */    
+    void setAsTriggerVolume(bool trigger) { NewtonCollisionSetAsTriggerVolume(m_col, (int)trigger); }
 };
 
 
@@ -139,22 +140,22 @@
 class _OgreNewtExport ConvexModifierCollision : public Collision
 {
 public:
-	//! constructor
-	ConvexModifierCollision( const OgreNewt::World* world, const OgreNewt::Collision* col );
+    //! constructor
+    ConvexModifierCollision( const OgreNewt::World* world, const OgreNewt::Collision* col );
 
-	//! destructor
-	~ConvexModifierCollision();
+    //! destructor
+    ~ConvexModifierCollision();
 
-	//! apply a scalar matrix to the collision
-	void setScalarMatrix( const Ogre::Matrix4&amp; mat ) const;
+    //! apply a scalar matrix to the collision
+    void setScalarMatrix( const Ogre::Matrix4&amp; mat ) const;
 
-	//! get the scalar matrix for the collision
-	Ogre::Matrix4 getScalarMatrix() const;
+    //! get the scalar matrix for the collision
+    Ogre::Matrix4 getScalarMatrix() const;
 
 };
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_COLLISION

Modified: dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
@@ -20,414 +21,414 @@
 namespace OgreNewt
 {
 
-	//! set of basic collision shapes
-	namespace CollisionPrimitives
-	{
-		//! face-winding enum.
-		enum _OgreNewtExport FaceWinding { FW_DEFAULT, FW_REVERSE };
+    //! set of basic collision shapes
+    namespace CollisionPrimitives
+    {
+        //! face-winding enum.
+        enum _OgreNewtExport FaceWinding { FW_DEFAULT, FW_REVERSE };
 
-		//! null collision (results in no collision)
-		class _OgreNewtExport Null : public OgreNewt::Collision
-		{
-		public:
-			//! constructor
-			Null( const World* world );
+        //! null collision (results in no collision)
+        class _OgreNewtExport Null : public OgreNewt::Collision
+        {
+        public:
+            //! constructor
+            Null( const World* world );
 
-			//! destructor
-			~Null() {}
-		};
+            //! destructor
+            ~Null() {}
+        };
 
 
-		//! standard primitive Box.
-		class _OgreNewtExport Box : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' box collision object.  Can be used for CollisionSerializer::importCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			Box(const World* world);
+        //! standard primitive Box.
+        class _OgreNewtExport Box : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' box collision object.  Can be used for CollisionSerializer::importCollision
+                \param world pointer to the OgreNewt::World
+            */
+            Box(const World* world);
 
-			//! constructor
-			/*!
-				\param world pointer to OgreNewt::World
-				\param size vector representing width, height, depth
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Box( const World* world, const Ogre::Vector3&amp; size, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                \param world pointer to OgreNewt::World
+                \param size vector representing width, height, depth
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            Box( const World* world, const Ogre::Vector3&amp; size, 
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~Box() {}
-		};
+            //! destructor
+            ~Box() {}
+        };
 
-		//! standard primitive Ellipsoid.  
-		class _OgreNewtExport Ellipsoid : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' ellipsoid collision object. Can be used for CollisionSerializer::importCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			Ellipsoid(const World* world);
+        //! standard primitive Ellipsoid.  
+        class _OgreNewtExport Ellipsoid : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' ellipsoid collision object. Can be used for CollisionSerializer::importCollision
+                \param world pointer to the OgreNewt::World
+            */
+            Ellipsoid(const World* world);
 
-			//! constructor
-			/*!
-				for a sphere, pass the same radius for all 3 axis.
-				\param world pointer to OgreNewt::World
-				\param size vector representing radius for all 3 axis
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Ellipsoid(const World* world, const Ogre::Vector3&amp; size, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                for a sphere, pass the same radius for all 3 axis.
+                \param world pointer to OgreNewt::World
+                \param size vector representing radius for all 3 axis
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            Ellipsoid(const World* world, const Ogre::Vector3&amp; size, 
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~Ellipsoid() {}
-		};
+            //! destructor
+            ~Ellipsoid() {}
+        };
 
-		//! standard primitive cylinder.
-		class _OgreNewtExport Cylinder : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' cylinder collision object. Can be used for CollisionSerializer::importCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			Cylinder(const World* world);
+        //! standard primitive cylinder.
+        class _OgreNewtExport Cylinder : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' cylinder collision object. Can be used for CollisionSerializer::importCollision
+                \param world pointer to the OgreNewt::World
+            */
+            Cylinder(const World* world);
 
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the cylinder (Y and Z axis)
-				\param height height of the cylinder (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                default aligned along the local X axis (x=height).
+                \param world pointer to OgreNewt::World
+                \param radius radius of the cylinder (Y and Z axis)
+                \param height height of the cylinder (X axis)
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~Cylinder() {}
-		};
+            //! destructor
+            ~Cylinder() {}
+        };
 
-		//! standard primitive capsule.
-		class _OgreNewtExport Capsule : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' capsule collision object. Can be used for CollisionSerializer::importCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			Capsule(const World* world);
+        //! standard primitive capsule.
+        class _OgreNewtExport Capsule : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' capsule collision object. Can be used for CollisionSerializer::importCollision
+                \param world pointer to the OgreNewt::World
+            */
+            Capsule(const World* world);
 
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the capsule (Y and Z axis)
-				\param height height of the capsule (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                default aligned along the local X axis (x=height).
+                \param world pointer to OgreNewt::World
+                \param radius radius of the capsule (Y and Z axis)
+                \param height height of the capsule (X axis)
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~Capsule() {}
-		};
+            //! destructor
+            ~Capsule() {}
+        };
 
-		//! standard primitive cone.
-		class _OgreNewtExport Cone : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' cone collision object. Can be used for CollisionSerializer::importCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			Cone(const World* world);
+        //! standard primitive cone.
+        class _OgreNewtExport Cone : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' cone collision object. Can be used for CollisionSerializer::importCollision
+                \param world pointer to the OgreNewt::World
+            */
+            Cone(const World* world);
 
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the cone (Y and Z axis)
-				\param height height of the cone (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                default aligned along the local X axis (x=height).
+                \param world pointer to OgreNewt::World
+                \param radius radius of the cone (Y and Z axis)
+                \param height height of the cone (X axis)
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~Cone() {}
-		};
+            //! destructor
+            ~Cone() {}
+        };
 
-		//! filled-donut shape primitive.
-		class _OgreNewtExport ChamferCylinder : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' chamferycylinder collision object. Can be used for CollisionSerializer::importCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			ChamferCylinder(const World* world);
+        //! filled-donut shape primitive.
+        class _OgreNewtExport ChamferCylinder : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' chamferycylinder collision object. Can be used for CollisionSerializer::importCollision
+                \param world pointer to the OgreNewt::World
+            */
+            ChamferCylinder(const World* world);
 
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the chamfer cylinder (Y and Z axis)
-				\param height height of the chamfer cylinder (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                default aligned along the local X axis (x=height).
+                \param world pointer to OgreNewt::World
+                \param radius radius of the chamfer cylinder (Y and Z axis)
+                \param height height of the chamfer cylinder (X axis)
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~ChamferCylinder() {}
-		};	
+            //! destructor
+            ~ChamferCylinder() {}
+        };  
 
-		//! ConvexHull primitive
-		/*!
-			 &quot;wrap&quot; around a set cloud of vertices.  a convex hull is the smallest possible convex shape that fully encloses all points supplied.
-		 */
-		class _OgreNewtExport ConvexHull : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' convexhull collision object. Can be used for CollisionSerializer::importCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			ConvexHull(const World* world);
+        //! ConvexHull primitive
+        /*!
+             &quot;wrap&quot; around a set cloud of vertices.  a convex hull is the smallest possible convex shape that fully encloses all points supplied.
+         */
+        class _OgreNewtExport ConvexHull : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' convexhull collision object. Can be used for CollisionSerializer::importCollision
+                \param world pointer to the OgreNewt::World
+            */
+            ConvexHull(const World* world);
 
-			//! constructor
-			/*!
-				Overloaded constructor.  pass a SceneNode*, and it will use the vertex data from the first attached object.
-				\param world pointer to the OgreNewt::World
-				\param node pointer to an Ogre::SceneNode with a single entity attached
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			ConvexHull( const World* world, Ogre::Entity* ent, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                Overloaded constructor.  pass a SceneNode*, and it will use the vertex data from the first attached object.
+                \param world pointer to the OgreNewt::World
+                \param node pointer to an Ogre::SceneNode with a single entity attached
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            ConvexHull( const World* world, Ogre::Entity* ent, 
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			/*!
-				Overloaded constructor.  pass a pointer to an array of vertices and the hull will be made from that.
-				\param world pointer to the OgreNewt::World
-				\param verts pointer to an array of Ogre::Vector3's that contain vertex position data
-				\param vertcount number ot vetices in the array
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount,
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            /*!
+                Overloaded constructor.  pass a pointer to an array of vertices and the hull will be made from that.
+                \param world pointer to the OgreNewt::World
+                \param verts pointer to an array of Ogre::Vector3's that contain vertex position data
+                \param vertcount number ot vetices in the array
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount,
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~ConvexHull() {}
-		};
+            //! destructor
+            ~ConvexHull() {}
+        };
 
-		
+        
 
 
 
-		//! TreeCollision - complex polygonal collision
-		/*!
-			TreeCollision objects are general polygon collision objects.  TreeCollision objects have a requirement that their mass must = 0 (aka are have infinite mass)
-		*/
-		class _OgreNewtExport TreeCollision : public OgreNewt::Collision
-		{
-		public:
-			//! constructor
-			/*!
-				Create a 'blank' tree collision object.  Can be used for manual TreeCollision creation, or to be used with TreeCollisionSerializer::importTreeCollision
-				\param world pointer to the OgreNewt::World
-			*/
-			TreeCollision( const World* world);
+        //! TreeCollision - complex polygonal collision
+        /*!
+            TreeCollision objects are general polygon collision objects.  TreeCollision objects have a requirement that their mass must = 0 (aka are have infinite mass)
+        */
+        class _OgreNewtExport TreeCollision : public OgreNewt::Collision
+        {
+        public:
+            //! constructor
+            /*!
+                Create a 'blank' tree collision object.  Can be used for manual TreeCollision creation, or to be used with TreeCollisionSerializer::importTreeCollision
+                \param world pointer to the OgreNewt::World
+            */
+            TreeCollision( const World* world);
 
-			//! constructor
-			/*!
-				Create a tree collision object.
-				\param world pointer to the OgreNewt::World
-				\param node pointer to an Ogre::SceneNode with a single entity attached.
-				\param optimize bool whether you want to optimize the collision or not.
-			*/
-			TreeCollision( const World* world, Ogre::Entity* ent, bool optimize, FaceWinding fw = FW_DEFAULT );
+            //! constructor
+            /*!
+                Create a tree collision object.
+                \param world pointer to the OgreNewt::World
+                \param node pointer to an Ogre::SceneNode with a single entity attached.
+                \param optimize bool whether you want to optimize the collision or not.
+            */
+            TreeCollision( const World* world, Ogre::Entity* ent, bool optimize, FaceWinding fw = FW_DEFAULT );
 
-			//! constructor
-			/*!
-				build a TreeCollision from vertice and index information.  This can be used with the dotScene scene manager
-				for building TreeCollision objects from each mesh in the scene.
-				\param world pointer to OgreNewt::World
-				\param numVertices number of vertices passed in the array.
-				\param numIndices number of indices passed in the array.
-				\param vertices pointer to array of vertices (positions only).
-				\param indices pointer to array of indices.
-				\param optimize bool whether you want to optimize the collision or not.
-			*/
-			TreeCollision( const World* world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, FaceWinding fw = FW_DEFAULT); 
+            //! constructor
+            /*!
+                build a TreeCollision from vertice and index information.  This can be used with the dotScene scene manager
+                for building TreeCollision objects from each mesh in the scene.
+                \param world pointer to OgreNewt::World
+                \param numVertices number of vertices passed in the array.
+                \param numIndices number of indices passed in the array.
+                \param vertices pointer to array of vertices (positions only).
+                \param indices pointer to array of indices.
+                \param optimize bool whether you want to optimize the collision or not.
+            */
+            TreeCollision( const World* world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, FaceWinding fw = FW_DEFAULT); 
 
-			//! constructor
-			/*!
-				build a TreeCollision from vertice and index information.  This can be used with the ogre Paging Landscape SceneManager,
-				or other custom solutions.
-				\param world pointer to OgreNewt::World
-				\param numVertices number of vertices in the array.
-				\param vertices pointer to array of Ogre::Vector3 vertices (positions only)
-				\param indexData pointer to Ogre::IndexData for the mesh
-				\param optimize bool whether you want to optimize the collision or not.
-			*/
-			TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, FaceWinding fw = FW_DEFAULT);
+            //! constructor
+            /*!
+                build a TreeCollision from vertice and index information.  This can be used with the ogre Paging Landscape SceneManager,
+                or other custom solutions.
+                \param world pointer to OgreNewt::World
+                \param numVertices number of vertices in the array.
+                \param vertices pointer to array of Ogre::Vector3 vertices (positions only)
+                \param indexData pointer to Ogre::IndexData for the mesh
+                \param optimize bool whether you want to optimize the collision or not.
+            */
+            TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, FaceWinding fw = FW_DEFAULT);
 
-			//! destructor
-			virtual ~TreeCollision() {}
+            //! destructor
+            virtual ~TreeCollision() {}
 
-			//! start a tree collision creation
-			void start();
+            //! start a tree collision creation
+            void start();
 
-			//! add a poly to the tree collision
-			/*!
-				Add a single poly to the tree collision.
-				\param polys pointer to an array of 3 Vector3D objects representing the global position of each poly.
-				\param ID and identifier to assign to this poly, that can be retrieved later upon collision detection.
-			*/
-			void addPoly( Ogre::Vector3* polys, unsigned int ID );
+            //! add a poly to the tree collision
+            /*!
+                Add a single poly to the tree collision.
+                \param polys pointer to an array of 3 Vector3D objects representing the global position of each poly.
+                \param ID and identifier to assign to this poly, that can be retrieved later upon collision detection.
+            */
+            void addPoly( Ogre::Vector3* polys, unsigned int ID );
 
-			//! finish the tree collision
-			void finish( bool optimize );
+            //! finish the tree collision
+            void finish( bool optimize );
 
-			//! set RayCastCallback active/disabled
-			/*!
-				\param active true = Callback active; false = Callback disabled 
-			*/
-			void setRayCastCallbackactive(bool active = true)
-			{
-				setRayCastCallbackactive( active, m_col );
-			}
+            //! set RayCastCallback active/disabled
+            /*!
+                \param active true = Callback active; false = Callback disabled 
+            */
+            void setRayCastCallbackactive(bool active = true)
+            {
+                setRayCastCallbackactive( active, m_col );
+            }
 
             //! used internally
-			static float _CDECL newtonRayCastCallback(float distance, float* normal, int faceId, void* userData);
+            static float _CDECL newtonRayCastCallback(float distance, float* normal, int faceId, void* userData);
 
         private:
-			static void setRayCastCallbackactive( bool active , const NewtonCollision *col );
+            static void setRayCastCallbackactive( bool active , const NewtonCollision *col );
 
         };
 
-		////////////////////////////////////////////////////////
-		//! TreeCollision created by parsing a tree of SceneNodes, adding collision data of all meshes.
-		/*!
-			Users can inherit this class, and inherit the &quot;getID&quot; function to perform their own filtering on the
-			IDs to pass to Newton.  IDs are useful during collision callbacks to determine which part of the world
-			is being hit.
+        ////////////////////////////////////////////////////////
+        //! TreeCollision created by parsing a tree of SceneNodes, adding collision data of all meshes.
+        /*!
+            Users can inherit this class, and inherit the &quot;getID&quot; function to perform their own filtering on the
+            IDs to pass to Newton.  IDs are useful during collision callbacks to determine which part of the world
+            is being hit.
 
-			By default, the ID is set to an incrementing integer.
-		*/
-		class _OgreNewtExport TreeCollisionSceneParser : public TreeCollision
-		{
-		public:
-			TreeCollisionSceneParser( OgreNewt::World* world );
+            By default, the ID is set to an incrementing integer.
+        */
+        class _OgreNewtExport TreeCollisionSceneParser : public TreeCollision
+        {
+        public:
+            TreeCollisionSceneParser( OgreNewt::World* world );
 
-			~TreeCollisionSceneParser() {}
+            ~TreeCollisionSceneParser() {}
 
-			//! parse the scene.
-			void parseScene( Ogre::SceneNode* startNode, bool optimize = true, FaceWinding fw = FW_DEFAULT );
+            //! parse the scene.
+            void parseScene( Ogre::SceneNode* startNode, bool optimize = true, FaceWinding fw = FW_DEFAULT );
 
-		protected:
+        protected:
 
-			//! this is a user-inherited function that lets you filter which Entities will be added to the treeCollision.
-			/*!
-				return true to add this entity, return false to ignore it.
-				You can also change the face winding on an entity-by-entity basis by changing the fw variable from within the filter.
-			*/
-			virtual bool entityFilter( const Ogre::SceneNode* currentNode, const Ogre::Entity* currentEntity, FaceWinding&amp; fw ) { return true; }
+            //! this is a user-inherited function that lets you filter which Entities will be added to the treeCollision.
+            /*!
+                return true to add this entity, return false to ignore it.
+                You can also change the face winding on an entity-by-entity basis by changing the fw variable from within the filter.
+            */
+            virtual bool entityFilter( const Ogre::SceneNode* currentNode, const Ogre::Entity* currentEntity, FaceWinding&amp; fw ) { return true; }
 
-			//! user inherit-able function, allows customization of the ID to be assigned to this group of polygons.
-			virtual unsigned int getID( const Ogre::SceneNode* currentNode, const Ogre::Entity* currentEntity, unsigned int currentSubMesh ) { return count++; }
+            //! user inherit-able function, allows customization of the ID to be assigned to this group of polygons.
+            virtual unsigned int getID( const Ogre::SceneNode* currentNode, const Ogre::Entity* currentEntity, unsigned int currentSubMesh ) { return count++; }
 
-		private:
-			//! recursive function to parse a single scene node.
-			void _parseNode( Ogre::SceneNode* node, const Ogre::Quaternion&amp; curOrient, const Ogre::Vector3&amp; curPos, const Ogre::Vector3&amp; curScale, FaceWinding fw );
+        private:
+            //! recursive function to parse a single scene node.
+            void _parseNode( Ogre::SceneNode* node, const Ogre::Quaternion&amp; curOrient, const Ogre::Vector3&amp; curPos, const Ogre::Vector3&amp; curScale, FaceWinding fw );
 
 
-			static int count;
-		};
+            static int count;
+        };
 
-		////////////////////////////////////////////////////////
-		//	COMPOUND COLLISION!
+        ////////////////////////////////////////////////////////
+        //  COMPOUND COLLISION!
 
-		//! create a compound from several collision pieces.
-		class _OgreNewtExport CompoundCollision : public OgreNewt::Collision
-		{
-		public:
-			//! constructor
-			/*!
-			Create a 'blank' ellipsoid compoundcollision object. Can be used for CollisionSerializer::importCollision
-			\param world pointer to the OgreNewt::World
-			*/
-			CompoundCollision(const World* world);
+        //! create a compound from several collision pieces.
+        class _OgreNewtExport CompoundCollision : public OgreNewt::Collision
+        {
+        public:
+            //! constructor
+            /*!
+            Create a 'blank' ellipsoid compoundcollision object. Can be used for CollisionSerializer::importCollision
+            \param world pointer to the OgreNewt::World
+            */
+            CompoundCollision(const World* world);
 
-			//! constructor
-			/*!
-				creates a compound collision object made from an array of simple primitive parts.  can be used to make very complex
-				collision shapes.
-				\param world pointer to the OgreNewt::World
-				\param col_array std::vector of pointers to existing collision objects.
-			*/
-			CompoundCollision( const World* world, std::vector&lt;OgreNewt::Collision*&gt; col_array );
+            //! constructor
+            /*!
+                creates a compound collision object made from an array of simple primitive parts.  can be used to make very complex
+                collision shapes.
+                \param world pointer to the OgreNewt::World
+                \param col_array std::vector of pointers to existing collision objects.
+            */
+            CompoundCollision( const World* world, std::vector&lt;OgreNewt::Collision*&gt; col_array );
 
-			//! destructor
-			~CompoundCollision() {}
-		};
+            //! destructor
+            ~CompoundCollision() {}
+        };
 
 
-		////////////////////////////////////////////////////////
-		// supplemental primitives built from convex hulls
-		////////////////////////////////////////////////////////
+        ////////////////////////////////////////////////////////
+        // supplemental primitives built from convex hulls
+        ////////////////////////////////////////////////////////
 
-		//! Pyramid primitive
-		/*!
-			4-sided base, comes to a single point. base is aligned on XZ plane. made from Convex Hull internally.  supplied as part of the
-			OgreNewt library, but not a built-in function of Newton istelf.
-		*/
-		class _OgreNewtExport Pyramid : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-			Create a 'blank' ellipsoid collision object. Can be used for CollisionSerializer::importCollision
-			\param world pointer to the OgreNewt::World
-			*/
-			Pyramid(const World* world);
+        //! Pyramid primitive
+        /*!
+            4-sided base, comes to a single point. base is aligned on XZ plane. made from Convex Hull internally.  supplied as part of the
+            OgreNewt library, but not a built-in function of Newton istelf.
+        */
+        class _OgreNewtExport Pyramid : public OgreNewt::ConvexCollision
+        {
+        public:
+            //! constructor
+            /*!
+            Create a 'blank' ellipsoid collision object. Can be used for CollisionSerializer::importCollision
+            \param world pointer to the OgreNewt::World
+            */
+            Pyramid(const World* world);
 
-			//! constructor
-			/*!
-				\param world pointer to the OgreNewt::World
-				\param size Ogre::Vector3 size.
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Pyramid( const World* world, const Ogre::Vector3&amp; size,
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
+            //! constructor
+            /*!
+                \param world pointer to the OgreNewt::World
+                \param size Ogre::Vector3 size.
+                \param orient orientation offset of the primitive
+                \param pos position offset of the primitive
+            */
+            Pyramid( const World* world, const Ogre::Vector3&amp; size,
+                const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
 
-			//! destructor
-			~Pyramid() {}
-		};
+            //! destructor
+            ~Pyramid() {}
+        };
 
 
 
-	}	// end namespace CollisionPrimitives
+    }   // end namespace CollisionPrimitives
 
 }// end namespace OgreNewt
 
-#endif	// _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
+#endif  // _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
 

Modified: dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-OgreNewt Library
+    OgreNewt Library
 
-Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_COLLISIONSERIALIZER
@@ -17,7 +18,7 @@
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
 {
-	class Collision;
+    class Collision;
 
   /*!
   This class can be used to (de)serialize a Collision. Pre-building a Collision and serializing from a tool,
@@ -36,11 +37,11 @@
     /*!
     Serialize the Collision to a file with the given name.
     */
-	void exportCollision(const Collision* collision, const Ogre::String&amp; filename);
+    void exportCollision(const Collision* collision, const Ogre::String&amp; filename);
 
     /*!
     Deserialize the Collision from a DataStream.
-	this will create a NEW Collision object
+    this will create a NEW Collision object
     */
     void importCollision(Ogre::DataStreamPtr&amp; stream, Collision* pDest);
 
@@ -59,7 +60,7 @@
   };
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_COLLISIONSERIALIZER

Modified: dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_CONTACTCALLBACK
@@ -23,39 +24,39 @@
 
 //! custom contact behavior
 /*!
-	this class is for creating custom behavior between material GroupIDs.
-	this class must be inherited, and the user functions created, and then
-	added to a MaterialPair class.
+    this class is for creating custom behavior between material GroupIDs.
+    this class must be inherited, and the user functions created, and then
+    added to a MaterialPair class.
 */
 class _OgreNewtExport ContactCallback
 {
 public:
 
-	//! constructor
-	ContactCallback();
+    //! constructor
+    ContactCallback();
 
-	//! destructor
-	virtual ~ContactCallback();
+    //! destructor
+    virtual ~ContactCallback();
 
-	//! user-defined AABB-overlap function
-	/*!
-		this function is called when 2 bodies AABB overlap.  they have not yet collided, but *may* do so this loop.
-		at this point, m_body0 and m_body1 are defined, but the contact isn't yet valid, so none of the member functions
-		can be called yet.  they must be called from the contacsProcess() function.
-		return 0 to ignore the collision, 1 to allow it.
-	*/
-	virtual int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex ) { return 1; }
+    //! user-defined AABB-overlap function
+    /*!
+        this function is called when 2 bodies AABB overlap.  they have not yet collided, but *may* do so this loop.
+        at this point, m_body0 and m_body1 are defined, but the contact isn't yet valid, so none of the member functions
+        can be called yet.  they must be called from the contacsProcess() function.
+        return 0 to ignore the collision, 1 to allow it.
+    */
+    virtual int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex ) { return 1; }
 
-	//! user-defined Process function
-	/*!
-		user process function.  it is called for each colliding pair of bodies. you can use
+    //! user-defined Process function
+    /*!
+        user process function.  it is called for each colliding pair of bodies. you can use
         the ContactJoint to iterate through all contact-points and change the &quot;material&quot; of each contact-point!
-	 */
-	virtual void contactsProcess( OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timeStep, int threadIndex ) { }
+     */
+    virtual void contactsProcess( OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timeStep, int threadIndex ) { }
 };
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_CONTACTCALLBACK

Modified: dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by melven
+        by melven
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_CONTACTJOINT
@@ -69,7 +70,7 @@
 
 //! with the methods from this class you can set the behavior of each contac-point
 /*!
-	this class is for creating custom behavior between material GroupIDs.
+    this class is for creating custom behavior between material GroupIDs.
     this class must not be inherited or instantiated directly in any way,
     you can obtain an object of this class in the contact-callback
     from the contactJoint and iterate through all contacts using the 
@@ -79,11 +80,11 @@
 {
 public:
 
-	//! constructor
-	Contact(void *contact, ContactJoint* parent);
+    //! constructor
+    Contact(void *contact, ContactJoint* parent);
 
-	//! destructor
-	~Contact();
+    //! destructor
+    ~Contact();
 
     //! return true, if this is not a valid contact (end of the contact-list!)
     operator bool() const { return m_contact != NULL; }
@@ -91,59 +92,59 @@
     //! get the next contact from the parent contact-joint
     Contact getNext() const;
 
-	// basic contact control commands... they can only be used, if this is a valid contact ( !contact == false )
+    // basic contact control commands... they can only be used, if this is a valid contact ( !contact == false )
 
     //! get the first body
     OgreNewt::Body* getBody0() const { return (OgreNewt::Body*) NewtonBodyGetUserData( NewtonJointGetBody0( m_parent-&gt;_getNewtonContactJoint() ) ); }
     OgreNewt::Body* getBody1() const { return (OgreNewt::Body*) NewtonBodyGetUserData( NewtonJointGetBody1( m_parent-&gt;_getNewtonContactJoint() ) ); }
 
-	//! get the face ID of a TreeCollision object
-	unsigned getFaceAttribute() const { return NewtonMaterialGetContactFaceAttribute( m_material ); }
+    //! get the face ID of a TreeCollision object
+    unsigned getFaceAttribute() const { return NewtonMaterialGetContactFaceAttribute( m_material ); }
 
-	//! get the Collision ID of a body currently colliding
-	unsigned getBodyCollisionID( OgreNewt::Body* body ) const { return NewtonMaterialGetBodyCollisionID( m_material, body-&gt;getNewtonBody() ); }
+    //! get the Collision ID of a body currently colliding
+    unsigned getBodyCollisionID( OgreNewt::Body* body ) const { return NewtonMaterialGetBodyCollisionID( m_material, body-&gt;getNewtonBody() ); }
 
-	//! speed of the collision
-	Ogre::Real getNormalSpeed() const { return (Ogre::Real)NewtonMaterialGetContactNormalSpeed( m_material ); }
+    //! speed of the collision
+    Ogre::Real getNormalSpeed() const { return (Ogre::Real)NewtonMaterialGetContactNormalSpeed( m_material ); }
 
-	//! force of the collision
-	/*!
-		only valid for objects in a stable state (sitting on top of each other, etc)
-	*/
-	Ogre::Vector3 getForce() const;
+    //! force of the collision
+    /*!
+        only valid for objects in a stable state (sitting on top of each other, etc)
+    */
+    Ogre::Vector3 getForce() const;
 
-	//! get positoin and normal of the collision
-	void getPositionAndNormal( Ogre::Vector3&amp; pos, Ogre::Vector3&amp; norm ) const { NewtonMaterialGetContactPositionAndNormal(m_material, &amp;pos.x, &amp;norm.x); }
+    //! get positoin and normal of the collision
+    void getPositionAndNormal( Ogre::Vector3&amp; pos, Ogre::Vector3&amp; norm ) const { NewtonMaterialGetContactPositionAndNormal(m_material, &amp;pos.x, &amp;norm.x); }
 
-	//! get the tangent vectors of the collision
-	void getTangentDirections( Ogre::Vector3&amp; dir0, Ogre::Vector3&amp; dir1 ) const { NewtonMaterialGetContactTangentDirections(m_material, &amp;dir0.x, &amp;dir1.x); }
+    //! get the tangent vectors of the collision
+    void getTangentDirections( Ogre::Vector3&amp; dir0, Ogre::Vector3&amp; dir1 ) const { NewtonMaterialGetContactTangentDirections(m_material, &amp;dir0.x, &amp;dir1.x); }
 
-	//! get tangent speed of the collision
-	Ogre::Real getTangentSpeed( int index ) const { return (Ogre::Real)NewtonMaterialGetContactTangentSpeed( m_material, index ); }
+    //! get tangent speed of the collision
+    Ogre::Real getTangentSpeed( int index ) const { return (Ogre::Real)NewtonMaterialGetContactTangentSpeed( m_material, index ); }
 
-	//! set softness of the current contact
-	void setSoftness( Ogre::Real softness ) { NewtonMaterialSetContactSoftness( m_material, (float)softness ); }
+    //! set softness of the current contact
+    void setSoftness( Ogre::Real softness ) { NewtonMaterialSetContactSoftness( m_material, (float)softness ); }
 
-	//! set elasticity of the current contact
-	void setElasticity( Ogre::Real elasticity ) { NewtonMaterialSetContactElasticity( m_material, (float)elasticity ); }
+    //! set elasticity of the current contact
+    void setElasticity( Ogre::Real elasticity ) { NewtonMaterialSetContactElasticity( m_material, (float)elasticity ); }
 
-	//! set friction state of current contact
-	void setFrictionState( int state, int index ) { NewtonMaterialSetContactFrictionState( m_material, state, index ); }
+    //! set friction state of current contact
+    void setFrictionState( int state, int index ) { NewtonMaterialSetContactFrictionState( m_material, state, index ); }
 
-	//! set static friction for current contact
-	void setFrictionCoef( Ogre::Real stat, Ogre::Real kinetic, int index ) { NewtonMaterialSetContactFrictionCoef( m_material, (float)stat, (float)kinetic, index ); }
+    //! set static friction for current contact
+    void setFrictionCoef( Ogre::Real stat, Ogre::Real kinetic, int index ) { NewtonMaterialSetContactFrictionCoef( m_material, (float)stat, (float)kinetic, index ); }
 
-	//! set tangent acceleration for contact
-	void setTangentAcceleration( Ogre::Real accel, int index ) { NewtonMaterialSetContactTangentAcceleration( m_material, (float)accel, index ); }
+    //! set tangent acceleration for contact
+    void setTangentAcceleration( Ogre::Real accel, int index ) { NewtonMaterialSetContactTangentAcceleration( m_material, (float)accel, index ); }
 
-	//! align tangent vectors with a user supplied direction
-	void rotateTangentDirections( const Ogre::Vector3&amp; dir ) { NewtonMaterialContactRotateTangentDirections( m_material, &amp;dir.x ); }
+    //! align tangent vectors with a user supplied direction
+    void rotateTangentDirections( const Ogre::Vector3&amp; dir ) { NewtonMaterialContactRotateTangentDirections( m_material, &amp;dir.x ); }
 
-	//! manually set the normal for the collision.
-	void setNormalDirection( const Ogre::Vector3&amp; dir ) { NewtonMaterialSetContactNormalDirection( m_material, &amp;dir.x ); }
+    //! manually set the normal for the collision.
+    void setNormalDirection( const Ogre::Vector3&amp; dir ) { NewtonMaterialSetContactNormalDirection( m_material, &amp;dir.x ); }
 
-	//! manually set the acceleration along the collision normal.
-	void setNormalAcceleration( Ogre::Real accel ) { NewtonMaterialSetContactNormalAcceleration( m_material, accel ); }
+    //! manually set the acceleration along the collision normal.
+    void setNormalAcceleration( Ogre::Real accel ) { NewtonMaterialSetContactNormalAcceleration( m_material, accel ); }
 
     //! removes the contact from the parent contact-joint, this means newton doesn't process this contact
     /*!
@@ -152,8 +153,8 @@
     */
     void remove();
 
-	//! get the NewtonMaterial from this callback.
-	NewtonMaterial* _getNewtonMaterial() { return m_material; }
+    //! get the NewtonMaterial from this callback.
+    NewtonMaterial* _getNewtonMaterial() { return m_material; }
 
 protected:
     NewtonMaterial* m_material;
@@ -162,7 +163,7 @@
 };
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_CONTACTJOINT

Modified: dependencies/OgreNewt/inc/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Debugger.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_Debugger.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_DEBUGGER
@@ -24,38 +25,38 @@
     class MaterialID;
     class Collision;
 
-	//! For viewing the Newton rigid bodies visually.
-	/*!
-		This class implements a debug view of the Newton world. You can access it via World::getDebugger().
+    //! For viewing the Newton rigid bodies visually.
+    /*!
+        This class implements a debug view of the Newton world. You can access it via World::getDebugger().
         It needs to be initialized (call World::getDebugger().init(...)).
-	*/
-	class _OgreNewtExport Debugger : public Ogre::Node::Listener
-	{
-	
-	public:
-		~Debugger();
+    */
+    class _OgreNewtExport Debugger : public Ogre::Node::Listener
+    {
+    
+    public:
+        ~Debugger();
 
-		//! init the debugger.
-		/*
-			\param smgr pointer to your Ogre::SceneManager
-		*/
-		void init( Ogre::SceneManager* smgr );
+        //! init the debugger.
+        /*
+            \param smgr pointer to your Ogre::SceneManager
+        */
+        void init( Ogre::SceneManager* smgr );
 
-		//! de-init the debugger (cleantup)
-		void deInit();
+        //! de-init the debugger (cleantup)
+        void deInit();
 
         //! called when one of the nodes used in this class are destroyed
         virtual void nodeDestroyed (const Ogre::Node *);
 
-		//! show the newton world
-		/*!
-			Draws the Newton world as 3D lines with informative text above each body
-		*/
-		void showDebugInformation();
+        //! show the newton world
+        /*!
+            Draws the Newton world as 3D lines with informative text above each body
+        */
+        void showDebugInformation();
 
-		//! remove lines and text drawn
-		void hideDebugInformation();
-	
+        //! remove lines and text drawn
+        void hideDebugInformation();
+    
         //! set default color
         void setDefaultColor(Ogre::ColourValue col);
 
@@ -92,13 +93,13 @@
         //! this function is used internally
         void addHitBody(const OgreNewt::Body* body);
 
-	protected:
+    protected:
         friend class OgreNewt::World;
         //! this function must only be used by an instance of the OgreNewt::World class
         Debugger(const OgreNewt::World* world);
 
         const OgreNewt::World*        m_world;
-		Ogre::SceneNode*		m_debugnode;
+        Ogre::SceneNode*        m_debugnode;
         typedef std::map&lt;int, Ogre::ColourValue&gt; MaterialIdColorMap;
         MaterialIdColorMap      m_materialcolors;
         Ogre::ColourValue       m_defaultcolor;
@@ -138,11 +139,11 @@
         //! this function is declared private, so nobody can use it!
         const Debugger&amp; operator=(const Debugger&amp; d) { return d; } // actually this implementation must *never* be used!
 
-		static void _CDECL newtonPerPoly( void* userData, int vertexCount, const float* faceVertec, int id );
-	};
+        static void _CDECL newtonPerPoly( void* userData, int vertexCount, const float* faceVertec, int id );
+    };
 
-}	// end namespace OgreNewt
+}   // end namespace OgreNewt
 
 
-#endif	// _INCLUDE_OGRENEWT_DEBUGGER
+#endif  // _INCLUDE_OGRENEWT_DEBUGGER
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Joint.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_JOINT
@@ -24,69 +25,69 @@
 
 //! base class for all joints.
 /*!
-	this class is inherited by all other specific joint types.
+    this class is inherited by all other specific joint types.
 */
 class _OgreNewtExport Joint
 {
 public:
 
-	//! constructor
-	Joint();
+    //! constructor
+    Joint();
 
-	//! destructor
-	virtual ~Joint();
+    //! destructor
+    virtual ~Joint();
 
-	//! returns collision state
-	/*!
-		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
-		\return integer value. 1 = collision on, 0 = collision off.
-	*/
-	int getCollisionState() const { return NewtonJointGetCollisionState( m_joint ); }
+    //! returns collision state
+    /*!
+        The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
+        \return integer value. 1 = collision on, 0 = collision off.
+    */
+    int getCollisionState() const { return NewtonJointGetCollisionState( m_joint ); }
 
-	//! sets the collision state
-	/*!
-		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
-		\param state integer value. 1 = collision on, 0 = collision off.
-	*/		
-	void setCollisionState( int state ) const { NewtonJointSetCollisionState( m_joint, state ); }
+    //! sets the collision state
+    /*!
+        The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
+        \param state integer value. 1 = collision on, 0 = collision off.
+    */      
+    void setCollisionState( int state ) const { NewtonJointSetCollisionState( m_joint, state ); }
 
 
-	//! get joint stiffness
-	/*!
-		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
-		\return float representing joint stiffness in range [0,1]
-	*/
-	Ogre::Real getStiffness() const { return (Ogre::Real)NewtonJointGetStiffness( m_joint ); }
+    //! get joint stiffness
+    /*!
+        Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
+        \return float representing joint stiffness in range [0,1]
+    */
+    Ogre::Real getStiffness() const { return (Ogre::Real)NewtonJointGetStiffness( m_joint ); }
 
-	//! set joint stiffness
-	/*!
-		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
-		\param stiffness float representing joint stiffness in range [0,1]
-	*/
-	void setStiffness( Ogre::Real stiffness ) const { NewtonJointSetStiffness( m_joint, stiffness ); }
+    //! set joint stiffness
+    /*!
+        Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
+        \param stiffness float representing joint stiffness in range [0,1]
+    */
+    void setStiffness( Ogre::Real stiffness ) const { NewtonJointSetStiffness( m_joint, stiffness ); }
 
 
-	//! set user data for this joint
-	/*!
-		user data can be used to connect this class to other user classes through the use of this general pointer.
-	*/
-	void setUserData( void* ptr ) { m_userdata = ptr; }
+    //! set user data for this joint
+    /*!
+        user data can be used to connect this class to other user classes through the use of this general pointer.
+    */
+    void setUserData( void* ptr ) { m_userdata = ptr; }
 
-	//! get user data for this joint
-	/*!
-		user data can be used to connect this class to other user classes through the use of this general pointer.
-	*/
-	void* getUserData() const { return m_userdata; }
+    //! get user data for this joint
+    /*!
+        user data can be used to connect this class to other user classes through the use of this general pointer.
+    */
+    void* getUserData() const { return m_userdata; }
 
-		
+        
 protected:
 
-	NewtonJoint* m_joint;
-	const OgreNewt::World* m_world;
+    NewtonJoint* m_joint;
+    const OgreNewt::World* m_world;
 
-	void* m_userdata;
+    void* m_userdata;
 
-	static void _CDECL destructor( const NewtonJoint* me );
+    static void _CDECL destructor( const NewtonJoint* me );
 
 };
 
@@ -97,80 +98,80 @@
 
 //! CustomJoint 
 /*!
-	this class represents a basic class for creating user-defined joints.  this class must be inherited to create discreet joints.
+    this class represents a basic class for creating user-defined joints.  this class must be inherited to create discreet joints.
 */
 class _OgreNewtExport CustomJoint : public Joint
 {
  
 public:
 
-	//! constructor
-	CustomJoint( unsigned int maxDOF, const Body* body0, const Body* body1 );
+    //! constructor
+    CustomJoint( unsigned int maxDOF, const Body* body0, const Body* body1 );
 
-	//! destructor
-	virtual ~CustomJoint();
+    //! destructor
+    virtual ~CustomJoint();
 
-	//! must be over-written for a functioning joint.
-	virtual void submitConstraint( Ogre::Real timeStep, int threadIndex ) = 0;
+    //! must be over-written for a functioning joint.
+    virtual void submitConstraint( Ogre::Real timeStep, int threadIndex ) = 0;
 
 
-	//! find the local orientation and position of the joint with regards to the 2 bodies in the joint.
-	void pinAndDirToLocal( const Ogre::Vector3&amp; pinpt, const Ogre::Vector3&amp; pindir, Ogre::Quaternion&amp; localOrient0, Ogre::Vector3&amp; localPos0, Ogre::Quaternion&amp; localOrient1, Ogre::Vector3&amp; localPos1 ) const;
+    //! find the local orientation and position of the joint with regards to the 2 bodies in the joint.
+    void pinAndDirToLocal( const Ogre::Vector3&amp; pinpt, const Ogre::Vector3&amp; pindir, Ogre::Quaternion&amp; localOrient0, Ogre::Vector3&amp; localPos0, Ogre::Quaternion&amp; localOrient1, Ogre::Vector3&amp; localPos1 ) const;
 
-	//! find the global orientation and position of the joint with regards to the a body in the joint.
-	void localToGlobal( const Ogre::Quaternion&amp; localOrient, const Ogre::Vector3&amp; localPos, Ogre::Quaternion&amp; globalOrient, Ogre::Vector3&amp; globalPos, int bodyIndex = 0 ) const;
+    //! find the global orientation and position of the joint with regards to the a body in the joint.
+    void localToGlobal( const Ogre::Quaternion&amp; localOrient, const Ogre::Vector3&amp; localPos, Ogre::Quaternion&amp; globalOrient, Ogre::Vector3&amp; globalPos, int bodyIndex = 0 ) const;
 
-	//! add a linear row to the constraint.
-	void addLinearRow( const Ogre::Vector3&amp; pt0, const Ogre::Vector3&amp; pt1, const Ogre::Vector3&amp; dir ) const;
+    //! add a linear row to the constraint.
+    void addLinearRow( const Ogre::Vector3&amp; pt0, const Ogre::Vector3&amp; pt1, const Ogre::Vector3&amp; dir ) const;
 
-	//! add an angular row to the constraint.
-	void addAngularRow( Ogre::Radian relativeAngleError, const Ogre::Vector3&amp; dir ) const;
+    //! add an angular row to the constraint.
+    void addAngularRow( Ogre::Radian relativeAngleError, const Ogre::Vector3&amp; dir ) const;
 
-	//! set the general jacobian rows directly.
-	void addGeneralRow( const Ogre::Vector3&amp; linear0, const Ogre::Vector3&amp; angular0, const Ogre::Vector3&amp; linear1, const Ogre::Vector3&amp; angular1 ) const;
+    //! set the general jacobian rows directly.
+    void addGeneralRow( const Ogre::Vector3&amp; linear0, const Ogre::Vector3&amp; angular0, const Ogre::Vector3&amp; linear1, const Ogre::Vector3&amp; angular1 ) const;
 
-	//! set row minimum friction
-	void setRowMinimumFriction( Ogre::Real friction ) const;
+    //! set row minimum friction
+    void setRowMinimumFriction( Ogre::Real friction ) const;
 
-	//! set row maximum friction
-	void setRowMaximumFriction( Ogre::Real friction ) const;
+    //! set row maximum friction
+    void setRowMaximumFriction( Ogre::Real friction ) const;
 
-	//! set row acceleration
-	void setRowAcceleration( Ogre::Real accel ) const;
+    //! set row acceleration
+    void setRowAcceleration( Ogre::Real accel ) const;
 
-	//! set row stiffness
-	void setRowStiffness( Ogre::Real stiffness ) const;
+    //! set row stiffness
+    void setRowStiffness( Ogre::Real stiffness ) const;
 
-	//! apply a spring to this row, allowing for joints with spring behaviour in 1 or more DoF's
-	/*!
-		\param springK float spring constant.
-		\param springD float natural rest state distance of the spring.
-	*/		
-	void setRowSpringDamper( Ogre::Real springK, Ogre::Real springD ) const;
+    //! apply a spring to this row, allowing for joints with spring behaviour in 1 or more DoF's
+    /*!
+        \param springK float spring constant.
+        \param springD float natural rest state distance of the spring.
+    */      
+    void setRowSpringDamper( Ogre::Real springK, Ogre::Real springD ) const;
 
-	//! retrieve the force acting on the current row.
-	Ogre::Real getRowForce( int row ) const { return NewtonUserJointGetRowForce( m_joint, row ); }
+    //! retrieve the force acting on the current row.
+    Ogre::Real getRowForce( int row ) const { return NewtonUserJointGetRowForce( m_joint, row ); }
 
-	//! pin vector to arbitrary quaternion utility function.
-	Ogre::Quaternion grammSchmidt( const Ogre::Vector3&amp; pin ) const;
+    //! pin vector to arbitrary quaternion utility function.
+    Ogre::Quaternion grammSchmidt( const Ogre::Vector3&amp; pin ) const;
 
 protected:
 
-	unsigned int m_maxDOF;
+    unsigned int m_maxDOF;
 
-	const OgreNewt::Body* m_body0;
-	const OgreNewt::Body* m_body1;
+    const OgreNewt::Body* m_body0;
+    const OgreNewt::Body* m_body1;
 
 private:
-	//! newton callback.  used internally.
-	static void _CDECL newtonSubmitConstraint( const NewtonJoint* me, float timeStep, int threadIndex );
-	static void _CDECL newtonGetInfo( const NewtonJoint* me, NewtonJointRecord* info );
+    //! newton callback.  used internally.
+    static void _CDECL newtonSubmitConstraint( const NewtonJoint* me, float timeStep, int threadIndex );
+    static void _CDECL newtonGetInfo( const NewtonJoint* me, NewtonJointRecord* info );
 
 };
 
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_JOINT

Modified: dependencies/OgreNewt/inc/OgreNewt_MaterialID.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_MaterialID.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_MaterialID.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_MATERIALID
@@ -25,33 +26,33 @@
 {
 public:
 
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt;;World
-	*/
-	MaterialID( const World* world );
+    //! constructor
+    /*!
+        \param world pointer to the OgreNewt;;World
+    */
+    MaterialID( const World* world );
 
-	/*!
-		Overloaded constructor, sets the internal ID manually.  should not be used by the end-user.
-	*/
-	MaterialID( const World* world, int ID );
+    /*!
+        Overloaded constructor, sets the internal ID manually.  should not be used by the end-user.
+    */
+    MaterialID( const World* world, int ID );
 
-	//! destructor
-	~MaterialID();
+    //! destructor
+    ~MaterialID();
 
-	//! get Newton-assigned material ID.
-	int getID() const { return id; }
+    //! get Newton-assigned material ID.
+    int getID() const { return id; }
 
 protected:
 
-	int id;
-	const OgreNewt::World* m_world;
+    int id;
+    const OgreNewt::World* m_world;
 
 };
 
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_MATERIALID

Modified: dependencies/OgreNewt/inc/OgreNewt_MaterialPair.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_MaterialPair.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_MaterialPair.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_MATERIALPAIR
@@ -24,76 +25,76 @@
 
 //! define interaction between materials
 /*!
-	this class represents a pair of Newton MaterialGroupIDs, which is 
-	used to define interaction bewteen materials.
+    this class represents a pair of Newton MaterialGroupIDs, which is 
+    used to define interaction bewteen materials.
 */
 class _OgreNewtExport MaterialPair
 {
 public:
 
-	//! constructor
-	/*!
-		creates an object representing a pair of materials, and defining how they will interact.
-		\param world pointer to the OgreNewt::World
-		\param mat1 pointer to first materialID
-		\param mat2 pointer to second materialID
-	*/
-	MaterialPair( const World* world, const MaterialID* mat1, const MaterialID* mat2 );
+    //! constructor
+    /*!
+        creates an object representing a pair of materials, and defining how they will interact.
+        \param world pointer to the OgreNewt::World
+        \param mat1 pointer to first materialID
+        \param mat2 pointer to second materialID
+    */
+    MaterialPair( const World* world, const MaterialID* mat1, const MaterialID* mat2 );
 
-	//! destructor
-	~MaterialPair();
+    //! destructor
+    ~MaterialPair();
 
 
-	// set the default behavior for this material pair.
+    // set the default behavior for this material pair.
 
-	//! set default softness for the material pair.
-	void setDefaultSoftness( Ogre::Real softness ) const { NewtonMaterialSetDefaultSoftness( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)softness ); }
+    //! set default softness for the material pair.
+    void setDefaultSoftness( Ogre::Real softness ) const { NewtonMaterialSetDefaultSoftness( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)softness ); }
 
-	//! set default elasticity for the material pair.
-	void setDefaultElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetDefaultElasticity( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)elasticity ); }
+    //! set default elasticity for the material pair.
+    void setDefaultElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetDefaultElasticity( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)elasticity ); }
 
-	//! set default collision for the material pair.
-	void setDefaultCollidable( int state ) const { NewtonMaterialSetDefaultCollidable( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
+    //! set default collision for the material pair.
+    void setDefaultCollidable( int state ) const { NewtonMaterialSetDefaultCollidable( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
 
-	//! set the default thickness for this material pair
-	void setDefaultSurfaceThickness( float thickness ) const { NewtonMaterialSetSurfaceThickness( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), thickness ); }
+    //! set the default thickness for this material pair
+    void setDefaultSurfaceThickness( float thickness ) const { NewtonMaterialSetSurfaceThickness( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), thickness ); }
 
-	//! set default friction for the material pair.
-	void setDefaultFriction( Ogre::Real stat, Ogre::Real kinetic ) const { NewtonMaterialSetDefaultFriction( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)stat, (float)kinetic ); }
+    //! set default friction for the material pair.
+    void setDefaultFriction( Ogre::Real stat, Ogre::Real kinetic ) const { NewtonMaterialSetDefaultFriction( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)stat, (float)kinetic ); }
 
-	//! set continuos collision on/off for this material pair
-	/*!
-		continuous collision mode is an advanced system used to prevent &quot;tunelling&quot;, or objects passing through one an other when traveling at high velocities.  
-		there is a performance hit involved, so this sould only be used when it is deemed necessary.
-	*/
-	void setContinuousCollisionMode( int state ) const { NewtonMaterialSetContinuousCollisionMode( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
+    //! set continuos collision on/off for this material pair
+    /*!
+        continuous collision mode is an advanced system used to prevent &quot;tunelling&quot;, or objects passing through one an other when traveling at high velocities.  
+        there is a performance hit involved, so this sould only be used when it is deemed necessary.
+    */
+    void setContinuousCollisionMode( int state ) const { NewtonMaterialSetContinuousCollisionMode( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
 
 
-	//! assign a custom collision callback.
-	/*!
-		ContactCallbacks allow for custom interaction between bodies of specific materials.
-		\param callback pointer to a user-created ContactCallback object
-	*/
-	void setContactCallback( OgreNewt::ContactCallback* callback );
+    //! assign a custom collision callback.
+    /*!
+        ContactCallbacks allow for custom interaction between bodies of specific materials.
+        \param callback pointer to a user-created ContactCallback object
+    */
+    void setContactCallback( OgreNewt::ContactCallback* callback );
 
 
 protected:
-	const MaterialID*	id0;
-	const MaterialID*	id1;
-	const World*		m_world;
+    const MaterialID*   id0;
+    const MaterialID*   id1;
+    const World*        m_world;
     OgreNewt::ContactCallback *m_contactcallback;
 
 private:
-	//! internal function.
-	static int _CDECL collisionCallback_onAABBOverlap( const NewtonMaterial* material, const NewtonBody* body0, const NewtonBody* body1, int threadIndex );
-	//! internal function.
-	static void _CDECL collisionCallback_contactsProcess(const NewtonJoint* contact, float timeStep, int threadIndex );
+    //! internal function.
+    static int _CDECL collisionCallback_onAABBOverlap( const NewtonMaterial* material, const NewtonBody* body0, const NewtonBody* body1, int threadIndex );
+    //! internal function.
+    static void _CDECL collisionCallback_contactsProcess(const NewtonJoint* contact, float timeStep, int threadIndex );
 
 
 };
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 // _INCLUDE_OGRENEWT_MATERIALPAIR

Modified: dependencies/OgreNewt/inc/OgreNewt_PlayerController.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_PlayerController.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_PlayerController.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,11 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by melven
+        by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_PLAYERCONTROLLER
@@ -181,8 +181,8 @@
 };
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 
-#endif	// _INCLUDE_OGRENEWT_PLAYERCONTROLLER
+#endif  // _INCLUDE_OGRENEWT_PLAYERCONTROLLER
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 
@@ -15,9 +16,19 @@
 
 #ifdef __APPLE__
 #    include &lt;Carbon/Carbon.h&gt;
-#    include &lt;Ogre/Ogre.h&gt;
+#   include &lt;Ogre/OgreVector3.h&gt;
+#   include &lt;Ogre/OgreQuaternion.h&gt;
+#   include &lt;Ogre/OgreMovableObject.h&gt;
+#   include &lt;Ogre/OgreRenderable.h&gt;
+#   include &lt;Ogre/OgreNode.h&gt;
+#   include &lt;Ogre/OgreFrameListener.h&gt;
 #else
-#    include &lt;Ogre.h&gt;
+#include &lt;OgreVector3.h&gt;
+#include &lt;OgreQuaternion.h&gt;
+#include &lt;OgreMovableObject.h&gt;
+#include &lt;OgreRenderable.h&gt;
+#include &lt;OgreNode.h&gt;
+#include &lt;OgreFrameListener.h&gt;
 #endif
 
 #include &lt;Newton.h&gt;

Modified: dependencies/OgreNewt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_RayCast.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_RayCast.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -6,6 +6,7 @@
     OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
         by Walaber
+        some changes by melven
 
 */
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Tools.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_Tools.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_TOOLS
@@ -19,160 +20,160 @@
     class World;
     class Collision;
 
-	//! set of handy convertors.
-	namespace Converters
-	{
-		//! Take a Newton matrix and create a Quaternion + Position_vector
-		/*!
-			\param matrix input newton matrix (float[16])
-			\param quat returned quaternion
-			\param pos returned position vector
-		*/
-		_OgreNewtExport void MatrixToQuatPos( const float* matrix, Ogre::Quaternion&amp; quat, Ogre::Vector3 &amp;pos );
-	
+    //! set of handy convertors.
+    namespace Converters
+    {
+        //! Take a Newton matrix and create a Quaternion + Position_vector
+        /*!
+            \param matrix input newton matrix (float[16])
+            \param quat returned quaternion
+            \param pos returned position vector
+        */
+        _OgreNewtExport void MatrixToQuatPos( const float* matrix, Ogre::Quaternion&amp; quat, Ogre::Vector3 &amp;pos );
+    
 
-		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
-		/*!
-			\param quat input quaternion
-			\param pos input position vector
-			\param matrix returned matrix (float[16])
-		*/
-		_OgreNewtExport void QuatPosToMatrix( const Ogre::Quaternion&amp; quat, const Ogre::Vector3 &amp;pos, float* matrix );
+        //! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
+        /*!
+            \param quat input quaternion
+            \param pos input position vector
+            \param matrix returned matrix (float[16])
+        */
+        _OgreNewtExport void QuatPosToMatrix( const Ogre::Quaternion&amp; quat, const Ogre::Vector3 &amp;pos, float* matrix );
 
-		//! Take a Newton matrix and make it into an Ogre::Matrix4.
-		/*!
-			\param matrix_in input matrix from Newton (float[16])
-			\param matrix_out output Ogre::Matrix4 object.
-		*/
-		_OgreNewtExport void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4&amp; matrix_out );
+        //! Take a Newton matrix and make it into an Ogre::Matrix4.
+        /*!
+            \param matrix_in input matrix from Newton (float[16])
+            \param matrix_out output Ogre::Matrix4 object.
+        */
+        _OgreNewtExport void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4&amp; matrix_out );
 
-		//! Take an Ogre::Matrix4 and make it into a Newton-happy matrix.
-		/*!
-			\param matrix_in Ogre::Matrix4 to be converted.
-			\param matrix_out Newton-happy output matrix (float[16])
-		*/
-		_OgreNewtExport void Matrix4ToMatrix( const Ogre::Matrix4&amp; matrix_in, float* matrix_out );
-	}
+        //! Take an Ogre::Matrix4 and make it into a Newton-happy matrix.
+        /*!
+            \param matrix_in Ogre::Matrix4 to be converted.
+            \param matrix_out Newton-happy output matrix (float[16])
+        */
+        _OgreNewtExport void Matrix4ToMatrix( const Ogre::Matrix4&amp; matrix_in, float* matrix_out );
+    }
 
-	//! low-level collision commands.
-	namespace CollisionTools
-	{
+    //! low-level collision commands.
+    namespace CollisionTools
+    {
 
-		//! find the point on a collision primitive closest to a global point.
-		/*!
-			\param world pointer to world
-			\param globalpt point to check distance from.
-			\param col collision primitive pointer
-			\param colorient orientation of the collision primitive
-			\param colpos position of the collision primitive
-			\param retpos returned position on the collision primitive in global space
-			\param retnormal returned normal on the collision primitive in global space
-		*/
-		_OgreNewtExport int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3&amp; globalpt, 
-									const OgreNewt::Collision* col, const Ogre::Quaternion&amp; colorient, const Ogre::Vector3&amp; colpos, 
-									Ogre::Vector3&amp; retpt, Ogre::Vector3&amp; retnormal, int threadIndex );
-									
+        //! find the point on a collision primitive closest to a global point.
+        /*!
+            \param world pointer to world
+            \param globalpt point to check distance from.
+            \param col collision primitive pointer
+            \param colorient orientation of the collision primitive
+            \param colpos position of the collision primitive
+            \param retpos returned position on the collision primitive in global space
+            \param retnormal returned normal on the collision primitive in global space
+        */
+        _OgreNewtExport int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3&amp; globalpt, 
+                                    const OgreNewt::Collision* col, const Ogre::Quaternion&amp; colorient, const Ogre::Vector3&amp; colpos, 
+                                    Ogre::Vector3&amp; retpt, Ogre::Vector3&amp; retnormal, int threadIndex );
+                                    
 
 
-		//! find the nearest 2 points between 2 collision shapes.
-		/*!
-			\param world pointer to world
-			\param colA pointer to collision primitive A
-			\param colOrientA orientation of collision primitive A
-			\param colPosA position of collision primitive A
-			\param colB pointer to collision primitive B
-			\param colOrientB orientation of collision primitive B
-			\param colPosB position of collision primitive B
-			\param retPosA returned position on collision primitive A
-			\param retPosB returned position on collision primitive B
-			\param retNorm returned collision normal
-		*/
-		_OgreNewtExport int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-															const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-															Ogre::Vector3&amp; retPosA, Ogre::Vector3&amp; retPosB, Ogre::Vector3&amp; retNorm, int threadIndex );
+        //! find the nearest 2 points between 2 collision shapes.
+        /*!
+            \param world pointer to world
+            \param colA pointer to collision primitive A
+            \param colOrientA orientation of collision primitive A
+            \param colPosA position of collision primitive A
+            \param colB pointer to collision primitive B
+            \param colOrientB orientation of collision primitive B
+            \param colPosB position of collision primitive B
+            \param retPosA returned position on collision primitive A
+            \param retPosB returned position on collision primitive B
+            \param retNorm returned collision normal
+        */
+        _OgreNewtExport int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
+                                                            const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
+                                                            Ogre::Vector3&amp; retPosA, Ogre::Vector3&amp; retPosB, Ogre::Vector3&amp; retNorm, int threadIndex );
 
 
-		//! manual collision between collision primitives.
-		/*!
-			This function allows you to perform a manual collision check on 2 collision primitives.
-			the function returns the number of contacts found.
-			\param world pointer to world
-			\param maxSize max number of contact points you can receive
-			\param colA pointer to Collision primitive A
-			\param colOrientA orientation of collision primitive A
-			\param colPosA position of collision primitive A
-			\param colB pointer to collision primitive B
-			\param colOrientB orientation of collision orimitive B
-			\param colPosB position of collision primitive B
-			\param retContactPts returned array of contact points
-			\param retNormals returned normals for each contact
-			\param retPenetrations returned penetrations for each contact.
-		*/
-		_OgreNewtExport int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
-			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-			Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex );
+        //! manual collision between collision primitives.
+        /*!
+            This function allows you to perform a manual collision check on 2 collision primitives.
+            the function returns the number of contacts found.
+            \param world pointer to world
+            \param maxSize max number of contact points you can receive
+            \param colA pointer to Collision primitive A
+            \param colOrientA orientation of collision primitive A
+            \param colPosA position of collision primitive A
+            \param colB pointer to collision primitive B
+            \param colOrientB orientation of collision orimitive B
+            \param colPosB position of collision primitive B
+            \param retContactPts returned array of contact points
+            \param retNormals returned normals for each contact
+            \param retPenetrations returned penetrations for each contact.
+        */
+        _OgreNewtExport int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
+            const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
+            const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
+            Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex );
 
 
-		//! manual collision between moving primitives.
-		/*!
-			This is the most advanced collision function, that takes 2 primitives with velocities and omegas,
-			and calculates if the will contact with each other over a set timestep.
-			\param world pointer to world
-			\param maxSize max number of contact points you can receive
-			\param colA pointer to Collision primitive A
-			\param colOrientA orientation of collision primitive A
-			\param colPosA position of collision primitive A
-			\param colVelA velocity of collision primitive A
-			\param colOmegaA omega of collision primitive A
-			\param colB pointer to collision primitive B
-			\param colOrientB orientation of collision orimitive B
-			\param colPosB position of collision primitive B
-			\param colVelB velocity of collision primitive B
-			\param colOmegaB omega of collision primitive B
-			\param retTimeOfImpact time of collision
-			\param retContactPts returned array of contact points
-			\param retNormals returned normals for each contact
-			\param retPenetrations returned penetrations for each contact.
-		*/
-		_OgreNewtExport int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
-			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA, const Ogre::Vector3&amp; colVelA, const Ogre::Vector3&amp; colOmegaA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB, const Ogre::Vector3&amp; colVelB, const Ogre::Vector3&amp; colOmegaB,
-			Ogre::Real&amp; retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex );
+        //! manual collision between moving primitives.
+        /*!
+            This is the most advanced collision function, that takes 2 primitives with velocities and omegas,
+            and calculates if the will contact with each other over a set timestep.
+            \param world pointer to world
+            \param maxSize max number of contact points you can receive
+            \param colA pointer to Collision primitive A
+            \param colOrientA orientation of collision primitive A
+            \param colPosA position of collision primitive A
+            \param colVelA velocity of collision primitive A
+            \param colOmegaA omega of collision primitive A
+            \param colB pointer to collision primitive B
+            \param colOrientB orientation of collision orimitive B
+            \param colPosB position of collision primitive B
+            \param colVelB velocity of collision primitive B
+            \param colOmegaB omega of collision primitive B
+            \param retTimeOfImpact time of collision
+            \param retContactPts returned array of contact points
+            \param retNormals returned normals for each contact
+            \param retPenetrations returned penetrations for each contact.
+        */
+        _OgreNewtExport int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
+            const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA, const Ogre::Vector3&amp; colVelA, const Ogre::Vector3&amp; colOmegaA,
+            const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB, const Ogre::Vector3&amp; colVelB, const Ogre::Vector3&amp; colOmegaB,
+            Ogre::Real&amp; retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex );
 
 
-		//! local raycast on a collision object.
-		/*!
-			This function performs a local raycast on a single collision primitive shape.  the function returns the distance to the
-			point of intersection as a scalar between [0,1].
-			\param col pointer to collision shape on which to cast the ray
-			\param startPt starting point of the ray, in local space of the collision shape
-			\param endPt end point of the ray, in local space of the collision shape
-			\param normal returned normal where the ray hit the collision.
-			\param colID returned ID of the collision primitive hit.
-		*/
-		_OgreNewtExport Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3&amp; startPt, const Ogre::Vector3&amp; endPt, 
-														Ogre::Vector3&amp; retNorm, int&amp; retColID );
-				
+        //! local raycast on a collision object.
+        /*!
+            This function performs a local raycast on a single collision primitive shape.  the function returns the distance to the
+            point of intersection as a scalar between [0,1].
+            \param col pointer to collision shape on which to cast the ray
+            \param startPt starting point of the ray, in local space of the collision shape
+            \param endPt end point of the ray, in local space of the collision shape
+            \param normal returned normal where the ray hit the collision.
+            \param colID returned ID of the collision primitive hit.
+        */
+        _OgreNewtExport Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3&amp; startPt, const Ogre::Vector3&amp; endPt, 
+                                                        Ogre::Vector3&amp; retNorm, int&amp; retColID );
+                
 
-		//! calculate the AABB of a collision primitive in an arbitrary orientation
-		/*!
-			Calculates the global AABB of a collision primitive in world space, given an orientation and position.
-			\param col collision shape to calculate.
-			\param orient world orientation of the collision.
-			\param pos world position of the collision.
-		*/
-		_OgreNewtExport Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos );
+        //! calculate the AABB of a collision primitive in an arbitrary orientation
+        /*!
+            Calculates the global AABB of a collision primitive in world space, given an orientation and position.
+            \param col collision shape to calculate.
+            \param orient world orientation of the collision.
+            \param pos world position of the collision.
+        */
+        _OgreNewtExport Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos );
 
-	}	// end namespace &quot;ColliionTools&quot;
+    }   // end namespace &quot;ColliionTools&quot;
 
-	namespace Springs
-	{
-	
-		_OgreNewtExport Ogre::Real calculateSpringDamperAcceleration( Ogre::Real deltaTime, Ogre::Real spingK, 
-									Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity );
-	
-	}	// end namespace SPRINGS
+    namespace Springs
+    {
+    
+        _OgreNewtExport Ogre::Real calculateSpringDamperAcceleration( Ogre::Real deltaTime, Ogre::Real spingK, 
+                                    Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity );
+    
+    }   // end namespace SPRINGS
 
         namespace OgreAddons
         {
@@ -284,7 +285,7 @@
 
         }
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 #endif
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Vehicle.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Vehicle.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_Vehicle.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 
 */
 #ifndef _INCLUDE_OGRENEWT_VEHICLE
@@ -22,199 +23,199 @@
 #ifdef INCLUDE_VEHICLE
 //! Represents a wheeled vehicle
 /*!
-	this class represents a basic vehicle, meant to be inherited by the user, with functionality added.
+    this class represents a basic vehicle, meant to be inherited by the user, with functionality added.
 */
-	class _OgreNewtExport Vehicle
-	{
-	public:
+    class _OgreNewtExport Vehicle
+    {
+    public:
 
-		//! basic vehicle tire.
-		/*!
-			secondary class: Tire.  this represents a basic tire.  you add tires by simply creating new tire objects, they are attached to the vehicle object you pass to the constructor.
-		*/
-		class _OgreNewtExport Tire
-		{
-		public:
-			//! overloaded constructor.
-			/*
-				this is the all-important constructor.
-				\param vehicle the parent vehicle to which you want to add this tire.
-				\param localorient local orientation of the tire (in the space of the chassis rigid body)
-				\param localpos local orientation of the tire (in the space of the chassis rigid body)
-				\param pin direction of the pin (axle) in the space of the tire
-				\param mass mass of the tire
-				\param width width of the tire
-				\param radius radis of the tire
-				\param susShock spring damper coefficient
-				\param susSpring spring strength
-				\param susLength spring length
-				\param colID collision ID used to determine collision in material callbacks.
-			*/
-			Tire( OgreNewt::Vehicle* vehicle, Ogre::Quaternion localorient, Ogre::Vector3 localpos, Ogre::Vector3 pin,
-				Ogre::Real mass, Ogre::Real width, Ogre::Real radius, Ogre::Real susShock, Ogre::Real susSpring, Ogre::Real susLength, int colID = 0);
+        //! basic vehicle tire.
+        /*!
+            secondary class: Tire.  this represents a basic tire.  you add tires by simply creating new tire objects, they are attached to the vehicle object you pass to the constructor.
+        */
+        class _OgreNewtExport Tire
+        {
+        public:
+            //! overloaded constructor.
+            /*
+                this is the all-important constructor.
+                \param vehicle the parent vehicle to which you want to add this tire.
+                \param localorient local orientation of the tire (in the space of the chassis rigid body)
+                \param localpos local orientation of the tire (in the space of the chassis rigid body)
+                \param pin direction of the pin (axle) in the space of the tire
+                \param mass mass of the tire
+                \param width width of the tire
+                \param radius radis of the tire
+                \param susShock spring damper coefficient
+                \param susSpring spring strength
+                \param susLength spring length
+                \param colID collision ID used to determine collision in material callbacks.
+            */
+            Tire( OgreNewt::Vehicle* vehicle, Ogre::Quaternion localorient, Ogre::Vector3 localpos, Ogre::Vector3 pin,
+                Ogre::Real mass, Ogre::Real width, Ogre::Real radius, Ogre::Real susShock, Ogre::Real susSpring, Ogre::Real susLength, int colID = 0);
 
-			//! destructor.
-			virtual ~Tire();
+            //! destructor.
+            virtual ~Tire();
 
-			//! attach a scenenode to the tire!
-			void attachToNode( Ogre::SceneNode* node ) { m_node = node; }
+            //! attach a scenenode to the tire!
+            void attachToNode( Ogre::SceneNode* node ) { m_node = node; }
 
-			//! update the position of the tire.  this must be called to update the attached scene node to the position of the tire!
-			void updateNode();
+            //! update the position of the tire.  this must be called to update the attached scene node to the position of the tire!
+            void updateNode();
 
-			//! get the Newton ID for this tire.
-			const void* getNewtonID() const { return m_tireid; }
+            //! get the Newton ID for this tire.
+            const void* getNewtonID() const { return m_tireid; }
 
-			//! get the parent vehicle.
-			OgreNewt::Vehicle* getVehicle() const { return m_vehicle; }
+            //! get the parent vehicle.
+            OgreNewt::Vehicle* getVehicle() const { return m_vehicle; }
 
-			//! get Ogre::SceneNode.
-			Ogre::SceneNode* getOgreNode() const { return m_node; }
+            //! get Ogre::SceneNode.
+            Ogre::SceneNode* getOgreNode() const { return m_node; }
 
-			//////////////////////////////////////////////////////////////////////
-			// Newton functions
-			
-			//! is the tire airborne?
-			int isAirBorne() const { return NewtonVehicleTireIsAirBorne( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //////////////////////////////////////////////////////////////////////
+            // Newton functions
+            
+            //! is the tire airborne?
+            int isAirBorne() const { return NewtonVehicleTireIsAirBorne( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! has the tire lost side grip?
-			int lostSideGrip() const { return NewtonVehicleTireLostSideGrip( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //! has the tire lost side grip?
+            int lostSideGrip() const { return NewtonVehicleTireLostSideGrip( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! has the tire lost traction?
-			int lostTraction() const { return NewtonVehicleTireLostTraction( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //! has the tire lost traction?
+            int lostTraction() const { return NewtonVehicleTireLostTraction( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! get the rotational velocity of the tire
-			Ogre::Real getOmega() const { return (Ogre::Real)NewtonVehicleGetTireOmega( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //! get the rotational velocity of the tire
+            Ogre::Real getOmega() const { return (Ogre::Real)NewtonVehicleGetTireOmega( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! get the load on the tire (along the suspension normal )
-			Ogre::Real getNormalLoad() const { return (Ogre::Real)NewtonVehicleGetTireNormalLoad( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //! get the load on the tire (along the suspension normal )
+            Ogre::Real getNormalLoad() const { return (Ogre::Real)NewtonVehicleGetTireNormalLoad( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! get the current steering angle for this tire
-			Ogre::Radian getSteeringAngle() const { return Ogre::Radian( NewtonVehicleGetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid ) ); }
+            //! get the current steering angle for this tire
+            Ogre::Radian getSteeringAngle() const { return Ogre::Radian( NewtonVehicleGetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid ) ); }
 
-			//! get the lateral speed of the tire (sideways)
-			Ogre::Real getLateralSpeed() const { return NewtonVehicleGetTireLateralSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //! get the lateral speed of the tire (sideways)
+            Ogre::Real getLateralSpeed() const { return NewtonVehicleGetTireLateralSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! get the longitudinal speed of the tire (forward/backward)
-			Ogre::Real getLongitudinalSpeed() const { return NewtonVehicleGetTireLongitudinalSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //! get the longitudinal speed of the tire (forward/backward)
+            Ogre::Real getLongitudinalSpeed() const { return NewtonVehicleGetTireLongitudinalSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! get the location and orientation of the tire (in global space).
-			void getPositionOrientation( Ogre::Quaternion&amp; orient, Ogre::Vector3&amp; pos );
+            //! get the location and orientation of the tire (in global space).
+            void getPositionOrientation( Ogre::Quaternion&amp; orient, Ogre::Vector3&amp; pos );
 
-			//! set the torque for this tire.  this must be called in the tire callback!
-			void setTorque( Ogre::Real torque ) const { NewtonVehicleSetTireTorque( m_vehicle-&gt;getNewtonVehicle(), m_tireid, torque ); }
+            //! set the torque for this tire.  this must be called in the tire callback!
+            void setTorque( Ogre::Real torque ) const { NewtonVehicleSetTireTorque( m_vehicle-&gt;getNewtonVehicle(), m_tireid, torque ); }
 
-			//! set the steering angle for the tire.  this must be called in the tire callback.
-			void setSteeringAngle( Ogre::Radian angle ) const { NewtonVehicleSetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid, angle.valueRadians() ); }
+            //! set the steering angle for the tire.  this must be called in the tire callback.
+            void setSteeringAngle( Ogre::Radian angle ) const { NewtonVehicleSetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid, angle.valueRadians() ); }
 
-			//! calculate the max brake acceleration to stop the tires.
-			Ogre::Real calculateMaxBrakeAcceleration() const { return (Ogre::Real)NewtonVehicleTireCalculateMaxBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+            //! calculate the max brake acceleration to stop the tires.
+            Ogre::Real calculateMaxBrakeAcceleration() const { return (Ogre::Real)NewtonVehicleTireCalculateMaxBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
 
-			//! set the brake acceleration
-			void setBrakeAcceleration( Ogre::Real accel, Ogre::Real limit ) const { NewtonVehicleTireSetBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)accel, (float)limit ); }
+            //! set the brake acceleration
+            void setBrakeAcceleration( Ogre::Real accel, Ogre::Real limit ) const { NewtonVehicleTireSetBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)accel, (float)limit ); }
 
-			//! max side slip speed
-			void setMaxSideSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxSideSleepSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
+            //! max side slip speed
+            void setMaxSideSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxSideSleepSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
 
-			//! set side slip coefficient
-			void setSideSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireSideSleepCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
+            //! set side slip coefficient
+            void setSideSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireSideSleepCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
 
-			//! max longitudinal slip speed
-			void setMaxLongitudinalSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxLongitudinalSlideSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
+            //! max longitudinal slip speed
+            void setMaxLongitudinalSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxLongitudinalSlideSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
 
-			//! set longitudinal slip coefficient
-			void setLongitudinalSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireLongitudinalSlideCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
+            //! set longitudinal slip coefficient
+            void setLongitudinalSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireLongitudinalSlideCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
 
 
 
 
-		protected:
-			OgreNewt::Vehicle* m_vehicle;
-			void* m_tireid;
+        protected:
+            OgreNewt::Vehicle* m_vehicle;
+            void* m_tireid;
 
-			Ogre::SceneNode* m_node;
+            Ogre::SceneNode* m_node;
 
-		};
+        };
 
 
-		//! constructor
-		Vehicle() { m_vehicle = NULL; }
+        //! constructor
+        Vehicle() { m_vehicle = NULL; }
 
-		//! destructor
-		virtual ~Vehicle();
+        //! destructor
+        virtual ~Vehicle();
 
-		//! initialize the vehicle
-		/*!
-			this function should be called to initialize the vehicle, assigning it's main chassis rigid body.  the function
-			also calls the virtual function &quot;setup&quot; which the user should implement to add tires to the vehicle.
-			\param chassis pointer to the OgreNewt::Body to use as the chassis.
-			\param updir unit vector signifying which direction is &quot;up&quot; in your world.  used for suspension.
-		*/
-		void init( OgreNewt::Body* chassis, const Ogre::Vector3&amp; updir );
+        //! initialize the vehicle
+        /*!
+            this function should be called to initialize the vehicle, assigning it's main chassis rigid body.  the function
+            also calls the virtual function &quot;setup&quot; which the user should implement to add tires to the vehicle.
+            \param chassis pointer to the OgreNewt::Body to use as the chassis.
+            \param updir unit vector signifying which direction is &quot;up&quot; in your world.  used for suspension.
+        */
+        void init( OgreNewt::Body* chassis, const Ogre::Vector3&amp; updir );
 
-		//! destroy the vehicle, including chassis Body.
-		void destroy();	
+        //! destroy the vehicle, including chassis Body.
+        void destroy(); 
 
-		//! setup the tires.
-		/*!
-			this is a virtual function that must be implemented by the user.  you should add and balance all tires in this function.
-		*/
-		virtual void setup() = 0;
+        //! setup the tires.
+        /*!
+            this is a virtual function that must be implemented by the user.  you should add and balance all tires in this function.
+        */
+        virtual void setup() = 0;
 
-		//! user callback for controlling the vehicle
-		/*!
-			callback called each frame.  inside this callback you can add torque and steering to the tires to control the vehicle.
-		*/
-		virtual void userCallback() {}
+        //! user callback for controlling the vehicle
+        /*!
+            callback called each frame.  inside this callback you can add torque and steering to the tires to control the vehicle.
+        */
+        virtual void userCallback() {}
 
-		//! get the chassis body.
-		OgreNewt::Body* getChassisBody() const { return m_chassis; }
+        //! get the chassis body.
+        OgreNewt::Body* getChassisBody() const { return m_chassis; }
 
-		//! get the NewtonJoint for the vehicle.
-		NewtonJoint* getNewtonVehicle()  const { return m_vehicle; }
+        //! get the NewtonJoint for the vehicle.
+        NewtonJoint* getNewtonVehicle()  const { return m_vehicle; }
 
-		//////////////////////////////////////////////////////////////
-		// Newton Vehicle functions.
+        //////////////////////////////////////////////////////////////
+        // Newton Vehicle functions.
 
-		//! reset the vehicle (stop all tires)
-		void reset() const { NewtonVehicleReset( m_vehicle ); }
+        //! reset the vehicle (stop all tires)
+        void reset() const { NewtonVehicleReset( m_vehicle ); }
 
-		//! get a pointer to the first tire
-		/*!
-			This can be used with the getNextTire function to iterate through all tires in the vehicle.  see examples for more info.
-			should only be called from inside the userCallback() function.
-		*/
-		const OgreNewt::Vehicle::Tire* getFirstTire() const;
+        //! get a pointer to the first tire
+        /*!
+            This can be used with the getNextTire function to iterate through all tires in the vehicle.  see examples for more info.
+            should only be called from inside the userCallback() function.
+        */
+        const OgreNewt::Vehicle::Tire* getFirstTire() const;
 
-		//! get a pointer to the next tire in the vehicle.
-		/*!
-			This can be used with the getFirstTire function to iterate through all tires in the vehicle.  see examples for more info.
-			should only be called from inside the userCallback() function.
-		*/
-		const OgreNewt::Vehicle::Tire* getNextTire( OgreNewt::Vehicle::Tire* current_tire ) const;
+        //! get a pointer to the next tire in the vehicle.
+        /*!
+            This can be used with the getFirstTire function to iterate through all tires in the vehicle.  see examples for more info.
+            should only be called from inside the userCallback() function.
+        */
+        const OgreNewt::Vehicle::Tire* getNextTire( OgreNewt::Vehicle::Tire* current_tire ) const;
 
 
-	protected:
+    protected:
 
-		OgreNewt::Body* m_chassis;
+        OgreNewt::Body* m_chassis;
 
-	private:
-		//! callback for newton... it calls the userCallback() function for you.
-		static void _CDECL newtonCallback( const NewtonJoint* me );
+    private:
+        //! callback for newton... it calls the userCallback() function for you.
+        static void _CDECL newtonCallback( const NewtonJoint* me );
 
-		static void _CDECL newtonDestructor( const NewtonJoint* me );
+        static void _CDECL newtonDestructor( const NewtonJoint* me );
 
-		NewtonJoint* m_vehicle;
-		
+        NewtonJoint* m_vehicle;
+        
 
-	};
+    };
 
 
 #endif
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 
 
-#endif	// _INCLUDE_OGRENEWT_VEHICLE
+#endif  // _INCLUDE_OGRENEWT_VEHICLE
 

Modified: dependencies/OgreNewt/inc/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_World.h	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/inc/OgreNewt_World.h	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,11 +1,12 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
+        some changes by melven
 */
 #ifndef _INCLUDE_OGRENEWT_WORLD
 #define _INCLUDE_OGRENEWT_WORLD
@@ -19,7 +20,7 @@
 
 //! main namespace.
 /*!
-	This is the main namespace for the OgreNewt library.  all classes are included in this namespace.
+    This is the main namespace for the OgreNewt library.  all classes are included in this namespace.
 */
 namespace OgreNewt
 {
@@ -31,168 +32,168 @@
 
 //! represents a physics world.
 /*!
-	this class represents a NewtonWorld, which is the basic space in which physics elements can exist.  It can have various Rigid Bodies, connected by joints, and other constraints.
+    this class represents a NewtonWorld, which is the basic space in which physics elements can exist.  It can have various Rigid Bodies, connected by joints, and other constraints.
 */
 class _OgreNewtExport World
 {
 
 public:
 
-	//! physics solver mode.
-	/*!
-		you can adjust the accuracy of the solver (and therefore the speed of the solver) using these, or a simple int &gt;= 2.  a value &gt;= 2 represents the number of passes you want the engine to take when attempting to reconcile joints.
-	*/
-	enum SolverModelMode 
-	{ 
-		SM_EXACT = 0,	/*!&lt; the most accurate simulation. */
-		SM_ADAPTIVE = 1	/*!&lt; still accurate, but faster. */
-	};
+    //! physics solver mode.
+    /*!
+        you can adjust the accuracy of the solver (and therefore the speed of the solver) using these, or a simple int &gt;= 2.  a value &gt;= 2 represents the number of passes you want the engine to take when attempting to reconcile joints.
+    */
+    enum SolverModelMode 
+    { 
+        SM_EXACT = 0,   /*!&lt; the most accurate simulation. */
+        SM_ADAPTIVE = 1 /*!&lt; still accurate, but faster. */
+    };
 
-	//! friction solver mode.
-	/*!
-		like the physics solver mode, these options allow you to reduce the accuracy of the friction model in exchange for speed.
-	*/
-	enum FrictionModelMode 
-	{ 
-		FM_EXACT = 0,	/*!&lt; exact friction model (default). */
-		FM_ADAPTIVE = 1	/*!&lt; adaptive friction mode. (faster but less accurate) */
-	};
+    //! friction solver mode.
+    /*!
+        like the physics solver mode, these options allow you to reduce the accuracy of the friction model in exchange for speed.
+    */
+    enum FrictionModelMode 
+    { 
+        FM_EXACT = 0,   /*!&lt; exact friction model (default). */
+        FM_ADAPTIVE = 1 /*!&lt; adaptive friction mode. (faster but less accurate) */
+    };
 
-	//! leave world callback.
-	/*!
-		this function is called when a body leaves the OgreNewt::World.  you can use this to destroy bodies that have left the scene,
-		or re-position them, reflect them, do whatever you want.
+    //! leave world callback.
+    /*!
+        this function is called when a body leaves the OgreNewt::World.  you can use this to destroy bodies that have left the scene,
+        or re-position them, reflect them, do whatever you want.
 
-		callback binding to member classes is exactly the same as the various callbacks for the Body class.
-	*/
-	typedef boost::function&lt;void(OgreNewt::Body*, int threadIndex)&gt; LeaveWorldCallback;
+        callback binding to member classes is exactly the same as the various callbacks for the Body class.
+    */
+    typedef boost::function&lt;void(OgreNewt::Body*, int threadIndex)&gt; LeaveWorldCallback;
 
 public:
-	//! Standard Constructor, creates the world.
-	World();
+    //! Standard Constructor, creates the world.
+    World();
 
-	//! Standard Destructor, destroys the world.
-	~World();		
+    //! Standard Destructor, destroys the world.
+    ~World();       
 
-	//! update the world by the specified time_step.
-	/*!
-		this function is clamped between values representing fps [60,600].  if you pass a smaller value, it is internally clamped to 60fps.  likewise a value higher than 600fps is treated as 600fs.
+    //! update the world by the specified time_step.
+    /*!
+        this function is clamped between values representing fps [60,600].  if you pass a smaller value, it is internally clamped to 60fps.  likewise a value higher than 600fps is treated as 600fs.
 
-		\param t_step Real value representing the time elapsed in seconds.
-	*/
-	void update( Ogre::Real t_step );	
+        \param t_step Real value representing the time elapsed in seconds.
+    */
+    void update( Ogre::Real t_step );   
 
-	//! invalidate internal cache
-	/*!
-		this function completely resets the cache that Newton uses to improve simulation performance.  This is useful for situations where you have reset the simulation to a previous point in time, or reset all bodies,
-		and do not want the state of the world from the previous frame affecting the next frame.
-	*/
-	void invalidateCache() { NewtonInvalidateCache( m_world ); }
+    //! invalidate internal cache
+    /*!
+        this function completely resets the cache that Newton uses to improve simulation performance.  This is useful for situations where you have reset the simulation to a previous point in time, or reset all bodies,
+        and do not want the state of the world from the previous frame affecting the next frame.
+    */
+    void invalidateCache() { NewtonInvalidateCache( m_world ); }
 
-	//! retrieves a pointer to the NewtonWorld
-	/*!
-		in most cases you shouldn't need this... but in case you want to implement something not yet in the library, you can use this to get a pointer to the NewtonWorld object.
-		\return pointer to NewtonWorld
-	*/
-	const NewtonWorld* getNewtonWorld() const { return m_world; }
+    //! retrieves a pointer to the NewtonWorld
+    /*!
+        in most cases you shouldn't need this... but in case you want to implement something not yet in the library, you can use this to get a pointer to the NewtonWorld object.
+        \return pointer to NewtonWorld
+    */
+    const NewtonWorld* getNewtonWorld() const { return m_world; }
 
-	//! get the default materialID object.
-	/*!
-		when you create a world, a default material is created, which is by default applied to all new rigid bodies.  you might need this pointer when assigning material callbacks, etc.
-		\return pointer to a MaterialID* representing the default material.
-	*/
-	const MaterialID* getDefaultMaterialID() const { return m_defaultMatID; }	// get pointer to default material ID object.
+    //! get the default materialID object.
+    /*!
+        when you create a world, a default material is created, which is by default applied to all new rigid bodies.  you might need this pointer when assigning material callbacks, etc.
+        \return pointer to a MaterialID* representing the default material.
+    */
+    const MaterialID* getDefaultMaterialID() const { return m_defaultMatID; }   // get pointer to default material ID object.
 
-	//! remove all bodies from the world.
-	/*!
-		destroys all Rigid Bodies and Joints in the world. the bodies are properly deleted, so don't try and access any pointers you have lying around!
-	*/
-	void destroyAllBodies() { NewtonDestroyAllBodies( m_world ); }
+    //! remove all bodies from the world.
+    /*!
+        destroys all Rigid Bodies and Joints in the world. the bodies are properly deleted, so don't try and access any pointers you have lying around!
+    */
+    void destroyAllBodies() { NewtonDestroyAllBodies( m_world ); }
 
-	//! set the physics solver model
-	/*!
-		setting the solver model allows sacrificing accuracy and realism for speed, good for games, etc.  for a more detailed description of how to use this function, see the Newton documentation.
-		\param model int representing the physics model.  you can also pass the enum values I've included.
-		\sa SolverModelMode
-	*/
-	void setSolverModel( int model ) { NewtonSetSolverModel( m_world, model ); }
+    //! set the physics solver model
+    /*!
+        setting the solver model allows sacrificing accuracy and realism for speed, good for games, etc.  for a more detailed description of how to use this function, see the Newton documentation.
+        \param model int representing the physics model.  you can also pass the enum values I've included.
+        \sa SolverModelMode
+    */
+    void setSolverModel( int model ) { NewtonSetSolverModel( m_world, model ); }
 
-	//! set the physics friction model
-	/*!
-		setting the friction model allows sacrificing accuracy and realism for speed, good for games, etc. for a more detailed description of how to use this function, see the Newton documentation.
-		\param model int representing friction model.  you can also pass the enum values I've included.
-		\sa FrictionModelMode
-	*/
-	void setFrictionModel( int model) { NewtonSetFrictionModel( m_world, model ); }
+    //! set the physics friction model
+    /*!
+        setting the friction model allows sacrificing accuracy and realism for speed, good for games, etc. for a more detailed description of how to use this function, see the Newton documentation.
+        \param model int representing friction model.  you can also pass the enum values I've included.
+        \sa FrictionModelMode
+    */
+    void setFrictionModel( int model) { NewtonSetFrictionModel( m_world, model ); }
 
-	//! specify a specific architecture to use for physics calculations.
-	/*!
-		Setting to a specific architecture can allow for deterministic physics calculations on systems with different cpus,
-		which is particularly useful for multiplayer systems where deterministic physics are absolutely vital.
-	*/
-	void setPlatformArchitecture( int mode ) { NewtonSetPlatformArchitecture( m_world, mode ); }
+    //! specify a specific architecture to use for physics calculations.
+    /*!
+        Setting to a specific architecture can allow for deterministic physics calculations on systems with different cpus,
+        which is particularly useful for multiplayer systems where deterministic physics are absolutely vital.
+    */
+    void setPlatformArchitecture( int mode ) { NewtonSetPlatformArchitecture( m_world, mode ); }
 
-	//! get the number of bodies in the simulation.
-	/*!
-		returns the number of bodies in the simulation.
-	*/
-	int getBodyCount() const { return NewtonWorldGetBodyCount( m_world ); }
+    //! get the number of bodies in the simulation.
+    /*!
+        returns the number of bodies in the simulation.
+    */
+    int getBodyCount() const { return NewtonWorldGetBodyCount( m_world ); }
 
     //! get the number of constaints in the simulation
     int getConstraintCount() const {return NewtonWorldGetConstraintCount( m_world ); }
 
-	//! multithread settings
-	void setMultithreadSolverOnSingleIsland( int mode ) { NewtonSetMultiThreadSolverOnSingleIsland( m_world, mode ); }
+    //! multithread settings
+    void setMultithreadSolverOnSingleIsland( int mode ) { NewtonSetMultiThreadSolverOnSingleIsland( m_world, mode ); }
 
-	//! set the number of threads for the physics simulation to use.
-	void setThreadCount(int threads) { NewtonSetThreadsCount( m_world, threads ); }
+    //! set the number of threads for the physics simulation to use.
+    void setThreadCount(int threads) { NewtonSetThreadsCount( m_world, threads ); }
 
-	//! get the number of threads the simulation is using.
-	int getThreadCount() const { return NewtonGetThreadsCount( m_world ); }
+    //! get the number of threads the simulation is using.
+    int getThreadCount() const { return NewtonGetThreadsCount( m_world ); }
 
-	//! notify an entrance to a critical section of code.
-	void criticalSectionLock() { NewtonWorldCriticalSectionLock( m_world ); }
+    //! notify an entrance to a critical section of code.
+    void criticalSectionLock() { NewtonWorldCriticalSectionLock( m_world ); }
 
-	//! notify the exit of a critical section of code.
-	void cricicalSectionUnlock() { NewtonWorldCriticalSectionUnlock( m_world ); }
+    //! notify the exit of a critical section of code.
+    void cricicalSectionUnlock() { NewtonWorldCriticalSectionUnlock( m_world ); }
 
-	//! set minimum framerate
-	void setMinimumFrameRate( Ogre::Real frame ) { NewtonSetMinimumFrameRate( m_world, frame ); }
+    //! set minimum framerate
+    void setMinimumFrameRate( Ogre::Real frame ) { NewtonSetMinimumFrameRate( m_world, frame ); }
 
-	//! set the newton world size
-	/*!
-		setting the world size is very important for a efficient simulation.  although basic collisions will work outside the world limits, other things like raycasting will not work outside the world limits.
-		\param min minimum point of the world.
-		\param max maximum point of the world.
-	*/
-	void setWorldSize( const Ogre::Vector3&amp; min, const Ogre::Vector3&amp; max );
+    //! set the newton world size
+    /*!
+        setting the world size is very important for a efficient simulation.  although basic collisions will work outside the world limits, other things like raycasting will not work outside the world limits.
+        \param min minimum point of the world.
+        \param max maximum point of the world.
+    */
+    void setWorldSize( const Ogre::Vector3&amp; min, const Ogre::Vector3&amp; max );
 
-	/*!
-		\param box bos describing the size of the world.
-	*/
-	void setWorldSize( const Ogre::AxisAlignedBox&amp; box );
+    /*!
+        \param box bos describing the size of the world.
+    */
+    void setWorldSize( const Ogre::AxisAlignedBox&amp; box );
 
-	/*!
-		get the world limits.
-	*/
-	Ogre::AxisAlignedBox getWorldSize() { return m_limits; }
+    /*!
+        get the world limits.
+    */
+    Ogre::AxisAlignedBox getWorldSize() { return m_limits; }
 
-	//! get the Newton SDK version.
-	int getVersion() const { return NewtonWorldGetVersion( m_world ); }
+    //! get the Newton SDK version.
+    int getVersion() const { return NewtonWorldGetVersion( m_world ); }
 
-	//! set the leave world callback
-	/*!
-		sets the callback to be used when a Body leaves the World limits.
-	*/
-	void setLeaveWorldCallback( LeaveWorldCallback callback );
-	template&lt;class c&gt; void setLeaveWorldCallback( boost::function&lt;void(c*, Body*, int)&gt; callback, c *instancedClassPointer )
-	{
-		setLeaveWorldCallback( boost::bind(callback, instancedClassPointer, _1, _2) );
-	}
+    //! set the leave world callback
+    /*!
+        sets the callback to be used when a Body leaves the World limits.
+    */
+    void setLeaveWorldCallback( LeaveWorldCallback callback );
+    template&lt;class c&gt; void setLeaveWorldCallback( boost::function&lt;void(c*, Body*, int)&gt; callback, c *instancedClassPointer )
+    {
+        setLeaveWorldCallback( boost::bind(callback, instancedClassPointer, _1, _2) );
+    }
 
 
-	//! updates only the collision of the world and call the callback functions if necessary, can be used for an collision only system
-	void CollisionUpdate() { NewtonCollisionUpdate( m_world ); }
+    //! updates only the collision of the world and call the callback functions if necessary, can be used for an collision only system
+    void collisionUpdate() { NewtonCollisionUpdate( m_world ); }
     //! to iterate through all bodies call this function and then use body-&gt;getNext()
     Body* getFirstBody() const;
 
@@ -211,11 +212,11 @@
     Debugger&amp; getDebugger() const {return m_debugger;}
 
 protected:
-	
-	NewtonWorld* m_world;
-	MaterialID* m_defaultMatID;
+    
+    NewtonWorld* m_world;
+    MaterialID* m_defaultMatID;
 
-	LeaveWorldCallback m_leaveCallback;
+    LeaveWorldCallback m_leaveCallback;
     
     BodyInAABBIterator m_bodyInAABBIterator;
 
@@ -223,14 +224,14 @@
 
 private:
 
-	static void _CDECL newtonLeaveWorld( const NewtonBody* body, int threadIndex );
+    static void _CDECL newtonLeaveWorld( const NewtonBody* body, int threadIndex );
 
-	Ogre::AxisAlignedBox m_limits;
+    Ogre::AxisAlignedBox m_limits;
 };
 
 }
 
-	
+    
 #endif
 // _INCLUDE_OGRENEWT_WORLD
 

Modified: dependencies/OgreNewt/src/OgreNewt_BasicFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_BasicFrameListener.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_BasicFrameListener.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -2,33 +2,41 @@
 #include &quot;OgreNewt_Debugger.h&quot;
 #include &quot;OgreNewt_World.h&quot;
 
+#ifdef __APPLE_
+#   include &lt;Ogre/OgreFrameListener.h&gt;
+#   include &lt;Ogre/OgreRenderWindow.h&gt;
+#else
+#   include &lt;OgreFrameListener.h&gt;
+#   include &lt;OgreRenderWindow.h&gt;
+#endif
+
 namespace OgreNewt
 {
 
 BasicFrameListener::BasicFrameListener( Ogre::RenderWindow* win, Ogre::SceneManager* mgr, OgreNewt::World* W, int update_framerate) :
         FrameListener()
 {
-	m_World = W;
-	desired_framerate = update_framerate;
+    m_World = W;
+    desired_framerate = update_framerate;
 
-	m_update = (Ogre::Real)(1.0f / (Ogre::Real)desired_framerate);
-	m_elapsed = 0.0f;
+    m_update = (Ogre::Real)(1.0f / (Ogre::Real)desired_framerate);
+    m_elapsed = 0.0f;
 
-	// add the standard debug viewer.
-	W-&gt;getDebugger().init( mgr );
+    // add the standard debug viewer.
+    W-&gt;getDebugger().init( mgr );
 
-	OIS::ParamList pl;
-	size_t windowHnd = 0;
-	std::ostringstream windowHndStr;
+    OIS::ParamList pl;
+    size_t windowHnd = 0;
+    std::ostringstream windowHndStr;
 
-	win-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
-	windowHndStr &lt;&lt; windowHnd;
-	pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
+    win-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
+    windowHndStr &lt;&lt; windowHnd;
+    pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
 
-	mInputManager = OIS::InputManager::createInputSystem( pl );
+    mInputManager = OIS::InputManager::createInputSystem( pl );
 
-	//Create all devices (We only catch joystick exceptions here, as, most people have Key/Mouse)
-	mKeyboard = static_cast&lt;OIS::Keyboard*&gt;(mInputManager-&gt;createInputObject( OIS::OISKeyboard, false ));
+    //Create all devices (We only catch joystick exceptions here, as, most people have Key/Mouse)
+    mKeyboard = static_cast&lt;OIS::Keyboard*&gt;(mInputManager-&gt;createInputObject( OIS::OISKeyboard, false ));
 
 }
 
@@ -38,62 +46,62 @@
 
 bool BasicFrameListener::frameStarted(const Ogre::FrameEvent &amp;evt)
 {
-	m_elapsed += evt.timeSinceLastFrame;
+    m_elapsed += evt.timeSinceLastFrame;
 
 #ifdef _DEBUG
-	Ogre::LogManager::getSingleton().logMessage(&quot;   Newton Frame Listener... m_elapsed: &quot;+Ogre::StringConverter::toString(m_elapsed)+
-		&quot;  m_update:&quot;+Ogre::StringConverter::toString(m_update));
+    Ogre::LogManager::getSingleton().logMessage(&quot;   Newton Frame Listener... m_elapsed: &quot;+Ogre::StringConverter::toString(m_elapsed)+
+        &quot;  m_update:&quot;+Ogre::StringConverter::toString(m_update));
 #endif
 
-	int count = 0;
+    int count = 0;
 
-	// loop through and update as many times as necessary (up to 10 times maximum).
-	if ((m_elapsed &gt; m_update) &amp;&amp; (m_elapsed &lt; (m_update * 10)) )
-	{
-		while (m_elapsed &gt; m_update)
-		{
-			m_World-&gt;update( m_update );
-			m_elapsed -= m_update;
-			count++;
-		}
-	}
-	else
-	{
-		if (m_elapsed &lt; (m_update))
-		{
-			// not enough time has passed this loop, so ignore for now.
-		}
-		else
-		{
-			// too much time has passed (would require more than 10 updates!), so just update once and reset.
-			// this often happens on the first frame of a game, where assets and other things were loading, then
-			// the elapsed time since the last drawn frame is very long.
-			m_World-&gt;update( m_elapsed );
-			count++;
-			m_elapsed = 0.0f; // reset the elapsed time so we don't become &quot;eternally behind&quot;.
-		}
-	}
+    // loop through and update as many times as necessary (up to 10 times maximum).
+    if ((m_elapsed &gt; m_update) &amp;&amp; (m_elapsed &lt; (m_update * 10)) )
+    {
+        while (m_elapsed &gt; m_update)
+        {
+            m_World-&gt;update( m_update );
+            m_elapsed -= m_update;
+            count++;
+        }
+    }
+    else
+    {
+        if (m_elapsed &lt; (m_update))
+        {
+            // not enough time has passed this loop, so ignore for now.
+        }
+        else
+        {
+            // too much time has passed (would require more than 10 updates!), so just update once and reset.
+            // this often happens on the first frame of a game, where assets and other things were loading, then
+            // the elapsed time since the last drawn frame is very long.
+            m_World-&gt;update( m_elapsed );
+            count++;
+            m_elapsed = 0.0f; // reset the elapsed time so we don't become &quot;eternally behind&quot;.
+        }
+    }
 
 #ifdef _DEBUG
-	Ogre::LogManager::getSingleton().logMessage(&quot;   Newton updates this loop: &quot;+Ogre::StringConverter::toString(count));
+    Ogre::LogManager::getSingleton().logMessage(&quot;   Newton updates this loop: &quot;+Ogre::StringConverter::toString(count));
 #endif
 
-	/////////////////////////////////////////////////////////////
-	//		DEBUGGER
-	mKeyboard-&gt;capture();
+    /////////////////////////////////////////////////////////////
+    //      DEBUGGER
+    mKeyboard-&gt;capture();
 
-	if (mKeyboard-&gt;isKeyDown(OIS::KC_F3))
-	{
-		m_World-&gt;getDebugger().showDebugInformation();
-	}
-	else
-	{
-		m_World-&gt;getDebugger().hideDebugInformation();
-	}
+    if (mKeyboard-&gt;isKeyDown(OIS::KC_F3))
+    {
+        m_World-&gt;getDebugger().showDebugInformation();
+    }
+    else
+    {
+        m_World-&gt;getDebugger().hideDebugInformation();
+    }
 
-	
-	return true;
+    
+    return true;
 }
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt

Modified: dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -7,56 +7,56 @@
 
 namespace BasicJoints
 {
-	
+    
 BallAndSocket::BallAndSocket( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos ) : Joint()
 {
-	m_world = world;
+    m_world = world;
 
-	if (parent)
-		m_joint = NewtonConstraintCreateBall( world-&gt;getNewtonWorld(), &amp;pos.x, child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
-	else
-		m_joint = NewtonConstraintCreateBall( world-&gt;getNewtonWorld(), &amp;pos.x, child-&gt;getNewtonBody(), NULL );
+    if (parent)
+        m_joint = NewtonConstraintCreateBall( world-&gt;getNewtonWorld(), &amp;pos.x, child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
+    else
+        m_joint = NewtonConstraintCreateBall( world-&gt;getNewtonWorld(), &amp;pos.x, child-&gt;getNewtonBody(), NULL );
 
 
-	// all constructors inherited from Joint MUST call these 2 functions to make the joint function properly.
-	NewtonJointSetUserData( m_joint, this );
-	NewtonJointSetDestructor( m_joint, destructor );
+    // all constructors inherited from Joint MUST call these 2 functions to make the joint function properly.
+    NewtonJointSetUserData( m_joint, this );
+    NewtonJointSetDestructor( m_joint, destructor );
 
     m_callback = NULL;
 }
 
 BallAndSocket::~BallAndSocket()
 {
-	// nothing, the ~Joint() function will take care of us.
+    // nothing, the ~Joint() function will take care of us.
 }
 
 Ogre::Vector3 BallAndSocket::getJointAngle() const
 {
-	Ogre::Vector3 ret;
+    Ogre::Vector3 ret;
 
-	NewtonBallGetJointAngle( m_joint, &amp;ret.x );
+    NewtonBallGetJointAngle( m_joint, &amp;ret.x );
 
-	return ret;
+    return ret;
 }
 
 
 Ogre::Vector3 BallAndSocket::getJointOmega() const
 {
-	Ogre::Vector3 ret;
+    Ogre::Vector3 ret;
 
-	NewtonBallGetJointOmega( m_joint, &amp;ret.x );
+    NewtonBallGetJointOmega( m_joint, &amp;ret.x );
 
-	return ret;
+    return ret;
 }
 
 
 Ogre::Vector3 BallAndSocket::getJointForce() const
 {
-	Ogre::Vector3 ret;
+    Ogre::Vector3 ret;
 
-	NewtonBallGetJointForce( m_joint, &amp;ret.x );
+    NewtonBallGetJointForce( m_joint, &amp;ret.x );
 
-	return ret;
+    return ret;
 }
 
 
@@ -74,24 +74,24 @@
 
 Hinge::Hinge( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin ) : Joint()
 {
-	m_world = world;
+    m_world = world;
 
-	if (parent)
-	{
-		m_joint = NewtonConstraintCreateHinge( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
-												child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
-	}
-	else
-	{
-		m_joint = NewtonConstraintCreateHinge( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
-												child-&gt;getNewtonBody(), NULL );
-	}
+    if (parent)
+    {
+        m_joint = NewtonConstraintCreateHinge( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
+                                                child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
+    }
+    else
+    {
+        m_joint = NewtonConstraintCreateHinge( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
+                                                child-&gt;getNewtonBody(), NULL );
+    }
 
-	NewtonJointSetUserData( m_joint, this );
-	NewtonJointSetDestructor( m_joint, destructor );
-	NewtonHingeSetUserCallback( m_joint, newtonCallback );
+    NewtonJointSetUserData( m_joint, this );
+    NewtonJointSetDestructor( m_joint, destructor );
+    NewtonHingeSetUserCallback( m_joint, newtonCallback );
 
-	m_callback = NULL;
+    m_callback = NULL;
 }
 
 Hinge::~Hinge()
@@ -101,70 +101,70 @@
 
 Ogre::Vector3 Hinge::getJointForce() const
 {
-	Ogre::Vector3 ret;
+    Ogre::Vector3 ret;
 
-	NewtonHingeGetJointForce( m_joint, &amp;ret.x );
+    NewtonHingeGetJointForce( m_joint, &amp;ret.x );
 
-	return ret;
+    return ret;
 }
 
 unsigned _CDECL Hinge::newtonCallback( const NewtonJoint* hinge, NewtonHingeSliderUpdateDesc* desc )
 {
-	Hinge* me = (Hinge*)NewtonJointGetUserData( hinge );
+    Hinge* me = (Hinge*)NewtonJointGetUserData( hinge );
 
-	me-&gt;m_desc = desc;
-	me-&gt;m_retval = 0;
+    me-&gt;m_desc = desc;
+    me-&gt;m_retval = 0;
 
-	if (me-&gt;m_callback)
-		(*me-&gt;m_callback)( me );
+    if (me-&gt;m_callback)
+        (*me-&gt;m_callback)( me );
 
-	me-&gt;m_desc = NULL;
+    me-&gt;m_desc = NULL;
 
-	return me-&gt;m_retval;
+    return me-&gt;m_retval;
 }
 
 /////// CALLBACK FUNCTIONS ///////
 void Hinge::setCallbackAccel( Ogre::Real accel )
 {
-	if (m_desc)
-	{
-		m_retval = 1;
-		m_desc-&gt;m_accel = (float)accel;
-	}
+    if (m_desc)
+    {
+        m_retval = 1;
+        m_desc-&gt;m_accel = (float)accel;
+    }
 }
 
 void Hinge::setCallbackFrictionMin( Ogre::Real min )
 {
-	if (m_desc)
-	{
-		m_retval = 1;
-		m_desc-&gt;m_minFriction = (float)min;
-	}
+    if (m_desc)
+    {
+        m_retval = 1;
+        m_desc-&gt;m_minFriction = (float)min;
+    }
 }
 
 void Hinge::setCallbackFrictionMax( Ogre::Real max )
 {
-	if (m_desc)
-	{
-		m_retval = 1;
-		m_desc-&gt;m_maxFriction = (float)max;
-	}
+    if (m_desc)
+    {
+        m_retval = 1;
+        m_desc-&gt;m_maxFriction = (float)max;
+    }
 }
 
 Ogre::Real Hinge::getCallbackTimestep() const
 {
-	if (m_desc)
-		return (Ogre::Real)m_desc-&gt;m_timestep;
-	else
-		return 0.0;
+    if (m_desc)
+        return (Ogre::Real)m_desc-&gt;m_timestep;
+    else
+        return 0.0;
 }
 
 Ogre::Real Hinge::calculateStopAlpha( Ogre::Radian angle ) const
 {
-	if (m_desc)
-		return (Ogre::Real)NewtonHingeCalculateStopAlpha( m_joint, m_desc, (float)angle.valueRadians() );
-	else
-		return 0.0;
+    if (m_desc)
+        return (Ogre::Real)NewtonHingeCalculateStopAlpha( m_joint, m_desc, (float)angle.valueRadians() );
+    else
+        return 0.0;
 }
 
 
@@ -176,24 +176,24 @@
 
 Slider::Slider( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin ) : Joint()
 {
-	m_world = world;
+    m_world = world;
 
-	if (parent)
-	{
-		m_joint = NewtonConstraintCreateSlider( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
-												child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
-	}
-	else
-	{
-		m_joint = NewtonConstraintCreateSlider( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
-												child-&gt;getNewtonBody(), NULL );
-	}
+    if (parent)
+    {
+        m_joint = NewtonConstraintCreateSlider( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
+                                                child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
+    }
+    else
+    {
+        m_joint = NewtonConstraintCreateSlider( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin.x,
+                                                child-&gt;getNewtonBody(), NULL );
+    }
 
-	NewtonJointSetUserData( m_joint, this );
-	NewtonJointSetDestructor( m_joint, destructor );
-	NewtonSliderSetUserCallback( m_joint, newtonCallback );
+    NewtonJointSetUserData( m_joint, this );
+    NewtonJointSetDestructor( m_joint, destructor );
+    NewtonSliderSetUserCallback( m_joint, newtonCallback );
 
-	m_callback = NULL;
+    m_callback = NULL;
 }
 
 Slider::~Slider()
@@ -202,71 +202,71 @@
 
 Ogre::Vector3 Slider::getJointForce() const
 {
-	Ogre::Vector3 ret;
+    Ogre::Vector3 ret;
 
-	NewtonSliderGetJointForce( m_joint, &amp;ret.x );
+    NewtonSliderGetJointForce( m_joint, &amp;ret.x );
 
-	return ret;
+    return ret;
 }
 
 unsigned _CDECL Slider::newtonCallback( const NewtonJoint* slider, NewtonHingeSliderUpdateDesc* desc )
 {
-	Slider* me = (Slider*)NewtonJointGetUserData( slider );
+    Slider* me = (Slider*)NewtonJointGetUserData( slider );
 
-	me-&gt;m_desc = desc;
-	me-&gt;m_retval = 0;
+    me-&gt;m_desc = desc;
+    me-&gt;m_retval = 0;
 
-	if (me-&gt;m_callback)
-		(*me-&gt;m_callback)( me );
+    if (me-&gt;m_callback)
+        (*me-&gt;m_callback)( me );
 
-	me-&gt;m_desc = NULL;
+    me-&gt;m_desc = NULL;
 
-	return me-&gt;m_retval;
+    return me-&gt;m_retval;
 }
 
 
 /////// CALLBACK FUNCTIONS ///////
 void Slider::setCallbackAccel( Ogre::Real accel )
 {
-	if (m_desc)
-	{
-		m_retval = 1;
-		m_desc-&gt;m_accel = (float)accel;
-	}
+    if (m_desc)
+    {
+        m_retval = 1;
+        m_desc-&gt;m_accel = (float)accel;
+    }
 }
 
 void Slider::setCallbackFrictionMin( Ogre::Real min )
 {
-	if (m_desc)
-	{
-		m_retval = 1;
-		m_desc-&gt;m_minFriction = (float)min;
-	}
+    if (m_desc)
+    {
+        m_retval = 1;
+        m_desc-&gt;m_minFriction = (float)min;
+    }
 }
 
 void Slider::setCallbackFrictionMax( Ogre::Real max )
 {
-	if (m_desc)
-	{
-		m_retval = 1;
-		m_desc-&gt;m_maxFriction = (float)max;
-	}
+    if (m_desc)
+    {
+        m_retval = 1;
+        m_desc-&gt;m_maxFriction = (float)max;
+    }
 }
 
 Ogre::Real Slider::getCallbackTimestep() const
 {
-	if (m_desc)
-		return (Ogre::Real)m_desc-&gt;m_timestep;
-	else
-		return 0.0;
+    if (m_desc)
+        return (Ogre::Real)m_desc-&gt;m_timestep;
+    else
+        return 0.0;
 }
 
 Ogre::Real Slider::calculateStopAccel( Ogre::Real dist ) const
 {
-	if (m_desc)
-		return (Ogre::Real)NewtonSliderCalculateStopAccel( m_joint, m_desc, (float)dist );
-	else
-		return 0.0;
+    if (m_desc)
+        return (Ogre::Real)NewtonSliderCalculateStopAccel( m_joint, m_desc, (float)dist );
+    else
+        return 0.0;
 }
 
 
@@ -278,24 +278,24 @@
 
 Universal::Universal( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin0, const Ogre::Vector3&amp; pin1 ) : Joint()
 {
-	m_world = world;
+    m_world = world;
 
-	if (parent)
-	{
-		m_joint = NewtonConstraintCreateUniversal( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin0.x, &amp;pin1.x,
-												child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
-	}
-	else
-	{
-		m_joint = NewtonConstraintCreateUniversal( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin0.x, &amp;pin1.x,
-												child-&gt;getNewtonBody(), NULL );
-	}
+    if (parent)
+    {
+        m_joint = NewtonConstraintCreateUniversal( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin0.x, &amp;pin1.x,
+                                                child-&gt;getNewtonBody(), parent-&gt;getNewtonBody() );
+    }
+    else
+    {
+        m_joint = NewtonConstraintCreateUniversal( world-&gt;getNewtonWorld(), &amp;pos.x, &amp;pin0.x, &amp;pin1.x,
+                                                child-&gt;getNewtonBody(), NULL );
+    }
 
-	NewtonJointSetUserData( m_joint, this );
-	NewtonJointSetDestructor( m_joint, destructor );
-	NewtonUniversalSetUserCallback( m_joint, newtonCallback );
+    NewtonJointSetUserData( m_joint, this );
+    NewtonJointSetDestructor( m_joint, destructor );
+    NewtonUniversalSetUserCallback( m_joint, newtonCallback );
 
-	m_callback = NULL;
+    m_callback = NULL;
 }
 
 Universal::~Universal()
@@ -304,85 +304,85 @@
 
 Ogre::Vector3 Universal::getJointForce() const
 {
-	Ogre::Vector3 ret;
+    Ogre::Vector3 ret;
 
-	NewtonUniversalGetJointForce( m_joint, &amp;ret.x );
+    NewtonUniversalGetJointForce( m_joint, &amp;ret.x );
 
-	return ret;
+    return ret;
 }
 
 unsigned _CDECL Universal::newtonCallback( const NewtonJoint* universal, NewtonHingeSliderUpdateDesc* desc )
 {
-	Universal* me = (Universal*)NewtonJointGetUserData( universal );
+    Universal* me = (Universal*)NewtonJointGetUserData( universal );
 
-	me-&gt;m_desc = desc;
-	me-&gt;m_retval = 0;
+    me-&gt;m_desc = desc;
+    me-&gt;m_retval = 0;
 
-	if (me-&gt;m_callback)
-		(*me-&gt;m_callback)( me );
+    if (me-&gt;m_callback)
+        (*me-&gt;m_callback)( me );
 
-	me-&gt;m_desc = NULL;
+    me-&gt;m_desc = NULL;
 
-	return me-&gt;m_retval;
+    return me-&gt;m_retval;
 }
 
 
 /////// CALLBACK FUNCTIONS ///////
 void Universal::setCallbackAccel( Ogre::Real accel, unsigned int axis )
 {
-	if (axis &gt; 1) { return; }
+    if (axis &gt; 1) { return; }
 
-	if (m_desc)
-	{
-		m_retval |= axis;
-		m_desc[axis].m_accel = (float)accel;
-	}
+    if (m_desc)
+    {
+        m_retval |= axis;
+        m_desc[axis].m_accel = (float)accel;
+    }
 }
 
 void Universal::setCallbackFrictionMax( Ogre::Real max, unsigned int axis )
 {
-	if (axis &gt; 1) { return; }
+    if (axis &gt; 1) { return; }
 
-	if (m_desc)
-	{
-		m_retval |= axis;
-		m_desc[axis].m_maxFriction = (float)max;
-	}
+    if (m_desc)
+    {
+        m_retval |= axis;
+        m_desc[axis].m_maxFriction = (float)max;
+    }
 }
 
 void Universal::setCallbackFrictionMin( Ogre::Real min, unsigned int axis )
 {
-	if (axis &gt; 1) { return; }
+    if (axis &gt; 1) { return; }
 
-	if (m_desc)
-	{
-		m_retval |= axis;
-		m_desc[axis].m_minFriction = (float)min;
-	}
+    if (m_desc)
+    {
+        m_retval |= axis;
+        m_desc[axis].m_minFriction = (float)min;
+    }
 }
 
 Ogre::Real Universal::getCallbackTimestep() const
 {
-	if (m_desc)
-		return (Ogre::Real)m_desc-&gt;m_timestep;
-	else
-		return 0.0;
+    if (m_desc)
+        return (Ogre::Real)m_desc-&gt;m_timestep;
+    else
+        return 0.0;
 }
 
 Ogre::Real Universal::calculateStopAlpha0( Ogre::Real angle ) const
 {
-	if (m_desc)
-		return (Ogre::Real)NewtonUniversalCalculateStopAlpha0( m_joint, m_desc, (float)angle );
-	else
-		return 0.0;
+    if (m_desc)
+        return (Ogre::Real)NewtonUniversalCalculateStopAlpha0( m_joint, m_desc, (float)angle );
+    else
+        return 0.0;
 }
 
 Ogre::Real Universal::calculateStopAlpha1( Ogre::Real angle ) const
 {
-	if (m_desc)
-		return (Ogre::Real)NewtonUniversalCalculateStopAlpha1( m_joint, m_desc, (float)angle );
-	else
-		return 0.0;
+    if (m_desc)
+        return (Ogre::Real)NewtonUniversalCalculateStopAlpha1( m_joint, m_desc, (float)angle );
+    else
+        return 0.0;
 }
 
 
@@ -393,12 +393,12 @@
 
 UpVector::UpVector( const World* world, const Body* body, const Ogre::Vector3&amp; pin )
 {
-	m_world = world;
+    m_world = world;
 
-	m_joint = NewtonConstraintCreateUpVector( world-&gt;getNewtonWorld(), &amp;pin.x, body-&gt;getNewtonBody() );
+    m_joint = NewtonConstraintCreateUpVector( world-&gt;getNewtonWorld(), &amp;pin.x, body-&gt;getNewtonBody() );
 
-	NewtonJointSetUserData( m_joint, this );
-	NewtonJointSetDestructor( m_joint, destructor );
+    NewtonJointSetUserData( m_joint, this );
+    NewtonJointSetDestructor( m_joint, destructor );
 
 }
 
@@ -408,18 +408,18 @@
 
 Ogre::Vector3 UpVector::getPin() const
 {
-	Ogre::Vector3 ret;
+    Ogre::Vector3 ret;
 
-	NewtonUpVectorGetPin( m_joint, &amp;ret.x );
+    NewtonUpVectorGetPin( m_joint, &amp;ret.x );
 
-	return ret;
+    return ret;
 }
 
 
 
 
 
-}	// end NAMESPACE BasicJoints
+}   // end NAMESPACE BasicJoints
 
 
 
@@ -438,129 +438,129 @@
 
 Custom2DJoint::Custom2DJoint(const OgreNewt::Body* body, const Ogre::Vector3&amp; pin ) : CustomJoint( 4, body, NULL )
 {
-	mPin = pin;
-	Ogre::Quaternion bodyorient;
-	Ogre::Vector3 bodypos;
+    mPin = pin;
+    Ogre::Quaternion bodyorient;
+    Ogre::Vector3 bodypos;
 
-	body-&gt;getPositionOrientation( bodypos, bodyorient );
+    body-&gt;getPositionOrientation( bodypos, bodyorient );
 
-	pinAndDirToLocal( bodypos, pin, mLocalOrient0, mLocalPos0, mLocalOrient1, mLocalPos1 );
+    pinAndDirToLocal( bodypos, pin, mLocalOrient0, mLocalPos0, mLocalOrient1, mLocalPos1 );
 
-	// initialize variables
-	mMin = mMax = Ogre::Degree(0);
-	mLimitsOn = false;
-	mAccel = 0.0f;
+    // initialize variables
+    mMin = mMax = Ogre::Degree(0);
+    mLimitsOn = false;
+    mAccel = 0.0f;
 
 }
 
 
 void Custom2DJoint::submitConstraint( Ogre::Real timeStep, int threadIndex )
 {
-	// get the global orientations.
-	Ogre::Quaternion globalOrient0, globalOrient1;
-	Ogre::Vector3 globalPos0, globalPos1;
+    // get the global orientations.
+    Ogre::Quaternion globalOrient0, globalOrient1;
+    Ogre::Vector3 globalPos0, globalPos1;
 
-	localToGlobal( mLocalOrient0, mLocalPos0, globalOrient0, globalPos0, 0 );
-	localToGlobal( mLocalOrient1, mLocalPos1, globalOrient1, globalPos1, 1 );
+    localToGlobal( mLocalOrient0, mLocalPos0, globalOrient0, globalPos0, 0 );
+    localToGlobal( mLocalOrient1, mLocalPos1, globalOrient1, globalPos1, 1 );
 
-	// calculate all main 6 vectors.
-	Ogre::Vector3 bod0X = globalOrient0 * Ogre::Vector3( Ogre::Vector3::UNIT_X );
-	Ogre::Vector3 bod0Y = globalOrient0 * Ogre::Vector3( Ogre::Vector3::UNIT_Y );
-	Ogre::Vector3 bod0Z = globalOrient0 * Ogre::Vector3( Ogre::Vector3::UNIT_Z );
-	
-	Ogre::Vector3 bod1X = globalOrient1 * Ogre::Vector3( Ogre::Vector3::UNIT_X );
-	Ogre::Vector3 bod1Y = globalOrient1 * Ogre::Vector3( Ogre::Vector3::UNIT_Y );
-	Ogre::Vector3 bod1Z = globalOrient1 * Ogre::Vector3( Ogre::Vector3::UNIT_Z );
+    // calculate all main 6 vectors.
+    Ogre::Vector3 bod0X = globalOrient0 * Ogre::Vector3( Ogre::Vector3::UNIT_X );
+    Ogre::Vector3 bod0Y = globalOrient0 * Ogre::Vector3( Ogre::Vector3::UNIT_Y );
+    Ogre::Vector3 bod0Z = globalOrient0 * Ogre::Vector3( Ogre::Vector3::UNIT_Z );
+    
+    Ogre::Vector3 bod1X = globalOrient1 * Ogre::Vector3( Ogre::Vector3::UNIT_X );
+    Ogre::Vector3 bod1Y = globalOrient1 * Ogre::Vector3( Ogre::Vector3::UNIT_Y );
+    Ogre::Vector3 bod1Z = globalOrient1 * Ogre::Vector3( Ogre::Vector3::UNIT_Z );
 
 #ifdef _DEBUG
-	Ogre::LogManager::getSingletonPtr()-&gt;logMessage(&quot; Submit Constraint   bod0X:&quot;+Ogre::StringConverter::toString( bod0X )+
-		&quot;   bod1X:&quot;+Ogre::StringConverter::toString( bod1X ) );
+    Ogre::LogManager::getSingletonPtr()-&gt;logMessage(&quot; Submit Constraint   bod0X:&quot;+Ogre::StringConverter::toString( bod0X )+
+        &quot;   bod1X:&quot;+Ogre::StringConverter::toString( bod1X ) );
 #endif
-	
-	// ---------------------------------------------------------------
-	// first add a linear row to keep the body on the plane.
-	addLinearRow( globalPos0, globalPos1, bod0X );
+    
+    // ---------------------------------------------------------------
+    // first add a linear row to keep the body on the plane.
+    addLinearRow( globalPos0, globalPos1, bod0X );
 
-	// have we strayed from the plane along the normal?
-	Ogre::Plane thePlane( bod0X, globalPos0 );
-	Ogre::Real stray = thePlane.getDistance( globalPos1 );
-	if (stray &gt; 0.0001f)
-	{
-		// we have strayed, apply acceleration to move back to 0 in one timestep.
-		Ogre::Real accel = (stray / timeStep);
-		if (thePlane.getSide( globalPos1 ) == Ogre::Plane::NEGATIVE_SIDE) { accel = -accel; }
+    // have we strayed from the plane along the normal?
+    Ogre::Plane thePlane( bod0X, globalPos0 );
+    Ogre::Real stray = thePlane.getDistance( globalPos1 );
+    if (stray &gt; 0.0001f)
+    {
+        // we have strayed, apply acceleration to move back to 0 in one timestep.
+        Ogre::Real accel = (stray / timeStep);
+        if (thePlane.getSide( globalPos1 ) == Ogre::Plane::NEGATIVE_SIDE) { accel = -accel; }
 
-		setRowAcceleration( accel );
-	}
+        setRowAcceleration( accel );
+    }
 
-	// see if the main axis (pin) has wandered off.
-	Ogre::Vector3 latDir = bod0X.crossProduct( bod1X );
-	Ogre::Real latMag = latDir.squaredLength();
+    // see if the main axis (pin) has wandered off.
+    Ogre::Vector3 latDir = bod0X.crossProduct( bod1X );
+    Ogre::Real latMag = latDir.squaredLength();
 
-	if (latMag &gt; 1.0e-6f)
-	{
-		// has wandered a bit, we need to correct.  first find the angle off.
-		latMag = Ogre::Math::Sqrt( latMag );
-		latDir.normalise();
-		Ogre::Radian angle = Ogre::Math::ASin( latMag );
+    if (latMag &gt; 1.0e-6f)
+    {
+        // has wandered a bit, we need to correct.  first find the angle off.
+        latMag = Ogre::Math::Sqrt( latMag );
+        latDir.normalise();
+        Ogre::Radian angle = Ogre::Math::ASin( latMag );
 
-		// ---------------------------------------------------------------
-		addAngularRow( angle, latDir );
+        // ---------------------------------------------------------------
+        addAngularRow( angle, latDir );
 
-		// ---------------------------------------------------------------
-		// secondary correction for stability.
-		Ogre::Vector3 latDir2 = latDir.crossProduct( bod1X );
-		addAngularRow( Ogre::Radian(0.0f), latDir2 );
-	}
-	else
-	{
-		// ---------------------------------------------------------------
-		// no major change, just add 2 simple constraints.
-		addAngularRow( Ogre::Radian(0.0f), bod1Y );
-		addAngularRow( Ogre::Radian(0.0f), bod1Z );
-	}
+        // ---------------------------------------------------------------
+        // secondary correction for stability.
+        Ogre::Vector3 latDir2 = latDir.crossProduct( bod1X );
+        addAngularRow( Ogre::Radian(0.0f), latDir2 );
+    }
+    else
+    {
+        // ---------------------------------------------------------------
+        // no major change, just add 2 simple constraints.
+        addAngularRow( Ogre::Radian(0.0f), bod1Y );
+        addAngularRow( Ogre::Radian(0.0f), bod1Z );
+    }
 
-	// calculate the current angle.
-	Ogre::Real cos = bod0Y.dotProduct( bod1Y );
-	Ogre::Real sin = (bod0Y.crossProduct( bod1Y )).dotProduct( bod0X );
+    // calculate the current angle.
+    Ogre::Real cos = bod0Y.dotProduct( bod1Y );
+    Ogre::Real sin = (bod0Y.crossProduct( bod1Y )).dotProduct( bod0X );
 
-	mAngle = Ogre::Math::ATan2( sin, cos );
+    mAngle = Ogre::Math::ATan2( sin, cos );
 
-	if (mLimitsOn)
-	{
-		if (mAngle &gt; mMax)
-		{
-			Ogre::Radian diff = mAngle - mMax;
+    if (mLimitsOn)
+    {
+        if (mAngle &gt; mMax)
+        {
+            Ogre::Radian diff = mAngle - mMax;
 
-			addAngularRow( diff, bod0X );
-			setRowStiffness( 1.0f );
-		}
-		else if (mAngle &lt; mMin)
-		{
-			Ogre::Radian diff = mAngle - mMin;
+            addAngularRow( diff, bod0X );
+            setRowStiffness( 1.0f );
+        }
+        else if (mAngle &lt; mMin)
+        {
+            Ogre::Radian diff = mAngle - mMin;
 
-			addAngularRow( diff, bod0X );
-			setRowStiffness( 1.0f );
-		}
-	}
-	else
-	{
-		if (mAccel != 0.0f)
-		{
-			addAngularRow( Ogre::Radian(0.0f), bod0X );
-			setRowAcceleration( mAccel );
+            addAngularRow( diff, bod0X );
+            setRowStiffness( 1.0f );
+        }
+    }
+    else
+    {
+        if (mAccel != 0.0f)
+        {
+            addAngularRow( Ogre::Radian(0.0f), bod0X );
+            setRowAcceleration( mAccel );
 
-			mAccel = 0.0f;
-		}
-	}
-	
+            mAccel = 0.0f;
+        }
+    }
+    
 }
 
 
 CustomRigidJoint::CustomRigidJoint(OgreNewt::Body *child, OgreNewt::Body *parent, Ogre::Vector3 dir, Ogre::Vector3 pos) : OgreNewt::CustomJoint(6,child,parent)
 {
-	// calculate local offsets.
-	pinAndDirToLocal( pos, dir, mLocalOrient0, mLocalPos0, mLocalOrient1, mLocalPos1 );
+    // calculate local offsets.
+    pinAndDirToLocal( pos, dir, mLocalOrient0, mLocalPos0, mLocalOrient1, mLocalPos1 );
 }
 
 CustomRigidJoint::~CustomRigidJoint()
@@ -569,38 +569,38 @@
 
 void CustomRigidJoint::submitConstraint( Ogre::Real timeStep, int threadIndex )
 {
-	// get globals.
-	Ogre::Vector3 globalPos0, globalPos1;
-	Ogre::Quaternion globalOrient0, globalOrient1;
+    // get globals.
+    Ogre::Vector3 globalPos0, globalPos1;
+    Ogre::Quaternion globalOrient0, globalOrient1;
 
-	localToGlobal( mLocalOrient0, mLocalPos0, globalOrient0, globalPos0, 0 );
-	localToGlobal( mLocalOrient1, mLocalPos1, globalOrient1, globalPos1, 1 );
+    localToGlobal( mLocalOrient0, mLocalPos0, globalOrient0, globalPos0, 0 );
+    localToGlobal( mLocalOrient1, mLocalPos1, globalOrient1, globalPos1, 1 );
 
-	// apply the constraints!
-	addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_X );
-	addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Y );
-	addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Z );
+    // apply the constraints!
+    addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_X );
+    addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Y );
+    addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Z );
 
-	// now find a point off 10 units away.
-	globalPos0 = globalPos0 + (globalOrient0 * (Ogre::Vector3::UNIT_X * 10.0f));
-	globalPos1 = globalPos1 + (globalOrient1 * (Ogre::Vector3::UNIT_X * 10.0f));
+    // now find a point off 10 units away.
+    globalPos0 = globalPos0 + (globalOrient0 * (Ogre::Vector3::UNIT_X * 10.0f));
+    globalPos1 = globalPos1 + (globalOrient1 * (Ogre::Vector3::UNIT_X * 10.0f));
 
-	// apply the constraints!
-	addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Y );
-	addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Z );
+    // apply the constraints!
+    addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Y );
+    addLinearRow( globalPos0, globalPos1, globalOrient0 * Ogre::Vector3::UNIT_Z );
 
-	Ogre::Vector3 xdir0 = globalOrient0 * Ogre::Vector3::UNIT_X;
-	Ogre::Vector3 xdir1 = globalOrient1 * Ogre::Vector3::UNIT_X;
+    Ogre::Vector3 xdir0 = globalOrient0 * Ogre::Vector3::UNIT_X;
+    Ogre::Vector3 xdir1 = globalOrient1 * Ogre::Vector3::UNIT_X;
 
-	Ogre::Radian angle = Ogre::Math::ACos( xdir0.dotProduct( xdir1 ) );
-	addAngularRow( angle, globalOrient0 * Ogre::Vector3::UNIT_X );
+    Ogre::Radian angle = Ogre::Math::ACos( xdir0.dotProduct( xdir1 ) );
+    addAngularRow( angle, globalOrient0 * Ogre::Vector3::UNIT_X );
 }
 
 
 
-}	// end NAMESPACE PrebuiltCustomJoints
+}   // end NAMESPACE PrebuiltCustomJoints
 
 
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt

Modified: dependencies/OgreNewt/src/OgreNewt_Body.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -7,295 +7,295 @@
 namespace OgreNewt
 {
 
-	
+    
 Body::Body( const World* W, const OgreNewt::Collision* col, int bodytype ) 
 {
-	m_world = W;
-	m_collision = col;
-	m_type = bodytype;
-	m_node = NULL;
-	m_matid = NULL;
-	
-	m_userdata = NULL;
+    m_world = W;
+    m_collision = col;
+    m_type = bodytype;
+    m_node = NULL;
+    m_matid = NULL;
+    
+    m_userdata = NULL;
 
-	m_forcecallback = NULL;
-	m_transformcallback = NULL;
-	m_buoyancycallback = NULL;
+    m_forcecallback = NULL;
+    m_transformcallback = NULL;
+    m_buoyancycallback = NULL;
 
-	m_body = NewtonCreateBody( m_world-&gt;getNewtonWorld(), col-&gt;getNewtonCollision() ); 
+    m_body = NewtonCreateBody( m_world-&gt;getNewtonWorld(), col-&gt;getNewtonCollision() ); 
 
-	NewtonBodySetUserData( m_body, this );
-	NewtonBodySetDestructorCallback( m_body, newtonDestructor );
+    NewtonBodySetUserData( m_body, this );
+    NewtonBodySetDestructorCallback( m_body, newtonDestructor );
 }
 
 Body::~Body()
 {
-	if (m_body)
-	{
-		if (NewtonBodyGetUserData(m_body))
-		{
-			NewtonBodySetDestructorCallback( m_body, NULL );
-			NewtonDestroyBody( m_world-&gt;getNewtonWorld(), m_body );
-		}
-	}
+    if (m_body)
+    {
+        if (NewtonBodyGetUserData(m_body))
+        {
+            NewtonBodySetDestructorCallback( m_body, NULL );
+            NewtonDestroyBody( m_world-&gt;getNewtonWorld(), m_body );
+        }
+    }
 }
 
 // destructor callback
 void _CDECL Body::newtonDestructor( const NewtonBody* body )
 {
-	//newton wants to destroy the body.. so first find it.
-	OgreNewt::Body* me;
+    //newton wants to destroy the body.. so first find it.
+    OgreNewt::Body* me;
 
-	me = (OgreNewt::Body*)NewtonBodyGetUserData( body );
+    me = (OgreNewt::Body*)NewtonBodyGetUserData( body );
 
-	// remove destructor callback
-	NewtonBodySetDestructorCallback( body, NULL );
-	// remove the user data
-	NewtonBodySetUserData( body, NULL );
+    // remove destructor callback
+    NewtonBodySetDestructorCallback( body, NULL );
+    // remove the user data
+    NewtonBodySetUserData( body, NULL );
 
-	//now delete the object.
-	delete me;
+    //now delete the object.
+    delete me;
 }
 
 
 // transform callback
 void _CDECL Body::newtonTransformCallback( const NewtonBody* body, const float* matrix, int threadIndex )
 {
-	Ogre::Quaternion orient;
-	Ogre::Vector3 pos;
-	OgreNewt::Body* me;
+    Ogre::Quaternion orient;
+    Ogre::Vector3 pos;
+    OgreNewt::Body* me;
 
-	me = (OgreNewt::Body*) NewtonBodyGetUserData( body );
+    me = (OgreNewt::Body*) NewtonBodyGetUserData( body );
 
-	OgreNewt::Converters::MatrixToQuatPos( matrix, orient, pos );
+    OgreNewt::Converters::MatrixToQuatPos( matrix, orient, pos );
 
-	if (me-&gt;m_transformcallback)
-		me-&gt;m_transformcallback( me, orient, pos, threadIndex );
+    if (me-&gt;m_transformcallback)
+        me-&gt;m_transformcallback( me, orient, pos, threadIndex );
 }
 
-	
+    
 void _CDECL Body::newtonForceTorqueCallback( const NewtonBody* body, float timeStep, int threadIndex )
 {
-	OgreNewt::Body* me = (OgreNewt::Body*)NewtonBodyGetUserData( body );
+    OgreNewt::Body* me = (OgreNewt::Body*)NewtonBodyGetUserData( body );
 
-	if (me-&gt;m_forcecallback)
-		me-&gt;m_forcecallback( me, timeStep, threadIndex );
+    if (me-&gt;m_forcecallback)
+        me-&gt;m_forcecallback( me, timeStep, threadIndex );
 }
 
 void Body::standardForceCallback( OgreNewt::Body* me, float timestep, int threadIndex )
 {
-	//apply a simple gravity force.
-	Ogre::Real mass;
-	Ogre::Vector3 inertia;
+    //apply a simple gravity force.
+    Ogre::Real mass;
+    Ogre::Vector3 inertia;
 
-	me-&gt;getMassMatrix(mass, inertia);
-	Ogre::Vector3 force(0,-9.8,0);
-	force *= mass;
+    me-&gt;getMassMatrix(mass, inertia);
+    Ogre::Vector3 force(0,-9.8,0);
+    force *= mass;
 
-	me-&gt;addForce( force );
+    me-&gt;addForce( force );
 
 }
 
 
 void Body::standardTransformCallback( OgreNewt::Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos, int threadIndex )
 {
-	me-&gt;m_node-&gt;setOrientation( orient );
-	me-&gt;m_node-&gt;setPosition( pos );
+    me-&gt;m_node-&gt;setOrientation( orient );
+    me-&gt;m_node-&gt;setPosition( pos );
 }
 
 
 
 int _CDECL Body::newtonBuoyancyCallback(const int collisionID, void *context, const float* globalSpaceMatrix, float* globalSpacePlane)
 {
-	OgreNewt::Body* me = (OgreNewt::Body*)context;
+    OgreNewt::Body* me = (OgreNewt::Body*)context;
 
-	
-	Ogre::Quaternion orient;
-	Ogre::Vector3 pos;
+    
+    Ogre::Quaternion orient;
+    Ogre::Vector3 pos;
 
-	OgreNewt::Converters::MatrixToQuatPos( globalSpaceMatrix, orient, pos );
+    OgreNewt::Converters::MatrixToQuatPos( globalSpaceMatrix, orient, pos );
 
-	// call our user' function to get the plane.
-	Ogre::Plane theplane;
-	
-	if (me-&gt;m_buoyancycallback(collisionID, me, orient, pos, theplane))
-	{
-		globalSpacePlane[0] = theplane.normal.x;
-		globalSpacePlane[1] = theplane.normal.y;
-		globalSpacePlane[2] = theplane.normal.z;
+    // call our user' function to get the plane.
+    Ogre::Plane theplane;
+    
+    if (me-&gt;m_buoyancycallback(collisionID, me, orient, pos, theplane))
+    {
+        globalSpacePlane[0] = theplane.normal.x;
+        globalSpacePlane[1] = theplane.normal.y;
+        globalSpacePlane[2] = theplane.normal.z;
 
-		globalSpacePlane[3] = theplane.d;
+        globalSpacePlane[3] = theplane.d;
 
-		return 1;
-	}
+        return 1;
+    }
 
-	return 0;
+    return 0;
 }
 
 
 // attachToNode
 void Body::attachNode( Ogre::Node* node )
 {
-	m_node = node;
-	if (m_body)
-	{
-		setCustomTransformCallback( &amp;Body::standardTransformCallback );
-	}
+    m_node = node;
+    if (m_body)
+    {
+        setCustomTransformCallback( &amp;Body::standardTransformCallback );
+    }
 }
 
 void Body::setPositionOrientation( const Ogre::Vector3&amp; pos, const Ogre::Quaternion&amp; orient )
 {
-	if (m_body)
-	{
-		float matrix[16];
+    if (m_body)
+    {
+        float matrix[16];
 
-		OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
-		NewtonBodySetMatrix( m_body, &amp;matrix[0] );
+        OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+        NewtonBodySetMatrix( m_body, &amp;matrix[0] );
 
-		if (m_node)
-		{
-			m_node-&gt;setOrientation( orient );
-			m_node-&gt;setPosition( pos );
-		}
-	}
+        if (m_node)
+        {
+            m_node-&gt;setOrientation( orient );
+            m_node-&gt;setPosition( pos );
+        }
+    }
 }
 
 // set mass matrix
 void Body::setMassMatrix( Ogre::Real mass, const Ogre::Vector3&amp; inertia )
 {
-	if (m_body)
-		NewtonBodySetMassMatrix( m_body, (float)mass, (float)inertia.x, (float)inertia.y, (float)inertia.z );
+    if (m_body)
+        NewtonBodySetMassMatrix( m_body, (float)mass, (float)inertia.x, (float)inertia.y, (float)inertia.z );
 }
 
 // basic gravity callback
 void Body::setStandardForceCallback()
 {
-	setCustomForceAndTorqueCallback( standardForceCallback );
+    setCustomForceAndTorqueCallback( standardForceCallback );
 }
 
 // custom user force callback
 void Body::setCustomForceAndTorqueCallback( ForceCallback callback )
 {
-	if (!m_forcecallback)
-	{
-		m_forcecallback = callback;
-		NewtonBodySetForceAndTorqueCallback( m_body, newtonForceTorqueCallback );
-	}
-	else
-	{
-			m_forcecallback = callback;
-	}
+    if (!m_forcecallback)
+    {
+        m_forcecallback = callback;
+        NewtonBodySetForceAndTorqueCallback( m_body, newtonForceTorqueCallback );
+    }
+    else
+    {
+            m_forcecallback = callback;
+    }
 
 }
 
 // custom user force callback
 void Body::setCustomTransformCallback( TransformCallback callback )
 {
-	if (!m_transformcallback)
-	{
-		m_transformcallback = callback;
-		NewtonBodySetTransformCallback( m_body, newtonTransformCallback );
-	}
-	else
-	{
-			m_transformcallback = callback;
-	}
+    if (!m_transformcallback)
+    {
+        m_transformcallback = callback;
+        NewtonBodySetTransformCallback( m_body, newtonTransformCallback );
+    }
+    else
+    {
+            m_transformcallback = callback;
+    }
 
 }
 
 //set collision
 void Body::setCollision( const OgreNewt::Collision* col )
 {
-	NewtonBodySetCollision( m_body, col-&gt;getNewtonCollision() );
+    NewtonBodySetCollision( m_body, col-&gt;getNewtonCollision() );
 
-	m_collision = col;
+    m_collision = col;
 }
 
 //get collision
 const OgreNewt::Collision* Body::getCollision() const
 {
-	return m_collision;
+    return m_collision;
 }
 
 //get material group ID
 const OgreNewt::MaterialID* Body::getMaterialGroupID() const
 {
-	if (m_matid)
-		return m_matid;
-	else
-        return m_world-&gt;getDefaultMaterialID();		
+    if (m_matid)
+        return m_matid;
+    else
+        return m_world-&gt;getDefaultMaterialID();     
 }
 
 
 // get position and orientation
 void Body::getPositionOrientation( Ogre::Vector3&amp; pos, Ogre::Quaternion&amp; orient ) const
 {
-	float matrix[16];
+    float matrix[16];
 
-	NewtonBodyGetMatrix( m_body, matrix );
-	OgreNewt::Converters::MatrixToQuatPos( matrix, orient, pos );
+    NewtonBodyGetMatrix( m_body, matrix );
+    OgreNewt::Converters::MatrixToQuatPos( matrix, orient, pos );
 }
 
 Ogre::AxisAlignedBox Body::getAABB() const
 {
-	Ogre::AxisAlignedBox ret;
-	Ogre::Vector3 min, max;
-	NewtonBodyGetAABB( m_body, &amp;min.x, &amp;max.x );
+    Ogre::AxisAlignedBox ret;
+    Ogre::Vector3 min, max;
+    NewtonBodyGetAABB( m_body, &amp;min.x, &amp;max.x );
 
-	ret.setExtents( min, max );
-	return ret;
+    ret.setExtents( min, max );
+    return ret;
 }
 
 void Body::getMassMatrix( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const
 {
-	NewtonBodyGetMassMatrix( m_body, &amp;mass, &amp;inertia.x, &amp;inertia.y, &amp;inertia.z );
+    NewtonBodyGetMassMatrix( m_body, &amp;mass, &amp;inertia.x, &amp;inertia.y, &amp;inertia.z );
 }
 
 void Body::getInvMass( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const
 {
-	NewtonBodyGetInvMass( m_body, &amp;mass, &amp;inertia.x, &amp;inertia.y, &amp;inertia.z );
+    NewtonBodyGetInvMass( m_body, &amp;mass, &amp;inertia.x, &amp;inertia.y, &amp;inertia.z );
 }
 
 Ogre::Vector3 Body::getOmega() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetOmega( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetOmega( m_body, &amp;ret.x );
+    return ret;
 }
 
 Ogre::Vector3 Body::getVelocity() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetVelocity( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetVelocity( m_body, &amp;ret.x );
+    return ret;
 }
 
 Ogre::Vector3 Body::getForce() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetForce( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetForce( m_body, &amp;ret.x );
+    return ret;
 }
 
 Ogre::Vector3 Body::getTorque() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetTorque( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetTorque( m_body, &amp;ret.x );
+    return ret;
 }
 
 Ogre::Vector3 Body::getForceAcceleration() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetForceAcc( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetForceAcc( m_body, &amp;ret.x );
+    return ret;
 }
 
 Ogre::Vector3 Body::getTorqueAcceleration() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetTorqueAcc( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetTorqueAcc( m_body, &amp;ret.x );
+    return ret;
 }
 
 Ogre::Vector3 Body::calculateInverseDynamicsForce(Ogre::Real timestep, Ogre::Vector3 desiredVelocity)
@@ -309,56 +309,56 @@
 
 Ogre::Vector3 Body::getAngularDamping() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetAngularDamping( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetAngularDamping( m_body, &amp;ret.x );
+    return ret;
 }
 
 Ogre::Vector3 Body::getCenterOfMass() const
 {
-	Ogre::Vector3 ret;
-	NewtonBodyGetCentreOfMass( m_body, &amp;ret.x );
-	return ret;
+    Ogre::Vector3 ret;
+    NewtonBodyGetCentreOfMass( m_body, &amp;ret.x );
+    return ret;
 }
 
 void Body::addBouyancyForce( Ogre::Real fluidDensity, Ogre::Real fluidLinearViscosity, Ogre::Real fluisAngularViscosity, const Ogre::Vector3&amp; gravity, buoyancyPlaneCallback callback )
 {
-	// call the newton function.
-	if (callback)
-		m_buoyancycallback = callback;
-	else
-		m_buoyancycallback = NULL;
+    // call the newton function.
+    if (callback)
+        m_buoyancycallback = callback;
+    else
+        m_buoyancycallback = NULL;
 
-	NewtonBodyAddBuoyancyForce( m_body, fluidDensity, fluidLinearViscosity, fluisAngularViscosity,
-		&amp;gravity.x, newtonBuoyancyCallback, this );
+    NewtonBodyAddBuoyancyForce( m_body, fluidDensity, fluidLinearViscosity, fluisAngularViscosity,
+        &amp;gravity.x, newtonBuoyancyCallback, this );
 
-	m_buoyancycallback = NULL;
+    m_buoyancycallback = NULL;
 }
 
 void Body::addGlobalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos )
 {
-	Ogre::Vector3 bodypos;
-	Ogre::Quaternion bodyorient;
-	getPositionOrientation( bodypos, bodyorient );
+    Ogre::Vector3 bodypos;
+    Ogre::Quaternion bodyorient;
+    getPositionOrientation( bodypos, bodyorient );
 
-	Ogre::Vector3 topoint = pos - bodypos;
-	Ogre::Vector3 torque = topoint.crossProduct( force );
+    Ogre::Vector3 topoint = pos - bodypos;
+    Ogre::Vector3 torque = topoint.crossProduct( force );
 
-	addForce( force );
-	addTorque( torque );
+    addForce( force );
+    addTorque( torque );
 }
 
 void Body::addLocalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos )
 {
-	Ogre::Vector3 bodypos;
-	Ogre::Quaternion bodyorient;
+    Ogre::Vector3 bodypos;
+    Ogre::Quaternion bodyorient;
 
-	getPositionOrientation( bodypos, bodyorient );
+    getPositionOrientation( bodypos, bodyorient );
 
-	Ogre::Vector3 globalforce = bodyorient * force;
-	Ogre::Vector3 globalpoint = (bodyorient * pos) + bodypos;
+    Ogre::Vector3 globalforce = bodyorient * force;
+    Ogre::Vector3 globalpoint = (bodyorient * pos) + bodypos;
 
-	addGlobalForce( globalforce, globalpoint );
+    addGlobalForce( globalforce, globalpoint );
 }
 
 Body* Body::getNext() const

Modified: dependencies/OgreNewt/src/OgreNewt_Collision.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Collision.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_Collision.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -5,42 +5,42 @@
 namespace OgreNewt
 {
 
-	
+    
 Collision::Collision( const World* world ) : m_col(NULL)
 {
-	m_world = world;
+    m_world = world;
 }
 
 Collision::~Collision()
 {
-	if (m_world-&gt;getNewtonWorld())
-		NewtonReleaseCollision( m_world-&gt;getNewtonWorld(), m_col );
+    if (m_world-&gt;getNewtonWorld())
+        NewtonReleaseCollision( m_world-&gt;getNewtonWorld(), m_col );
 }
 
 
 Ogre::AxisAlignedBox Collision::getAABB( const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) const
 {
-	Ogre::AxisAlignedBox box;
-	Ogre::Vector3 min, max;
-	float matrix[16];
-	OgreNewt::Converters::QuatPosToMatrix( orient, pos, matrix );
+    Ogre::AxisAlignedBox box;
+    Ogre::Vector3 min, max;
+    float matrix[16];
+    OgreNewt::Converters::QuatPosToMatrix( orient, pos, matrix );
 
     if( m_col )
     {
-    	NewtonCollisionCalculateAABB( m_col, matrix, &amp;min.x, &amp;max.x );
+        NewtonCollisionCalculateAABB( m_col, matrix, &amp;min.x, &amp;max.x );
 
-	    box = Ogre::AxisAlignedBox(min, max);
+        box = Ogre::AxisAlignedBox(min, max);
     }
-	return box;
+    return box;
 }
 
 CollisionPrimitive Collision::getCollisionPrimitiveType(const NewtonCollision *col)
 {
-	NewtonCollisionInfoRecord *info = new NewtonCollisionInfoRecord();
+    NewtonCollisionInfoRecord *info = new NewtonCollisionInfoRecord();
 
-	NewtonCollisionGetInfo( col, info );
+    NewtonCollisionGetInfo( col, info );
 
-	return static_cast&lt;CollisionPrimitive&gt;(info-&gt;m_collisionType);
+    return static_cast&lt;CollisionPrimitive&gt;(info-&gt;m_collisionType);
 }
 
 
@@ -57,7 +57,7 @@
 
 ConvexModifierCollision::ConvexModifierCollision(const World* world, const Collision* col) : Collision(world)
 {
-	m_col = NewtonCreateConvexHullModifier( world-&gt;getNewtonWorld(), col-&gt;getNewtonCollision() );
+    m_col = NewtonCreateConvexHullModifier( world-&gt;getNewtonWorld(), col-&gt;getNewtonCollision() );
 }
 
 ConvexModifierCollision::~ConvexModifierCollision()
@@ -66,29 +66,29 @@
 
 void ConvexModifierCollision::setScalarMatrix( const Ogre::Matrix4&amp; mat ) const
 {
-	float matrix[16];
-	OgreNewt::Converters::Matrix4ToMatrix( mat, matrix );
+    float matrix[16];
+    OgreNewt::Converters::Matrix4ToMatrix( mat, matrix );
 
     if( m_col )
-    	NewtonConvexHullModifierSetMatrix( m_col, matrix );	
+        NewtonConvexHullModifierSetMatrix( m_col, matrix ); 
 }
 
 Ogre::Matrix4 ConvexModifierCollision::getScalarMatrix() const
 {
-	float matrix[16];
-	Ogre::Matrix4 mat;
-	
+    float matrix[16];
+    Ogre::Matrix4 mat;
+    
     if( m_col )
     {
-    	NewtonConvexHullModifierGetMatrix( m_col, matrix );
+        NewtonConvexHullModifierGetMatrix( m_col, matrix );
 
-    	OgreNewt::Converters::MatrixToMatrix4( matrix, mat );
+        OgreNewt::Converters::MatrixToMatrix4( matrix, mat );
     }
 
-	return mat;
+    return mat;
 }
 
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 

Modified: dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -2,775 +2,785 @@
 #include &quot;OgreNewt_Tools.h&quot;
 #include &quot;OgreNewt_RayCast.h&quot;
 
+#ifdef __APPLE__
+#   include &lt;Ogre/OgreEntity.h&gt;
+#   include &lt;Ogre/OgreSubMesh.h&gt;
+#   include &lt;Ogre/OgreSceneNode.h&gt;
+#else
+#   include &lt;OgreEntity.h&gt;
+#   include &lt;OgreSubMesh.h&gt;
+#   include &lt;OgreSceneNode.h&gt;
+#endif
+
 namespace OgreNewt
 {
 
-	namespace CollisionPrimitives
-	{
+    namespace CollisionPrimitives
+    {
 
-		// OgreNewt::CollisionPrimitives::Null
-		Null::Null(const OgreNewt::World *world) : Collision( world )
-		{
-			m_col = NewtonCreateNull( m_world-&gt;getNewtonWorld() );
-		}
+        // OgreNewt::CollisionPrimitives::Null
+        Null::Null(const OgreNewt::World *world) : Collision( world )
+        {
+            m_col = NewtonCreateNull( m_world-&gt;getNewtonWorld() );
+        }
 
 
-		// OgreNewt::CollisionPrimitives::Box
-		Box::Box(const World* world) : ConvexCollision( world )
-		{}
+        // OgreNewt::CollisionPrimitives::Box
+        Box::Box(const World* world) : ConvexCollision( world )
+        {}
 
-		Box::Box( const World* world, const Ogre::Vector3&amp; size, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
+        Box::Box( const World* world, const Ogre::Vector3&amp; size, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			m_col = NewtonCreateBox( m_world-&gt;getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &amp;matrix[0] );
-		}
+            m_col = NewtonCreateBox( m_world-&gt;getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &amp;matrix[0] );
+        }
 
 
 
-		// OgreNewt::CollisionPrimitives::Ellipsoid
-		Ellipsoid::Ellipsoid(const World* world) : ConvexCollision( world )
-		{}
+        // OgreNewt::CollisionPrimitives::Ellipsoid
+        Ellipsoid::Ellipsoid(const World* world) : ConvexCollision( world )
+        {}
 
-		Ellipsoid::Ellipsoid( const World* world, const Ogre::Vector3&amp; size, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
+        Ellipsoid::Ellipsoid( const World* world, const Ogre::Vector3&amp; size, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			m_col = NewtonCreateSphere( m_world-&gt;getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &amp;matrix[0] );
-		}
+            m_col = NewtonCreateSphere( m_world-&gt;getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &amp;matrix[0] );
+        }
 
 
-		// OgreNewt::CollisionPrimitives::Cylinder
-		Cylinder::Cylinder(const World* world) : ConvexCollision( world )
-		{}
+        // OgreNewt::CollisionPrimitives::Cylinder
+        Cylinder::Cylinder(const World* world) : ConvexCollision( world )
+        {}
 
-		Cylinder::Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
-									const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
+        Cylinder::Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+                                    const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			m_col = NewtonCreateCylinder( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
-		}
+            m_col = NewtonCreateCylinder( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
+        }
 
 
-		// OgreNewt::CollisionPrimitives::Capsule
-		Capsule::Capsule(const World* world) : ConvexCollision( world )
-		{}
+        // OgreNewt::CollisionPrimitives::Capsule
+        Capsule::Capsule(const World* world) : ConvexCollision( world )
+        {}
 
-		Capsule::Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
-									const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
+        Capsule::Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
+                                    const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			m_col = NewtonCreateCapsule( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
-		}
+            m_col = NewtonCreateCapsule( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
+        }
 
 
-		// OgreNewt::CollisionPrimitives::Cone
-		Cone::Cone(const World* world) : ConvexCollision( world )
-		{}
+        // OgreNewt::CollisionPrimitives::Cone
+        Cone::Cone(const World* world) : ConvexCollision( world )
+        {}
 
-		Cone::Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
-									const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
+        Cone::Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
+                                    const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			m_col = NewtonCreateCone( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
-		}
+            m_col = NewtonCreateCone( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
+        }
 
-		// OgreNewt::CollisionPrimitives::ChamferCylinder
-		ChamferCylinder::ChamferCylinder(const World* world) : ConvexCollision( world )
-		{}
+        // OgreNewt::CollisionPrimitives::ChamferCylinder
+        ChamferCylinder::ChamferCylinder(const World* world) : ConvexCollision( world )
+        {}
 
-		ChamferCylinder::ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
-									const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
+        ChamferCylinder::ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+                                    const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			m_col = NewtonCreateChamferCylinder( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
-		}
+            m_col = NewtonCreateChamferCylinder( m_world-&gt;getNewtonWorld(), (float)radius, (float)height, &amp;matrix[0] );
+        }
 
 
-		
-		// OgreNewt::CollisionPrimitives::ConvexHull
-		ConvexHull::ConvexHull(const World* world) : ConvexCollision( world )
-		{}
+        
+        // OgreNewt::CollisionPrimitives::ConvexHull
+        ConvexHull::ConvexHull(const World* world) : ConvexCollision( world )
+        {}
 
-		ConvexHull::ConvexHull( const World* world, Ogre::Entity* obj, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			Ogre::Vector3 scale(1.0,1.0,1.0);
-			
+        ConvexHull::ConvexHull( const World* world, Ogre::Entity* obj, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            Ogre::Vector3 scale(1.0,1.0,1.0);
+            
 
-			//get the mesh!
-			//Ogre::Entity* obj = (Ogre::Entity*)node-&gt;getAttachedObject(0);
-			Ogre::MeshPtr mesh = obj-&gt;getMesh();
+            //get the mesh!
+            //Ogre::Entity* obj = (Ogre::Entity*)node-&gt;getAttachedObject(0);
+            Ogre::MeshPtr mesh = obj-&gt;getMesh();
 
                         // get scale, if attached to node
                         Ogre::Node * node = obj-&gt;getParentNode();
                         if (node) scale = node-&gt;getScale();
 
-			//find number of submeshes
-			unsigned short sub = mesh-&gt;getNumSubMeshes();
+            //find number of submeshes
+            unsigned short sub = mesh-&gt;getNumSubMeshes();
 
-			size_t total_verts = 0;
+            size_t total_verts = 0;
 
-			Ogre::VertexData* v_data;
-			bool addedShared = false;
+            Ogre::VertexData* v_data;
+            bool addedShared = false;
 
-			for (unsigned short i=0;i&lt;sub;i++)
-			{
-				Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(i);
-				if (sub_mesh-&gt;useSharedVertices)
-				{
-					if (!addedShared)
-					{
-						v_data = mesh-&gt;sharedVertexData;
-						total_verts += v_data-&gt;vertexCount;
+            for (unsigned short i=0;i&lt;sub;i++)
+            {
+                Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(i);
+                if (sub_mesh-&gt;useSharedVertices)
+                {
+                    if (!addedShared)
+                    {
+                        v_data = mesh-&gt;sharedVertexData;
+                        total_verts += v_data-&gt;vertexCount;
 
-						addedShared = true;
-					}
-				}
-				else
-				{
-					v_data = sub_mesh-&gt;vertexData;
-					total_verts += v_data-&gt;vertexCount;
-				}
-			}
-		
-			addedShared = false;
+                        addedShared = true;
+                    }
+                }
+                else
+                {
+                    v_data = sub_mesh-&gt;vertexData;
+                    total_verts += v_data-&gt;vertexCount;
+                }
+            }
+        
+            addedShared = false;
 
-			//make array to hold vertex positions!
-			Ogre::Vector3* vertices = new Ogre::Vector3[total_verts];
-			unsigned int offset = 0;
+            //make array to hold vertex positions!
+            Ogre::Vector3* vertices = new Ogre::Vector3[total_verts];
+            unsigned int offset = 0;
 
-			//loop back through, adding vertices as we go!
-			for (unsigned short i=0;i&lt;sub;i++)
-			{
-				Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(i);
-				Ogre::VertexDeclaration* v_decl;
-				const Ogre::VertexElement* p_elem;
-				float* v_Posptr;
-				size_t v_count;
-		
-				v_data = NULL;
+            //loop back through, adding vertices as we go!
+            for (unsigned short i=0;i&lt;sub;i++)
+            {
+                Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(i);
+                Ogre::VertexDeclaration* v_decl;
+                const Ogre::VertexElement* p_elem;
+                float* v_Posptr;
+                size_t v_count;
+        
+                v_data = NULL;
 
-				if (sub_mesh-&gt;useSharedVertices)
-				{
-					if (!addedShared)
-					{
-						v_data = mesh-&gt;sharedVertexData;
-						v_count = v_data-&gt;vertexCount;
-						v_decl = v_data-&gt;vertexDeclaration;
-						p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
-						addedShared = true;
-					}
-				}
-				else
-				{
-					v_data = sub_mesh-&gt;vertexData;
-					v_count = v_data-&gt;vertexCount;
-					v_decl = v_data-&gt;vertexDeclaration;
-					p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
-				}
+                if (sub_mesh-&gt;useSharedVertices)
+                {
+                    if (!addedShared)
+                    {
+                        v_data = mesh-&gt;sharedVertexData;
+                        v_count = v_data-&gt;vertexCount;
+                        v_decl = v_data-&gt;vertexDeclaration;
+                        p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
+                        addedShared = true;
+                    }
+                }
+                else
+                {
+                    v_data = sub_mesh-&gt;vertexData;
+                    v_count = v_data-&gt;vertexCount;
+                    v_decl = v_data-&gt;vertexDeclaration;
+                    p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
+                }
 
-				if (v_data)
-				{
-					size_t start = v_data-&gt;vertexStart;
-					//pointer
-					Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
-					unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
-					unsigned char* v_offset;
+                if (v_data)
+                {
+                    size_t start = v_data-&gt;vertexStart;
+                    //pointer
+                    Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
+                    unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+                    unsigned char* v_offset;
 
-					//loop through vertex data...
-					for (size_t j=start; j&lt;(start+v_count); j++)
-					{
-						//get offset to Position data!
-						v_offset = v_ptr + (j * v_sptr-&gt;getVertexSize());
-						p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+                    //loop through vertex data...
+                    for (size_t j=start; j&lt;(start+v_count); j++)
+                    {
+                        //get offset to Position data!
+                        v_offset = v_ptr + (j * v_sptr-&gt;getVertexSize());
+                        p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
 
-						//now get vertex positions...
-						vertices[offset].x = *v_Posptr; v_Posptr++;
-						vertices[offset].y = *v_Posptr; v_Posptr++;
-						vertices[offset].z = *v_Posptr; v_Posptr++;
+                        //now get vertex positions...
+                        vertices[offset].x = *v_Posptr; v_Posptr++;
+                        vertices[offset].y = *v_Posptr; v_Posptr++;
+                        vertices[offset].z = *v_Posptr; v_Posptr++;
 
-						vertices[offset] *= scale;
+                        vertices[offset] *= scale;
 
-						offset++;
-					}
+                        offset++;
+                    }
 
-					//unlock buffer
-					v_sptr-&gt;unlock();
-				}
+                    //unlock buffer
+                    v_sptr-&gt;unlock();
+                }
 
-		
-			}
+        
+            }
 
-			float matrix[16];
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
-	
-			//okay, let's try making the ConvexHull!
-			m_col = NewtonCreateConvexHull( m_world-&gt;getNewtonWorld(), (int)total_verts, (float*)&amp;vertices[0].x, sizeof(Ogre::Vector3), 0.001f, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+    
+            //okay, let's try making the ConvexHull!
+            m_col = NewtonCreateConvexHull( m_world-&gt;getNewtonWorld(), (int)total_verts, (float*)&amp;vertices[0].x, sizeof(Ogre::Vector3), 0.001f, &amp;matrix[0] );
 
-			delete []vertices;
+            delete []vertices;
 
-		}
+        }
 
 
-		// OgreNewt::CollisionPrimitives::ConvexHull
-		ConvexHull::ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+        // OgreNewt::CollisionPrimitives::ConvexHull
+        ConvexHull::ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			//make the collision primitive.
-			m_col = NewtonCreateConvexHull( m_world-&gt;getNewtonWorld(), vertcount, (float*)&amp;verts[0].x, sizeof(Ogre::Vector3), 0.001f, &amp;matrix[0]);
-		}
+            //make the collision primitive.
+            m_col = NewtonCreateConvexHull( m_world-&gt;getNewtonWorld(), vertcount, (float*)&amp;verts[0].x, sizeof(Ogre::Vector3), 0.001f, &amp;matrix[0]);
+        }
 
 
 
 
-		TreeCollision::TreeCollision( const World* world) : Collision(world)
-		{
-		}
+        TreeCollision::TreeCollision( const World* world) : Collision(world)
+        {
+        }
 
 
-		TreeCollision::TreeCollision( const World* world, Ogre::Entity* obj, bool optimize, FaceWinding fw ) : Collision( world )
-		{
-			Ogre::Vector3 scale;
+        TreeCollision::TreeCollision( const World* world, Ogre::Entity* obj, bool optimize, FaceWinding fw ) : Collision( world )
+        {
+            Ogre::Vector3 scale;
 
-			start();
+            start();
 
-			Ogre::MeshPtr mesh = obj-&gt;getMesh();
+            Ogre::MeshPtr mesh = obj-&gt;getMesh();
 
                         // get scale, if attached to node
                         Ogre::Node * node = obj-&gt;getParentNode();
                         if (node) scale = node-&gt;getScale();
 
-			//find number of sub-meshes
-			unsigned short sub = mesh-&gt;getNumSubMeshes();
+            //find number of sub-meshes
+            unsigned short sub = mesh-&gt;getNumSubMeshes();
 
-			for (unsigned short cs=0;cs&lt;sub;cs++)
-			{
-				Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(cs);
+            for (unsigned short cs=0;cs&lt;sub;cs++)
+            {
+                Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(cs);
 
-				//vertex data!
-				Ogre::VertexData* v_data;
+                //vertex data!
+                Ogre::VertexData* v_data;
 
-				if (sub_mesh-&gt;useSharedVertices)
-				{
-					v_data = mesh-&gt;sharedVertexData;
-				}
-				else
-				{
-					v_data = sub_mesh-&gt;vertexData;
-				}
-		
-				//let's find more information about the Vertices...
-				Ogre::VertexDeclaration* v_decl = v_data-&gt;vertexDeclaration;
-				const Ogre::VertexElement* p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
-		
-				// get pointer!
-				Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
-				unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
-		
-				//now find more about the index!!
-				Ogre::IndexData* i_data = sub_mesh-&gt;indexData;
-				size_t index_count = i_data-&gt;indexCount;
-				size_t poly_count = index_count / 3;
-		
-				// get pointer!
-				Ogre::HardwareIndexBufferSharedPtr i_sptr = i_data-&gt;indexBuffer;
-		
-				// 16 or 32 bit indices?
-				bool uses32bit = ( i_sptr-&gt;getType() == Ogre::HardwareIndexBuffer::IT_32BIT );
-				unsigned long* i_Longptr;
-				unsigned short* i_Shortptr;
-		
-		
-				if ( uses32bit)
-				{
-					i_Longptr = static_cast&lt;unsigned long*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
-					
-				}
-				else
-				{
-					i_Shortptr = static_cast&lt;unsigned short*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
-				}
+                if (sub_mesh-&gt;useSharedVertices)
+                {
+                    v_data = mesh-&gt;sharedVertexData;
+                }
+                else
+                {
+                    v_data = sub_mesh-&gt;vertexData;
+                }
+        
+                //let's find more information about the Vertices...
+                Ogre::VertexDeclaration* v_decl = v_data-&gt;vertexDeclaration;
+                const Ogre::VertexElement* p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
+        
+                // get pointer!
+                Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
+                unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+        
+                //now find more about the index!!
+                Ogre::IndexData* i_data = sub_mesh-&gt;indexData;
+                size_t index_count = i_data-&gt;indexCount;
+                size_t poly_count = index_count / 3;
+        
+                // get pointer!
+                Ogre::HardwareIndexBufferSharedPtr i_sptr = i_data-&gt;indexBuffer;
+        
+                // 16 or 32 bit indices?
+                bool uses32bit = ( i_sptr-&gt;getType() == Ogre::HardwareIndexBuffer::IT_32BIT );
+                unsigned long* i_Longptr;
+                unsigned short* i_Shortptr;
+        
+        
+                if ( uses32bit)
+                {
+                    i_Longptr = static_cast&lt;unsigned long*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+                    
+                }
+                else
+                {
+                    i_Shortptr = static_cast&lt;unsigned short*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+                }
 
 
-				//now loop through the indices, getting polygon info!
-				int i_offset = 0;
+                //now loop through the indices, getting polygon info!
+                int i_offset = 0;
 
-				for (size_t i=0; i&lt;poly_count; i++)
-				{
-					Ogre::Vector3 poly_verts[3];
-					unsigned char* v_offset;
-					float* v_Posptr;
-					int idx;
+                for (size_t i=0; i&lt;poly_count; i++)
+                {
+                    Ogre::Vector3 poly_verts[3];
+                    unsigned char* v_offset;
+                    float* v_Posptr;
+                    int idx;
 
-					if (uses32bit)
-					{
-						for (int j=0;j&lt;3;j++)
-						{
-							idx = i_Longptr[i_offset+j];		// index to first vertex!
-							v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
-							p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
-							//now get vertex position from v_Posptr!
-							poly_verts[j].x = *v_Posptr; v_Posptr++;
-							poly_verts[j].y = *v_Posptr; v_Posptr++;
-							poly_verts[j].z = *v_Posptr; v_Posptr++;
+                    if (uses32bit)
+                    {
+                        for (int j=0;j&lt;3;j++)
+                        {
+                            idx = i_Longptr[i_offset+j];        // index to first vertex!
+                            v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
+                            p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+                            //now get vertex position from v_Posptr!
+                            poly_verts[j].x = *v_Posptr; v_Posptr++;
+                            poly_verts[j].y = *v_Posptr; v_Posptr++;
+                            poly_verts[j].z = *v_Posptr; v_Posptr++;
 
-							poly_verts[j] *= scale;
-						}
-					}
-					else
-					{
-						for (int j=0;j&lt;3;j++)
-						{
-							idx = i_Shortptr[i_offset+j];		// index to first vertex!
-							v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
-							p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
-							//now get vertex position from v_Posptr!
+                            poly_verts[j] *= scale;
+                        }
+                    }
+                    else
+                    {
+                        for (int j=0;j&lt;3;j++)
+                        {
+                            idx = i_Shortptr[i_offset+j];       // index to first vertex!
+                            v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
+                            p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+                            //now get vertex position from v_Posptr!
 
-							// switch poly winding.
-							poly_verts[j].x = *v_Posptr; v_Posptr++;
-							poly_verts[j].y = *v_Posptr; v_Posptr++;
-							poly_verts[j].z = *v_Posptr; v_Posptr++;
-							
-							poly_verts[j] *= scale;
-						}
-					}
-					
-					if (fw == FW_DEFAULT)
-					{
-						addPoly( poly_verts, cs );	
-					}
-					else
-					{
-						Ogre::Vector3 rev_poly_verts[3];
-						rev_poly_verts[0] = poly_verts[0];
-						rev_poly_verts[0] = poly_verts[2];
-						rev_poly_verts[0] = poly_verts[1];
+                            // switch poly winding.
+                            poly_verts[j].x = *v_Posptr; v_Posptr++;
+                            poly_verts[j].y = *v_Posptr; v_Posptr++;
+                            poly_verts[j].z = *v_Posptr; v_Posptr++;
+                            
+                            poly_verts[j] *= scale;
+                        }
+                    }
+                    
+                    if (fw == FW_DEFAULT)
+                    {
+                        addPoly( poly_verts, cs );  
+                    }
+                    else
+                    {
+                        Ogre::Vector3 rev_poly_verts[3];
+                        rev_poly_verts[0] = poly_verts[0];
+                        rev_poly_verts[0] = poly_verts[2];
+                        rev_poly_verts[0] = poly_verts[1];
 
-						addPoly( rev_poly_verts, cs );
-					}
+                        addPoly( rev_poly_verts, cs );
+                    }
 
-					i_offset += 3;
-				}
+                    i_offset += 3;
+                }
 
-				//unlock the buffers!
-				v_sptr-&gt;unlock();
-				i_sptr-&gt;unlock();
-	
-			}
-			//done!
-			finish( optimize );
-		}
+                //unlock the buffers!
+                v_sptr-&gt;unlock();
+                i_sptr-&gt;unlock();
+    
+            }
+            //done!
+            finish( optimize );
+        }
 
 
-		TreeCollision::TreeCollision(const OgreNewt::World *world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, FaceWinding fw) : OgreNewt::Collision( world )
-		{
-			start();
+        TreeCollision::TreeCollision(const OgreNewt::World *world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, FaceWinding fw) : OgreNewt::Collision( world )
+        {
+            start();
  
-			int numPolys = numIndices / 3;
+            int numPolys = numIndices / 3;
  
-			Ogre::Vector3 *vecVertices = new Ogre::Vector3[numVertices];
+            Ogre::Vector3 *vecVertices = new Ogre::Vector3[numVertices];
  
-			for (int curVertex = 0; curVertex &lt; numVertices; curVertex++)
-			{
-	            vecVertices[curVertex].x = vertices[0 + curVertex * 3];
-				vecVertices[curVertex].y = vertices[1 + curVertex * 3];
-				vecVertices[curVertex].z = vertices[2 + curVertex * 3];
-			}
+            for (int curVertex = 0; curVertex &lt; numVertices; curVertex++)
+            {
+                vecVertices[curVertex].x = vertices[0 + curVertex * 3];
+                vecVertices[curVertex].y = vertices[1 + curVertex * 3];
+                vecVertices[curVertex].z = vertices[2 + curVertex * 3];
+            }
  
-			for ( int poly = 0; poly &lt; numPolys; poly++ )
-			{
-				Ogre::Vector3 poly_verts[3];
+            for ( int poly = 0; poly &lt; numPolys; poly++ )
+            {
+                Ogre::Vector3 poly_verts[3];
  
-				if (fw == FW_DEFAULT)
-				{
-					poly_verts[0] = vecVertices[indices[0 + poly * 3]];
-					poly_verts[1] = vecVertices[indices[1 + poly * 3]];
-					poly_verts[2] = vecVertices[indices[2 + poly * 3]];
-				}
-				else
-				{
-					poly_verts[0] = vecVertices[indices[0 + poly * 3]];
-					poly_verts[2] = vecVertices[indices[1 + poly * 3]];
-					poly_verts[1] = vecVertices[indices[2 + poly * 3]];
-				}
+                if (fw == FW_DEFAULT)
+                {
+                    poly_verts[0] = vecVertices[indices[0 + poly * 3]];
+                    poly_verts[1] = vecVertices[indices[1 + poly * 3]];
+                    poly_verts[2] = vecVertices[indices[2 + poly * 3]];
+                }
+                else
+                {
+                    poly_verts[0] = vecVertices[indices[0 + poly * 3]];
+                    poly_verts[2] = vecVertices[indices[1 + poly * 3]];
+                    poly_verts[1] = vecVertices[indices[2 + poly * 3]];
+                }
  
-				addPoly( poly_verts, 0 );
-			}
+                addPoly( poly_verts, 0 );
+            }
  
-			delete [] vecVertices;
-	 
-		     finish( optimize );
-		}
+            delete [] vecVertices;
+     
+             finish( optimize );
+        }
 
 
-		TreeCollision::TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, FaceWinding fw) : Collision( world )
-		{
-			start();
+        TreeCollision::TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, FaceWinding fw) : Collision( world )
+        {
+            start();
 
-			unsigned int numPolys = indexData-&gt;indexCount / 3;
-			Ogre::HardwareIndexBufferSharedPtr hwIndexBuffer=indexData-&gt;indexBuffer;
-			size_t indexSize=hwIndexBuffer-&gt;getIndexSize();
-			void* indices=hwIndexBuffer-&gt;lock(Ogre::HardwareBuffer::HBL_READ_ONLY);
+            unsigned int numPolys = indexData-&gt;indexCount / 3;
+            Ogre::HardwareIndexBufferSharedPtr hwIndexBuffer=indexData-&gt;indexBuffer;
+            size_t indexSize=hwIndexBuffer-&gt;getIndexSize();
+            void* indices=hwIndexBuffer-&gt;lock(Ogre::HardwareBuffer::HBL_READ_ONLY);
 
-			assert((indexSize==2) || (indexSize==4));
+            assert((indexSize==2) || (indexSize==4));
 
-			if (indexSize==2)
-			{
-				unsigned short* curIndex=(unsigned short*)indices;
-				for ( unsigned int poly = 0; poly &lt; numPolys; poly++ )
-				{
-					Ogre::Vector3 poly_verts[3];
+            if (indexSize==2)
+            {
+                unsigned short* curIndex=(unsigned short*)indices;
+                for ( unsigned int poly = 0; poly &lt; numPolys; poly++ )
+                {
+                    Ogre::Vector3 poly_verts[3];
 
-					//invert vertex winding (otherwise, raycasting won't work???)
-					if (fw == FW_DEFAULT)
-					{
-						poly_verts[0] = vertices[*curIndex]; curIndex++;
-						poly_verts[1] = vertices[*curIndex]; curIndex++;
-						poly_verts[2] = vertices[*curIndex]; curIndex++;
-					}
-					else
-					{
-						poly_verts[0] = vertices[*curIndex]; curIndex++;
-						poly_verts[2] = vertices[*curIndex]; curIndex++;
-						poly_verts[1] = vertices[*curIndex]; curIndex++;
-					}
+                    //invert vertex winding (otherwise, raycasting won't work???)
+                    if (fw == FW_DEFAULT)
+                    {
+                        poly_verts[0] = vertices[*curIndex]; curIndex++;
+                        poly_verts[1] = vertices[*curIndex]; curIndex++;
+                        poly_verts[2] = vertices[*curIndex]; curIndex++;
+                    }
+                    else
+                    {
+                        poly_verts[0] = vertices[*curIndex]; curIndex++;
+                        poly_verts[2] = vertices[*curIndex]; curIndex++;
+                        poly_verts[1] = vertices[*curIndex]; curIndex++;
+                    }
 
-					addPoly( poly_verts, 0 );
-				}
-			}
-			else
-			{
-				unsigned int* curIndex=(unsigned int*)indices;
-				for ( unsigned int poly = 0; poly &lt; numPolys; poly++ )
-				{
-					Ogre::Vector3 poly_verts[3];
+                    addPoly( poly_verts, 0 );
+                }
+            }
+            else
+            {
+                unsigned int* curIndex=(unsigned int*)indices;
+                for ( unsigned int poly = 0; poly &lt; numPolys; poly++ )
+                {
+                    Ogre::Vector3 poly_verts[3];
 
-					if (fw == FW_DEFAULT)
-					{
-						poly_verts[0] = vertices[*curIndex]; curIndex++;
-						poly_verts[1] = vertices[*curIndex]; curIndex++;
-						poly_verts[2] = vertices[*curIndex]; curIndex++;
-					}
-					else
-					{
-						poly_verts[0] = vertices[*curIndex]; curIndex++;
-						poly_verts[2] = vertices[*curIndex]; curIndex++;
-						poly_verts[1] = vertices[*curIndex]; curIndex++;
-					}
+                    if (fw == FW_DEFAULT)
+                    {
+                        poly_verts[0] = vertices[*curIndex]; curIndex++;
+                        poly_verts[1] = vertices[*curIndex]; curIndex++;
+                        poly_verts[2] = vertices[*curIndex]; curIndex++;
+                    }
+                    else
+                    {
+                        poly_verts[0] = vertices[*curIndex]; curIndex++;
+                        poly_verts[2] = vertices[*curIndex]; curIndex++;
+                        poly_verts[1] = vertices[*curIndex]; curIndex++;
+                    }
 
-					addPoly( poly_verts, 0 );
-				}
-			}
+                    addPoly( poly_verts, 0 );
+                }
+            }
       
-			hwIndexBuffer-&gt;unlock();
-			finish( optimize );
-		} 
+            hwIndexBuffer-&gt;unlock();
+            finish( optimize );
+        } 
 
 
-		void TreeCollision::start()
-		{
-			m_col = NewtonCreateTreeCollision( m_world-&gt;getNewtonWorld() );
-			NewtonTreeCollisionBeginBuild( m_col );
-		}
+        void TreeCollision::start()
+        {
+            m_col = NewtonCreateTreeCollision( m_world-&gt;getNewtonWorld() );
+            NewtonTreeCollisionBeginBuild( m_col );
+        }
 
-		void TreeCollision::addPoly( Ogre::Vector3* polys, unsigned int ID )
-		{
-			NewtonTreeCollisionAddFace( m_col, 3, (float*)&amp;polys[0].x, sizeof(Ogre::Vector3), ID );
-		}
+        void TreeCollision::addPoly( Ogre::Vector3* polys, unsigned int ID )
+        {
+            NewtonTreeCollisionAddFace( m_col, 3, (float*)&amp;polys[0].x, sizeof(Ogre::Vector3), ID );
+        }
 
-		void TreeCollision::finish( bool optimize )
-		{
-			NewtonTreeCollisionEndBuild( m_col, optimize );
+        void TreeCollision::finish( bool optimize )
+        {
+            NewtonTreeCollisionEndBuild( m_col, optimize );
         }
 
 
         float _CDECL TreeCollision::newtonRayCastCallback(float interception, float *normal, int faceId, void *userData)
         {
-			Body* bod = ((Raycast*)userData)-&gt;m_treecollisioncallback_lastbody;
-			
+            Body* bod = ((Raycast*)userData)-&gt;m_treecollisioncallback_lastbody;
+            
             //! TODO: what do we need to return here?
-			if(!bod)
-				return 0;
+            if(!bod)
+                return 0;
 
-			((Raycast*)userData)-&gt;userCallback( bod, interception, Ogre::Vector3(normal[0], normal[1], normal[2]), faceId );
+            ((Raycast*)userData)-&gt;userCallback( bod, interception, Ogre::Vector3(normal[0], normal[1], normal[2]), faceId );
 
-			((Raycast*)userData)-&gt;m_treecollisioncallback_bodyalreadyadded = true;
+            ((Raycast*)userData)-&gt;m_treecollisioncallback_bodyalreadyadded = true;
 
-			return interception;
+            return interception;
         }
 
-		void TreeCollision::setRayCastCallbackactive(bool active, const NewtonCollision *col )
-		{
-			if(active)
-				NewtonTreeCollisionSetUserRayCastCallback( col, newtonRayCastCallback );
-			else
-				NewtonTreeCollisionSetUserRayCastCallback( col, NULL );
-		}
+        void TreeCollision::setRayCastCallbackactive(bool active, const NewtonCollision *col )
+        {
+            if(active)
+                NewtonTreeCollisionSetUserRayCastCallback( col, newtonRayCastCallback );
+            else
+                NewtonTreeCollisionSetUserRayCastCallback( col, NULL );
+        }
 
-		int TreeCollisionSceneParser::count = 0;
-		
-		
-		TreeCollisionSceneParser::TreeCollisionSceneParser( OgreNewt::World* world ) : TreeCollision( world )
-		{
-		}
-		
-		void TreeCollisionSceneParser::parseScene( Ogre::SceneNode *startNode, bool optimize, FaceWinding fw)
-		{
-			count = 0;
+        int TreeCollisionSceneParser::count = 0;
+        
+        
+        TreeCollisionSceneParser::TreeCollisionSceneParser( OgreNewt::World* world ) : TreeCollision( world )
+        {
+        }
+        
+        void TreeCollisionSceneParser::parseScene( Ogre::SceneNode *startNode, bool optimize, FaceWinding fw)
+        {
+            count = 0;
 
-			start();
+            start();
 
-			// parse the individual nodes.
-			Ogre::Quaternion rootOrient = Ogre::Quaternion::IDENTITY;
-			Ogre::Vector3 rootPos = Ogre::Vector3::ZERO;
-			Ogre::Vector3 rootScale = Ogre::Vector3::UNIT_SCALE;
+            // parse the individual nodes.
+            Ogre::Quaternion rootOrient = Ogre::Quaternion::IDENTITY;
+            Ogre::Vector3 rootPos = Ogre::Vector3::ZERO;
+            Ogre::Vector3 rootScale = Ogre::Vector3::UNIT_SCALE;
 
-			_parseNode( startNode, rootOrient, rootPos, rootScale, fw );
+            _parseNode( startNode, rootOrient, rootPos, rootScale, fw );
 
-			finish( optimize );
-		}
+            finish( optimize );
+        }
 
-		void TreeCollisionSceneParser::_parseNode(Ogre::SceneNode *node, const Ogre::Quaternion &amp;curOrient, const Ogre::Vector3 &amp;curPos, const Ogre::Vector3 &amp;curScale, FaceWinding fw)
-		{
-			// parse this scene node.
-			// do children first.
-			Ogre::Quaternion thisOrient = curOrient * node-&gt;getOrientation();
-			Ogre::Vector3 thisPos = curPos + (curOrient * (node-&gt;getPosition() * curScale));
-			Ogre::Vector3 thisScale = curScale * node-&gt;getScale();
+        void TreeCollisionSceneParser::_parseNode(Ogre::SceneNode *node, const Ogre::Quaternion &amp;curOrient, const Ogre::Vector3 &amp;curPos, const Ogre::Vector3 &amp;curScale, FaceWinding fw)
+        {
+            // parse this scene node.
+            // do children first.
+            Ogre::Quaternion thisOrient = curOrient * node-&gt;getOrientation();
+            Ogre::Vector3 thisPos = curPos + (curOrient * (node-&gt;getPosition() * curScale));
+            Ogre::Vector3 thisScale = curScale * node-&gt;getScale();
 
-			Ogre::SceneNode::ChildNodeIterator child_it = node-&gt;getChildIterator();
+            Ogre::SceneNode::ChildNodeIterator child_it = node-&gt;getChildIterator();
 
-			while (child_it.hasMoreElements())
-			{
-				_parseNode( (Ogre::SceneNode*)child_it.getNext(), thisOrient, thisPos, thisScale, fw );
-			}
+            while (child_it.hasMoreElements())
+            {
+                _parseNode( (Ogre::SceneNode*)child_it.getNext(), thisOrient, thisPos, thisScale, fw );
+            }
 
 
-			// now add the polys from this node.
-			//now get the mesh!
-			unsigned int num_obj = node-&gt;numAttachedObjects();
-			for (unsigned int co=0; co&lt;num_obj; co++)
-			{
-				Ogre::MovableObject* obj = node-&gt;getAttachedObject(co);
-				if (obj-&gt;getMovableType() != &quot;Entity&quot;)
-					continue;
-			
-				Ogre::Entity* ent = (Ogre::Entity*)obj;
+            // now add the polys from this node.
+            //now get the mesh!
+            unsigned int num_obj = node-&gt;numAttachedObjects();
+            for (unsigned int co=0; co&lt;num_obj; co++)
+            {
+                Ogre::MovableObject* obj = node-&gt;getAttachedObject(co);
+                if (obj-&gt;getMovableType() != &quot;Entity&quot;)
+                    continue;
+            
+                Ogre::Entity* ent = (Ogre::Entity*)obj;
 
-				if (!entityFilter(node, ent, fw))
-					continue;
+                if (!entityFilter(node, ent, fw))
+                    continue;
 
-				Ogre::MeshPtr mesh = ent-&gt;getMesh();
+                Ogre::MeshPtr mesh = ent-&gt;getMesh();
 
-				//find number of sub-meshes
-				unsigned short sub = mesh-&gt;getNumSubMeshes();
+                //find number of sub-meshes
+                unsigned short sub = mesh-&gt;getNumSubMeshes();
 
-				for (unsigned short cs=0;cs&lt;sub;cs++)
-				{
-					Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(cs);
+                for (unsigned short cs=0;cs&lt;sub;cs++)
+                {
+                    Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(cs);
 
-					//vertex data!
-					Ogre::VertexData* v_data;
+                    //vertex data!
+                    Ogre::VertexData* v_data;
 
-					if (sub_mesh-&gt;useSharedVertices)
-					{	
-						v_data = mesh-&gt;sharedVertexData;
-					}
-					else
-					{
-						v_data = sub_mesh-&gt;vertexData;
-					}
-		
-					//let's find more information about the Vertices...
-					Ogre::VertexDeclaration* v_decl = v_data-&gt;vertexDeclaration;
-					const Ogre::VertexElement* p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
-		
-					// get pointer!
-					Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
-					unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
-		
-					//now find more about the index!!
-					Ogre::IndexData* i_data = sub_mesh-&gt;indexData;
-					size_t index_count = i_data-&gt;indexCount;
-					size_t poly_count = index_count / 3;
-		
-					// get pointer!
-					Ogre::HardwareIndexBufferSharedPtr i_sptr = i_data-&gt;indexBuffer;
-		
-					// 16 or 32 bit indices?
-					bool uses32bit = ( i_sptr-&gt;getType() == Ogre::HardwareIndexBuffer::IT_32BIT );
-					unsigned long* i_Longptr;
-					unsigned short* i_Shortptr;
-		
-					if ( uses32bit)
-					{
-						i_Longptr = static_cast&lt;unsigned long*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
-					}
-					else
-					{
-						i_Shortptr = static_cast&lt;unsigned short*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
-					}
+                    if (sub_mesh-&gt;useSharedVertices)
+                    {   
+                        v_data = mesh-&gt;sharedVertexData;
+                    }
+                    else
+                    {
+                        v_data = sub_mesh-&gt;vertexData;
+                    }
+        
+                    //let's find more information about the Vertices...
+                    Ogre::VertexDeclaration* v_decl = v_data-&gt;vertexDeclaration;
+                    const Ogre::VertexElement* p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
+        
+                    // get pointer!
+                    Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
+                    unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+        
+                    //now find more about the index!!
+                    Ogre::IndexData* i_data = sub_mesh-&gt;indexData;
+                    size_t index_count = i_data-&gt;indexCount;
+                    size_t poly_count = index_count / 3;
+        
+                    // get pointer!
+                    Ogre::HardwareIndexBufferSharedPtr i_sptr = i_data-&gt;indexBuffer;
+        
+                    // 16 or 32 bit indices?
+                    bool uses32bit = ( i_sptr-&gt;getType() == Ogre::HardwareIndexBuffer::IT_32BIT );
+                    unsigned long* i_Longptr;
+                    unsigned short* i_Shortptr;
+        
+                    if ( uses32bit)
+                    {
+                        i_Longptr = static_cast&lt;unsigned long*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+                    }
+                    else
+                    {
+                        i_Shortptr = static_cast&lt;unsigned short*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+                    }
 
-					//now loop through the indices, getting polygon info!
-					int i_offset = 0;
+                    //now loop through the indices, getting polygon info!
+                    int i_offset = 0;
 
-					for (size_t i=0; i&lt;poly_count; i++)
-					{
-						Ogre::Vector3 poly_verts[3];
-						unsigned char* v_offset;
-						float* v_Posptr;
-						int idx;
+                    for (size_t i=0; i&lt;poly_count; i++)
+                    {
+                        Ogre::Vector3 poly_verts[3];
+                        unsigned char* v_offset;
+                        float* v_Posptr;
+                        int idx;
 
-						if (uses32bit)
-						{
-							for (int j=0;j&lt;3;j++)
-							{
-								idx = i_Longptr[i_offset+j];		// index to first vertex!
-								v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
-								p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
-								//now get vertex position from v_Posptr!
-								poly_verts[j].x = *v_Posptr; v_Posptr++;
-								poly_verts[j].y = *v_Posptr; v_Posptr++;
-								poly_verts[j].z = *v_Posptr; v_Posptr++;
-	
-								poly_verts[j] = thisPos + (thisOrient * (poly_verts[j] * curScale));
-							}
-						}
-						else
-						{
-							for (int j=0;j&lt;3;j++)
-							{
-								idx = i_Shortptr[i_offset+j];		// index to first vertex!
-								v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
-								p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
-								//now get vertex position from v_Posptr!
+                        if (uses32bit)
+                        {
+                            for (int j=0;j&lt;3;j++)
+                            {
+                                idx = i_Longptr[i_offset+j];        // index to first vertex!
+                                v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
+                                p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+                                //now get vertex position from v_Posptr!
+                                poly_verts[j].x = *v_Posptr; v_Posptr++;
+                                poly_verts[j].y = *v_Posptr; v_Posptr++;
+                                poly_verts[j].z = *v_Posptr; v_Posptr++;
+    
+                                poly_verts[j] = thisPos + (thisOrient * (poly_verts[j] * curScale));
+                            }
+                        }
+                        else
+                        {
+                            for (int j=0;j&lt;3;j++)
+                            {
+                                idx = i_Shortptr[i_offset+j];       // index to first vertex!
+                                v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
+                                p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+                                //now get vertex position from v_Posptr!
 
-								// switch poly winding.
-								poly_verts[j].x = *v_Posptr; v_Posptr++;
-								poly_verts[j].y = *v_Posptr; v_Posptr++;
-								poly_verts[j].z = *v_Posptr; v_Posptr++;
-							
-								poly_verts[j] = thisPos + (thisOrient * (poly_verts[j] * curScale));
-							}
-						}
-					
-						if (fw == FW_DEFAULT)
-						{
-							addPoly( poly_verts, cs );	
-						}
-						else
-						{
-							Ogre::Vector3 rev_poly_verts[3];
-							rev_poly_verts[0] = poly_verts[0];
-							rev_poly_verts[0] = poly_verts[2];
-							rev_poly_verts[0] = poly_verts[1];
+                                // switch poly winding.
+                                poly_verts[j].x = *v_Posptr; v_Posptr++;
+                                poly_verts[j].y = *v_Posptr; v_Posptr++;
+                                poly_verts[j].z = *v_Posptr; v_Posptr++;
+                            
+                                poly_verts[j] = thisPos + (thisOrient * (poly_verts[j] * curScale));
+                            }
+                        }
+                    
+                        if (fw == FW_DEFAULT)
+                        {
+                            addPoly( poly_verts, cs );  
+                        }
+                        else
+                        {
+                            Ogre::Vector3 rev_poly_verts[3];
+                            rev_poly_verts[0] = poly_verts[0];
+                            rev_poly_verts[0] = poly_verts[2];
+                            rev_poly_verts[0] = poly_verts[1];
 
-							addPoly( rev_poly_verts, cs );
-						}
-						
-						i_offset += 3;
-					}
+                            addPoly( rev_poly_verts, cs );
+                        }
+                        
+                        i_offset += 3;
+                    }
 
-					//unlock the buffers!
-					v_sptr-&gt;unlock();
-					i_sptr-&gt;unlock();
+                    //unlock the buffers!
+                    v_sptr-&gt;unlock();
+                    i_sptr-&gt;unlock();
 
-				}
-			}
+                }
+            }
 
-		}
+        }
 
 
 
 
 
-		// OgreNewt::CollisionPrimitives::CompoundCollision
-		CompoundCollision::CompoundCollision(const World* world) : Collision( world )
-		{}
-		
-		CompoundCollision::CompoundCollision( const World* world, std::vector&lt;OgreNewt::Collision*&gt; col_array ) : Collision( world )
-		{
-			//get the number of elements.
-			unsigned int num = col_array.size();
+        // OgreNewt::CollisionPrimitives::CompoundCollision
+        CompoundCollision::CompoundCollision(const World* world) : Collision( world )
+        {}
+        
+        CompoundCollision::CompoundCollision( const World* world, std::vector&lt;OgreNewt::Collision*&gt; col_array ) : Collision( world )
+        {
+            //get the number of elements.
+            unsigned int num = col_array.size();
 
-			// create simple array.
-			NewtonCollision** array = new NewtonCollision*[num];
+            // create simple array.
+            NewtonCollision** array = new NewtonCollision*[num];
 
-			for (unsigned int i=0;i&lt;num;i++)
-			{
-				array[i] = (NewtonCollision*)col_array[i]-&gt;getNewtonCollision();
-			}
+            for (unsigned int i=0;i&lt;num;i++)
+            {
+                array[i] = (NewtonCollision*)col_array[i]-&gt;getNewtonCollision();
+            }
 
-			m_col = NewtonCreateCompoundCollision( world-&gt;getNewtonWorld(), num, array );
+            m_col = NewtonCreateCompoundCollision( world-&gt;getNewtonWorld(), num, array );
 
 
-			delete[] array;
-		}
+            delete[] array;
+        }
 
-		
-		// OgreNewt::CollisionPrimitives::Pyramid
-		Pyramid::Pyramid(const World* world) : ConvexCollision( world )
-		{}
+        
+        // OgreNewt::CollisionPrimitives::Pyramid
+        Pyramid::Pyramid(const World* world) : ConvexCollision( world )
+        {}
 
-		Pyramid::Pyramid( const World* world, const Ogre::Vector3&amp; size, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
-		{
-			float matrix[16];
+        Pyramid::Pyramid( const World* world, const Ogre::Vector3&amp; size, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
+        {
+            float matrix[16];
 
-			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
+            OgreNewt::Converters::QuatPosToMatrix( orient, pos, &amp;matrix[0] );
 
-			// create a simple pyramid collision primitive using the Newton Convex Hull interface.
-			// this function places the center of mass 1/3 up y from the base.
+            // create a simple pyramid collision primitive using the Newton Convex Hull interface.
+            // this function places the center of mass 1/3 up y from the base.
 
-			float* vertices = new float[15];
-			unsigned short idx = 0;
+            float* vertices = new float[15];
+            unsigned short idx = 0;
 
-			// make the bottom base.
-			for (int ix=-1; ix&lt;=1; ix+=2)
-			{
-				for (int iz=-1; iz&lt;=1; iz+=2)
-				{
-					vertices [idx++] = (size.x/2.0) * ix;
-					vertices [idx++] = -(size.y/3.0);
-					vertices [idx++] = (size.z/2.0) * iz;
-				}
-			}
+            // make the bottom base.
+            for (int ix=-1; ix&lt;=1; ix+=2)
+            {
+                for (int iz=-1; iz&lt;=1; iz+=2)
+                {
+                    vertices [idx++] = (size.x/2.0) * ix;
+                    vertices [idx++] = -(size.y/3.0);
+                    vertices [idx++] = (size.z/2.0) * iz;
+                }
+            }
 
-			// make the tip.
-			vertices [idx++] = 0.0f;
-			vertices [idx++] = (size.y*2.0/3.0);
-			vertices [idx++] = 0.0f;
+            // make the tip.
+            vertices [idx++] = 0.0f;
+            vertices [idx++] = (size.y*2.0/3.0);
+            vertices [idx++] = 0.0f;
 
-			//make the collision primitive.
-			m_col = NewtonCreateConvexHull( m_world-&gt;getNewtonWorld(), 5, vertices, sizeof(float)*3, 0.001f, &amp;matrix[0]);
+            //make the collision primitive.
+            m_col = NewtonCreateConvexHull( m_world-&gt;getNewtonWorld(), 5, vertices, sizeof(float)*3, 0.001f, &amp;matrix[0]);
 
 
-			delete []vertices;
-		}
+            delete []vertices;
+        }
 
 
 
-	}	// end namespace CollisionPrimitives
+    }   // end namespace CollisionPrimitives
 
-}	// end namespace OgreNewt
+}   // end namespace OgreNewt
 
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -60,6 +60,6 @@
     Ogre::DataStreamPtr ptr =* (static_cast&lt;Ogre::DataStreamPtr*&gt;(deserializeHandle));
     ptr-&gt;read(buffer, size);
   }
-}	// end namespace OgreNewt
+}   // end namespace OgreNewt
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_ContactJoint.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_ContactJoint.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_ContactJoint.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -58,9 +58,9 @@
 
 Ogre::Vector3 Contact::getForce() const 
 {
-	Ogre::Vector3 force;
-	NewtonMaterialGetContactForce( m_material, &amp;force.x );
-	return force;
+    Ogre::Vector3 force;
+    NewtonMaterialGetContactForce( m_material, &amp;force.x );
+    return force;
 }
 
 void Contact::remove()

Modified: dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -2,8 +2,19 @@
 #include &quot;OgreNewt_World.h&quot;
 #include &quot;OgreNewt_Body.h&quot;
 #include &quot;OgreNewt_Collision.h&quot;
+
 #include &lt;sstream&gt;
 
+#ifdef __APPLE__
+#   include &lt;Ogre/OgreSceneNode.h&gt;
+#   include &lt;Ogre/OgreSceneManager.h&gt;
+#   include &lt;Ogre/OgreManualObject.h&gt;
+#else
+#   include &lt;OgreSceneNode.h&gt;
+#   include &lt;OgreSceneManager.h&gt;
+#   include &lt;OgreManualObject.h&gt;
+#endif
+
 namespace OgreNewt
 {
 
@@ -47,13 +58,13 @@
 
 void Debugger::deInit()
 {
-	if (m_debugnode)
-	{
+    if (m_debugnode)
+    {
         m_debugnode-&gt;setListener(NULL);
-		m_debugnode-&gt;removeAllChildren();
-		m_debugnode-&gt;getParentSceneNode()-&gt;removeAndDestroyChild( m_debugnode-&gt;getName() );
-		m_debugnode = NULL;
-	}
+        m_debugnode-&gt;removeAllChildren();
+        m_debugnode-&gt;getParentSceneNode()-&gt;removeAndDestroyChild( m_debugnode-&gt;getName() );
+        m_debugnode = NULL;
+    }
 
 
     clearBodyDebugDataCache();
@@ -63,9 +74,9 @@
     if( m_raycastsnode )
     {
         m_raycastsnode-&gt;setListener(NULL);
-		m_raycastsnode-&gt;removeAndDestroyAllChildren();
-		m_raycastsnode-&gt;getParentSceneNode()-&gt;removeAndDestroyChild( m_raycastsnode-&gt;getName() );
-		m_raycastsnode = NULL;
+        m_raycastsnode-&gt;removeAndDestroyAllChildren();
+        m_raycastsnode-&gt;getParentSceneNode()-&gt;removeAndDestroyChild( m_raycastsnode-&gt;getName() );
+        m_raycastsnode = NULL;
     }
 }
 
@@ -132,9 +143,9 @@
 
 void Debugger::hideDebugInformation()
 {
-	// erase any existing lines!
+    // erase any existing lines!
     if( m_debugnode )
-    	m_debugnode-&gt;removeAllChildren();
+        m_debugnode-&gt;removeAllChildren();
 }
 
 void Debugger::setMaterialColor(const MaterialID* mat, Ogre::ColourValue col)
@@ -245,24 +256,24 @@
 void _CDECL Debugger::newtonPerPoly( void* userData, int vertexCount, const float* faceVertec, int id )
 {
     Ogre::ManualObject* lines = (Ogre::ManualObject*)userData;
-	Ogre::Vector3 p0, p1;
+    Ogre::Vector3 p0, p1;
 
         if( vertexCount &lt; 2 )
             return;
 
-	int i= vertexCount - 1;
-	p0 = Ogre::Vector3( faceVertec[(i*3) + 0], faceVertec[(i*3) + 1], faceVertec[(i*3) + 2] );
+    int i= vertexCount - 1;
+    p0 = Ogre::Vector3( faceVertec[(i*3) + 0], faceVertec[(i*3) + 1], faceVertec[(i*3) + 2] );
 
 
-	for (i=0;i&lt;vertexCount;i++)
-	{
-		p1 = Ogre::Vector3( faceVertec[(i*3) + 0], faceVertec[(i*3) + 1], faceVertec[(i*3) + 2] );
+    for (i=0;i&lt;vertexCount;i++)
+    {
+        p1 = Ogre::Vector3( faceVertec[(i*3) + 0], faceVertec[(i*3) + 1], faceVertec[(i*3) + 2] );
 
-		lines-&gt;position( p0 );
-		lines-&gt;position( p1 );
+        lines-&gt;position( p0 );
+        lines-&gt;position( p1 );
 
-		p0 = p1;
-	}
+        p0 = p1;
+    }
 }
 
 
@@ -428,5 +439,5 @@
     m_raycastsnode-&gt;attachObject(line);
 }
 
-}	// end namespace OgreNewt
+}   // end namespace OgreNewt
 

Modified: dependencies/OgreNewt/src/OgreNewt_Joint.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Joint.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_Joint.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -1,4 +1,3 @@
-/*  #include &lt;assert.h&gt;  why do we need this here? */
 #include &quot;OgreNewt_Joint.h&quot;
 #include &quot;OgreNewt_Body.h&quot;
 #include &quot;OgreNewt_World.h&quot;
@@ -7,37 +6,37 @@
 namespace OgreNewt
 {
 
-	
+    
 Joint::Joint()
 {
-	// nothing here
+    // nothing here
 }
 
 Joint::~Joint()
 {
 
-	if(m_joint)
-	{
-		if (NewtonJointGetUserData(m_joint))
-		{
-			NewtonJointSetDestructor( m_joint, NULL );
-			NewtonDestroyJoint( m_world-&gt;getNewtonWorld(), m_joint );
-		}
-	}
+    if(m_joint)
+    {
+        if (NewtonJointGetUserData(m_joint))
+        {
+            NewtonJointSetDestructor( m_joint, NULL );
+            NewtonDestroyJoint( m_world-&gt;getNewtonWorld(), m_joint );
+        }
+    }
 
 }
 
 
 void _CDECL Joint::destructor( const NewtonJoint* me )
 {
-	Joint* jnt;
+    Joint* jnt;
 
-	jnt = (Joint*)NewtonJointGetUserData( me );
+    jnt = (Joint*)NewtonJointGetUserData( me );
 
-	NewtonJointSetDestructor( me, NULL );
-	NewtonJointSetUserData( me, NULL );
+    NewtonJointSetDestructor( me, NULL );
+    NewtonJointSetUserData( me, NULL );
 
-	delete jnt;
+    delete jnt;
 }
 
 
@@ -45,24 +44,24 @@
 
 CustomJoint::CustomJoint( unsigned int maxDOF, const Body* body0, const Body* body1 ) : Joint()
 {
-	m_maxDOF = maxDOF;
+    m_maxDOF = maxDOF;
 
-	m_body0 = body0;
-	m_body1 = body1;
+    m_body0 = body0;
+    m_body1 = body1;
 
-	m_world = m_body0-&gt;getWorld();
+    m_world = m_body0-&gt;getWorld();
 
-	if (body1)
-		m_joint = NewtonConstraintCreateUserJoint( m_world-&gt;getNewtonWorld(), m_maxDOF, 
-													CustomJoint::newtonSubmitConstraint, CustomJoint::newtonGetInfo,
-													m_body0-&gt;getNewtonBody(), m_body1-&gt;getNewtonBody() );
-	else
-		m_joint = NewtonConstraintCreateUserJoint( m_world-&gt;getNewtonWorld(), m_maxDOF, 
-													CustomJoint::newtonSubmitConstraint, CustomJoint::newtonGetInfo,
-													m_body0-&gt;getNewtonBody(), NULL );
+    if (body1)
+        m_joint = NewtonConstraintCreateUserJoint( m_world-&gt;getNewtonWorld(), m_maxDOF, 
+                                                    CustomJoint::newtonSubmitConstraint, CustomJoint::newtonGetInfo,
+                                                    m_body0-&gt;getNewtonBody(), m_body1-&gt;getNewtonBody() );
+    else
+        m_joint = NewtonConstraintCreateUserJoint( m_world-&gt;getNewtonWorld(), m_maxDOF, 
+                                                    CustomJoint::newtonSubmitConstraint, CustomJoint::newtonGetInfo,
+                                                    m_body0-&gt;getNewtonBody(), NULL );
 
-	NewtonJointSetUserData (m_joint, this);
-	NewtonJointSetDestructor (m_joint, destructor);
+    NewtonJointSetUserData (m_joint, this);
+    NewtonJointSetDestructor (m_joint, destructor);
 
 }
 
@@ -72,153 +71,153 @@
 
 
 void CustomJoint::pinAndDirToLocal( const Ogre::Vector3&amp; pinpt, const Ogre::Vector3&amp; pindir, 
-								   Ogre::Quaternion&amp; localOrient0, Ogre::Vector3&amp; localPos0, Ogre::Quaternion&amp; localOrient1, Ogre::Vector3&amp; localPos1 ) const
+                                   Ogre::Quaternion&amp; localOrient0, Ogre::Vector3&amp; localPos0, Ogre::Quaternion&amp; localOrient1, Ogre::Vector3&amp; localPos1 ) const
 {
-	localOrient0 = localOrient1 =  Ogre::Quaternion::IDENTITY;
-	localPos0 = localPos1 = Ogre::Vector3::ZERO;
+    localOrient0 = localOrient1 =  Ogre::Quaternion::IDENTITY;
+    localPos0 = localPos1 = Ogre::Vector3::ZERO;
 
-	Ogre::Quaternion bodyOrient0 = Ogre::Quaternion::IDENTITY;
-	Ogre::Quaternion bodyOrient1 = Ogre::Quaternion::IDENTITY;
-	Ogre::Vector3 bodyPos0 = Ogre::Vector3::ZERO;
-	Ogre::Vector3 bodyPos1 = Ogre::Vector3::ZERO;
+    Ogre::Quaternion bodyOrient0 = Ogre::Quaternion::IDENTITY;
+    Ogre::Quaternion bodyOrient1 = Ogre::Quaternion::IDENTITY;
+    Ogre::Vector3 bodyPos0 = Ogre::Vector3::ZERO;
+    Ogre::Vector3 bodyPos1 = Ogre::Vector3::ZERO;
 
-	Ogre::Quaternion pinOrient = grammSchmidt(pindir);
+    Ogre::Quaternion pinOrient = grammSchmidt(pindir);
 
-	m_body0-&gt;getPositionOrientation( bodyPos0, bodyOrient0 );
+    m_body0-&gt;getPositionOrientation( bodyPos0, bodyOrient0 );
 
-	if (m_body1)
-		m_body1-&gt;getPositionOrientation( bodyPos1, bodyOrient1 );
+    if (m_body1)
+        m_body1-&gt;getPositionOrientation( bodyPos1, bodyOrient1 );
 
-	localPos0 = bodyOrient0.Inverse() * (pinpt - bodyPos0);
-	localOrient0 = pinOrient * bodyOrient0.Inverse();
+    localPos0 = bodyOrient0.Inverse() * (pinpt - bodyPos0);
+    localOrient0 = pinOrient * bodyOrient0.Inverse();
 
-	localPos1 = bodyOrient1.Inverse() * (pinpt - bodyPos1);
-	localOrient1 = pinOrient * bodyOrient1.Inverse();
+    localPos1 = bodyOrient1.Inverse() * (pinpt - bodyPos1);
+    localOrient1 = pinOrient * bodyOrient1.Inverse();
 
 }
 
 
 void CustomJoint::localToGlobal( const Ogre::Quaternion&amp; localOrient, const Ogre::Vector3&amp; localPos, Ogre::Quaternion&amp; globalOrient, Ogre::Vector3&amp; globalPos, int bodyIndex ) const
 {
-	globalOrient = Ogre::Quaternion::IDENTITY;
-	globalPos= Ogre::Vector3::ZERO;
+    globalOrient = Ogre::Quaternion::IDENTITY;
+    globalPos= Ogre::Vector3::ZERO;
 
-	const Body* bdy = NULL;
-	if (bodyIndex == 0)
-		bdy = m_body0;
-	else if (m_body1)
-		bdy = m_body1;
+    const Body* bdy = NULL;
+    if (bodyIndex == 0)
+        bdy = m_body0;
+    else if (m_body1)
+        bdy = m_body1;
 
-	Ogre::Quaternion bodyOrient = Ogre::Quaternion::IDENTITY;
-	Ogre::Vector3 bodyPos = Ogre::Vector3::ZERO;
+    Ogre::Quaternion bodyOrient = Ogre::Quaternion::IDENTITY;
+    Ogre::Vector3 bodyPos = Ogre::Vector3::ZERO;
 
-	if (bdy)
-		bdy-&gt;getPositionOrientation( bodyPos, bodyOrient );
+    if (bdy)
+        bdy-&gt;getPositionOrientation( bodyPos, bodyOrient );
 
-	globalPos = (bodyOrient * localPos) + bodyPos;
-	globalOrient = bodyOrient * localOrient;
+    globalPos = (bodyOrient * localPos) + bodyPos;
+    globalOrient = bodyOrient * localOrient;
 }
 
-	
+    
 
 void CustomJoint::addLinearRow( const Ogre::Vector3&amp; pt0, const Ogre::Vector3&amp; pt1, const Ogre::Vector3&amp; dir ) const
 {
-	NewtonUserJointAddLinearRow( m_joint, &amp;pt0.x, &amp;pt1.x, &amp;dir.x );
+    NewtonUserJointAddLinearRow( m_joint, &amp;pt0.x, &amp;pt1.x, &amp;dir.x );
 }
 
 void CustomJoint::addAngularRow( Ogre::Radian relativeAngleError, const Ogre::Vector3&amp; dir ) const
 {
-	NewtonUserJointAddAngularRow( m_joint, relativeAngleError.valueRadians(), &amp;dir.x );
+    NewtonUserJointAddAngularRow( m_joint, relativeAngleError.valueRadians(), &amp;dir.x );
 }
 
 void CustomJoint::addGeneralRow(const Ogre::Vector3&amp; linear0, const Ogre::Vector3&amp; angular0, const Ogre::Vector3&amp; linear1, const Ogre::Vector3&amp; angular1) const
 {
-	float jacobian0[6], jacobian1[6];
+    float jacobian0[6], jacobian1[6];
 
-	jacobian0[0] = linear0.x;
-	jacobian0[1] = linear0.y;
-	jacobian0[2] = linear0.z;
-	jacobian0[3] = angular0.x;
-	jacobian0[4] = angular0.y;
-	jacobian0[5] = angular0.z;
+    jacobian0[0] = linear0.x;
+    jacobian0[1] = linear0.y;
+    jacobian0[2] = linear0.z;
+    jacobian0[3] = angular0.x;
+    jacobian0[4] = angular0.y;
+    jacobian0[5] = angular0.z;
 
-	jacobian1[0] = linear1.x;
-	jacobian1[1] = linear1.y;
-	jacobian1[2] = linear1.z;
-	jacobian1[3] = angular1.x;
-	jacobian1[4] = angular1.y;
-	jacobian1[5] = angular1.z;
+    jacobian1[0] = linear1.x;
+    jacobian1[1] = linear1.y;
+    jacobian1[2] = linear1.z;
+    jacobian1[3] = angular1.x;
+    jacobian1[4] = angular1.y;
+    jacobian1[5] = angular1.z;
 
-	NewtonUserJointAddGeneralRow( m_joint, jacobian0, jacobian1 );
+    NewtonUserJointAddGeneralRow( m_joint, jacobian0, jacobian1 );
 }
 
 
 void CustomJoint::setRowMinimumFriction( Ogre::Real friction ) const
 {
-	NewtonUserJointSetRowMinimumFriction( m_joint, friction );
+    NewtonUserJointSetRowMinimumFriction( m_joint, friction );
 }
 
 
 void CustomJoint::setRowMaximumFriction( Ogre::Real friction ) const
 {
-	NewtonUserJointSetRowMaximumFriction( m_joint, friction );
+    NewtonUserJointSetRowMaximumFriction( m_joint, friction );
 }
 
 
 void CustomJoint::setRowAcceleration( Ogre::Real accel ) const
 {
-	NewtonUserJointSetRowAcceleration( m_joint, accel );
+    NewtonUserJointSetRowAcceleration( m_joint, accel );
 }
 
 void CustomJoint::setRowStiffness( Ogre::Real stiffness ) const
 {
-	NewtonUserJointSetRowStiffness( m_joint, stiffness );
+    NewtonUserJointSetRowStiffness( m_joint, stiffness );
 }
 
 void CustomJoint::setRowSpringDamper(Ogre::Real springK, Ogre::Real springD) const
 {
-	NewtonUserJointSetRowSpringDamperAcceleration( m_joint, springK, springD );
+    NewtonUserJointSetRowSpringDamperAcceleration( m_joint, springK, springD );
 }
 
 
 void _CDECL CustomJoint::newtonSubmitConstraint( const NewtonJoint* me, float timeStep, int threadIndex )
 {
-	CustomJoint* j = (CustomJoint*)NewtonJointGetUserData( me );
+    CustomJoint* j = (CustomJoint*)NewtonJointGetUserData( me );
 
-	j-&gt;submitConstraint( (Ogre::Real)timeStep, threadIndex );
+    j-&gt;submitConstraint( (Ogre::Real)timeStep, threadIndex );
 }
 
 
 void _CDECL CustomJoint::newtonGetInfo(const NewtonJoint *me, NewtonJointRecord *info)
 {
-	CustomJoint* j = (CustomJoint*)NewtonJointGetUserData( me );
+    CustomJoint* j = (CustomJoint*)NewtonJointGetUserData( me );
 }
 
 
 Ogre::Quaternion CustomJoint::grammSchmidt( const Ogre::Vector3&amp; pin ) const
 {
-	Ogre::Vector3 front, up, right;
-	front = pin;
+    Ogre::Vector3 front, up, right;
+    front = pin;
 
-	front.normalise();
-	if (Ogre::Math::Abs( front.z ) &gt; 0.577f)
-		right = front.crossProduct( Ogre::Vector3(-front.y, front.z, 0.0f) );
-	else
-		right = front.crossProduct( Ogre::Vector3(-front.y, front.x, 0.0f) );
-	right.normalise();
-	up = right.crossProduct( front );
+    front.normalise();
+    if (Ogre::Math::Abs( front.z ) &gt; 0.577f)
+        right = front.crossProduct( Ogre::Vector3(-front.y, front.z, 0.0f) );
+    else
+        right = front.crossProduct( Ogre::Vector3(-front.y, front.x, 0.0f) );
+    right.normalise();
+    up = right.crossProduct( front );
 
-	Ogre::Matrix3 ret;
-	ret.FromAxes( front, up, right );
+    Ogre::Matrix3 ret;
+    ret.FromAxes( front, up, right );
 
-	Ogre::Quaternion quat;
-	quat.FromRotationMatrix( ret );
+    Ogre::Quaternion quat;
+    quat.FromRotationMatrix( ret );
 
-	return quat;
+    return quat;
 }
 
 
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 

Modified: dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -4,17 +4,17 @@
 namespace OgreNewt
 {
 
-	
+    
 MaterialID::MaterialID( const World* world )
 {
-	m_world = world;
-	id = NewtonMaterialCreateGroupID( m_world-&gt;getNewtonWorld() );
+    m_world = world;
+    id = NewtonMaterialCreateGroupID( m_world-&gt;getNewtonWorld() );
 }
 
 MaterialID::MaterialID( const World* world, int ID )
 {
-	m_world = world;
-	id = ID;
+    m_world = world;
+    id = ID;
 }
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -4,12 +4,12 @@
 namespace OgreNewt
 {
 
-	
+ 
 MaterialPair::MaterialPair( const World* world, const MaterialID* mat1, const MaterialID* mat2 )
 {
-	m_world = world;
-	id0 = mat1;
-	id1 = mat2;
+    m_world = world;
+    id0 = mat1;
+    id1 = mat2;
     m_contactcallback = NULL;
 }
 
@@ -23,15 +23,15 @@
     m_contactcallback = callback;
     if( callback )
     {
-	    NewtonMaterialSetCollisionCallback( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), this,
-		    collisionCallback_onAABBOverlap,
-    		collisionCallback_contactsProcess);
+        NewtonMaterialSetCollisionCallback( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), this,
+            collisionCallback_onAABBOverlap,
+            collisionCallback_contactsProcess);
     }
     else
     {
-	    NewtonMaterialSetCollisionCallback( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), NULL,
-		    NULL,
-    		NULL);
+        NewtonMaterialSetCollisionCallback( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), NULL,
+            NULL,
+            NULL);
     }
 }
 
@@ -39,12 +39,12 @@
 int _CDECL MaterialPair::collisionCallback_onAABBOverlap( const NewtonMaterial* material, const NewtonBody* newtonBody0, const NewtonBody* newtonBody1, int threadIndex )
 {
     MaterialPair* me;
-	me = (MaterialPair*)NewtonMaterialGetMaterialPairUserData( material );
+    me = (MaterialPair*)NewtonMaterialGetMaterialPairUserData( material );
 
-	Body* body0 = (OgreNewt::Body*)NewtonBodyGetUserData( newtonBody0 );
-	Body* body1 = (OgreNewt::Body*)NewtonBodyGetUserData( newtonBody1 );
+    Body* body0 = (OgreNewt::Body*)NewtonBodyGetUserData( newtonBody0 );
+    Body* body1 = (OgreNewt::Body*)NewtonBodyGetUserData( newtonBody1 );
 
-	return me-&gt;m_contactcallback-&gt;onAABBOverlap( body0, body1, threadIndex );
+    return me-&gt;m_contactcallback-&gt;onAABBOverlap( body0, body1, threadIndex );
 }
 
 void _CDECL MaterialPair::collisionCallback_contactsProcess(const NewtonJoint *newtonContactJoint, float timestep, int threadIndex )
@@ -57,28 +57,6 @@
     {
         ( me-&gt;m_contactcallback-&gt;contactsProcess )(contactJoint, timestep, threadIndex);
     }
-
-    /*
-     // OLD CODE!
-        for (void* contact = NewtonContactJointGetFirstContact (contactJoint); contact; contact = NewtonContactJointGetNextContact (contactJoint, contact))
-        {
-	        ContactCallback *me;
-                NewtonMaterial* material = NewtonContactGetMaterial(contact);
-
-                me = (ContactCallback*)NewtonMaterialGetMaterialPairUserData( material );
-
-                me-&gt;m_material = material;
-                me-&gt;m_body0 = (OgreNewt::Body*)NewtonBodyGetUserData( NewtonJointGetBody0(contactJoint) );
-	        me-&gt;m_body1 = (OgreNewt::Body*)NewtonBodyGetUserData( NewtonJointGetBody1(contactJoint) );
-
-	        // call the user-defined callback function!
-	        if( !me-&gt;contactProcess( (Ogre::Real)timeStep, threadIndex ) )
-                {
-                    NewtonContactJointRemoveContact(contactJoint, contact);
-                }
-        }
-    */
-
 }
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -3,6 +3,7 @@
 #include &quot;OgreNewt_Collision.h&quot;
 #include &quot;OgreNewt_CollisionPrimitives.h&quot;
 #include &quot;OgreNewt_World.h&quot;
+
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 
@@ -694,5 +695,5 @@
 }
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 

Modified: dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -10,12 +10,12 @@
 {
 
 
-	Raycast::Raycast()	{}
-	Raycast::~Raycast()	{}
+    Raycast::Raycast()  {}
+    Raycast::~Raycast() {}
 
 
-	void Raycast::go(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt )
-	{
+    void Raycast::go(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt )
+    {
         if( world-&gt;getDebugger().isRaycastRecording() )
         {
             world-&gt;getDebugger().addRay(startpt, endpt);
@@ -23,21 +23,21 @@
 
         m_treecollisioncallback_lastbody = NULL;
 
-		// perform the raycast!
-		NewtonWorldRayCast( world-&gt;getNewtonWorld(), (float*)&amp;startpt, (float*)&amp;endpt, OgreNewt::Raycast::newtonRaycastFilter, this, OgreNewt::Raycast::newtonRaycastPreFilter );
+        // perform the raycast!
+        NewtonWorldRayCast( world-&gt;getNewtonWorld(), (float*)&amp;startpt, (float*)&amp;endpt, OgreNewt::Raycast::newtonRaycastFilter, this, OgreNewt::Raycast::newtonRaycastPreFilter );
 
         m_treecollisioncallback_lastbody = NULL;
 
-	}
+    }
 
-	float _CDECL Raycast::newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersectParam)
-	{
-		// get our object!
-		Raycast* me = (Raycast*)userData;
+    float _CDECL Raycast::newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersectParam)
+    {
+        // get our object!
+        Raycast* me = (Raycast*)userData;
 
-		Body* bod = (Body*)NewtonBodyGetUserData( body );
+        Body* bod = (Body*)NewtonBodyGetUserData( body );
         const World* world = bod-&gt;getWorld();
-		Ogre::Vector3 normal = Ogre::Vector3( hitNormal[0], hitNormal[1], hitNormal[2] );
+        Ogre::Vector3 normal = Ogre::Vector3( hitNormal[0], hitNormal[1], hitNormal[2] );
 
 
         if( me-&gt;m_treecollisioncallback_bodyalreadyadded )
@@ -50,28 +50,28 @@
         }
 
 
-		if (me-&gt;userCallback( bod, intersectParam, normal, collisionID ))
-			return intersectParam;
-		else
-			return 1.1;
+        if (me-&gt;userCallback( bod, intersectParam, normal, collisionID ))
+            return intersectParam;
+        else
+            return 1.1;
 
-	}
+    }
 
-	unsigned _CDECL Raycast::newtonRaycastPreFilter(const NewtonBody *body, const NewtonCollision *collision, void* userData)
-	{
-		// get our object!
-		Raycast* me = (Raycast*)userData;
+    unsigned _CDECL Raycast::newtonRaycastPreFilter(const NewtonBody *body, const NewtonCollision *collision, void* userData)
+    {
+        // get our object!
+        Raycast* me = (Raycast*)userData;
 
-		Body* bod = (Body*)NewtonBodyGetUserData( body );
+        Body* bod = (Body*)NewtonBodyGetUserData( body );
         const World* world = bod-&gt;getWorld();
 
 
         me-&gt;m_treecollisioncallback_bodyalreadyadded = false;
         me-&gt;m_treecollisioncallback_lastbody = bod;
 
-		if (me-&gt;userPreFilterCallback( bod ))
-			return 1;
-		else
+        if (me-&gt;userPreFilterCallback( bod ))
+            return 1;
+        else
         {
 
             if( world-&gt;getDebugger().isRaycastRecording() &amp;&amp; world-&gt;getDebugger().isRaycastRecordingHitBodies() )
@@ -79,97 +79,97 @@
                 world-&gt;getDebugger().addDiscardedBody(bod);
             }
 
-			return 0;
+            return 0;
         }
-	}
+    }
 
 
 
-	//--------------------------------
-	BasicRaycast::BasicRaycastInfo::BasicRaycastInfo()
-	{
-		mBody = NULL;
-		mDistance = -1.0;
-		mNormal = Ogre::Vector3::ZERO;
-	}
+    //--------------------------------
+    BasicRaycast::BasicRaycastInfo::BasicRaycastInfo()
+    {
+        mBody = NULL;
+        mDistance = -1.0;
+        mNormal = Ogre::Vector3::ZERO;
+    }
 
-	BasicRaycast::BasicRaycastInfo::~BasicRaycastInfo() {}
+    BasicRaycast::BasicRaycastInfo::~BasicRaycastInfo() {}
 
 
-	BasicRaycast::BasicRaycast()    {}
+    BasicRaycast::BasicRaycast()    {}
 
 
-	BasicRaycast::BasicRaycast(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted)
+    BasicRaycast::BasicRaycast(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted)
         : Raycast()
-	{
-		go( world, startpt, endpt, sorted );
-	}
+    {
+        go( world, startpt, endpt, sorted );
+    }
 
 
     void BasicRaycast::go(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted)
-	{
+    {
         Raycast::go( world, startpt, endpt );
         if( sorted )
         {
             std::sort(mRayList.begin(), mRayList.end());
         }
-	}
+    }
 
 
-	BasicRaycast::~BasicRaycast()	{}
+    BasicRaycast::~BasicRaycast()   {}
 
 
-	int BasicRaycast::getHitCount() const { return (int)mRayList.size(); }
+    int BasicRaycast::getHitCount() const { return (int)mRayList.size(); }
 
 
-	BasicRaycast::BasicRaycastInfo BasicRaycast::getFirstHit() const
-	{
-		//return the closest hit...
-		BasicRaycast::BasicRaycastInfo ret;
+    BasicRaycast::BasicRaycastInfo BasicRaycast::getFirstHit() const
+    {
+        //return the closest hit...
+        BasicRaycast::BasicRaycastInfo ret;
 
-		Ogre::Real dist = Ogre::Math::POS_INFINITY;
+        Ogre::Real dist = Ogre::Math::POS_INFINITY;
 
-		RaycastInfoList::const_iterator it;
-		for (it = mRayList.begin(); it != mRayList.end(); it++)
-		{
-			if (it-&gt;mDistance &lt; dist)
-			{
-				dist = it-&gt;mDistance;
-				ret = (*it);
-			}
-		}
+        RaycastInfoList::const_iterator it;
+        for (it = mRayList.begin(); it != mRayList.end(); it++)
+        {
+            if (it-&gt;mDistance &lt; dist)
+            {
+                dist = it-&gt;mDistance;
+                ret = (*it);
+            }
+        }
 
 
-		return ret;
-	}
+        return ret;
+    }
 
 
-	BasicRaycast::BasicRaycastInfo BasicRaycast::getInfoAt( int hitnum ) const
-	{
-		BasicRaycast::BasicRaycastInfo ret;
+    BasicRaycast::BasicRaycastInfo BasicRaycast::getInfoAt( int hitnum ) const
+    {
+        BasicRaycast::BasicRaycastInfo ret;
 
-		if ((hitnum &lt; 0) || (hitnum &gt;= mRayList.size()))
-			return ret;
+        if ((hitnum &lt; 0) || (hitnum &gt;= mRayList.size()))
+            return ret;
 
-		ret = mRayList.at(hitnum);
+        ret = mRayList.at(hitnum);
 
-		return ret;
-	}
+        return ret;
+    }
 
-	bool BasicRaycast::userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID )
-	{
-		// create a new infor object.
-		BasicRaycast::BasicRaycastInfo newinfo;
+    bool BasicRaycast::userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID )
+    {
+        // create a new infor object.
+        BasicRaycast::BasicRaycastInfo newinfo;
 
-		newinfo.mBody = body;
-		newinfo.mDistance = distance;
-		newinfo.mNormal = normal;
-		newinfo.mCollisionID = collisionID;
+        newinfo.mBody = body;
+        newinfo.mDistance = distance;
+        newinfo.mNormal = normal;
+        newinfo.mCollisionID = collisionID;
 
-		mRayList.push_back( newinfo );
+        mRayList.push_back( newinfo );
 
-		return false;
-	}
+        return false;
+    }
 
 
 
@@ -182,7 +182,7 @@
         {
         }
 
-	Convexcast::~Convexcast()
+    Convexcast::~Convexcast()
         {
             if( mReturnInfoList )
             {
@@ -191,8 +191,8 @@
         }
 
 
-	void Convexcast::go(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount, int threadIndex)
-	{
+    void Convexcast::go(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount, int threadIndex)
+    {
 
         if( world-&gt;getDebugger().isRaycastRecording() )
         {
@@ -209,7 +209,7 @@
                 }
 
                 memset(mReturnInfoList, 0, sizeof(mReturnInfoList[0])*mReturnInfoListSize);
-		// perform the cast
+        // perform the cast
                 float matrix[16];
                 OgreNewt::Converters::QuatPosToMatrix(colori, startpt, &amp;matrix[0] );
                 mFirstContactDistance = -1;
@@ -240,19 +240,19 @@
                     world-&gt;getDebugger().addHitBody(body);
                 }
             }
-	}
+    }
 
-	unsigned _CDECL Convexcast::newtonConvexcastPreFilter(const NewtonBody *body, const NewtonCollision *collision, void* userData)
-	{
-		// get our object!
-		Convexcast* me = (Convexcast*)userData;
+    unsigned _CDECL Convexcast::newtonConvexcastPreFilter(const NewtonBody *body, const NewtonCollision *collision, void* userData)
+    {
+        // get our object!
+        Convexcast* me = (Convexcast*)userData;
 
-		Body* bod = (Body*)NewtonBodyGetUserData( body );
+        Body* bod = (Body*)NewtonBodyGetUserData( body );
         const World* world = bod-&gt;getWorld();
 
-		if (me-&gt;userPreFilterCallback( bod ))
-			return 1;
-		else
+        if (me-&gt;userPreFilterCallback( bod ))
+            return 1;
+        else
         {
 
             if( world-&gt;getDebugger().isRaycastRecording() &amp;&amp; world-&gt;getDebugger().isRaycastRecordingHitBodies() )
@@ -260,33 +260,33 @@
                 world-&gt;getDebugger().addDiscardedBody(bod);
             }
 
-			return 0;
+            return 0;
         }
-	}
+    }
 
 
 
 //-------------------------------------------------------------------------------------
-	BasicConvexcast::ConvexcastContactInfo::ConvexcastContactInfo()
-	{
-		mBody = NULL;
-	}
+    BasicConvexcast::ConvexcastContactInfo::ConvexcastContactInfo()
+    {
+        mBody = NULL;
+    }
 
-	BasicConvexcast::ConvexcastContactInfo::~ConvexcastContactInfo() {}
+    BasicConvexcast::ConvexcastContactInfo::~ConvexcastContactInfo() {}
 
         BasicConvexcast::BasicConvexcast()
         {
         }
 
-	BasicConvexcast::BasicConvexcast(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount, int threadIndex)
-	{
-		go( world, col, startpt, colori, endpt, maxcontactscount, threadIndex);
-	}
+    BasicConvexcast::BasicConvexcast(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount, int threadIndex)
+    {
+        go( world, col, startpt, colori, endpt, maxcontactscount, threadIndex);
+    }
 
-	BasicConvexcast::~BasicConvexcast()	{}
+    BasicConvexcast::~BasicConvexcast() {}
 
 
-	int BasicConvexcast::calculateBodyHitCount() const
+    int BasicConvexcast::calculateBodyHitCount() const
         {
             int count = 0;
             for( int i = 0; i &lt; mReturnInfoListLength; i++ )
@@ -309,8 +309,8 @@
             return mReturnInfoListLength;
         }
 
-	BasicConvexcast::ConvexcastContactInfo BasicConvexcast::getInfoAt( int hitnum ) const
-	{
+    BasicConvexcast::ConvexcastContactInfo BasicConvexcast::getInfoAt( int hitnum ) const
+    {
             ConvexcastContactInfo info;
 
             if( hitnum &lt; 0 || hitnum &gt;= mReturnInfoListLength )
@@ -327,13 +327,13 @@
             info.mContactPoint.z = mReturnInfoList[hitnum].m_point[2];
             info.mContactPenetration = mReturnInfoList[hitnum].m_penetration;
 
-	    return info;
-	}
+        return info;
+    }
 
         Ogre::Real BasicConvexcast::getDistanceToFirstHit() const
         {
             return mFirstContactDistance;
         }
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 

Modified: dependencies/OgreNewt/src/OgreNewt_Tools.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -5,218 +5,226 @@
 #include &lt;iostream&gt;
 
 #ifdef __APPLE__
-#    include &lt;Ogre/OgreFontManager.h&gt;
+#   include &lt;Ogre/OgreFontManager.h&gt;
+#   include &lt;Ogre/OgreMaterialManager.h&gt;
+#   include &lt;Ogre/OgreCamera.h&gt;
+#   include &lt;Ogre/OgreHardwareBufferManager.h&gt;
+#   include &lt;Ogre/OgreRoot.h&gt;
 #else
-#    include &lt;OgreFontManager.h&gt;
+#   include &lt;OgreFontManager.h&gt;
+#   include &lt;OgreMaterialManager.h&gt;
+#   include &lt;OgreCamera.h&gt;
+#   include &lt;OgreHardwareBufferManager.h&gt;
+#   include &lt;OgreRoot.h&gt;
 #endif
 
 namespace OgreNewt
 {
 
-	namespace Converters
-	{
-		
-		//! Take a Newton matrix and create a Quaternion + Position_vector
-		void MatrixToQuatPos( const float* matrix, Ogre::Quaternion&amp; quat, Ogre::Vector3 &amp;pos )
-		{
-			// this takes a matrix returned by Newton, and creates a Quaternion
-			// and position Vector3, which is more meaningful for Ogre.
-			using namespace Ogre;
-			quat = Quaternion( Matrix3(	matrix[0], matrix[4], matrix[8],
-							matrix[1], matrix[5], matrix[9],
-							matrix[2], matrix[6], matrix[10] ) );
-		
-			pos = Vector3( matrix[12], matrix[13], matrix[14] );
-		}
+    namespace Converters
+    {
+        
+        //! Take a Newton matrix and create a Quaternion + Position_vector
+        void MatrixToQuatPos( const float* matrix, Ogre::Quaternion&amp; quat, Ogre::Vector3 &amp;pos )
+        {
+            // this takes a matrix returned by Newton, and creates a Quaternion
+            // and position Vector3, which is more meaningful for Ogre.
+            using namespace Ogre;
+            quat = Quaternion( Matrix3( matrix[0], matrix[4], matrix[8],
+                            matrix[1], matrix[5], matrix[9],
+                            matrix[2], matrix[6], matrix[10] ) );
+        
+            pos = Vector3( matrix[12], matrix[13], matrix[14] );
+        }
 
-		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
-		void QuatPosToMatrix( const Ogre::Quaternion&amp; quat, const Ogre::Vector3 &amp;pos, float* matrix )
-		{
-			// this takes a Quaternion and a Vector3 and creates a float array
-			// which is more meaningful to Newton.
-			using namespace Ogre;
-			Matrix3 rot;
-			Vector3 xcol, ycol, zcol;
-			
-			quat.ToRotationMatrix( rot );	// creates a 3x3 rotation matrix from the Quaternion.
+        //! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
+        void QuatPosToMatrix( const Ogre::Quaternion&amp; quat, const Ogre::Vector3 &amp;pos, float* matrix )
+        {
+            // this takes a Quaternion and a Vector3 and creates a float array
+            // which is more meaningful to Newton.
+            using namespace Ogre;
+            Matrix3 rot;
+            Vector3 xcol, ycol, zcol;
+            
+            quat.ToRotationMatrix( rot );   // creates a 3x3 rotation matrix from the Quaternion.
 
-			xcol = rot.GetColumn(0);
-			ycol = rot.GetColumn(1);
-			zcol = rot.GetColumn(2);
-		
-			// now fill the final matrix with the appropriate data:
-			matrix[0] = xcol.x;
-			matrix[1] = xcol.y;
-			matrix[2] = xcol.z;
-			matrix[3] = 0.0f;
-		
-			matrix[4] = ycol.x;
-			matrix[5] = ycol.y;
-			matrix[6] = ycol.z;
-			matrix[7] = 0.0f;
-		
-			matrix[8] = zcol.x;
-			matrix[9] = zcol.y;
-			matrix[10] = zcol.z;
-			matrix[11] = 0.0f;
-		
-			matrix[12] = pos.x;
-			matrix[13] = pos.y;
-			matrix[14] = pos.z;
-			matrix[15] = 1.0;
-		}
+            xcol = rot.GetColumn(0);
+            ycol = rot.GetColumn(1);
+            zcol = rot.GetColumn(2);
+        
+            // now fill the final matrix with the appropriate data:
+            matrix[0] = xcol.x;
+            matrix[1] = xcol.y;
+            matrix[2] = xcol.z;
+            matrix[3] = 0.0f;
+        
+            matrix[4] = ycol.x;
+            matrix[5] = ycol.y;
+            matrix[6] = ycol.z;
+            matrix[7] = 0.0f;
+        
+            matrix[8] = zcol.x;
+            matrix[9] = zcol.y;
+            matrix[10] = zcol.z;
+            matrix[11] = 0.0f;
+        
+            matrix[12] = pos.x;
+            matrix[13] = pos.y;
+            matrix[14] = pos.z;
+            matrix[15] = 1.0;
+        }
 
-		void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4&amp; matrix_out )
-		{
-			// from Newton to Ogre::Matrix4
-			matrix_out = Ogre::Matrix4( matrix_in[0], matrix_in[4], matrix_in[8], matrix_in[12],
-				matrix_in[1], matrix_in[5], matrix_in[9], matrix_in[13],
-				matrix_in[2], matrix_in[6], matrix_in[10], matrix_in[14],
-				matrix_in[3], matrix_in[7], matrix_in[11], matrix_in[15] );
-		}
+        void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4&amp; matrix_out )
+        {
+            // from Newton to Ogre::Matrix4
+            matrix_out = Ogre::Matrix4( matrix_in[0], matrix_in[4], matrix_in[8], matrix_in[12],
+                matrix_in[1], matrix_in[5], matrix_in[9], matrix_in[13],
+                matrix_in[2], matrix_in[6], matrix_in[10], matrix_in[14],
+                matrix_in[3], matrix_in[7], matrix_in[11], matrix_in[15] );
+        }
 
-		void Matrix4ToMatrix( const Ogre::Matrix4&amp; matrix_in, float* matrix_out )
-		{
-			// from Ogre to Newton.
-			matrix_out[0] = matrix_in[0][0];
-			matrix_out[1] = matrix_in[1][0];
-			matrix_out[2] = matrix_in[2][0];
-			matrix_out[3] = matrix_in[3][0];
+        void Matrix4ToMatrix( const Ogre::Matrix4&amp; matrix_in, float* matrix_out )
+        {
+            // from Ogre to Newton.
+            matrix_out[0] = matrix_in[0][0];
+            matrix_out[1] = matrix_in[1][0];
+            matrix_out[2] = matrix_in[2][0];
+            matrix_out[3] = matrix_in[3][0];
 
-			matrix_out[4] = matrix_in[0][1];
-			matrix_out[5] = matrix_in[1][1];
-			matrix_out[6] = matrix_in[2][1];
-			matrix_out[7] = matrix_in[3][1];
+            matrix_out[4] = matrix_in[0][1];
+            matrix_out[5] = matrix_in[1][1];
+            matrix_out[6] = matrix_in[2][1];
+            matrix_out[7] = matrix_in[3][1];
 
-			matrix_out[8] = matrix_in[0][2];
-			matrix_out[9] = matrix_in[1][2];
-			matrix_out[10] = matrix_in[2][2];
-			matrix_out[11] = matrix_in[3][2];
+            matrix_out[8] = matrix_in[0][2];
+            matrix_out[9] = matrix_in[1][2];
+            matrix_out[10] = matrix_in[2][2];
+            matrix_out[11] = matrix_in[3][2];
 
-			matrix_out[12] = matrix_in[0][3];
-			matrix_out[13] = matrix_in[1][3];
-			matrix_out[14] = matrix_in[2][3];
-			matrix_out[15] = matrix_in[3][3];
-		}
+            matrix_out[12] = matrix_in[0][3];
+            matrix_out[13] = matrix_in[1][3];
+            matrix_out[14] = matrix_in[2][3];
+            matrix_out[15] = matrix_in[3][3];
+        }
 
 
-	} // end namespace &quot;converters&quot;
+    } // end namespace &quot;converters&quot;
 
-	
-	namespace CollisionTools
-	{
-		//! find the point on a collision primitive closest to a global point.
-		
-		int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3&amp; globalpt, 
-									const OgreNewt::Collision* col, const Ogre::Quaternion&amp; colorient, const Ogre::Vector3&amp; colpos, 
-									Ogre::Vector3&amp; retpt, Ogre::Vector3&amp; retnormal, int threadIndex )
-		{
-			float matrix[16];
-			Converters::QuatPosToMatrix( colorient, colpos, matrix );
+    
+    namespace CollisionTools
+    {
+        //! find the point on a collision primitive closest to a global point.
+        
+        int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3&amp; globalpt, 
+                                    const OgreNewt::Collision* col, const Ogre::Quaternion&amp; colorient, const Ogre::Vector3&amp; colpos, 
+                                    Ogre::Vector3&amp; retpt, Ogre::Vector3&amp; retnormal, int threadIndex )
+        {
+            float matrix[16];
+            Converters::QuatPosToMatrix( colorient, colpos, matrix );
 #ifdef __APPLE__
-			return NewtonCollisionPointDistance( world-&gt;getNewtonWorld(), &amp;globalpt.x, col-&gt;getNewtonCollision(), matrix, &amp;retpt.x, &amp;retnormal.x);
+            return NewtonCollisionPointDistance( world-&gt;getNewtonWorld(), &amp;globalpt.x, col-&gt;getNewtonCollision(), matrix, &amp;retpt.x, &amp;retnormal.x);
 #else
-			return NewtonCollisionPointDistance( world-&gt;getNewtonWorld(), &amp;globalpt.x, col-&gt;getNewtonCollision(), matrix, &amp;retpt.x, &amp;retnormal.x, threadIndex);
+            return NewtonCollisionPointDistance( world-&gt;getNewtonWorld(), &amp;globalpt.x, col-&gt;getNewtonCollision(), matrix, &amp;retpt.x, &amp;retnormal.x, threadIndex);
 #endif
-		}
-		
+        }
+        
 
 
-		
-		int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-															const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-															Ogre::Vector3&amp; retPosA, Ogre::Vector3&amp; retPosB, Ogre::Vector3&amp; retNorm, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
+        
+        int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
+                                                            const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
+                                                            Ogre::Vector3&amp; retPosA, Ogre::Vector3&amp; retPosB, Ogre::Vector3&amp; retNorm, int threadIndex )
+        {
+            float matrixA[16];
+            float matrixB[16];
 
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+            Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+            Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
 
 #ifdef __APPLE__
-			return NewtonCollisionClosestPoint( world-&gt;getNewtonWorld(), colA-&gt;getNewtonCollision(), matrixA, colB-&gt;getNewtonCollision(), matrixB,
-												&amp;retPosA.x, &amp;retPosB.x, &amp;retNorm.x);
+            return NewtonCollisionClosestPoint( world-&gt;getNewtonWorld(), colA-&gt;getNewtonCollision(), matrixA, colB-&gt;getNewtonCollision(), matrixB,
+                                                &amp;retPosA.x, &amp;retPosB.x, &amp;retNorm.x);
 #else
-			return NewtonCollisionClosestPoint( world-&gt;getNewtonWorld(), colA-&gt;getNewtonCollision(), matrixA, colB-&gt;getNewtonCollision(), matrixB,
+            return NewtonCollisionClosestPoint( world-&gt;getNewtonWorld(), colA-&gt;getNewtonCollision(), matrixA, colB-&gt;getNewtonCollision(), matrixB,
                                                &amp;retPosA.x, &amp;retPosB.x, &amp;retNorm.x, threadIndex );
 #endif
-		}
+        }
 
 
-		int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
-			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-			Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
+        int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
+            const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
+            const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
+            Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
+        {
+            float matrixA[16];
+            float matrixB[16];
 
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+            Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+            Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
 
 #ifdef __APPLE__
-			return NewtonCollisionCollide( world-&gt;getNewtonWorld(), maxSize, colA-&gt;getNewtonCollision(), matrixA,
-				colB-&gt;getNewtonCollision(), matrixB, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations);
+            return NewtonCollisionCollide( world-&gt;getNewtonWorld(), maxSize, colA-&gt;getNewtonCollision(), matrixA,
+                colB-&gt;getNewtonCollision(), matrixB, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations);
 #else
-			return NewtonCollisionCollide( world-&gt;getNewtonWorld(), maxSize, colA-&gt;getNewtonCollision(), matrixA,
+            return NewtonCollisionCollide( world-&gt;getNewtonWorld(), maxSize, colA-&gt;getNewtonCollision(), matrixA,
                                           colB-&gt;getNewtonCollision(), matrixB, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations, threadIndex );
 #endif
-		}
+        }
 
 
-		int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
-			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA, const Ogre::Vector3&amp; colVelA, const Ogre::Vector3&amp; colOmegaA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB, const Ogre::Vector3&amp; colVelB, const Ogre::Vector3&amp; colOmegaB,
-			Ogre::Real&amp; retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
+        int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
+            const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA, const Ogre::Vector3&amp; colVelA, const Ogre::Vector3&amp; colOmegaA,
+            const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB, const Ogre::Vector3&amp; colVelB, const Ogre::Vector3&amp; colOmegaB,
+            Ogre::Real&amp; retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
+        {
+            float matrixA[16];
+            float matrixB[16];
 
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+            Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+            Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
 
 #ifdef __APPLE__
-			return NewtonCollisionCollideContinue( world-&gt;getNewtonWorld(), maxSize, timeStep,
+            return NewtonCollisionCollideContinue( world-&gt;getNewtonWorld(), maxSize, timeStep,
                                                   colA-&gt;getNewtonCollision(), matrixA, &amp;colVelA.x, &amp;colOmegaA.x, 
                                                   colB-&gt;getNewtonCollision(), matrixB, &amp;colVelB.x, &amp;colOmegaB.x,
                                                   &amp;retTimeOfImpact, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations);
 #else
-			return NewtonCollisionCollideContinue( world-&gt;getNewtonWorld(), maxSize, timeStep,
+            return NewtonCollisionCollideContinue( world-&gt;getNewtonWorld(), maxSize, timeStep,
                                                   colA-&gt;getNewtonCollision(), matrixA, &amp;colVelA.x, &amp;colOmegaA.x, 
                                                   colB-&gt;getNewtonCollision(), matrixB, &amp;colVelB.x, &amp;colOmegaB.x,
                                                   &amp;retTimeOfImpact, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations, threadIndex );
 #endif
-		}
+        }
 
 
-		Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3&amp; startPt, const Ogre::Vector3&amp; endPt, 
-			Ogre::Vector3&amp; retNorm, int&amp; retColID )
-		{
-			return NewtonCollisionRayCast( col-&gt;getNewtonCollision(), &amp;startPt.x, &amp;endPt.x, &amp;retNorm.x, &amp;retColID );
-		}
+        Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3&amp; startPt, const Ogre::Vector3&amp; endPt, 
+            Ogre::Vector3&amp; retNorm, int&amp; retColID )
+        {
+            return NewtonCollisionRayCast( col-&gt;getNewtonCollision(), &amp;startPt.x, &amp;endPt.x, &amp;retNorm.x, &amp;retColID );
+        }
 
-		Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos )
-		{
-			float matrix[16];
-			Converters::QuatPosToMatrix( orient, pos, matrix );
-			Ogre::Vector3 min, max;
+        Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos )
+        {
+            float matrix[16];
+            Converters::QuatPosToMatrix( orient, pos, matrix );
+            Ogre::Vector3 min, max;
 
-			NewtonCollisionCalculateAABB( col-&gt;getNewtonCollision(), matrix, &amp;min.x, &amp;max.x );
+            NewtonCollisionCalculateAABB( col-&gt;getNewtonCollision(), matrix, &amp;min.x, &amp;max.x );
 
-			return Ogre::AxisAlignedBox( min, max );
-		}
+            return Ogre::AxisAlignedBox( min, max );
+        }
 
-	}	// end namespace &quot;CollisionTools&quot;
+    }   // end namespace &quot;CollisionTools&quot;
 
-	namespace Springs
-	{
+    namespace Springs
+    {
 
-		Ogre::Real calculateSpringDamperAcceleration(Ogre::Real deltaTime, Ogre::Real springK,
-						Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity )
-		{
-			return NewtonCalculateSpringDamperAcceleration( deltaTime, springK, stretchDistance, springDamping, dampVelocity );
-		}
-	}
+        Ogre::Real calculateSpringDamperAcceleration(Ogre::Real deltaTime, Ogre::Real springK,
+                        Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity )
+        {
+            return NewtonCalculateSpringDamperAcceleration( deltaTime, springK, stretchDistance, springDamping, dampVelocity );
+        }
+    }
 
 
         namespace OgreAddons

Modified: dependencies/OgreNewt/src/OgreNewt_Vehicle.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Vehicle.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_Vehicle.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -8,155 +8,155 @@
 ////////////////////////////////////////////////////////
 // TIRE FUNCTIONS
 
-	// constructor
-	Vehicle::Tire::Tire( OgreNewt::Vehicle* vehicle, Ogre::Quaternion localorient, Ogre::Vector3 localpos, Ogre::Vector3 pin,
-				Ogre::Real mass, Ogre::Real width, Ogre::Real radius, Ogre::Real susShock, Ogre::Real susSpring, Ogre::Real susLength, int colID)
-	{
-		m_vehicle = vehicle;
-		m_node = NULL;
-		
-		float matrix[16];
+    // constructor
+    Vehicle::Tire::Tire( OgreNewt::Vehicle* vehicle, Ogre::Quaternion localorient, Ogre::Vector3 localpos, Ogre::Vector3 pin,
+                Ogre::Real mass, Ogre::Real width, Ogre::Real radius, Ogre::Real susShock, Ogre::Real susSpring, Ogre::Real susLength, int colID)
+    {
+        m_vehicle = vehicle;
+        m_node = NULL;
+        
+        float matrix[16];
 
-		OgreNewt::Converters::QuatPosToMatrix( localorient, localpos, matrix );
+        OgreNewt::Converters::QuatPosToMatrix( localorient, localpos, matrix );
 
-		m_tireid = NewtonVehicleAddTire ( m_vehicle-&gt;getNewtonVehicle(), matrix, &amp;pin.x, mass, width, radius, 
-		       susShock, susSpring, susLength, this, colID );
+        m_tireid = NewtonVehicleAddTire ( m_vehicle-&gt;getNewtonVehicle(), matrix, &amp;pin.x, mass, width, radius, 
+               susShock, susSpring, susLength, this, colID );
 
-	}
+    }
 
 
-	// destructor
-	Vehicle::Tire::~Tire()
-	{
-		// remove the tire from the vehicle.
-		NewtonVehicleRemoveTire( m_vehicle-&gt;getNewtonVehicle(), m_tireid );
+    // destructor
+    Vehicle::Tire::~Tire()
+    {
+        // remove the tire from the vehicle.
+        NewtonVehicleRemoveTire( m_vehicle-&gt;getNewtonVehicle(), m_tireid );
 
-	}
+    }
 
-	void Vehicle::Tire::updateNode()
-	{
-		if (!m_node)
-			return;
+    void Vehicle::Tire::updateNode()
+    {
+        if (!m_node)
+            return;
 
-		Ogre::Quaternion orient;
-		Ogre::Vector3 pos;
+        Ogre::Quaternion orient;
+        Ogre::Vector3 pos;
 
-		getPositionOrientation( orient, pos );
-		m_node-&gt;setOrientation( orient );
-		m_node-&gt;setPosition( pos );
-	}
+        getPositionOrientation( orient, pos );
+        m_node-&gt;setOrientation( orient );
+        m_node-&gt;setPosition( pos );
+    }
 
-	void Vehicle::Tire::getPositionOrientation( Ogre::Quaternion&amp; orient, Ogre::Vector3&amp; pos )
-	{
-		float matrix[16];
+    void Vehicle::Tire::getPositionOrientation( Ogre::Quaternion&amp; orient, Ogre::Vector3&amp; pos )
+    {
+        float matrix[16];
 
-		NewtonVehicleGetTireMatrix( m_vehicle-&gt;getNewtonVehicle(), m_tireid, matrix );
-		OgreNewt::Converters::MatrixToQuatPos( matrix, orient, pos );
-	}
+        NewtonVehicleGetTireMatrix( m_vehicle-&gt;getNewtonVehicle(), m_tireid, matrix );
+        OgreNewt::Converters::MatrixToQuatPos( matrix, orient, pos );
+    }
 
 
 
 ///////////////////////////////////////////////////////////////////
 // VEHICLE FUNCTIONS
 
-	Vehicle::~Vehicle()
-	{
-		// destroy the joint!
-		if(m_vehicle)
-		{
-			if (NewtonJointGetUserData(m_vehicle))
-			{
-				NewtonJointSetDestructor( m_vehicle, NULL );
-				NewtonDestroyJoint( m_chassis-&gt;getWorld()-&gt;getNewtonWorld(), m_vehicle );
-			}
-		}
-		
-	}
+    Vehicle::~Vehicle()
+    {
+        // destroy the joint!
+        if(m_vehicle)
+        {
+            if (NewtonJointGetUserData(m_vehicle))
+            {
+                NewtonJointSetDestructor( m_vehicle, NULL );
+                NewtonDestroyJoint( m_chassis-&gt;getWorld()-&gt;getNewtonWorld(), m_vehicle );
+            }
+        }
+        
+    }
 
 
 
-	void Vehicle::init( OgreNewt::Body* chassis, const Ogre::Vector3&amp; updir )
-	{
-		// setup the basic vehicle.
-		m_chassis = chassis;
+    void Vehicle::init( OgreNewt::Body* chassis, const Ogre::Vector3&amp; updir )
+    {
+        // setup the basic vehicle.
+        m_chassis = chassis;
 
-		m_vehicle = NewtonConstraintCreateVehicle (chassis-&gt;getWorld()-&gt;getNewtonWorld(), &amp;updir.x, chassis-&gt;getNewtonBody() );
+        m_vehicle = NewtonConstraintCreateVehicle (chassis-&gt;getWorld()-&gt;getNewtonWorld(), &amp;updir.x, chassis-&gt;getNewtonBody() );
 
-		// set the user data
-		NewtonJointSetUserData( m_vehicle, this );
-		NewtonJointSetDestructor( m_vehicle, newtonDestructor );
+        // set the user data
+        NewtonJointSetUserData( m_vehicle, this );
+        NewtonJointSetDestructor( m_vehicle, newtonDestructor );
 
-		//set the tire callback.
-		NewtonVehicleSetTireCallback( m_vehicle, newtonCallback );
+        //set the tire callback.
+        NewtonVehicleSetTireCallback( m_vehicle, newtonCallback );
 
-		//now call the user setup function
-		setup();
+        //now call the user setup function
+        setup();
 
-	}
+    }
 
-	void Vehicle::destroy()
-	{
-		// don't let newton call the destructor.
-		NewtonJointSetDestructor( m_vehicle, NULL );
+    void Vehicle::destroy()
+    {
+        // don't let newton call the destructor.
+        NewtonJointSetDestructor( m_vehicle, NULL );
 
-		// destroy the chassis.
-		if (m_chassis)
-			delete m_chassis;
+        // destroy the chassis.
+        if (m_chassis)
+            delete m_chassis;
 
-		// joint is now destroyed.
-		m_vehicle = NULL;
-	}
+        // joint is now destroyed.
+        m_vehicle = NULL;
+    }
 
-	// get first tire.
-	const OgreNewt::Vehicle::Tire* Vehicle::getFirstTire() const
-	{
-		Vehicle::Tire* tire = NULL;
-		void* id = 0;
+    // get first tire.
+    const OgreNewt::Vehicle::Tire* Vehicle::getFirstTire() const
+    {
+        Vehicle::Tire* tire = NULL;
+        void* id = 0;
 
-		id = NewtonVehicleGetFirstTireID( m_vehicle );
+        id = NewtonVehicleGetFirstTireID( m_vehicle );
 
-		if (id)
-			tire = (Vehicle::Tire*)NewtonVehicleGetTireUserData( m_vehicle, id );
+        if (id)
+            tire = (Vehicle::Tire*)NewtonVehicleGetTireUserData( m_vehicle, id );
 
-		return tire;
-	}
+        return tire;
+    }
 
-	// get next tire.
-	const OgreNewt::Vehicle::Tire* Vehicle::getNextTire( Vehicle::Tire* current_tire ) const
-	{
-		Vehicle::Tire* tire = NULL;
-		void* id = 0;
+    // get next tire.
+    const OgreNewt::Vehicle::Tire* Vehicle::getNextTire( Vehicle::Tire* current_tire ) const
+    {
+        Vehicle::Tire* tire = NULL;
+        void* id = 0;
 
-		id = NewtonVehicleGetNextTireID( m_vehicle, (void*)current_tire-&gt;getNewtonID() );
+        id = NewtonVehicleGetNextTireID( m_vehicle, (void*)current_tire-&gt;getNewtonID() );
 
-		if (id)
-			tire = (Vehicle::Tire*)NewtonVehicleGetTireUserData( m_vehicle, id );
+        if (id)
+            tire = (Vehicle::Tire*)NewtonVehicleGetTireUserData( m_vehicle, id );
 
-		return tire;
-	}
+        return tire;
+    }
 
 
-	// Newton callback.
-	void _CDECL Vehicle::newtonCallback( const NewtonJoint* me )
-	{
-		OgreNewt::Vehicle* vehicle;
+    // Newton callback.
+    void _CDECL Vehicle::newtonCallback( const NewtonJoint* me )
+    {
+        OgreNewt::Vehicle* vehicle;
 
-		vehicle = (Vehicle*)NewtonJointGetUserData( me );
+        vehicle = (Vehicle*)NewtonJointGetUserData( me );
 
-		vehicle-&gt;userCallback();
-	}
+        vehicle-&gt;userCallback();
+    }
 
-	void _CDECL Vehicle::newtonDestructor( const NewtonJoint* me )
-	{
-		Vehicle* vehicle;
+    void _CDECL Vehicle::newtonDestructor( const NewtonJoint* me )
+    {
+        Vehicle* vehicle;
 
-		vehicle = (Vehicle*)NewtonJointGetUserData( me );
+        vehicle = (Vehicle*)NewtonJointGetUserData( me );
 
-		NewtonJointSetDestructor( me, NULL );
-		NewtonJointSetUserData( me, NULL );
+        NewtonJointSetDestructor( me, NULL );
+        NewtonJointSetUserData( me, NULL );
 
-		delete vehicle;
-	}
+        delete vehicle;
+    }
 
 
 
@@ -175,5 +175,5 @@
 #endif
 
 
-}	// end NAMESPACE OgreNewt
+}   // end NAMESPACE OgreNewt
 

Modified: dependencies/OgreNewt/src/OgreNewt_World.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_World.cpp	2009-03-16 18:17:28 UTC (rev 4837)
+++ dependencies/OgreNewt/src/OgreNewt_World.cpp	2009-03-17 13:36:05 UTC (rev 4838)
@@ -11,78 +11,78 @@
     m_bodyInAABBIterator(this),
     m_debugger(this)
 {
-	m_limits = Ogre::AxisAlignedBox(Ogre::Vector3(-100,-100,-100), Ogre::Vector3(100,100,100));
+    m_limits = Ogre::AxisAlignedBox(Ogre::Vector3(-100,-100,-100), Ogre::Vector3(100,100,100));
 
-	m_world = NewtonCreate( NULL, NULL );
+    m_world = NewtonCreate( NULL, NULL );
 
-	if (!m_world)
-	{
-		// world not created!
-	}
+    if (!m_world)
+    {
+        // world not created!
+    }
 
-	NewtonWorldSetUserData( m_world, this );
+    NewtonWorldSetUserData( m_world, this );
 
-	// create the default ID.
-	m_defaultMatID = new OgreNewt::MaterialID( this, NewtonMaterialGetDefaultGroupID( m_world ) );
+    // create the default ID.
+    m_defaultMatID = new OgreNewt::MaterialID( this, NewtonMaterialGetDefaultGroupID( m_world ) );
 
-	m_leaveCallback = NULL;
+    m_leaveCallback = NULL;
 }
 
 // Destructor
 World::~World()
 {
-	if (m_defaultMatID)
-		delete m_defaultMatID;
+    if (m_defaultMatID)
+        delete m_defaultMatID;
 
-	if (m_world)
-		NewtonDestroy( m_world );
+    if (m_world)
+        NewtonDestroy( m_world );
 }
 
 // update
 void World::update( Ogre::Real t_step )
 {
-	NewtonUpdate( m_world, (float)t_step );
+    NewtonUpdate( m_world, (float)t_step );
 }
 
 void World::setWorldSize( const Ogre::Vector3&amp; min, const Ogre::Vector3&amp; max )
 {
-	NewtonSetWorldSize( m_world, (float*)&amp;min.x, (float*)&amp;max.x );
-	m_limits = Ogre::AxisAlignedBox(min, max);
+    NewtonSetWorldSize( m_world, (float*)&amp;min.x, (float*)&amp;max.x );
+    m_limits = Ogre::AxisAlignedBox(min, max);
 }
 
 void World::setWorldSize( const Ogre::AxisAlignedBox&amp; box )
 {
-	NewtonSetWorldSize( m_world, (float*)&amp;box.getMinimum(), (float*)&amp;box.getMaximum() );
-	m_limits = box;
+    NewtonSetWorldSize( m_world, (float*)&amp;box.getMinimum(), (float*)&amp;box.getMaximum() );
+    m_limits = box;
 }
 
 void World::setLeaveWorldCallback( LeaveWorldCallback callback )
 {
-	if (!m_leaveCallback)
-	{
-		NewtonSetBodyLeaveWorldEvent( m_world, World::newtonLeaveWorld );
-	}
+    if (!m_leaveCallback)
+    {
+        NewtonSetBodyLeaveWorldEvent( m_world, World::newtonLeaveWorld );
+    }
 
-	if (callback)
-	{
-		m_leaveCallback = callback;
-	}
-	else
-	{
-		NewtonSetBodyLeaveWorldEvent( m_world, NULL );
-		m_leaveCallback = NULL;
-	}
+    if (callback)
+    {
+        m_leaveCallback = callback;
+    }
+    else
+    {
+        NewtonSetBodyLeaveWorldEvent( m_world, NULL );
+        m_leaveCallback = NULL;
+    }
 }
 
 void _CDECL World::newtonLeaveWorld( const NewtonBody* body, int threadIndex )
 {
-	OgreNewt::World* me = (OgreNewt::World*)NewtonWorldGetUserData( NewtonBodyGetWorld( body ) );
+    OgreNewt::World* me = (OgreNewt::World*)NewtonWorldGetUserData( NewtonBodyGetWorld( body ) );
 
-	if (me-&gt;m_leaveCallback)
-	{
-		OgreNewt::Body* b = (OgreNewt::Body*)NewtonBodyGetUserData( body );
-		me-&gt;m_leaveCallback( b, threadIndex );
-	}
+    if (me-&gt;m_leaveCallback)
+    {
+        OgreNewt::Body* b = (OgreNewt::Body*)NewtonBodyGetUserData( body );
+        me-&gt;m_leaveCallback( b, threadIndex );
+    }
 }
 
 Body* World::getFirstBody() const


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001894.html">[Dsa-hl-svn] r4837 - in rl/trunk/editors/Lockenwickler/src: .	media/icons
</A></li>
	<LI>Next message: <A HREF="001896.html">[Dsa-hl-svn] r4839 - rl/trunk/editors/Lockenwickler/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1895">[ date ]</a>
              <a href="thread.html#1895">[ thread ]</a>
              <a href="subject.html#1895">[ subject ]</a>
              <a href="author.html#1895">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
