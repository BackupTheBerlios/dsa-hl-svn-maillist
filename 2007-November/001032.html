<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3961 - modules/common/scripts	modules/regressiontest/dialogs modules/regressiontest/dsa	rl/trunk rl/trunk/engine/ai rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/common/include	rl/trunk/engine/common/src rl/trunk/engine/core/include	rl/trunk/engine/rules/src rl/trunk/engine/script/swig	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3961%20-%20modules/common/scripts%0A%09modules/regressiontest/dialogs%20modules/regressiontest/dsa%0A%09rl/trunk%20rl/trunk/engine/ai%20rl/trunk/engine/ai/include%0A%09rl/trunk/engine/ai/src%20rl/trunk/engine/common/include%0A%09rl/trunk/engine/common/src%20rl/trunk/engine/core/include%0A%09rl/trunk/engine/rules/src%20rl/trunk/engine/script/swig%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src&In-Reply-To=%3C200711041324.lA4DOrcw025036%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001031.html">
   <LINK REL="Next"  HREF="001033.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3961 - modules/common/scripts	modules/regressiontest/dialogs modules/regressiontest/dsa	rl/trunk rl/trunk/engine/ai rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/common/include	rl/trunk/engine/common/src rl/trunk/engine/core/include	rl/trunk/engine/rules/src rl/trunk/engine/script/swig	rl/trunk/engine/ui/include rl/trunk/engine/ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3961%20-%20modules/common/scripts%0A%09modules/regressiontest/dialogs%20modules/regressiontest/dsa%0A%09rl/trunk%20rl/trunk/engine/ai%20rl/trunk/engine/ai/include%0A%09rl/trunk/engine/ai/src%20rl/trunk/engine/common/include%0A%09rl/trunk/engine/common/src%20rl/trunk/engine/core/include%0A%09rl/trunk/engine/rules/src%20rl/trunk/engine/script/swig%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src&In-Reply-To=%3C200711041324.lA4DOrcw025036%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3961 - modules/common/scripts	modules/regressiontest/dialogs modules/regressiontest/dsa	rl/trunk rl/trunk/engine/ai rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/common/include	rl/trunk/engine/common/src rl/trunk/engine/core/include	rl/trunk/engine/rules/src rl/trunk/engine/script/swig	rl/trunk/engine/ui/include rl/trunk/engine/ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sun Nov  4 14:24:53 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001031.html">[Dsa-hl-svn] r3960 - modules/kanalisation/maps
</A></li>
        <LI>Next message: <A HREF="001033.html">[Dsa-hl-svn] r3962 - in rl/trunk/engine: ai/include ai/src ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1032">[ date ]</a>
              <a href="thread.html#1032">[ thread ]</a>
              <a href="subject.html#1032">[ subject ]</a>
              <a href="author.html#1032">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2007-11-04 14:24:21 +0100 (Sun, 04 Nov 2007)
New Revision: 3961

Added:
   modules/regressiontest/dialogs/testdialog.dialog
   rl/trunk/engine/ai/include/Dialog.h
   rl/trunk/engine/ai/include/DialogCondition.h
   rl/trunk/engine/ai/include/DialogElement.h
   rl/trunk/engine/ai/include/DialogImplication.h
   rl/trunk/engine/ai/include/DialogManager.h
   rl/trunk/engine/ai/include/DialogParagraph.h
   rl/trunk/engine/ai/include/DialogVariable.h
   rl/trunk/engine/ai/src/Dialog.cpp
   rl/trunk/engine/ai/src/DialogCondition.cpp
   rl/trunk/engine/ai/src/DialogElement.cpp
   rl/trunk/engine/ai/src/DialogImplication.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/DialogParagraph.cpp
   rl/trunk/engine/ai/src/DialogVariable.cpp
Removed:
   rl/trunk/engine/ai/include/AimlNodeImplRl.h
   rl/trunk/engine/ai/include/AimlParserImplRl.h
   rl/trunk/engine/ai/include/ContextConditionProcessor.h
   rl/trunk/engine/ai/include/ContextInterpreter.h
   rl/trunk/engine/ai/include/DialogCharacter.h
   rl/trunk/engine/ai/include/DialogScriptProcessor.h
   rl/trunk/engine/ai/include/predicates/
   rl/trunk/engine/ai/src/AimlNodeImplRl.cpp
   rl/trunk/engine/ai/src/AimlParserImplRl.cpp
   rl/trunk/engine/ai/src/ContextConditionProcessor.cpp
   rl/trunk/engine/ai/src/ContextInterpreter.cpp
   rl/trunk/engine/ai/src/DialogCharacter.cpp
   rl/trunk/engine/ai/src/DialogScriptProcessor.cpp
   rl/trunk/engine/ai/src/predicates/
Modified:
   modules/common/scripts/npc.rb
   modules/common/scripts/steering.rb
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   rl/trunk/configure.in
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/AgentDialogState.h
   rl/trunk/engine/ai/include/AiMessages.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/DialogOption.h
   rl/trunk/engine/ai/include/DialogResponse.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/DialogOption.cpp
   rl/trunk/engine/ai/src/DialogResponse.cpp
   rl/trunk/engine/ai/src/Makefile.am
   rl/trunk/engine/common/include/Property.h
   rl/trunk/engine/common/src/Property.cpp
   rl/trunk/engine/core/include/SaveGameFileReader.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/ui/include/DialogControlState.h
   rl/trunk/engine/ui/include/DialogWindow.h
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Initial commit of new dialog system (still some open issues)

Modified: modules/common/scripts/npc.rb
===================================================================
--- modules/common/scripts/npc.rb	2007-11-04 10:12:14 UTC (rev 3960)
+++ modules/common/scripts/npc.rb	2007-11-04 13:24:21 UTC (rev 3961)
@@ -6,23 +6,17 @@
   end
 
   def doAction(object, actor, target)
-    bot = $AI.getBot(object.getName())
-    if (bot.nil?)
-      bot = $AI.loadBot(object.getName(), object.getDialogfile())
-    end
-    if ( not bot.nil? )
-      bot.setPlayerCharacter( actor );
-      bot.setNonPlayerCharacter( object );
+    dialog = DialogManager::getSingleton().createDialog(object.getDialog(), object, actor)  
 	  agent = AgentManager::getSingleton().createAgent(object)
 	  agent.pushState(RlScript::AST_DIALOG);
 	  agent.getCurrentState().setDialogPartner(
-		AgentManager::getSingleton().createAgent(actor))
-    end
+  		AgentManager::getSingleton().createAgent(actor))
+    agent.getCurrentState().setDialog(dialog);
   end
 end
 
 module TalkTarget
-  @mDialogfile;
+  @mDialog;
 
   def initialize(id)
     super(id)
@@ -30,15 +24,15 @@
   end
 
   def setProperty(key, value)
-    if (key == &quot;dialogfile&quot;)
-      @mDialogfile = value;
+    if (key == &quot;dialog&quot;)
+      @mDialog = value;
     else
       super(key, value)
     end
   end
 
-  def getDialogfile()
-    return @mDialogfile;
+  def getDialog()
+    return @mDialog;
   end
 end
 

Modified: modules/common/scripts/steering.rb
===================================================================
--- modules/common/scripts/steering.rb	2007-11-04 10:12:14 UTC (rev 3960)
+++ modules/common/scripts/steering.rb	2007-11-04 13:24:21 UTC (rev 3961)
@@ -105,7 +105,6 @@
 	
 	def activate()
 		$SCRIPT.log(&quot;Activate DialogSteering&quot;);
-		getController().setAnimation(&quot;gehen&quot;);
 	end
 		
 	def update(elapsedTime)
@@ -151,7 +150,6 @@
 	
 	def activate()
 		$SCRIPT.log(&quot;Activate DialogSteering&quot;);
-		getController().setAnimation(&quot;gehen&quot;);
 	end
 		
 	def update(elapsedTime)

Added: modules/regressiontest/dialogs/testdialog.dialog
===================================================================
--- modules/regressiontest/dialogs/testdialog.dialog	2007-11-04 10:12:14 UTC (rev 3960)
+++ modules/regressiontest/dialogs/testdialog.dialog	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,74 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
+&lt;dialog name=&quot;testdialog&quot;&gt;
+	&lt;variable name=&quot;geheimnisbekannt&quot; type=&quot;BOOL&quot; data=&quot;false&quot;/&gt;
+	
+	&lt;start&gt;
+		&lt;response id=&quot;0&quot;&gt;Du solltest mir nur drohen, wenn Geheimnisbekannt true ist. Geheimnisbekannt ist momentan {$geheimnisbekannt}.
+			&lt;option id=&quot;1&quot; label=&quot;Abstraktionstext&quot;&gt;Selectiontext; nach dem Auswahlklick angezeigt. Jetzt gehts zu Pattern 2.
+				&lt;response id=&quot;2&quot;&gt;
+					&lt;p&gt;Dies ist Pattern 2&lt;/p&gt;
+					&lt;p&gt;Dies ist der zweite Text von Pattern 2&lt;/p&gt;
+					&lt;option id=&quot;3&quot;&gt;Zu Pattern 1.
+						&lt;gotoresponse id=&quot;0&quot;/&gt;
+					&lt;/option&gt;
+				&lt;/response&gt;
+			&lt;/option&gt;
+			&lt;switchoption id=&quot;4&quot;&gt;[Dem NSC drohen]
+				&lt;dialogvariable name=&quot;geheimnisbekannt&quot;/&gt;
+				&lt;case&gt;&lt;equals value=&quot;false&quot;/&gt;
+					&lt;option id=&quot;5&quot;&gt;Ich drohe dir, kenne aber dein Geheimnis nicht!
+						&lt;gotoresponse id=&quot;10&quot;/&gt;
+					&lt;/option&gt;
+				&lt;/case&gt;
+				&lt;case&gt;&lt;equals value=&quot;true&quot;/&gt;
+					&lt;option id=&quot;6&quot;&gt;Ich drohe dir und kenne dein schreckliches Geheimnis!
+						&lt;response id=&quot;19&quot;&gt;Oh nein! Ich gebe auf! Du darfst ins Men&#195;&#188; zur&#195;&#188;ck!
+							&lt;option id=&quot;20&quot;&gt;Tja, Informiertheit ist alles. Gut, dass ich das Tutorial zu dem Thema gelesen habe. Danke, Steele.
+								&lt;gotoresponse id=&quot;0&quot;/&gt;
+							&lt;/option&gt;
+						&lt;/response&gt;
+					&lt;/option&gt;
+				&lt;/case&gt;
+			&lt;/switchoption&gt;
+			&lt;option id=&quot;11&quot;&gt;Ich werde dein Geheimnis dem Alrik Fa&#195;&#159;bauer erz&#195;&#164;hlen.
+				&lt;if&gt;&lt;dialogvariable name=&quot;geheimnisbekannt&quot;/&gt;&lt;equals value=&quot;true&quot;/&gt;&lt;/if&gt;
+				&lt;response id=&quot;12&quot;&gt;
+					&lt;p&gt;Oh, nein, nicht dem Alrik! *heul*&lt;/p&gt;
+					&lt;gotoresponse id=&quot;0&quot;/&gt;
+				&lt;/response&gt;
+			&lt;/option&gt;
+			&lt;option id=&quot;13&quot;&gt;Morgen bin ich zum Kaffeetrinken beim Alrik eingeladen
+				&lt;if&gt;&lt;dialogvariable name=&quot;geheimnisbekannt&quot;/&gt;&lt;equals value=&quot;false&quot;/&gt;&lt;/if&gt;
+				&lt;response id=&quot;14&quot;&gt;
+					&lt;p&gt;Ja, der Alrik ist ein netter Mensch.&lt;/p&gt;
+					&lt;gotoresponse id=&quot;0&quot;/&gt;
+				&lt;/response&gt;				
+			&lt;/option&gt;
+			&lt;option id=&quot;7&quot;&gt;Wie lautet das Geheimnis?
+				&lt;switchresponse id=&quot;18&quot;&gt;
+					&lt;dialogvariable name=&quot;geheimnisbekannt&quot;/&gt;
+					&lt;case&gt;&lt;equals value=&quot;false&quot;/&gt;
+						&lt;response id=&quot;8&quot;&gt;Mein Geheimnis ist: Ich kann keine Geheimnisse behalten! *schluchz*
+							&lt;setvariable name=&quot;geheimnisbekannt&quot; value=&quot;true&quot;/&gt;
+							&lt;option id=&quot;9&quot;&gt;Har har har... Na warte, Freundchen!
+								&lt;gotoresponse id=&quot;0&quot;/&gt;
+							&lt;/option&gt;
+						&lt;/response&gt;
+					&lt;/case&gt;
+					&lt;case&gt;&lt;equals value=&quot;true&quot;/&gt;
+						&lt;response id=&quot;17&quot;&gt;
+							&lt;p&gt;Du kennst mein Geheimnis doch schon l&#195;&#164;ngst!&lt;/p&gt;
+							&lt;gotoresponse id=&quot;0&quot;/&gt;
+						&lt;/response&gt;
+					&lt;/case&gt;
+				&lt;/switchresponse&gt;
+			&lt;/option&gt;
+		&lt;/response&gt;
+	&lt;/start&gt;
+	
+	&lt;response id=&quot;10&quot;&gt;Dann musst du sterben! (bzw. den Dialog verlassen)
+		&lt;option id=&quot;15&quot;&gt;Ok ... schade
+			&lt;response id=&quot;16&quot;&gt;&lt;exit/&gt;&lt;/response&gt;
+		&lt;/option&gt;
+	&lt;/response&gt;
+&lt;/dialog&gt;
\ No newline at end of file

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-11-04 10:12:14 UTC (rev 3960)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-11-04 13:24:21 UTC (rev 3961)
@@ -27,7 +27,7 @@
         &lt;property name=&quot;geometrytype&quot; type=&quot;STRING&quot; data=&quot;ellipsoid&quot;/&gt;
         &lt;property name=&quot;meshfile&quot; type=&quot;STRING&quot; data=&quot;men_alrike.mesh&quot;/&gt;
         &lt;property name=&quot;mass&quot; type=&quot;REAL&quot; data=&quot;65&quot;/&gt;
-        &lt;property name=&quot;dialogfile&quot; type=&quot;STRING&quot; data=&quot;testperson.xml&quot;/&gt;
+        &lt;property name=&quot;dialog&quot; type=&quot;STRING&quot; data=&quot;testdialog&quot;/&gt;
         &lt;property name=&quot;behaviours&quot; type=&quot;ARRAY&quot;&gt;
             &lt;property type=&quot;STRING&quot; data=&quot;DefaultIdleBehaviour&quot;/&gt;
             &lt;property type=&quot;STRING&quot; data=&quot;DialogBehaviour&quot;/&gt;

Modified: rl/trunk/configure.in
===================================================================
--- rl/trunk/configure.in	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/configure.in	2007-11-04 13:24:21 UTC (rev 3961)
@@ -95,7 +95,6 @@
 
 dnl Other stuff we need
 AC_CHECK_PROG(HAVE_DOXYGEN_PROG, doxygen, `which doxygen`, false)
-AC_CHECK_LIB([MadaBot], [main], [], AC_MSG_ERROR([Can't find libMadaBot]))
 
 # Newton
 AC_CHECK_LIB([Newton], [fopen], [], AC_MSG_ERROR([Can't find libNewton]) )

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
 &lt;VisualStudioProject
 	ProjectType=&quot;Visual C++&quot;
-	Version=&quot;8,00&quot;
+	Version=&quot;8.00&quot;
 	Name=&quot;RlAI&quot;
 	ProjectGUID=&quot;{C3E78B89-587B-499A-BE7D-4FE8564F0CD7}&quot;
 	RootNamespace=&quot;RlAI&quot;
@@ -315,14 +315,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\AimlNodeImplRl.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
-				RelativePath=&quot;.\src\AimlParserImplRl.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\src\AiSubsystem.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -351,31 +343,43 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\ContextConditionProcessor.cpp&quot;
+				RelativePath=&quot;.\src\CreatureWalkPathJob.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\ContextInterpreter.cpp&quot;
+				RelativePath=&quot;.\src\Dialog.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\CreatureWalkPathJob.cpp&quot;
+				RelativePath=&quot;.\src\DialogCondition.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\DialogCharacter.cpp&quot;
+				RelativePath=&quot;.\src\DialogElement.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\DialogImplication.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\src\DialogManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\DialogOption.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\DialogParagraph.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\DialogResponse.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\DialogScriptProcessor.cpp&quot;
+				RelativePath=&quot;.\src\DialogVariable.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
@@ -438,50 +442,6 @@
 				RelativePath=&quot;.\src\WayPointNode.cpp&quot;
 				&gt;
 			&lt;/File&gt;
-			&lt;Filter
-				Name=&quot;predicates&quot;
-				&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\CreaturePredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\EigenschaftsProbePredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\EigenschaftsWertPredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\GrundWertPredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\QuestKnownPredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\QuestPartsPredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\QuestStatePredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\ScriptPredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\TalentProbePredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\src\predicates\TalentWertPredicates.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-			&lt;/Filter&gt;
 		&lt;/Filter&gt;
 		&lt;Filter
 			Name=&quot;Headerdateien&quot;
@@ -517,14 +477,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\AimlNodeImplRl.h&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
-				RelativePath=&quot;.\include\AimlParserImplRl.h&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\include\AiPrerequisites.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -557,31 +509,43 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\ContextConditionProcessor.h&quot;
+				RelativePath=&quot;.\include\CreatureWalkPathJob.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\ContextInterpreter.h&quot;
+				RelativePath=&quot;.\include\Dialog.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\CreatureWalkPathJob.h&quot;
+				RelativePath=&quot;.\include\DialogCondition.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\DialogCharacter.h&quot;
+				RelativePath=&quot;.\include\DialogElement.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\DialogImplication.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\DialogManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\DialogOption.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\DialogParagraph.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\DialogResponse.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\DialogScriptProcessor.h&quot;
+				RelativePath=&quot;.\include\DialogVariable.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
@@ -632,50 +596,6 @@
 				RelativePath=&quot;.\include\WayPointNode.h&quot;
 				&gt;
 			&lt;/File&gt;
-			&lt;Filter
-				Name=&quot;predicates&quot;
-				&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\CreaturePredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\EigenschaftsProbePredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\EigenschaftsWertPredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\GrundWertPredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\QuestKnownPredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\QuestPartsPredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\QuestStatePredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\ScriptPredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\TalentProbePredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;.\include\predicates\TalentWertPredicates.h&quot;
-					&gt;
-				&lt;/File&gt;
-			&lt;/Filter&gt;
 		&lt;/Filter&gt;
 		&lt;Filter
 			Name=&quot;Ressourcendateien&quot;

Modified: rl/trunk/engine/ai/include/AgentDialogState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentDialogState.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/AgentDialogState.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -21,6 +21,7 @@
 
 namespace rl
 {
+    class Dialog;
 
     class _RlAiExport AgentDialogState :
         public AgentState
@@ -31,9 +32,11 @@
 
         virtual void update(const Ogre::Real elapsedTime);
         void setDialogPartner(Agent* partner);
+        void setDialog(Dialog* dialog);
 
     private:
         Agent* mPartner;
+        Dialog* mDialog;
         bool mTalking;
     };
 

Modified: rl/trunk/engine/ai/include/AiMessages.h
===================================================================
--- rl/trunk/engine/ai/include/AiMessages.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/AiMessages.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -22,7 +22,7 @@
 
 namespace rl
 {
-    class DialogCharacter;
+    class Dialog;
 
     enum AiMessageTypeIds
     {
@@ -35,7 +35,7 @@
     };
 
     /// Message sent when a dialog with the player will be started
-    typedef MessageType&lt;RLMSG_CONTROLLERS_DIALOG_STARTED/*, DialogCharacter* */&gt; 
+    typedef MessageType&lt;RLMSG_CONTROLLERS_DIALOG_STARTED, Dialog*&gt; 
         MessageType_DialogStarted;
 }
 

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -21,21 +21,14 @@
 #include &quot;AiPrerequisites.h&quot;
 
 #include &quot;MessagePump.h&quot;
-#include &quot;XmlProcessor.h&quot;
 #include &quot;World.h&quot;
 
-namespace MadaBot
-{
-	template &lt;class S&gt; class AimlCore;
-}
-
 namespace rl
 {
 	class Agent;
 	class AgentManager;
 	class AiWorld;
-	class ContextInterpreter;
-	class DialogCharacter;
+    class DialogManager;
 	class Landmark;
 	class LandmarkPath;
 	class WayPointGraphManager;
@@ -45,8 +38,7 @@
 	 * Handles creation of all AI related object Managers.
 	 */
 	class _RlAiExport AiSubsystem 
-        : public Ogre::Singleton&lt;AiSubsystem&gt;,
-        private XmlProcessor
+        : public Ogre::Singleton&lt;AiSubsystem&gt;
 	{
 	public:
 		//! default constructor
@@ -84,44 +76,7 @@
 
 		Landmark* getLandmark(const Ogre::String&amp; name) const;
 
-		/**
-		 * Get the bot with the given name
-		 * @return the bot or NULL if the bot does not exist
-		 */
-		DialogCharacter* getBot(const CeGuiString&amp; botName);
-
-		ContextInterpreter* getContextInterpreter();
-
-		/**
-		 * Load a DialogCharacter from a xml file
-		 * If no name is given, the first available bot in the xml file is loaded
-		 * @param fileName xml file with the bot definition
-		 * @param botName name of the bot to load
-		 * @return will return a DialogCharacter...
-		 */
-		DialogCharacter* loadBot(const CeGuiString&amp; botName, const CeGuiString&amp; fileName = &quot;&quot;);
-	
-        /**
-         * Helper function, that retrieves an xml resource from its file name
-         * If resource not yet created, it gets first searched in the current
-         * adventure module group, then in the default group.
-         */
-        Ogre::ResourcePtr getXmlResource(const Ogre::String&amp; filename);
-
-		/**
-		 * Set the DialogCharacter loaded from ruby
-		 */
-		void setCurrentDialogCharacter(DialogCharacter* bot);
-		DialogCharacter* getCurrentDialogCharacter() const;
-
 	private:
-		typedef std::map&lt;CeGuiString, DialogCharacter*&gt; BotMap;
-		typedef MadaBot::AimlCore&lt;CeGuiString&gt; AimlCore; 
-		BotMap mBots;
-		AimlCore* mCore;
-		ContextInterpreter* mContextInterpreter;
-		DialogCharacter* mCurrentBot;
-
         /** Initializes the AI subsystem.
 		 * Creates AiWorld and AgentManager, registers a scene listener,
 		 * adds the AgentManager to the GameLoop as a task.
@@ -147,6 +102,8 @@
 		//! AiWorld representation - WIP!!! (object to changes)
 		AiWorld* mWorld;
 
+        DialogManager* mDialogManager;
+
 		std::map&lt;Ogre::String, LandmarkPath*&gt; mLandmarkPaths;
 		std::map&lt;Ogre::String, Landmark*&gt; mLandmarks;
 
@@ -154,11 +111,6 @@
 	    MessagePump::ScopedConnection mSceneClearingConnection;
 	};
 
-	inline ContextInterpreter* AiSubsystem::getContextInterpreter()
-	{
-		return mContextInterpreter;
-	}
-
     inline AiWorld* AiSubsystem::getWorld()
 	{
 		return mWorld;

Deleted: rl/trunk/engine/ai/include/AimlNodeImplRl.h
===================================================================
--- rl/trunk/engine/ai/include/AimlNodeImplRl.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/AimlNodeImplRl.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,47 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __Rl_AimlNodeImplRl_H__
-#define __Rl_AimlNodeImplRl_H__
-
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;AimlNode.h&quot;
-
-#include &quot;XmlProcessor.h&quot;
-
-using namespace MadaBot;
-namespace rl
-{
-	XERCES_CPP_NAMESPACE_USE
-	class XERCES_CPP_NAMESPACE::DOMNode;
-
-    /**
-     * Implementation of the XmlNode interface for AIML files in Rastullahs Lockenpracht
-     */
-	class AimlNodeImplRl 
-        :   public AimlNode&lt;CeGuiString&gt;,
-            private XmlProcessor
-	{
-	public:
-		AimlNodeImplRl(DOMNode* node);
-		virtual ~AimlNodeImplRl(void);
-	//	void setNodeValue(const XmlString&amp; v){}
-
-		bool isElement(){ return false;}
-
-	private:
-	};
-}
-#endif

Deleted: rl/trunk/engine/ai/include/AimlParserImplRl.h
===================================================================
--- rl/trunk/engine/ai/include/AimlParserImplRl.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/AimlParserImplRl.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,42 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __Rl_AimlParserImplRl_H__
-#define __Rl_AimlParserImplRl_H__
-
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;XmlMapper/XmlParser.h&quot;
-
-#include &lt;OgreResource.h&gt;
-
-using namespace XmlMapper;
-
-namespace rl
-{
-    /**
-     * Implementation of the XmlParser interface for AIML files in Rastullahs Lockenpracht
-     */
-	class AimlParserImplRl : public XmlParser&lt;CeGuiString&gt;
-	{
-	public:
-		virtual ~AimlParserImplRl();
-		
-		virtual XmlDocument&lt;CeGuiString&gt;* parse(const CeGuiString&amp; fileName);
-
-	private:
-		Ogre::ResourcePtr getXmlResource(const CeGuiString&amp; fileName);
-	};
-}
-#endif

Deleted: rl/trunk/engine/ai/include/ContextConditionProcessor.h
===================================================================
--- rl/trunk/engine/ai/include/ContextConditionProcessor.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/ContextConditionProcessor.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,60 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __Rl_ContextConditionProcessor_H__
-#define __Rl_ContextConditionProcessor_H__
-
-#include &quot;XmlMapper/XmlNodeProcessor.h&quot;
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;AimlBot.h&quot;
-
-using namespace XmlMapper;
-using namespace MadaBot;
-
-namespace rl
-{
-    /**
-     * Special ConditionProcessor for processing conditions that are a ChildNode
-     * of a specific gossip context
-     */
-	class ContextConditionProcessor 
-		: public XmlNodeProcessor&lt;Response, AimlBot, CeGuiString, false&gt;
-	{
-	public:
-		ContextConditionProcessor(void); 
-		virtual ~ContextConditionProcessor(void);
-		
-        /**
-         * Get the needed Predicates of an AimlBot for preparing the processing of a 
-         * condition
-         */
-		virtual void preprocessStep();
-
-        /**
-         * Evaluates every ChildNode of the condition if it is a ListItem (&lt;li&gt;)
-         */
-		virtual void processChildStep(XmlNode&lt;CeGuiString&gt;* pChild);
-
-        /**
-         * Not used in this processor
-         */
-		virtual void postprocessStep();
-	protected:
-		virtual void initialize();
-		CeGuiString mPredicateValue;
-		CeGuiString mNodeValue;
-	};
-}
-#endif

Deleted: rl/trunk/engine/ai/include/ContextInterpreter.h
===================================================================
--- rl/trunk/engine/ai/include/ContextInterpreter.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/ContextInterpreter.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,71 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __Rl_AimlContextInterpreter_H__
-#define __Rl_AimlContextInterpreter_H__
-
-#include &quot;AimlInterpreter.h&quot;
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;DialogResponse.h&quot;
-using namespace MadaBot;
-
-namespace rl
-{
-	/**
-	 * Uses the AIML element &quot;gossip&quot; to interpret the childNodes in a 
-	 * specific context for dialog options/selections/responses
-	 * 
-	 */
-	class ContextInterpreter
-		: public AimlInterpreter&lt;CeGuiString&gt;
-	{
-	public:
-		ContextInterpreter(void);
-		virtual ~ContextInterpreter(void);
-
-		DialogResponse* interpret(const Response&lt;CeGuiString&gt;::GossipData&amp; pData, AimlBot&lt;CeGuiString&gt;* pProcessHelper=NULL);
-		virtual Response&lt;CeGuiString&gt; process(XmlNode&lt;CeGuiString&gt;* pNode, AimlBot&lt;CeGuiString&gt;* pProcessHelper=NULL);
-		
-		void processResponse();
-		void processOption();
-		void processSelection();
-	protected:
-		virtual void initialize();
-		AimlBot&lt;CeGuiString&gt;* mBot;
-
-		CeGuiString mCurrentType;
-		DialogResponse::Responses mResponses;
-		DialogResponse::DialogOptions mOptions;
-
-		static CeGuiString INTERPRETER_NAME;
-		static CeGuiString RL_TYPE;
-		static CeGuiString RL_LI_ID;
-		static CeGuiString RL_PATTERN_REF;
-		static CeGuiString RL_E_PROBE;
-		static CeGuiString RL_E_MODIFIER;
-		static CeGuiString RL_T_PROBE;
-		static CeGuiString RL_T_MODIFIER;
-		static CeGuiString RL_RESPONSE;
-		static CeGuiString RL_OPTION;
-		static CeGuiString RL_SELECTION;
-		static CeGuiString AIML_CONDITION;
-		static CeGuiString AIML_TYPE;
-		static CeGuiString AIML_GOSSIP;
-		static CeGuiString AIML_LI;
-
-		
-	};
-}
-#endif

Added: rl/trunk/engine/ai/include/Dialog.h
===================================================================
--- rl/trunk/engine/ai/include/Dialog.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/Dialog.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,54 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __Dialog_H__
+#define __Dialog_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+#include &quot;Properties.h&quot;
+
+namespace rl
+{
+    class DialogOption;
+    class DialogResponse;
+    class GameObject;
+
+    class _RlAiExport Dialog : public PropertyHolder
+    {
+    public:
+        Dialog(GameObject* pc, GameObject* npc);
+        ~Dialog();
+
+        DialogResponse* getDialogStart() const;
+        void setStartResponse(DialogResponse* start);
+        void initialize();
+        GameObject* getNpc(int id) const;
+        GameObject* getPc(int id) const;
+
+        virtual const Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const Property&amp; value);
+        virtual PropertyRecord* getAllProperties() const;
+
+    private:
+        DialogResponse* mDialogStart;
+        std::vector&lt;GameObject*&gt; mNonPlayerCharacters;
+        std::vector&lt;GameObject*&gt; mPlayerCharacters;
+        PropertyRecord mPropertyVariables;
+    };
+
+}
+
+#endif // __Dialog_H__

Deleted: rl/trunk/engine/ai/include/DialogCharacter.h
===================================================================
--- rl/trunk/engine/ai/include/DialogCharacter.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogCharacter.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,162 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __Rl_DialogCharacter_H__
-#define __Rl_DialogCharacter_H__
-
-#include &quot;AiPrerequisites.h&quot;
-//#include &quot;DialogListener.h&quot;
-
-namespace MadaBot
-{
-	template &lt;class S&gt; class AimlBot;
-	template &lt;class S&gt; class Predicates;
-}
-using namespace MadaBot;
-
-namespace rl
-{
-	class Creature;
-	class DialogResponse;
-
-    /**
-     * Representation of a Character that is able to respond in a Dialog
-     * @todo Art der Erstellung &#228;ndern, das ist zu kompliziert.
-     */
-	class _RlAiExport DialogCharacter 
-	{
-	public:
-		DialogCharacter();
-	//	DialogCharacter(const CeGuiString&amp; name);
-		virtual ~DialogCharacter(void);
-
-		const CeGuiString getName() const;
-
-		Predicates&lt;CeGuiString&gt;* getPredicates(const CeGuiString&amp; pType);
-
-		// deprecated
-		Creature* getDialogCharacter() const;
-		void setDialogCharacter(Creature* dialogCharacter);
-		Creature* getDialogPartner() const;
-		void setDialogPartner(Creature* dialogPartner);
-
-		void initialize();
-		/**
-		 * SHOULD NOT BE CALLED IN PUBLIC
-		 * set the dialogbot, this is done in DialogSubsystem/AimlCore
-		 */
-		void setBot(AimlBot&lt;CeGuiString&gt;* bot);
-        
-        bool hasExitRequest() const;
-/*		void addDialogListener(DialogListener* listener);
-		void removeDialogListener(DialogListener* listener);
-		void updateDialogListeners(DialogListener::DialogEvent e);
-*/
-		Creature* getNonPlayerCharacter() const;
-		void setNonPlayerCharacter(Creature* npc);
-
-		Creature* getPlayerCharacter() const;
-		void setPlayerCharacter(Creature* pc);
-
-		// not used in script, thereby it can return a reference
-		const CeGuiString&amp; getVoiceFile() const;
-		void setVoiceFile(const CeGuiString&amp; filename);
-
-		/**
-		 * calculation of special condition values
-		 * should have a second parameter &quot;patternValue&quot;
-		 */
-		virtual int calcOptionValue(const CeGuiString&amp; optionName);
-		virtual int calcResponseValue(const CeGuiString&amp; responseName);
-		virtual int calcSelectionValue(const CeGuiString&amp; selectionName);
-
-		DialogResponse* createResponse(const CeGuiString&amp; input);
-		bool isActive(){ return mActive; }
-		
-	private:
-		bool mActive;
-		AimlBot&lt;CeGuiString&gt;* mBot;
-
-		Creature* mNonPlayerCharacter;
-		Creature* mPlayerCharacter;
-
-//		typedef std::list&lt;DialogListener*&gt; Listeners;
-//		Listeners mDialogListener;
-
-	};
-
-	inline void DialogCharacter::setBot(AimlBot&lt;CeGuiString&gt;* bot)
-	{
-		mBot = bot;
-	}
-
-	inline Creature* DialogCharacter::getDialogCharacter() const
-	{
-		return mPlayerCharacter;
-	}
-	
-	inline void DialogCharacter::setDialogCharacter(Creature* dialogCharacter)
-	{
-		mPlayerCharacter = dialogCharacter;
-	}
-
-	inline Creature* DialogCharacter::getPlayerCharacter() const
-	{
-		return mPlayerCharacter;
-	}
-	
-	inline void DialogCharacter::setPlayerCharacter(Creature* pc)
-	{
-		mPlayerCharacter = pc;
-	}
-
-	inline Creature* DialogCharacter::getDialogPartner() const
-	{
-		return mNonPlayerCharacter;
-	}
-
-	inline void DialogCharacter::setDialogPartner(Creature* dialogPartner)
-	{
-		mNonPlayerCharacter = dialogPartner;
-	}
-
-	inline Creature* DialogCharacter::getNonPlayerCharacter() const
-	{
-		return mNonPlayerCharacter;
-	}
-
-	inline void DialogCharacter::setNonPlayerCharacter(Creature* npc)
-	{
-		mNonPlayerCharacter = npc;
-	}
-
-    /// @todo Magic Number.
-    inline int DialogCharacter::calcOptionValue(const CeGuiString&amp; optionName)
-    {
-        return 4;
-    }
-
-	inline int DialogCharacter::calcResponseValue(const CeGuiString&amp; responseName)
-    {
-        return 4;
-    }
-
-	inline int DialogCharacter::calcSelectionValue(const CeGuiString&amp; selectionName)
-    {
-        return 4;
-    }
-}
-
-#endif

Added: rl/trunk/engine/ai/include/DialogCondition.h
===================================================================
--- rl/trunk/engine/ai/include/DialogCondition.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogCondition.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,97 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __DialogCondition_H__
+#define __DialogCondition_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl
+{
+    class Dialog;
+    class DialogVariable;
+
+    class DialogCondition
+    {
+    public:
+        DialogCondition();
+        virtual ~DialogCondition();
+
+        void setVariable(DialogVariable* var);
+
+        bool isTrue(Dialog* dialog);
+        virtual bool isFulfilled(DialogVariable* var, Dialog* dialog) = 0;
+
+    private:
+        DialogVariable* mVariable;
+    };
+
+    class DialogConditionTrue : public DialogCondition
+    {
+    public:
+        DialogConditionTrue();
+        virtual ~DialogConditionTrue();
+
+        virtual bool isFulfilled(DialogVariable* var, Dialog* dialog);
+    };
+
+    class DialogConditionEquals : public DialogCondition
+    {
+    public:
+        DialogConditionEquals(const CeGuiString&amp; testValue);
+        virtual ~DialogConditionEquals();
+
+        virtual bool isFulfilled(DialogVariable* var, Dialog* dialog);
+
+    private:
+        CeGuiString mTestValue;
+    };
+
+    class DialogConditionInRange : public DialogCondition
+    {
+    public:
+        DialogConditionInRange(Ogre::Real lowerBound, Ogre::Real upperBound);
+        virtual ~DialogConditionInRange();
+
+        virtual bool isFulfilled(DialogVariable* var, Dialog* dialog);
+    private:
+        Ogre::Real mLowerBound; 
+        Ogre::Real mUpperBound;
+    };
+
+    class DialogConditionLowerThan : public DialogCondition
+    {
+    public:
+        DialogConditionLowerThan(Ogre::Real upperBound);
+        virtual ~DialogConditionLowerThan();
+
+        virtual bool isFulfilled(DialogVariable* var, Dialog* dialog);
+    private:
+        Ogre::Real mUpperBound;
+    };
+
+    class DialogConditionGreaterThan : public DialogCondition
+    {
+    public:
+        DialogConditionGreaterThan(Ogre::Real lowerBound);
+        virtual ~DialogConditionGreaterThan();
+
+        virtual bool isFulfilled(DialogVariable* var, Dialog* dialog);
+    private:
+        Ogre::Real mLowerBound; 
+    };
+}
+
+#endif // __DialogCondition_H__

Added: rl/trunk/engine/ai/include/DialogElement.h
===================================================================
--- rl/trunk/engine/ai/include/DialogElement.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogElement.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,106 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __DialogElement_H__
+#define __DialogElement_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+#include &quot;DialogCondition.h&quot;
+#include &quot;DialogVariable.h&quot;
+
+
+namespace rl
+{
+    class DialogParagraph;
+
+    class _RlAiExport DialogElement
+    {
+    public:
+        int getId() const;
+        void addParagraph(DialogParagraph* paragraph);
+        virtual std::list&lt;DialogParagraph*&gt; getParagraphs(Dialog* dialog);
+
+    protected:
+        DialogElement(int id);
+        virtual ~DialogElement();
+
+    private:
+        int mId;
+        std::list&lt;DialogParagraph*&gt; mParagraphs;
+    };
+
+    template&lt;class DialogElementType&gt;
+    class DialogSelection : public DialogElementType
+    {
+    public:
+        DialogSelection(int id)
+            : DialogElementType(id), mVariable(NULL)
+        {
+        }
+
+
+        ~DialogSelection()
+        {
+        }
+
+        void setVariable(DialogVariable* variable)
+        {
+            mVariable = variable;
+        }
+
+        virtual std::list&lt;DialogParagraph*&gt; getParagraphs(Dialog* dialog)
+        {
+            DialogElementType* selectedElem = getSelectedElement(dialog);
+
+            if (selectedElem)
+            {
+                return selectedElem-&gt;getParagraphs(dialog);
+            }
+            
+            std::list&lt;DialogParagraph*&gt; empty;
+            return empty;
+        }
+
+        void addElement(DialogCondition* condition, DialogElementType* element)
+        {
+            mElements.push_back(std::make_pair(condition, element));
+        }
+
+    protected:
+        DialogElementType* getSelectedElement(Dialog* dialog) const
+        {
+            for (typename CondElemMap::const_iterator it = mElements.begin(); it != mElements.end(); ++it)
+            {
+                DialogCondition* condition = it-&gt;first;
+                if ((mVariable &amp;&amp; condition-&gt;isFulfilled(mVariable, dialog))
+                    || (!mVariable &amp;&amp; it-&gt;first-&gt;isTrue(dialog)))
+                {
+                    return it-&gt;second;
+                }
+            }
+
+            return NULL;
+        }
+
+    private:
+        typedef std::vector&lt;std::pair&lt;DialogCondition*, DialogElementType*&gt; &gt; CondElemMap;
+        CondElemMap mElements;
+        DialogVariable* mVariable;
+    };
+
+}
+
+#endif // __DialogElement_H__

Added: rl/trunk/engine/ai/include/DialogImplication.h
===================================================================
--- rl/trunk/engine/ai/include/DialogImplication.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogImplication.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,49 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __DialogImplication_H__
+#define __DialogImplication_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport DialogImplication
+    {
+    public:
+        DialogImplication();
+        virtual ~DialogImplication();
+        
+        virtual void apply(Dialog* dialog) = 0;
+    };
+
+    class DialogVariableAssignment : public DialogImplication
+    {
+    public:
+        DialogVariableAssignment(const Ogre::String&amp; variableName, const CeGuiString&amp; value);
+        virtual ~DialogVariableAssignment();
+
+        virtual void apply(Dialog* dialog);
+
+    private:
+        Ogre::String mVariableName; 
+        CeGuiString mValue;
+    };
+}
+
+#endif //__DialogImplication_H__

Added: rl/trunk/engine/ai/include/DialogManager.h
===================================================================
--- rl/trunk/engine/ai/include/DialogManager.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogManager.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,96 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __DialogManager_H__
+#define __DialogManager_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+#include &lt;xercesc/dom/DOMElement.hpp&gt;
+
+#include &lt;OgreScriptLoader.h&gt;
+#include &quot;Properties.h&quot;
+#include &quot;XmlProcessor.h&quot;
+
+namespace rl
+{
+    class Dialog;
+    class DialogCondition;
+    class DialogElement;
+    class DialogImplication;
+    class DialogOption;
+    class DialogParagraph;
+    class DialogResponse;
+    class DialogVariable;
+    class GameObject;
+
+    class _RlAiExport DialogManager 
+        : public Ogre::Singleton&lt;DialogManager&gt;, 
+        public Ogre::ScriptLoader, 
+        private XmlProcessor
+    {
+    public:
+        DialogManager();
+        ~DialogManager();
+
+        virtual const Ogre::StringVector&amp; getScriptPatterns() const;
+        virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
+		virtual Ogre::Real getLoadingOrder() const;
+        Dialog* createDialog(const Ogre::String&amp; name, GameObject* pc, GameObject* npc);
+
+    private:
+
+        class DialogPrototype
+        {
+        public:
+            void addOption(DialogOption* option);
+            DialogOption* getOption(int id) const;
+            void addResponse(DialogResponse* option);
+            DialogResponse* getResponse(int id) const;
+
+            void setStartResponse(DialogResponse* response);
+            Dialog* createDialog(GameObject* pc, GameObject* npc);
+            void setProperty(const Ogre::String&amp; key, const Property&amp; value);
+
+        private:
+            std::map&lt;int, DialogOption*&gt; mOptionCache;
+            std::map&lt;int, DialogResponse*&gt; mResponseCache;
+            DialogResponse* mDialogStart;
+            PropertyRecord mPropertyVariables;
+        };
+
+        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
+        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
+        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
+        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
+        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
+        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
+        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
+        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
+        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
+        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
+        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
+        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
+        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
+
+        Ogre::StringVector mScriptPatterns;
+        std::map&lt;Ogre::String, DialogPrototype*&gt; mDialogs;
+    };
+
+}
+
+#endif // __DialogManager_H__

Modified: rl/trunk/engine/ai/include/DialogOption.h
===================================================================
--- rl/trunk/engine/ai/include/DialogOption.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogOption.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -13,63 +13,48 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
-#ifndef __Rl_DialogOption_H__
-#define __Rl_DialogOption_H__
+#ifndef __DialogOption_H__
+#define __DialogOption_H__
 
 #include &quot;AiPrerequisites.h&quot;
 
-namespace MadaBot
-{
-	template &lt;class S&gt; class AimlBot;
-	template &lt;class S&gt; class Response;
-}
-using namespace MadaBot;
+#include &quot;DialogElement.h&quot;
+
 namespace rl
 {
+    class Dialog;
+    class DialogCondition;
+    class DialogResponse;
+    class DialogElement;
+
     /**
      * The selectable options a player can choose from in a Dialog
      */
-	class _RlAiExport DialogOption
-	{
-	public:
-		DialogOption(const Response&lt;CeGuiString&gt;&amp; pData, AimlBot&lt;CeGuiString&gt;* pBot = NULL);
-		~DialogOption(void);
+    class _RlAiExport DialogOption : public DialogElement
+    {
+    public:
+        DialogOption(int id);
+        ~DialogOption();
 
-		/**
-		 * Process through the data of the selection and modify it by possible
-		 * conditions that occure 
-		 * TextData, SoundId and PatternId can be altered after the execution of this method
-		 */
-		void processSelection();
 
-		inline const CeGuiString&amp; getId() const
-		{
-			return mId;
-		}
+        const CeGuiString&amp; getLabel() const;
+        void setLabel(const CeGuiString&amp; label);
 
-		inline const CeGuiString&amp; getPattern() const
-		{
-			return mPatternId;
-		}
+        void setResponse(DialogResponse* response);
+        DialogResponse* getResponse() const;
 
-		const CeGuiString&amp; getText() const;
 
-		inline void setId(const CeGuiString&amp; id)
-		{
-			mId = id;
-		}
+        void setPrecondition(DialogCondition* precondition);
 
-		inline void setPattern(const CeGuiString&amp; pattern)
-		{
-			mPatternId = pattern;
-		}
-		
-	private:
-		AimlBot&lt;CeGuiString&gt;* mBot;
-		Response&lt;CeGuiString&gt;* mData;
-		CeGuiString mId;
-		CeGuiString mPatternId;
-		
-	};
+        bool isAvailable(Dialog* dialog) const;
+
+    private:
+        DialogResponse* mResponse;
+        DialogCondition* mPrecondition;
+        CeGuiString mLabel;
+    };
+    
+    typedef DialogSelection&lt;DialogOption&gt; DialogOptionSelection;
 }
-#endif
+
+#endif // __DialogOption_H__

Added: rl/trunk/engine/ai/include/DialogParagraph.h
===================================================================
--- rl/trunk/engine/ai/include/DialogParagraph.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogParagraph.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __DialogParagraph_H__
+#define __DialogParagraph_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl
+{
+    class DialogResponse;
+
+    class _RlAiExport DialogParagraph
+    {
+    public:
+        DialogParagraph(const CeGuiString&amp; text, const Ogre::String&amp; voicefile = &quot;&quot;);
+        virtual ~DialogParagraph();
+
+        const CeGuiString&amp; getText() const;
+        const Ogre::String&amp; getVoiceFile() const;
+        virtual DialogResponse* getResponse() const;
+
+    private:
+        CeGuiString mText;
+        Ogre::String mVoiceFile;
+    };
+
+    class _RlAiExport DialogGotoResponse : public DialogParagraph
+    {
+    public:
+        DialogGotoResponse(DialogResponse* response);
+        virtual DialogResponse* getResponse() const;
+    private:
+        DialogResponse* mResponse;
+    };
+}
+
+#endif // __DialogParagraph_H__

Modified: rl/trunk/engine/ai/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/ai/include/DialogResponse.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogResponse.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -13,64 +13,54 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
-#ifndef __Rl_DialogResponse_H__
-#define __Rl_DialogResponse_H__
+#ifndef __DialogResponse_H__
+#define __DialogResponse_H__
 
 #include &quot;AiPrerequisites.h&quot;
-#include &quot;CommonPrerequisites.h&quot;
 
-namespace MadaBot
-{
-	template &lt;class S&gt; class AimlBot;
-}
-using namespace MadaBot;
+#include &quot;DialogElement.h&quot;
 
 namespace rl
 {
-	class NaturalLanguageProcessor;
-	class DialogOption;
+    class Dialog;
+    class DialogImplication;
+	class DialogOption;   
+    class GameObject;
 
     /**
      * The reponse a DialogCharacter can give in a Dialog
      */
-	class _RlAiExport DialogResponse
-	{
-	public:
-		typedef std::map&lt;int, CeGuiString&gt; Options;
-		typedef std::list&lt;std::pair&lt;CeGuiString, CeGuiString&gt; &gt; Responses;
-		typedef std::vector&lt;DialogOption*&gt; DialogOptions;
+    class _RlAiExport DialogResponse : public DialogElement
+    {
+    public:
+        typedef std::vector&lt;DialogOption*&gt; Options;
+        typedef std::vector&lt;DialogImplication*&gt; Implications;
 
-		DialogResponse( const CeGuiString&amp; input, 
-						const CeGuiString&amp; response,
-						const Options&amp; currentOptions, 
-						const Options&amp; selectableOptions,
-						NaturalLanguageProcessor* nlp);
-		DialogResponse( const Responses&amp; responses, 
-						const DialogOptions&amp; options,
-						AimlBot&lt;CeGuiString&gt;* bot);
-		virtual ~DialogResponse(void);
+        DialogResponse(int id, int npcId = 0);
+        virtual ~DialogResponse();
 
-		const Options&amp; getOptions() { return mCurrentOptions; }
-		const CeGuiString&amp; getResponse() { return mResponse;}
-		/**
-		 * @return all options with thier pattern-id
-		 */
-		const DialogOptions&amp; getDialogOptions() { return mOptions;}
-		/**
-		 * @return all responses with their sound id
-		 */
-		const Responses&amp; getResponses() { return mResponses; }
-	private:
-		CeGuiString mInput;
-		CeGuiString mResponse;
-		Options mCurrentOptions;
-		Options mSelectableOptions;
-		
-		Responses mResponses;
-		DialogOptions mOptions;
-		AimlBot&lt;CeGuiString&gt;* mBot;
 
-		NaturalLanguageProcessor* mNlp;
-	};
+        void addOption(DialogOption* option);
+        void addImplication(DialogImplication* effect);
+        virtual const Options&amp; getOptions(Dialog* dialog) const;
+        const Options getAvailableOptions(Dialog* dialog) const;
+
+        void applyImplications(Dialog* dialog);
+
+        GameObject* getNpc(Dialog* dialog) const;
+
+    private:
+        Options mOptions;
+        Implications mEffects;
+        int mNpcId;
+    };
+    
+    class DialogResponseSelection : public DialogSelection&lt;DialogResponse&gt;
+    {
+    public:
+        DialogResponseSelection(int id);
+        virtual const Options&amp; getOptions(Dialog* dialog) const;
+    };
+
 }
 #endif

Deleted: rl/trunk/engine/ai/include/DialogScriptProcessor.h
===================================================================
--- rl/trunk/engine/ai/include/DialogScriptProcessor.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogScriptProcessor.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,44 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __Rl_DialogScriptProcessor_H__
-#define __Rl_DialogScriptProcessor_H__
-
-#include &quot;XmlMapper/XmlNodeProcessor.h&quot;
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;AimlBot.h&quot;
-
-using namespace XmlMapper;
-using namespace MadaBot;
-
-namespace rl
-{
-	/**
-	 * Loads ans processes a DialogCharacter script
-	 */
-	class DialogScriptProcessor
-			: public XmlNodeProcessor&lt;AimlBot, AimlCore, CeGuiString&gt;
-	{
-	public:
-		DialogScriptProcessor();
-		~DialogScriptProcessor();
-		void preprocessStep();
-		void processChildStep(XmlNode&lt;CeGuiString&gt;* pChild){}
-		void postprocessStep(){}
-	protected:
-		void initialize();
-	};
-}
-#endif

Added: rl/trunk/engine/ai/include/DialogVariable.h
===================================================================
--- rl/trunk/engine/ai/include/DialogVariable.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/DialogVariable.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,63 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __DialogVariable_H__
+#define __DialogVariable_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+#include &quot;Property.h&quot;
+
+namespace rl
+{
+    class Dialog;
+
+    class DialogVariable
+    {
+    public:
+        const Property&amp; getValue(Dialog* dialog);
+        void invalidate();
+
+    protected:
+        DialogVariable();
+        virtual ~DialogVariable();
+        virtual Property calculateValue(Dialog* dialog) = 0;
+
+    private:
+        bool mRecalculate;
+        Property mValue;
+    };
+
+    class DialogPropertyVariable : public DialogVariable
+    {
+    public:
+        DialogPropertyVariable(const Ogre::String&amp; propertyName);
+
+    protected:
+        virtual Property calculateValue(Dialog* dialog);
+
+    private:
+        Ogre::String mPropertyName;
+    };
+
+
+    class DialogVariableTalentProbe
+    {
+    public:
+        
+    };
+}
+
+#endif //__DialogVariable_H__

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-11-04 13:24:21 UTC (rev 3961)
@@ -14,6 +14,15 @@
 	AStarNodePool.h \
 	AStarWayPointNode.h \
 	CreatureWalkPathJob.h \
+	Dialog.h \
+	DialogCondition.h \
+	DialogElement.h \
+	DialogElementSelection.h \
+	DialogImplication.h \
+	DialogManager.h \
+	DialogOption.h \
+	DialogResponse.h \
+	DialogVariable.h \
 	FuzzyState.h \
 	FuzzyStateMachine.h \
 	Landmark.h \
@@ -23,23 +32,4 @@
 	SteeringVehicle.h \
 	WayPointNode.h \
 	WayPointGraph.h \
-	WayPointGraphManager.h \
-	AimlNodeImplRl.h \
-	AimlParserImplRl.h \
-	ContextConditionProcessor.h \
-	ContextInterpreter.h \
-	DialogCharacter.h \
-	DialogOption.h \
-	DialogPrerequisites.h \
-	DialogResponse.h \
-	DialogScriptProcessor.h \
-	ScriptProcessor.h \
-	predicates/CreaturePredicates.h \
-	predicates/EigenschaftsWertPredicates.h \
-	predicates/EigenschaftsProbePredicates.h \
-	predicates/QuestKnownPredicates.h \
-	predicates/QuestPartsPredicates.h \
-	predicates/QuestStatePredicates.h \
-	predicates/ScriptPredicates.h \
-	predicates/TalentProbePredicates.h \
-	predicates/TalentWertPredicates.h
+	WayPointGraphManager.h
\ No newline at end of file

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -22,7 +22,6 @@
 #include &quot;AgentDialogState.h&quot;
 #include &quot;AgentSteeringState.h&quot;
 #include &quot;Creature.h&quot;
-#include &quot;DialogCharacter.h&quot;
 #include &quot;Exception.h&quot;
 #include &quot;ScriptWrapper.h&quot;
 #include &quot;SteeringVehicle.h&quot;

Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -45,6 +45,11 @@
         mPartner = partner;
     }
 
+    void AgentDialogState::setDialog(Dialog* dialog)
+    {
+        mDialog = dialog;
+    }
+
     void AgentDialogState::update(const Ogre::Real elapsedTime)
     {
         static CreatureController* ctrl = 
@@ -68,7 +73,7 @@
                 ctrl-&gt;setAnimation(&quot;reden&quot;);
 				mTalking = true;
 
-                MessagePump::getSingleton().sendMessage&lt;MessageType_DialogStarted&gt;();
+                MessagePump::getSingleton().sendMessage&lt;MessageType_DialogStarted&gt;(mDialog);
                 
                 mAgent-&gt;popState();
             }			

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -33,21 +33,12 @@
 #include &quot;XmlProcessor.h&quot;
 #include &quot;XmlResourceManager.h&quot;
 #include &quot;ContentModule.h&quot;
+#include &quot;DialogManager.h&quot;
 
-#include &quot;AimlCore.h&quot;
-#include &quot;AimlParserImplRl.h&quot;
-#include &quot;DialogCharacter.h&quot;
-#include &quot;ScriptProcessor.h&quot;
-#include &quot;DialogScriptProcessor.h&quot;
-#include &quot;ContextInterpreter.h&quot;
-
 using namespace Ogre;
-using namespace MadaBot;
+using namespace OpenSteer;
 using namespace XERCES_CPP_NAMESPACE;
 
-using namespace Ogre;
-using namespace OpenSteer;
-
 template&lt;&gt; rl::AiSubsystem* Singleton&lt;rl::AiSubsystem&gt;::ms_Singleton = 0;
 
 namespace rl {
@@ -55,11 +46,7 @@
 AiSubsystem::AiSubsystem(void)
     : mAgentManager(NULL),
 	  mWayPointGraphManager(NULL),
-      mWorld(NULL),
-      mCore(new AimlCore()),
-	  mContextInterpreter(new ContextInterpreter()),
-	  mCurrentBot(NULL)
-
+      mWorld(NULL)
 {
     LOG_MESSAGE(Logger::AI, &quot;Init Start&quot;);
     initialize();
@@ -73,20 +60,10 @@
     mWorld-&gt;removeAllObstacles();
 	removeAllLandmarkPaths();
 	removeAllLandmarks();
+    delete mDialogManager;
     delete mAgentManager;
 	delete mWayPointGraphManager;
     delete mWorld;
-
-  	delete mCore;
-	delete mContextInterpreter;
-
-	for(BotMap::iterator iter = mBots.begin();
-		iter != mBots.end();
-		++iter)
-	{
-		delete iter-&gt;second;
-	}
-
 }
 
 void AiSubsystem::initialize()
@@ -94,6 +71,8 @@
     mAgentManager = new AgentManager();
 	mWayPointGraphManager = new WayPointGraphManager();
     mWorld = new AiWorld();
+    mDialogManager = new DialogManager();
+    Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mDialogManager);
 
     mSceneLoadedConnection =
         MessagePump::getSingleton().addMessageHandler&lt;MessageType_SceneLoaded&gt;(
@@ -103,27 +82,6 @@
 		    boost::bind(&amp;AiSubsystem::onBeforeClearScene, this));
 
     GameLoop::getSingleton().addTask(AgentManager::getSingletonPtr(), GameLoop::TG_LOGIC);
-
-#if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
-    setlocale(LC_ALL, &quot;C&quot;);
-#endif
-
-	mCore-&gt;setParser(new AimlParserImplRl());
-	mCore-&gt;getBotInterpreter().addProcessor(new DialogScriptProcessor());
-	mCore-&gt;getAimlInterpreter().addProcessor(new ScriptProcessor());
-////  Initialize Xerces if this wasn't done already
-//	try
-//	{
-//        
-//    }
-//    catch (const XMLException&amp; exc)
-//	{
-//		char* excmsg = XMLString::transcode(exc.getMessage());
-//		std::string excs=&quot;Exception while initializing Xerces: &quot;;
-//		excs+=excmsg;
-//		LOG_MESSAGE(Logger::DIALOG, excs);
-//        XMLString::release(&amp;excmsg);
-//    }
 }
 
 bool AiSubsystem::onBeforeClearScene()
@@ -134,11 +92,9 @@
     return true;
 }
 
-
-
 bool AiSubsystem::onAfterSceneLoaded()
 {
-    // newton world hinzuf&#252;gen
+    // newton world hinzuf&#239;&#191;&#189;gen
     Obstacle *newtonWorld = new NewtonWorldAsObstacle;
     newtonWorld-&gt;setSeenFrom(AbstractObstacle::both);
     mWorld-&gt;addObstacle(newtonWorld);
@@ -204,65 +160,4 @@
 	mLandmarks.clear();
 }
 
-DialogCharacter* AiSubsystem::getBot(const CeGuiString&amp; botName)
-{
-	BotMap::iterator itr = mBots.find(botName);
-	if(itr != mBots.end())
-	{
-		return itr-&gt;second;
-	}
-	return NULL;
 }
-
-
-DialogCharacter* AiSubsystem::loadBot(const CeGuiString&amp; botName, const CeGuiString&amp; fileName)
-{
-	mCurrentBot = NULL;
-	AimlBot&lt;CeGuiString&gt;* bot = mCore-&gt;loadBot(botName.c_str(), fileName.c_str());
-//  while processing the bot definition, a DialogCharacter should have been created
-//  through a ruby script and stored in mCurrentBot
-    if (mCurrentBot == NULL)
-    {
-        mCurrentBot = new DialogCharacter();
-    }
-
-	if(bot != NULL)
-	{
-		mCurrentBot-&gt;setBot(bot);
-		mCurrentBot-&gt;initialize();
-	}
-	LOG_MESSAGE(Logger::DIALOG,&quot;AimlBot &quot; + botName + &quot;loaded and initialized&quot;);
-	mBots.insert(BotMap::value_type(mCurrentBot-&gt;getName(), mCurrentBot));
-	return mCurrentBot;
-}
-
-ResourcePtr AiSubsystem::getXmlResource(const Ogre::String&amp; filename)
-{
-    ResourcePtr res = XmlResourceManager::getSingleton().getByName(filename);
-
-    if (res.isNull())
-    {
-        Ogre::String group = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME;
-        if (ResourceGroupManager::getSingleton().resourceExists(
-			CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId(), filename))
-        {
-            group = CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId();
-        }
-        res = XmlResourceManager::getSingleton().create(filename, group);
-
-    }
-    return res;
-}
-
-void AiSubsystem::setCurrentDialogCharacter(DialogCharacter* bot)
-{
-	mCurrentBot = bot;
-}
-
-DialogCharacter* AiSubsystem::getCurrentDialogCharacter() const
-{
-    return mCurrentBot;
-}
-
-
-}

Deleted: rl/trunk/engine/ai/src/AimlNodeImplRl.cpp
===================================================================
--- rl/trunk/engine/ai/src/AimlNodeImplRl.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/AimlNodeImplRl.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,105 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-#include &lt;xercesc/util/XMLString.hpp&gt;
-#include &lt;xercesc/util/XMLChar.hpp&gt;
-#include &lt;xercesc/util/TransService.hpp&gt;
-#include &quot;AimlNodeImplRl.h&quot;
-
-#include &quot;XmlProcessor.h&quot;
-
-namespace rl {
-
-AimlNodeImplRl::AimlNodeImplRl(DOMNode* pNode)
-{
-    initializeXml();
-	mNodeName  = transcodeToString(pNode-&gt;getLocalName());
-	// #text or #comment have no local name, use NodeName for them
-	if(mNodeName.empty())
-	{
-		mNodeName  = transcodeToString(pNode-&gt;getNodeName());
-	}
-	mNodeName.c_str();
-
-	// remove whitespaces from textnodes
-	if(mNodeName == &quot;#text&quot;)
-	{
-		XMLCh* tmp = XMLString::replicate(pNode-&gt;getNodeValue());
-		XMLString::collapseWS(tmp);
-		mNodeValue = transcodeToString(tmp);
-		XMLString::release(&amp;tmp);
-	}
-	else
-	{
-		mNodeValue = transcodeToString(pNode-&gt;getNodeValue());
-	}
-	mNodeValue.c_str();
-	// mpa attributes
-	DOMNamedNodeMap* attributes = pNode-&gt;getAttributes();
-	if(attributes != NULL)
-	{
-		for(unsigned int i = 0; i &lt; attributes-&gt;getLength(); ++i)
-		{
-			CeGuiString attributeName  =
-				transcodeToString(attributes-&gt;item(i)-&gt;getNodeName());
-			CeGuiString attributeValue =
-				transcodeToString(attributes-&gt;item(i)-&gt;getNodeValue());
-			mAttributes.insert(Attributes::value_type(attributeName, attributeValue));
-		}
-	}
-	//debug
-	for(Attributes::iterator itr = mAttributes.begin(); itr != mAttributes.end() ;++itr)
-	{
-		itr-&gt;first.c_str();
-		itr-&gt;second.c_str();
-	}
-	// map children
-	DOMNode* child = pNode-&gt;getFirstChild();
-	for(; child !=NULL; child = child-&gt;getNextSibling())
-	{
-		// don't add pure whitespaces as AimlNode
-		XMLCh* cmp = XMLString::transcode(&quot;#text&quot;);
-		if(XMLString::equals(child-&gt;getNodeName(), cmp))
-		{
-			if(XMLChar1_0::isAllSpaces(child-&gt;getNodeValue(), XMLString::stringLen(child-&gt;getNodeValue())))
-			{
-				continue;
-			}
-		}
-		XMLString::release(&amp;cmp);
-		mChildren.push_back(new AimlNodeImplRl(child));
-	}
-	if(!mChildren.empty())
-	{
-		std::vector&lt;XmlNode&lt;CeGuiString&gt;*&gt;::iterator itr = mChildren.begin();
-		std::vector&lt;XmlNode&lt;CeGuiString&gt;*&gt;::iterator itrnext;
-		for(; itr != mChildren.end()-1; ++itr)
-		{
-			itrnext= itr+1;
-			(*itr)-&gt;setNextSibling((*itrnext));
-		}
-		(*itr)-&gt;setNextSibling(NULL);
-	}
-}
-
-AimlNodeImplRl::~AimlNodeImplRl(void)
-{
-    shutdownXml();
-}
-
-}

Deleted: rl/trunk/engine/ai/src/AimlParserImplRl.cpp
===================================================================
--- rl/trunk/engine/ai/src/AimlParserImplRl.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/AimlParserImplRl.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,69 +0,0 @@
-
-#include &quot;stdinc.h&quot;
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-#include &lt;xercesc/parsers/XercesDOMParser.hpp&gt;
-#include &lt;xercesc/sax/HandlerBase.hpp&gt;
-#include &quot;AimlParserImplRl.h&quot;
-#include &quot;XmlResourceManager.h&quot;
-#include &quot;XmlMapper/XmlDocument.h&quot;
-#include &quot;AimlNodeImplRl.h&quot;
-#include &quot;Logger.h&quot;
-
-// needed for resources
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;ContentModule.h&quot;
-
-using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
-
-namespace rl {
-
-
-AimlParserImplRl::~AimlParserImplRl(void)
-{
-}
-
-XmlDocument&lt;CeGuiString&gt;* AimlParserImplRl::parse(const CeGuiString&amp; fileName)
-{
-	XercesDOMParser parser;// = new XercesDOMParser();
-
-	parser.setIncludeIgnorableWhitespace(false);
-	parser.setDoNamespaces(true);
-
-	XmlPtr res = getXmlResource(fileName);
-
-    bool result = res-&gt;parseBy(&amp;parser);
-
-    if(result)
-    {
-        XERCES_CPP_NAMESPACE::DOMDocument* doc = parser.getDocument();
-	    XERCES_CPP_NAMESPACE::DOMElement* test = doc-&gt;getDocumentElement();
-	    XmlNode&lt;CeGuiString&gt;* rootNode = new AimlNodeImplRl(doc-&gt;getDocumentElement());
-	    return (new XmlDocument&lt;CeGuiString&gt;(rootNode));
-    }
-    std::string message = &quot;File '&quot;+ std::string(fileName.c_str()) +&quot;' could not be parsed.&quot;;
-    message += &quot;Possible reason: Wrong file format.&quot;;
-    LOG_ERROR(Logger::DIALOG, message );
-    return NULL;
-}
-
-ResourcePtr AimlParserImplRl::getXmlResource(const CeGuiString&amp; fileName)
-{
-	ResourcePtr res = XmlResourceManager::getSingleton().getByName(fileName.c_str());
-
-    if (res.isNull())
-    {
-        Ogre::String group = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME;
-        if (ResourceGroupManager::getSingleton().resourceExists(
-			CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId(), fileName.c_str()))
-        {
-            group = CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId();
-        }
-		res = XmlResourceManager::getSingleton().create(fileName.c_str(), group);
-
-    }
-    return res;
-}
-
-}

Deleted: rl/trunk/engine/ai/src/ContextConditionProcessor.cpp
===================================================================
--- rl/trunk/engine/ai/src/ContextConditionProcessor.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/ContextConditionProcessor.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,108 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;ContextConditionProcessor.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;Logger.h&quot;
-
-namespace rl {
-
-ContextConditionProcessor::ContextConditionProcessor(void)
-	: XmlNodeProcessor&lt;Response, AimlBot, CeGuiString, false&gt;(&quot;contextCondition&quot;)
-{
-	initialize();
-}
-
-ContextConditionProcessor::~ContextConditionProcessor(void)
-{
-}
-
-void ContextConditionProcessor::initialize()
-{
-	addAllowedSubProcessor(&quot;li&quot;);
-	addAttribute(&quot;mod&quot;);
-	addAttribute(&quot;type&quot;);
-	addAttribute(&quot;name&quot;);
-	addAttribute(&quot;value&quot;);
-}
-
-void ContextConditionProcessor::preprocessStep()
-{
-	mPredicateValue.clear();
-	mNodeValue.clear();
-	mCurrentReturnValue.clear();
-    RlAssert(mCurrentHelper != NULL, &quot;No AimlBot found&quot;);
-	try
-	{
-		LOG_MESSAGE(Logger::DIALOG, &quot;ContextCondition: getPredciates&quot;);
-        Predicates&lt;CeGuiString&gt;* predicates = NULL;
-		if(mAttributes[&quot;type&quot;].find(&quot;probe&quot;) != CeGuiString::npos)
-		{
-			predicates = mCurrentHelper-&gt;getPredicates(mAttributes[&quot;type&quot;]);
-            if( predicates == NULL )
-            {
-                CeGuiString message = &quot;No predicate found with type: &quot; + mAttributes[&quot;type&quot;];
-                Throw( NullPointerException, message.c_str() );
-            }
-            predicates-&gt;setPredicate(&quot;mod&quot;, mAttributes[&quot;mod&quot;]);
-		}
-		predicates = mCurrentHelper-&gt;getPredicates(mAttributes[&quot;type&quot;]);
-        if( predicates == NULL )
-        {
-          CeGuiString message = &quot;No predicate found with type: &quot; + mAttributes[&quot;type&quot;];
-          Throw( NullPointerException, message.c_str() );
-        }
-        mPredicateValue = predicates-&gt;getPredicate(mAttributes[&quot;name&quot;]);
-
-		if(!mAttributes[&quot;value&quot;].empty())
-		{
-			mNodeValue = mAttributes[&quot;value&quot;];
-		}
-	}
-	catch(...)
-	{
-	}
-}
-
-void ContextConditionProcessor::processChildStep(XmlNode&lt;CeGuiString&gt;* pChild)
-{
-	mNodeValue.c_str();
-	mPredicateValue.c_str();
-	CeGuiString value = mNodeValue;
-	if(value.empty())
-	{
-		value = pChild-&gt;getAttribute(&quot;value&quot;);
-	}
-	value.c_str();
-	CeGuiString logMessage = &quot;evaluated &lt;li&gt; with id &quot; + pChild-&gt;getAttribute(&quot;id&quot;) + &quot;. &quot;;
-    logMessage += &quot;Condition Value: &quot; + value + &quot; List(&lt;li&gt;) Value: &quot; + mPredicateValue;
-    logMessage += &quot;result: &quot;;
-	CeGuiString result = &quot;false&quot;;
-	if(mPredicateValue == value)
-	{
-		mCurrentReturnValue += pChild;
-		result = &quot;true&quot;;
-	}
-	LOG_DEBUG(Logger::DIALOG, logMessage + result);
-}
-
-void ContextConditionProcessor::postprocessStep()
-{
-}
-
-}

Deleted: rl/trunk/engine/ai/src/ContextInterpreter.cpp
===================================================================
--- rl/trunk/engine/ai/src/ContextInterpreter.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/ContextInterpreter.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,191 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;ContextInterpreter.h&quot;
-#include &quot;ContextConditionProcessor.h&quot;
-#include &quot;ScriptProcessor.h&quot;
-#include &quot;DialogResponse.h&quot;
-#include &quot;DialogOption.h&quot;
-#include &quot;AimlBot.h&quot;
-
-using namespace std;
-
-namespace rl {
-
-CeGuiString ContextInterpreter::INTERPRETER_NAME = &quot;contextInterpreter&quot;;
-CeGuiString ContextInterpreter::RL_TYPE = &quot;rldialog:type&quot;;
-CeGuiString ContextInterpreter::RL_LI_ID = &quot;rldialog:id&quot;;
-CeGuiString ContextInterpreter::RL_PATTERN_REF = &quot;rldialog:patternRef&quot;;
-CeGuiString ContextInterpreter::RL_E_PROBE = &quot;eigenschaftsprobe&quot;;
-CeGuiString ContextInterpreter::RL_E_MODIFIER = &quot; (E) &quot;;
-CeGuiString ContextInterpreter::RL_T_PROBE = &quot;talentprobe&quot;;
-CeGuiString ContextInterpreter::RL_T_MODIFIER = &quot; (T) &quot;;
-CeGuiString ContextInterpreter::RL_RESPONSE = &quot;response&quot;;
-CeGuiString ContextInterpreter::RL_OPTION = &quot;option&quot;;
-CeGuiString ContextInterpreter::RL_SELECTION = &quot;selection&quot;;
-CeGuiString ContextInterpreter::AIML_CONDITION = &quot;condition&quot;;
-CeGuiString ContextInterpreter::AIML_TYPE = &quot;type&quot;;
-CeGuiString ContextInterpreter::AIML_GOSSIP = &quot;gossip&quot;;
-CeGuiString ContextInterpreter::AIML_LI = &quot;li&quot;;
-
-ContextInterpreter::ContextInterpreter(void)
-	: AimlInterpreter&lt;CeGuiString&gt;(INTERPRETER_NAME), mBot(NULL)
-{
-	initialize();
-}
-
-ContextInterpreter::~ContextInterpreter(void)
-{
-}
-
-void ContextInterpreter::processResponse()
-{
-//  now we have one response with several &lt;li&gt;s. those &lt;li&gt;s should be processed
-	Response&lt;CeGuiString&gt;::GossipData gossip = mReturnValue.getGossip();
-	Response&lt;CeGuiString&gt;::GossipData::const_iterator itr = gossip.begin();
-	for(; itr != gossip.end(); ++itr)
-	{
-		if((*itr)-&gt;getNodeName() == AIML_LI)
-		{
-			CeGuiString id = (*itr)-&gt;getAttribute(RL_LI_ID);
-			id.c_str();
-			CeGuiString text = getProcessor(AIML_LI)-&gt;process(*itr, mBot).getResponse();
-			text.c_str();
-			mResponses.push_back(make_pair&lt;CeGuiString, CeGuiString&gt;(id, text));
-		}
-	}
-}
-
-void ContextInterpreter::processOption()
-{
-	Response&lt;CeGuiString&gt;::GossipData gossip = mReturnValue.getGossip();
-	Response&lt;CeGuiString&gt;::GossipData::const_iterator itr = gossip.begin();
-	for(; itr != gossip.end(); ++itr)
-	{
-		if((*itr)-&gt;getNodeName() == AIML_LI)
-		{
-			Response&lt;CeGuiString&gt; response = getProcessor(AIML_LI)-&gt;process(*itr, mBot);
-		//  check if this option is influenced by a condition check
-			XmlNode&lt;CeGuiString&gt;* pChild = (*itr)-&gt;getFirstChild();
-			for(; pChild != NULL; pChild = pChild-&gt;getNextSibling())
-			{
-				if(pChild-&gt;getNodeName() == AIML_CONDITION)
-				{
-					CeGuiString type = pChild-&gt;getAttribute(AIML_TYPE);
-					if(type == RL_E_PROBE)
-					{
-						response += RL_E_MODIFIER;
-					}
-					else if(type == RL_T_PROBE)
-					{
-						response += RL_T_MODIFIER;
-					}
-				}
-			}
-			DialogOption* option = new DialogOption(response, mBot);
-			option-&gt;setId((*itr)-&gt;getAttribute(RL_LI_ID));
-			option-&gt;setPattern((*itr)-&gt;getAttribute(RL_PATTERN_REF));
-			mOptions.push_back(option);
-		}
-		else
-		{
-			// exception or logging...
-		}
-	}
-}
-
-void ContextInterpreter::processSelection()
-{
-	Response&lt;CeGuiString&gt;::GossipData gossip = mReturnValue.getGossip();
-	Response&lt;CeGuiString&gt;::GossipData::const_iterator itr = gossip.begin();
-	for(; itr != gossip.end(); ++itr)
-	{
-		if((*itr)-&gt;getNodeName() == AIML_LI)
-		{
-			DialogOption* option = new DialogOption(getProcessor(AIML_LI)-&gt;process(*itr));
-			option-&gt;setId((*itr)-&gt;getAttribute(RL_LI_ID));
-			option-&gt;setPattern((*itr)-&gt;getAttribute(RL_PATTERN_REF));
-			mOptions.push_back(option);
-		}
-	}
-}
-
-DialogResponse* ContextInterpreter::interpret(const Response&lt;CeGuiString&gt;::GossipData&amp; pData, AimlBot&lt;CeGuiString&gt;* pProcessHelper)
-{
-	mOptions.clear();
-	mResponses.clear();
-	mBot = pProcessHelper;
-	CeGuiString type;
-	Response&lt;CeGuiString&gt;::GossipData::const_iterator itr = pData.begin();
-	for(; itr != pData.end(); ++itr)
-	{
-		mCurrentType = (*itr)-&gt;getAttribute(RL_TYPE);
-		mCurrentType.c_str();
-		pProcessHelper-&gt;getPredicates(&quot;default&quot;)-&gt;setPredicate(&quot;contextType&quot;, mCurrentType);
-		process( (*itr), pProcessHelper);
-	}
-	pProcessHelper-&gt;getPredicates(&quot;default&quot;)-&gt;setPredicate(&quot;contextType&quot;, &quot;&quot;);
-	return new DialogResponse(mResponses, mOptions, pProcessHelper);
-}
-
-Response&lt;CeGuiString&gt; ContextInterpreter
-			::process(XmlNode&lt;CeGuiString&gt;* pNode, AimlBot&lt;CeGuiString&gt;* pProcessHelper)
-{
-//  pNode == gossip
-	Response&lt;CeGuiString&gt; response;
-	XmlNode&lt;CeGuiString&gt;* child = pNode-&gt;getFirstChild();
-	for(; child != NULL; child = child-&gt;getNextSibling(), mReturnValue.clear())
-	{
-		if(child-&gt;getNodeName() == AIML_LI)
-		{
-		//	add the li-node to the responses gossip data
-			mReturnValue += child;
-		}
-		else if(child-&gt;getNodeName() == AIML_CONDITION)
-		{
-		//	add a list of valid li-nodes to the gossip data of the repsonse
-			LOG_MESSAGE(Logger::DIALOG, &quot;process condition in context&quot; + mCurrentType);
-			mReturnValue += getProcessor(&quot;contextCondition&quot;)
-					-&gt;process(child, pProcessHelper);
-		}
-	//	process the returnValue for the specific context
-		if(mCurrentType == RL_RESPONSE &amp;&amp; pNode-&gt;getNodeName() == AIML_GOSSIP)
-		{
-			LOG_MESSAGE(Logger::DIALOG, &quot;process response&quot;);
-			processResponse();
-		}
-		else if(mCurrentType == RL_OPTION &amp;&amp; pNode-&gt;getNodeName() == AIML_GOSSIP)
-		{
-			LOG_MESSAGE(Logger::DIALOG, &quot;process option&quot;);
-			processOption();
-		}
-		else if(mCurrentType == RL_SELECTION &amp;&amp; pNode-&gt;getNodeName() == AIML_GOSSIP)
-		{
-			LOG_MESSAGE(Logger::DIALOG, &quot;process selection&quot;);
-			processSelection();
-		}
-	}
-	return response;
-}
-
-void ContextInterpreter::initialize()
-{
-	addProcessor(new ContextConditionProcessor());
-	addProcessor(new ScriptProcessor());
-}
-
-}

Added: rl/trunk/engine/ai/src/Dialog.cpp
===================================================================
--- rl/trunk/engine/ai/src/Dialog.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/Dialog.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,76 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;Dialog.h&quot;
+#include &quot;DialogResponse.h&quot;
+
+namespace rl
+{
+
+    Dialog::Dialog(GameObject* npc, GameObject* pc)
+    {
+        mNonPlayerCharacters.push_back(npc);
+        mPlayerCharacters.push_back(pc);
+    }
+
+    Dialog::~Dialog()
+    {
+    }
+
+    DialogResponse* Dialog::getDialogStart() const
+    {
+        return mDialogStart;
+    }
+
+    void Dialog::setStartResponse(DialogResponse* start)
+    {
+        mDialogStart = start;
+    }
+
+    void Dialog::initialize() ///@todo hand over NPCs and party
+    {
+    }
+
+    GameObject* Dialog::getNpc(int id) const
+    {
+        return mNonPlayerCharacters[id];
+    }
+
+    GameObject* Dialog::getPc(int id) const
+    {
+        return mPlayerCharacters[id];
+    }
+
+    const Property Dialog::getProperty(const Ogre::String&amp; key) const
+    {
+        ///@todo dialog's state
+        return mPropertyVariables.getProperty(key);
+    }
+
+    void Dialog::setProperty(const Ogre::String&amp; key, const Property&amp; value)
+    {
+        ///@todo dialog's state
+        mPropertyVariables.setProperty(key, value);
+    }
+
+    PropertyRecord* Dialog::getAllProperties() const
+    {
+        PropertyRecord* ps = new PropertyRecord();
+        ///@todo to allow saving dialog's state
+        return ps;
+    }
+}

Deleted: rl/trunk/engine/ai/src/DialogCharacter.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogCharacter.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogCharacter.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,145 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;DialogCharacter.h&quot;
-#include &quot;AiSubsystem.h&quot;
-#include &quot;ContextInterpreter.h&quot;
-#include &quot;AimlBot.h&quot;
-#include &quot;Response.h&quot;
-
-#include &quot;Predicates.h&quot;
-#include &quot;EigenschaftsProbePredicates.h&quot;
-#include &quot;EigenschaftsWertPredicates.h&quot;
-#include &quot;QuestKnownPredicates.h&quot;
-#include &quot;QuestPartsPredicates.h&quot;
-#include &quot;QuestStatePredicates.h&quot;
-#include &quot;ScriptPredicates.h&quot;
-#include &quot;TalentProbePredicates.h&quot;
-#include &quot;TalentWertPredicates.h&quot;
-#include &quot;GrundWertPredicates.h&quot;
-
-
-namespace rl
-{
-	DialogCharacter::DialogCharacter()
-		: mActive(false),
-		  mBot(NULL),
-		  mNonPlayerCharacter(NULL),
-		  mPlayerCharacter(NULL)
-	{
-	}
-
-	DialogCharacter::~DialogCharacter(void)
-	{
-		if(mBot)
-		{
-			delete mBot;
-		}
-	}
-
-	void DialogCharacter::initialize()
-	{
-	//  add additional predicates
-		if(mBot != NULL)
-		{
-			mBot-&gt;addPredicates(new EigenschaftsProbePredicates(mPlayerCharacter));
-			mBot-&gt;addPredicates(new EigenschaftsWertPredicates(mPlayerCharacter));
-			mBot-&gt;addPredicates(new QuestKnownPredicates());
-			mBot-&gt;addPredicates(new QuestPartsPredicates());
-			mBot-&gt;addPredicates(new QuestStatePredicates());
-			mBot-&gt;addPredicates(new ScriptPredicates(this));
-			mBot-&gt;addPredicates(new TalentProbePredicates(mPlayerCharacter));
-			mBot-&gt;addPredicates(new TalentWertPredicates(mPlayerCharacter));
-			mBot-&gt;addPredicates(new GrundWertPredicates(mPlayerCharacter));
-		}
-	}
-
-/*	void DialogCharacter::addDialogListener(DialogListener* listener)
-	{
-		mDialogListener.push_back(listener);
-	}
-
-	void DialogCharacter::removeDialogListener(DialogListener* listener)
-	{
-		mDialogListener.remove(listener);
-	}
-	void DialogCharacter::updateDialogListeners(DialogListener::DialogEvent e)
-	{
-		Listeners::iterator itr = mDialogListener.begin();
-		for(; itr != mDialogListener.end(); ++itr)
-		{
-			(*itr)-&gt;onDialogEvent(e);
-		}
-	}
-*/
-
-    bool DialogCharacter::hasExitRequest() const
-    {
-        return mBot-&gt;hasExitRequest();
-    }
-
-	const CeGuiString DialogCharacter::getName() const
-	{
-		return mBot-&gt;getName();
-	}
-
-	Predicates&lt;CeGuiString&gt;* DialogCharacter::getPredicates(const CeGuiString&amp; pType)
-	{
-		return mBot-&gt;getPredicates(pType);
-	}
-
-	DialogResponse* DialogCharacter::createResponse(const CeGuiString&amp; input)
-	{
-//		DialogListener::DialogEvent dialogEvent = DialogListener::DIALOG_RESPONSE;
-		if(!mActive)
-		{
-			mActive=true;
-//			dialogEvent = DialogListener::DIALOG_START;
-		}
-		input.c_str();
-		DialogResponse* dialogResponse = NULL;
-		LOG_MESSAGE(Logger::DIALOG, &quot;Create AIML response&quot;);
-		Response&lt;CeGuiString&gt; response = mBot-&gt;respond(input);
-		if(response.hasGossip())
-		{
-			ContextInterpreter* interpreter = AiSubsystem::getSingleton().getContextInterpreter();
-			if(interpreter!= NULL)
-			{
-				LOG_MESSAGE(Logger::DIALOG, &quot;Create DialogResponse&quot;);
-				dialogResponse = interpreter-&gt;interpret(response.getGossip(), mBot);
-			}
-		}
-		// why check for response.empty()???
-		if(response.empty() || dialogResponse == NULL)
-		{
-			mActive = false;
-//			dialogEvent = DialogListener::DIALOG_END;
-		}
-//		updateDialogListeners(dialogEvent);
-		return dialogResponse;
-	}
-
-	void DialogCharacter::setVoiceFile(const CeGuiString&amp; filename)
-	{
-		mBot-&gt;setVoice(filename);
-	}
-
-	const CeGuiString&amp; DialogCharacter::getVoiceFile() const
-	{
-		return mBot-&gt;getVoice();
-	}
-}

Added: rl/trunk/engine/ai/src/DialogCondition.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogCondition.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogCondition.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,120 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogCondition.h&quot;
+
+#include &quot;Dialog.h&quot;
+#include &quot;DialogVariable.h&quot;
+#include &quot;Property.h&quot;
+
+namespace rl
+{
+
+    DialogCondition::DialogCondition()
+        : mVariable(NULL)
+    {
+    }
+
+    DialogCondition::~DialogCondition()
+    {
+    }
+
+    bool DialogCondition::isTrue(Dialog* dialog)
+    {
+        if (mVariable)
+        {
+            mVariable-&gt;invalidate();
+            return isFulfilled(mVariable, dialog);
+        }
+        return false;
+    }
+
+    void DialogCondition::setVariable(DialogVariable* var)
+    {
+        mVariable = var;
+    }
+
+    DialogConditionTrue::DialogConditionTrue() 
+    {
+    }
+
+    DialogConditionTrue::~DialogConditionTrue() 
+    {
+    }
+
+    bool DialogConditionTrue::isFulfilled(DialogVariable* var, Dialog* dialog) 
+    { 
+        return true; 
+    }
+
+    DialogConditionEquals::DialogConditionEquals(const CeGuiString&amp; testValue)
+        : mTestValue(testValue)
+    {
+    }
+
+    DialogConditionEquals::~DialogConditionEquals()
+    {
+    }
+
+    bool DialogConditionEquals::isFulfilled(DialogVariable* var, Dialog* dialog)
+    {
+        return var-&gt;getValue(dialog).getAsString() == mTestValue;
+    }
+
+    DialogConditionInRange::DialogConditionInRange(Ogre::Real lowerBound, Ogre::Real upperBound)
+    {
+    }
+    
+    DialogConditionInRange::~DialogConditionInRange()
+    {
+    }
+    
+    bool DialogConditionInRange::isFulfilled(DialogVariable* var, Dialog* dialog)
+    {
+        Ogre::Real numVar = var-&gt;getValue(dialog).getAsNumber();
+        return mLowerBound &lt;= numVar &amp;&amp; numVar &lt;= mUpperBound;
+    }
+
+    DialogConditionLowerThan::DialogConditionLowerThan(Ogre::Real upperBound)
+        : mUpperBound(upperBound)
+    {
+    }
+    
+    DialogConditionLowerThan::~DialogConditionLowerThan()
+    {
+    }
+
+    bool DialogConditionLowerThan::isFulfilled(DialogVariable* var, Dialog* dialog)
+    {
+        return var-&gt;getValue(dialog).getAsNumber() &lt; mUpperBound;
+    }
+
+    DialogConditionGreaterThan::DialogConditionGreaterThan(Ogre::Real lowerBound)
+        : mLowerBound(lowerBound)
+    {
+    }
+
+    DialogConditionGreaterThan::~DialogConditionGreaterThan()
+    {
+    }
+
+    bool DialogConditionGreaterThan::isFulfilled(DialogVariable* var, Dialog* dialog)
+    {
+        return var-&gt;getValue(dialog).getAsNumber() &gt; mLowerBound;
+    }
+
+}

Added: rl/trunk/engine/ai/src/DialogElement.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogElement.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogElement.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,54 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogElement.h&quot;
+
+#include &quot;DialogParagraph.h&quot;
+
+namespace rl
+{
+    DialogElement::DialogElement(int id)
+        : mId(id)
+    {
+    }
+
+    DialogElement::~DialogElement()
+    {
+        for (std::list&lt;DialogParagraph*&gt;::iterator it = mParagraphs.begin();
+            it != mParagraphs.end(); ++it)
+        {
+            delete *it;
+        }
+    }
+
+    int DialogElement::getId() const
+    {
+        return mId;
+    }
+
+    void DialogElement::addParagraph(DialogParagraph* paragraph)
+    {
+        mParagraphs.push_back(paragraph);
+    }
+
+    std::list&lt;DialogParagraph*&gt; DialogElement::getParagraphs(Dialog* dialog)
+    {
+        return mParagraphs;
+    }
+
+}

Added: rl/trunk/engine/ai/src/DialogImplication.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogImplication.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogImplication.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,53 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogImplication.h&quot;
+
+#include &quot;Dialog.h&quot;
+#include &quot;Property.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    DialogImplication::DialogImplication()
+    {
+    }
+
+    DialogImplication::~DialogImplication()
+    {
+    }
+
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName, const CeGuiString&amp; value)
+        : mVariableName(variableName), mValue(value)
+    {
+    }
+
+    DialogVariableAssignment::~DialogVariableAssignment()
+    {
+    }
+
+    void DialogVariableAssignment::apply(Dialog* dialog)
+    {
+        Property prop = dialog-&gt;getProperty(mVariableName);
+        prop.getFromString(mValue);
+        dialog-&gt;setProperty(mVariableName, prop);
+    }
+
+
+}

Added: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,538 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogManager.h&quot;
+
+#include &lt;xercesc/dom/DOM.hpp&gt;
+
+#include &quot;Dialog.h&quot;
+#include &quot;DialogCondition.h&quot;
+#include &quot;DialogElement.h&quot;
+#include &quot;DialogImplication.h&quot;
+#include &quot;DialogOption.h&quot;
+#include &quot;DialogParagraph.h&quot;
+#include &quot;DialogResponse.h&quot;
+#include &quot;DialogVariable.h&quot;
+#include &quot;XmlPropertyReader.h&quot;
+
+using namespace Ogre;
+using namespace XERCES_CPP_NAMESPACE;
+
+template&lt;&gt;
+    rl::DialogManager* Ogre::Singleton&lt;rl::DialogManager&gt;::ms_Singleton = NULL;
+
+namespace rl
+{
+
+    DialogManager::DialogManager()
+        : XmlProcessor(), ScriptLoader()
+    {
+        mScriptPatterns.push_back(&quot;*.dialog&quot;);
+    }
+
+    DialogManager::~DialogManager()
+    {
+    }
+
+    const StringVector&amp; DialogManager::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+    
+	Ogre::Real DialogManager::getLoadingOrder() const
+    {
+        return 1000;
+    }
+
+    void DialogManager::parseScript(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
+    {
+        initializeXml();
+
+        DOMDocument* doc = loadDocument(stream);
+        if (doc)
+        {
+            DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
+
+            for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
+            {
+                DOMNode* cur = dialogNodes-&gt;item(i);
+                processDialog(static_cast&lt;DOMElement*&gt;(cur));
+            }
+        }
+
+        shutdownXml();
+    }
+
+    void DialogManager::processDialog(DOMElement* dialogElem)
+    {
+        DialogPrototype* dialogPrototype = new DialogPrototype();
+        Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
+        mDialogs[name] = dialogPrototype;
+
+        // first step: process all possible references
+        processElementNodes(dialogElem, &quot;option&quot;, dialogPrototype);
+        processElementNodes(dialogElem, &quot;switchoption&quot;, dialogPrototype);
+        processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
+        processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
+
+        for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
+        {
+            if (hasNodeName(curChild, &quot;variable&quot;))
+            {
+                createDialogVariable(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, &quot;option&quot;))
+            {
+                processOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
+            }
+            else if (hasNodeName(curChild, &quot;switchoption&quot;))
+            {
+                processSwitchOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, &quot;response&quot;))
+            {
+                processResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
+            }
+            else if (hasNodeName(curChild, &quot;switchresponse&quot;))
+            {
+                processSwitchResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, &quot;start&quot;))
+            {
+                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL; 
+                    curChildChild = curChildChild-&gt;getNextSibling())
+                {
+                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
+                    if (response)
+                    {
+                        dialogPrototype-&gt;setStartResponse(response);
+                    }
+                }
+            }
+        }
+    }
+
+    void DialogManager::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype)
+    {
+        DOMNodeList* dialogElemNodes = dialogXml-&gt;getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
+        for (XMLSize_t i = 0; i &lt; dialogElemNodes-&gt;getLength(); ++i)
+        {
+            DOMElement* dialogElemXml = static_cast&lt;DOMElement*&gt;(dialogElemNodes-&gt;item(i));
+            if (!hasAttribute(dialogElemXml, &quot;id&quot;))
+            {
+                Throw(WrongFormatException, &quot;option/switchoption/response/switchresponse node without id found&quot;);
+            }
+            int id = getAttributeValueAsInteger(dialogElemXml, &quot;id&quot;);
+            CeGuiString text = getValueAsString(dialogElemXml);
+
+            if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
+            {
+                DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
+                option-&gt;setLabel(text);
+                dialogPrototype-&gt;addOption(option);
+            }
+            else if (hasNodeName(dialogElemXml, &quot;option&quot;))
+            {
+                DialogOption* option = new DialogOption(id);
+                if (hasAttribute(dialogElemXml, &quot;label&quot;))
+                {
+                    option-&gt;setLabel(getAttributeValueAsString(dialogElemXml, &quot;label&quot;));
+                }
+                else
+                {
+                    option-&gt;setLabel(text);
+                }
+                dialogPrototype-&gt;addOption(option);
+            }
+            else if (hasNodeName(dialogElemXml, &quot;response&quot;))
+            {
+                dialogPrototype-&gt;addResponse(new DialogResponse(id));
+            }
+            else if (hasNodeName(dialogElemXml, &quot;switchresponse&quot;))
+            {
+                dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
+            }
+        }
+        
+    }
+
+    DialogResponse* DialogManager::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    {
+        DialogResponse* response = NULL;
+        if (hasNodeName(node, &quot;response&quot;))
+        {
+            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
+        }
+        else if (hasNodeName(node, &quot;gotoresponse&quot;))
+        {
+            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
+        }
+        else if (hasNodeName(node, &quot;switchresponse&quot;))
+        {
+            response = processSwitchResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
+        }
+        return response;
+    }
+
+    DialogResponse* DialogManager::processResponse(DOMElement *responseXml, DialogManager::DialogPrototype *dialogPrototype, bool subelements)
+    {
+        int id = getAttributeValueAsInteger(responseXml, &quot;id&quot;);
+        DialogResponse* response = dialogPrototype-&gt;getResponse(id);
+
+        if (!response)  Throw(IllegalArgumentException, &quot;No response with ID &quot;+StringConverter::toString(id));
+
+        if (subelements)
+        {
+            bool paragraphsDefined = false;
+
+            for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+            {
+                DialogOption* option = processOptionClasses(cur, dialogPrototype);
+                if (option)
+                {
+                    response-&gt;addOption(option);
+                    continue;
+                }
+
+                DialogImplication* implication = processImplicationClasses(cur);
+                if (implication)
+                {
+                    response-&gt;addImplication(implication);
+                    continue;
+                }
+
+                if (hasNodeName(cur, &quot;p&quot;))
+                {
+                    response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+                    paragraphsDefined = true;
+                }
+                else if (hasNodeName(cur, &quot;gotoresponse&quot;))
+                {
+                    int id = getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(cur), &quot;id&quot;);
+                    response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
+                }
+            }
+
+            if (!paragraphsDefined)
+            {
+                CeGuiString responseXmlText = getValueAsString(responseXml);
+                response-&gt;addParagraph(new DialogParagraph(responseXmlText));
+            }
+        }            
+
+        return response;
+    }
+
+    DialogResponse* DialogManager::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
+    {
+        int id = getAttributeValueAsInteger(switchRespXml, &quot;id&quot;);
+        DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
+
+        if (!response)  Throw(IllegalArgumentException, &quot;No switchresponse with ID &quot;+StringConverter::toString(id));
+
+        for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
+            if (variable != NULL)
+            {
+                response-&gt;setVariable(variable);
+            }
+            else if (hasNodeName(cur, &quot;case&quot;))
+            {
+                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
+                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
+                {
+                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
+                    if (responseCase)
+                    {
+                         response-&gt;addElement(condition, responseCase);
+                         break;
+                    }
+                }               
+            }
+        }
+
+
+        return response;
+    }
+
+    DialogOption* DialogManager::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    {
+        DialogOption* option = NULL;
+        if (hasNodeName(node, &quot;option&quot;))
+        {
+            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
+        }
+        else if (hasNodeName(node, &quot;optionref&quot;))
+        {
+            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
+        }
+        else if (hasNodeName(node, &quot;switchoption&quot;))
+        {
+            option = processSwitchOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
+        }
+        return option;
+    }
+
+    DialogOption* DialogManager::processOption(DOMElement *optionXml, DialogManager::DialogPrototype *dialogPrototype, bool subelements)
+    {
+        int id = getAttributeValueAsInteger(optionXml, &quot;id&quot;);
+        DialogOption* option = dialogPrototype-&gt;getOption(id);
+
+        if (!option)    Throw(IllegalArgumentException, &quot;No option with ID &quot;+StringConverter::toString(id));
+
+        if (subelements)
+        {
+            bool paragraphsDefined = false;
+
+            for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+            {
+                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
+                if (response)
+                {
+                    option-&gt;setResponse(response);
+                }
+                else if (hasNodeName(cur, &quot;if&quot;))
+                {
+                    option-&gt;setPrecondition(processIf(static_cast&lt;DOMElement*&gt;(cur)));
+                }
+                else if (hasNodeName(cur, &quot;p&quot;))
+                {
+                    option-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+                    paragraphsDefined = true;
+                }
+            }
+
+            if (!paragraphsDefined)
+            {
+                CeGuiString optionXmlText = getValueAsString(optionXml);
+                option-&gt;addParagraph(new DialogParagraph(optionXmlText));
+            }
+        }
+
+        return option;
+    }
+
+    DialogOption* DialogManager::processSwitchOption(DOMElement *switchOptXml, DialogManager::DialogPrototype *dialogPrototype)
+    {
+        int id = getAttributeValueAsInteger(switchOptXml, &quot;id&quot;);
+        DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
+
+        if (!option) Throw(IllegalArgumentException, &quot;No switchoption with ID &quot;+StringConverter::toString(id));
+
+        for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
+            if (variable != NULL)
+            {
+                option-&gt;setVariable(variable);
+            }
+            else if (hasNodeName(cur, &quot;case&quot;))
+            {
+                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
+                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
+                {
+                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
+                    if (optionCase)
+                    {
+                         option-&gt;addElement(condition, optionCase);
+                         break;
+                    }
+                }               
+            }
+        }
+            
+        return option;
+    }
+
+    void DialogManager::createDialogVariable(DOMElement *variableXml, DialogManager::DialogPrototype *dialogPrototype)
+    {
+        XmlPropertyReader reader;
+        PropertyEntry entry = reader.processProperty(variableXml);
+        dialogPrototype-&gt;setProperty(entry.first, entry.second);
+    }
+
+    DialogCondition* DialogManager::processIf(DOMElement *ifXml)
+    {
+        DialogCondition* cond = NULL;
+        DialogVariable* var = NULL;
+
+        for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+            {
+                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
+
+                DialogCondition* curCond = processConditionClasses(curElem);
+                if (curCond)
+                {
+                    cond = curCond;
+                }
+
+                DialogVariable* curVar = processVariableClasses(curElem);
+                if (curVar)
+                {
+                    var = curVar;
+                }
+            }
+        }
+
+        cond-&gt;setVariable(var);
+        return cond;
+    }
+
+    DialogParagraph* DialogManager::processParagraph(DOMElement* paragraphXml)
+    {
+        Ogre::String voicefile = &quot;&quot;;
+        if (hasAttribute(paragraphXml, &quot;voicefile&quot;))
+        {
+            voicefile = getAttributeValueAsStdString(paragraphXml, &quot;voicefile&quot;);
+        }
+        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
+    }
+
+    DialogCondition* DialogManager::processCase(DOMElement *caseXml)
+    {
+        DialogCondition* cond = NULL;
+
+        for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+            {
+                DialogCondition* curCond = processConditionClasses(static_cast&lt;DOMElement*&gt;(cur));
+                if (curCond)
+                {
+                    cond = curCond;
+                }
+            }
+        }
+
+        return cond;
+    }
+
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, GameObject* pc, GameObject* npc)
+    {
+        std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator it = mDialogs.find(name);
+        if (it == mDialogs.end())
+        {
+            return NULL;
+        }
+
+        return it-&gt;second-&gt;createDialog(pc, npc);
+    }
+
+    void DialogManager::DialogPrototype::addOption(DialogOption* option)
+    {
+        if (mOptionCache.find(option-&gt;getId()) != mOptionCache.end())
+        {
+            Throw(IllegalArgumentException, 
+                &quot;Duplicate option/switchoption ID &quot;+Ogre::StringConverter::toString(option-&gt;getId()));
+        }
+        mOptionCache[option-&gt;getId()] = option;
+    }
+
+    DialogOption* DialogManager::DialogPrototype::getOption(int id) const
+    {
+        std::map&lt;int, DialogOption*&gt;::const_iterator it = mOptionCache.find(id);
+        if (it == mOptionCache.end())
+        {
+            return NULL;
+        }
+        return it-&gt;second;
+    }
+
+    void DialogManager::DialogPrototype::addResponse(DialogResponse* response)
+    {
+        if (mResponseCache.find(response-&gt;getId()) != mResponseCache.end())
+        {
+            Throw(IllegalArgumentException, 
+                &quot;Duplicate Response/switchResponse ID &quot;+Ogre::StringConverter::toString(response-&gt;getId()));
+        }
+        mResponseCache[response-&gt;getId()] = response;
+    }
+
+    DialogResponse* DialogManager::DialogPrototype::getResponse(int id) const
+    {
+        std::map&lt;int, DialogResponse*&gt;::const_iterator it = mResponseCache.find(id);
+        if (it == mResponseCache.end())
+        {
+            return NULL;
+        }
+        return it-&gt;second;
+    }
+
+    Dialog* DialogManager::DialogPrototype::createDialog(GameObject* pc, GameObject* npc)
+    {
+        Dialog* dialog = new Dialog(pc, npc);
+        dialog-&gt;setStartResponse(mDialogStart);
+        
+        for (PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
+            it != mPropertyVariables.end(); ++it)
+        {
+            dialog-&gt;setProperty(it-&gt;first, it-&gt;second);
+        }
+
+        return dialog;
+    }
+
+    void DialogManager::DialogPrototype::setProperty(const Ogre::String &amp;key, const rl::Property &amp;value)
+    {
+        mPropertyVariables.setProperty(key, value);
+    }
+
+    void DialogManager::DialogPrototype::setStartResponse(DialogResponse* start)
+    {
+        mDialogStart = start;
+    }
+
+    DialogVariable* DialogManager::processVariableClasses(DOMElement* variableXml)
+    {
+        if (hasNodeName(variableXml, &quot;dialogvariable&quot;))
+        {
+            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, &quot;name&quot;));
+        }
+
+        return NULL;
+    }
+
+    DialogCondition* DialogManager::processConditionClasses(DOMElement* conditionXml)
+    {
+        if (hasNodeName(conditionXml, &quot;equals&quot;))
+        {
+            return new DialogConditionEquals(getAttributeValueAsString(conditionXml, &quot;value&quot;));
+        }
+
+        return NULL;
+    }
+
+    DialogImplication* DialogManager::processImplicationClasses(DOMNode* implicationXml)
+    {
+        if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+        {
+            DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
+
+            if (hasNodeName(implicationElem, &quot;setvariable&quot;))
+            {
+                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
+                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
+                return new DialogVariableAssignment(variableName, variableValue);
+            }
+        }
+
+        return NULL;
+    }
+}

Modified: rl/trunk/engine/ai/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogOption.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogOption.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -16,49 +16,54 @@
 #include &quot;stdinc.h&quot; //precompiled header
 
 #include &quot;DialogOption.h&quot;
-#include &quot;DialogResponse.h&quot;
-#include &quot;AiSubsystem.h&quot;
-#include &quot;ContextInterpreter.h&quot;
-#include &quot;Response.h&quot;
 
-namespace rl {
+#include &quot;DialogCondition.h&quot;
 
-DialogOption::DialogOption(const Response&lt;CeGuiString&gt;&amp; pData, AimlBot&lt;CeGuiString&gt;* pBot)
-	: mBot(pBot), mData(new Response&lt;CeGuiString&gt;(pData))
+namespace rl
 {
-}
 
-DialogOption::~DialogOption(void)
-{
-	if(mData)
-	{
-		delete mData;
-	}
-}
+    DialogOption::DialogOption(int id)
+    : DialogElement(id), mPrecondition(NULL), mLabel(&quot;&quot;)
+    {
+    }
 
-const CeGuiString&amp; DialogOption::getText() const
-{
-	return mData-&gt;getResponse();
-}
+    DialogOption::~DialogOption()
+    {
+    }
 
-void DialogOption::processSelection()
-{
-	DialogResponse* response = NULL;
-	ContextInterpreter* interpreter = AiSubsystem::getSingleton().getContextInterpreter();
-	if(interpreter != NULL)
-	{
-		response = interpreter-&gt;interpret(mData-&gt;getGossip(), mBot);
-		LOG_MESSAGE(Logger::DIALOG, &quot;Parsed selected option&quot;);
-		if(response != NULL &amp;&amp; !response-&gt;getDialogOptions().empty())
-		{
-			DialogOption* option = (*response-&gt;getDialogOptions().begin());
-			mData-&gt;clear();
-			(*mData) += option-&gt;getText();
-			mId = option-&gt;getId();
-			mPatternId = option-&gt;getPattern();
-			delete response;
-		}
-	}
-}
+    void DialogOption::setResponse(DialogResponse *response)
+    {
+        mResponse = response;
+    }
 
+    DialogResponse* DialogOption::getResponse() const
+    {
+        return mResponse;
+    }
+
+    void DialogOption::setPrecondition(DialogCondition* precondition)
+    {
+        mPrecondition = precondition;
+    }
+
+    bool DialogOption::isAvailable(Dialog* dialog) const
+    {
+        if (mPrecondition)
+        {
+            return mPrecondition-&gt;isTrue(dialog);
+        }
+
+        return true;
+    }
+
+    void DialogOption::setLabel(const CeGuiString &amp;label)
+    {
+        mLabel = label;
+    }
+
+    const CeGuiString&amp; DialogOption::getLabel() const
+    {
+        return mLabel;
+    }
+
 }

Added: rl/trunk/engine/ai/src/DialogParagraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogParagraph.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogParagraph.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,57 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogParagraph.h&quot;
+
+namespace rl
+{
+
+    DialogParagraph::DialogParagraph(
+        const CeGuiString&amp; text, const Ogre::String&amp; voicefile)
+    : mText(text), mVoiceFile(voicefile)
+    {
+    }
+
+    DialogParagraph::~DialogParagraph(void)
+    {
+    }
+
+    const CeGuiString&amp; DialogParagraph::getText() const
+    {
+        return mText;
+    }
+
+    const Ogre::String&amp; DialogParagraph::getVoiceFile() const
+    {
+        return mVoiceFile;
+    }
+
+    DialogResponse* DialogParagraph::getResponse() const
+    {
+        return NULL;
+    }
+
+    DialogGotoResponse::DialogGotoResponse(rl::DialogResponse *response)
+        : DialogParagraph(&quot;&quot;, &quot;&quot;), mResponse(response)
+    {
+    }
+
+    DialogResponse* DialogGotoResponse::getResponse() const
+    {
+        return mResponse;
+    }
+}
\ No newline at end of file

Modified: rl/trunk/engine/ai/src/DialogResponse.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogResponse.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogResponse.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -16,38 +16,76 @@
 #include &quot;stdinc.h&quot; //precompiled header
 
 #include &quot;DialogResponse.h&quot;
+
+#include &quot;Dialog.h&quot;
+#include &quot;DialogImplication.h&quot;
 #include &quot;DialogOption.h&quot;
 
 namespace rl
 {
-	DialogResponse::DialogResponse( const CeGuiString&amp; input,
-									const CeGuiString&amp; response,
-									const Options&amp; currentOptions,
-									const Options&amp; selectableOptions,
-									NaturalLanguageProcessor* nlp)
-		:	mInput(input),
-			mResponse(response),
-			mCurrentOptions(currentOptions),
-			mSelectableOptions(selectableOptions),
-			mNlp(nlp)
-	{
-	}
+	DialogResponse::DialogResponse(int id, int npcId)
+        : DialogElement(id), mNpcId(npcId)
+    {
+    }
 
-	DialogResponse::DialogResponse( const Responses &amp;responses,
-									const DialogOptions &amp;options,
-									AimlBot&lt;CeGuiString&gt;* bot)
-		: mResponses(responses),
-		  mOptions(options),
-		  mBot(bot)
-	{
-	}
+    DialogResponse::~DialogResponse()
+    {
+    }
+    
 
-	DialogResponse::~DialogResponse(void)
-	{
-		DialogOptions::iterator itr = mOptions.begin();
-		for(; itr != mOptions.end(); ++itr)
-		{
-			delete (*itr);
-		}
-	}
+    void DialogResponse::addOption(rl::DialogOption *option)
+    {
+        mOptions.push_back(option);
+    }
+
+    const DialogResponse::Options&amp; DialogResponse::getOptions(Dialog* dialog) const
+    {
+        return mOptions;
+    }
+
+    const DialogResponse::Options DialogResponse::getAvailableOptions(Dialog* dialog) const
+    {
+        Options availableOptions;
+
+        Options allOptions = getOptions(dialog);
+        for (Options::const_iterator it = allOptions.begin(); it != allOptions.end(); ++it)
+        {
+            DialogOption* cur = *it;
+            if (cur-&gt;isAvailable(dialog))
+            {
+                availableOptions.push_back(cur);
+            }
+        }
+
+        return availableOptions;
+    }
+
+    void DialogResponse::addImplication(DialogImplication* implication)
+    {
+        mEffects.push_back(implication);
+    }
+
+    void DialogResponse::applyImplications(rl::Dialog *dialog)
+    {
+        for (Implications::iterator it = mEffects.begin(); it != mEffects.end(); ++it)
+        {
+            (*it)-&gt;apply(dialog);
+        }
+    }
+
+    GameObject* DialogResponse::getNpc(rl::Dialog *dialog) const
+    {
+        return dialog-&gt;getNpc(mNpcId);
+    }
+
+    DialogResponseSelection::DialogResponseSelection(int id)
+        : DialogSelection&lt;DialogResponse&gt;(id)
+    {
+    }
+
+    const DialogResponse::Options&amp; DialogResponseSelection::getOptions(Dialog* dialog) const
+    {
+        return getSelectedElement(dialog)-&gt;getOptions(dialog);
+    }
+
 }

Deleted: rl/trunk/engine/ai/src/DialogScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogScriptProcessor.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogScriptProcessor.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,57 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;DialogScriptProcessor.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-
-namespace rl {
-
-DialogScriptProcessor::DialogScriptProcessor()
-	: XmlNodeProcessor&lt;AimlBot, AimlCore, CeGuiString&gt;(&quot;script&quot;)
-{
-	initialize();
-}
-
-DialogScriptProcessor::~DialogScriptProcessor()
-{
-}
-
-void DialogScriptProcessor::initialize()
-{
-	addAttribute(&quot;src&quot;);
-	addAttribute(&quot;class&quot;);
-}
-
-void DialogScriptProcessor::preprocessStep()
-{
-	if( !(mAttributes[&quot;src&quot;].empty() &amp;&amp; mAttributes[&quot;class&quot;].empty() ) )
-	{
-		CoreSubsystem::getSingleton().getRubyInterpreter()
-			-&gt;execute((&quot;load \&quot;&quot; + mAttributes[&quot;src&quot;] + &quot;\&quot;&quot;).c_str());
-	//  create the string for instanciating the class
-		std::stringstream newDialogScriptObject;
-				newDialogScriptObject &lt;&lt; &quot;DialogSubsystem.getSingleton()&quot;;
-				newDialogScriptObject &lt;&lt; &quot;.setCurrentDialogCharacter(&quot;;
-				newDialogScriptObject &lt;&lt; mAttributes[&quot;class&quot;].c_str() &lt;&lt; &quot;.new())&quot;;
-				// execute the ruby command
-				CoreSubsystem::getSingleton().getRubyInterpreter()
-					-&gt;execute(newDialogScriptObject.str());
-	}
-}
-
-}

Added: rl/trunk/engine/ai/src/DialogVariable.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogVariable.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/DialogVariable.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -0,0 +1,58 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogVariable.h&quot;
+
+#include &quot;Dialog.h&quot;
+
+namespace rl
+{
+    DialogVariable::DialogVariable()
+        : mRecalculate(true)
+    {
+    }
+
+    DialogVariable::~DialogVariable()
+    {
+    }
+
+    const Property&amp; DialogVariable::getValue(Dialog* dialog)
+    {
+        if (mRecalculate)
+        {
+            mValue = calculateValue(dialog);
+            mRecalculate = false;
+        }
+
+        return mValue;
+    }
+
+    void DialogVariable::invalidate()
+    {
+        mRecalculate = true;
+    }
+
+    DialogPropertyVariable::DialogPropertyVariable(const Ogre::String &amp;propertyName)
+        : mPropertyName(propertyName)
+    {
+    }
+
+    Property DialogPropertyVariable::calculateValue(Dialog* dialog)
+    {
+        return dialog-&gt;getProperty(mPropertyName);
+    }
+}

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-11-04 13:24:21 UTC (rev 3961)
@@ -17,6 +17,14 @@
 	AStarNodePool.cpp \
 	AStarWayPointNode.cpp \
 	CreatureWalkPathJob.cpp \
+	Dialog.cpp \
+	DialogCondition.cpp \
+	DialogElement.cpp \
+	DialogImplication.cpp \
+	DialogManager.cpp \
+	DialogOption.cpp \
+	DialogResponse.cpp \
+	DialogVariable.cpp \
 	FuzzyState.cpp \
 	FuzzyStateMachine.cpp \
 	Landmark.cpp \
@@ -25,23 +33,4 @@
 	SteeringVehicle.cpp \
 	WayPointNode.cpp \
 	WayPointGraph.cpp \
-	WayPointGraphManager.cpp \
-	AimlNodeImplRl.cpp \
-	AimlParserImplRl.cpp \
-	ContextConditionProcessor.cpp \
-	ContextInterpreter.cpp \
-	DialogCharacter.cpp \
-	DialogOption.cpp \
-	DialogResponse.cpp \
-	DialogScriptProcessor.cpp \
-	ScriptProcessor.cpp \
-	predicates/CreaturePredicates.cpp \
-	predicates/EigenschaftsProbePredicates.cpp \
-	predicates/EigenschaftsWertPredicates.cpp \
-	predicates/GrundWertPredicates.cpp \
-	predicates/QuestKnownPredicates.cpp \
-	predicates/QuestPartsPredicates.cpp \
-	predicates/QuestStatePredicates.cpp \
-	predicates/ScriptPredicates.cpp \
-	predicates/TalentProbePredicates.cpp \
-	predicates/TalentWertPredicates.cpp	
+	WayPointGraphManager.cpp
\ No newline at end of file

Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/common/include/Property.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -99,6 +99,7 @@
         Ogre::String getName() const;
         CeGuiString getAsString() const;
         Ogre::Real getAsNumber() const;
+        void getFromString(const CeGuiString&amp; string);
 
         bool operator==(const Property&amp; other) const;
 

Modified: rl/trunk/engine/common/src/Property.cpp
===================================================================
--- rl/trunk/engine/common/src/Property.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/common/src/Property.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -1,77 +1,78 @@
-/* 
- * (C) 2003-2007. Team Pantheon. www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here:
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm">http://www.jpaulmorrison.com/fbp/artistic2.htm</A>
- */
-
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Property.h&quot;
-
-#include &quot;Exception.h&quot;
-
-using namespace boost;
-using namespace Ogre;
-
-namespace rl {
-
-    Property::Property()
-    {
-    }
-
-    Ogre::String Property::getTypeName() const
-    {
-        return mValue.type().name();
-    }
-
-    Ogre::String Property::getName() const
-    {
-        return mName;
-    }
-
-    bool Property::isEmpty() const
-    {
-        return mValue.empty();
-    }
-
-    bool Property::operator ==(const rl::Property &amp;other) const
-    {
-        if (other.getTypeName() == getTypeName())
-        {
-            return other.getAsString() == getAsString();
-        }
-
-        return false;
-    }
-
-    Ogre::Real Property::getAsNumber() const
-    {
-        if (isInt())
-        {
-            return toInt();
-        }
-        else if (isReal())
-        {
-            return toReal();
-        }
-        else
-        {
-            return 0;
-        }
-    }
-
-    CeGuiString Property::getAsString() const
-    {
+/* 
+ * (C) 2003-2007. Team Pantheon. www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here:
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm">http://www.jpaulmorrison.com/fbp/artistic2.htm</A>
+ */
+
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Property.h&quot;
+
+#include &quot;Exception.h&quot;
+#include &quot;CEGUIPropertyHelper.h&quot;
+
+using namespace boost;
+using namespace Ogre;
+
+namespace rl {
+
+    Property::Property()
+    {
+    }
+
+    Ogre::String Property::getTypeName() const
+    {
+        return mValue.type().name();
+    }
+
+    Ogre::String Property::getName() const
+    {
+        return mName;
+    }
+
+    bool Property::isEmpty() const
+    {
+        return mValue.empty();
+    }
+
+    bool Property::operator ==(const rl::Property &amp;other) const
+    {
+        if (other.getTypeName() == getTypeName())
+        {
+            return other.getAsString() == getAsString();
+        }
+
+        return false;
+    }
+
+    Ogre::Real Property::getAsNumber() const
+    {
+        if (isInt())
+        {
+            return toInt();
+        }
+        else if (isReal())
+        {
+            return toReal();
+        }
+        else
+        {
+            return 0;
+        }
+    }
+
+    CeGuiString Property::getAsString() const
+    {
         if (isBool())
         {
             return StringConverter::toString(toBool());
@@ -114,10 +115,61 @@
   //      {
   //          return StringConverter::toString(toBool());
   //      }
-		//else if (isMap())
+		//else if (isMap())
   //      {
   //          return StringConverter::toString(toBool());
   //      }
         return &quot;&quot;;
-    }
-}
+    }
+
+    void Property::getFromString(const CeGuiString&amp; str)
+    {
+        if (isBool())
+        {
+            mValue = CEGUI::PropertyHelper::stringToBool(str);
+        }
+        else if (isString())
+        {
+            mValue = str;
+        }
+        else if (isInt())
+        {
+            mValue = CEGUI::PropertyHelper::stringToInt(str);
+        }
+        else if (isReal())
+        {
+            mValue = CEGUI::PropertyHelper::stringToFloat(str);
+        }
+        else if (isVector3())
+        {
+            mValue = StringConverter::parseVector3(str.c_str());
+        }
+        else if (isQuaternion())
+        {
+            mValue = StringConverter::parseQuaternion(str.c_str());
+        }
+        ///@todo
+        //else if (isIntTriple())
+        //{
+        //    Tripel&lt;int&gt; triple = toIntTriple();
+        //    mValue = StringConverter::toString(triple.first)
+        //        + &quot;,&quot; + StringConverter::toString(triple.second)
+        //        + &quot;,&quot; + StringConverter::toString(triple.third);
+        //}
+        //else if (isIntPair())
+        //{
+        //    IntPair pair = toIntPair();
+        //    mValue = StringConverter::toString(pair.first)
+        //        + &quot;,&quot; + StringConverter::toString(pair.second);
+        //}
+		//else if (isArray()) 
+  //      {
+  //          mValue = StringConverter::toString(toBool());
+  //      }
+		//else if (isMap())
+  //      {
+  //          mValue = StringConverter::toString(toBool());
+  //      }
+        mValue = str;
+    }
+}

Modified: rl/trunk/engine/core/include/SaveGameFileReader.h
===================================================================
--- rl/trunk/engine/core/include/SaveGameFileReader.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/core/include/SaveGameFileReader.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -38,4 +38,4 @@
     };
 }
 
-#endif //#ifndef _SaveGameFileReader_H_
\ No newline at end of file
+#endif //#ifndef _SaveGameFileReader_H_

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -159,7 +159,7 @@
         mActions.push_back(make_pair(action, option));
         LOG_MESSAGE(Logger::RULES,
             &quot;Bei GameObject #&quot;+Ogre::StringConverter::toString(mId)+
-            &quot; (&quot;+getName()+&quot;) wurde Aktion &quot;+action-&gt;getName().c_str()+&quot; hinzugef&#252;gt.&quot;);
+            &quot; (&quot;+getName()+&quot;) wurde Aktion &quot;+action-&gt;getName().c_str()+&quot; hinzugef&#239;&#191;&#189;gt.&quot;);
     }
 
     void GameObject::addActionInGroup(Action* action, ActionGroup* group, int option)
@@ -186,7 +186,7 @@
             if ((*it).second == Action::ACT_DISABLED)
                 continue;
             //if ((*it).second &gt; ACT_NEEDS_TALENT)
-            if (actor != NULL &amp;&amp; !(*it).first-&gt;canDo(const_cast&lt;GameObject*&gt;(this), actor)) // Aktion nicht m&#246;glich
+            if (actor != NULL &amp;&amp; !(*it).first-&gt;canDo(const_cast&lt;GameObject*&gt;(this), actor)) // Aktion nicht m&#239;&#191;&#189;glich
                 continue;
 
             actions.push_back((*it).first);

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-11-04 13:24:21 UTC (rev 3961)
@@ -34,5 +34,6 @@
 #include &quot;Landmark.h&quot;
 #include &quot;LandmarkPath.h&quot;
 #include &quot;CreatureWalkPathJob.h&quot;
-#include &quot;DialogCharacter.h&quot;
+#include &quot;Dialog.h&quot;
+#include &quot;DialogManager.h&quot;
 %}
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-11-04 13:24:21 UTC (rev 3961)
@@ -77,6 +77,7 @@
     {
     public:
         void setDialogPartner(rl::Agent* partner);
+        void setDialog(rl::Dialog* dialog);
     private:
         AgentDialogState(rl::Agent* agent);
     };
@@ -93,37 +94,10 @@
         void pushState(rl::AgentStateType type);
 	};
 
-    %feature(&quot;director&quot;) DialogCharacter;
-	class DialogCharacter
-	{
-	public:
-		DialogCharacter();
-		virtual ~DialogCharacter();
-
-		const rl::CeGuiString getName() const;
-		rl::Creature* getDialogCharacter() const;
-		void setDialogCharacter(rl::Creature* dialogCharacter);
-		rl::Creature* getDialogPartner() const;
-		void setDialogPartner(rl::Creature* dialogPartner);
-		
-		rl::Creature* getNonPlayerCharacter()const;
-		void setNonPlayerCharacter(rl::Creature* npc);
-		
-		rl::Creature* getPlayerCharacter()const;
-		void setPlayerCharacter(rl::Creature* pc);
-		
-		virtual int calcOptionValue(const rl::CeGuiString&amp; optionName)=0;	
-		virtual int calcResponseValue(const rl::CeGuiString&amp; responseName)=0;
-		virtual int calcSelectionValue(const rl::CeGuiString&amp; selectionName)=0;
-	};
-
 	class AiSubsystem 
 	{
 	public:
 		static AiSubsystem&amp; getSingleton(void);
-		rl::DialogCharacter* getBot(const rl::CeGuiString&amp; botName);
-		rl::DialogCharacter* loadBot(const rl::CeGuiString&amp; fileName, const rl::CeGuiString&amp; botName = &quot;&quot;);
-		void setCurrentDialogCharacter(rl::DialogCharacter* bot);
 	};
 	
 	%feature(&quot;director&quot;) BehaviourFactory;
@@ -277,23 +251,38 @@
 	class LandmarkPath
 	{
 	public:
-		typedef std::deque&lt;Landmark*&gt; LandmarkList;
+        typedef std::deque&lt;rl::Landmark*&gt; LandmarkList;
 		LandmarkPath(const Ogre::String&amp; name);
 
 		void addPoint(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
-		void addPoint(Landmark* lm);
-        LandmarkList getPoints();
+		void addPoint(rl::Landmark* lm);
+        rl::LandmarkPath::LandmarkList getPoints();
 	};
 	
 	class CreatureWalkPathJob : public Job
     {
     public:
-        CreatureWalkPathJob(const Ogre::String&amp; name, CreatureController* movingCreature, Landmark* startLandmark);
+        CreatureWalkPathJob(const Ogre::String&amp; name, rl::CreatureController* movingCreature, rl::Landmark* startLandmark);
 
         void addLandmark(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
-        void addLandmark(Landmark* lm);
-        void setWayPoints(const WayPointGraph* wps);
+        void addLandmark(rl::Landmark* lm);
+        void setWayPoints(const rl::WayPointGraph* wps);
     };
+
+    class Dialog
+    {
+    private:
+        Dialog(rl::GameObject* npc, rl::GameObject* pc);
+    };
+
+    class DialogManager
+    {
+    public:
+        static rl::DialogManager&amp; getSingleton();
+        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::GameObject* npc, rl::GameObject* pc);
+    private:
+        DialogManager();
+    };
 } // Namespace
 
 %{

Modified: rl/trunk/engine/ui/include/DialogControlState.h
===================================================================
--- rl/trunk/engine/ui/include/DialogControlState.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ui/include/DialogControlState.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -25,10 +25,14 @@
 namespace rl {
 
 	class Actor;
-	class DialogCharacter;
+	class Dialog;
+    class DialogElement;
+	class DialogOption;
+	class DialogParagraph;
 	class DialogResponse;
 	class DialogWindow;
 	class GameLoggerWindow;
+    class GameObject;
 	class MeshAnimation;
 	class SoundObject;
 	class SubtitleWindow;
@@ -60,15 +64,14 @@
 		/// @override
 		virtual void run(Ogre::Real elapsedTime);
 
-		/// Setzt den Dialogpartner (Diealogf&#252;hrenden Spieler-Actor)
-		void setDialogPartner(Actor* partner);
+		void start(Dialog* dialog);
 
 		/// Antwort eines der Dialogf&#252;hrenden
 		void response(Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile = &quot;&quot;);
 
         virtual bool mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled);
 
-		bool handleDialogSelectOption();	
+		bool handleDialogSelectOption(DialogOption* option);	
 		bool handleDialogClose();
 		bool requestDialogClose();
 
@@ -85,15 +88,17 @@
 
         Ogre::Real mSubtitleSpeed;
 
-		/// Der Untertitel Text
+		/// Der Untertitel-Text
 		CeGuiString mText;
 		/// Es wird gerade Text angezeigt
 		bool mTextShown;
 
-		/// Der Spieler der redet
-		Actor* mDialogPartner;
-		/// Der Besitzer des Dialoges (Der Bauer mit dem der Spieler redet)
-		Actor* mCurrentActor;
+		GameObject* mCurrentSpeaker;
+		GameObject* mCurrentListener;
+        DialogResponse* mCurrentResponse;
+        DialogOption* mCurrentOption;
+        std::list&lt;DialogParagraph*&gt; mCurrentParagraphs;
+
         /// Die Art der Kamerapositinierung
         DialogMode mDialogMode;
 
@@ -104,7 +109,7 @@
 		SoundObject* mSoundObject;
 	
 		float getShowTextLength(const CeGuiString&amp; text) const;
-        void recalculateCamera( Actor* speaker, Actor* listener );
+        void recalculateCamera(GameObject* speaker, GameObject* listener );
 
 		enum DialogState
 		{
@@ -114,28 +119,17 @@
 			CLOSING_DIALOG
 		};
 
-		DialogCharacter* mBot;
-		DialogResponse* mCurrentResponse;
+		Dialog* mDialog;
 		GameLoggerWindow* mGameLogger;
 		DialogState mState;
 		CeGuiString mCurrentResponseText;
 				
-		void getOptions(const CeGuiString&amp; question);
+        void showResponse(DialogResponse* response);
+        void showOptions(const std::list&lt;DialogOption*&gt;&amp; options);
+        void doTalk(DialogParagraph* paragraph);
+        Ogre::Vector3 getParticipantPosition(GameObject* participant);
 
-		static const CeGuiString DIALOG_START;
-		static const CeGuiString DIALOG_EXIT;
-		static const CeGuiString DIALOG_END;
-
-		void getResponse(const CeGuiString&amp; msg);
-		unsigned int count();
-		void setCallback(Ogre::String function);
-		int getSelectedOption();
-
-		void initialize(DialogCharacter* bot);
 		void textFinished();
-
-        void start();
-
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/include/DialogWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DialogWindow.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ui/include/DialogWindow.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -23,6 +23,7 @@
 #include &lt;map&gt;
 
 #include &quot;AbstractWindow.h&quot;
+#include &quot;DialogResponse.h&quot;
 
 namespace rl {
 
@@ -35,16 +36,20 @@
 
 		void setName(const CeGuiString&amp; name);
 		void setImage(const CeGuiString&amp; imageset, const CeGuiString&amp; image);
-		void setAvailableOptions(const CeGuiStringVector&amp; options);
+        void setAvailableOptions(const DialogResponse::Options&amp; options);
 		void setChosenOption(const CeGuiString&amp; option);
 		void setResponse(const CeGuiString&amp; response);
 		void setDialogEnd();
 		int getSelectedOptionIndex() const;
 
 	private:
+        bool handleDialogSelectOption();
+
 		static const CEGUI::colour COLOR_PLAYER_CHARACTER;
 		static const CEGUI::colour COLOR_NON_PLAYER_CHARACTER;
 
+        DialogControlState* mController;
+
 		CEGUI::Listbox* mDialogOptions;
 		CEGUI::Window* mImage;
 		CEGUI::Listbox* mQuestion;

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ui/include/InputManager.h	2007-11-04 13:24:21 UTC (rev 3961)
@@ -34,9 +34,10 @@
 namespace rl {
 
     class AbstractWindow;
-    class GameObject;
     class ControlState;
     class CommandMapper;
+    class Dialog;
+    class GameObject;
 
     class _RlUiExport InputManager
         :    public Ogre::Singleton&lt;InputManager&gt;,
@@ -98,7 +99,7 @@
         enum Modifiers {ALT_MASK = 1, CTRL_MASK = 2, SHIFT_MASK = 4, SUPER_MASK = 8};
 
         void initializeOis(Ogre::RenderWindow* wnd);
-        bool startDialog(/* CeGuiString dialog */);
+        bool startDialog(Dialog* dialog);
 
         Ogre::Vector3 mSavedMouseState;
 

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -25,7 +25,9 @@
 #include &quot;CommandMapper.h&quot;
 #include &quot;ConfigurationManager.h&quot;
 #include &quot;CoreSubsystem.h&quot;
-#include &quot;DialogCharacter.h&quot;
+#include &quot;Dialog.h&quot;
+#include &quot;DialogElement.h&quot;
+#include &quot;DialogParagraph.h&quot;
 #include &quot;DialogOption.h&quot;
 #include &quot;DialogResponse.h&quot;
 #include &quot;DialogWindow.h&quot;
@@ -51,10 +53,6 @@
 
 namespace rl {
 
-	const CeGuiString DialogControlState::DIALOG_START = &quot;1&quot;;
-	const CeGuiString DialogControlState::DIALOG_END = &quot;DIALOG BEENDET&quot;;
-	const CeGuiString DialogControlState::DIALOG_EXIT = &quot;EXIT&quot;;
-
     DialogControlState::DialogControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_DIALOG),
@@ -70,10 +68,10 @@
         mSoundObject(NULL),
         mTalkAnimation(NULL),
         mSubtitleSpeed(1.0f),
-		mCurrentResponse(NULL),
 		mCurrentResponseText(&quot;&quot;),
-		mBot(NULL),
-		mGameLogger(NULL)
+		mGameLogger(NULL),
+        mCurrentSpeaker(NULL),
+        mCurrentListener(NULL)
     {
         mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
             &quot;General&quot;, &quot;Subtitle Speed&quot;);
@@ -118,59 +116,67 @@
         ogreCam-&gt;setOrientation(Quaternion::IDENTITY);
         mCameraActor-&gt;_getSceneNode()-&gt;setFixedYawAxis(true);
 
-        mDialogWindow = new DialogWindow(this);
-        mSubtitleWindow = new SubtitleWindow();
+        if (!mDialogWindow)
+        {
+            mDialogWindow = new DialogWindow(this);
+        }
+        if (!mSubtitleWindow)
+        {
+            mSubtitleWindow = new SubtitleWindow();
+        }
+        mDialogWindow-&gt;setVisible(true);
+        mSubtitleWindow-&gt;setVisible(true);
 
 		mGameLogger = WindowFactory::getSingleton().getGameLogger();
-
-		DialogCharacter* bot = AiSubsystem::getSingleton().getCurrentDialogCharacter();
-		initialize(bot);
     }
 
-	void DialogControlState::initialize(DialogCharacter* bot)
+	void DialogControlState::start(Dialog* dialog)
 	{
-		mBot = bot;
-        mBot-&gt;setDialogCharacter(mCharacter);
-		mDialogPartner = mBot-&gt;getDialogPartner()-&gt;getActor();
+		mDialog = dialog;
 
-        recalculateCamera( mDialogPartner, mCharacterActor );
+		//Ogre::String voiceFile = mBot-&gt;getVoiceFile().c_str();
+		//if (voiceFile != &quot;&quot;)
+		//{
+		//	if (voiceFile.find(&quot;.zip&quot;) != Ogre::String::npos)
+		//	{
+		//		ResourceGroupManager::getSingleton().addResourceLocation(
+		//			voiceFile, &quot;Zip&quot;, voiceFile);
+		//	}
+		//	else
+		//	{
+		//		ResourceGroupManager::getSingleton().addResourceLocation(
+  //         			voiceFile, &quot;FileSystem&quot;, voiceFile);
+		//	}
+		//}
 
-		Ogre::String voiceFile = mBot-&gt;getVoiceFile().c_str();
-		if (voiceFile != &quot;&quot;)
+		if (!mDialog || !mDialogWindow)
 		{
-			if (voiceFile.find(&quot;.zip&quot;) != Ogre::String::npos)
-			{
-				ResourceGroupManager::getSingleton().addResourceLocation(
-					voiceFile, &quot;Zip&quot;, voiceFile);
-			}
-			else
-			{
-				ResourceGroupManager::getSingleton().addResourceLocation(
-           			voiceFile, &quot;FileSystem&quot;, voiceFile);
-			}
+			Throw(IllegalStateException, &quot;DialogControlState not properly initialized.&quot;);
 		}
 
-		start();
+        mCurrentSpeaker = mDialog-&gt;getNpc(0);
+        mCurrentListener = mDialog-&gt;getPc(0);
+        showResponse(mDialog-&gt;getDialogStart());
 	}
 
     void DialogControlState::run(Real elapsedTime)
     {
-        if ( elapsedTime &lt;= 0.0 )
+        if (elapsedTime &lt;= 0.0)
             return;
 
         // Aktuellen Abstand zur gew&#195;&#188;nschten Position berechnen
         Vector3 posDistance = (mTargetCameraPosition - mCameraActor-&gt;_getSceneNode()-&gt;getPosition());
         // Ist eine Anpassung n&#195;&#182;tig?
-        if ( posDistance != Vector3::ZERO )
+        if (posDistance != Vector3::ZERO)
         {
             // Die Kameraanpassgeschwindigkeit
             Real speed = 1/elapsedTime;
             mCameraActor-&gt;setPosition(mTargetCameraPosition);
         }
 
-        mCameraActor-&gt;setOrientation( Quaternion::IDENTITY );
-        mCameraActor-&gt;_getSceneNode()-&gt;setDirection( mTargetCameraDirection );
-        mCameraActor-&gt;_getSceneNode()-&gt;_update( true, false );
+        mCameraActor-&gt;setOrientation(Quaternion::IDENTITY);
+        mCameraActor-&gt;_getSceneNode()-&gt;setDirection(mTargetCameraDirection);
+        mCameraActor-&gt;_getSceneNode()-&gt;_update(true, false);
 
         // Textanzeigedauer
         if (mCurrFadeTextTime &gt;= 0)
@@ -200,44 +206,38 @@
                 + StringConverter::toString(mCurrFadeTextTime));
     }
 
-    void DialogControlState::recalculateCamera( Actor* speaker, Actor* listener )
+    void DialogControlState::recalculateCamera(GameObject* speaker, GameObject* listener)
     {
         // Position camera at position between char and dialog partner
-        Vector3 charEyes = speaker-&gt;getWorldPosition();
-        // Modify by MeshBounds
-        if ( speaker-&gt;getControlledObject()-&gt;isMeshObject() )
-        {
-            MeshObject* mo = dynamic_cast&lt;MeshObject*&gt;(speaker-&gt;getControlledObject());
-            Ogre::AxisAlignedBox aab = mo-&gt;getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            charEyes += speaker-&gt;getWorldOrientation()*offset;
-        }
+        Vector3 speakerEyes = getParticipantPosition(speaker);
+        Vector3 listenerEyes = getParticipantPosition(listener);
+        Vector3 globalCameraPosition = (speakerEyes + listenerEyes) / 2.0f;
 
-        Vector3 partEyes = listener-&gt;getWorldPosition();
+        // Weltkoordinaten in lokale umwandeln
+        mTargetCameraPosition =
+            -1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldOrientation().Inverse()*
+            (mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldPosition() - globalCameraPosition));
+
+        mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
+    }
+
+    Vector3 DialogControlState::getParticipantPosition(GameObject* participant)
+    {
+        Vector3 eyesPosition = participant-&gt;getPosition();
+
         // Modify by MeshBounds
-        if ( listener-&gt;getControlledObject()-&gt;isMeshObject() )
+        if (participant-&gt;getActor() &amp;&amp; participant-&gt;getActor()-&gt;getControlledObject()-&gt;isMeshObject())
         {
-            MeshObject* mo = dynamic_cast&lt;MeshObject*&gt;(listener-&gt;getControlledObject());
+            MeshObject* mo = static_cast&lt;MeshObject*&gt;(participant-&gt;getActor()-&gt;getControlledObject());
             Ogre::AxisAlignedBox aab = mo-&gt;getDefaultSize();
             Vector3 offset(
                 aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            partEyes += listener-&gt;getWorldOrientation()*offset;
+                aab.getMaximum().y * 0.933,
+                aab.getCenter().z);
+            eyesPosition += participant-&gt;getOrientation() * offset;
         }
 
-        Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
-
-        // Weltkoordinaten in lokale umwandeln
-        mTargetCameraPosition =
-            -1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldOrientation().Inverse()*
-            (mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldPosition() - globalCameraPosition));
-
-
-        mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
+        return eyesPosition;
     }
 
     float DialogControlState::getShowTextLength(const CeGuiString&amp; text) const
@@ -246,21 +246,23 @@
                0.25f;                   // Fade in
     }
 
-    void DialogControlState::response(
-        Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile)
+    void DialogControlState::doTalk(DialogParagraph* paragraph)
     {
-        if ( actor == mDialogPartner )
-            recalculateCamera( mCharacterActor, mDialogPartner );
-        else
-            recalculateCamera( mDialogPartner, mCharacterActor );
+        mDialogWindow-&gt;setVisible(false);
+        Ogre::String soundFile = paragraph-&gt;getVoiceFile();
+        CeGuiString text = paragraph-&gt;getText();
 
+        recalculateCamera(mCurrentSpeaker, mCurrentListener);
+
+        Actor* actor = mCurrentSpeaker-&gt;getActor();
+
         // Ungef&#195;&#164;hre Lesedauer bestimmen
         float fadeTime = getShowTextLength(text);
         if (soundFile.length() == 0)
         {
             float speed = mSubtitleSpeed;
 
-            if ( mSubtitleSpeed == 0.0 )
+            if (mSubtitleSpeed == 0.0)
                 speed = 1.0;
 
             mCurrFadeTextTime = fadeTime*speed;
@@ -268,18 +270,20 @@
         }
         else
         {
-            if ( mSoundObject != NULL )
+            if (mSoundObject != NULL)
+            {
                 mSoundObject-&gt;getMovableObject()-&gt;getParentSceneNode()-&gt;detachObject(
-                    mSoundObject-&gt;getMovableObject() );
+                    mSoundObject-&gt;getMovableObject());
+                delete mSoundObject;
+            }
 
-            delete mSoundObject;
             mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()-&gt;
                     createSound(soundFile, ST_SAMPLE), soundFile);
 
             // An Sprecher h&#195;&#164;ngen
-            actor-&gt;_getSceneNode()-&gt;attachObject( mSoundObject-&gt;getMovableObject() );
-            actor-&gt;_getSceneNode()-&gt;_update( true, false );
-            mSoundObject-&gt;_setActor( actor );
+            actor-&gt;_getSceneNode()-&gt;attachObject(mSoundObject-&gt;getMovableObject());
+            actor-&gt;_getSceneNode()-&gt;_update(true, false);
+            mSoundObject-&gt;_setActor(actor);
             mSoundObject-&gt;set3d(true);
             mSoundObject-&gt;play();
             mSoundObject-&gt;_update();
@@ -320,12 +324,13 @@
         OIS::MouseButtonID id, bool handled)
     {
         bool retval = false;
-        if( ControlState::mouseReleased(evt, id, handled) )
+        if (ControlState::mouseReleased(evt, id, handled))
             retval = true;
 
-        if( !handled &amp;&amp; !retval )
+        if (!handled &amp;&amp; !retval)
         {
-            if (mTextShown &amp;&amp; (mCurrFadeTextTime + 0.25) &lt; mTotalFadeTextTime)
+            if (mTextShown &amp;&amp; 
+                (mCurrFadeTextTime + 0.25 &lt; mTotalFadeTextTime))
             {
                 mCurrFadeTextTime = -1;
                 retval = true;
@@ -335,146 +340,84 @@
         return retval;
     }
 
-	void DialogControlState::start()
+    void DialogControlState::showResponse(DialogResponse* response)
 	{
-		if (!mBot || !mDialogWindow)
+        if (!response )
 		{
-			Throw(IllegalStateException, &quot;DialogControlState not properly initialized.&quot;);
-		}
-
-		mDialogWindow-&gt;setName(mBot-&gt;getName());
-		getResponse(DIALOG_START);
-	}
-
-	void DialogControlState::getResponse(const CeGuiString&amp; msg)
-	{
-		delete mCurrentResponse;
-		mCurrentResponse = mBot-&gt;createResponse(msg);
-
-		if (mBot-&gt;hasExitRequest())
-		{
 			mDialogWindow-&gt;setDialogEnd();
 			mState = CLOSING_DIALOG;
 			handleDialogClose();
 			return;
 		}
-		if (mCurrentResponse == NULL)
-		{
-			mDialogWindow-&gt;setDialogEnd();
-			mState = CLOSING_DIALOG;
-		//	&#195;&#156;bergangsl&#195;&#182;sung, wenn gerade kein sprecher aktiv ist wird
-		//	nicht nicht textFinished aufgerufen
-		//  hier m&#195;&#188;sste wahrscheinlich requestClose auftauchen
-			handleDialogClose();
-			return;
-		}
 
-		DialogResponse::Responses responses = mCurrentResponse-&gt;getResponses();
-		CeGuiString responseSound = &quot;null.ogg&quot;;
-		CeGuiString responseText;
-		if (!responses.empty())
-		{
-			responseSound = responses.begin()-&gt;first;
-			responseText = responses.begin()-&gt;second;
-			responseText.c_str();
-			responseSound.c_str();
-		}
+        mState = TALKING_PARTNER_CHARACTER;
+		mCurrentResponse = response;
+        mCurrentOption = NULL;
 
-		response(mBot-&gt;getDialogPartner()-&gt;getActor(),
-				responseText, responseSound.c_str());
-
-		if (!responseText.empty())
-		{
-			mDialogWindow-&gt;setResponse(responseText);
-
-			mGameLogger-&gt;logDialogEvent(mBot-&gt;getName(), responseText);
-			LOG_MESSAGE(Logger::DIALOG, mBot-&gt;getName() + &quot; says: &quot; + responseText);
-		}
-
 		mDialogWindow-&gt;setVisible(false);
-		mState = TALKING_PARTNER_CHARACTER;
-		mCurrentResponseText = msg;
+
+        mCurrentListener = mCurrentSpeaker;
+        mCurrentSpeaker = response-&gt;getNpc(mDialog);
+        mCurrentParagraphs = response-&gt;getParagraphs(mDialog);
+        DialogParagraph* firstParagraph = mCurrentParagraphs.front();
+        response-&gt;applyImplications(mDialog);
+        if (!firstParagraph-&gt;getResponse())
+        {
+            doTalk(firstParagraph);
+        }
+        else
+        {
+            showResponse(firstParagraph-&gt;getResponse());
+        }
 	}
 
 	void DialogControlState::textFinished()
 	{
-		if (mState == TALKING_PARTNER_CHARACTER)
-		{
-			getOptions(mCurrentResponseText);
-			mDialogWindow-&gt;setVisible(true);
-			mState = CHOOSING_OPTION;
-		}
+        mCurrentParagraphs.pop_front();
+        if (!mCurrentParagraphs.empty())
+        {
+            DialogParagraph* curParagraph = mCurrentParagraphs.front();
+            if (curParagraph-&gt;getResponse() == NULL)
+            {
+                doTalk(curParagraph);
+            }
+            else
+            {
+                showResponse(curParagraph-&gt;getResponse());
+            }
+        }
+        else
+        {
+		    if (mState == TALKING_PARTNER_CHARACTER)
+		    {
+                mCurrentListener = mCurrentSpeaker;
+                mCurrentSpeaker = mCharacter;
 
-		if (mState == TALKING_PLAYER_CHARACTER)
-		{
-			getResponse(mCurrentResponseText);
-		}
+                DialogResponse::Options options = mCurrentResponse-&gt;getAvailableOptions(mDialog);
+                mDialogWindow-&gt;setAvailableOptions(options);
+		        mDialogWindow-&gt;setVisible(true);
+		        mState = CHOOSING_OPTION;
+		    }
+            else if (mState == TALKING_PLAYER_CHARACTER)
+            {
+                showResponse(mCurrentOption-&gt;getResponse());
+            }
+        }
 
 		LOG_DEBUG(Logger::UI,
 					StringConverter::toString(mState)
-					+ &quot; bei textFinished&quot; );
+					+ &quot; bei textFinished&quot;);
 	}
 
-	void DialogControlState::getOptions(const CeGuiString&amp; question)
+	bool DialogControlState::handleDialogSelectOption(DialogOption* option)
 	{
-		if (mCurrentResponse == NULL)
-		{
-			Throw(rl::IllegalStateException, &quot;mCurrentResponse must not be NULL.&quot;);
-			return;
-		}
+        mCurrentOption = option;
+        mState = TALKING_PLAYER_CHARACTER;
+        mCurrentListener = mCurrentSpeaker;
+        mCurrentSpeaker = mDialog-&gt;getPc(0); ///@todo allow char switch 
+        mCurrentParagraphs = option-&gt;getParagraphs(mDialog);
+        doTalk(mCurrentParagraphs.front());
 
-		DialogResponse::DialogOptions options = mCurrentResponse-&gt;getDialogOptions();
-
-		if (options.empty())
-		{
-			mDialogWindow-&gt;setDialogEnd();
-			handleDialogClose();
-			return;
-		}
-
-		//mDialogOptions-&gt;clearAllSelections();
-
-		CeGuiStringVector optionTexts;
-		for(DialogResponse::DialogOptions::const_iterator itr = options.begin();
-			itr != options.end(); ++itr)
-		{
-			CeGuiString currentOption = (*itr)-&gt;getText();
-			LOG_DEBUG(Logger::UI, &quot;Player option: &quot; + currentOption);
-
-			optionTexts.push_back(currentOption);
-			///@todo mark attribute/talent checks
-		}
-
-		mDialogWindow-&gt;setAvailableOptions(optionTexts);
-	}
-
-	bool DialogControlState::handleDialogSelectOption()
-	{
-		int idx = mDialogWindow-&gt;getSelectedOptionIndex();
-		if (idx != -1)
-		{
-			DialogOption* option = mCurrentResponse-&gt;getDialogOptions()[idx];
-			option-&gt;processSelection();
-			mCurrentResponseText = option-&gt;getPattern();
-			CeGuiString selectedOption = option-&gt;getText();
-			if (mCurrentResponseText != &quot;0&quot; &amp;&amp; mCurrentResponseText != &quot;666&quot;)
-			{
-				if (!selectedOption.empty())
-				{
-					mState = TALKING_PLAYER_CHARACTER;
-					mGameLogger-&gt;logDialogEvent(&quot;Held&quot;, selectedOption);
-					LOG_MESSAGE(Logger::DIALOG,
-						&quot;Player says: &quot; + selectedOption);
-					mDialogWindow-&gt;setChosenOption(selectedOption);
-					response(
-						mBot-&gt;getDialogCharacter()-&gt;getActor(),
-						selectedOption,
-						option-&gt;getId().c_str());
-					mDialogWindow-&gt;setVisible(false);
-				}
-			}
-		}
-
 		return true;
 	}
 
@@ -489,7 +432,7 @@
 	bool DialogControlState::requestDialogClose()
 	{
 	//	handleClose is called automatically
-		getResponse(DIALOG_EXIT);
+		//@todo
 		return true;
 	}
 

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -24,10 +24,10 @@
 #include &quot;ConfigurationManager.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;DebugWindow.h&quot;
-#include &quot;DialogCharacter.h&quot;
+#include &quot;DialogControlState.h&quot;
+#include &quot;DialogOption.h&quot;
+#include &quot;DialogParagraph.h&quot;
 #include &quot;DialogResponse.h&quot;
-#include &quot;DialogOption.h&quot;
-#include &quot;DialogControlState.h&quot;
 #include &quot;GameLoggerWindow.h&quot;
 #include &quot;InputManager.h&quot;
 #include &quot;ListboxWrappedTextItem.h&quot;
@@ -43,7 +43,8 @@
 	const CEGUI::colour DialogWindow::COLOR_NON_PLAYER_CHARACTER(0xFFFFFF7F);
 
 	DialogWindow::DialogWindow(DialogControlState* controller)
-	  : AbstractWindow(&quot;dialogwindow.xml&quot;, WIT_MOUSE_INPUT, false)
+	  : AbstractWindow(&quot;dialogwindow.xml&quot;, WIT_MOUSE_INPUT, false),
+      mController(controller)
 	{
 		mImage = getWindow(&quot;DialogWindow/Image&quot;);
 		mName = getWindow(&quot;DialogWindow/Name&quot;);
@@ -56,7 +57,7 @@
 
 		mDialogOptions-&gt;subscribeEvent(
 			Listbox::EventSelectionChanged, 
-			boost::bind(&amp;DialogControlState::handleDialogSelectOption, controller));
+			boost::bind(&amp;DialogWindow::handleDialogSelectOption, this));
 
 		mDialogOptions-&gt;moveToFront();
 		mDialogOptions-&gt;setClippedByParent(true);
@@ -91,49 +92,51 @@
 		setResponse(&quot;&quot;);
 	}
 
-	void DialogWindow::setAvailableOptions(const CeGuiStringVector&amp; options)
+    void DialogWindow::setAvailableOptions(const DialogResponse::Options&amp; options)
 	{
-		unsigned int i = 0;
-		for(CeGuiStringVector::const_iterator itr = options.begin(); 
+		unsigned int optionCount = 0;
+		for(DialogResponse::Options::const_iterator itr = options.begin(); 
 			itr != options.end(); ++itr)
-		{	
+		{
+            DialogOption* cur = *itr;
+
 			ListboxWrappedTextItem* item = NULL;
-			if(i &lt; mDialogOptions-&gt;getItemCount())
+            CeGuiString text;
+            if (cur-&gt;getLabel().empty())
+            {
+                text = cur-&gt;getParagraphs(NULL).front()-&gt;getText();
+            }
+            else
+            {
+                text = cur-&gt;getLabel();
+            }
+
+			if(optionCount &lt; mDialogOptions-&gt;getItemCount())
 			{
 				item = static_cast&lt;ListboxWrappedTextItem*&gt;(
-					mDialogOptions-&gt;getListboxItemFromIndex(i));
-				item-&gt;setText(*itr);
+					mDialogOptions-&gt;getListboxItemFromIndex(optionCount));
+                item-&gt;setText(text);
+                item-&gt;setUserData(cur);
 			}
 			else
 			{
-				item =	new ListboxWrappedTextItem(*itr, 6, true);
+				item = new ListboxWrappedTextItem(text, 6, true);
+                item-&gt;setUserData(cur);
 				mDialogOptions-&gt;addItem(item);
 			}
 
 			item-&gt;setTextFormatting(CEGUI::WordWrapLeftAligned);
 			mDialogOptions-&gt;handleUpdatedItemData();
 
-			++i;
+			++optionCount;
 		}
-		while(i &lt; mDialogOptions-&gt;getItemCount())
+
+		while(optionCount &lt; mDialogOptions-&gt;getItemCount())
 		{
-			mDialogOptions-&gt;removeItem(mDialogOptions-&gt;getListboxItemFromIndex(i));
+			mDialogOptions-&gt;removeItem(mDialogOptions-&gt;getListboxItemFromIndex(optionCount));
 		}	
 	}
 
-	int DialogWindow::getSelectedOptionIndex() const
-	{
-		CEGUI::ListboxItem* curr = mDialogOptions-&gt;getFirstSelectedItem();
-		if (curr)
-		{
-			return mDialogOptions-&gt;getItemIndex(curr);
-		}
-		else
-		{
-			return -1;
-		}
-	}
-
 	void DialogWindow::setChosenOption(const CeGuiString&amp; option)
 	{
 		mPlayerText-&gt;setText(&quot;Held: &quot; + option);
@@ -145,4 +148,17 @@
 		mQuestion-&gt;handleUpdatedItemData();
 	}
 
+    bool DialogWindow::handleDialogSelectOption()
+    {
+		CEGUI::ListboxItem* curr = mDialogOptions-&gt;getFirstSelectedItem();
+		if (curr)
+		{
+            return mController-&gt;handleDialogSelectOption(static_cast&lt;DialogOption*&gt;(curr-&gt;getUserData()));
+		}
+		else
+		{
+			return -1;
+		}
+    }
+
 }

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -132,7 +132,7 @@
         mMouse-&gt;getMouseState().height = height;
 
         MessagePump::getSingleton().addMessageHandler&lt;MessageType_DialogStarted&gt;(
-            boost::bind(&amp;InputManager::startDialog, this/*, _1*/));
+            boost::bind(&amp;InputManager::startDialog, this, _1));
 
         LOG_DEBUG(Logger::UI, &quot;Done initializing input manager.&quot;);
     }
@@ -457,9 +457,10 @@
         }
     }
 
-    bool InputManager::startDialog(/* CeGuiString dialog */) 
+    bool InputManager::startDialog(Dialog* dialog)
     {
         pushControlState(CST_DIALOG);
+        dynamic_cast&lt;DialogControlState*&gt;(mControlStates.top())-&gt;start(dialog);
         return true;
     }
 

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-11-04 10:12:14 UTC (rev 3960)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-11-04 13:24:21 UTC (rev 3961)
@@ -27,7 +27,6 @@
 #include &quot;Console.h&quot;
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;DebugWindow.h&quot;
-#include &quot;DialogCharacter.h&quot;
 #include &quot;DialogControlState.h&quot;
 #include &quot;DialogWindow.h&quot;
 #include &quot;Exception.h&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001031.html">[Dsa-hl-svn] r3960 - modules/kanalisation/maps
</A></li>
	<LI>Next message: <A HREF="001033.html">[Dsa-hl-svn] r3962 - in rl/trunk/engine: ai/include ai/src ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1032">[ date ]</a>
              <a href="thread.html#1032">[ thread ]</a>
              <a href="subject.html#1032">[ subject ]</a>
              <a href="author.html#1032">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
