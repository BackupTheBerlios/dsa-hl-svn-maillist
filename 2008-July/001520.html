<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4449 - in rl/branches/newton20/engine: ai/src	core/include core/src rules/include rules/src script/src	ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4449%20-%20in%20rl/branches/newton20/engine%3A%20ai/src%0A%09core/include%20core/src%20rules/include%20rules/src%20script/src%0A%09ui/include%20ui/src&In-Reply-To=%3C200807141346.m6EDkAKY018367%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001519.html">
   <LINK REL="Next"  HREF="001521.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4449 - in rl/branches/newton20/engine: ai/src	core/include core/src rules/include rules/src script/src	ui/include ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4449%20-%20in%20rl/branches/newton20/engine%3A%20ai/src%0A%09core/include%20core/src%20rules/include%20rules/src%20script/src%0A%09ui/include%20ui/src&In-Reply-To=%3C200807141346.m6EDkAKY018367%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4449 - in rl/branches/newton20/engine: ai/src	core/include core/src rules/include rules/src script/src	ui/include ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Mon Jul 14 15:46:10 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001519.html">[Dsa-hl-svn] r4448 - rl/branches
</A></li>
        <LI>Next message: <A HREF="001521.html">[Dsa-hl-svn] r4450 - in modules/kanalisation: maps	materials/textures scripts/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1520">[ date ]</a>
              <a href="thread.html#1520">[ thread ]</a>
              <a href="subject.html#1520">[ subject ]</a>
              <a href="author.html#1520">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2008-07-14 15:45:55 +0200 (Mon, 14 Jul 2008)
New Revision: 4449

Modified:
   rl/branches/newton20/engine/ai/src/PhysicalObstacle.cpp
   rl/branches/newton20/engine/core/include/GameEventManager.h
   rl/branches/newton20/engine/core/include/GameLoop.h
   rl/branches/newton20/engine/core/include/PhysicalThing.h
   rl/branches/newton20/engine/core/include/PhysicsController.h
   rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h
   rl/branches/newton20/engine/core/include/PhysicsManager.h
   rl/branches/newton20/engine/core/src/DotSceneLoader.cpp
   rl/branches/newton20/engine/core/src/GameEventManager.cpp
   rl/branches/newton20/engine/core/src/GameLoop.cpp
   rl/branches/newton20/engine/core/src/PhysicalThing.cpp
   rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/branches/newton20/engine/core/src/PhysicsManager.cpp
   rl/branches/newton20/engine/rules/include/CreatureController.h
   rl/branches/newton20/engine/rules/include/CreatureControllerManager.h
   rl/branches/newton20/engine/rules/src/CreatureController.cpp
   rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp
   rl/branches/newton20/engine/rules/src/RotateMovement.cpp
   rl/branches/newton20/engine/rules/src/StandAroundMovement.cpp
   rl/branches/newton20/engine/script/src/EntityNodeProcessor.cpp
   rl/branches/newton20/engine/ui/include/FreeflightControlState.h
   rl/branches/newton20/engine/ui/include/MovementControlState.h
   rl/branches/newton20/engine/ui/src/ControlState.cpp
   rl/branches/newton20/engine/ui/src/FreeflightControlState.cpp
   rl/branches/newton20/engine/ui/src/MovementControlState.cpp
Log:
changes for newton2.0 ... not completely working yet, (ogrenewt for newton2.0 needed to use this, if you want to try this branch, ask me)


Modified: rl/branches/newton20/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/branches/newton20/engine/ai/src/PhysicalObstacle.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/ai/src/PhysicalObstacle.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -70,8 +70,8 @@
         Quaternion orientation;
         body-&gt;getPositionOrientation(position, orientation);
 
-    	OgreNewt::CollisionPtr collision = body-&gt;getCollision();
-    	RlAssert(collision.getPointer(), &quot;Body has no collision!&quot;);
+    	const OgreNewt::Collision* collision = body-&gt;getCollision();
+    	RlAssert(collision, &quot;Body has no collision!&quot;);
     	AxisAlignedBox box = collision-&gt;getAABB();
     	Ogre::Vector3 dims = box.getMaximum() - box.getMinimum();
     	OpenSteer::BoxObstacle *obstacle = new OpenSteer::BoxObstacle(dims[0], dims[1], dims[2]);

Modified: rl/branches/newton20/engine/core/include/GameEventManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/GameEventManager.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/include/GameEventManager.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -131,7 +131,7 @@
 
 
     /// newton collision callback function
-    int userProcess();
+    int userProcess(Ogre::Real timestep, int threadid);
 
     /// notify about newton world update
     void notifyNewtonWorldUpdate();

Modified: rl/branches/newton20/engine/core/include/GameLoop.h
===================================================================
--- rl/branches/newton20/engine/core/include/GameLoop.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/include/GameLoop.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -116,6 +116,7 @@
     unsigned long mSmoothedFrames;
     /// Time cap for frame time, to prevent interpolation problems during spikes.
     Ogre::Real mMaxFrameTime;
+    Ogre::Real mMinFrameTime;
     bool mQuitRequested;
     bool mPaused;
 

Modified: rl/branches/newton20/engine/core/include/PhysicalThing.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicalThing.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/include/PhysicalThing.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -120,7 +120,7 @@
         void _detachFromSceneNode(Ogre::SceneNode* node);
 
 		/** ForceCallback for mBody (OgreNewt::Body). */
-        void onApplyForceAndTorque();
+        void onApplyForceAndTorque(float timeStep);
         void addForce(const Ogre::Vector3&amp; force);
 
         void freeze();

Modified: rl/branches/newton20/engine/core/include/PhysicsController.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicsController.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/include/PhysicsController.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -39,7 +39,7 @@
 		 * to be applied to the associated PhysicalThing object.
 		 * @param thing PhysicalThing to apply force and torque to.
 		 */
-        virtual void OnApplyForceAndTorque(PhysicalThing* thing) = 0;
+        virtual void OnApplyForceAndTorque(PhysicalThing* thing, float timestep) = 0;
     };
 }
 

Modified: rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -32,7 +32,7 @@
     {
     public:
         int userBegin();
-        int userProcess();
+        int userProcess( Ogre::Real timeStep, int threadid);
         /// This function calls the contact listeners. So any specialised listener overriding
         /// this one, has to call it explicitly.
         void userEnd();

Modified: rl/branches/newton20/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicsManager.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/include/PhysicsManager.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -143,11 +143,11 @@
         // Newton callbacks ...
         /// generic force callback. Gravity is applied and the force,
         /// applied via PhysicalThing interface.
-        static void genericForceCallback(OgreNewt::Body* body);
+        static void genericForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         /// special force callback for controlled characters (or monsters even)
         /// those bodies have up vector and are controlled using inverse dynamics
-        static void controlledForceCallback(OgreNewt::Body* body);
+        static void controlledForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         OgreNewt::World* _getNewtonWorld() const;
 
@@ -288,6 +288,7 @@
         struct CollisionInUse
         {
         public:
+            CollisionInUse() : colPtr(NULL), geomType(GT_NONE) {}
             GeometryType geomType;  //! primitive type
             OgreNewt::CollisionPtr colPtr;          //! the collision primitve
         };

Modified: rl/branches/newton20/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/DotSceneLoader.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/src/DotSceneLoader.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -492,7 +492,7 @@
                 child = child-&gt;getNextSibling();
                 continue;
             }
-            collision.setNull();
+            collision = NULL;
             // am Anfang steht ein Node mit dem Typ
             std::string typeAsString = transcodeToStdString(child-&gt;getNodeName());
 
@@ -701,21 +701,21 @@
                 {
                     LOG_MESSAGE(Logger::CORE,
                         &quot; Mesh-Collisions in &lt;collisions&gt; werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-                    collision.setNull();
+                    collision = NULL;
                 }
 /*
                 else if (typeAsString.compare(&quot;meshhull&quot;) == 0)  // automatische convexhull mit daten aus mesh
                 {
                     LOG_MESSAGE(Logger::CORE,
                         &quot; Entityhull-Collisions werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-                    collision.setNull();
+                    collision = NULL;
                 }
 */
                 else
                 {
                     LOG_MESSAGE(Logger::CORE,
                         &quot; &gt; Parse Error beim Erstellen einer Collision; ung&#252;ltiger typ: '&quot;+typeAsString+&quot;' !&quot;);
-                    collision.setNull();
+                    collision = NULL;
                     //return OgreNewt::CollisionPtr(NULL);
                 }
 
@@ -723,7 +723,7 @@
 
 
             // Collision dem vektor hinzuf&#252;gen
-            if (!collision.isNull())
+            if (collision != NULL)
                 mCollisions.push_back(collision);
 
             child = child-&gt;getNextSibling();
@@ -868,9 +868,7 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
-                                    newEnt,
-                                    false));
-                    //orientation, pos));
+                                    newEnt));
                     LOG_DEBUG(Logger::CORE, &quot; physical_body 'convexhull' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
                 }
                 else if (physical_body.compare(&quot;mesh&quot;) == 0 || physical_body.compare(&quot;auto&quot;))
@@ -891,7 +889,7 @@
         }
 
         // zur liste hinzuf&#252;gen
-        if (!collision.isNull())
+        if (collision != NULL)
         {
             mCollisions.push_back(collision);
         }
@@ -906,7 +904,7 @@
 
 
         // wieder aus der liste entfernen, falls mehrere entities hier definiert werden
-        if (!collision.isNull())
+        if (collision != NULL)
         {
             mCollisions.pop_back();
         }

Modified: rl/branches/newton20/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/GameEventManager.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/src/GameEventManager.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -50,7 +50,7 @@
         physicsManager-&gt;createMaterialPair(area_mat, lev_mat)-&gt;setDefaultCollidable(0);// -&gt;setContactCallback(this);
 
         // set collision-debug color
-        physicsManager-&gt;getNewtonDebugger()-&gt;setMaterialColor(area_mat, Ogre::ColourValue::Green);
+        //physicsManager-&gt;getNewtonDebugger()-&gt;setMaterialColor(area_mat, Ogre::ColourValue::Green);
     }
 
     GameEventManager::~GameEventManager( )
@@ -275,7 +275,7 @@
         return NAME;
     }
 
-    int GameEventManager::userProcess()
+    int GameEventManager::userProcess(Real timestep, int)
     {
         NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(m_body0);
         if( it != mBodyGameAreaMap.end() )

Modified: rl/branches/newton20/engine/core/src/GameLoop.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/GameLoop.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/src/GameLoop.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -40,6 +40,7 @@
           mLastTimes(),
           mSmoothedFrames(3),
           mMaxFrameTime(0.1f),
+          mMinFrameTime(1.0/60),
           mQuitRequested(false),
           mPaused(false)
     {
@@ -138,6 +139,16 @@
         if( elapsedTime &lt; mGameTime )
             unsmoothedFrameTime = 1;
 
+        if( unsmoothedFrameTime &lt; mMinFrameTime*1000 )
+        {
+            usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            elapsedTime = mTimer-&gt;getMilliseconds();
+            unsmoothedFrameTime = elapsedTime - mGameTime;
+            if( elapsedTime &lt; mGameTime )
+                unsmoothedFrameTime = 1;
+        }
+
+
         if( unsmoothedFrameTime &gt; mMaxFrameTime*1000 )
         {
             LOG_DEBUG(Logger::CORE, &quot;The current frame time was truncated at maximum.&quot;);

Modified: rl/branches/newton20/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicalThing.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/src/PhysicalThing.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -145,7 +145,7 @@
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
     {
-        mBody-&gt;attachToNode(node);
+        mBody-&gt;attachNode(node);
     }
 
     void PhysicalThing::_attachToBone(MeshObject* object, const std::string&amp; boneName )
@@ -189,7 +189,7 @@
         mUpVectorJoint = NULL;
     }
 
-    void PhysicalThing::onApplyForceAndTorque()
+    void PhysicalThing::onApplyForceAndTorque(float timestep)
     {
         Vector3 gravity = mOverrideGravity ?
             mGravity : PhysicsManager::getSingleton().getGravity();
@@ -199,7 +199,7 @@
 
     void PhysicalThing::addForce(const Ogre::Vector3&amp; force)
     {
-        mBody-&gt;unFreeze();
+        //mBody-&gt;unFreeze();
         mPendingForce += force;
     }
 
@@ -210,8 +210,10 @@
 
     void PhysicalThing::setMass(Ogre::Real mass)
     {
+        Vector3 inertia;
+        mBody-&gt;getMassMatrix(mMass, inertia);
         mMass = mass;
-        mBody-&gt;setMass(mass);
+        mBody-&gt;setMassMatrix(mass, inertia);
     }
 
     void PhysicalThing::setGravityOverride(bool override, const Vector3&amp; gravity)
@@ -306,12 +308,12 @@
 
     void PhysicalThing::freeze()
     {
-        mBody-&gt;freeze();
+        //mBody-&gt;freeze();
     }
 
     void PhysicalThing::unfreeze()
     {
-        mBody-&gt;unFreeze();
+        //mBody-&gt;unFreeze();
     }
 
     void PhysicalThing::setContactListener(PhysicsContactListener* listener)
@@ -482,10 +484,10 @@
         {
             // prepare for control
             mPhysicsController = controller;
-            mBody-&gt;setAutoFreeze(0);
-            mBody-&gt;unFreeze();
-            mBody-&gt;setLinearDamping(0.0f);
-            mBody-&gt;setAngularDamping(Vector3::ZERO);
+            //mBody-&gt;setAutoFreeze(0);
+            //mBody-&gt;unFreeze();
+            //mBody-&gt;setLinearDamping(0.0f);
+            //mBody-&gt;setAngularDamping(Vector3::ZERO);
 
             mBody-&gt;setCustomForceAndTorqueCallback( PhysicsManager::controlledForceCallback );
 

Modified: rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -20,6 +20,9 @@
 #include &quot;Actor.h&quot;
 #include &quot;PhysicalThing.h&quot;
 
+
+using namespace Ogre;
+
 namespace rl
 {
     int PhysicsGenericContactCallback::userBegin()
@@ -27,7 +30,7 @@
         return 1;
     }
 
-    int PhysicsGenericContactCallback::userProcess()
+    int PhysicsGenericContactCallback::userProcess(Real timeStep, int)
     {
         return 1;
     }

Modified: rl/branches/newton20/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -99,7 +99,7 @@
         // setup level material
         createMaterialID(&quot;level&quot;);
 
-        mNewtonDebugger-&gt;setMaterialColor(getMaterialID(&quot;level&quot;), Ogre::ColourValue::Blue);
+        //mNewtonDebugger-&gt;setMaterialColor(getMaterialID(&quot;level&quot;), Ogre::ColourValue::Blue);
 
         // below here starts 'old' stale fix code that should be removed
 
@@ -306,15 +306,15 @@
 
         for( size_t i = 0; i &lt; collisions.size(); i++)
         {
-		    if( collisions[i].isNull() )
+		    if( collisions[i] == NULL )
                 continue;
 
             OgreNewt::CollisionPtr collision = collisions[i];
 
-		    OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
+            OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
 
 
-            body-&gt;attachToNode(node);
+            body-&gt;attachNode(node);
             body-&gt;setPositionOrientation(node-&gt;getWorldPosition(),
                 node-&gt;getWorldOrientation());
             body-&gt;setMaterialGroupID(getMaterialID(&quot;level&quot;));
@@ -364,26 +364,23 @@
 		*/
     }
 
-    // adopted from the chararcter demo in the newton sdk
-    // copyright 2000-2004
-    // By Julio Jerez
-    void PhysicsManager::genericForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::genericForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         // apply saved forces in the PhysicalThing
         PhysicalThing* thing =
             static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
 
-        thing-&gt;onApplyForceAndTorque();
+        thing-&gt;onApplyForceAndTorque(timestep);
     }
 
-    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         PhysicalThing* thing =
             static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
 
         if (thing-&gt;getPhysicsController())
         {
-            thing-&gt;getPhysicsController()-&gt;OnApplyForceAndTorque(thing);
+            thing-&gt;getPhysicsController()-&gt;OnApplyForceAndTorque(thing, timestep);
         }
         else
         {
@@ -480,7 +477,8 @@
         CollisionInUse &amp;usedcol (mCollisionPrimitives[collisionName]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -495,7 +493,27 @@
 
                 if( inertia )
                 {
+
                     // we must set inertia here, the calling function doesn't know we are not creating a new collision
+                    switch(usedcol.geomType)
+                    {
+                    case GT_BOX: // from createBox
+                    case GT_CAPSULE: // from createCapsule
+                    case GT_CONVEXHULL: // from createCollisionFromEntity
+                    case GT_ELLIPSOID: // from createEllipsoid
+                    case GT_PYRAMID: // createPyramid
+                    case GT_SPHERE:
+                        {
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+                        }
+                        break;
+                    case GT_MESH:
+                    case GT_NONE:
+                        *inertia = Ogre::Vector3::ZERO;
+                        break;
+                    }
+/*
                     Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
                     Vector3 size( aabb.getSize() );
                     switch(usedcol.geomType)
@@ -539,11 +557,12 @@
                         }
                         break;
                     }
+*/
                 }
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory-&gt;createCollisionFromEntity(
@@ -568,7 +587,8 @@
         CollisionInUse &amp;usedcol (mCollisionPrimitives[name]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -582,7 +602,7 @@
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory-&gt;createCollisionFromAABB(
@@ -804,14 +824,12 @@
 			// calculate the convex hull of the animated mesh
 			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-				entity, entity-&gt;hasSkeleton(), *orientation, *offset));
+				entity, /*entity-&gt;hasSkeleton(),*/ *orientation, *offset));
 
 			if (inertia != NULL)
 			{
-				*inertia = Vector3(
-				size.x*size.x/6.0f,
-				size.y*size.y/6.0f,
-				size.z*size.z/6.0f) * Mass;
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
 			}
         }
         else if (geomType == GT_MESH)
@@ -821,14 +839,14 @@
 
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-                entity, false, true));
+                entity, false/*, true */ ));
         }
         else
         {
             Throw(IllegalArgumentException, &quot;unknown geometry type.&quot;);
         }
 
-        if (rval.isNull())
+        if ( rval == NULL )
         {
             LOG_DEBUG(Logger::CORE, &quot; creating collision primitiv '&quot;+
                 PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' for Entity '&quot;+
@@ -860,13 +878,18 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia)
-            *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
 
-		// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
+        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
@@ -886,12 +909,17 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia)
-            *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
 
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox&amp; aabb,
@@ -914,14 +942,17 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
+ 
+        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            Vector3(radius, radius, radius), *orientation, *offset));
         if (inertia)
-            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
-            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
-
-		// a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-    		PhysicsManager::getSingleton()._getNewtonWorld(),
-            Vector3(radius, radius, radius), *orientation, *offset));
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+        }
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
@@ -945,13 +976,19 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia)
-            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
@@ -975,16 +1012,21 @@
     		offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia) {
-            double sradius = radius*radius;
-			*inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
-        }
 
-		// an capsule primitiv has got its coordinate system at its center, so shift it with radius
-		// additionally it is x axis aligned, so rotate it 90 degrees around z axis
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
+
+        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
+        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+        }
+        return rval;
     }
 
 }
+

Modified: rl/branches/newton20/engine/rules/include/CreatureController.h
===================================================================
--- rl/branches/newton20/engine/rules/include/CreatureController.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/rules/include/CreatureController.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -52,10 +52,10 @@
         bool run(Ogre::Real elapsedTime);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// Newton contact callback called by the movingCreatureManager
-        int userProcess();
+        int userProcess(Ogre::Real timestep, int threadid);
 
         Creature* getCreature() {return mCreature;}
         bool refetchCreature();

Modified: rl/branches/newton20/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/branches/newton20/engine/rules/include/CreatureControllerManager.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/rules/include/CreatureControllerManager.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -60,7 +60,7 @@
         const Ogre::String&amp; getName() const;
 
         // Newton Contact Callback
-        int userProcess();
+        int userProcess(Ogre::Real timestep, int threadid);
     protected:
         typedef std::map&lt;Creature*, CreatureController*&gt; ControllerMap;
         ControllerMap mControllers;

Modified: rl/branches/newton20/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/CreatureController.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/rules/src/CreatureController.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -80,7 +80,10 @@
 
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
 
+//        mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setAngularDamping(0*Vector3::UNIT_SCALE);
+        mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setContinuousCollisionMode(1);
 
+
         std::pair&lt;MovementType, AbstractMovement*&gt; movementPair;
         movementPair.first = MT_NONE;
         movementPair.second = NULL;
@@ -154,6 +157,8 @@
                 mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
 
                 mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setMaterialID(mOldMaterialId);
+        
+//                mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setAngularDamping(0.1*Vector3::UNIT_SCALE);
             }
         }
     }
@@ -359,14 +364,13 @@
         return false;
     }
 
-    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing)
+    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         Vector3 force, torque;
         OgreNewt::Body *body = thing-&gt;_getBody();
         force = Vector3::ZERO;
         torque = Vector3::ZERO;
         OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world-&gt;getTimeStep();
         Real mass;
         Vector3 inertia;
         body-&gt;getMassMatrix(mass, inertia);
@@ -387,8 +391,9 @@
         body-&gt;setTorque(torque);
     }
 
-    int CreatureController::userProcess()
+    int CreatureController::userProcess(Real timestep, int threadid)
     {
+
         // own collision handling (floor, in order to get information for mAbstractLocation)
         Vector3 point;
         Vector3 normal;
@@ -419,7 +424,29 @@
                 mLastFloorContact = time;
             }
         }
+/*
+        setContactFrictionState(0,0);
+        setContactFrictionState(0,1);
+        setContactTangentAcceleration(0, 0);
+        setContactTangentAcceleration(0, 1);
+        setContactNormalDirection(((Vector3::UNIT_Y.dotProduct(point-charPos)*Vector3::UNIT_Y + charPos) - point).normalisedCopy());
+        setContactNormalAcceleration(0);
 
+std::ostringstream oss;
+Vector3 vec1, vec2;
+oss &lt;&lt; &quot; Collision: Point: &quot; &lt;&lt; point
+    &lt;&lt; &quot;  \t Normal: &quot; &lt;&lt; normal
+    &lt;&lt; &quot;  \t Force: &quot; &lt;&lt; getContactForce()
+    &lt;&lt; &quot;  \t Normal-Speed: &quot; &lt;&lt; getContactNormalSpeed()
+    &lt;&lt; &quot;  \t Contact-Speed: &quot; &lt;&lt; point
+    &lt;&lt; &quot;  \t Contact-Normal: &quot; &lt;&lt; normal;
+getContactTangentDirections(vec1, vec2);
+oss &lt;&lt; &quot;  \t Tangent-Directions: &quot; &lt;&lt; vec1 &lt;&lt; &quot; &quot; &lt;&lt; vec2;
+LOG_MESSAGE(Logger::RULES, oss.str());
+*/
+        setContactFrictionState(0,0);
+        setContactFrictionState(0,1);
+/*
         if( stepHeight &lt; 0.4 )
         {
             if(stepHeight &gt; 0.01f) // experimantal value, 
@@ -437,7 +464,6 @@
                 setContactFrictionState(1,0);
                 setContactFrictionState(1,1);
             }
-            //setContactTangentAcceleration(5);
             //setContactElasticity(0.0f);
         }
         else
@@ -455,6 +481,7 @@
                 setContactFrictionState(0,1);
             }
         }
+*/
 
         if(mMovement != NULL)
         {
@@ -464,7 +491,7 @@
             // for processing this contact. Should probably be solved in OgreNewt directly.
             OgreNewt::ContactCallback *movement = mMovement;
             *movement = (OgreNewt::ContactCallback)(*this);
-            return movement-&gt;userProcess();
+            return movement-&gt;userProcess(timestep, threadid);
         }
 
         // return one to tell Newton we want to accept this contact

Modified: rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -44,15 +44,30 @@
 
         physicsManager-&gt;createMaterialPair(char_mat, def_mat)-&gt;setContactCallback(this);
         physicsManager-&gt;createMaterialPair(char_mat, level_mat)-&gt;setContactCallback(this);
-        
-        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultFriction(0.8f,0.4f);
-        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultFriction(0.8f,0.4f);
+        physicsManager-&gt;createMaterialPair(char_mat, char_mat); //-&gt;setContactCallback(this);
+
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultFriction(0.0f,0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultFriction(0.0f,0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultFriction(0.0f,0.0f);
         physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultElasticity(0.0f);
         physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultElasticity(0.0f);
-        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultSoftness(1.0f);
-        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultSoftness(1.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultElasticity(0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultSoftness(0.5f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultSoftness(0.5f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultSoftness(0.5f);
 
-        physicsManager-&gt;getNewtonDebugger()-&gt;setMaterialColor(char_mat, Ogre::ColourValue::Red);
+/*        
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultFriction(0.8f,0.4f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultFriction(0.8f,0.4f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultFriction(0.8f,0.4f);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultElasticity(0.01f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultElasticity(0.01f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultElasticity(0.01);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultSoftness(0.8f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultSoftness(0.8f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultSoftness(0.8f);
+*/
+        //physicsManager-&gt;getNewtonDebugger()-&gt;setMaterialColor(char_mat, Ogre::ColourValue::Red);
     }
 
     CreatureControllerManager::~CreatureControllerManager()
@@ -146,7 +161,7 @@
         }
     }
 
-    int CreatureControllerManager::userProcess()
+    int CreatureControllerManager::userProcess(Real timestep, int threadid)
     {
         Actor *actor = static_cast&lt;Actor*&gt;(m_body0-&gt;getUserData());
         if( actor != NULL )
@@ -159,8 +174,8 @@
                 // for the controllers to work. This is because these members are used by OgreNewt functions
                 // for processing this contact. Should probably be solved in OgreNewt directly.
                 OgreNewt::ContactCallback* controller = it-&gt;second;
-                *controller = (OgreNewt::ContactCallback)(*this);
-                return controller-&gt;userProcess();
+               *controller = (OgreNewt::ContactCallback)(*this);
+                return controller-&gt;userProcess(timestep, threadid);
             }
         }
 

Modified: rl/branches/newton20/engine/rules/src/RotateMovement.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/RotateMovement.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/rules/src/RotateMovement.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -28,7 +28,7 @@
     RotateMovement::RotateMovement(CreatureController *creature) : AbstractMovement(creature), mYaw(0)
     {
         mRotLinearSpringK = 600.0f;
-        Real relationCoefficient = 1.0f;
+        Real relationCoefficient = 1.1f;
         mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
     }
 

Modified: rl/branches/newton20/engine/rules/src/StandAroundMovement.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/StandAroundMovement.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/rules/src/StandAroundMovement.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -44,14 +44,14 @@
     {
         AbstractMovement::activate();
         getRotationMovement()-&gt;activate();
-        getStepRecognitionMovement()-&gt;activate();
+        //getStepRecognitionMovement()-&gt;activate();
     }
 
     void StandAroundMovement::deactivate()
     {
         AbstractMovement::deactivate();
         getRotationMovement()-&gt;deactivate();
-        getStepRecognitionMovement()-&gt;deactivate();
+        //getStepRecognitionMovement()-&gt;deactivate();
     }
 
     bool StandAroundMovement::calculateBaseVelocity(Real &amp;velocity)
@@ -89,7 +89,7 @@
         // (changing direction during slow movement makes char slide sideways)
         force.y = 0;
 
-        getStepRecognitionMovement()-&gt;calculateForceAndTorque(force, torque, timestep);
+        //getStepRecognitionMovement()-&gt;calculateForceAndTorque(force, torque, timestep);
     }
 
     bool StandAroundMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
@@ -104,9 +104,9 @@
         if( getRotationMovement()-&gt;isPossible() )
             if( getRotationMovement()-&gt;run(elapsedTime, direction, rotation) )
                 ret = true;
-        if( getStepRecognitionMovement()-&gt;isPossible() )
-            if (getStepRecognitionMovement()-&gt;run(elapsedTime, direction, rotation) )
-                ret = true;
+        //if( getStepRecognitionMovement()-&gt;isPossible() )
+        //    if (getStepRecognitionMovement()-&gt;run(elapsedTime, direction, rotation) )
+        //        ret = true;
         return ret;
     }
 

Modified: rl/branches/newton20/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/EntityNodeProcessor.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/script/src/EntityNodeProcessor.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -250,9 +250,7 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
-                                    entity,
-                                    false));
-                    //orientation, pos));
+                                    entity));
                     LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'convexhull' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;mesh&quot; || physicsProxyType == &quot;auto&quot;)
@@ -274,7 +272,7 @@
             }
         }
 
-        if (!collision.isNull())
+        if ( collision != NULL )
         {
             collisions.push_back(collision);
         }

Modified: rl/branches/newton20/engine/ui/include/FreeflightControlState.h
===================================================================
--- rl/branches/newton20/engine/ui/include/FreeflightControlState.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/ui/include/FreeflightControlState.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -59,10 +59,10 @@
 
         /// This is the OgreNewt contact process callback for the combination
         /// Character &lt;-&gt; Level
-        int userProcess();
+        int userProcess(Ogre::Real timestep, int threadid);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
 	private:		
 		int mCurrentMovementState;

Modified: rl/branches/newton20/engine/ui/include/MovementControlState.h
===================================================================
--- rl/branches/newton20/engine/ui/include/MovementControlState.h	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/ui/include/MovementControlState.h	2008-07-14 13:45:55 UTC (rev 4449)
@@ -60,10 +60,10 @@
 
         /// This is the OgreNewt contact process callback for the combination
         /// Character &lt;-&gt; Level
-        int userProcess();
+        int userProcess(Ogre::Real timestep, int threadid);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// First oder Third person view.
         void setViewMode(ViewMode mode);

Modified: rl/branches/newton20/engine/ui/src/ControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/ControlState.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/ui/src/ControlState.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -108,9 +108,9 @@
             PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
             PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;))-&gt;setDefaultCollidable(0);
 
-        PhysicsManager::getSingleton().getNewtonDebugger()-&gt;setMaterialColor(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            Ogre::ColourValue::Black);
+        //PhysicsManager::getSingleton().getNewtonDebugger()-&gt;setMaterialColor(
+        //    PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+        //    Ogre::ColourValue::Black);
 	}
 
     ControlState::~ControlState()

Modified: rl/branches/newton20/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/FreeflightControlState.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/ui/src/FreeflightControlState.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -286,7 +286,7 @@
         return retval;
 	}
 
-    int FreeflightControlState::userProcess()
+    int FreeflightControlState::userProcess(Real timestep, int)
     {
         if (m_body0 == mCamBody || m_body1 == mCamBody)
         {
@@ -307,14 +307,11 @@
 
 
 
-    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
         OgreNewt::Body* body = thing-&gt;_getBody();
 
-        // Get the current world timestep
-        Real timestep = world-&gt;getTimeStep();
-
         if (body == mCamBody)
         {
             // apply camera force

Modified: rl/branches/newton20/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-07-14 13:41:24 UTC (rev 4448)
+++ rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-07-14 13:45:55 UTC (rev 4449)
@@ -224,18 +224,21 @@
         mat_pair-&gt;setContactCallback(this);
         mat_pair-&gt;setDefaultCollidable(1);
         mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
             PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
             PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
         mat_pair-&gt;setContactCallback(this);
         mat_pair-&gt;setDefaultCollidable(1);
         mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
             PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
             PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
         mat_pair-&gt;setContactCallback(this);
         mat_pair-&gt;setDefaultCollidable(1);
         mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
 
         mCharacterState.mCurrentMovementState = MOVE_NONE;
 
@@ -698,7 +701,7 @@
 
     // -------------------------------------------------------------
     // character collision moved to CreatureController(Manager)
-    int MovementControlState::userProcess()
+    int MovementControlState::userProcess(Real timestep, int)
     {
         if( mViewMode == VM_FIRST_PERSON )
             return 0;
@@ -719,10 +722,9 @@
 
     //------------------------------------------------------------------------
     // character callback moved to CreatureController
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world-&gt;getTimeStep();
 
         calculateCamera(timestep);
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001519.html">[Dsa-hl-svn] r4448 - rl/branches
</A></li>
	<LI>Next message: <A HREF="001521.html">[Dsa-hl-svn] r4450 - in modules/kanalisation: maps	materials/textures scripts/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1520">[ date ]</a>
              <a href="thread.html#1520">[ thread ]</a>
              <a href="subject.html#1520">[ subject ]</a>
              <a href="author.html#1520">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
