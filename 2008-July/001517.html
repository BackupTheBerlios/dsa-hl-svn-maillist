<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4446 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/ai/include engine/ai/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4446%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/ai/include%20engine/ai/src&In-Reply-To=%3C200807111959.m6BJxhYS010677%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001516.html">
   <LINK REL="Next"  HREF="001518.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4446 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/ai/include engine/ai/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4446%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/ai/include%20engine/ai/src&In-Reply-To=%3C200807111959.m6BJxhYS010677%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4446 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/ai/include engine/ai/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Fri Jul 11 21:59:43 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001516.html">[Dsa-hl-svn] r4445 - in rl/trunk/engine/common: include src
</A></li>
        <LI>Next message: <A HREF="001518.html">[Dsa-hl-svn] r4447 - in rl/trunk/engine/ai: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1517">[ date ]</a>
              <a href="thread.html#1517">[ thread ]</a>
              <a href="subject.html#1517">[ subject ]</a>
              <a href="author.html#1517">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-07-11 21:59:08 +0200 (Fri, 11 Jul 2008)
New Revision: 4446

Added:
   rl/trunk/engine/ai/include/DialogLoader.h
   rl/trunk/engine/ai/src/DialogLoader.cpp
Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/ai/include/DialogManager.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/Makefile.am
Log:
Extracted DialogLoader from DialogManager 

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-07-11 19:59:08 UTC (rev 4446)
@@ -666,6 +666,22 @@
 		48B772E50D583521000A3B97 /* XmlPropertyWriter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */; };
 		48D0BDC70E23375E00863824 /* libruby.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
 		48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
+		48D0BE2C0E273C5E00863824 /* SaveAble.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE280E273C5E00863824 /* SaveAble.h */; };
+		48D0BE2D0E273C5E00863824 /* SaveAbleCollection.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE290E273C5E00863824 /* SaveAbleCollection.h */; };
+		48D0BE2E0E273C5E00863824 /* SaveAbleFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */; };
+		48D0BE2F0E273C5E00863824 /* SaveAbleManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */; };
+		48D0BE330E273C8000863824 /* WriteableDataStream.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE300E273C8000863824 /* WriteableDataStream.h */; };
+		48D0BE340E273C8000863824 /* WriteableDataStreamFormatTarget.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE310E273C8000863824 /* WriteableDataStreamFormatTarget.h */; };
+		48D0BE350E273C8000863824 /* WriteableFileSystemArchiv.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE320E273C8000863824 /* WriteableFileSystemArchiv.h */; };
+		48D0BE390E273C9700863824 /* WriteableDataStream.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE360E273C9700863824 /* WriteableDataStream.cpp */; };
+		48D0BE3A0E273C9700863824 /* WriteableDataStreamFormatTarget.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE370E273C9700863824 /* WriteableDataStreamFormatTarget.cpp */; };
+		48D0BE3B0E273C9700863824 /* WriteableFileSystemArchiv.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE380E273C9700863824 /* WriteableFileSystemArchiv.cpp */; };
+		48D0BE400E273CB000863824 /* SaveAble.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE3C0E273CB000863824 /* SaveAble.cpp */; };
+		48D0BE410E273CB000863824 /* SaveAbleCollection.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */; };
+		48D0BE420E273CB000863824 /* SaveAbleFactory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */; };
+		48D0BE430E273CB000863824 /* SaveAbleManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */; };
+		48D0BE690E273FF400863824 /* DialogLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE680E273FF400863824 /* DialogLoader.h */; };
+		48D0BE6D0E27401E00863824 /* DialogLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D0BE6B0E27401E00863824 /* DialogLoader.cpp */; };
 		48D34A630D90F5D500C89477 /* SaveGameData.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D34A610D90F5D500C89477 /* SaveGameData.h */; };
 		48D34A640D90F5D500C89477 /* SaveGameData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48D34A620D90F5D500C89477 /* SaveGameData.cpp */; };
 		48D34A7D0D91C7D800C89477 /* SaveGameFile.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056E0D71EDC40024198D /* SaveGameFile.h */; };
@@ -1457,6 +1473,22 @@
 		48B772E00D583521000A3B97 /* XmlProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlProcessor.cpp; path = ../engine/common/src/XmlProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E10D583521000A3B97 /* XmlPropertyReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyReader.cpp; path = ../engine/common/src/XmlPropertyReader.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAble.h; path = ../engine/core/include/SaveAble.h; sourceTree = SOURCE_ROOT; };
+		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleCollection.h; path = ../engine/core/include/SaveAbleCollection.h; sourceTree = SOURCE_ROOT; };
+		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleFactory.h; path = ../engine/core/include/SaveAbleFactory.h; sourceTree = SOURCE_ROOT; };
+		48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleManager.h; path = ../engine/core/include/SaveAbleManager.h; sourceTree = SOURCE_ROOT; };
+		48D0BE300E273C8000863824 /* WriteableDataStream.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStream.h; path = ../engine/common/include/WriteableDataStream.h; sourceTree = SOURCE_ROOT; };
+		48D0BE310E273C8000863824 /* WriteableDataStreamFormatTarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableDataStreamFormatTarget.h; path = ../engine/common/include/WriteableDataStreamFormatTarget.h; sourceTree = SOURCE_ROOT; };
+		48D0BE320E273C8000863824 /* WriteableFileSystemArchiv.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WriteableFileSystemArchiv.h; path = ../engine/common/include/WriteableFileSystemArchiv.h; sourceTree = SOURCE_ROOT; };
+		48D0BE360E273C9700863824 /* WriteableDataStream.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStream.cpp; path = ../engine/common/src/WriteableDataStream.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE370E273C9700863824 /* WriteableDataStreamFormatTarget.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableDataStreamFormatTarget.cpp; path = ../engine/common/src/WriteableDataStreamFormatTarget.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE380E273C9700863824 /* WriteableFileSystemArchiv.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WriteableFileSystemArchiv.cpp; path = ../engine/common/src/WriteableFileSystemArchiv.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE3C0E273CB000863824 /* SaveAble.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAble.cpp; path = ../engine/core/src/SaveAble.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleCollection.cpp; path = ../engine/core/src/SaveAbleCollection.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleFactory.cpp; path = ../engine/core/src/SaveAbleFactory.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveAbleManager.cpp; path = ../engine/core/src/SaveAbleManager.cpp; sourceTree = SOURCE_ROOT; };
+		48D0BE680E273FF400863824 /* DialogLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogLoader.h; path = ../engine/ai/include/DialogLoader.h; sourceTree = SOURCE_ROOT; };
+		48D0BE6B0E27401E00863824 /* DialogLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoader.cpp; path = ../engine/ai/src/DialogLoader.cpp; sourceTree = SOURCE_ROOT; };
 		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
 		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
 		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; lastKnownFileType = folder; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
@@ -1692,6 +1724,12 @@
 		444EAB1F0BD0E25C00C6D4A0 /* RlCommon */ = {
 			isa = PBXGroup;
 			children = (
+				48D0BE360E273C9700863824 /* WriteableDataStream.cpp */,
+				48D0BE370E273C9700863824 /* WriteableDataStreamFormatTarget.cpp */,
+				48D0BE380E273C9700863824 /* WriteableFileSystemArchiv.cpp */,
+				48D0BE300E273C8000863824 /* WriteableDataStream.h */,
+				48D0BE310E273C8000863824 /* WriteableDataStreamFormatTarget.h */,
+				48D0BE320E273C8000863824 /* WriteableFileSystemArchiv.h */,
 				485A056A0D71EDC40024198D /* MessageObject.h */,
 				485A057E0D71EDF20024198D /* MessagePump.cpp */,
 				485A056B0D71EDC40024198D /* MessagePump.h */,
@@ -1742,6 +1780,14 @@
 		444EAB200BD0E27400C6D4A0 /* RlCore */ = {
 			isa = PBXGroup;
 			children = (
+				48D0BE3C0E273CB000863824 /* SaveAble.cpp */,
+				48D0BE3D0E273CB000863824 /* SaveAbleCollection.cpp */,
+				48D0BE3E0E273CB000863824 /* SaveAbleFactory.cpp */,
+				48D0BE3F0E273CB000863824 /* SaveAbleManager.cpp */,
+				48D0BE280E273C5E00863824 /* SaveAble.h */,
+				48D0BE290E273C5E00863824 /* SaveAbleCollection.h */,
+				48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */,
+				48D0BE2B0E273C5E00863824 /* SaveAbleManager.h */,
 				485A05860D71EDF20024198D /* Trigger.cpp */,
 				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
 				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
@@ -1976,6 +2022,8 @@
 				444EAC680BD0E52E00C6D4A0 /* WayPointGraph.cpp */,
 				444EAC690BD0E52E00C6D4A0 /* WayPointGraphManager.cpp */,
 				444EAC6A0BD0E52E00C6D4A0 /* WayPointNode.cpp */,
+				48D0BE680E273FF400863824 /* DialogLoader.h */,
+				48D0BE6B0E27401E00863824 /* DialogLoader.cpp */,
 			);
 			name = RlAi;
 			sourceTree = &quot;&lt;group&gt;&quot;;
@@ -2388,6 +2436,9 @@
 				485A05740D71EDC40024198D /* MessageObject.h in Headers */,
 				485A05750D71EDC40024198D /* MessagePump.h in Headers */,
 				485A05760D71EDC40024198D /* MessageType.h in Headers */,
+				48D0BE330E273C8000863824 /* WriteableDataStream.h in Headers */,
+				48D0BE340E273C8000863824 /* WriteableDataStreamFormatTarget.h in Headers */,
+				48D0BE350E273C8000863824 /* WriteableFileSystemArchiv.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2476,6 +2527,10 @@
 				48D34A7F0D91C7D800C89477 /* SaveGameFileReader.h in Headers */,
 				48D34A800D91C7D800C89477 /* SaveGameFileWriter.h in Headers */,
 				48D34A810D91C7D800C89477 /* SaveGameManager.h in Headers */,
+				48D0BE2C0E273C5E00863824 /* SaveAble.h in Headers */,
+				48D0BE2D0E273C5E00863824 /* SaveAbleCollection.h in Headers */,
+				48D0BE2E0E273C5E00863824 /* SaveAbleFactory.h in Headers */,
+				48D0BE2F0E273C5E00863824 /* SaveAbleManager.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2521,6 +2576,7 @@
 				483D31620D85B398003477A0 /* DialogVariable.h in Headers */,
 				483D31630D85B398003477A0 /* SimpleVehicle.h in Headers */,
 				483D31640D85B398003477A0 /* WalkPathBehaviour.h in Headers */,
+				48D0BE690E273FF400863824 /* DialogLoader.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2992,6 +3048,9 @@
 				48B772E40D583521000A3B97 /* XmlPropertyReader.cpp in Sources */,
 				48B772E50D583521000A3B97 /* XmlPropertyWriter.cpp in Sources */,
 				485A05880D71EDF20024198D /* MessagePump.cpp in Sources */,
+				48D0BE390E273C9700863824 /* WriteableDataStream.cpp in Sources */,
+				48D0BE3A0E273C9700863824 /* WriteableDataStreamFormatTarget.cpp in Sources */,
+				48D0BE3B0E273C9700863824 /* WriteableFileSystemArchiv.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3072,6 +3131,10 @@
 				48389C290D867B1A00AFAB66 /* Trigger.cpp in Sources */,
 				48389C2C0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.cpp in Sources */,
 				48D34A640D90F5D500C89477 /* SaveGameData.cpp in Sources */,
+				48D0BE400E273CB000863824 /* SaveAble.cpp in Sources */,
+				48D0BE410E273CB000863824 /* SaveAbleCollection.cpp in Sources */,
+				48D0BE420E273CB000863824 /* SaveAbleFactory.cpp in Sources */,
+				48D0BE430E273CB000863824 /* SaveAbleManager.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3113,6 +3176,7 @@
 				48389BC00D8675E700AFAB66 /* DialogParagraph.cpp in Sources */,
 				48389BC10D8675E700AFAB66 /* DialogResponse.cpp in Sources */,
 				48389BC20D8675E700AFAB66 /* DialogVariable.cpp in Sources */,
+				48D0BE6D0E27401E00863824 /* DialogLoader.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Added: rl/trunk/engine/ai/include/DialogLoader.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoader.h	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/engine/ai/include/DialogLoader.h	2008-07-11 19:59:08 UTC (rev 4446)
@@ -0,0 +1,95 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __DialogLoader_H__
+#define __DialogLoader_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+#include &quot;Properties.h&quot;
+#include &quot;XmlProcessor.h&quot;
+ 
+namespace rl 
+{
+	class Creature;
+    class Dialog;
+    class DialogCondition;
+    class DialogElement;
+    class DialogImplication;
+    class DialogOption;
+    class DialogParagraph;
+    class DialogResponse;
+    class DialogVariable;
+	class Property;
+
+
+	class DialogLoader : public Ogre::ScriptLoader, private XmlProcessor
+	{
+	public:
+		DialogLoader();
+		~DialogLoader();
+	
+		virtual const Ogre::StringVector&amp; getScriptPatterns() const;
+        virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
+		virtual Ogre::Real getLoadingOrder() const;
+		
+		Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const;
+
+	private: 
+		class DialogPrototype
+        {
+        public:
+            DialogPrototype();
+            ~DialogPrototype();
+            void addOption(DialogOption* option);
+            DialogOption* getOption(const CeGuiString&amp; id) const;
+            void addResponse(DialogResponse* option);
+            DialogResponse* getResponse(const CeGuiString&amp; id) const;
+
+            void setStartResponse(DialogResponse* response);
+            Dialog* createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
+            void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+
+        private:
+            std::map&lt;CeGuiString, DialogOption*&gt; mOptionCache;
+            std::map&lt;CeGuiString, DialogResponse*&gt; mResponseCache;
+            DialogResponse* mDialogStart;
+            PropertyRecord mPropertyVariables;
+        };
+		
+        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
+        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
+        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
+        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
+        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
+        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
+        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
+        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
+        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
+        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
+        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
+        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
+        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
+        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
+
+        Ogre::StringVector mScriptPatterns;
+        std::map&lt;Ogre::String, DialogPrototype*&gt; mDialogs;
+
+	};
+}
+
+#endif //__DialogLoader_H__

Modified: rl/trunk/engine/ai/include/DialogManager.h
===================================================================
--- rl/trunk/engine/ai/include/DialogManager.h	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/engine/ai/include/DialogManager.h	2008-07-11 19:59:08 UTC (rev 4446)
@@ -1,129 +1,80 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef __DialogManager_H__
-#define __DialogManager_H__
-
-#include &quot;AiPrerequisites.h&quot;
-
-#include &quot;Properties.h&quot;
-#include &quot;SaveGameData.h&quot;
-#include &quot;XmlProcessor.h&quot;
-
-namespace rl
-{
-    class Creature;
-    class Dialog;
-    class DialogCondition;
-    class DialogElement;
-    class DialogImplication;
-    class DialogOption;
-    class DialogParagraph;
-    class DialogResponse;
-    class DialogVariable;
-
-    class _RlAiExport DialogManager 
-        : public Ogre::Singleton&lt;DialogManager&gt;, 
-        public Ogre::ScriptLoader, 
-        public PropertyHolder,
-        public SaveGameData,
-        private XmlProcessor
-    {
-    public:
-        static const Ogre::String PROPERTY_DIALOGS;
-        static const Ogre::String PROPERTY_DIALOG;
-        static const Ogre::String PROPERTY_DIALOG_NAME;
-        static const Ogre::String PROPERTY_NPCS;
-
-        DialogManager();
-        ~DialogManager();
-
-        virtual const Ogre::StringVector&amp; getScriptPatterns() const;
-        virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
-		virtual Ogre::Real getLoadingOrder() const;
-        Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc, rl::Creature* pc);
-        Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
-
-        virtual const Property getProperty(const CeGuiString&amp; key) const;
-        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-        virtual void writeData(SaveGameFileWriter *writer);
-        virtual void readData(SaveGameFileReader* reader);
-        virtual CeGuiString getXmlNodeIdentifier() const;
-        virtual int getPriority() const;
-
-    private:
-
-        class DialogPrototype
-        {
-        public:
-            DialogPrototype();
-            ~DialogPrototype();
-            void addOption(DialogOption* option);
-            DialogOption* getOption(const CeGuiString&amp; id) const;
-            void addResponse(DialogResponse* option);
-            DialogResponse* getResponse(const CeGuiString&amp; id) const;
-
-            void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
-            void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-
-        private:
-            std::map&lt;CeGuiString, DialogOption*&gt; mOptionCache;
-            std::map&lt;CeGuiString, DialogResponse*&gt; mResponseCache;
-            DialogResponse* mDialogStart;
-            PropertyRecord mPropertyVariables;
-        };
-
-        class DialogConfiguration
-        {
-        public:
-            DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs);
-
-            const Ogre::String&amp; getName() const;
-            const std::vector&lt;Creature*&gt;&amp; getNpcs() const;
-            
-            bool operator==(const DialogConfiguration&amp;) const;
-            bool operator&lt;(const DialogConfiguration&amp;) const;
-        private:
-            Ogre::String mDialogName;
-            std::vector&lt;Creature*&gt; mNpcs;
-        };
-
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
-
-        Ogre::StringVector mScriptPatterns;
-        std::map&lt;Ogre::String, DialogPrototype*&gt; mDialogs;
-        std::map&lt;DialogConfiguration, Dialog*&gt; mDialogStates;
-    };
-
-}
-
-#endif // __DialogManager_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef __DialogManager_H__
+#define __DialogManager_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+#include &quot;Properties.h&quot;
+#include &quot;SaveGameData.h&quot;
+#include &quot;XmlProcessor.h&quot;
+
+namespace rl
+{
+    class Creature;
+	class Dialog;
+	class DialogLoader;
+
+    class _RlAiExport DialogManager 
+        : public Ogre::Singleton&lt;DialogManager&gt;, 
+        public PropertyHolder,
+        public SaveGameData
+    {
+    public:
+        static const Ogre::String PROPERTY_DIALOGS;
+        static const Ogre::String PROPERTY_DIALOG;
+        static const Ogre::String PROPERTY_DIALOG_NAME;
+        static const Ogre::String PROPERTY_NPCS;
+
+        DialogManager();
+        ~DialogManager();
+
+        Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc, rl::Creature* pc);
+        Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
+
+        virtual const Property getProperty(const CeGuiString&amp; key) const;
+        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+        virtual void writeData(SaveGameFileWriter *writer);
+        virtual void readData(SaveGameFileReader* reader);
+        virtual CeGuiString getXmlNodeIdentifier() const;
+        virtual int getPriority() const;
+
+    private:
+ 
+        class DialogConfiguration
+        {
+        public:
+            DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs);
+
+            const Ogre::String&amp; getName() const;
+            const std::vector&lt;Creature*&gt;&amp; getNpcs() const;
+            
+            bool operator==(const DialogConfiguration&amp;) const;
+            bool operator&lt;(const DialogConfiguration&amp;) const;
+        private:
+            Ogre::String mDialogName;
+            std::vector&lt;Creature*&gt; mNpcs;
+        };
+
+
+        std::map&lt;DialogConfiguration, Dialog*&gt; mDialogStates;
+		DialogLoader* mDialogLoader;
+    };
+
+}
+
+#endif // __DialogManager_H__

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/engine/ai/include/Makefile.am	2008-07-11 19:59:08 UTC (rev 4446)
@@ -19,6 +19,7 @@
 	DialogElement.h \
 	DialogElementSelection.h \
 	DialogImplication.h \
+	DialogLoader.h \
 	DialogManager.h \
 	DialogOption.h \
 	DialogResponse.h \

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2008-07-11 19:59:08 UTC (rev 4446)
@@ -72,7 +72,6 @@
 	mWayPointGraphManager = new WayPointGraphManager();
     mWorld = new AiWorld();
     mDialogManager = new DialogManager();
-    Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mDialogManager);
 
     mSceneLoadedConnection =
         MessagePump::getSingleton().addMessageHandler&lt;MessageType_SceneLoaded&gt;(

Added: rl/trunk/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoader.cpp	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/engine/ai/src/DialogLoader.cpp	2008-07-11 19:59:08 UTC (rev 4446)
@@ -0,0 +1,739 @@
+/*
+ *  DialogLoader.cpp
+ *  Rastullah
+ *
+ *  Created by Sascha Kolewa on 11.07.08.
+ *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *
+ */
+#include &lt;xercesc/dom/DOM.hpp&gt;
+
+#include &quot;DialogLoader.h&quot;
+
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;Dialog.h&quot;
+#include &quot;DialogCondition.h&quot;
+#include &quot;DialogElement.h&quot;
+#include &quot;DialogImplication.h&quot;
+#include &quot;DialogOption.h&quot;
+#include &quot;DialogParagraph.h&quot;
+#include &quot;DialogResponse.h&quot;
+#include &quot;DialogVariable.h&quot;
+#include &quot;XmlPropertyReader.h&quot;
+
+using namespace Ogre;
+using namespace XERCES_CPP_NAMESPACE;
+
+namespace rl
+{
+	DialogLoader::DialogLoader()
+	      : XmlProcessor(), ScriptLoader()
+    {
+        mScriptPatterns.push_back(&quot;*.dialog&quot;);
+  	}
+	
+    DialogLoader::~DialogLoader()
+    {
+		std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator itr = mDialogs.begin();
+        std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator end = mDialogs.end();
+        for(; itr != end; ++itr)
+        {
+			DialogPrototype* p = itr-&gt;second;
+			delete p;
+		}
+        mDialogs.clear();
+	}
+ 
+    const StringVector&amp; DialogLoader::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+    
+	Ogre::Real DialogLoader::getLoadingOrder() const
+    {
+        return 1000;
+    }
+
+    void DialogLoader::parseScript(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
+    {
+        initializeXml();
+
+        DOMDocument* doc = loadDocument(stream);
+        if (doc)
+        {
+            DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
+
+            for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
+            {
+                DOMNode* cur = dialogNodes-&gt;item(i);
+                processDialog(static_cast&lt;DOMElement*&gt;(cur));
+            }
+        }
+
+        shutdownXml();
+    }
+	
+	Dialog* DialogLoader::createDialog(const String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, 
+		const std::vector&lt;Creature*&gt;&amp; npcs) const
+	{
+		std::map&lt;Ogre::String, DialogPrototype*&gt;::const_iterator it =
+			mDialogs.find(name);
+			
+		if (it == mDialogs.end())
+		{
+			return NULL;
+		}
+		
+		return it-&gt;second-&gt;createDialog(pcs, npcs);
+	}
+	
+    void DialogLoader::processDialog(DOMElement* dialogElem)
+    {
+        DialogPrototype* dialogPrototype = new DialogPrototype();
+        Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
+        mDialogs[name] = dialogPrototype;
+
+        // first step: process all possible references
+        processElementNodes(dialogElem, &quot;option&quot;, dialogPrototype);
+        processElementNodes(dialogElem, &quot;switchoption&quot;, dialogPrototype);
+        processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
+        processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
+
+        for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
+        {
+            if (hasNodeName(curChild, &quot;variable&quot;))
+            {
+                createDialogVariable(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, &quot;option&quot;))
+            {
+                processOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
+            }
+            else if (hasNodeName(curChild, &quot;switchoption&quot;))
+            {
+                processSwitchOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, &quot;response&quot;))
+            {
+                processResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
+            }
+            else if (hasNodeName(curChild, &quot;switchresponse&quot;))
+            {
+                processSwitchResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+            }
+            else if (hasNodeName(curChild, &quot;start&quot;))
+            {
+                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL; 
+                    curChildChild = curChildChild-&gt;getNextSibling())
+                {
+                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
+                    if (response)
+                    {
+                        dialogPrototype-&gt;setStartResponse(response);
+                    }
+                }
+            }
+        }
+        LOG_MESSAGE(Logger::AI, &quot;Processed Dialog &quot;+ name);
+    }
+
+    void DialogLoader::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype)
+    {
+        DOMNodeList* dialogElemNodes = dialogXml-&gt;getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
+        for (XMLSize_t i = 0; i &lt; dialogElemNodes-&gt;getLength(); ++i)
+        {
+            DOMElement* dialogElemXml = static_cast&lt;DOMElement*&gt;(dialogElemNodes-&gt;item(i));
+            if (!hasAttribute(dialogElemXml, &quot;id&quot;))
+            {
+                Throw(WrongFormatException, &quot;option/switchoption/response/switchresponse node without id found&quot;);
+            }
+            CeGuiString id = getAttributeValueAsString(dialogElemXml, &quot;id&quot;);
+            CeGuiString text = getValueAsString(dialogElemXml);
+
+            if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
+            {
+                DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
+                option-&gt;setLabel(text);
+                dialogPrototype-&gt;addOption(option);
+            }
+            else if (hasNodeName(dialogElemXml, &quot;option&quot;))
+            {
+                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, &quot;autoSelect&quot;);
+                DialogOption* option = new DialogOption(id, isAutoSelected);
+                if (hasAttribute(dialogElemXml, &quot;label&quot;))
+                {
+                    option-&gt;setLabel(getAttributeValueAsString(dialogElemXml, &quot;label&quot;));
+                }
+                else
+                {
+                    option-&gt;setLabel(text);
+                }
+                dialogPrototype-&gt;addOption(option);
+            }
+            else if (hasNodeName(dialogElemXml, &quot;response&quot;))
+            {
+                dialogPrototype-&gt;addResponse(new DialogResponse(id));
+            }
+            else if (hasNodeName(dialogElemXml, &quot;switchresponse&quot;))
+            {
+                dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
+            }
+        }
+        
+    }
+
+    DialogResponse* DialogLoader::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    {
+        DialogResponse* response = NULL;
+        if (hasNodeName(node, &quot;response&quot;))
+        {
+            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
+        }
+        else if (hasNodeName(node, &quot;gotoresponse&quot;))
+        {
+            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
+        }
+        else if (hasNodeName(node, &quot;switchresponse&quot;))
+        {
+            response = processSwitchResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
+        }
+        return response;
+    }
+
+    DialogResponse* DialogLoader::processResponse(DOMElement *responseXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
+    {
+        CeGuiString id = getAttributeValueAsString(responseXml, &quot;id&quot;);
+
+        DialogResponse* response = dialogPrototype-&gt;getResponse(id);
+
+        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No response with ID &quot;+ id).c_str());
+        
+        bool languageDefined = false;
+        DOMElement* defaultLanguage = NULL;
+        if (subelements)
+        {
+            bool paragraphsDefined = false;
+
+            for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+            {
+                DialogOption* option = processOptionClasses(cur, dialogPrototype);
+                if (option)
+                {
+                    response-&gt;addOption(option);
+                    continue;
+                }
+
+                DialogImplication* implication = processImplicationClasses(cur);
+                if (implication)
+                {
+                    response-&gt;addImplication(implication);
+                    continue;
+                }
+
+                if (hasNodeName(cur, &quot;p&quot;))
+                {
+                    response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+                    paragraphsDefined = true;
+                }
+                // process translations
+                else if (hasNodeName(cur, &quot;t&quot;))
+                {
+                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
+                    // check loca
+                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
+                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
+                    {
+                        processTranslation(response, translation);
+                        languageDefined = true;
+                    }
+                    // set german as default language
+                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
+                    {
+                        defaultLanguage = translation;
+                    }
+                    paragraphsDefined = true;
+                }
+                else if (hasNodeName(cur, &quot;gotoresponse&quot;))
+                {
+                    CeGuiString id = getAttributeValueAsString(static_cast&lt;DOMElement*&gt;(cur), &quot;id&quot;);
+                    response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
+                }
+            }
+
+            if (!paragraphsDefined)
+            {
+                CeGuiString responseXmlText = getValueAsString(responseXml);
+                response-&gt;addParagraph(new DialogParagraph(responseXmlText));
+            }
+        }            
+        // use german as the default language if german is not set as
+        // default language but no other language was found!
+        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
+            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
+        {
+            processTranslation(response, defaultLanguage);
+            languageDefined = true;
+        }
+
+        return response;
+    }
+
+    DialogResponse* DialogLoader::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
+    {
+        CeGuiString id = getAttributeValueAsString(switchRespXml, &quot;id&quot;);
+        DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
+
+        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No switchresponse with ID &quot;+ id).c_str());
+
+        for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
+            if (variable != NULL)
+            {
+                response-&gt;setVariable(variable);
+            }
+            else if (hasNodeName(cur, &quot;case&quot;))
+            {
+                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
+                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
+                {
+                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
+                    if (responseCase)
+                    {
+                         response-&gt;addElement(condition, responseCase);
+                         break;
+                    }
+                }               
+            }
+        }
+
+
+        return response;
+    }
+
+    DialogOption* DialogLoader::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    {
+        DialogOption* option = NULL;
+        if (hasNodeName(node, &quot;option&quot;))
+        {
+            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
+        }
+        else if (hasNodeName(node, &quot;optionref&quot;))
+        {
+            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
+        }
+        else if (hasNodeName(node, &quot;switchoption&quot;))
+        {
+            option = processSwitchOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
+        }
+        return option;
+    }
+
+    DialogOption* DialogLoader::processOption(DOMElement *optionXml, DialogLoader::DialogPrototype *dialogPrototype, bool subelements)
+    {
+        CeGuiString id = getAttributeValueAsString(optionXml, &quot;id&quot;);
+
+        DialogOption* option = dialogPrototype-&gt;getOption(id);
+
+        if (!option)    Throw(IllegalArgumentException, CeGuiString(&quot;No option with ID &quot;+ id).c_str());
+
+        bool languageDefined = false;
+        DOMElement* defaultLanguage = NULL;
+
+        if (subelements)
+        {
+            bool paragraphsDefined = false;
+
+            for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+            {
+                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
+                if (response)
+                {
+                    option-&gt;setResponse(response);
+                }
+                else if (hasNodeName(cur, &quot;if&quot;))
+                {
+                    option-&gt;setPrecondition(processIf(static_cast&lt;DOMElement*&gt;(cur)));
+                }
+                else if (hasNodeName(cur, &quot;p&quot;))
+                {
+                    option-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+                    paragraphsDefined = true;
+                }
+                // process translations
+                else if (hasNodeName(cur, &quot;t&quot;))
+                {
+                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
+                    // check loca
+                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
+                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
+                    {
+                        defaultLanguage = translation;
+                        processTranslation(option, translation);
+                        std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
+                        if(!label.empty())
+                        {
+                            option-&gt;setLabel(label);
+                        }
+                        languageDefined = true;
+                    }
+                    // set german as default language
+                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
+                    {
+                        defaultLanguage = translation;
+                    }
+                    paragraphsDefined = true;
+                }
+            }
+
+            if (!paragraphsDefined)
+            {
+                CeGuiString optionXmlText = getValueAsString(optionXml);
+                option-&gt;addParagraph(new DialogParagraph(optionXmlText));
+            }
+        }
+        // use german as the default language if german is not set as
+        // default language but no other language was found!
+        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
+            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
+        {
+            processTranslation(option, defaultLanguage);
+            std::string label = getAttributeValueAsStdString(defaultLanguage, &quot;label&quot;);
+            if(!label.empty())
+            {
+                option-&gt;setLabel(label);
+            }
+            languageDefined = true;
+        }
+
+        return option;
+    }
+
+    DialogOption* DialogLoader::processSwitchOption(DOMElement *switchOptXml, DialogLoader::DialogPrototype *dialogPrototype)
+    {
+        CeGuiString id = getAttributeValueAsString(switchOptXml, &quot;id&quot;);
+        DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
+
+        if (!option) Throw(IllegalArgumentException, CeGuiString(&quot;No switchoption with ID &quot;+ id).c_str());
+
+        for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
+            if (variable != NULL)
+            {
+                option-&gt;setVariable(variable);
+            }
+            else if (hasNodeName(cur, &quot;case&quot;))
+            {
+                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
+                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
+                {
+                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
+                    if (optionCase)
+                    {
+                         option-&gt;addElement(condition, optionCase);
+                         break;
+                    }
+                }               
+            }
+            // process translations
+            else if (hasNodeName(cur, &quot;t&quot;))
+            {
+                DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
+                // check loca
+                if(getAttributeValueAsStdString(translation, &quot;language&quot;) == 
+                    ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
+                {
+                    std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
+                    if(!label.empty())
+                    {
+                        option-&gt;setLabel(label);
+                    }
+                } 
+            }
+        }
+            
+        return option;
+    }
+
+    void DialogLoader::createDialogVariable(DOMElement *variableXml, DialogLoader::DialogPrototype *dialogPrototype)
+    {
+        XmlPropertyReader reader;
+        PropertyEntry entry = reader.processProperty(variableXml);
+        dialogPrototype-&gt;setProperty(entry.first, entry.second);
+    }
+
+    DialogCondition* DialogLoader::processIf(DOMElement *ifXml)
+    {
+        DialogCondition* cond = NULL;
+        DialogVariable* var = NULL;
+
+        for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+            {
+                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
+
+                DialogCondition* curCond = processConditionClasses(curElem);
+                if (curCond)
+                {
+                    cond = curCond;
+                }
+
+                DialogVariable* curVar = processVariableClasses(curElem);
+                if (curVar)
+                {
+                    var = curVar;
+                }
+            }
+        }
+
+        cond-&gt;setVariable(var);
+        return cond;
+    }
+
+    DialogParagraph* DialogLoader::processParagraph(DOMElement* paragraphXml)
+    {
+        Ogre::String voicefile = &quot;&quot;;
+        if (hasAttribute(paragraphXml, &quot;voicefile&quot;))
+        {
+            voicefile = getAttributeValueAsStdString(paragraphXml, &quot;voicefile&quot;);
+        }
+        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
+    }
+
+    DialogCondition* DialogLoader::processCase(DOMElement *caseXml)
+    {
+        DialogCondition* cond = NULL;
+
+        for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+            {
+                DialogCondition* curCond = processConditionClasses(static_cast&lt;DOMElement*&gt;(cur));
+                if (curCond)
+                {
+                    cond = curCond;
+                }
+            }
+        }
+
+        return cond;
+    }
+
+    DialogLoader::DialogPrototype::DialogPrototype()
+    {
+    }
+
+    DialogLoader::DialogPrototype::~DialogPrototype()
+    {
+        std::map&lt;CeGuiString, DialogOption*&gt;::iterator it;
+        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
+            if( it-&gt;second != NULL )
+                delete it-&gt;second;
+
+        std::map&lt;CeGuiString, DialogResponse*&gt;::iterator it1;
+        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
+            if( it1-&gt;second != NULL )
+                delete it1-&gt;second;
+    }
+
+    void DialogLoader::DialogPrototype::addOption(DialogOption* option)
+    {
+        if (mOptionCache.find(option-&gt;getId()) != mOptionCache.end())
+        {
+            Throw(IllegalArgumentException, 
+                CeGuiString(&quot;Duplicate option/switchoption ID &quot;+ option-&gt;getId()).c_str());
+        }
+        mOptionCache[option-&gt;getId()] = option;
+    }
+
+    DialogOption* DialogLoader::DialogPrototype::getOption(const CeGuiString&amp; id) const
+    {
+        std::map&lt;CeGuiString, DialogOption*&gt;::const_iterator it = mOptionCache.find(id);
+        if (it == mOptionCache.end())
+        {
+            return NULL;
+        }
+        return it-&gt;second;
+    }
+
+    void DialogLoader::DialogPrototype::addResponse(DialogResponse* response)
+    {
+        if (mResponseCache.find(response-&gt;getId()) != mResponseCache.end())
+        {
+            Throw(IllegalArgumentException, 
+                CeGuiString(&quot;Duplicate Response/switchResponse ID &quot;+ response-&gt;getId()).c_str());
+        }
+        mResponseCache[response-&gt;getId()] = response;
+    }
+
+    DialogResponse* DialogLoader::DialogPrototype::getResponse(const CeGuiString&amp; id) const
+    {
+        std::map&lt;CeGuiString, DialogResponse*&gt;::const_iterator it = mResponseCache.find(id);
+        if (it == mResponseCache.end())
+        {
+            return NULL;
+        }
+        return it-&gt;second;
+    }
+
+    Dialog* DialogLoader::DialogPrototype::createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
+    {
+        Dialog* dialog = new Dialog(pcs, npcs);
+        dialog-&gt;setStartResponse(mDialogStart);
+        
+        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
+            it != mPropertyVariables.end(); ++it)
+        {
+            dialog-&gt;setProperty(it-&gt;first, it-&gt;second);
+        }
+
+        return dialog;
+    }
+
+    void DialogLoader::DialogPrototype::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        mPropertyVariables.setProperty(key, value);
+    }
+
+    void DialogLoader::DialogPrototype::setStartResponse(DialogResponse* start)
+    {
+        mDialogStart = start;
+    }
+
+
+    DialogCondition* DialogLoader::processConditionClasses(DOMElement* conditionXml)
+    {
+        if (hasNodeName(conditionXml, &quot;equals&quot;))
+        {
+            return new DialogConditionEquals(
+                getAttributeValueAsString(conditionXml, &quot;value&quot;));
+        }
+        else if (hasNodeName(conditionXml, &quot;inrange&quot;))
+        {
+            return new DialogConditionInRange(
+                getAttributeValueAsReal(conditionXml, &quot;from&quot;),
+                getAttributeValueAsReal(conditionXml, &quot;to&quot;));
+        }
+        else if (hasNodeName(conditionXml, &quot;lower&quot;))
+        {
+            return new DialogConditionLowerThan(
+                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
+        }
+        else if (hasNodeName(conditionXml, &quot;lowereq&quot;))
+        {
+            return new DialogConditionLowerOrEquals(
+                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
+        }
+        else if (hasNodeName(conditionXml, &quot;greater&quot;))
+        {
+            return new DialogConditionGreaterThan(
+                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
+        }
+        else if (hasNodeName(conditionXml, &quot;greatereq&quot;))
+        {
+            return new DialogConditionGreaterOrEquals(
+                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
+        }
+
+        return NULL;
+    }
+
+    DialogVariable* DialogLoader::processVariableClasses(DOMElement* variableXml)
+    {
+        if (hasNodeName(variableXml, &quot;dialogvariable&quot;))
+        {
+            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, &quot;name&quot;));
+        }
+        else if (hasNodeName(variableXml, &quot;queststate&quot;))
+        {
+            Ogre::String questId = getAttributeValueAsStdString(variableXml, &quot;quest&quot;);
+            Ogre::String prop = getAttributeValueAsStdString(variableXml, &quot;property&quot;);
+            return new QuestStateVariable(questId, prop);
+        }
+        else if (hasNodeName(variableXml, &quot;attributecheck&quot;))
+        {
+            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;attribute&quot;);
+            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
+            int modifier = 0;
+            if (hasAttribute(variableXml, &quot;modifier&quot;))
+            {
+                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
+            }
+            return new EigenschaftsProbeVariable(attr, modifier, target);
+        }
+        else if (hasNodeName(variableXml, &quot;talentcheck&quot;))
+        {
+            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;talent&quot;);
+            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
+            int modifier = 0;
+            if (hasAttribute(variableXml, &quot;modifier&quot;))
+            {
+                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
+            }
+            return new TalentProbeVariable(attr, modifier, target);
+        }
+
+        return NULL;
+    }
+
+
+    DialogImplication* DialogLoader::processImplicationClasses(DOMNode* implicationXml)
+    {
+        if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+        {
+            DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
+
+            if (hasNodeName(implicationElem, &quot;setvariable&quot;))
+            {
+                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
+                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
+                return new DialogVariableAssignment(variableName, variableValue);
+            }
+            else if (hasNodeName(implicationElem, &quot;incvariable&quot;))
+            {
+                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
+                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
+                return new DialogVariableIncrease(variableName, variableValue);
+            }
+            else if (hasNodeName(implicationElem, &quot;decvariable&quot;))
+            {
+                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
+                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
+                return new DialogVariableDecrease(variableName, variableValue);
+            }
+            else if (hasNodeName(implicationElem, &quot;setoptionactive&quot;))
+            {
+                CeGuiString id = getAttributeValueAsString(implicationElem, &quot;id&quot;);
+                bool value = getAttributeValueAsBool(implicationElem, &quot;value&quot;);
+                return new DialogElementActivation(id, value, true);
+            }
+			else if (hasNodeName(implicationElem, &quot;exit&quot;))
+			{
+				return new DialogExit();
+			}
+            else if (hasNodeName(implicationElem, &quot;changequest&quot;))
+            {
+                Ogre::String questId = getAttributeValueAsStdString(implicationElem, &quot;quest&quot;);
+                Ogre::String prop = getAttributeValueAsStdString(implicationElem, &quot;property&quot;);
+                CeGuiString newvalue = getAttributeValueAsString(implicationElem, &quot;newvalue&quot;);
+                return new QuestPropertyAssignment(questId, prop, newvalue);
+            }
+        }
+
+        return NULL;
+    }
+
+    void DialogLoader::processTranslation(DialogElement* element, DOMNode* translationXml)
+    {
+        for (DOMNode* cur = translationXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        {
+            if (hasNodeName(cur, &quot;p&quot;))
+            {
+                element-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+            }
+        }
+    }
+
+}
\ No newline at end of file

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2008-07-11 19:59:08 UTC (rev 4446)
@@ -1,886 +1,194 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot;
-
-#include &quot;DialogManager.h&quot;
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
-#include &quot;Creature.h&quot;
-#include &quot;Dialog.h&quot;
-#include &quot;DialogCondition.h&quot;
-#include &quot;DialogElement.h&quot;
-#include &quot;DialogImplication.h&quot;
-#include &quot;DialogOption.h&quot;
-#include &quot;DialogParagraph.h&quot;
-#include &quot;DialogResponse.h&quot;
-#include &quot;DialogVariable.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;XmlPropertyReader.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;SaveGameManager.h&quot;
-
-using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
-
-template&lt;&gt;
-    rl::DialogManager* Ogre::Singleton&lt;rl::DialogManager&gt;::ms_Singleton = NULL;
-
-namespace rl
-{
-    const Ogre::String DialogManager::PROPERTY_DIALOGS = &quot;dialogs&quot;;
-    const Ogre::String DialogManager::PROPERTY_DIALOG = &quot;dialog&quot;;
-    const Ogre::String DialogManager::PROPERTY_DIALOG_NAME = &quot;name&quot;;
-    const Ogre::String DialogManager::PROPERTY_NPCS = &quot;npc&quot;;
-
-    DialogManager::DialogManager()
-        : XmlProcessor(), ScriptLoader()
-    {
-        mScriptPatterns.push_back(&quot;*.dialog&quot;);
-        SaveGameManager::getSingleton().registerSaveGameData(this);
-    }
-
-    DialogManager::~DialogManager()
-    {
-        SaveGameManager::getSingleton().unregisterSaveGameData(this);
-        {
-            std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator itr = mDialogs.begin();
-            std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator end = mDialogs.end();
-            for(; itr != end; ++itr)
-            {
-                DialogPrototype* p = itr-&gt;second;
-                //delete (*itr-&gt;second);
-            }
-            mDialogs.clear();
-        }
-        {
-            std::map&lt;DialogConfiguration, Dialog*&gt;::iterator itr = mDialogStates.begin();
-            std::map&lt;DialogConfiguration, Dialog*&gt;::iterator end = mDialogStates.end();
-            for(; itr != end; ++itr)
-            {
-                //delete (*itr-&gt;second);
-            }
-            mDialogStates.clear();
-        }
-    }
-
-    const StringVector&amp; DialogManager::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-    
-	Ogre::Real DialogManager::getLoadingOrder() const
-    {
-        return 1000;
-    }
-
-    void DialogManager::parseScript(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
-    {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
-        if (doc)
-        {
-            DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
-
-            for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes-&gt;item(i);
-                processDialog(static_cast&lt;DOMElement*&gt;(cur));
-            }
-        }
-
-        shutdownXml();
-    }
-
-    const Property DialogManager::getProperty(const CeGuiString&amp; key) const
-    {
-        if (key == DialogManager::PROPERTY_DIALOGS)
-        {
-            PropertyArray vec;
-            for (std::map&lt;DialogConfiguration, Dialog*&gt;::const_iterator it
-                = mDialogStates.begin(); it != mDialogStates.end(); ++it)
-            {
-                PropertyMap curDialogProp;
-                PropertyRecordPtr dialogProps = it-&gt;second-&gt;getAllProperties();
-                curDialogProp[DialogManager::PROPERTY_DIALOG] = dialogProps-&gt;toPropertyMap();
-                curDialogProp[DialogManager::PROPERTY_DIALOG_NAME] = Property(it-&gt;first.getName());
-
-                PropertyArray npcs;
-
-                for (std::vector&lt;Creature*&gt;::const_iterator itNpc = it-&gt;first.getNpcs().begin();
-                    itNpc != it-&gt;first.getNpcs().end(); ++itNpc)
-                {
-                    npcs.push_back(GameObjectManager::getSingleton().toProperty(*itNpc));
-                }
-
-                curDialogProp[DialogManager::PROPERTY_NPCS] = Property(npcs);
-            }
-
-            return Property(vec);
-        }
-
-        Throw(IllegalArgumentException, key + &quot; is not a property of DialogManager&quot;);
-    }
-
-    PropertyKeys DialogManager::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        keys.insert(DialogManager::PROPERTY_DIALOGS);
-        return keys;
-    }
-
-    void DialogManager::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        ///@todo implement
-    }
-
-    void DialogManager::writeData(SaveGameFileWriter *writer)
-    {
-        LOG_MESSAGE(Logger::RULES, &quot;Saving dialogs&quot;);
-
-        PropertyRecordPtr set = getAllProperties();
-        writer-&gt;writeEachProperty(this, set-&gt;toPropertyMap());
-    }
-
-    void DialogManager::readData(SaveGameFileReader* reader)
-    {
-        LOG_MESSAGE(Logger::RULES, &quot;Loading dialogs&quot;);
-
-        PropertyRecordPtr properties = reader-&gt;getAllPropertiesAsRecord(this);
-        setProperties(properties);
-    }
-
-    int DialogManager::getPriority() const
-    {
-        return 50;
-    }
-
-    CeGuiString DialogManager::getXmlNodeIdentifier() const
-    {
-        return &quot;dialogs&quot;;
-    }
-
-
-    void DialogManager::processDialog(DOMElement* dialogElem)
-    {
-        DialogPrototype* dialogPrototype = new DialogPrototype();
-        Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
-        mDialogs[name] = dialogPrototype;
-
-        // first step: process all possible references
-        processElementNodes(dialogElem, &quot;option&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;switchoption&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
-        processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
-
-        for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
-        {
-            if (hasNodeName(curChild, &quot;variable&quot;))
-            {
-                createDialogVariable(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;option&quot;))
-            {
-                processOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, &quot;switchoption&quot;))
-            {
-                processSwitchOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;response&quot;))
-            {
-                processResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
-            }
-            else if (hasNodeName(curChild, &quot;switchresponse&quot;))
-            {
-                processSwitchResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
-            }
-            else if (hasNodeName(curChild, &quot;start&quot;))
-            {
-                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL; 
-                    curChildChild = curChildChild-&gt;getNextSibling())
-                {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
-                    if (response)
-                    {
-                        dialogPrototype-&gt;setStartResponse(response);
-                    }
-                }
-            }
-        }
-        LOG_MESSAGE(Logger::AI, &quot;Processed Dialog &quot;+ name);
-    }
-
-    void DialogManager::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype)
-    {
-        DOMNodeList* dialogElemNodes = dialogXml-&gt;getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i &lt; dialogElemNodes-&gt;getLength(); ++i)
-        {
-            DOMElement* dialogElemXml = static_cast&lt;DOMElement*&gt;(dialogElemNodes-&gt;item(i));
-            if (!hasAttribute(dialogElemXml, &quot;id&quot;))
-            {
-                Throw(WrongFormatException, &quot;option/switchoption/response/switchresponse node without id found&quot;);
-            }
-            CeGuiString id = getAttributeValueAsString(dialogElemXml, &quot;id&quot;);
-            CeGuiString text = getValueAsString(dialogElemXml);
-
-            if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
-            {
-                DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
-                option-&gt;setLabel(text);
-                dialogPrototype-&gt;addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, &quot;option&quot;))
-            {
-                bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, &quot;autoSelect&quot;);
-                DialogOption* option = new DialogOption(id, isAutoSelected);
-                if (hasAttribute(dialogElemXml, &quot;label&quot;))
-                {
-                    option-&gt;setLabel(getAttributeValueAsString(dialogElemXml, &quot;label&quot;));
-                }
-                else
-                {
-                    option-&gt;setLabel(text);
-                }
-                dialogPrototype-&gt;addOption(option);
-            }
-            else if (hasNodeName(dialogElemXml, &quot;response&quot;))
-            {
-                dialogPrototype-&gt;addResponse(new DialogResponse(id));
-            }
-            else if (hasNodeName(dialogElemXml, &quot;switchresponse&quot;))
-            {
-                dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
-            }
-        }
-        
-    }
-
-    DialogResponse* DialogManager::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogResponse* response = NULL;
-        if (hasNodeName(node, &quot;response&quot;))
-        {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, &quot;gotoresponse&quot;))
-        {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, &quot;switchresponse&quot;))
-        {
-            response = processSwitchResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
-        }
-        return response;
-    }
-
-    DialogResponse* DialogManager::processResponse(DOMElement *responseXml, DialogManager::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(responseXml, &quot;id&quot;);
-
-        DialogResponse* response = dialogPrototype-&gt;getResponse(id);
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No response with ID &quot;+ id).c_str());
-        
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-            {
-                DialogOption* option = processOptionClasses(cur, dialogPrototype);
-                if (option)
-                {
-                    response-&gt;addOption(option);
-                    continue;
-                }
-
-                DialogImplication* implication = processImplicationClasses(cur);
-                if (implication)
-                {
-                    response-&gt;addImplication(implication);
-                    continue;
-                }
-
-                if (hasNodeName(cur, &quot;p&quot;))
-                {
-                    response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, &quot;t&quot;))
-                {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
-                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                    {
-                        processTranslation(response, translation);
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-                else if (hasNodeName(cur, &quot;gotoresponse&quot;))
-                {
-                    CeGuiString id = getAttributeValueAsString(static_cast&lt;DOMElement*&gt;(cur), &quot;id&quot;);
-                    response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString responseXmlText = getValueAsString(responseXml);
-                response-&gt;addParagraph(new DialogParagraph(responseXmlText));
-            }
-        }            
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
-            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
-        {
-            processTranslation(response, defaultLanguage);
-            languageDefined = true;
-        }
-
-        return response;
-    }
-
-    DialogResponse* DialogManager::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchRespXml, &quot;id&quot;);
-        DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
-
-        if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No switchresponse with ID &quot;+ id).c_str());
-
-        for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
-            if (variable != NULL)
-            {
-                response-&gt;setVariable(variable);
-            }
-            else if (hasNodeName(cur, &quot;case&quot;))
-            {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
-                {
-                    DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
-                    if (responseCase)
-                    {
-                         response-&gt;addElement(condition, responseCase);
-                         break;
-                    }
-                }               
-            }
-        }
-
-
-        return response;
-    }
-
-    DialogOption* DialogManager::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
-    {
-        DialogOption* option = NULL;
-        if (hasNodeName(node, &quot;option&quot;))
-        {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
-        }
-        else if (hasNodeName(node, &quot;optionref&quot;))
-        {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
-        }
-        else if (hasNodeName(node, &quot;switchoption&quot;))
-        {
-            option = processSwitchOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
-        }
-        return option;
-    }
-
-    DialogOption* DialogManager::processOption(DOMElement *optionXml, DialogManager::DialogPrototype *dialogPrototype, bool subelements)
-    {
-        CeGuiString id = getAttributeValueAsString(optionXml, &quot;id&quot;);
-
-        DialogOption* option = dialogPrototype-&gt;getOption(id);
-
-        if (!option)    Throw(IllegalArgumentException, CeGuiString(&quot;No option with ID &quot;+ id).c_str());
-
-        bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
-
-        if (subelements)
-        {
-            bool paragraphsDefined = false;
-
-            for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-            {
-                DialogResponse* response = processResponseClasses(cur, dialogPrototype);
-                if (response)
-                {
-                    option-&gt;setResponse(response);
-                }
-                else if (hasNodeName(cur, &quot;if&quot;))
-                {
-                    option-&gt;setPrecondition(processIf(static_cast&lt;DOMElement*&gt;(cur)));
-                }
-                else if (hasNodeName(cur, &quot;p&quot;))
-                {
-                    option-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-                    paragraphsDefined = true;
-                }
-                // process translations
-                else if (hasNodeName(cur, &quot;t&quot;))
-                {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
-                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                    {
-                        defaultLanguage = translation;
-                        processTranslation(option, translation);
-                        std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                        if(!label.empty())
-                        {
-                            option-&gt;setLabel(label);
-                        }
-                        languageDefined = true;
-                    }
-                    // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
-                    {
-                        defaultLanguage = translation;
-                    }
-                    paragraphsDefined = true;
-                }
-            }
-
-            if (!paragraphsDefined)
-            {
-                CeGuiString optionXmlText = getValueAsString(optionXml);
-                option-&gt;addParagraph(new DialogParagraph(optionXmlText));
-            }
-        }
-        // use german as the default language if german is not set as
-        // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
-            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
-        {
-            processTranslation(option, defaultLanguage);
-            std::string label = getAttributeValueAsStdString(defaultLanguage, &quot;label&quot;);
-            if(!label.empty())
-            {
-                option-&gt;setLabel(label);
-            }
-            languageDefined = true;
-        }
-
-        return option;
-    }
-
-    DialogOption* DialogManager::processSwitchOption(DOMElement *switchOptXml, DialogManager::DialogPrototype *dialogPrototype)
-    {
-        CeGuiString id = getAttributeValueAsString(switchOptXml, &quot;id&quot;);
-        DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
-
-        if (!option) Throw(IllegalArgumentException, CeGuiString(&quot;No switchoption with ID &quot;+ id).c_str());
-
-        for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
-            if (variable != NULL)
-            {
-                option-&gt;setVariable(variable);
-            }
-            else if (hasNodeName(cur, &quot;case&quot;))
-            {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
-                {
-                    DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
-                    if (optionCase)
-                    {
-                         option-&gt;addElement(condition, optionCase);
-                         break;
-                    }
-                }               
-            }
-            // process translations
-            else if (hasNodeName(cur, &quot;t&quot;))
-            {
-                DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                // check loca
-                if(getAttributeValueAsStdString(translation, &quot;language&quot;) == 
-                    ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
-                {
-                    std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                    if(!label.empty())
-                    {
-                        option-&gt;setLabel(label);
-                    }
-                } 
-            }
-        }
-            
-        return option;
-    }
-
-    void DialogManager::createDialogVariable(DOMElement *variableXml, DialogManager::DialogPrototype *dialogPrototype)
-    {
-        XmlPropertyReader reader;
-        PropertyEntry entry = reader.processProperty(variableXml);
-        dialogPrototype-&gt;setProperty(entry.first, entry.second);
-    }
-
-    DialogCondition* DialogManager::processIf(DOMElement *ifXml)
-    {
-        DialogCondition* cond = NULL;
-        DialogVariable* var = NULL;
-
-        for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
-
-                DialogCondition* curCond = processConditionClasses(curElem);
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-
-                DialogVariable* curVar = processVariableClasses(curElem);
-                if (curVar)
-                {
-                    var = curVar;
-                }
-            }
-        }
-
-        cond-&gt;setVariable(var);
-        return cond;
-    }
-
-    DialogParagraph* DialogManager::processParagraph(DOMElement* paragraphXml)
-    {
-        Ogre::String voicefile = &quot;&quot;;
-        if (hasAttribute(paragraphXml, &quot;voicefile&quot;))
-        {
-            voicefile = getAttributeValueAsStdString(paragraphXml, &quot;voicefile&quot;);
-        }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
-    }
-
-    DialogCondition* DialogManager::processCase(DOMElement *caseXml)
-    {
-        DialogCondition* cond = NULL;
-
-        for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                DialogCondition* curCond = processConditionClasses(static_cast&lt;DOMElement*&gt;(cur));
-                if (curCond)
-                {
-                    cond = curCond;
-                }
-            }
-        }
-
-        return cond;
-    }
-
-    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, Creature* npc, Creature* pc)
-    {
-        std::vector&lt;Creature*&gt; npcs;
-        npcs.push_back(npc);
-        std::vector&lt;Creature*&gt; pcs;
-        pcs.push_back(pc);
-
-        return createDialog(name, npcs, pcs);
-    }
-
-    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
-    {
-        std::map&lt;DialogConfiguration, Dialog*&gt;::iterator it 
-            = mDialogStates.find(DialogConfiguration(name, npcs));
-
-        Dialog* dialog;
-        if (it != mDialogStates.end())
-        {
-            dialog = (*it).second;
-        }
-        else 
-        {
-            std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator it = mDialogs.find(name);
-            if (it == mDialogs.end())
-            {
-                return NULL;
-            }
-
-            dialog = it-&gt;second-&gt;createDialog(pcs, npcs); ///@todo save dialogs
-            dialog-&gt;initialize();
-            mDialogStates[DialogConfiguration(name, npcs)] = dialog;
-        }
-		return dialog;
-    }
-
-    DialogManager::DialogPrototype::DialogPrototype()
-    {
-    }
-
-    DialogManager::DialogPrototype::~DialogPrototype()
-    {
-        std::map&lt;CeGuiString, DialogOption*&gt;::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it-&gt;second != NULL )
-                delete it-&gt;second;
-
-        std::map&lt;CeGuiString, DialogResponse*&gt;::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1-&gt;second != NULL )
-                delete it1-&gt;second;
-    }
-
-    void DialogManager::DialogPrototype::addOption(DialogOption* option)
-    {
-        if (mOptionCache.find(option-&gt;getId()) != mOptionCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString(&quot;Duplicate option/switchoption ID &quot;+ option-&gt;getId()).c_str());
-        }
-        mOptionCache[option-&gt;getId()] = option;
-    }
-
-    DialogOption* DialogManager::DialogPrototype::getOption(const CeGuiString&amp; id) const
-    {
-        std::map&lt;CeGuiString, DialogOption*&gt;::const_iterator it = mOptionCache.find(id);
-        if (it == mOptionCache.end())
-        {
-            return NULL;
-        }
-        return it-&gt;second;
-    }
-
-    void DialogManager::DialogPrototype::addResponse(DialogResponse* response)
-    {
-        if (mResponseCache.find(response-&gt;getId()) != mResponseCache.end())
-        {
-            Throw(IllegalArgumentException, 
-                CeGuiString(&quot;Duplicate Response/switchResponse ID &quot;+ response-&gt;getId()).c_str());
-        }
-        mResponseCache[response-&gt;getId()] = response;
-    }
-
-    DialogResponse* DialogManager::DialogPrototype::getResponse(const CeGuiString&amp; id) const
-    {
-        std::map&lt;CeGuiString, DialogResponse*&gt;::const_iterator it = mResponseCache.find(id);
-        if (it == mResponseCache.end())
-        {
-            return NULL;
-        }
-        return it-&gt;second;
-    }
-
-    Dialog* DialogManager::DialogPrototype::createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
-    {
-        Dialog* dialog = new Dialog(pcs, npcs);
-        dialog-&gt;setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
-            it != mPropertyVariables.end(); ++it)
-        {
-            dialog-&gt;setProperty(it-&gt;first, it-&gt;second);
-        }
-
-        return dialog;
-    }
-
-    void DialogManager::DialogPrototype::setProperty(const CeGuiString&amp; key, const Property&amp; value)
-    {
-        mPropertyVariables.setProperty(key, value);
-    }
-
-    void DialogManager::DialogPrototype::setStartResponse(DialogResponse* start)
-    {
-        mDialogStart = start;
-    }
-
-    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs)
-        : mDialogName(name), mNpcs(npcs)
-    {
-    }
-
-    const Ogre::String&amp; DialogManager::DialogConfiguration::getName() const
-    {
-        return mDialogName;
-    }
-
-    const std::vector&lt;Creature*&gt;&amp; DialogManager::DialogConfiguration::getNpcs() const
-    {
-        return mNpcs;
-    }
-
-    bool DialogManager::DialogConfiguration::operator &lt;(const rl::DialogManager::DialogConfiguration &amp; other) const
-    {
-        return mDialogName &lt; other.mDialogName;
-    }
-
-    bool DialogManager::DialogConfiguration::operator ==(const rl::DialogManager::DialogConfiguration &amp; other) const
-    {
-        return (mDialogName == other.mDialogName) 
-            &amp;&amp; (mNpcs == other.mNpcs);
-    }
-
-    DialogCondition* DialogManager::processConditionClasses(DOMElement* conditionXml)
-    {
-        if (hasNodeName(conditionXml, &quot;equals&quot;))
-        {
-            return new DialogConditionEquals(
-                getAttributeValueAsString(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;inrange&quot;))
-        {
-            return new DialogConditionInRange(
-                getAttributeValueAsReal(conditionXml, &quot;from&quot;),
-                getAttributeValueAsReal(conditionXml, &quot;to&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;lower&quot;))
-        {
-            return new DialogConditionLowerThan(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;lowereq&quot;))
-        {
-            return new DialogConditionLowerOrEquals(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;greater&quot;))
-        {
-            return new DialogConditionGreaterThan(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-        else if (hasNodeName(conditionXml, &quot;greatereq&quot;))
-        {
-            return new DialogConditionGreaterOrEquals(
-                getAttributeValueAsReal(conditionXml, &quot;value&quot;));
-        }
-
-        return NULL;
-    }
-
-    DialogVariable* DialogManager::processVariableClasses(DOMElement* variableXml)
-    {
-        if (hasNodeName(variableXml, &quot;dialogvariable&quot;))
-        {
-            return new DialogPropertyVariable(getAttributeValueAsStdString(variableXml, &quot;name&quot;));
-        }
-        else if (hasNodeName(variableXml, &quot;queststate&quot;))
-        {
-            Ogre::String questId = getAttributeValueAsStdString(variableXml, &quot;quest&quot;);
-            Ogre::String prop = getAttributeValueAsStdString(variableXml, &quot;property&quot;);
-            return new QuestStateVariable(questId, prop);
-        }
-        else if (hasNodeName(variableXml, &quot;attributecheck&quot;))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;attribute&quot;);
-            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
-            int modifier = 0;
-            if (hasAttribute(variableXml, &quot;modifier&quot;))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
-            }
-            return new EigenschaftsProbeVariable(attr, modifier, target);
-        }
-        else if (hasNodeName(variableXml, &quot;talentcheck&quot;))
-        {
-            CeGuiString attr = getAttributeValueAsString(variableXml, &quot;talent&quot;);
-            CeGuiString target = getAttributeValueAsString(variableXml, &quot;target&quot;);
-            int modifier = 0;
-            if (hasAttribute(variableXml, &quot;modifier&quot;))
-            {
-                modifier = getAttributeValueAsInteger(variableXml, &quot;modifier&quot;);
-            }
-            return new TalentProbeVariable(attr, modifier, target);
-        }
-
-        return NULL;
-    }
-
-
-    DialogImplication* DialogManager::processImplicationClasses(DOMNode* implicationXml)
-    {
-        if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
-
-            if (hasNodeName(implicationElem, &quot;setvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableAssignment(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;incvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableIncrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;decvariable&quot;))
-            {
-                Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
-                CeGuiString variableValue = getAttributeValueAsString(implicationElem, &quot;value&quot;);
-                return new DialogVariableDecrease(variableName, variableValue);
-            }
-            else if (hasNodeName(implicationElem, &quot;setoptionactive&quot;))
-            {
-                CeGuiString id = getAttributeValueAsString(implicationElem, &quot;id&quot;);
-                bool value = getAttributeValueAsBool(implicationElem, &quot;value&quot;);
-                return new DialogElementActivation(id, value, true);
-            }
-			else if (hasNodeName(implicationElem, &quot;exit&quot;))
-			{
-				return new DialogExit();
-			}
-            else if (hasNodeName(implicationElem, &quot;changequest&quot;))
-            {
-                Ogre::String questId = getAttributeValueAsStdString(implicationElem, &quot;quest&quot;);
-                Ogre::String prop = getAttributeValueAsStdString(implicationElem, &quot;property&quot;);
-                CeGuiString newvalue = getAttributeValueAsString(implicationElem, &quot;newvalue&quot;);
-                return new QuestPropertyAssignment(questId, prop, newvalue);
-            }
-        }
-
-        return NULL;
-    }
-
-    void DialogManager::processTranslation(DialogElement* element, DOMNode* translationXml)
-    {
-        for (DOMNode* cur = translationXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
-        {
-            if (hasNodeName(cur, &quot;p&quot;))
-            {
-                element-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
-            }
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogManager.h&quot;
+
+
+#include &quot;Creature.h&quot;
+#include &quot;Dialog.h&quot;
+#include &quot;DialogLoader.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;SaveGameManager.h&quot;
+
+using namespace Ogre;
+using namespace XERCES_CPP_NAMESPACE;
+
+template&lt;&gt;
+    rl::DialogManager* Ogre::Singleton&lt;rl::DialogManager&gt;::ms_Singleton = NULL;
+
+namespace rl
+{
+    const Ogre::String DialogManager::PROPERTY_DIALOGS = &quot;dialogs&quot;;
+    const Ogre::String DialogManager::PROPERTY_DIALOG = &quot;dialog&quot;;
+    const Ogre::String DialogManager::PROPERTY_DIALOG_NAME = &quot;name&quot;;
+    const Ogre::String DialogManager::PROPERTY_NPCS = &quot;npc&quot;;
+
+    DialogManager::DialogManager()
+    {
+		mDialogLoader = new DialogLoader();
+		Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(
+			mDialogLoader);
+        SaveGameManager::getSingleton().registerSaveGameData(this);
+    }
+
+    DialogManager::~DialogManager()
+    {
+		Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(
+			mDialogLoader);
+		delete mDialogLoader;
+        SaveGameManager::getSingleton().unregisterSaveGameData(this);
+		std::map&lt;DialogConfiguration, Dialog*&gt;::iterator itr = mDialogStates.begin();
+		std::map&lt;DialogConfiguration, Dialog*&gt;::iterator end = mDialogStates.end();
+		for(; itr != end; ++itr)
+		{
+			delete itr-&gt;second;
+		}
+		mDialogStates.clear();
+    }
+
+
+    const Property DialogManager::getProperty(const CeGuiString&amp; key) const
+    {
+        if (key == DialogManager::PROPERTY_DIALOGS)
+        {
+            PropertyArray vec;
+            for (std::map&lt;DialogConfiguration, Dialog*&gt;::const_iterator it
+                = mDialogStates.begin(); it != mDialogStates.end(); ++it)
+            {
+                PropertyMap curDialogProp;
+                PropertyRecordPtr dialogProps = it-&gt;second-&gt;getAllProperties();
+                curDialogProp[DialogManager::PROPERTY_DIALOG] = dialogProps-&gt;toPropertyMap();
+                curDialogProp[DialogManager::PROPERTY_DIALOG_NAME] = Property(it-&gt;first.getName());
+
+                PropertyArray npcs;
+
+                for (std::vector&lt;Creature*&gt;::const_iterator itNpc = it-&gt;first.getNpcs().begin();
+                    itNpc != it-&gt;first.getNpcs().end(); ++itNpc)
+                {
+                    npcs.push_back(GameObjectManager::getSingleton().toProperty(*itNpc));
+                }
+
+                curDialogProp[DialogManager::PROPERTY_NPCS] = Property(npcs);
+            }
+
+            return Property(vec);
+        }
+
+        Throw(IllegalArgumentException, key + &quot; is not a property of DialogManager&quot;);
+    }
+	
+	int DialogManager::getPriority() const
+	{
+		return 50;
+	}
+
+    PropertyKeys DialogManager::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(DialogManager::PROPERTY_DIALOGS);
+        return keys;
+    }
+
+    void DialogManager::setProperty(const CeGuiString&amp; key, const Property&amp; value)
+    {
+        ///@todo implement
+    }
+
+    void DialogManager::writeData(SaveGameFileWriter *writer)
+    {
+        LOG_MESSAGE(Logger::RULES, &quot;Saving dialogs&quot;);
+
+        PropertyRecordPtr set = getAllProperties();
+        writer-&gt;writeEachProperty(this, set-&gt;toPropertyMap());
+    }
+
+    void DialogManager::readData(SaveGameFileReader* reader)
+    {
+        LOG_MESSAGE(Logger::RULES, &quot;Loading dialogs&quot;);
+
+        PropertyRecordPtr properties = reader-&gt;getAllPropertiesAsRecord(this);
+        setProperties(properties);
+    }
+
+    CeGuiString DialogManager::getXmlNodeIdentifier() const
+    {
+        return &quot;dialogs&quot;;
+    }
+
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, Creature* npc, Creature* pc)
+    {
+        std::vector&lt;Creature*&gt; npcs;
+        npcs.push_back(npc);
+        std::vector&lt;Creature*&gt; pcs;
+        pcs.push_back(pc);
+
+        return createDialog(name, npcs, pcs);
+    }
+
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
+    {
+        std::map&lt;DialogConfiguration, Dialog*&gt;::iterator it 
+            = mDialogStates.find(DialogConfiguration(name, npcs));
+
+        Dialog* dialog;
+        if (it != mDialogStates.end())
+        {
+            dialog = (*it).second;
+        }
+        else 
+        {
+			dialog = mDialogLoader-&gt;createDialog(name, pcs, npcs); ///@todo save dialogs
+			
+			if (!dialog) 
+			{
+				return NULL;
+			}
+			
+            dialog-&gt;initialize();
+            mDialogStates[DialogConfiguration(name, npcs)] = dialog;
+        }
+		return dialog;
+    }
+	
+    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs)
+        : mDialogName(name), mNpcs(npcs)
+    {
+    }
+
+    const Ogre::String&amp; DialogManager::DialogConfiguration::getName() const
+    {
+        return mDialogName;
+    }
+
+    const std::vector&lt;Creature*&gt;&amp; DialogManager::DialogConfiguration::getNpcs() const
+    {
+        return mNpcs;
+    }
+
+    bool DialogManager::DialogConfiguration::operator &lt;(const rl::DialogManager::DialogConfiguration &amp; other) const
+    {
+        return mDialogName &lt; other.mDialogName;
+    }
+
+    bool DialogManager::DialogConfiguration::operator ==(const rl::DialogManager::DialogConfiguration &amp; other) const
+    {
+        return (mDialogName == other.mDialogName) 
+            &amp;&amp; (mNpcs == other.mNpcs);
+    }
+
+
+}

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2008-07-11 19:42:39 UTC (rev 4445)
+++ rl/trunk/engine/ai/src/Makefile.am	2008-07-11 19:59:08 UTC (rev 4446)
@@ -21,6 +21,7 @@
 	DialogCondition.cpp \
 	DialogElement.cpp \
 	DialogImplication.cpp \
+	DialogLoader.cpp \
 	DialogManager.cpp \
 	DialogOption.cpp \
 	DialogParagraph.cpp \


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001516.html">[Dsa-hl-svn] r4445 - in rl/trunk/engine/common: include src
</A></li>
	<LI>Next message: <A HREF="001518.html">[Dsa-hl-svn] r4447 - in rl/trunk/engine/ai: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1517">[ date ]</a>
              <a href="thread.html#1517">[ thread ]</a>
              <a href="subject.html#1517">[ subject ]</a>
              <a href="author.html#1517">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
