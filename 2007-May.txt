From blakharaz at mail.berlios.de  Tue May  1 22:08:27 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 1 May 2007 22:08:27 +0200
Subject: [Dsa-hl-svn] r3373 - in rl/trunk/engine: rules/include rules/src
	script/src ui/include ui/src
Message-ID: <200705012008.l41K8RWb012044@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-01 22:08:14 +0200 (Tue, 01 May 2007)
New Revision: 3373

Modified:
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/script/src/Makefile.am
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/Makefile.am
Log:
Fix linux build

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-04-30 14:18:09 UTC (rev 3372)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-05-01 20:08:14 UTC (rev 3373)
@@ -26,6 +26,8 @@
 	QuestListener.h \
 	RulesPrerequisites.h \
 	RulesSubsystem.h \
+	SelectionHelper.h \
+	Selector.h \
 	StateSet.h \
 	SonderfertigkeitenStateSet.h \
 	Talent.h \
@@ -37,10 +39,4 @@
 	TimerListener.h \
 	TimerManager.h \
 	Weapon.h \
-	ZauberStateSet.h \
-	AbstractMapNodeProcessor.h \
-	EntityNodeProcessor.h \
-	GameObjectNodeProcessor.h \
-	LightNodeProcessor.h \
-	MapLoader.h \
-	SoundNodeProcessor.h
+	ZauberStateSet.h

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-04-30 14:18:09 UTC (rev 3372)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-05-01 20:08:14 UTC (rev 3373)
@@ -32,6 +32,8 @@
 	QuestEvent.cpp \
 	QuestListener.cpp \
 	RulesSubsystem.cpp \
+	SelectionHelper.cpp \
+	Selector.cpp \
 	Slot.cpp \
 	SonderfertigkeitenStateSet.cpp \
 	StateSet.cpp \
@@ -43,10 +45,4 @@
 	TimerListener.cpp \
 	TimerManager.cpp  \
 	Weapon.cpp \
-	ZauberStateSet.cpp \
-	AbstractMapNodeProcessor.cpp \
-	EntityNodeProcessor.cpp \
-	GameObjectNodeProcessor.cpp \
-	LightNodeProcessor.cpp \
-	MapLoader.cpp \
-	SoundNodeProcessor.cpp
+	ZauberStateSet.cpp

Modified: rl/trunk/engine/script/src/Makefile.am
===================================================================
--- rl/trunk/engine/script/src/Makefile.am	2007-04-30 14:18:09 UTC (rev 3372)
+++ rl/trunk/engine/script/src/Makefile.am	2007-05-01 20:08:14 UTC (rev 3373)
@@ -16,4 +16,10 @@
 libRlScript_la_SOURCES = \
   ScriptSubsystem.cpp \
   ScriptObjectMarker.cpp \
-	../swig/RlExports.cxx 
+	../swig/RlExports.cxx \
+	AbstractMapNodeProcessor.cpp \
+	EntityNodeProcessor.cpp \
+	GameObjectNodeProcessor.cpp \
+	LightNodeProcessor.cpp \
+	MapLoader.cpp \
+	SoundNodeProcessor.cpp

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-04-30 14:18:09 UTC (rev 3372)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-05-01 20:08:14 UTC (rev 3373)
@@ -12,7 +12,6 @@
     Console.h \
     ContainerContentWindow.h \
     CutsceneCharacterController.h \
-    DataLoadingProgressWindow.h \
     DebugWindow.h \
     DialogWindow.h \
     DialogCharacterController.h \
@@ -36,8 +35,8 @@
     MovementCharacterController.h \
     ObjectDescriptionWindow.h \
     PlaylistWindow.h \
+    ProgressWindow.h \
     RenderSystemConfigComponent.h \
-    Selector.h \
     SoundDriverConfigComponent.h \
     SubtitleWindow.h \
     UiPrerequisites.h \

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-04-30 14:18:09 UTC (rev 3372)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-05-01 20:08:14 UTC (rev 3373)
@@ -21,7 +21,6 @@
     ContainerContentWindow.cpp \
     Console.cpp \
     CutsceneCharacterController.cpp \
-    DataLoadingProgressWindow.cpp \
     DebugWindow.cpp \
     DialogCharacterController.cpp \
     DialogWindow.cpp \
@@ -45,8 +44,8 @@
     MovementCharacterController.cpp \
     ObjectDescriptionWindow.cpp \
     PlaylistWindow.cpp \
+    ProgressWindow.cpp \
     RenderSystemConfigComponent.cpp \
-    Selector.cpp \
     SoundDriverConfigComponent.cpp \
     SubtitleWindow.cpp \
     UiSubsystem.cpp \



From blakharaz at mail.berlios.de  Tue May  1 22:12:31 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 1 May 2007 22:12:31 +0200
Subject: [Dsa-hl-svn] r3374 - in rl/trunk/engine: ai/include ai/src
	common/include common/src core/include core/src
	dialog/include dialog/src rules/include rules/src
	script/include script/src ui/include ui/src
Message-ID: <200705012012.l41KCVQc012312@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-01 22:12:01 +0200 (Tue, 01 May 2007)
New Revision: 3374

Modified:
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/WayPointGraphManager.h
   rl/trunk/engine/ai/include/WayPointNode.h
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/WayPointGraphManager.cpp
   rl/trunk/engine/common/include/Logger.h
   rl/trunk/engine/common/include/ScriptWrapper.h
   rl/trunk/engine/common/src/Logger.cpp
   rl/trunk/engine/common/src/ScriptWrapper.cpp
   rl/trunk/engine/core/include/ActorManager.h
   rl/trunk/engine/core/include/AnimationManager.h
   rl/trunk/engine/core/include/ConfigurationManager.h
   rl/trunk/engine/core/include/DebugVisualsManager.h
   rl/trunk/engine/core/include/GameEventManager.h
   rl/trunk/engine/core/include/JobScheduler.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/include/SoundManager.h
   rl/trunk/engine/core/src/ActorManager.cpp
   rl/trunk/engine/core/src/AnimationManager.cpp
   rl/trunk/engine/core/src/DebugVisualsManager.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/JobScheduler.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/SoundManager.cpp
   rl/trunk/engine/dialog/include/DialogSubsystem.h
   rl/trunk/engine/dialog/src/DialogSubsystem.cpp
   rl/trunk/engine/rules/include/ActionManager.h
   rl/trunk/engine/rules/include/CombatManager.h
   rl/trunk/engine/rules/include/DsaManager.h
   rl/trunk/engine/rules/include/TimerManager.h
   rl/trunk/engine/rules/src/ActionManager.cpp
   rl/trunk/engine/rules/src/CombatManager.cpp
   rl/trunk/engine/rules/src/DsaManager.cpp
   rl/trunk/engine/rules/src/TimerManager.cpp
   rl/trunk/engine/script/include/ScriptObjectMarker.h
   rl/trunk/engine/script/include/ScriptSubsystem.h
   rl/trunk/engine/script/src/ScriptObjectMarker.cpp
   rl/trunk/engine/script/src/ScriptSubsystem.cpp
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/include/WindowManager.h
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
   rl/trunk/engine/ui/src/WindowManager.cpp
Log:
Remove all getSingleton() and getSingletonPtr() methods (maybe these were needed for vc6 or gcc 2.95)

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -46,7 +46,7 @@
 	 * to do its ai stuff (path finding, movement, decission making).
 	 */
 	class _RlAiExport AgentManager
-		: protected Ogre::Singleton<AgentManager>,
+		: public Ogre::Singleton<AgentManager>,
 		  public GameTask,
           public GameObjectStateListener
   	//	  public PhysicsController,
@@ -65,11 +65,6 @@
 			AGENT_FLOCKING = 2	//!< hmm, possibly for groups behaviour of NPCs
 		};
 
-		//! returns the agentmanager object
-		static AgentManager& getSingleton(void);
-		//! returns a pointer to the agentmanager object
-        static AgentManager* getSingletonPtr(void);
-
 		//! defines a std::vector list of Vehicle objects for OpenSteer
 		typedef std::vector<SteeringVehicle*> VehicleList;
 

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -35,19 +35,14 @@
 		  public SceneChangeListener
 	{
 	public:
-		//! returns the aisubsystem object.
-		static AiSubsystem & getSingleton(void);
-		//! returns a pointer to the aisubsystem object.
-        static AiSubsystem * getSingletonPtr(void);
-
 		//! default constructor
-		AiSubsystem(void);
+		AiSubsystem();
 		/** explicit virtual destructor.
 		 * Unregisters Scene listener, makes AgentManager drop all Agents,
 		 * unregisters AgentManager from GameLoop,
 		 * deletes AgentManager, WayPointGraphManager and AiWorld
 		 */
-		virtual ~AiSubsystem(void);
+		virtual ~AiSubsystem();
 		
 		/** Returns the stored world object representing storing obstacles.
 		 */

Modified: rl/trunk/engine/ai/include/WayPointGraphManager.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -32,15 +32,10 @@
 	 * are many waypoints. At the moment this not something to consider.
 	 */
 	class _RlAiExport WayPointGraphManager 
-		: protected Ogre::Singleton<WayPointGraphManager>
+		: public Ogre::Singleton<WayPointGraphManager>
 	{
 
 	public:
-		//! returns the agentmanager object
-		static WayPointGraphManager& getSingleton(void);
-		//! returns a pointer to the agentmanager object
-        static WayPointGraphManager* getSingletonPtr(void);
-
 		/** Constructor
 		 */
 		WayPointGraphManager();

Modified: rl/trunk/engine/ai/include/WayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointNode.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ai/include/WayPointNode.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -33,7 +33,7 @@
 		enum WayPointNodeType 
 		{
 			WP_UNKNOWN = 0,			//!< initial type - shouldn't be used
-			WP_EXTERIOR = 1,		//!< when the node is 'outdoors'
+			WP_EXTERIOR = 1 << 0,	//!< when the node is 'outdoors'
 			WP_INTERIOR = 1 << 1,	//!< when the node is inside (a building)
 		};
 		//! defines a weighted edge with a distance weigth

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -33,16 +33,6 @@
     }
 };
 
-AgentManager& AgentManager::getSingleton(void)
-{
-    return Singleton<AgentManager>::getSingleton();
-}
-
-AgentManager* AgentManager::getSingletonPtr(void)
-{
-    return Singleton<AgentManager>::getSingletonPtr();
-}
-
 AgentManager::AgentManager(void)
     : mBehaviourFactory(NULL), mAllNeighbors(), mAgents(), mPlayer(NULL)
 {

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -29,16 +29,6 @@
 
 namespace rl {
 
-AiSubsystem& AiSubsystem::getSingleton(void)
-{
-    return Singleton<AiSubsystem>::getSingleton();
-}
-
-AiSubsystem* AiSubsystem::getSingletonPtr(void)
-{
-    return Singleton<AiSubsystem>::getSingletonPtr();
-}
-
 AiSubsystem::AiSubsystem(void)
     : mAgentManager(NULL),
 	  mWayPointGraphManager(NULL),

Modified: rl/trunk/engine/ai/src/WayPointGraphManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -24,19 +24,10 @@
 
 namespace rl {
 
-WayPointGraphManager& WayPointGraphManager::getSingleton(void)
-{
-	return Singleton<WayPointGraphManager>::getSingleton();
-}
-
-WayPointGraphManager* WayPointGraphManager::getSingletonPtr(void)
-{
-	return Singleton<WayPointGraphManager>::getSingletonPtr();
-}
-
 WayPointGraphManager::WayPointGraphManager()
 {
 }
+
 WayPointGraphManager::~WayPointGraphManager()
 {
 	removeAllWayPointGraphs();

Modified: rl/trunk/engine/common/include/Logger.h
===================================================================
--- rl/trunk/engine/common/include/Logger.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/common/include/Logger.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -53,10 +53,6 @@
 		Logger(const Ogre::String& logDirectory, const Ogre::String& ogreLogFile, const Ogre::String& rastullahLogFile);
 		virtual ~Logger();
 
-        // Singleton Stuff
-        static Logger & getSingleton(void);
-        static Logger * getSingletonPtr(void);
-
 		void log(
 			const LogLevel level,
 			const Ogre::String& component,

Modified: rl/trunk/engine/common/include/ScriptWrapper.h
===================================================================
--- rl/trunk/engine/common/include/ScriptWrapper.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/common/include/ScriptWrapper.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -30,7 +30,7 @@
 		virtual void disowned( void* ptr ) = 0;
     };
 
-    class _RlCommonExport ScriptWrapper : protected Ogre::Singleton<ScriptWrapper>
+    class _RlCommonExport ScriptWrapper : public Ogre::Singleton<ScriptWrapper>
     {
     public:
         ScriptWrapper();
@@ -44,9 +44,6 @@
 		void deleted( void* ptr );
 		void owned( void* ptr );
         void disowned( void* ptr );
-        /** Returns the Singleton */
-        static ScriptWrapper & getSingleton(void);
-        static ScriptWrapper * getSingletonPtr(void);  
     private:
         ScriptWrapperInstance* m_ScriptWrapperInstance;
     };

Modified: rl/trunk/engine/common/src/Logger.cpp
===================================================================
--- rl/trunk/engine/common/src/Logger.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/common/src/Logger.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -38,16 +38,6 @@
 namespace rl
 {
 
-Logger& Logger::getSingleton(void)
-{
-    return Singleton<Logger>::getSingleton();
-}
-
-Logger* Logger::getSingletonPtr(void)
-{
-    return Singleton<Logger>::getSingletonPtr();
-}
-
 Logger::Logger(const Ogre::String& logDirectory, const Ogre::String& ogreLogFile, const Ogre::String& rastullahLogFile)
     : mLog(0),
       mLogLevel(LL_ERROR),

Modified: rl/trunk/engine/common/src/ScriptWrapper.cpp
===================================================================
--- rl/trunk/engine/common/src/ScriptWrapper.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/common/src/ScriptWrapper.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -22,16 +22,6 @@
 
 namespace rl {
 
-    ScriptWrapper& ScriptWrapper::getSingleton(void)
-	{
-		return Singleton<ScriptWrapper>::getSingleton();
-	}
-
-	ScriptWrapper* ScriptWrapper::getSingletonPtr(void)
-	{
-		return Singleton<ScriptWrapper>::getSingletonPtr();
-	}
-
     ScriptWrapper::ScriptWrapper()
         : m_ScriptWrapperInstance( NULL )
     {

Modified: rl/trunk/engine/core/include/ActorManager.h
===================================================================
--- rl/trunk/engine/core/include/ActorManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/ActorManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -33,7 +33,7 @@
     typedef std::map<const Ogre::String,Actor*> ActorPtrMap;
     typedef std::pair<const Ogre::String,Actor*> ActorPtrPair;
 
-    class _RlCoreExport ActorManager : protected Ogre::Singleton<ActorManager>
+    class _RlCoreExport ActorManager : public Ogre::Singleton<ActorManager>
     {
     public:
         ActorManager( );
@@ -69,10 +69,6 @@
         Ogre::Real getDefaultActorRenderingDistance() const;
         void setDefaultActorRenderingDistance( Ogre::Real dist );
 
-        /** Returns the Singleton */
-        static ActorManager & getSingleton(void);
-        static ActorManager * getSingletonPtr(void);        
-
     private:
         ActorPtrMap mActors;
         World* mWorld;

Modified: rl/trunk/engine/core/include/AnimationManager.h
===================================================================
--- rl/trunk/engine/core/include/AnimationManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/AnimationManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -40,7 +40,7 @@
 */
 class _RlCoreExport AnimationManager
   : public GameTask,
-    protected Ogre::Singleton<AnimationManager>
+    public Ogre::Singleton<AnimationManager>
 {
 public:
 	/// Interpolations-Modus, Spline ist besser, braucht auch mehr Perfomance
@@ -129,10 +129,6 @@
     virtual void run(Ogre::Real timePassed);
     virtual const Ogre::String& getName() const;
 
-	/// Singleton
-    static AnimationManager & getSingleton(void);
-	/// Singleton
-	static AnimationManager * getSingletonPtr(void);
 private:
     static void stopAnimation( BaseAnimation* anim );
 

Modified: rl/trunk/engine/core/include/ConfigurationManager.h
===================================================================
--- rl/trunk/engine/core/include/ConfigurationManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/ConfigurationManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -41,7 +41,7 @@
      * configuration files. If no configuration file is available, sane default values are
      * provided so that Rastullah will work properly on most systems.
      */
-    class _RlCoreExport ConfigurationManager : protected Ogre::Singleton<ConfigurationManager>
+    class _RlCoreExport ConfigurationManager : public Ogre::Singleton<ConfigurationManager>
     {
         public:
 

Modified: rl/trunk/engine/core/include/DebugVisualsManager.h
===================================================================
--- rl/trunk/engine/core/include/DebugVisualsManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/DebugVisualsManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -37,10 +37,6 @@
         DebugVisualsManager();
         virtual ~DebugVisualsManager();
 
-        // Singleton Stuff
-        static DebugVisualsManager& getSingleton(void);
-        static DebugVisualsManager* getSingletonPtr(void);
-
         /// Shows all visualisables, whose flags are set.
         /// @param flags Flags to compare to.
         void show(unsigned long flags);

Modified: rl/trunk/engine/core/include/GameEventManager.h
===================================================================
--- rl/trunk/engine/core/include/GameEventManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/GameEventManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -38,7 +38,7 @@
  */
 class _RlCoreExport GameEventManager
   : public GameTask,
-    protected Ogre::Singleton<GameEventManager>
+    public Ogre::Singleton<GameEventManager>
 {
 public:
     /** Default Constructor */
@@ -78,11 +78,6 @@
       */
     void removeAllAreas( Actor* actor );
 
-    /// Singleton
-    static GameEventManager & getSingleton(void);
-    /// Singleton
-    static GameEventManager * getSingletonPtr(void);
-
     virtual const Ogre::String& getName() const;
 
 	void removeQueuedDeletionSources();

Modified: rl/trunk/engine/core/include/JobScheduler.h
===================================================================
--- rl/trunk/engine/core/include/JobScheduler.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/JobScheduler.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -51,10 +51,6 @@
         JobScheduler();
         virtual ~JobScheduler();
 
-        // Singleton Stuff
-        static JobScheduler& getSingleton(void);
-        static JobScheduler* getSingletonPtr(void);
-
         /**
          * Adds a Job to the scheduler.
          * @param job The job to be added.

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -72,7 +72,7 @@
      */
     class _RlCoreExport PhysicsManager
         :   public GameTask,
-            protected Ogre::Singleton<PhysicsManager>
+            public Ogre::Singleton<PhysicsManager>
     {
     public:
 
@@ -120,10 +120,6 @@
         bool isEnabled() const;
         void setEnabled(bool enabled);
 
-        // Singleton Stuff
-        static PhysicsManager & getSingleton(void);
-        static PhysicsManager * getSingletonPtr(void);
-
 		/// Levelgeometrie hinzuf?gen
         void addLevelGeometry(Ogre::Entity* ent, const std::vector<OgreNewt::CollisionPtr> &collisions);
 		/// Komplette Levelgeometrie aufl?sen

Modified: rl/trunk/engine/core/include/SoundManager.h
===================================================================
--- rl/trunk/engine/core/include/SoundManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/include/SoundManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -51,10 +51,6 @@
             public Ogre::Singleton<SoundManager>, public GameTask
     {
     public:
-        /// Gibt das Singleton zurueck.
-        static SoundManager& getSingleton();
-        /// Gibt einen Zeiger auf das Singleton zurueck.
-        static SoundManager* getSingletonPtr();
         /// Eine Resource erzeugen
         /// Konstruktor
         SoundManager();

Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -40,16 +40,6 @@
 
 namespace rl {
 
-    ActorManager& ActorManager::getSingleton(void)
-    {
-        return Singleton<ActorManager>::getSingleton();
-    }
-
-    ActorManager* ActorManager::getSingletonPtr(void)
-    {
-        return Singleton<ActorManager>::getSingletonPtr();
-    }
-
     ActorManager::ActorManager()
         : mActors(),
         mWorld(CoreSubsystem::getSingleton().getWorld()),

Modified: rl/trunk/engine/core/src/AnimationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/AnimationManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/src/AnimationManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -344,16 +344,6 @@
     }
 }
 
-AnimationManager& AnimationManager::getSingleton(void)
-{
-    return Ogre::Singleton<AnimationManager>::getSingleton();
-}
-
-AnimationManager* AnimationManager::getSingletonPtr(void)
-{
-    return Ogre::Singleton<AnimationManager>::getSingletonPtr();
-}
-
 const Ogre::String& AnimationManager::getName() const
 {
     static Ogre::String NAME = "AnimationManager";

Modified: rl/trunk/engine/core/src/DebugVisualsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/DebugVisualsManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/src/DebugVisualsManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -24,16 +24,6 @@
 
 namespace rl
 {
-    DebugVisualsManager& DebugVisualsManager::getSingleton(void)
-    {
-        return Singleton<DebugVisualsManager>::getSingleton();
-    }
-
-    DebugVisualsManager* DebugVisualsManager::getSingletonPtr(void)
-    {
-        return Singleton<DebugVisualsManager>::getSingletonPtr();
-    }
-
     DebugVisualsManager::DebugVisualsManager() : mVisualisables()
     {
     }

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -24,16 +24,6 @@
 
 namespace rl {
 
-    GameEventManager& GameEventManager::getSingleton(void)
-    {
-        return Ogre::Singleton<GameEventManager>::getSingleton();
-    }
-
-    GameEventManager* GameEventManager::getSingletonPtr(void)
-    {
-        return Ogre::Singleton<GameEventManager>::getSingletonPtr();
-    }
-
     GameEventManager::GameEventManager( ) :
         mAreaEventSources(),
 		mQueuedDeletionSources()

Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -25,16 +25,6 @@
 
 namespace rl
 {
-    JobScheduler& JobScheduler::getSingleton(void)
-    {
-        return Singleton<JobScheduler>::getSingleton();
-    }
-
-    JobScheduler* JobScheduler::getSingletonPtr(void)
-    {
-        return Singleton<JobScheduler>::getSingletonPtr();
-    }
-
     JobScheduler::JobScheduler()
         : mJobQueue(), mRemovedJobs(), mTokenThreshold(JP_NORMAL), mTicketCounter(0)
     {

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -66,16 +66,6 @@
 		return body->getCollision()->getAABB();
 	}
 
-    PhysicsManager& PhysicsManager::getSingleton(void)
-    {
-        return Singleton<PhysicsManager>::getSingleton();
-    }
-
-    PhysicsManager* PhysicsManager::getSingletonPtr(void)
-    {
-        return Singleton<PhysicsManager>::getSingletonPtr();
-    }
-
     PhysicsManager::PhysicsManager( )
         : mEnabled(false),
         mNewtonDebugger(),

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -43,26 +43,6 @@
 namespace rl
 {
     /**
-     * @return Eine Referenz auf das Singleton-Objekt.
-     * @author JoSch
-     * @date 04-26-2004
-     */
-    SoundManager& SoundManager::getSingleton()
-    {
-        return Singleton<SoundManager>::getSingleton();
-    }
-
-    /**
-     * @return Ein Zeiger auf das Singleton-Objekt.
-     * @author JoSch
-     * @date 04-26-2004
-     */
-    SoundManager* SoundManager::getSingletonPtr()
-    {
-        return Singleton<SoundManager>::getSingletonPtr();
-    }
-
-    /**
      * Standardkonstruktor
      * @author JoSch
      * @date 01-27-2005

Modified: rl/trunk/engine/dialog/include/DialogSubsystem.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -38,9 +38,6 @@
 		public Ogre::Singleton<DialogSubsystem>
 	{
 	public:
-		static DialogSubsystem & getSingleton(void);
-        static DialogSubsystem * getSingletonPtr(void);
-
 		DialogSubsystem();
 		virtual ~DialogSubsystem();
 		

Modified: rl/trunk/engine/dialog/src/DialogSubsystem.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -37,16 +37,6 @@
 
 namespace rl {
 
-DialogSubsystem& DialogSubsystem::getSingleton(void)
-{
-	return Singleton<DialogSubsystem>::getSingleton();
-}
-
-DialogSubsystem* DialogSubsystem::getSingletonPtr(void)
-{
-	return Singleton<DialogSubsystem>::getSingletonPtr();
-}
-
 DialogSubsystem::DialogSubsystem()
 	: mCore(new AimlCore()),
 	  mContextInterpreter(new ContextInterpreter()),

Modified: rl/trunk/engine/rules/include/ActionManager.h
===================================================================
--- rl/trunk/engine/rules/include/ActionManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/include/ActionManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -58,9 +58,6 @@
 		void registerInGameGlobalAction(Action* action, ActionGroup* group);
 		Action* getInGameGlobalAction(const CeGuiString actionName) const;
 		const ActionVector& getInGameGlobalActions();
-	
-        static ActionManager& getSingleton(void);
-        static ActionManager* getSingletonPtr(void);
     };
 }
 

Modified: rl/trunk/engine/rules/include/CombatManager.h
===================================================================
--- rl/trunk/engine/rules/include/CombatManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/include/CombatManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -29,9 +29,6 @@
     class _RlRulesExport CombatManager : public Ogre::Singleton<CombatManager>
     {
     public:
-        static CombatManager& getSingleton(void);
-        static CombatManager* getSingletonPtr(void);
-
        CombatManager();
         ~CombatManager();
 

Modified: rl/trunk/engine/rules/include/DsaManager.h
===================================================================
--- rl/trunk/engine/rules/include/DsaManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/include/DsaManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -51,9 +51,6 @@
 			RULE_DISTANZKLASSEN
 		};
 
-        static DsaManager& getSingleton(void);
-        static DsaManager* getSingletonPtr(void);
-
         /** Default Constructor */
         DsaManager();
         /** Default Deconstructor */

Modified: rl/trunk/engine/rules/include/TimerManager.h
===================================================================
--- rl/trunk/engine/rules/include/TimerManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/include/TimerManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -35,9 +35,6 @@
 class _RlRulesExport TimerManager : public GameTask, public Ogre::Singleton<TimerManager>
 {
 public:
-	static TimerManager& getSingleton();
-	static TimerManager* getSingletonPtr();
-
 	TimerManager();
 	virtual ~TimerManager();
 

Modified: rl/trunk/engine/rules/src/ActionManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/ActionManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/src/ActionManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -44,16 +44,6 @@
 		return end;
 	}
 
-    ActionManager& ActionManager::getSingleton(void)
-    {
-    return Singleton<ActionManager>::getSingleton();
-    }
-
-    ActionManager* ActionManager::getSingletonPtr(void)
-    {
-        return Singleton<ActionManager>::getSingletonPtr();
-    }
-
     ActionManager::ActionManager()
     {
     }

Modified: rl/trunk/engine/rules/src/CombatManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CombatManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/src/CombatManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -25,16 +25,7 @@
 
 namespace rl
 {
-    CombatManager& CombatManager::getSingleton(void)
-    {
-        return Singleton<CombatManager>::getSingleton();
-    }
 
-    CombatManager* CombatManager::getSingletonPtr(void)
-    {
-        return Singleton<CombatManager>::getSingletonPtr();
-    }
-
     CombatManager::CombatManager() : mCurrentCombat(NULL)
     {
     }

Modified: rl/trunk/engine/rules/src/DsaManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/src/DsaManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -37,16 +37,6 @@
 
 namespace rl
 {
-    DsaManager& DsaManager::getSingleton(void)
-    {
-        return Ogre::Singleton<DsaManager>::getSingleton();
-    }
-
-    DsaManager* DsaManager::getSingletonPtr(void)
-    {
-        return Ogre::Singleton<DsaManager>::getSingletonPtr();
-    }
-
     DsaManager::DsaManager()
         : mLastGameTime(0),
         mLastClock(0),

Modified: rl/trunk/engine/rules/src/TimerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/rules/src/TimerManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -31,16 +31,6 @@
 
 namespace rl {
 
-	TimerManager& TimerManager::getSingleton()
-	{
-		return Singleton<TimerManager>::getSingleton();
-	}
-
-	TimerManager* TimerManager::getSingletonPtr()
-	{
-		return Singleton<TimerManager>::getSingletonPtr();
-	}
-
 	TimerManager::TimerManager() :
 		mTimers()
 	{

Modified: rl/trunk/engine/script/include/ScriptObjectMarker.h
===================================================================
--- rl/trunk/engine/script/include/ScriptObjectMarker.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/script/include/ScriptObjectMarker.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -33,16 +33,13 @@
 
 
 namespace rl {
-    class _RlScriptExport ScriptObjectMarker : protected Ogre::Singleton<ScriptObjectMarker>, 
+    class _RlScriptExport ScriptObjectMarker : public Ogre::Singleton<ScriptObjectMarker>, 
         protected ScriptWrapperInstance
     {
     public:
         ScriptObjectMarker();
         ~ScriptObjectMarker();
 
-        static ScriptObjectMarker& getSingleton();
-        static ScriptObjectMarker* getSingletonPtr();
-
         virtual void owned( void* ptr );
         virtual void disowned( void* ptr );
         virtual void deleted( void* ptr );

Modified: rl/trunk/engine/script/include/ScriptSubsystem.h
===================================================================
--- rl/trunk/engine/script/include/ScriptSubsystem.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/script/include/ScriptSubsystem.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -29,9 +29,6 @@
         ScriptSubsystem();
         virtual ~ScriptSubsystem();
 
-        static ScriptSubsystem& getSingleton();
-        static ScriptSubsystem* getSingletonPtr();
-
         void log(const CeGuiString& message);
 
     private:

Modified: rl/trunk/engine/script/src/ScriptObjectMarker.cpp
===================================================================
--- rl/trunk/engine/script/src/ScriptObjectMarker.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/script/src/ScriptObjectMarker.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -25,16 +25,6 @@
 
 namespace rl {
 
-    ScriptObjectMarker& ScriptObjectMarker::getSingleton()
-    {
-        return Ogre::Singleton<ScriptObjectMarker>::getSingleton();
-    }
-
-    ScriptObjectMarker* ScriptObjectMarker::getSingletonPtr()
-    {
-        return Ogre::Singleton<ScriptObjectMarker>::getSingletonPtr();
-    }
-
     ScriptObjectMarker::ScriptObjectMarker() :
         m_RubyRefCountMap()
     {

Modified: rl/trunk/engine/script/src/ScriptSubsystem.cpp
===================================================================
--- rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -20,22 +20,12 @@
 
 using Ogre::Singleton;
 
-template<> rl::ScriptSubsystem* Singleton<rl::ScriptSubsystem>::ms_Singleton = 0;
+template<> rl::ScriptSubsystem* Singleton<rl::ScriptSubsystem>::ms_Singleton = NULL;
 
 namespace rl {
 
-    ScriptSubsystem& ScriptSubsystem::getSingleton()
+    ScriptSubsystem::ScriptSubsystem() : mScriptObjectMarker(NULL)
     {
-        return Singleton<ScriptSubsystem>::getSingleton();
-    }
-
-    ScriptSubsystem* ScriptSubsystem::getSingletonPtr()
-    {
-        return Singleton<ScriptSubsystem>::getSingletonPtr();
-    }
-
-    ScriptSubsystem::ScriptSubsystem() : mScriptObjectMarker(0)
-    {
         mScriptObjectMarker = new ScriptObjectMarker();	
     }
 

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/include/InputManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -48,9 +48,6 @@
         InputManager(Ogre::RenderWindow* window);
         ~InputManager();
 
-        static InputManager & getSingleton(void);
-        static InputManager * getSingletonPtr(void);
-
         bool isMouseButtonDown( OIS::MouseButtonID buttonID );
 
         Ogre::Real getMouseRelativeX(void) const;

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -45,7 +45,7 @@
     class WindowManager;
 
     class _RlUiExport UiSubsystem : public SceneChangeListener,
-        protected Ogre::Singleton<UiSubsystem>
+        public Ogre::Singleton<UiSubsystem>
     {
     public:
         static const char* CEGUI_ROOT;
@@ -55,10 +55,6 @@
         /** Default Deconstructor */
         virtual ~UiSubsystem();
 
-        /** Returns the Singleton */
-        static UiSubsystem & getSingleton(void);
-        static UiSubsystem * getSingletonPtr(void);
-
         CEGUI::OgreCEGUIRenderer* getGUIRenderer();
         Person* getActiveCharacter() const;
         ///@todo function feels misplaced here,

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -72,9 +72,6 @@
 
         void initialize();
 
-        static WindowFactory& getSingleton();
-        static WindowFactory* getSingletonPtr();
-
         void setActiveCharacter(Creature* character);
 
         void showActionChoice(GameObject* obj);

Modified: rl/trunk/engine/ui/include/WindowManager.h
===================================================================
--- rl/trunk/engine/ui/include/WindowManager.h	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/include/WindowManager.h	2007-05-01 20:12:01 UTC (rev 3374)
@@ -39,9 +39,6 @@
 		WindowManager();
 		~WindowManager();
 
-		static WindowManager& getSingleton();
-		static WindowManager* getSingletonPtr();
-
 		void registerWindow(AbstractWindow* window);
 		void destroyWindow(AbstractWindow* window);
 		void closeTopWindow();

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -94,16 +94,6 @@
         }
     }
 
-    InputManager& InputManager::getSingleton()
-    {
-        return Singleton<InputManager>::getSingleton();
-    }
-
-    InputManager* InputManager::getSingletonPtr()
-    {
-        return Singleton<InputManager>::getSingletonPtr();
-    }
-
     void InputManager::initializeOis(RenderWindow* win)
     {
         // BEGIN INPUT INITIALIZATION
@@ -118,7 +108,7 @@
             pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_EXCLUSIVE")));
             pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_FOREGROUND")));
         #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        //    pl.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
+            pl.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
         //    pl.insert(std::make_pair(std::string("x11_keyboard_grab"), std::string("false")));
         #endif
 

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -55,16 +55,6 @@
 namespace rl {
     const char* UiSubsystem::CEGUI_ROOT = "RootWindow";
 
-    UiSubsystem& UiSubsystem::getSingleton(void)
-    {
-        return Singleton<UiSubsystem>::getSingleton();
-    }
-
-    UiSubsystem* UiSubsystem::getSingletonPtr(void)
-    {
-        return Singleton<UiSubsystem>::getSingletonPtr();
-    }
-
     UiSubsystem::UiSubsystem() :
         mCharacter(NULL),
         mInputManager(NULL),

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -133,16 +133,6 @@
         delete mSubtitleWindow;
     }
 
-    WindowFactory& WindowFactory::getSingleton()
-    {
-        return Ogre::Singleton<WindowFactory>::getSingleton();
-    }
-
-    WindowFactory* WindowFactory::getSingletonPtr()
-    {
-        return Ogre::Singleton<WindowFactory>::getSingletonPtr();
-    }
-
     void WindowFactory::showCharacterActionChoice()
     {
         showActionChoice(UiSubsystem::getSingleton().getActiveCharacter());

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2007-05-01 20:08:14 UTC (rev 3373)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2007-05-01 20:12:01 UTC (rev 3374)
@@ -78,14 +78,4 @@
 		mWindowList.push_back(window);
 		return true;
 	}
-
-	WindowManager& WindowManager::getSingleton()
-	{
-		return Ogre::Singleton<WindowManager>::getSingleton();
-	}
-
-	WindowManager* WindowManager::getSingletonPtr()
-	{
-		return Ogre::Singleton<WindowManager>::getSingletonPtr();
-	}
 }



From blakharaz at mail.berlios.de  Tue May  1 22:14:11 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 1 May 2007 22:14:11 +0200
Subject: [Dsa-hl-svn] r3375 - in rl/trunk/engine: core/include core/src
	script/include script/src
Message-ID: <200705012014.l41KEBMo012396@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-01 22:13:52 +0200 (Tue, 01 May 2007)
New Revision: 3375

Modified:
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/script/include/MapLoader.h
   rl/trunk/engine/script/src/MapLoader.cpp
Log:
Pause all game tasks while loading a map

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2007-05-01 20:12:01 UTC (rev 3374)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2007-05-01 20:13:52 UTC (rev 3375)
@@ -69,10 +69,6 @@
     /** Renders one frame (for internal use) */
     void renderOneFrame();
 
-    /** Returns the Singleton */
-    //static CoreSubsystem & getSingleton();
-    //static CoreSubsystem * getSingletonPtr();
-
     World* getWorld();
     void loadMap(const Ogre::String type, const Ogre::String filename,
         const Ogre::String module);
@@ -117,6 +113,10 @@
      */
     Ogre::RenderWindow* getRenderWindow();
 
+	/// Sets the pause state of the game
+	/// @param paused <code>true</code> if the game should be paused, <code>false</code> if it should be continued
+	void setPaused(bool paused);
+
 private:
     World* mWorld;
     RubyInterpreter* mRubyInterpreter;

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2007-05-01 20:12:01 UTC (rev 3374)
+++ rl/trunk/engine/core/include/GameLoop.h	2007-05-01 20:13:52 UTC (rev 3375)
@@ -31,7 +31,7 @@
 /// GameLoop::loop is called immediately after RL has been initialised.
 /// GameLoop is dumb, it only calls added tasks in the set order.
 /// No game logic whatsoever is handled here.
-class _RlCoreExport GameLoop : protected Ogre::Singleton<GameLoop>
+class _RlCoreExport GameLoop : public Ogre::Singleton<GameLoop>
 {
 public:
     /// Groups a task can belong to. Tasks are executed in the order listed.
@@ -60,6 +60,13 @@
 	/// Request the game to quit. The current task loop will finish though.
 	void quitGame();
 
+	/// Returns <code>true</code> if the game is paused
+	bool isPaused() const;
+
+	/// Sets the pause state of the game
+	/// @param paused <code>true</code> if the game should be paused, <code>false</code> if it should be continued
+	void setPaused(bool paused);
+
     /// Returns time since game started in Milliseconds.
     unsigned long getClock() const;
 
@@ -70,9 +77,6 @@
     /// @see CoreSubsystem
     void _executeOneRenderLoop();
       
-    static GameLoop & getSingleton(void);
-	static GameLoop * getSingletonPtr(void);
-
 private:
     /// Internal struct for storing the tasks in the queue.
     /// Contains additional meta-information useful for scheduling.
@@ -115,6 +119,7 @@
     /// Time cap for frame time, to prevent interpolation problems during spikes.
     Ogre::Real mMaxFrameTime;
 	bool mQuitRequested;
+	bool mPaused;
 
     /// Averages frame rate over mSmoothPeriod milliseconds.
     /// Steadies Controls and Physics a bit.

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-05-01 20:12:01 UTC (rev 3374)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-05-01 20:13:52 UTC (rev 3375)
@@ -155,6 +155,11 @@
         return mRenderWindow;
     }
 
+	void CoreSubsystem::setPaused(bool paused)
+	{
+		mGameLoop->setPaused(paused);
+	}
+
     bool CoreSubsystem::initializeCoreSubsystem()
     {
         // By not specifying the first two parameters, OGRE will not try

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-05-01 20:12:01 UTC (rev 3374)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-05-01 20:13:52 UTC (rev 3375)
@@ -29,17 +29,8 @@
 
 template<> rl::GameLoop* Singleton<rl::GameLoop>::ms_Singleton = 0;
 
-namespace rl {
-
-    GameLoop* GameLoop::getSingletonPtr(void)
-    {
-        return Singleton<GameLoop>::getSingletonPtr();
-    }
-    GameLoop& GameLoop::getSingleton(void)
-    {
-        return Singleton<GameLoop>::getSingleton();
-    }
-
+namespace rl 
+{
     GameLoop::GameLoop()
         : mTaskLists(),
           mAddedTasks(),
@@ -49,14 +40,15 @@
           mLastTimes(),
           mSmoothPeriod(500),
           mMaxFrameTime(0.250f),
-          mQuitRequested(false)
+          mQuitRequested(false),
+		  mPaused(false)
     {
         // create five task lists, one for each taskgroup
-        mTaskLists.push_back(new GameTaskList);
-        mTaskLists.push_back(new GameTaskList);
-        mTaskLists.push_back(new GameTaskList);
-        mTaskLists.push_back(new GameTaskList);
-        mTaskLists.push_back(new GameTaskList);
+        mTaskLists.push_back(new GameTaskList());
+        mTaskLists.push_back(new GameTaskList());
+        mTaskLists.push_back(new GameTaskList());
+        mTaskLists.push_back(new GameTaskList());
+        mTaskLists.push_back(new GameTaskList());
 
         mTimer = new Timer();
     }
@@ -114,6 +106,16 @@
         }
     }
 
+	bool GameLoop::isPaused() const
+	{
+		return mPaused;
+	}
+
+	void GameLoop::setPaused(bool paused)
+	{
+		mPaused = paused;
+	}
+
     void GameLoop::_executeOneRenderLoop()
     {
         // Calculate frame time. This time is smoothed and capped.
@@ -134,9 +136,9 @@
             GameTaskList* tasks = mTaskLists[i];
             for (GameTaskList::iterator it = tasks->begin(); it != tasks->end(); ++it)
             {
-                if (it->valid && !(it->task->isPaused()))
+                if (it->valid && !(it->task->isPaused()) && !isPaused())
                 {
-                    it->task->run(frameTime);
+					it->task->run(frameTime);
                 }
             }
         }

Modified: rl/trunk/engine/script/include/MapLoader.h
===================================================================
--- rl/trunk/engine/script/include/MapLoader.h	2007-05-01 20:12:01 UTC (rev 3374)
+++ rl/trunk/engine/script/include/MapLoader.h	2007-05-01 20:13:52 UTC (rev 3375)
@@ -43,10 +43,7 @@
         void loadMap(const Ogre::String& mapresource, bool loadGameObjects = true);
 
     private:
-        enum {ENTITIES, GAMEOBJECTS, SOUNDS, LIGHTS};
-    
         XmlPropertyReader* mXmlPropertyProcessor;
-        int mStatistics[4];
         std::list<AbstractMapNodeProcessor*> mNodeProcessors;
 
         Ogre::SceneNode* mRootSceneNode;

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2007-05-01 20:12:01 UTC (rev 3374)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2007-05-01 20:13:52 UTC (rev 3375)
@@ -106,6 +106,7 @@
             DOMElement* dataDocumentContent = doc->getDocumentElement();
             
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
+			CoreSubsystem::getSingleton().setPaused(true);
             
             LOG_MESSAGE(Logger::RULES, "Processing nodes");
             
@@ -118,6 +119,7 @@
             doc->release();
 
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
+			CoreSubsystem::getSingleton().setPaused(false);
         }
         else
         {
@@ -140,14 +142,8 @@
 
         for (DOMNode* cur = nodesElem->getFirstChild(); 
             cur != NULL; 
-            cur = cur->getNextSibling(), count += 1)
+            cur = cur->getNextSibling())
         {
-            if (count % 250 == 0)
-            {
-                setLoadingPercentage(count/numChildren, 
-                    Ogre::StringConverter::toString(count/numChildren*100.0f, 0) + "%");
-            }
-
             if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
             {
                 DOMElement* curElem = static_cast<DOMElement*>(cur);
@@ -164,6 +160,13 @@
                         "Node " + XmlHelper::transcodeToString(curElem->getNodeName()) + " could not be processed.");
                 }
             }
+
+			count += 1;
+            if (count % 250 == 0)
+            {
+                setLoadingPercentage(count/numChildren, 
+                    Ogre::StringConverter::toString(count/numChildren*100.0f, 0) + "%");
+            }
         }
     }
 



From melven at mail.berlios.de  Wed May  2 20:42:28 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 2 May 2007 20:42:28 +0200
Subject: [Dsa-hl-svn] r3376 - rl/trunk/engine/rules/src
Message-ID: <200705021842.l42IgSgt026113@sheep.berlios.de>

Author: melven
Date: 2007-05-02 20:42:11 +0200 (Wed, 02 May 2007)
New Revision: 3376

Modified:
   rl/trunk/engine/rules/src/Creature.cpp
Log:
small corrections of the TaktischeBewegungs-functions

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-05-01 20:13:52 UTC (rev 3375)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-05-02 18:42:11 UTC (rev 3376)
@@ -1062,6 +1062,8 @@
         else if( (movementType & BEWEGUNG_HOCHSPRUNG) || (movementType & BEWEGUNG_WEITSPRUNG) )
         {
             // if( getragenes Gewicht > KK ) return false
+            if( getAu() < 6.0 || getAu() < getAuBasis()/3.0 )
+                return false;
         }
 
 
@@ -1176,6 +1178,10 @@
             {
                 velocity *= 0.3;
             }
+            if( movementType & BEWEGUNG_RUECKWAERTS )
+            {
+                velocity *= 0.3;
+            }
             return velocity;
         }
         else if( movementType & BEWEGUNG_HOCHSPRUNG )



From melven at mail.berlios.de  Wed May  2 20:48:07 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 2 May 2007 20:48:07 +0200
Subject: [Dsa-hl-svn] r3377 - rl/trunk/engine/ui/src
Message-ID: <200705021848.l42Im7eh026310@sheep.berlios.de>

Author: melven
Date: 2007-05-02 20:47:52 +0200 (Wed, 02 May 2007)
New Revision: 3377

Modified:
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
provisionally set the orientation of the character directly (due to changes in ogre)

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-02 18:42:11 UTC (rev 3376)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-02 18:47:52 UTC (rev 3377)
@@ -131,7 +131,7 @@
             mCharacterActor->getControlledObject());
         AxisAlignedBox aabb = charMesh->getDefaultSize();
 
-        // wird sp?er neu berechnet in calculateOptimalCameraPosition
+        // this will be recalculated in calculateOptimalCameraPosition
         mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
 
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
@@ -1178,6 +1178,7 @@
 
 
 
+
             // Calculate angular velocity
             // We first need the yaw rotation from actual yaw to desired yaw
             Vector3 src = orientation*Vector3::NEGATIVE_UNIT_Z;
@@ -1186,14 +1187,16 @@
             dst.y = 0;
             Radian yaw = src.getRotationTo(dst).getYaw();
 
-
+/*
             // was soll dieser komische Fehler?
             // wenn yaw 0 sein sollte, wird er manchmal zu -90 grad, find ich nich nett
             if( (yaw.valueDegrees() - (-90)) < 0.5 )
                 if( src.directionEquals(-dst, Degree(45)) )
                     yaw = Degree(0);
+*/
+            if( src.directionEquals(dst, Degree(1)))
+                yaw = Degree(0);
 
-
             // Calculate omega in order to go this rotation in mMaxDelay seconds.
             // Real newOmega = yaw.valueRadians() / mMaxDelay;
             Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
@@ -1202,7 +1205,11 @@
             // sollte nicht direkt gesetzt werden!
             Vector3 springAcc = -mRotLinearSpringK*diff - mRotLinearDampingK * omega;
             //body->setOmega(Vector3(0, newOmega, 0)); // omega sollte nicht direkt gesetzt werden
-            body->setTorque( mass * springAcc );
+//            body->setTorque( mass * springAcc );
+
+            // All this doesn't work correctly with the new version of ogre
+            // So we set the orientation directly until the problem is solved
+            mCharacterActor->setOrientation(Quaternion(mYaw, Vector3::UNIT_Y));
         }
 
 



From melven at mail.berlios.de  Wed May  2 21:06:47 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 2 May 2007 21:06:47 +0200
Subject: [Dsa-hl-svn] r3378 - in rl/trunk/engine/ui: include src
Message-ID: <200705021906.l42J6lpb029204@sheep.berlios.de>

Author: melven
Date: 2007-05-02 21:06:34 +0200 (Wed, 02 May 2007)
New Revision: 3378

Modified:
   rl/trunk/engine/ui/include/FreeFlightCharacterController.h
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
Log:
yaw and pitch work correctly now (turning right/left is always treated as rotation of the (global)y-axis)

Modified: rl/trunk/engine/ui/include/FreeFlightCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-05-02 18:47:52 UTC (rev 3377)
+++ rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-05-02 19:06:34 UTC (rev 3378)
@@ -68,6 +68,8 @@
 		Ogre::Real mRotationSpeed;
         Ogre::Vector3 mDesiredVelocity;
         Ogre::Vector3 mCameraUpConstraint;
+        Ogre::Radian mYaw;
+        Ogre::Radian mPitch;
         bool mCollisionsEnabled;
         Ogre::Real mMouseSensitivity;
         bool mInvertedMouse;

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-05-02 18:47:52 UTC (rev 3377)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-05-02 19:06:34 UTC (rev 3378)
@@ -43,7 +43,9 @@
         mDesiredVelocity(Vector3::ZERO),
         mCollisionsEnabled(false),
         mPitchRange(Degree(-89), Degree(89)),
-        mCameraUpConstraint(Vector3::ZERO)
+        mCameraUpConstraint(Vector3::ZERO),
+        mYaw(Degree(0)),
+        mPitch(Degree(0))
 	{
         mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
         mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
@@ -156,34 +158,34 @@
 		}
 
 
-        Radian yaw;
         if (movement & TURN_LEFT)
-            yaw = elapsedTime * Degree(120.0f);
+            mYaw += elapsedTime * Degree(120.0f);
         if (movement & TURN_RIGHT)
-            yaw = -elapsedTime * Degree(120.0f);
+            mYaw -= elapsedTime * Degree(120.0f);
 
         // mouse
         if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
         {
-            yaw = -mMouseSensitivity * Degree(im->getMouseRelativeX() / 10);
+            mYaw -= mMouseSensitivity * Degree(im->getMouseRelativeX() / 10);
         }
-        while (yaw.valueDegrees() > 360.0f) yaw -= Degree(360.0f);
-        while (yaw.valueDegrees() < -360.0f) yaw += Degree(360.0f);
+        while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
+        while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
 
-        Radian pitch;
+
         if (mInvertedMouse)
-            pitch = mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
+            mPitch += mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
         else
-            pitch = -mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
+            mPitch -= mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
 
-        while (pitch.valueDegrees() > 360.0f) pitch -= Degree(360.0f);
-        while (pitch.valueDegrees() < -360.0f) pitch += Degree(360.0f);
-        if (pitch < mPitchRange.first) pitch = mPitchRange.first;
-        if (pitch > mPitchRange.second) pitch = mPitchRange.second;
+        while (mPitch.valueDegrees() > 360.0f) mPitch -= Degree(360.0f);
+        while (mPitch.valueDegrees() < -360.0f) mPitch += Degree(360.0f);
+        if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
+        if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
 
+        mCameraActor->setOrientation(Quaternion::IDENTITY);
         mCameraActor->getPhysicalThing()->clearUpConstraint();
-        mCameraActor->yaw(yaw.valueDegrees());
-        mCameraActor->pitch(pitch.valueDegrees());
+        mCameraActor->yaw(mYaw.valueDegrees());
+        mCameraActor->pitch(mPitch.valueDegrees());
     }
 
 	void FreeFlightCharacterController::toggleCameraCollision()
@@ -212,6 +214,8 @@
 		    mCameraActor->setOrientation( Quaternion::IDENTITY );
             mCameraActor->setPosition( Vector3::ZERO );
         }
+        mYaw = Degree(0);
+        mPitch = Degree(0);
 	}
 
 	bool FreeFlightCharacterController::injectKeyDown(int keycode)



From blakharaz at mail.berlios.de  Thu May  3 01:44:37 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 3 May 2007 01:44:37 +0200
Subject: [Dsa-hl-svn] r3379 - modules/common/scripts rl/trunk/docs/documents
	rl/trunk/engine/core rl/trunk/engine/core/include
	rl/trunk/engine/core/src rl/trunk/engine/script
	rl/trunk/engine/script/include rl/trunk/engine/script/src
	rl/trunk/engine/script/swig
Message-ID: <200705022344.l42NibS1026330@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-03 01:44:19 +0200 (Thu, 03 May 2007)
New Revision: 3379

Added:
   rl/trunk/engine/core/include/Trigger.h
   rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
   rl/trunk/engine/script/include/TriggerFactory.h
   rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
Modified:
   modules/common/scripts/globals.rb
   rl/trunk/docs/documents/scene_format_proposal.xml
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/Zone.h
   rl/trunk/engine/core/src/Zone.cpp
   rl/trunk/engine/core/src/ZoneManager.cpp
   rl/trunk/engine/script/RlScript2005.vcproj
   rl/trunk/engine/script/include/ScriptSubsystem.h
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/src/ScriptSubsystem.cpp
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlScript.head.swig
   rl/trunk/engine/script/swig/RlScript.swig
Log:
Zones: Added triggers
Maploader: Added support for particle systems and triggers

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-05-02 19:06:34 UTC (rev 3378)
+++ modules/common/scripts/globals.rb	2007-05-02 23:44:19 UTC (rev 3379)
@@ -65,4 +65,16 @@
 rbf = RubyBehaviourFactory.new();
 $AI.setBehaviourFactory(rbf);
 
+class RubyTriggerFactory < TriggerFactory
+  def initialize()
+    super();
+  end
+
+  def createTrigger(classname)
+    return Module.const_get(classname).new();
+  end
+end
+
+ScriptSubsystem.getSingleton().setTriggerFactory(RubyTriggerFactory.new())
+
 require( "questsound.rb" );

Modified: rl/trunk/docs/documents/scene_format_proposal.xml
===================================================================
--- rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-02 23:44:19 UTC (rev 3379)
@@ -98,6 +98,9 @@
 			<!-- properties can be found in .gof files -->
 			<property name="description" type="STRING" data="Eine T?r, allerdings ist keine Klinke vorhanden" />
 		</gameobject>
+		
+		<!-- Particle system -->
+		<particlesystem name="Steinstaubwolke" material="Techdemo/Steinstaubwolke" active="true"/>
 
 	</nodes>
 
@@ -161,13 +164,18 @@
 		</zone>
 	</zones>
 
+        <environment>
+        	<!-- Sky Box -->
+        	<sky type="box" material="ruchinsky" drawfirst="true" distance="600"/>
+        
+        	<!-- Sky Dome -->
+        	<sky type="dome" material="ruchinsky" drawfirst="true">
+        		<skydomesettings curvature="10" tiling = "8" />
+        	</sky>
 
-	<!-- Sky Box -->
-	<sky type="box" material="ruchinsky" drawfirst="true" distance="600"/>
+        	<fog type="exp" expdensity="0.001" />
 
-	<!-- Sky Dome -->
-	<sky type="dome" material="ruchinsky" drawfirst="true">
-		<skydomesettings curvature="10" tiling = "8" />
-	</sky>
+        	<fog type="linear" start="0.0" end="1.0"/>
+       	</environment>
 
 </rastullahmap>

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-05-02 23:44:19 UTC (rev 3379)
@@ -569,6 +569,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\Trigger.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\World.h"
 				>
 			</File>

Added: rl/trunk/engine/core/include/Trigger.h
===================================================================
--- rl/trunk/engine/core/include/Trigger.h	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/core/include/Trigger.h	2007-05-02 23:44:19 UTC (rev 3379)
@@ -0,0 +1,33 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __Trigger_H__
+#define __Trigger_H__
+
+#include "CorePrerequisites.h"
+
+#include "Properties.h"
+
+namespace rl
+{
+	class _RlCoreExport Trigger : public PropertyHolder
+	{
+	public:
+		virtual bool activate() = 0;
+		virtual bool deactivate() = 0;
+	};
+}
+
+#endif // __Trigger_H__

Modified: rl/trunk/engine/core/include/Zone.h
===================================================================
--- rl/trunk/engine/core/include/Zone.h	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/core/include/Zone.h	2007-05-02 23:44:19 UTC (rev 3379)
@@ -24,6 +24,7 @@
 
 	class Actor;
 	class LightObject;
+	class Trigger;
 
 	///@todo: Inheritance is wrong, Zone should be a GameAreaEventSource, ZoneManager a GameAreaListener
 	class _RlCoreExport Zone : public GameAreaListener
@@ -33,8 +34,10 @@
 
 		void addLight(Actor* light);
         void addSound(const Ogre::String& name);
-		std::vector<Actor*> getLights() const;
-        std::vector<Ogre::String> getSounds() const;
+		void addTrigger(Trigger* trigger);
+		std::list<Actor*> getLights() const;
+        std::list<Ogre::String> getSounds() const;
+		std::list<Trigger*> getTriggers() const;
 
 		Actor* getActor() const;
 
@@ -42,9 +45,12 @@
 	    virtual void areaEntered(GameAreaEvent *anEvent);
 
 	private:
-		std::vector<Actor*> mLights;
-		std::vector<Ogre::String> mSounds;
+		std::list<Actor*> mLights;
+		std::list<Ogre::String> mSounds;
+		std::list<Trigger*> mTriggers;
 		Actor* mActor;
+
+		void deleteTriggers(const std::list<Trigger*>& toDelete);
 	};
 
 }

Modified: rl/trunk/engine/core/src/Zone.cpp
===================================================================
--- rl/trunk/engine/core/src/Zone.cpp	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/core/src/Zone.cpp	2007-05-02 23:44:19 UTC (rev 3379)
@@ -18,9 +18,9 @@
 #include "ActorManager.h"
 #include "GameAreaEvent.h"
 #include "GameEventManager.h"
+#include "Trigger.h"
 #include "ZoneManager.h"
 
-
 namespace rl 
 {
 
@@ -38,11 +38,35 @@
 	void Zone::areaLeft(GameAreaEvent *anEvent)
 	{
 		ZoneManager::getSingleton().areaLeft(this);
+
+		std::list<Trigger*> toDelete;
+		for (std::list<Trigger*>::iterator it = mTriggers.begin(); it != mTriggers.end(); ++it)
+		{
+			bool remove = (*it)->deactivate();
+			if (remove)
+			{
+				toDelete.push_back(*it);
+			}
+		}
+
+		deleteTriggers(toDelete);
 	}
 
     void Zone::areaEntered(GameAreaEvent *anEvent)
 	{		
 		ZoneManager::getSingleton().areaEntered(this);
+
+		std::list<Trigger*> toDelete;
+		for (std::list<Trigger*>::iterator it = mTriggers.begin(); it != mTriggers.end(); ++it)
+		{
+			bool remove = (*it)->activate();
+			if (remove)
+			{
+				toDelete.push_back(*it);
+			}
+		}
+
+		deleteTriggers(toDelete);
 	}
 
 	void Zone::addLight(Actor* lo)
@@ -61,16 +85,29 @@
 		}
 	}
 
-	std::vector<Actor*> Zone::getLights() const
+	std::list<Actor*> Zone::getLights() const
 	{
-		std::vector<Actor*> rval(mLights);
+		std::list<Actor*> rval(mLights);
 		return rval;
 	}
 	
-	std::vector<Ogre::String> Zone::getSounds() const
+	std::list<Ogre::String> Zone::getSounds() const
 	{
-		std::vector<Ogre::String> rval(mSounds);
+		std::list<Ogre::String> rval(mSounds);
 		return rval;
 	}
 
+
+	void Zone::deleteTriggers(const std::list<Trigger*>& toDelete)
+	{
+		for (std::list<Trigger*>::const_iterator it = toDelete.begin(); 
+			it != toDelete.end(); ++it)
+		{
+			const Trigger* cur = *it;
+
+			std::list<Trigger*>::iterator trigIt = 
+				std::find(mTriggers.begin(), mTriggers.end(), cur);
+			mTriggers.erase(trigIt);
+		}
+	}
 }

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2007-05-02 23:44:19 UTC (rev 3379)
@@ -94,8 +94,8 @@
 		Zone* currentZone = mActiveZones.front();
 		std::set<Actor*> activeLights;
 
-		std::vector<Actor*> curLights = currentZone->getLights();
-		for (std::vector<Actor*>::const_iterator it = curLights.begin(); it != curLights.end(); it++)
+		std::list<Actor*> curLights = currentZone->getLights();
+		for (std::list<Actor*>::const_iterator it = curLights.begin(); it != curLights.end(); it++)
 		{
 			activeLights.insert(*it);
 			(*it)->setVisible(true);
@@ -103,8 +103,8 @@
 
 		for (std::map<const Ogre::String, Zone*>::const_iterator itZones = mZones.begin(); itZones != mZones.end(); itZones++)
 		{
-			std::vector<Actor*> curLights = (*itZones).second->getLights();
-			for (std::vector<Actor*>::const_iterator itLights = curLights.begin(); itLights != curLights.end(); itLights++)
+			std::list<Actor*> curLights = (*itZones).second->getLights();
+			for (std::list<Actor*>::const_iterator itLights = curLights.begin(); itLights != curLights.end(); itLights++)
 			{
 				if (activeLights.find(*itLights) == activeLights.end())
 				{
@@ -113,8 +113,8 @@
 			}
 		}
 
-		std::vector<Actor*> defLights = mDefaultZone->getLights();
-		for (std::vector<Actor*>::const_iterator itLights = defLights.begin(); itLights != defLights.end(); itLights++)
+		std::list<Actor*> defLights = mDefaultZone->getLights();
+		for (std::list<Actor*>::const_iterator itLights = defLights.begin(); itLights != defLights.end(); itLights++)
 		{
 			if (activeLights.find(*itLights) == activeLights.end())
 			{
@@ -128,8 +128,8 @@
 		Zone* currentZone = mActiveZones.front();
 		std::set<Ogre::String> activeSounds;
 
-		std::vector<Ogre::String> curSounds = currentZone->getSounds();
-		for (std::vector<Ogre::String>::const_iterator it = curSounds.begin(); it != curSounds.end(); it++)
+		std::list<Ogre::String> curSounds = currentZone->getSounds();
+		for (std::list<Ogre::String>::const_iterator it = curSounds.begin(); it != curSounds.end(); it++)
 		{
 			activeSounds.insert(*it);
 			///@todo switch sound on
@@ -137,8 +137,8 @@
 
 		for (std::map<const Ogre::String, Zone*>::const_iterator itZones = mZones.begin(); itZones != mZones.end(); itZones++)
 		{
-			std::vector<Ogre::String> curSounds = (*itZones).second->getSounds();
-			for (std::vector<Ogre::String>::const_iterator itSounds = curSounds.begin(); itSounds != curSounds.end(); itSounds++)
+			std::list<Ogre::String> curSounds = (*itZones).second->getSounds();
+			for (std::list<Ogre::String>::const_iterator itSounds = curSounds.begin(); itSounds != curSounds.end(); itSounds++)
 			{
 				if (activeSounds.find(*itSounds) == activeSounds.end())
 				{
@@ -147,8 +147,8 @@
 			}
 		}
 
-		std::vector<Ogre::String> defSounds = mDefaultZone->getSounds();
-		for (std::vector<Ogre::String>::const_iterator itSounds = defSounds.begin(); itSounds != defSounds.end(); itSounds++)
+		std::list<Ogre::String> defSounds = mDefaultZone->getSounds();
+		for (std::list<Ogre::String>::const_iterator itSounds = defSounds.begin(); itSounds != defSounds.end(); itSounds++)
 		{
 			if (activeSounds.find(*itSounds) == activeSounds.end())
 			{

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2007-05-02 23:44:19 UTC (rev 3379)
@@ -309,6 +309,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\ParticleSystemNodeProcessor.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\SoundNodeProcessor.cpp"
 					>
 				</File>
@@ -331,6 +335,10 @@
 				RelativePath=".\include\ScriptSubsystem.h"
 				>
 			</File>
+			<File
+				RelativePath=".\include\TriggerFactory.h"
+				>
+			</File>
 			<Filter
 				Name="map loading"
 				>
@@ -355,6 +363,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\ParticleSystemNodeProcessor.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\SoundNodeProcessor.h"
 					>
 				</File>

Added: rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2007-05-02 23:44:19 UTC (rev 3379)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __ParticleSystemNodeProcessor_H__
+#define __ParticleSystemNodeProcessor_H__
+
+#include <xercesc/dom/DOMElement.hpp>
+
+#include "ScriptPrerequisites.h"
+#include "AbstractMapNodeProcessor.h"
+
+
+namespace rl
+{
+    class ParticleSystemNodeProcessor : public AbstractMapNodeProcessor
+    {
+    public:
+        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+    };
+}
+
+#endif // __ParticleSystemNodeProcessor_H__

Modified: rl/trunk/engine/script/include/ScriptSubsystem.h
===================================================================
--- rl/trunk/engine/script/include/ScriptSubsystem.h	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/include/ScriptSubsystem.h	2007-05-02 23:44:19 UTC (rev 3379)
@@ -20,7 +20,9 @@
 #include "ScriptPrerequisites.h"
 #include "OgreSingleton.h"
 
-namespace rl {
+namespace rl 
+{
+	class TriggerFactory;
     class ScriptObjectMarker;
 
     class _RlScriptExport ScriptSubsystem : public Ogre::Singleton<ScriptSubsystem>
@@ -30,9 +32,13 @@
         virtual ~ScriptSubsystem();
 
         void log(const CeGuiString& message);
+		void setTriggerFactory(TriggerFactory* factory);
+		TriggerFactory* getTriggerFactory() const;
 
     private:
         ScriptObjectMarker* mScriptObjectMarker;
+		TriggerFactory* mTriggerFactory;
+
         void initializeScriptSubsystem();
     };
 }

Added: rl/trunk/engine/script/include/TriggerFactory.h
===================================================================
--- rl/trunk/engine/script/include/TriggerFactory.h	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/include/TriggerFactory.h	2007-05-02 23:44:19 UTC (rev 3379)
@@ -0,0 +1,32 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __TriggerFactory_H__
+#define __TriggerFactory_H__
+
+#include "ScriptPrerequisites.h"
+
+namespace rl 
+{
+	class Trigger;
+
+	class _RlScriptExport TriggerFactory
+	{
+	public:
+		virtual Trigger* createTrigger(const Ogre::String& classname) = 0;
+	};
+}
+
+#endif // __TriggerFactory_H__

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2007-05-02 23:44:19 UTC (rev 3379)
@@ -30,9 +30,13 @@
 #include "GameObjectConstants.h"
 #include "GameObjectNodeProcessor.h"
 #include "LightNodeProcessor.h"
+#include "ParticleSystemNodeProcessor.h"
 #include "ProgressWindow.h"
 #include "PropertyReader.h"
+#include "ScriptSubsystem.h"
 #include "SoundNodeProcessor.h"
+#include "Trigger.h"
+#include "TriggerFactory.h"
 #include "World.h"
 #include "XmlHelper.h"
 #include "XmlResource.h"
@@ -59,6 +63,7 @@
         mNodeProcessors.push_back(new GameObjectNodeProcessor());
         mNodeProcessors.push_back(new SoundNodeProcessor());
         mNodeProcessors.push_back(new LightNodeProcessor());
+		mNodeProcessors.push_back(new ParticleSystemNodeProcessor());
     }
 
     MapLoader::~MapLoader()
@@ -106,6 +111,7 @@
             DOMElement* dataDocumentContent = doc->getDocumentElement();
             
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
+			///@todo: Window jobs don't work if Core is paused, think about solution 
 			CoreSubsystem::getSingleton().setPaused(true);
             
             LOG_MESSAGE(Logger::RULES, "Processing nodes");
@@ -119,6 +125,7 @@
             doc->release();
 
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
+			///@todo: Window jobs don't work if Core is paused, think about solution 
 			CoreSubsystem::getSingleton().setPaused(false);
         }
         else
@@ -168,6 +175,8 @@
                     Ogre::StringConverter::toString(count/numChildren*100.0f, 0) + "%");
             }
         }
+
+		setLoadingPercentage(1);
     }
 
 	void MapLoader::processZones(xercesc_2_7::DOMElement *zonesElem)
@@ -234,6 +243,16 @@
 									Ogre::String name = XmlHelper::getAttributeValueAsStdString(curElem, "name");
 									zone->addSound(name);
 								}
+								else if (XmlHelper::hasNodeName(curElem, "trigger"))
+								{
+									Ogre::String classname = 
+										XmlHelper::getAttributeValueAsStdString(curElem, "classname");
+
+									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
+										->createTrigger(classname);
+
+									///@todo trigger properties
+								}
 							}
 						}
 					}
@@ -336,7 +355,7 @@
 
         CoreSubsystem::getSingleton().renderOneFrame();
 
-        if (percentage >= 0.99)
+        if (percentage == 1)
         {
             mPercentageWindow->setVisible(false, true);
             mPercentageWindow = NULL;

Added: rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2007-05-02 23:44:19 UTC (rev 3379)
@@ -0,0 +1,55 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "ParticleSystemNodeProcessor.h"
+
+#include "XmlHelper.h"
+
+#include "Actor.h"
+#include "ActorManager.h"
+#include "ParticleSystemObject.h"
+
+using namespace Ogre;
+using namespace XERCES_CPP_NAMESPACE;
+
+namespace rl
+{
+    bool ParticleSystemNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    {
+		if (!XmlHelper::hasNodeName(nodeElem, "particlesystem"))
+		{
+			return false;
+		}
+
+		LOG_DEBUG(Logger::RULES, 
+            "Processing particle system node " 
+                + XmlHelper::getAttributeValueAsStdString(nodeElem, "name"));
+
+		if (XmlHelper::hasAttribute(nodeElem, "name") && XmlHelper::hasAttribute(nodeElem, "material"))
+		{
+			Ogre::String name = XmlHelper::getAttributeValueAsStdString(nodeElem, "name");
+			Ogre::String material = XmlHelper::getAttributeValueAsStdString(nodeElem, "material");
+
+			Actor* part = ActorManager::getSingleton().createParticleSystemActor(
+				name, material);
+
+			if (XmlHelper::hasAttribute(nodeElem, "active"))
+			{
+				bool active = XmlHelper::getAttributeValueAsBool(nodeElem, "active");
+				static_cast<ParticleSystemObject*>(part->getControlledObject())->setActive(active);
+			}
+		}
+	}
+}

Modified: rl/trunk/engine/script/src/ScriptSubsystem.cpp
===================================================================
--- rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-05-02 23:44:19 UTC (rev 3379)
@@ -24,7 +24,8 @@
 
 namespace rl {
 
-    ScriptSubsystem::ScriptSubsystem() : mScriptObjectMarker(NULL)
+    ScriptSubsystem::ScriptSubsystem()
+		: mScriptObjectMarker(NULL), mTriggerFactory(NULL)
     {
         mScriptObjectMarker = new ScriptObjectMarker();	
     }
@@ -39,4 +40,14 @@
         LOG_MESSAGE(Logger::SCRIPT, message);
     }
 
+	TriggerFactory* ScriptSubsystem::getTriggerFactory() const
+	{
+		return mTriggerFactory;
+	}
+
+	void ScriptSubsystem::setTriggerFactory(TriggerFactory* factory)
+	{
+		mTriggerFactory = factory;
+	}
+
 }

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-05-02 23:44:19 UTC (rev 3379)
@@ -44,6 +44,7 @@
 #include "MeshAnimation.h"
 #include "FadeAnimation.h"
 #include "TrackAnimation.h"
+#include "Trigger.h"
 #include "GameLoop.h"
 #include "World.h"
 #include "ContentModule.h"

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-05-02 23:44:19 UTC (rev 3379)
@@ -870,5 +870,15 @@
 	Zone* getZone(const Ogre::String& name) const;
 };
 
+class  Trigger
+{
+public:
+	virtual bool activate() = 0;
+	virtual bool deactivate() = 0;
+	virtual const rl::Property getProperty(const Ogre::String& key) const = 0;
+    virtual void setProperty(const Ogre::String& key, const rl::Property& value) = 0;
+    virtual rl::PropertySet* getAllProperties() const = 0;
+    virtual void setProperties(const rl::PropertySet* props);
+};
 
 }

Modified: rl/trunk/engine/script/swig/RlScript.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.head.swig	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/swig/RlScript.head.swig	2007-05-02 23:44:19 UTC (rev 3379)
@@ -18,4 +18,5 @@
 //----------- Includes - Script -----------
 #include "MapLoader.h"
 #include "ScriptSubsystem.h"
+#include "TriggerFactory.h"
 %}
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlScript.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.swig	2007-05-02 19:06:34 UTC (rev 3378)
+++ rl/trunk/engine/script/swig/RlScript.swig	2007-05-02 23:44:19 UTC (rev 3379)
@@ -14,13 +14,15 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
-namespace rl {
+namespace rl 
+{
 	class ScriptSubsystem
 	{
 	public:
 		static rl::ScriptSubsystem& getSingleton();
 
 		void log(const rl::CeGuiString& message);
+		void setTriggerFactory(rl::TriggerFactory* factory);
 	};
 	  
     class MapLoader
@@ -29,4 +31,10 @@
         MapLoader(const Ogre::String& resourceGroup);
         void loadMap(const Ogre::String& mapresource, bool loadGameObjects = true);
     };
+    
+    class TriggerFactory
+	{
+	public:
+		virtual rl::Trigger* createTrigger(const Ogre::String& classname) = 0;
+	};
 }
\ No newline at end of file



From blakharaz at mail.berlios.de  Thu May  3 12:32:01 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 3 May 2007 12:32:01 +0200
Subject: [Dsa-hl-svn] r3380 - rl/branches
Message-ID: <200705031032.l43AW1PA014653@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-03 12:32:00 +0200 (Thu, 03 May 2007)
New Revision: 3380

Removed:
   rl/branches/before_gameobject_system/
   rl/branches/old_inventory_window/
Log:
Removed branches (these were just backups of old states)



From blakharaz at mail.berlios.de  Thu May  3 21:46:29 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 3 May 2007 21:46:29 +0200
Subject: [Dsa-hl-svn] r3381 - modules/common/scripts
	rl/trunk/engine/script/swig
Message-ID: <200705031946.l43JkTHx013277@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-03 21:45:56 +0200 (Thu, 03 May 2007)
New Revision: 3381

Added:
   modules/common/scripts/initialize_factories.rb
Modified:
   modules/common/scripts/globals.rb
   rl/trunk/engine/script/swig/RlScript.swig
Log:
Fix TriggerFactory (has to be director and added a virtual dtor)

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-05-03 10:32:00 UTC (rev 3380)
+++ modules/common/scripts/globals.rb	2007-05-03 19:45:56 UTC (rev 3381)
@@ -37,44 +37,6 @@
 $hpw = HeroPosWriter.new()
 print "Aktuelle Spielerposition in Log schreiben mit '$hpw.writePos'"
 
-class RubyGameObjectFactory < GameObjectFactory
-  def initialize()
-    super();
-  end
-
-  def createRubyGameObject(classname, id)
-    return Module.const_get(classname).new(id);
-  end
-end
-
-rgof = RubyGameObjectFactory.new();
-$GOM.setGameObjectFactory(rgof);
-
 require 'steering.rb'
-
-class RubyBehaviourFactory < BehaviourFactory
-  def initialize()
-    super();
-  end
-
-  def createBehaviour(classname)
-    return Module.const_get(classname).new();
-  end
-end
-
-rbf = RubyBehaviourFactory.new();
-$AI.setBehaviourFactory(rbf);
-
-class RubyTriggerFactory < TriggerFactory
-  def initialize()
-    super();
-  end
-
-  def createTrigger(classname)
-    return Module.const_get(classname).new();
-  end
-end
-
-ScriptSubsystem.getSingleton().setTriggerFactory(RubyTriggerFactory.new())
-
-require( "questsound.rb" );
+require 'initialize_factories.rb'
+require "questsound.rb"

Added: modules/common/scripts/initialize_factories.rb
===================================================================
--- modules/common/scripts/initialize_factories.rb	2007-05-03 10:32:00 UTC (rev 3380)
+++ modules/common/scripts/initialize_factories.rb	2007-05-03 19:45:56 UTC (rev 3381)
@@ -0,0 +1,33 @@
+class RubyGameObjectFactory < GameObjectFactory
+  def initialize()
+    super();
+  end
+
+  def createRubyGameObject(classname, id)
+    return Module.const_get(classname).new(id);
+  end
+end
+
+class RubyBehaviourFactory < BehaviourFactory
+  def initialize()
+    super();
+  end
+
+  def createBehaviour(classname)
+    return Module.const_get(classname).new();
+  end
+end
+
+class RubyTriggerFactory < TriggerFactory
+  def initialize()
+    super();
+  end
+
+  def createTrigger(classname)
+    return Module.const_get(classname).new();
+  end
+end
+
+$GOM.setGameObjectFactory(RubyGameObjectFactory.new());
+$AI.setBehaviourFactory(RubyBehaviourFactory.new());
+$SCRIPT.setTriggerFactory(RubyTriggerFactory.new())

Modified: rl/trunk/engine/script/swig/RlScript.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.swig	2007-05-03 10:32:00 UTC (rev 3380)
+++ rl/trunk/engine/script/swig/RlScript.swig	2007-05-03 19:45:56 UTC (rev 3381)
@@ -31,10 +31,12 @@
         MapLoader(const Ogre::String& resourceGroup);
         void loadMap(const Ogre::String& mapresource, bool loadGameObjects = true);
     };
-    
+ 
+	%feature("director") TriggerFactory;    
     class TriggerFactory
 	{
 	public:
+		virtual ~TriggerFactory();
 		virtual rl::Trigger* createTrigger(const Ogre::String& classname) = 0;
 	};
 }
\ No newline at end of file



From blakharaz at mail.berlios.de  Thu May  3 23:17:48 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 3 May 2007 23:17:48 +0200
Subject: [Dsa-hl-svn] r3382 - rl/trunk/engine/script/include
Message-ID: <200705032117.l43LHmC7024537@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-03 23:17:43 +0200 (Thu, 03 May 2007)
New Revision: 3382

Modified:
   rl/trunk/engine/script/include/TriggerFactory.h
Log:
Fix TriggerFactory (has to be director and added a virtual dtor)

Modified: rl/trunk/engine/script/include/TriggerFactory.h
===================================================================
--- rl/trunk/engine/script/include/TriggerFactory.h	2007-05-03 19:45:56 UTC (rev 3381)
+++ rl/trunk/engine/script/include/TriggerFactory.h	2007-05-03 21:17:43 UTC (rev 3382)
@@ -25,6 +25,7 @@
 	class _RlScriptExport TriggerFactory
 	{
 	public:
+		virtual ~TriggerFactory() {}
 		virtual Trigger* createTrigger(const Ogre::String& classname) = 0;
 	};
 }



From blakharaz at mail.berlios.de  Thu May  3 23:21:16 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 3 May 2007 23:21:16 +0200
Subject: [Dsa-hl-svn] r3383 - in rl/trunk/engine/ai: . include src
Message-ID: <200705032121.l43LLGdB024722@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-03 23:21:02 +0200 (Thu, 03 May 2007)
New Revision: 3383

Added:
   rl/trunk/engine/ai/include/Landmark.h
   rl/trunk/engine/ai/include/LandmarkPath.h
   rl/trunk/engine/ai/src/Landmark.cpp
   rl/trunk/engine/ai/src/LandmarkPath.cpp
Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/WayPointNode.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
Log:
Introduced Landmark (named waypoint) and LandmarkPath (path of named waypoints)

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-05-03 21:21:02 UTC (rev 3383)
@@ -325,6 +325,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\Landmark.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\LandmarkPath.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\PhysicalObstacle.cpp"
 				>
 			</File>
@@ -403,6 +411,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\Landmark.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\LandmarkPath.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\PhysicalObstacle.h"
 				>
 			</File>

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-05-03 21:21:02 UTC (rev 3383)
@@ -24,9 +24,12 @@
 {
 	class Agent;
 	class AgentManager;
+	class AiWorld;
+	class Landmark;
+	class LandmarkPath;
 	class WayPointGraphManager;
-	class AiWorld;
 
+
 	/** Central core of AI
 	 * Handles creation of all AI related object Managers.
 	 */
@@ -50,10 +53,26 @@
 
 		/** Trigger function triggered after scene load.
 		 */
-		void onAfterSceneLoaded();
+		virtual void onAfterSceneLoaded();
+
 		/** Trigger function triggered before scene load.
 		 */
-        void onBeforeClearScene();
+        virtual void onBeforeClearScene();
+
+		/** Creates an named LandmarkPath.
+		 * @param name the path's name
+		 */
+		LandmarkPath* createLandmarkPath(const Ogre::String& name);
+
+		LandmarkPath* getLandmarkPath(const Ogre::String& name) const;
+
+		/** Creates an named Landmark.
+		 * @param name the landmark's name
+		 */
+		Landmark* createLandmark(const Ogre::String& name, const Ogre::Vector3& position);
+
+		Landmark* getLandmark(const Ogre::String& name) const;
+
 	private:
 		/** Initializes the AI subsystem.
 		 * Creates AiWorld and AgentManager, registers a scene listener,
@@ -61,12 +80,27 @@
 		 */
 		void initialize();
 
+		/** Removes all registered LandmarkPaths
+		 * Clears all internal lists and deallocates the memory of the 
+		 * stored objects.
+		 */
+		void removeAllLandmarkPaths();
+
+		/** Removes all registered Landmarkss
+		 * Clears all internal lists and deallocates the memory of the 
+		 * stored objects.
+		 */
+		void removeAllLandmarks();
+
 		//! single AgentManager object
 		AgentManager* mAgentManager;
 		//! single WayPointGraphManager object
 		WayPointGraphManager *mWayPointGraphManager;
 		//! AiWorld representation - WIP!!! (object to changes)
 		AiWorld* mWorld;
+
+		std::map<Ogre::String, LandmarkPath*> mLandmarkPaths;
+		std::map<Ogre::String, Landmark*> mLandmarks;
 	};
 
 	inline AiWorld* AiSubsystem::getWorld()

Added: rl/trunk/engine/ai/include/Landmark.h
===================================================================
--- rl/trunk/engine/ai/include/Landmark.h	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/include/Landmark.h	2007-05-03 21:21:02 UTC (rev 3383)
@@ -0,0 +1,37 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __Landmark_H__
+#define __Landmark_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl
+{
+	class _RlAiExport Landmark
+	{
+	public:
+		Landmark(const Ogre::String& name, const Ogre::Vector3& position);
+		
+		const Ogre::String& getName() const;
+		const Ogre::Vector3& getPosition() const;
+
+	private:
+		Ogre::String mName;
+		Ogre::Vector3 mPosition;
+	};
+}
+
+#endif //__Landmark_H__

Added: rl/trunk/engine/ai/include/LandmarkPath.h
===================================================================
--- rl/trunk/engine/ai/include/LandmarkPath.h	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/include/LandmarkPath.h	2007-05-03 21:21:02 UTC (rev 3383)
@@ -0,0 +1,40 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#ifndef __LandmarkPath_H__
+#define __LandmarkPath_H__
+
+#include "AiPrerequisites.h"
+
+namespace rl
+{
+	class Landmark;
+
+	class _RlAiExport LandmarkPath
+	{
+	public:
+		LandmarkPath(const Ogre::String& name);
+		~LandmarkPath();
+
+		void addPoint(const Ogre::String& name, const Ogre::Vector3& position);
+		void addPoint(Landmark* lm);
+
+	private:
+		std::list<Landmark*> mPoints;
+		Ogre::String mName;
+	};
+}
+
+#endif //__LandmarkPath_H__

Modified: rl/trunk/engine/ai/include/WayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointNode.h	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/include/WayPointNode.h	2007-05-03 21:21:02 UTC (rev 3383)
@@ -17,7 +17,6 @@
 #define __RlAI_WayPointNode_H__
 
 #include "AiPrerequisites.h"
-#include "OgreVector3.h"
 
 namespace rl
 {

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-05-03 21:21:02 UTC (rev 3383)
@@ -14,12 +14,15 @@
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
 #include "AiSubsystem.h"
+
 #include "AiWorld.h"
 #include "AgentManager.h"
+#include "CoreSubsystem.h"
+#include "GameLoop.h"
+#include "Landmark.h"
+#include "LandmarkPath.h"
+#include "Logger.h"
 #include "WayPointGraphManager.h"
-#include "Logger.h"
-#include "GameLoop.h"
-#include "CoreSubsystem.h"
 #include "World.h"
 
 using namespace Ogre;
@@ -45,6 +48,8 @@
 	GameLoop::getSingleton().removeTask(AgentManager::getSingletonPtr());
     AgentManager::getSingleton().removeAllAgents();
     mWorld->removeAllObstacles();
+	removeAllLandmarkPaths();
+	removeAllLandmarks();
     delete mAgentManager;
 	delete mWayPointGraphManager;
     delete mWorld;
@@ -95,4 +100,63 @@
 */
 }
 
+Landmark* AiSubsystem::createLandmark(const Ogre::String& name, const Ogre::Vector3& position)
+{
+	Landmark* lm = new Landmark(name, position);
+	mLandmarks[name] = lm;
+	return lm;
 }
+
+Landmark* AiSubsystem::getLandmark(const Ogre::String& name) const
+{
+	std::map<Ogre::String, Landmark*>::const_iterator it = mLandmarks.find(name);
+
+	if (it == mLandmarks.end())
+	{
+		return NULL;
+	}
+	return (*it).second;
+}
+
+LandmarkPath* AiSubsystem::createLandmarkPath(const Ogre::String& name)
+{
+	LandmarkPath* path = new LandmarkPath(name);
+	mLandmarkPaths[name] = path;
+	return path;
+}
+
+LandmarkPath* AiSubsystem::getLandmarkPath(const Ogre::String& name) const
+{
+	std::map<Ogre::String, LandmarkPath*>::const_iterator it = mLandmarkPaths.find(name);
+
+	if (it == mLandmarkPaths.end())
+	{
+		return NULL;
+	}
+	return (*it).second;
+}
+
+void AiSubsystem::removeAllLandmarkPaths()
+{
+	for (std::map<Ogre::String, LandmarkPath*>::iterator it = mLandmarkPaths.begin(); 
+		it != mLandmarkPaths.end(); it++)
+	{
+		delete (*it).second;
+	}
+
+	mLandmarkPaths.clear();
+}
+
+void AiSubsystem::removeAllLandmarks()
+{
+	for (std::map<Ogre::String, Landmark*>::iterator it = mLandmarks.begin(); 
+		it != mLandmarks.end(); it++)
+	{
+		delete (*it).second;
+	}
+
+	mLandmarks.clear();
+}
+
+
+}

Added: rl/trunk/engine/ai/src/Landmark.cpp
===================================================================
--- rl/trunk/engine/ai/src/Landmark.cpp	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/src/Landmark.cpp	2007-05-03 21:21:02 UTC (rev 3383)
@@ -0,0 +1,24 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "Landmark.h"
+
+namespace rl
+{
+	Landmark::Landmark(const Ogre::String &name, const Ogre::Vector3 &position)
+		: mName(name), mPosition(position)
+	{
+	}
+}

Added: rl/trunk/engine/ai/src/LandmarkPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-05-03 21:17:43 UTC (rev 3382)
+++ rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-05-03 21:21:02 UTC (rev 3383)
@@ -0,0 +1,41 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "LandmarkPath.h"
+
+#include "AiSubsystem.h"
+
+namespace rl
+{
+	LandmarkPath::LandmarkPath(const Ogre::String& name)
+		: mName(name)
+	{
+	}
+
+	LandmarkPath::~LandmarkPath()
+	{
+		mPoints.clear();
+	}
+
+	void LandmarkPath::addPoint(const Ogre::String &name, const Ogre::Vector3 &position)
+	{
+		addPoint(AiSubsystem::getSingleton().createLandmark(name, position));
+	}
+
+	void LandmarkPath::addPoint(Landmark *lm)
+	{
+		mPoints.push_back(lm);
+	}
+}



From blakharaz at mail.berlios.de  Thu May  3 23:23:37 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 3 May 2007 23:23:37 +0200
Subject: [Dsa-hl-svn] r3384 - in rl/trunk: docs/documents engine/script
	engine/script/include engine/script/src
Message-ID: <200705032123.l43LNb71025013@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-03 23:23:27 +0200 (Thu, 03 May 2007)
New Revision: 3384

Added:
   rl/trunk/engine/script/include/EnvironmentProcessor.h
   rl/trunk/engine/script/include/WaypointProcessor.h
   rl/trunk/engine/script/include/ZoneProcessor.h
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
   rl/trunk/engine/script/src/WaypointProcessor.cpp
   rl/trunk/engine/script/src/ZoneProcessor.cpp
Modified:
   rl/trunk/docs/documents/scene_format_proposal.xml
   rl/trunk/engine/script/RlScript2005.vcproj
   rl/trunk/engine/script/include/MapLoader.h
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
Log:
* Adaptation to map format change
* Split up MapLoader in different classes
* Load particle systems, landmarks, landmark paths

Modified: rl/trunk/docs/documents/scene_format_proposal.xml
===================================================================
--- rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-03 21:23:27 UTC (rev 3384)
@@ -108,16 +108,16 @@
 	<!-- Waypoints -->
 	<waypoints>
 
-		<waypoint name="temple entrance">
+		<landmark name="temple entrance">
 			<position x="5.7285" y="-7.94034" z="18.4169" />
-		</waypoint>
+		</landmark>
 
-		<waypointlist name="bauerrogalfsbetrunkenerheimweg" >
-			<waypoint name="kneipe" />
-			<waypoint name="kirche" />
-			<waypoint name="feldweg" />
-			<waypoint name="graben" />
-		</waypointlist>
+		<landmarkpath name="bauerrogalfsbetrunkenerheimweg" >
+			<landmark name="kneipe" />
+			<landmark name="kirche" />
+			<landmark name="feldweg" />
+			<landmark name="graben" />
+		</landmarkpath>
 
 	</waypoints>
 
@@ -155,7 +155,7 @@
 			<center x="141.95" y="7.20" z="32.55" />
 
 			<!-- Name of the ruby class, an instance will be created -->
-			<trigger classname="DoomsDayDevice" > 
+			<trigger classname="DoomsDayDevice" >
 				<!-- Parameters are properties -->
 				<property name="message" type="STRING" data="You triggered the dooms day device!" />
 			</trigger>
@@ -167,7 +167,7 @@
         <environment>
         	<!-- Sky Box -->
         	<sky type="box" material="ruchinsky" drawfirst="true" distance="600"/>
-        
+
         	<!-- Sky Dome -->
         	<sky type="dome" material="ruchinsky" drawfirst="true">
         		<skydomesettings curvature="10" tiling = "8" />

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2007-05-03 21:23:27 UTC (rev 3384)
@@ -297,6 +297,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\EnvironmentProcessor.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\GameObjectNodeProcessor.cpp"
 					>
 				</File>
@@ -316,6 +320,14 @@
 					RelativePath=".\src\SoundNodeProcessor.cpp"
 					>
 				</File>
+				<File
+					RelativePath=".\src\WaypointProcessor.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\ZoneProcessor.cpp"
+					>
+				</File>
 			</Filter>
 		</Filter>
 		<Filter
@@ -351,6 +363,37 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\EnvironmentProcessor.h"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release with Symbols|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+				</File>
+				<File
 					RelativePath=".\include\GameObjectNodeProcessor.h"
 					>
 				</File>
@@ -370,6 +413,41 @@
 					RelativePath=".\include\SoundNodeProcessor.h"
 					>
 				</File>
+				<File
+					RelativePath=".\include\WaypointProcessor.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\ZoneProcessor.h"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release with Symbols|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"
+							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+						/>
+					</FileConfiguration>
+				</File>
 			</Filter>
 		</Filter>
 		<Filter

Added: rl/trunk/engine/script/include/EnvironmentProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EnvironmentProcessor.h	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/include/EnvironmentProcessor.h	2007-05-03 21:23:27 UTC (rev 3384)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __EnvironmentProcessor_H__
+#define __EnvironmentProcessor_H__
+
+#include "ScriptPrerequisites.h"
+
+#include "AbstractMapNodeProcessor.h"
+
+namespace rl
+{
+	class EnvironmentProcessor : private AbstractMapNodeProcessor
+	{
+	public:
+		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+		void processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem);
+		void processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem);
+	};
+}
+
+#endif //__EnvironmentProcessor_H__

Modified: rl/trunk/engine/script/include/MapLoader.h
===================================================================
--- rl/trunk/engine/script/include/MapLoader.h	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/include/MapLoader.h	2007-05-03 21:23:27 UTC (rev 3384)
@@ -53,8 +53,6 @@
 
         void setRootSceneNode(Ogre::SceneNode* node);
         void processSceneNodes(XERCES_CPP_NAMESPACE::DOMElement* nodesElem, bool loadGameObjects);
-        void processZones(XERCES_CPP_NAMESPACE::DOMElement* zonesElem);
-		void processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* skyElem);
         void setLoadingPercentage(Ogre::Real percentage, const Ogre::String& text = "");
     };
 

Added: rl/trunk/engine/script/include/WaypointProcessor.h
===================================================================
--- rl/trunk/engine/script/include/WaypointProcessor.h	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/include/WaypointProcessor.h	2007-05-03 21:23:27 UTC (rev 3384)
@@ -0,0 +1,32 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __WaypointProcessor_H__
+#define __WaypointProcessor_H__
+
+#include "ScriptPrerequisites.h"
+
+#include "AbstractMapNodeProcessor.h"
+
+namespace rl
+{
+	class WaypointProcessor : private AbstractMapNodeProcessor
+	{
+	public:
+		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+	};
+}
+
+#endif //__WaypointProcessor_H__
\ No newline at end of file

Added: rl/trunk/engine/script/include/ZoneProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ZoneProcessor.h	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/include/ZoneProcessor.h	2007-05-03 21:23:27 UTC (rev 3384)
@@ -0,0 +1,32 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __ZoneProcessor_H__
+#define __ZoneProcessor_H__
+
+#include "ScriptPrerequisites.h"
+
+#include "AbstractMapNodeProcessor.h"
+
+namespace rl
+{
+	class ZoneProcessor : private AbstractMapNodeProcessor
+	{
+	public:
+		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+	};
+}
+
+#endif //__ZoneNodeProcessor_H__
\ No newline at end of file

Added: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-05-03 21:23:27 UTC (rev 3384)
@@ -0,0 +1,109 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "EnvironmentProcessor.h"
+
+#include "CoreSubsystem.h"
+#include "World.h"
+#include "XmlHelper.h"
+
+using namespace XERCES_CPP_NAMESPACE;
+using namespace Ogre;
+
+
+namespace rl
+{
+	bool EnvironmentProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+	{
+		if (nodeElem == NULL)
+		{
+			return false;
+		}
+
+		processSkySettings(XmlHelper::getChildNamed(nodeElem, "sky"));
+		processFogSettings(XmlHelper::getChildNamed(nodeElem, "fog"));
+
+		return true;
+	}
+
+
+	void EnvironmentProcessor::processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* skyElem)
+	{
+        if (skyElem == NULL)
+		{
+			return;
+		}
+
+		if (!XmlHelper::hasAttribute(skyElem, "material") 
+			|| !XmlHelper::hasAttribute(skyElem, "type"))
+		{
+			LOG_ERROR(Logger::RULES, "<sky> element must have at least attributes 'type' and 'material'.");
+		}
+		else
+		{
+			Ogre::String type = XmlHelper::getAttributeValueAsStdString(skyElem, "type");
+			Ogre::String material = XmlHelper::getAttributeValueAsStdString(skyElem, "material");
+
+			bool drawFirst = true;
+			if (XmlHelper::hasAttribute(skyElem, "drawfirst"))
+			{
+				drawFirst = XmlHelper::getAttributeValueAsBool(skyElem, "drawfirst");
+			}
+			
+			Ogre::Real distance = 5000;
+			if (XmlHelper::hasAttribute(skyElem, "distance"))
+			{
+				distance = XmlHelper::getAttributeValueAsReal(skyElem, "distance");
+			}				
+
+			if (type == "dome")
+			{
+				Ogre::Real curvature = 10;
+				Ogre::Real tiling = 8;
+
+				DOMElement* domeSettings = XmlHelper::getChildNamed(skyElem, "skydomesettings");
+				if (domeSettings != NULL)
+				{
+					if (XmlHelper::hasAttribute(domeSettings, "curvature"))
+					{
+						curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "curvature");
+					}
+					if (XmlHelper::hasAttribute(domeSettings, "tiling"))
+					{
+						curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "tiling");
+					}
+				}
+				CoreSubsystem::getSingleton().getWorld()->setSkyDome(
+					true, material, curvature, tiling, distance, drawFirst);
+			}
+			else if (type == "box")
+			{
+				CoreSubsystem::getSingleton().getWorld()->setSkyBox(true, material, distance, drawFirst);
+			}
+			else if (type == "plane")
+			{
+				LOG_ERROR(Logger::RULES, "Sky Plane is not implemented yet.");
+			}
+		}
+	}
+
+
+	void EnvironmentProcessor::processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem)
+	{
+		///@todo process fog node
+	}
+
+}

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2007-05-03 21:23:27 UTC (rev 3384)
@@ -22,27 +22,21 @@
 #include <OgreResourceManager.h>
 
 #include "AbstractMapNodeProcessor.h"
-#include "Actor.h"
-#include "ActorManager.h"
-#include "ContentModule.h"
 #include "CoreSubsystem.h"
 #include "EntityNodeProcessor.h"
-#include "GameObjectConstants.h"
+#include "EnvironmentProcessor.h"
 #include "GameObjectNodeProcessor.h"
 #include "LightNodeProcessor.h"
 #include "ParticleSystemNodeProcessor.h"
 #include "ProgressWindow.h"
 #include "PropertyReader.h"
-#include "ScriptSubsystem.h"
 #include "SoundNodeProcessor.h"
-#include "Trigger.h"
-#include "TriggerFactory.h"
+#include "WaypointProcessor.h"
 #include "World.h"
 #include "XmlHelper.h"
 #include "XmlResource.h"
 #include "XmlResourceManager.h"
-#include "Zone.h"
-#include "ZoneManager.h"
+#include "ZoneProcessor.h"
 
 using namespace Ogre;
 using namespace XERCES_CPP_NAMESPACE;
@@ -111,22 +105,27 @@
             DOMElement* dataDocumentContent = doc->getDocumentElement();
             
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
-			///@todo: Window jobs don't work if Core is paused, think about solution 
-			CoreSubsystem::getSingleton().setPaused(true);
+			///@todo: Window fade jobs don't work if Core is paused, think about solution for: CoreSubsystem::getSingleton().setPaused(true);
             
             LOG_MESSAGE(Logger::RULES, "Processing nodes");
             
             processSceneNodes(XmlHelper::getChildNamed(dataDocumentContent, "nodes"), loadGameObjects);
-            processZones(XmlHelper::getChildNamed(dataDocumentContent, "zones"));
-            processSkySettings(XmlHelper::getChildNamed(dataDocumentContent, "sky"));
             
+			ZoneProcessor zp;
+			zp.processNode(XmlHelper::getChildNamed(dataDocumentContent, "zones"), loadGameObjects);
+			
+			EnvironmentProcessor ep;
+			ep.processNode(XmlHelper::getChildNamed(dataDocumentContent, "environment"), loadGameObjects);
+            
+			WaypointProcessor wp;
+			wp.processNode(XmlHelper::getChildNamed(dataDocumentContent, "waypoints"), loadGameObjects);
+            
             LOG_MESSAGE(Logger::RULES, "Map loaded");
     
             doc->release();
 
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
-			///@todo: Window jobs don't work if Core is paused, think about solution 
-			CoreSubsystem::getSingleton().setPaused(false);
+			///@todo: Window fade jobs don't work if Core is paused, think about solution for: CoreSubsystem::getSingleton().setPaused(false);
         }
         else
         {
@@ -179,156 +178,6 @@
 		setLoadingPercentage(1);
     }
 
-	void MapLoader::processZones(xercesc_2_7::DOMElement *zonesElem)
-	{
-		if (zonesElem == NULL)
-		{
-			return; // no zones
-		}
-
-        for (DOMNode* cur = zonesElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE
-				&& XmlHelper::hasNodeName(cur, "zone"))
-            {
-				DOMElement* curZoneElem = static_cast<DOMElement*>(cur);
-				if (XmlHelper::hasAttribute(curZoneElem, "type"))
-				{
-					Ogre::String type = XmlHelper::getAttributeValueAsStdString(curZoneElem, "type");
-					Zone* zone = NULL;
-					if (type == "default")
-					{
-						zone = ZoneManager::getSingleton().getDefaultZone();
-					}
-					else if (type == "mesh")
-					{
-						///@todo: zone = ZoneManager::getSingleton().createZone(...);
-					}
-					else if (type == "sphere")
-					{						
-						Vector3 center = Vector3::ZERO;
-						DOMElement* centerElem = XmlHelper::getChildNamed(curZoneElem, "center");
-						if (centerElem != NULL)
-						{
-							center = XmlHelper::getValueAsVector3(centerElem);
-						}
-
-						Real radius = 1;
-						DOMElement* radiusElem = XmlHelper::getChildNamed(curZoneElem, "radius");
-						if (radiusElem != NULL)
-						{
-							radius = XmlHelper::getAttributeValueAsReal(radiusElem, "r");
-						}
-
-						Ogre::String name = XmlHelper::getAttributeValueAsStdString(curZoneElem, "name");
-
-						zone = ZoneManager::getSingleton().createZone(
-							name, center, radius, QUERYFLAG_PLAYER);
-					}
-
-					if (zone != NULL)
-					{
-						for (DOMNode* cur = curZoneElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-						{
-							if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-							{
-								DOMElement* curElem = static_cast<DOMElement*>(cur);
-								if (XmlHelper::hasNodeName(curElem, "light"))
-								{
-									Ogre::String name = XmlHelper::getAttributeValueAsStdString(curElem, "name");
-									zone->addLight(ActorManager::getSingleton().getActor(name));
-								}
-								else if (XmlHelper::hasNodeName(curElem, "sound"))
-								{
-									Ogre::String name = XmlHelper::getAttributeValueAsStdString(curElem, "name");
-									zone->addSound(name);
-								}
-								else if (XmlHelper::hasNodeName(curElem, "trigger"))
-								{
-									Ogre::String classname = 
-										XmlHelper::getAttributeValueAsStdString(curElem, "classname");
-
-									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
-										->createTrigger(classname);
-
-									///@todo trigger properties
-								}
-							}
-						}
-					}
-					else
-					{
-						LOG_ERROR(Logger::RULES, "Zone of type '"+type+"' could not be processes.");
-					}
-				}
-				else
-				{
-					LOG_ERROR(Logger::RULES, "<zone> element must have attribute 'type'.");
-				}
-			}
-		}
-	}
-
-	void MapLoader::processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* skyElem)
-	{
-        if (skyElem == NULL)
-		{
-			return;
-		}
-
-		if (!XmlHelper::hasAttribute(skyElem, "material") 
-			|| !XmlHelper::hasAttribute(skyElem, "type"))
-		{
-			LOG_ERROR(Logger::RULES, "<sky> element must have at least attributes 'type' and 'material'.");
-		}
-		else
-		{
-			Ogre::String type = XmlHelper::getAttributeValueAsStdString(skyElem, "type");
-			Ogre::String material = XmlHelper::getAttributeValueAsStdString(skyElem, "material");
-
-			bool drawFirst = true;
-			if (XmlHelper::hasAttribute(skyElem, "drawfirst"))
-			{
-				drawFirst = XmlHelper::getAttributeValueAsBool(skyElem, "drawfirst");
-			}
-			
-			Ogre::Real distance = 5000;
-			if (XmlHelper::hasAttribute(skyElem, "distance"))
-			{
-				drawFirst = XmlHelper::getAttributeValueAsBool(skyElem, "distance");
-			}				
-
-			if (type == "dome")
-			{
-				Ogre::Real curvature = 10;
-				Ogre::Real tiling = 8;
-
-				DOMElement* domeSettings = XmlHelper::getChildNamed(skyElem, "skydomesettings");
-				if (domeSettings != NULL)
-				{
-					if (XmlHelper::hasAttribute(domeSettings, "curvature"))
-					{
-						curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "curvature");
-					}
-					if (XmlHelper::hasAttribute(domeSettings, "tiling"))
-					{
-						curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "tiling");
-					}
-				}
-				CoreSubsystem::getSingleton().getWorld()->setSkyDome(
-					true, material, curvature, tiling, distance, drawFirst);
-			}
-			else if (type == "box")
-			{
-				CoreSubsystem::getSingleton().getWorld()->setSkyBox(true, material, distance, drawFirst);
-			}
-			else if (type == "plane")
-			{
-				LOG_ERROR(Logger::RULES, "Sky Plane is not implemented yet.");
-			}
-		}
-	}
-
     void MapLoader::setRootSceneNode(SceneNode* node)
     {
         mRootSceneNode = node;

Modified: rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2007-05-03 21:23:27 UTC (rev 3384)
@@ -33,23 +33,28 @@
 			return false;
 		}
 
-		LOG_DEBUG(Logger::RULES, 
-            "Processing particle system node " 
-                + XmlHelper::getAttributeValueAsStdString(nodeElem, "name"));
-
-		if (XmlHelper::hasAttribute(nodeElem, "name") && XmlHelper::hasAttribute(nodeElem, "material"))
+		if (!XmlHelper::hasAttribute(nodeElem, "material"))
 		{
-			Ogre::String name = XmlHelper::getAttributeValueAsStdString(nodeElem, "name");
-			Ogre::String material = XmlHelper::getAttributeValueAsStdString(nodeElem, "material");
+			LOG_WARNING(Logger::SCRIPT, "Particle system nodes must at least have the attribute 'material'.");
+			return false;
+		}
 
-			Actor* part = ActorManager::getSingleton().createParticleSystemActor(
-				name, material);
+		Ogre::String name = XmlHelper::getAttributeValueAsStdString(nodeElem, "name");
 
-			if (XmlHelper::hasAttribute(nodeElem, "active"))
-			{
-				bool active = XmlHelper::getAttributeValueAsBool(nodeElem, "active");
-				static_cast<ParticleSystemObject*>(part->getControlledObject())->setActive(active);
-			}
+		LOG_DEBUG(Logger::SCRIPT, 
+            "Processing particle system node " + name);
+
+		Ogre::String material = XmlHelper::getAttributeValueAsStdString(nodeElem, "material");
+
+		Actor* part = ActorManager::getSingleton().createParticleSystemActor(
+			name, material);
+
+		if (XmlHelper::hasAttribute(nodeElem, "active"))
+		{
+			bool active = XmlHelper::getAttributeValueAsBool(nodeElem, "active");
+			static_cast<ParticleSystemObject*>(part->getControlledObject())->setActive(active);
 		}
+
+		return true;
 	}
 }

Added: rl/trunk/engine/script/src/WaypointProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/WaypointProcessor.cpp	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/src/WaypointProcessor.cpp	2007-05-03 21:23:27 UTC (rev 3384)
@@ -0,0 +1,82 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "WaypointProcessor.h"
+
+#include "AiSubsystem.h"
+#include "Landmark.h"
+#include "LandmarkPath.h"
+#include "XmlHelper.h"
+
+using namespace XERCES_CPP_NAMESPACE;
+using namespace Ogre;
+
+namespace rl
+{
+	bool WaypointProcessor::processNode(DOMElement* nodeElem, bool loadGameObjects)
+	{
+		if (nodeElem == NULL)
+		{
+			return false;
+		}
+
+		for (DOMNode* cur = nodeElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+		{
+			if (cur->getNodeType() == DOMNode::ELEMENT_NODE && XmlHelper::hasNodeName(cur, "landmark"))
+			{
+				DOMElement* elem = static_cast<DOMElement*>(cur);
+				Ogre::String name = XmlHelper::getAttributeValueAsStdString(elem, "name");
+				DOMElement* posChild = XmlHelper::getChildNamed(elem, "position");
+				if (name != "" && posChild != NULL)
+				{
+					AiSubsystem::getSingleton().createLandmark(
+						name, processVector3(posChild));
+				}
+			}
+		}
+
+		for (DOMNode* cur = nodeElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+		{
+			if (cur->getNodeType() == DOMNode::ELEMENT_NODE && XmlHelper::hasNodeName(cur, "landmarkgraph"))
+			{
+				DOMElement* elem = static_cast<DOMElement*>(cur);
+				///@todo process waypointgraph
+				Ogre::String name;
+
+				LandmarkPath* path = AiSubsystem::getSingleton().createLandmarkPath(name);
+				
+				for (DOMNode* curPathChild = nodeElem->getFirstChild(); 
+					curPathChild != NULL; curPathChild = curPathChild->getNextSibling())
+				{
+					if (curPathChild->getNodeType() == DOMNode::ELEMENT_NODE 
+						&& XmlHelper::hasNodeName(curPathChild, "landmark"))
+					{
+						DOMElement* curLmElem = static_cast<DOMElement*>(curPathChild);
+						Landmark* lm = AiSubsystem::getSingleton().getLandmark(
+							XmlHelper::getAttributeValueAsStdString(curLmElem, "name"));
+
+						if (lm != NULL)
+						{
+							path->addPoint(lm);
+						}
+					}
+				}
+			}
+		}
+
+		return true;
+	}
+}

Added: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-05-03 21:21:02 UTC (rev 3383)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-05-03 21:23:27 UTC (rev 3384)
@@ -0,0 +1,126 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "ZoneProcessor.h"
+
+#include "ActorManager.h"
+#include "GameObjectConstants.h"
+#include "ScriptSubsystem.h"
+#include "Trigger.h"
+#include "TriggerFactory.h"
+#include "XmlHelper.h"
+#include "Zone.h"
+#include "ZoneManager.h"
+
+using namespace XERCES_CPP_NAMESPACE;
+using namespace Ogre;
+
+namespace rl
+{
+
+	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
+	{
+		if (zonesElem == NULL)
+		{
+			return false; // no zones
+		}
+
+        for (DOMNode* cur = zonesElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            if (cur->getNodeType() == DOMNode::ELEMENT_NODE
+				&& XmlHelper::hasNodeName(cur, "zone"))
+            {
+				DOMElement* curZoneElem = static_cast<DOMElement*>(cur);
+				if (XmlHelper::hasAttribute(curZoneElem, "type"))
+				{
+					Ogre::String type = XmlHelper::getAttributeValueAsStdString(curZoneElem, "type");
+					Zone* zone = NULL;
+					if (type == "default")
+					{
+						zone = ZoneManager::getSingleton().getDefaultZone();
+					}
+					else if (type == "mesh")
+					{
+						///@todo: zone = ZoneManager::getSingleton().createZone(...);
+					}
+					else if (type == "sphere")
+					{						
+						Vector3 center = Vector3::ZERO;
+						DOMElement* centerElem = XmlHelper::getChildNamed(curZoneElem, "center");
+						if (centerElem != NULL)
+						{
+							center = XmlHelper::getValueAsVector3(centerElem);
+						}
+
+						Real radius = 1;
+						DOMElement* radiusElem = XmlHelper::getChildNamed(curZoneElem, "radius");
+						if (radiusElem != NULL)
+						{
+							radius = XmlHelper::getAttributeValueAsReal(radiusElem, "r");
+						}
+
+						Ogre::String name = XmlHelper::getAttributeValueAsStdString(curZoneElem, "name");
+
+						zone = ZoneManager::getSingleton().createZone(
+							name, center, radius, QUERYFLAG_PLAYER);
+					}
+
+					if (zone != NULL)
+					{
+						for (DOMNode* cur = curZoneElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+						{
+							if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+							{
+								DOMElement* curElem = static_cast<DOMElement*>(cur);
+								if (XmlHelper::hasNodeName(curElem, "light"))
+								{
+									Ogre::String name = XmlHelper::getAttributeValueAsStdString(curElem, "name");
+									zone->addLight(ActorManager::getSingleton().getActor(name));
+								}
+								else if (XmlHelper::hasNodeName(curElem, "sound"))
+								{
+									Ogre::String name = XmlHelper::getAttributeValueAsStdString(curElem, "name");
+									zone->addSound(name);
+								}
+								else if (XmlHelper::hasNodeName(curElem, "trigger"))
+								{
+									Ogre::String classname = 
+										XmlHelper::getAttributeValueAsStdString(curElem, "classname");
+
+									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
+										->createTrigger(classname);
+
+									///@todo trigger properties
+								}
+							}
+						}
+					}
+					else
+					{
+						LOG_ERROR(Logger::RULES, "Zone of type '"+type+"' could not be processes.");
+					}
+				}
+				else
+				{
+					LOG_ERROR(Logger::RULES, "<zone> element must have attribute 'type'.");
+				}
+			}
+		}
+
+		return true;
+	}
+
+}



From blakharaz at mail.berlios.de  Thu May  3 23:24:09 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 3 May 2007 23:24:09 +0200
Subject: [Dsa-hl-svn] r3385 - modules/techdemo/maps
Message-ID: <200705032124.l43LO9Bu025039@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-03 23:24:04 +0200 (Thu, 03 May 2007)
New Revision: 3385

Modified:
   modules/techdemo/maps/techdemo_terrain.rlmap.xml
Log:
Fix sky

Modified: modules/techdemo/maps/techdemo_terrain.rlmap.xml
===================================================================
--- modules/techdemo/maps/techdemo_terrain.rlmap.xml	2007-05-03 21:23:27 UTC (rev 3384)
+++ modules/techdemo/maps/techdemo_terrain.rlmap.xml	2007-05-03 21:24:04 UTC (rev 3385)
@@ -30613,7 +30613,10 @@
         </light>
   </nodes>
 
-  	<sky type="box" material="rl/dsa07" range="10000"/>
+  <environment>
+  	<sky type="box" material="rl/dsa07" distance="2500"/>
+  </environment>
+
 	<zones>
 		<zone type="default">
 			<light name="sunlight"/>



From josch at mail.berlios.de  Fri May  4 23:44:15 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Fri, 4 May 2007 23:44:15 +0200
Subject: [Dsa-hl-svn] r3386 - in rl/trunk/engine: ai/include ai/src
	common/include core/include dialog/include rules/include
	script/src script/swig ui/include ui/src
Message-ID: <200705042144.l44LiFKf017465@sheep.berlios.de>

Author: josch
Date: 2007-05-04 23:43:59 +0200 (Fri, 04 May 2007)
New Revision: 3386

Modified:
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/src/Makefile.am
   rl/trunk/engine/common/include/Makefile.am
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/dialog/include/Makefile.am
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/script/src/Makefile.am
   rl/trunk/engine/script/swig/Makefile.am
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/Makefile.am
Log:
Build problems on Linux fixed

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -3,6 +3,7 @@
 	AgentManager.h \
 	AiPrerequisites.h \
 	AiSubsystem.h \
+	AiWorld.h \
 	AStarCosts.h \
 	AStar.h \
 	AStarHeuristic.h \
@@ -10,7 +11,10 @@
 	AStarWayPointNode.h \
 	FuzzyState.h \
 	FuzzyStateMachine.h \
+	Landmark.h \
+	LandmarkPath.h \
 	PhysicalObstacle.h \
+	PlayerVehicle.h \
 	SteeringMachine.h \
 	SteeringVehicle.h \
 	WayPointNode.h \

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -15,6 +15,8 @@
 	AStarWayPointNode.cpp \
 	FuzzyState.cpp \
 	FuzzyStateMachine.cpp \
+	Landmark.cpp \
+	LandmarkPath.cpp \
 	PhysicalObstacle.cpp \
 	PlayerVehicle.cpp \
 	SteeringVehicle.cpp \

Modified: rl/trunk/engine/common/include/Makefile.am
===================================================================
--- rl/trunk/engine/common/include/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/common/include/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -12,17 +12,13 @@
 	Logger.h \
 	MathUtil.h \
 	OgreXercesInput.h \
-	Playlist.h \
-	SimplePlaylist.h \
-        Properties.cpp \
-        Property.cpp \
-        RastullahPrerequisites.h \
-        ScriptWrapper.h \
+    Properties.h \
+    Property.h \
+    PropertyReader.h \
+    RastullahPrerequisites.h \
+    ScriptWrapper.h \
 	Sleep.h \
 	Tripel.h \
 	XmlHelper.h \
 	XmlResource.h \
 	XmlResourceManager.h
-	
-	
-	

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/core/include/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -9,6 +9,7 @@
 	CameraObject.h \
 	ConfigurationManager.h \
 	ContentModule.h \
+	CoreDefines.h \
 	CoreEvents.h \
 	CorePrerequisites.h \
 	CoreSubsystem.h \
@@ -54,6 +55,7 @@
 	SoundObject.h \
 	SoundResource.h \
 	TrackAnimation.h \
+	Trigger.h \
 	World.h \
 	Zone.h \
 	ZoneManager.h \

Modified: rl/trunk/engine/dialog/include/Makefile.am
===================================================================
--- rl/trunk/engine/dialog/include/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/dialog/include/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -7,9 +7,11 @@
 	DialogOption.h \
 	DialogPrerequisites.h \
 	DialogResponse.h \
+	DialogScriptProcessor.h \
 	DialogSubsystem.h \
 	ScriptProcessor.h \
 	predicates/CreaturePredicates.h \
+	predicates/EigenschaftsWertPredicates.h \
 	predicates/EigenschaftsProbePredicates.h \
 	predicates/QuestKnownPredicates.h \
 	predicates/QuestPartsPredicates.h \

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -1,6 +1,7 @@
 noinst_HEADERS = \
 	Action.h \
 	ActionManager.h \
+	Armor.h \
 	Combat.h \
 	CombatManager.h \
 	Container.h \
@@ -13,8 +14,11 @@
 	Eigenschaft.h \
 	EigenschaftenStateSet.h \
 	GameObject.h \
+	GameObjectConstants.h \
+	GameObjectStateListener.h \
 	Item.h \
 	Inventory.h \
+	JournalEntry.h \
 	Kampftechnik.h \
 	ObjectStateChangeEvent.h \
 	ObjectStateChangeEventSource.h \
@@ -28,6 +32,7 @@
 	RulesSubsystem.h \
 	SelectionHelper.h \
 	Selector.h \
+	Slot.h \
 	StateSet.h \
 	SonderfertigkeitenStateSet.h \
 	Talent.h \

Modified: rl/trunk/engine/script/src/Makefile.am
===================================================================
--- rl/trunk/engine/script/src/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/script/src/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -14,12 +14,16 @@
     -Wl,--defsym -Wl,Init_libRlScript=Init_RlScript
 	
 libRlScript_la_SOURCES = \
-  ScriptSubsystem.cpp \
-  ScriptObjectMarker.cpp \
-	../swig/RlExports.cxx \
-	AbstractMapNodeProcessor.cpp \
-	EntityNodeProcessor.cpp \
-	GameObjectNodeProcessor.cpp \
-	LightNodeProcessor.cpp \
-	MapLoader.cpp \
-	SoundNodeProcessor.cpp
+	AbstractMapNodeProcessor.cpp \
+	EntityNodeProcessor.cpp \
+	EnvironmentProcessor.cpp \
+	GameObjectNodeProcessor.cpp \
+	LightNodeProcessor.cpp \
+	MapLoader.cpp \
+	ParticleSystemNodeProcessor.cpp \
+	ScriptSubsystem.cpp \
+	ScriptObjectMarker.cpp \
+	SoundNodeProcessor.cpp \
+	WaypointProcessor.cpp \
+	ZoneProcessor.cpp \
+	../swig/RlExports.cxx 

Modified: rl/trunk/engine/script/swig/Makefile.am
===================================================================
--- rl/trunk/engine/script/swig/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/script/swig/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -5,7 +5,11 @@
 RlExports.cxx: RlCore.head.swig RlCore.swig RlRules.head.swig \
  RlRules.swig RlUi.head.swig RlUi.swig RlAi.head.swig RlAi.swig \
  RlScript.head.swig RlScript.swig RlCommon.head.swig RlCommon.swig \
- RlDialog.head.swig RlDialog.swig RlExports.i TypeMaps.i
+ RlDialog.head.swig RlDialog.swig RlExports.i TypeMaps.i RlExports.i \
+ TypeDynamicDirector.swig TypeOgreColourValue.swig TypeOgreQuaternion.swig \
+ TypeOgreRadian.swig TypeOgreReal.swig TypeOgreString.swig TypeOgreStringVector.swig \
+ TypeOgreVector3.swig TypeRlCeGuiString.swig TypeRlCeGuiStringVector.swig \
+ TypeRlProperty.swig TypeRlTripelInt.swig TypeStdPairIntInt.swig
  
 .i.cxx:
 	$(SWIG) $(SWIG_RUBY_OPT) -o $@ $<

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -2,6 +2,7 @@
     AboutWindow.h \
     ActionChoiceWindow.h \
     AbstractWindow.h \
+    CeGuiHelper.h \
     CharacterController.h \
     CharacterSheetWindow.h \
     CharacterStateWindow.h \
@@ -37,6 +38,7 @@
     PlaylistWindow.h \
     ProgressWindow.h \
     RenderSystemConfigComponent.h \
+    SaveLoadWindow.h \
     SoundDriverConfigComponent.h \
     SubtitleWindow.h \
     UiPrerequisites.h \

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-05-03 21:24:04 UTC (rev 3385)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-05-04 21:43:59 UTC (rev 3386)
@@ -28,7 +28,6 @@
     GameLoggerWindow.cpp \
     GameObjectInfoWindow.cpp \
     GameObjectPropsWindow.cpp \
-    SaveLoadWindow.cpp \
     GameSettings.cpp \
     InfoPopup.cpp \
     InGameMenuWindow.cpp \
@@ -46,6 +45,8 @@
     PlaylistWindow.cpp \
     ProgressWindow.cpp \
     RenderSystemConfigComponent.cpp \
+    SaveLoadWindow.cpp \
+    SoundConfig.cpp \
     SoundDriverConfigComponent.cpp \
     SubtitleWindow.cpp \
     UiSubsystem.cpp \



From pnyx at mail.berlios.de  Sat May  5 10:21:24 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sat, 5 May 2007 10:21:24 +0200
Subject: [Dsa-hl-svn] r3387 - content
Message-ID: <200705050821.l458LOYN023785@sheep.berlios.de>

Author: pnyx
Date: 2007-05-05 10:21:15 +0200 (Sat, 05 May 2007)
New Revision: 3387

Added:
   content/textures/
Log:
textures odner hinzugef?\195?\188gt



From alassion at mail.berlios.de  Sat May  5 10:26:56 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:26:56 +0200
Subject: [Dsa-hl-svn] r3388 - content/textures
Message-ID: <200705050826.l458QupU024300@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:26:42 +0200 (Sat, 05 May 2007)
New Revision: 3388

Added:
   content/textures/balken_01.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\balken_01.png


Added: content/textures/balken_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/balken_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:27:20 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:27:20 +0200
Subject: [Dsa-hl-svn] r3389 - content/textures
Message-ID: <200705050827.l458RK6M024348@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:27:06 +0200 (Sat, 05 May 2007)
New Revision: 3389

Added:
   content/textures/balken_02.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\balken_02.png


Added: content/textures/balken_02.png
===================================================================
(Binary files differ)


Property changes on: content/textures/balken_02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:27:50 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:27:50 +0200
Subject: [Dsa-hl-svn] r3390 - content/textures
Message-ID: <200705050827.l458Rom4024410@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:27:32 +0200 (Sat, 05 May 2007)
New Revision: 3390

Added:
   content/textures/felsen_02.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/felsen_02.png
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:28:10 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:28:10 +0200
Subject: [Dsa-hl-svn] r3391 - content/textures
Message-ID: <200705050828.l458SAjp024436@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:27:54 +0200 (Sat, 05 May 2007)
New Revision: 3391

Added:
   content/textures/felsen_03.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/felsen_03.png
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_03.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:28:26 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:28:26 +0200
Subject: [Dsa-hl-svn] r3392 - content/textures
Message-ID: <200705050828.l458SQB9024461@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:28:13 +0200 (Sat, 05 May 2007)
New Revision: 3392

Added:
   content/textures/gras_01.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/gras_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/gras_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:28:46 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:28:46 +0200
Subject: [Dsa-hl-svn] r3393 - content/textures
Message-ID: <200705050828.l458SkOi024489@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:28:32 +0200 (Sat, 05 May 2007)
New Revision: 3393

Added:
   content/textures/gras_02.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/gras_02.png
===================================================================
(Binary files differ)


Property changes on: content/textures/gras_02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:28:55 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:28:55 +0200
Subject: [Dsa-hl-svn] r3394 - content/textures
Message-ID: <200705050828.l458StMZ024522@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:28:50 +0200 (Sat, 05 May 2007)
New Revision: 3394

Added:
   content/textures/grasbueschel.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/grasbueschel.png
===================================================================
(Binary files differ)


Property changes on: content/textures/grasbueschel.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:29:12 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:29:12 +0200
Subject: [Dsa-hl-svn] r3395 - content/textures
Message-ID: <200705050829.l458TCnY024541@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:29:08 +0200 (Sat, 05 May 2007)
New Revision: 3395

Added:
   content/textures/baumstamm_01.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/baumstamm_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/baumstamm_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:29:22 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:29:22 +0200
Subject: [Dsa-hl-svn] r3396 - content/textures
Message-ID: <200705050829.l458TMHp024554@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:29:14 +0200 (Sat, 05 May 2007)
New Revision: 3396

Added:
   content/textures/baumstamm_02.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/baumstamm_02.png
===================================================================
(Binary files differ)


Property changes on: content/textures/baumstamm_02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:30:15 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:30:15 +0200
Subject: [Dsa-hl-svn] r3397 - content/textures
Message-ID: <200705050830.l458UFUd024734@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:30:03 +0200 (Sat, 05 May 2007)
New Revision: 3397

Added:
   content/textures/baumstamm_03.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/baumstamm_03.png
===================================================================
(Binary files differ)


Property changes on: content/textures/baumstamm_03.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:30:36 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:30:36 +0200
Subject: [Dsa-hl-svn] r3398 - content/textures
Message-ID: <200705050830.l458UacY024805@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:30:19 +0200 (Sat, 05 May 2007)
New Revision: 3398

Added:
   content/textures/boden_01.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/boden_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:31:02 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:31:02 +0200
Subject: [Dsa-hl-svn] r3399 - content/textures
Message-ID: <200705050831.l458V2fX024993@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:30:46 +0200 (Sat, 05 May 2007)
New Revision: 3399

Added:
   content/textures/boden_02.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/boden_02.png
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:31:18 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:31:18 +0200
Subject: [Dsa-hl-svn] r3400 - content/textures
Message-ID: <200705050831.l458VIxE025042@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:31:03 +0200 (Sat, 05 May 2007)
New Revision: 3400

Added:
   content/textures/fachwerk_01.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/fachwerk_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/fachwerk_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:31:41 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:31:41 +0200
Subject: [Dsa-hl-svn] r3401 - content/textures
Message-ID: <200705050831.l458VfR8025088@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:31:25 +0200 (Sat, 05 May 2007)
New Revision: 3401

Added:
   content/textures/fachwerk_02.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/fachwerk_02.png
===================================================================
(Binary files differ)


Property changes on: content/textures/fachwerk_02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:32:45 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:32:45 +0200
Subject: [Dsa-hl-svn] r3402 - content/textures
Message-ID: <200705050832.l458WjM7025180@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:31:45 +0200 (Sat, 05 May 2007)
New Revision: 3402

Added:
   content/textures/felsen.psd
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/felsen.psd
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen.psd
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:33:09 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:33:09 +0200
Subject: [Dsa-hl-svn] r3403 - content/textures
Message-ID: <200705050833.l458X9qT025227@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:32:55 +0200 (Sat, 05 May 2007)
New Revision: 3403

Added:
   content/textures/felsen_01.png
Log:
Added items remotely

C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\gras_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\grasbueschel.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\baumstamm_03.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\boden_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_01.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\fachwerk_02.png
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen.psd
C:\Dokumente und Einstellungen\Administrator\Desktop\alassion_texpaket\felsen_01.png


Added: content/textures/felsen_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 10:34:05 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 10:34:05 +0200
Subject: [Dsa-hl-svn] r3404 - content/textures
Message-ID: <200705050834.l458Y5ci025292@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 10:34:04 +0200 (Sat, 05 May 2007)
New Revision: 3404

Removed:
   content/textures/felsen.psd
Log:
Removed file/folder

Deleted: content/textures/felsen.psd
===================================================================
(Binary files differ)



From alassion at mail.berlios.de  Sat May  5 12:57:18 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:57:18 +0200
Subject: [Dsa-hl-svn] r3405 - content/textures
Message-ID: <200705051057.l45AvIff010535@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:57:15 +0200 (Sat, 05 May 2007)
New Revision: 3405

Added:
   content/textures/grasbueschel.dds
Log:
DDS Textures - updated

Added: content/textures/grasbueschel.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/grasbueschel.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:57:38 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:57:38 +0200
Subject: [Dsa-hl-svn] r3406 - content/textures
Message-ID: <200705051057.l45Avc3K012025@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:57:34 +0200 (Sat, 05 May 2007)
New Revision: 3406

Added:
   content/textures/balken_01.dds
Log:
DDS Textures - updated

Added: content/textures/balken_01.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/balken_01.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:57:47 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:57:47 +0200
Subject: [Dsa-hl-svn] r3407 - content/textures
Message-ID: <200705051057.l45AvlNA012375@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:57:42 +0200 (Sat, 05 May 2007)
New Revision: 3407

Added:
   content/textures/balken_02.dds
Log:
DDS Textures - updated

Added: content/textures/balken_02.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/balken_02.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:58:00 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:58:00 +0200
Subject: [Dsa-hl-svn] r3408 - content/textures
Message-ID: <200705051058.l45Aw0iu013085@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:57:56 +0200 (Sat, 05 May 2007)
New Revision: 3408

Added:
   content/textures/baumstamm_01.dds
Log:
DDS Textures - updated

Added: content/textures/baumstamm_01.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/baumstamm_01.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:58:16 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:58:16 +0200
Subject: [Dsa-hl-svn] r3409 - content/textures
Message-ID: <200705051058.l45AwGep013467@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:58:09 +0200 (Sat, 05 May 2007)
New Revision: 3409

Added:
   content/textures/baumstamm_02.dds
Log:
DDS Textures - updated

Added: content/textures/baumstamm_02.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/baumstamm_02.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:58:32 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:58:32 +0200
Subject: [Dsa-hl-svn] r3410 - content/textures
Message-ID: <200705051058.l45AwWSf013831@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:58:25 +0200 (Sat, 05 May 2007)
New Revision: 3410

Added:
   content/textures/boden_01.dds
Log:
DDS Textures - updated

Added: content/textures/boden_01.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_01.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:58:48 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:58:48 +0200
Subject: [Dsa-hl-svn] r3411 - content/textures
Message-ID: <200705051058.l45Awm4X014146@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:58:41 +0200 (Sat, 05 May 2007)
New Revision: 3411

Added:
   content/textures/boden_02.dds
Log:
DDS Textures - updated

Added: content/textures/boden_02.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_02.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:59:09 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:59:09 +0200
Subject: [Dsa-hl-svn] r3412 - content/textures
Message-ID: <200705051059.l45Ax9PB014561@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:59:03 +0200 (Sat, 05 May 2007)
New Revision: 3412

Added:
   content/textures/fachwerk_01.dds
Log:
DDS Textures - updated

Added: content/textures/fachwerk_01.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/fachwerk_01.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:59:25 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:59:25 +0200
Subject: [Dsa-hl-svn] r3413 - content/textures
Message-ID: <200705051059.l45AxP6V015352@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:59:20 +0200 (Sat, 05 May 2007)
New Revision: 3413

Added:
   content/textures/fachwerk_02.dds
Log:
DDS Textures - updated

Added: content/textures/fachwerk_02.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/fachwerk_02.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:59:41 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:59:41 +0200
Subject: [Dsa-hl-svn] r3414 - content/textures
Message-ID: <200705051059.l45AxfA9015661@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:59:31 +0200 (Sat, 05 May 2007)
New Revision: 3414

Added:
   content/textures/felsen_01.dds
Log:
DDS Textures - updated

Added: content/textures/felsen_01.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_01.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 12:59:53 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 12:59:53 +0200
Subject: [Dsa-hl-svn] r3415 - content/textures
Message-ID: <200705051059.l45Axr4k016121@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 12:59:45 +0200 (Sat, 05 May 2007)
New Revision: 3415

Added:
   content/textures/felsen_02.dds
Log:
DDS Textures - updated

Added: content/textures/felsen_02.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_02.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 13:00:21 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 13:00:21 +0200
Subject: [Dsa-hl-svn] r3416 - content/textures
Message-ID: <200705051100.l45B0L2s017351@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 13:00:12 +0200 (Sat, 05 May 2007)
New Revision: 3416

Added:
   content/textures/felsen_03.dds
Log:
DDS Textures - updated

Added: content/textures/felsen_03.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_03.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 13:00:35 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 13:00:35 +0200
Subject: [Dsa-hl-svn] r3417 - content/textures
Message-ID: <200705051100.l45B0ZsP017978@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 13:00:27 +0200 (Sat, 05 May 2007)
New Revision: 3417

Added:
   content/textures/gras_01.dds
Log:
DDS Textures - updated

Added: content/textures/gras_01.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/gras_01.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Sat May  5 13:00:57 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sat, 5 May 2007 13:00:57 +0200
Subject: [Dsa-hl-svn] r3418 - content/textures
Message-ID: <200705051100.l45B0vML018343@sheep.berlios.de>

Author: alassion
Date: 2007-05-05 13:00:51 +0200 (Sat, 05 May 2007)
New Revision: 3418

Added:
   content/textures/gras_02.dds
Log:
DDS Textures - updated

Added: content/textures/gras_02.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/gras_02.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From blakharaz at mail.berlios.de  Sun May  6 21:30:36 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 6 May 2007 21:30:36 +0200
Subject: [Dsa-hl-svn] r3419 - rl/trunk/docs/documents
Message-ID: <200705061930.l46JUaKo002223@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-06 21:30:29 +0200 (Sun, 06 May 2007)
New Revision: 3419

Modified:
   rl/trunk/docs/documents/scene_format_proposal.xml
Log:
Proposal for animations and tracks on entity nodes

Modified: rl/trunk/docs/documents/scene_format_proposal.xml
===================================================================
--- rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-05 11:00:51 UTC (rev 3418)
+++ rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-06 19:30:29 UTC (rev 3419)
@@ -15,6 +15,14 @@
 			<physicsproxy type="none" /> <!-- type is none|box|sphere|ellipsoid|mesh|convexhull|custom -->
 			<renderingdistance data="20000" />
 
+			<!-- active animations and tracks -->
+            <animation type="track" name="eagle_path_1" active="false"/>
+            <animation type="track" name="eagle_path_2" active="false">
+                       <keyframe framenr="1">
+                                 <translation x="0" y="1" z="2"/>
+                                 <rotation qx="0.000000" qy="-0.975135" qz="0.000000" qw="0.221611"/>
+                       </keyframe>
+            <animation type="mesh" name="fly"/>
 		</entity>
 
 		<!-- static mesh with custom collision-->
@@ -42,7 +50,6 @@
 					<center x="141.95" y="7.20" z="32.55" />
 				</collision>
 			</physicsproxy>
-
 		</entity>
 
 



From blakharaz at mail.berlios.de  Mon May  7 11:53:15 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 7 May 2007 11:53:15 +0200
Subject: [Dsa-hl-svn] r3420 - in rl/trunk: engine/ai/include
	engine/common/include engine/dialog/include
	engine/dialog/include/predicates plugins/fmod4driver/include
Message-ID: <200705070953.l479rFtr000750@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-07 11:53:02 +0200 (Mon, 07 May 2007)
New Revision: 3420

Modified:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AStarCosts.h
   rl/trunk/engine/ai/include/AStarHeuristic.h
   rl/trunk/engine/ai/include/AStarNodePool.h
   rl/trunk/engine/ai/include/AStarWayPointNode.h
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/AiPrerequisites.h
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/include/FuzzyState.h
   rl/trunk/engine/ai/include/FuzzyStateMachine.h
   rl/trunk/engine/ai/include/LandmarkPath.h
   rl/trunk/engine/ai/include/PhysicalObstacle.h
   rl/trunk/engine/ai/include/PlayerVehicle.h
   rl/trunk/engine/ai/include/SteeringMachine.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/include/WayPointGraphManager.h
   rl/trunk/engine/ai/include/WayPointNode.h
   rl/trunk/engine/common/include/XmlErrorHandler.h
   rl/trunk/engine/dialog/include/AimlNodeImplRl.h
   rl/trunk/engine/dialog/include/AimlParserImplRl.h
   rl/trunk/engine/dialog/include/ContextConditionProcessor.h
   rl/trunk/engine/dialog/include/ContextInterpreter.h
   rl/trunk/engine/dialog/include/DialogCharacter.h
   rl/trunk/engine/dialog/include/DialogOption.h
   rl/trunk/engine/dialog/include/DialogPrerequisites.h
   rl/trunk/engine/dialog/include/DialogResponse.h
   rl/trunk/engine/dialog/include/DialogScriptProcessor.h
   rl/trunk/engine/dialog/include/DialogSubsystem.h
   rl/trunk/engine/dialog/include/ScriptProcessor.h
   rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h
   rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h
   rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h
   rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h
   rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h
   rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h
   rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h
   rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h
   rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h
   rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h
   rl/trunk/plugins/fmod4driver/include/Fmod4ConfigComponent.h
Log:
Updated copyright to 2007

Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AStar.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
@@ -45,12 +45,12 @@
          */
         void reset();
 
-        int mNodesSearched;
-        int mNodesAdded;
-        int mNodesRemoved;
-        int mNodesVisited;
-        int mNodesLeft;
-        int mPathLength;
+        int mNodesSearched;
+        int mNodesAdded;
+        int mNodesRemoved;
+        int mNodesVisited;
+        int mNodesLeft;
+        int mPathLength;
         int mPathCost;
 	};
 

Modified: rl/trunk/engine/ai/include/AStarCosts.h
===================================================================
--- rl/trunk/engine/ai/include/AStarCosts.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AStarCosts.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/AStarHeuristic.h
===================================================================
--- rl/trunk/engine/ai/include/AStarHeuristic.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AStarHeuristic.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/AStarNodePool.h
===================================================================
--- rl/trunk/engine/ai/include/AStarNodePool.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AStarNodePool.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/AStarWayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/Agent.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/AiPrerequisites.h
===================================================================
--- rl/trunk/engine/ai/include/AiPrerequisites.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AiPrerequisites.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/FuzzyState.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyState.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/FuzzyState.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/FuzzyStateMachine.h
===================================================================
--- rl/trunk/engine/ai/include/FuzzyStateMachine.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/FuzzyStateMachine.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/LandmarkPath.h
===================================================================
--- rl/trunk/engine/ai/include/LandmarkPath.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/LandmarkPath.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/PhysicalObstacle.h
===================================================================
--- rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/PlayerVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/PlayerVehicle.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/PlayerVehicle.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/SteeringMachine.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringMachine.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/SteeringMachine.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/WayPointGraphManager.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/WayPointGraphManager.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/ai/include/WayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointNode.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/ai/include/WayPointNode.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/common/include/XmlErrorHandler.h
===================================================================
--- rl/trunk/engine/common/include/XmlErrorHandler.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/common/include/XmlErrorHandler.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.

Modified: rl/trunk/engine/dialog/include/AimlNodeImplRl.h
===================================================================
--- rl/trunk/engine/dialog/include/AimlNodeImplRl.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/AimlNodeImplRl.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/AimlParserImplRl.h
===================================================================
--- rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/AimlParserImplRl.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/ContextConditionProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/ContextConditionProcessor.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/ContextConditionProcessor.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/ContextInterpreter.h
===================================================================
--- rl/trunk/engine/dialog/include/ContextInterpreter.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/ContextInterpreter.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/DialogCharacter.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogCharacter.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/DialogCharacter.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/DialogOption.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogOption.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/DialogOption.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/DialogPrerequisites.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogPrerequisites.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/DialogPrerequisites.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogResponse.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/DialogResponse.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/DialogScriptProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogScriptProcessor.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/DialogScriptProcessor.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/DialogSubsystem.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/DialogSubsystem.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/ScriptProcessor.h
===================================================================
--- rl/trunk/engine/dialog/include/ScriptProcessor.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/ScriptProcessor.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/CreaturePredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/EigenschaftsProbePredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/EigenschaftsWertPredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/GrundWertPredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/QuestKnownPredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/QuestPartsPredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/QuestStatePredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/ScriptPredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/TalentProbePredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h
===================================================================
--- rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/engine/dialog/include/predicates/TalentWertPredicates.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4ConfigComponent.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4ConfigComponent.h	2007-05-06 19:30:29 UTC (rev 3419)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4ConfigComponent.h	2007-05-07 09:53:02 UTC (rev 3420)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.



From no22 at mail.berlios.de  Mon May  7 14:42:10 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Mon, 7 May 2007 14:42:10 +0200
Subject: [Dsa-hl-svn] r3421 - in rl/trunk/engine: core core/include core/src
	rules/include rules/src script/swig
Message-ID: <200705071242.l47CgABp030717@sheep.berlios.de>

Author: no22
Date: 2007-05-07 14:42:00 +0200 (Mon, 07 May 2007)
New Revision: 3421

Modified:
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/Job.h
   rl/trunk/engine/core/include/LightObject.h
   rl/trunk/engine/core/src/LightObject.cpp
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
*added LightFadeJob (not tested yet, do not use)
*minor changes to Creature

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-05-07 12:42:00 UTC (rev 3421)
@@ -457,6 +457,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\LightFadeJob.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\LightObject.h"
 				>
 			</File>
@@ -706,6 +710,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\LightFadeJob.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\LightObject.cpp"
 				>
 			</File>

Modified: rl/trunk/engine/core/include/Job.h
===================================================================
--- rl/trunk/engine/core/include/Job.h	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/core/include/Job.h	2007-05-07 12:42:00 UTC (rev 3421)
@@ -22,7 +22,7 @@
 namespace rl
 {
     /** A Job is an independent executional entity, that encapsules a singe specific task
-     *  of a some finite duration.
+     *  of some finite duration.
      *  If you want some task to be executed every frame over the length of the game,
      *  use GameTask instead.<br>
      *  A Job is registered with the JobScheduler using JobScheduler#addJob.

Modified: rl/trunk/engine/core/include/LightObject.h
===================================================================
--- rl/trunk/engine/core/include/LightObject.h	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/core/include/LightObject.h	2007-05-07 12:42:00 UTC (rev 3421)
@@ -42,8 +42,10 @@
             Ogre::Real linear, Ogre::Real quadric);
         void setDiffuseColour(Ogre::Real red, Ogre::Real green, Ogre::Real blue);
         void setDiffuseColour(const Ogre::ColourValue& colour);
+        Ogre::ColourValue getDiffuseColour() const;
         void setSpecularColour(Ogre::Real red, Ogre::Real green, Ogre::Real blue);
         void setSpecularColour(const Ogre::ColourValue& colour);
+        Ogre::ColourValue getSpecularColour() const;
         void setDirection(Ogre::Real x, Ogre::Real y, Ogre::Real z);
         void setDirection(const Ogre::Vector3& direction);
 		void setSpotlightRange(Ogre::Real innerAngle, Ogre::Real outerAngle,

Modified: rl/trunk/engine/core/src/LightObject.cpp
===================================================================
--- rl/trunk/engine/core/src/LightObject.cpp	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/core/src/LightObject.cpp	2007-05-07 12:42:00 UTC (rev 3421)
@@ -56,6 +56,11 @@
         getLight()->setDiffuseColour(colour);
     }
 
+    Ogre::ColourValue LightObject::getDiffuseColour() const
+    {
+        return getLight()->getDiffuseColour();
+    }
+
     void LightObject::setDirection( Real x, Real y, Real z)
     {
         getLight()->setDirection(x,y,z);
@@ -76,6 +81,11 @@
         getLight()->setSpecularColour(red,green,blue);
     }
 
+    Ogre::ColourValue LightObject::getSpecularColour() const
+    {
+        return getLight()->getSpecularColour();
+    }
+
 	void LightObject::setSpotlightRange( Real innerAngle, Real outerAngle,
 		Real falloff )
 	{

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/rules/include/Effect.h	2007-05-07 12:42:00 UTC (rev 3421)
@@ -78,17 +78,6 @@
             QUANTIFIER_UNIQUE_BUT_CUMULATIVE
         };
 
-        /**
-         *  Spezifiziert bestimmte Merkmale eines Effekts und erlaubt damit darauf zu
-         *  reagieren.
-         *  @warning Das Konzept ist nur ein Prototyp und kann jederzeit verworfen 
-         *   werden.
-         **/
-        enum EffectTag
-        {
-            EFFECTTAG_NONE,
-            EFFECTTAG_KRANKHEIT
-        };
 
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.
 		Effect(int stufe = 1);

Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/rules/include/EffectManager.h	2007-05-07 12:42:00 UTC (rev 3421)
@@ -40,7 +40,7 @@
 		~EffectManager();
 
         /**
-         *  Ueberprueft die Effekte auf Veraenderungen.
+         *  Checks effects for changes.
          **/
 		void checkEffects();
         /** 
@@ -69,7 +69,11 @@
          **/
 		void addEffect(Effect* effect);
         
+        /// Removes effects by pointer.
         void removeEffect(Effect* effect);
+
+        /// Removes effects by name.
+        void removeEffect(CeGuiString name);
         
         /**
          * Checks the effects for the given status.
@@ -89,12 +93,6 @@
 		typedef std::set<Effect*> Effects;
 		Effects mEffects;
         /**
-         * Eine Liste von Tags und Effekten die auf das hinzufuegen
-         * eines Effekts mit diesem Tag reagieren.
-         **/
-        typedef std::map<Effect::EffectTag, Effects> Watchlist;
-		Watchlist mWatchlist;
-        /**
          * Eine Liste die wiedergibt, wann welcher Effekt
          * ueberprueft werden muss.
          **/

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-05-07 12:42:00 UTC (rev 3421)
@@ -802,10 +802,13 @@
             tp = 0;
         }
         ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType&LEDAMAGE_FIRE) == LEDAMAGE_FIRE) CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Fire!\"");
-        if ((damageType&LEDAMAGE_WATER) == LEDAMAGE_WATER) CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Water!\"");
-        if ((damageType&LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC) CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Demons!\"");
-        if ((damageType&LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
+        if ((damageType & LEDAMAGE_FIRE) == LEDAMAGE_FIRE) 
+            CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Fire!\"");
+        if ((damageType & LEDAMAGE_WATER) == LEDAMAGE_WATER) 
+            CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Water!\"");
+        if ((damageType & LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC) 
+            CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Demons!\"");
+        if ((damageType & LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
         {
             damageAu(tp, AUDAMAGE_NORMAL);
             tp = (int)floor(tp/2.);

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2007-05-07 12:42:00 UTC (rev 3421)
@@ -68,10 +68,10 @@
         // Preconditions: time > 0, effect != NULL
         if (time <= 0) Throw(IllegalArgumentException, "time parameter is <= 0!");
         if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
-        // Hole aktuelle ingame Zeit und addiere time darauf
+        // Get current ingame time and add timeUntilCheck
         RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
         RL_LONGLONG timeForCheck = now + timeUntilCheck;
-        // Fuege die Summe und Effekt in die Checklist ein
+        // Insert Sum and effect into the checklist
         mChecklist[timeForCheck].insert(effect);
     }
     
@@ -81,7 +81,7 @@
         RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
         if (date <= now) Throw(IllegalArgumentException, "date lies in the past!");
         if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
-        // Fuege Datum und Effekt in die Checklist ein
+        // Insert date and effect into the checklist
         mChecklist[date].insert(effect);
     }
 
@@ -113,11 +113,25 @@
     
     void EffectManager::removeEffect(Effect* effect)
     {
-      effect->disable();
       mEffects.erase(effect);
       ScriptWrapper::getSingleton().disowned(effect);
       ///@todo also remove from the check lists?
     }
+
+    void EffectManager::removeEffect(CeGuiString name)
+    {
+		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+		{
+            if ((*it)->getName() == name)
+            {
+                ScriptWrapper::getSingleton().disowned(*it);
+                mEffects.erase(it);
+                return;
+            }
+        }
+    }
+
+
     
     Effect::Status EffectManager::getStatus()
     {

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-05-07 12:42:00 UTC (rev 3421)
@@ -58,6 +58,7 @@
 #include "PlayAnimationJob.h"
 #include "Zone.h"
 #include "ZoneManager.h"
+#include "LightFadeJob.h"
 #undef message
 #undef send
 %}

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-05-07 12:42:00 UTC (rev 3421)
@@ -842,6 +842,15 @@
     bool execute(Ogre::Real time);
 };
 
+class LightFadeJob : public rl::Job
+{
+public:
+    LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse, 
+        const Ogre::ColourValue& targetSpecular, Ogre::Real duration = 1.0f);
+
+    virtual bool execute(Ogre::Real time);
+};
+
 class JobScheduler
 {
 public:
@@ -875,9 +884,9 @@
 public:
 	virtual bool activate() = 0;
 	virtual bool deactivate() = 0;
-	virtual const rl::Property getProperty(const Ogre::String& key) const = 0;
-    virtual void setProperty(const Ogre::String& key, const rl::Property& value) = 0;
-    virtual rl::PropertySet* getAllProperties() const = 0;
+	virtual const rl::Property getProperty(const Ogre::String& key) const = 0;
+    virtual void setProperty(const Ogre::String& key, const rl::Property& value) = 0;
+    virtual rl::PropertySet* getAllProperties() const = 0;
     virtual void setProperties(const rl::PropertySet* props);
 };
 

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-05-07 09:53:02 UTC (rev 3420)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-05-07 12:42:00 UTC (rev 3421)
@@ -549,14 +549,7 @@
             QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
             QUANTIFIER_UNIQUE_BUT_CUMULATIVE
         };
-
-        enum EffectTag
-        {
-            EFFECTTAG_NONE,
-            EFFECTTAG_KRANKHEIT
-        };
         
-
       // other constants
         static const int REMOVE = -1;
         static const int PERMANENT = 0;



From tanis at mail.berlios.de  Mon May  7 22:57:22 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 7 May 2007 22:57:22 +0200
Subject: [Dsa-hl-svn] r3422 - modules/common/gui/imagesets
Message-ID: <200705072057.l47KvMBZ000438@sheep.berlios.de>

Author: tanis
Date: 2007-05-07 22:57:14 +0200 (Mon, 07 May 2007)
New Revision: 3422

Modified:
   modules/common/gui/imagesets/RastullahButtons.imageset
   modules/common/gui/imagesets/RastullahButtons.png
Log:
Added attack/parry buttons. Not pretty? Oh, well. Deal with it! :P

Modified: modules/common/gui/imagesets/RastullahButtons.imageset
===================================================================
--- modules/common/gui/imagesets/RastullahButtons.imageset	2007-05-07 12:42:00 UTC (rev 3421)
+++ modules/common/gui/imagesets/RastullahButtons.imageset	2007-05-07 20:57:14 UTC (rev 3422)
@@ -7,4 +7,6 @@
     <Image Name="Buttons/CloseDoor" XPos="222" YPos="0" Width="37" Height="37" />
     <Image Name="Buttons/Talk" XPos="259" YPos="0" Width="37" Height="37" />
     <Image Name="Buttons/ViewObject" XPos="333" YPos="0" Width="37" Height="37" />
+    <Image Name="Buttons/Attack" XPos="370" YPos="0" Width="37" Height="37" />
+    <Image Name="Buttons/Parry" XPos="407" YPos="0" Width="37" Height="37" />
 </Imageset>

Modified: modules/common/gui/imagesets/RastullahButtons.png
===================================================================
(Binary files differ)



From no22 at mail.berlios.de  Thu May 10 14:25:47 2007
From: no22 at mail.berlios.de (no22 at mail.berlios.de)
Date: Thu, 10 May 2007 14:25:47 +0200
Subject: [Dsa-hl-svn] r3423 - in rl/trunk/engine/core: include src
Message-ID: <200705101225.l4ACPlgn032685@sheep.berlios.de>

Author: no22
Date: 2007-05-10 14:25:34 +0200 (Thu, 10 May 2007)
New Revision: 3423

Added:
   rl/trunk/engine/core/include/LightFadeJob.h
   rl/trunk/engine/core/src/LightFadeJob.cpp
Log:
*added missing files

Added: rl/trunk/engine/core/include/LightFadeJob.h
===================================================================
--- rl/trunk/engine/core/include/LightFadeJob.h	2007-05-07 20:57:14 UTC (rev 3422)
+++ rl/trunk/engine/core/include/LightFadeJob.h	2007-05-10 12:25:34 UTC (rev 3423)
@@ -0,0 +1,57 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_LIGHT_FADE_JOB_H__
+#define __RL_LIGHT_FADE_JOB_H__
+
+#include "CorePrerequisites.h"
+#include <OgreSingleton.h>
+#include "LightObject.h"
+
+#include "Job.h"
+
+namespace rl {
+
+    class _RlCoreExport LightFadeJob : public Job
+    {
+    public:
+        LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse, 
+            const Ogre::ColourValue& targetSpecular, Ogre::Real duration = 1.0f);
+
+        virtual bool execute(Ogre::Real time);
+        virtual void discard();
+
+    protected:
+        /**
+         *  Interpolates between two color values. The interpolated colour is returned in
+         *  currentColour and depends on mTime and mDuration.
+         **/
+        bool interpolateColour(const Ogre::ColourValue& startColour, 
+            const Ogre::ColourValue& endColour, Ogre::ColourValue& currentColour);
+        int mSteps;
+        LightObject* mLightObject;
+        /// The time passed since job start.
+        Ogre::Real mTime;
+        /// The total duration of the fade job.
+        Ogre::Real mDuration;
+        Ogre::ColourValue mTargetDiffuse;
+        Ogre::ColourValue mStartDiffuse;
+        Ogre::ColourValue mTargetSpecular;
+        Ogre::ColourValue mStartSpecular;
+    };
+}
+
+#endif

Added: rl/trunk/engine/core/src/LightFadeJob.cpp
===================================================================
--- rl/trunk/engine/core/src/LightFadeJob.cpp	2007-05-07 20:57:14 UTC (rev 3422)
+++ rl/trunk/engine/core/src/LightFadeJob.cpp	2007-05-10 12:25:34 UTC (rev 3423)
@@ -0,0 +1,101 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "LightFadeJob.h"
+
+
+namespace rl
+{
+    LightFadeJob::LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse, 
+        const Ogre::ColourValue& targetSpecular, Ogre::Real duration)
+        : Job(true, true),
+        mLightObject(lightObject),
+        mDuration(duration)
+    {
+        if (mLightObject != NULL)
+        {
+            mStartDiffuse = mLightObject->getDiffuseColour();
+            mStartSpecular = mLightObject->getSpecularColour();
+        }
+    }
+
+    bool LightFadeJob::execute(Ogre::Real time)
+    {
+        // Precondition: mLightObject != NULL
+        if (mLightObject == NULL)
+        {
+            discard();
+            return true;
+        }
+
+        // add passed time to total time
+        mTime += time;
+
+        bool diffuseInterpolationFinished = false;
+        bool specularInterpolationFinished = false;
+
+        // interpolate colour values and set light source
+        Ogre::ColourValue currentDiffuse;
+        diffuseInterpolationFinished = interpolateColour(mStartDiffuse, mTargetDiffuse, currentDiffuse);
+        mLightObject->setDiffuseColour(currentDiffuse);
+        Ogre::ColourValue currentSpecular;
+        specularInterpolationFinished = interpolateColour(mStartSpecular, mTargetSpecular, currentSpecular);
+        mLightObject->setSpecularColour(currentSpecular);
+
+        // Are we done now?
+        if (diffuseInterpolationFinished && specularInterpolationFinished)
+        {
+            discard();
+            return true;
+        }
+        //mWindow->getWindow()->setAlpha(mCurrentAlpha);
+
+        return false;
+    }
+
+    void LightFadeJob::discard()
+    {
+        /// @todo check if light source is invisible?
+    }
+
+    bool LightFadeJob::interpolateColour(const Ogre::ColourValue& startColour, 
+        const Ogre::ColourValue& endColour, Ogre::ColourValue& currentColour)
+    {
+        // Postcondition: mTime <= mDuration
+        if (mDuration < mTime)
+            return true;
+
+        // calculate current factor
+        float factor;
+        if (mTime == mDuration)
+        {
+            factor = 1.0f;
+        }
+        else
+        {
+            factor = (float)mTime / (float)mDuration;
+        }
+
+        // vresult = (1-factor)*vstart + factor*vend
+        currentColour = (1.0f - factor) * startColour + factor * endColour;
+
+        // if (finished) return true
+        if (mTime == mDuration)
+            return true;
+        else
+            return false;
+    }
+}



From timm at mail.berlios.de  Thu May 10 16:07:19 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 10 May 2007 16:07:19 +0200
Subject: [Dsa-hl-svn] r3424 - dependencies/opensteer/src
Message-ID: <200705101407.l4AE7Jf3010729@sheep.berlios.de>

Author: timm
Date: 2007-05-10 16:07:01 +0200 (Thu, 10 May 2007)
New Revision: 3424

Modified:
   dependencies/opensteer/src/Obstacle.cpp
Log:
Absturz im Release Modus beseitigt

Modified: dependencies/opensteer/src/Obstacle.cpp
===================================================================
--- dependencies/opensteer/src/Obstacle.cpp	2007-05-10 12:25:34 UTC (rev 3423)
+++ dependencies/opensteer/src/Obstacle.cpp	2007-05-10 14:07:01 UTC (rev 3424)
@@ -98,7 +98,8 @@
     // future path, select the one whose point of intersection is nearest
     next.intersect = false;
     nearest.intersect = false;
-    for (ObstacleIterator o = obstacles.begin(); o != obstacles.end(); o++)
+    ObstacleIterator o;
+    for (o = obstacles.begin(); o != obstacles.end(); o++)
     {
         // find nearest point (if any) where vehicle path intersects obstacle
         // o, storing the results in PathIntersection object "next"



From timm at mail.berlios.de  Thu May 10 16:10:16 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 10 May 2007 16:10:16 +0200
Subject: [Dsa-hl-svn] r3425 - rl/trunk/engine/core/src
Message-ID: <200705101410.l4AEAGGw011051@sheep.berlios.de>

Author: timm
Date: 2007-05-10 16:09:45 +0200 (Thu, 10 May 2007)
New Revision: 3425

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
Log:
addSetting("General", "LogLevel", "2"); ---> addSetting("General", "Log Level", "2");

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-05-10 14:07:01 UTC (rev 3424)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-05-10 14:09:45 UTC (rev 3425)
@@ -57,7 +57,7 @@
         mModulesCfgFile = "modules.cfg";
 
         // Setup general default values
-        addSetting("General", "LogLevel", "2");
+        addSetting("General", "Log Level", "2");
         addSetting("General", "Subtitle Speed", "0.0");
 
         // Setup sound default values



From melven at mail.berlios.de  Thu May 10 17:53:31 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 10 May 2007 17:53:31 +0200
Subject: [Dsa-hl-svn] r3426 - rl/trunk/engine/ui/src
Message-ID: <200705101553.l4AFrVTk017382@sheep.berlios.de>

Author: melven
Date: 2007-05-10 17:53:18 +0200 (Thu, 10 May 2007)
New Revision: 3426

Modified:
   rl/trunk/engine/ui/src/DebugWindow.cpp
Log:
Added player orientation to the debugwindow

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2007-05-10 14:09:45 UTC (rev 3425)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2007-05-10 15:53:18 UTC (rev 3426)
@@ -178,11 +178,18 @@
             if( charObj != NULL )
             {
                 Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
+                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
 
                 textSt += "\nPlayer Position [ "
                     + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
                     + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
                     + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
+
+                textSt += "\nPlayer Orientation [ "
+                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+" ]";
             }
         }
 



From melven at mail.berlios.de  Thu May 10 18:00:36 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 10 May 2007 18:00:36 +0200
Subject: [Dsa-hl-svn] r3427 - rl/trunk/engine/ui/src
Message-ID: <200705101600.l4AG0aRZ018210@sheep.berlios.de>

Author: melven
Date: 2007-05-10 17:59:06 +0200 (Thu, 10 May 2007)
New Revision: 3427

Modified:
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
Setting player orientation via a spring-acceleration-system (works now with new version of ogre, but does probably not work with the old one!)

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-10 15:53:18 UTC (rev 3426)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-10 15:59:06 UTC (rev 3427)
@@ -80,7 +80,7 @@
         mCharacterState(),
         mDesiredDistance(2.00),
         mDistanceRange(0.60, 7.00),
-        mYaw(0),
+        mYaw(180),
         mCamYaw(0),
         mCamVirtualYaw(0),
         mPitch(20),
@@ -835,7 +835,7 @@
 
 
         // ---------------------------- show animation -----------------------------
-        if (newAnimation != "")
+        if (newAnimation != "" && newAnimation != "drehen_links" && newAnimation != "drehen_rechts" )
         {
             // nur schneller nicht langsamer ausfhren!
             if (animSpeed < 1) animSpeed = 1;
@@ -1181,35 +1181,21 @@
 
             // Calculate angular velocity
             // We first need the yaw rotation from actual yaw to desired yaw
-            Vector3 src = orientation*Vector3::NEGATIVE_UNIT_Z;
+            Vector3 src = orientation*Vector3::UNIT_Z;
             src.y = 0;
             Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
             dst.y = 0;
-            Radian yaw = src.getRotationTo(dst).getYaw();
+            Radian yaw = src.getRotationTo(dst, Vector3::UNIT_Y).getYaw();
 
-/*
-            // was soll dieser komische Fehler?
-            // wenn yaw 0 sein sollte, wird er manchmal zu -90 grad, find ich nich nett
-            if( (yaw.valueDegrees() - (-90)) < 0.5 )
-                if( src.directionEquals(-dst, Degree(45)) )
-                    yaw = Degree(0);
-*/
-            if( src.directionEquals(dst, Degree(1)))
-                yaw = Degree(0);
 
-            // Calculate omega in order to go this rotation in mMaxDelay seconds.
-            // Real newOmega = yaw.valueRadians() / mMaxDelay;
+            // using a spring system to apply the rotation
             Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
             Vector3 omega = mCharBody->getOmega();
             omega.x = omega.z = 0;
-            // sollte nicht direkt gesetzt werden!
-            Vector3 springAcc = -mRotLinearSpringK*diff - mRotLinearDampingK * omega;
+            // should not set directly orientation!
+            Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
             //body->setOmega(Vector3(0, newOmega, 0)); // omega sollte nicht direkt gesetzt werden
-//            body->setTorque( mass * springAcc );
-
-            // All this doesn't work correctly with the new version of ogre
-            // So we set the orientation directly until the problem is solved
-            mCharacterActor->setOrientation(Quaternion(mYaw, Vector3::UNIT_Y));
+            body->setTorque( mass * springAcc );
         }
 
 



From timm at mail.berlios.de  Thu May 10 18:33:39 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 10 May 2007 18:33:39 +0200
Subject: [Dsa-hl-svn] r3428 - in rl/trunk/engine: rules/include rules/src
	ui/src
Message-ID: <200705101633.l4AGXdfL030009@sheep.berlios.de>

Author: timm
Date: 2007-05-10 18:33:18 +0200 (Thu, 10 May 2007)
New Revision: 3428

Modified:
   rl/trunk/engine/rules/include/Selector.h
   rl/trunk/engine/rules/src/Selector.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
MovmentCharacterController: Filter f?\195?\188r InScene GameObjects eingebaut

Modified: rl/trunk/engine/rules/include/Selector.h
===================================================================
--- rl/trunk/engine/rules/include/Selector.h	2007-05-10 15:59:06 UTC (rev 3427)
+++ rl/trunk/engine/rules/include/Selector.h	2007-05-10 16:33:18 UTC (rev 3428)
@@ -48,6 +48,15 @@
         unsigned int mAlignment;
     };
 
+    class _RlRulesExport InSceneSelectionFilter : public SelectionFilter
+    {
+    public:
+        InSceneSelectionFilter();
+
+        /// Return true, if the GameObject is in scene with properties as set in the filter.
+        virtual bool pass(GameObject*) const;
+    };
+
     /// Superclass for all Selectors in RL.
     /// Selectors provide a way to query for GameObjects in a game.
     /// Either in the scene, or inventory, or anywhere else.

Modified: rl/trunk/engine/rules/src/Selector.cpp
===================================================================
--- rl/trunk/engine/rules/src/Selector.cpp	2007-05-10 15:59:06 UTC (rev 3427)
+++ rl/trunk/engine/rules/src/Selector.cpp	2007-05-10 16:33:18 UTC (rev 3428)
@@ -44,6 +44,19 @@
         return false;
     }
 
+    InSceneSelectionFilter::InSceneSelectionFilter()
+    {
+    }
+
+    bool InSceneSelectionFilter::pass(GameObject* go) const
+    {
+        if (go->getState() == GOS_IN_SCENE)
+        {
+            return true;
+        }
+        return false;
+    }
+
     Selector::Selector(unsigned long mask) : mSelection(), mSelectionMask(mask), mFilter(NULL)
     {
     }

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-10 15:59:06 UTC (rev 3427)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-10 16:33:18 UTC (rev 3428)
@@ -137,6 +137,8 @@
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
         mCombatSelector.setFilter(filter);
+
+        mSelector.setFilter(new InSceneSelectionFilter());
     }
 
     //------------------------------------------------------------------------



From tanis at mail.berlios.de  Thu May 10 19:01:43 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 10 May 2007 19:01:43 +0200
Subject: [Dsa-hl-svn] r3429 - dependencies/opensteer/win32
Message-ID: <200705101701.l4AH1hKh031004@sheep.berlios.de>

Author: tanis
Date: 2007-05-10 19:01:27 +0200 (Thu, 10 May 2007)
New Revision: 3429

Modified:
   dependencies/opensteer/win32/opensteer.vcproj
Log:
OBJ files are noe put in configuration depending directories, in order to prevent inadvertent mixing of debug/release object files.

Modified: dependencies/opensteer/win32/opensteer.vcproj
===================================================================
--- dependencies/opensteer/win32/opensteer.vcproj	2007-05-10 16:33:18 UTC (rev 3428)
+++ dependencies/opensteer/win32/opensteer.vcproj	2007-05-10 17:01:27 UTC (rev 3429)
@@ -18,7 +18,7 @@
 		<Configuration
 			Name="Debug|Win32"
 			OutputDirectory="..\lib"
-			IntermediateDirectory=".\obj"
+			IntermediateDirectory=".\obj\$(ConfigurationName)"
 			ConfigurationType="4"
 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
 			CharacterSet="2"
@@ -91,7 +91,7 @@
 		<Configuration
 			Name="Release|Win32"
 			OutputDirectory="..\lib"
-			IntermediateDirectory=".\obj"
+			IntermediateDirectory=".\obj\$(ConfigurationName)"
 			ConfigurationType="4"
 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
 			CharacterSet="2"



From timm at mail.berlios.de  Thu May 10 20:15:47 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 10 May 2007 20:15:47 +0200
Subject: [Dsa-hl-svn] r3430 - rl/trunk/engine/ui/src
Message-ID: <200705101815.l4AIFlSE010812@sheep.berlios.de>

Author: timm
Date: 2007-05-10 20:15:31 +0200 (Thu, 10 May 2007)
New Revision: 3430

Modified:
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
Log:
play idle animation after the end of a dialog

Modified: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-05-10 17:01:27 UTC (rev 3429)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-05-10 18:15:31 UTC (rev 3430)
@@ -75,6 +75,18 @@
 
     void DialogCharacterController::pause()
     {
+        if(mDialogPartner)
+        {
+            MeshObject* mesh = dynamic_cast<MeshObject*>(mDialogPartner->getControlledObject());
+            if (mesh != NULL)
+            {
+                mesh->stopAllAnimations();
+                if (mesh->hasAnimation("idle"))
+                {
+                    mTalkAnimation = mesh->startAnimation("idle");
+                }
+            }
+        }
         mCameraActor->getPhysicalThing()->unfreeze();
         mCharacterActor->getPhysicalThing()->unfreeze();
         mDialogWindow->setVisible(false, false);



From timm at mail.berlios.de  Thu May 10 21:01:57 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 10 May 2007 21:01:57 +0200
Subject: [Dsa-hl-svn] r3431 - rl/trunk/engine/core/src
Message-ID: <200705101901.l4AJ1vv8013989@sheep.berlios.de>

Author: timm
Date: 2007-05-10 21:01:41 +0200 (Thu, 10 May 2007)
New Revision: 3431

Modified:
   rl/trunk/engine/core/src/GameLoop.cpp
Log:
fixed bug: program goes on running after closing window

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-05-10 18:15:31 UTC (rev 3430)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-05-10 19:01:41 UTC (rev 3431)
@@ -17,6 +17,7 @@
 
 #include <OgreRoot.h>
 #include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
 
 #include "GameTask.h"
 #include "CoreSubsystem.h"
@@ -100,7 +101,7 @@
         mGameTime = mTimer->getMilliseconds() - 50;
 
         // Loop until game exit is requested.
-        while (!mQuitRequested)
+        while (!mQuitRequested && !CoreSubsystem::getSingleton().getRenderWindow()->isClosed())
         {
             _executeOneRenderLoop();
         }



From josch at mail.berlios.de  Thu May 10 22:43:51 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Thu, 10 May 2007 22:43:51 +0200
Subject: [Dsa-hl-svn] r3432 - in rl/trunk/engine/core: include src
Message-ID: <200705102043.l4AKhp6E022730@sheep.berlios.de>

Author: josch
Date: 2007-05-10 22:43:42 +0200 (Thu, 10 May 2007)
New Revision: 3432

Modified:
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/core/src/Makefile.am
Log:
Build problems on Linux fixed: Added LightFadeJob

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-05-10 19:01:41 UTC (rev 3431)
+++ rl/trunk/engine/core/include/Makefile.am	2007-05-10 20:43:42 UTC (rev 3432)
@@ -27,6 +27,7 @@
 	Job.h \
 	JobListener.h \
 	JobScheduler.h \
+	LightFadeJob.h \
 	LightObject.h \
 	LineSetPrimitive.h \
 	ListenerMovable.h \

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-05-10 19:01:41 UTC (rev 3431)
+++ rl/trunk/engine/core/src/Makefile.am	2007-05-10 20:43:42 UTC (rev 3432)
@@ -32,6 +32,7 @@
 	Job.cpp \
 	JobScheduler.cpp \
 	LightObject.cpp \
+	LightFadeJob.cpp \
 	LineSetPrimitive.cpp \
 	ListenerObject.cpp \
 	ListenerMovable.cpp \



From blakharaz at mail.berlios.de  Thu May 10 23:19:32 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 10 May 2007 23:19:32 +0200
Subject: [Dsa-hl-svn] r3433 - in rl/trunk: docs/documents
	engine/script/include engine/script/src
Message-ID: <200705102119.l4ALJWXR025039@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-10 23:19:25 +0200 (Thu, 10 May 2007)
New Revision: 3433

Modified:
   rl/trunk/docs/documents/scene_format_proposal.xml
   rl/trunk/engine/script/include/EntityNodeProcessor.h
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
Log:
MapLoader:
- interface for animation processing
- fog

Modified: rl/trunk/docs/documents/scene_format_proposal.xml
===================================================================
--- rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-10 20:43:42 UTC (rev 3432)
+++ rl/trunk/docs/documents/scene_format_proposal.xml	2007-05-10 21:19:25 UTC (rev 3433)
@@ -180,9 +180,18 @@
         		<skydomesettings curvature="10" tiling = "8" />
         	</sky>
 
-        	<fog type="exp" expdensity="0.001" />
+        	<fog type="exp" density="0.001">
+        	     <colour r="0.3" g="0.3" b="0.3" />
+        	</fog>
 
-        	<fog type="linear" start="0.0" end="1.0"/>
+        	<fog type="exp2" density="0.001">
+        	     <colour r="0.3" g="0.3" b="0.3" />
+        	</fog>
+
+        	<fog type="linear" start="0.0" end="1.0">
+        	     <colour r="0.5" g="0.5" b="0.5" />
+        	</fog>
+
        	</environment>
 
 </rastullahmap>

Modified: rl/trunk/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EntityNodeProcessor.h	2007-05-10 20:43:42 UTC (rev 3432)
+++ rl/trunk/engine/script/include/EntityNodeProcessor.h	2007-05-10 21:19:25 UTC (rev 3433)
@@ -47,7 +47,8 @@
         Ogre::String mResourceGroup;
 
         void createCollision(Ogre::Entity* entity, Ogre::String meshFile, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);
-    };
+		void processAnimation(Ogre::Entity* entity, xercesc_2_7::DOMElement *animationElem);
+	};
 }
 
 #endif // __EntityNodeProcessor_H__

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2007-05-10 20:43:42 UTC (rev 3432)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2007-05-10 21:19:25 UTC (rev 3433)
@@ -18,6 +18,7 @@
 #include <OgreEntity.h>
 #include <OgreMeshManager.h>
 #include <OgreNewt_CollisionPrimitives.h>
+#include <xercesc/dom/DOM.hpp>
 
 #include "CoreSubsystem.h"
 #include "PhysicsManager.h"
@@ -125,6 +126,17 @@
         {
             parentNode->scale(processVector3(scaleElem));
         }
+
+		AutoXMLCh animation("animation");
+		DOMNodeList* list = nodeElem->getElementsByTagName(animation.data());
+		for (XMLSize_t idx = 0; idx < list->getLength(); idx++)
+		{
+			DOMNode* cur = list->item(idx);
+			if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+			{
+				processAnimation(newEnt, static_cast<DOMElement*>(cur));
+			}
+		}
         
         return true;
     }
@@ -278,4 +290,9 @@
         }
 	}
 
+	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, xercesc_2_7::DOMElement *animationElem)
+	{
+		///@todo EntityNodeProcessor::processAnimation
+	}
+
 }

Modified: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-05-10 20:43:42 UTC (rev 3432)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-05-10 21:19:25 UTC (rev 3433)
@@ -104,6 +104,65 @@
 	void EnvironmentProcessor::processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem)
 	{
 		///@todo process fog node
+		if (!XmlHelper::hasAttribute(fogElem, "material"))
+		{
+			LOG_ERROR(
+				Logger::RULES, 
+				"<fog> element must have at least the attribute 'type'.");
+			return;
+		}
+
+		DOMElement* colourElem = XmlHelper::getChildNamed(fogElem, "colour");
+		if (colourElem == NULL)
+		{
+			LOG_ERROR(Logger::RULES, "No fog colour set.");
+			return;
+		}
+		ColourValue fogColour = processColour(colourElem);
+
+		Ogre::String type = XmlHelper::getAttributeValueAsStdString(fogElem, "type");
+		if (type == "exp" || type == "exp2")
+		{
+			if (XmlHelper::hasAttribute(fogElem, "density"))
+			{
+				Ogre::Real density = XmlHelper::getAttributeValueAsReal(fogElem, "density");
+				if (type == "exp")
+				{
+					CoreSubsystem::getSingleton().getWorld()->setFog(
+						World::FOG_EXP, fogColour, density);
+				}
+				else if (type == "exp2")
+				{
+					CoreSubsystem::getSingleton().getWorld()->setFog(
+						World::FOG_EXP2, fogColour, density);
+				}
+			}
+			else
+			{
+				LOG_ERROR(
+					Logger::RULES, type + " fog needs attribute 'density'.");
+			}
+		}
+		else if (type == "linear")
+		{
+			if (XmlHelper::hasAttribute(fogElem, "start")
+				&& XmlHelper::hasAttribute(fogElem, "end"))
+			{
+				Ogre::Real start = XmlHelper::getAttributeValueAsReal(fogElem, "start");
+				Ogre::Real end = XmlHelper::getAttributeValueAsReal(fogElem, "end");
+				CoreSubsystem::getSingleton().getWorld()->setFog(
+					World::FOG_LINEAR, fogColour, 0, start, end);
+			}
+			else
+			{
+				LOG_ERROR(
+					Logger::RULES, "linear fog needs attributes 'start' and 'end'.");
+			}
+		}
+		else
+		{
+			LOG_ERROR(
+				Logger::RULES, type + " is an unknown fog type.");
+		}
 	}
-
 }



From blakharaz at mail.berlios.de  Thu May 10 23:22:39 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 10 May 2007 23:22:39 +0200
Subject: [Dsa-hl-svn] r3434 - in rl/trunk/engine/ai: include src
Message-ID: <200705102122.l4ALMdNt025308@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-10 23:22:32 +0200 (Thu, 10 May 2007)
New Revision: 3434

Modified:
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/include/PhysicalObstacle.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
Log:
Avoid some object copying by returning references

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2007-05-10 21:19:25 UTC (rev 3433)
+++ rl/trunk/engine/ai/include/AiWorld.h	2007-05-10 21:22:32 UTC (rev 3434)
@@ -35,7 +35,7 @@
 
 		/** Returns a list of obstacles for OpenSteer.
 		 */
-		OpenSteer::ObstacleGroup getSteeringObstacles();
+		const OpenSteer::ObstacleGroup& getSteeringObstacles();
 		/** Adds an obstacle to the internal list of obstacles
 		 */
 		void addObstacle(OpenSteer::Obstacle* obstacle);

Modified: rl/trunk/engine/ai/include/PhysicalObstacle.h
===================================================================
--- rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-05-10 21:19:25 UTC (rev 3433)
+++ rl/trunk/engine/ai/include/PhysicalObstacle.h	2007-05-10 21:22:32 UTC (rev 3434)
@@ -36,7 +36,7 @@
             PhysicalObstacle(PhysicalThing *thing);
 			/** explicit default destructor
 			 */
-            virtual ~PhysicalObstacle();
+            ~PhysicalObstacle();
             /** returns the associated OpenSteer::Obstacle.
 			 */
             OpenSteer::Obstacle *getObstacle() const;

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-05-10 21:19:25 UTC (rev 3433)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-05-10 21:22:32 UTC (rev 3434)
@@ -325,10 +325,10 @@
 
 		/** retrieves the neighbours of this SteeringVehicle
 		 */
-		OpenSteer::AVGroup getNeighbors();
+		OpenSteer::AVGroup getNeighbors() const;
 		/** retrieves the obstacles
 		 */
-		OpenSteer::ObstacleGroup getObstacles();
+		const OpenSteer::ObstacleGroup& getObstacles() const;
 
 	//    float _mass;       // mass (defaults to unity so acceleration=force)
     //   float _radius;     // size of bounding sphere, for obstacle avoidance, etc.

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-05-10 21:19:25 UTC (rev 3433)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-05-10 21:22:32 UTC (rev 3434)
@@ -56,7 +56,7 @@
 	mObstacles.push_back(obstacle);	
 }
 
-ObstacleGroup AiWorld::getSteeringObstacles()
+const ObstacleGroup& AiWorld::getSteeringObstacles()
 {
 	return mObstacles;
 }

Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-05-10 21:19:25 UTC (rev 3433)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-05-10 21:22:32 UTC (rev 3434)
@@ -25,8 +25,10 @@
 
 namespace rl {
     PhysicalObstacle::PhysicalObstacle(PhysicalThing *thing)
+		: mPhysicalThing(thing),
+		  mObstacle(NULL)
     {
-        setPhysicalThing(thing);
+        _update();
     }
      
     PhysicalObstacle::~PhysicalObstacle()

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-05-10 21:19:25 UTC (rev 3433)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-05-10 21:22:32 UTC (rev 3434)
@@ -260,11 +260,11 @@
 }
 
 
-AVGroup SteeringVehicle::getNeighbors()
+AVGroup SteeringVehicle::getNeighbors() const
 {
 	AVGroup group;
 	AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
-	AgentManager::VehicleList::iterator itr = list.begin();
+	AgentManager::VehicleList::const_iterator itr = list.begin();
 	for(; itr != list.end(); ++itr)
 	{
 		if( (*itr) != this )
@@ -359,7 +359,7 @@
 	return _maxSpeed = ms;
 }
 
-ObstacleGroup SteeringVehicle::getObstacles()
+const ObstacleGroup& SteeringVehicle::getObstacles() const
 {
 	return AiSubsystem::getSingleton().getWorld()->getSteeringObstacles();
 }



From blakharaz at mail.berlios.de  Thu May 10 23:55:25 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 10 May 2007 23:55:25 +0200
Subject: [Dsa-hl-svn] r3435 - modules/regressiontest/dsa
Message-ID: <200705102155.l4ALtPYo027333@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-10 23:55:14 +0200 (Thu, 10 May 2007)
New Revision: 3435

Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
Log:
Key of show container content window action was renamed -> adapt backpack's properties

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-05-10 21:22:32 UTC (rev 3434)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-05-10 21:55:14 UTC (rev 3435)
@@ -66,9 +66,9 @@
         <property name="volume" type="INTPAIR" data="8,6"/>
         <property name="size" type="INTPAIR" data="2,2"/>
         <property name="actions" type="ARRAY">
-        	<property type="STRING" data="act_showcontainercontent"/>
+        	<property type="STRING" data="showcontainercontent"/>
         </property>
-        <property name="defaultaction" type="STRING" data="act_showcontainercontent"/>
+        <property name="defaultaction" type="STRING" data="showcontainercontent"/>
     </gameobjectclass>
 
     <!-- ErrorHandlingTest -->



From blakharaz at mail.berlios.de  Thu May 10 23:56:42 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 10 May 2007 23:56:42 +0200
Subject: [Dsa-hl-svn] r3436 - rl/trunk/engine/rules/src
Message-ID: <200705102156.l4ALugJ8027406@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-10 23:56:39 +0200 (Thu, 10 May 2007)
New Revision: 3436

Modified:
   rl/trunk/engine/rules/src/GameObject.cpp
Log:
Log error if actions set by properties are not registered at ActionManager

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-05-10 21:55:14 UTC (rev 3435)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-05-10 21:56:39 UTC (rev 3436)
@@ -469,13 +469,17 @@
 				std::vector<Property> vecVal = value.toArray();
 				for (std::vector<Property>::iterator it = vecVal.begin(); it != vecVal.end(); it++)
 				{
-					Action* act = ActionManager::getSingleton().getAction(
-						(*it).toString().c_str());
+					Ogre::String actionName = (*it).toString().c_str();
+					Action* act = ActionManager::getSingleton().getAction(actionName);
 
 					if (act != NULL)
 					{
 						addAction(act);
 					}
+					else
+					{
+						LOG_ERROR(Logger::RULES, "'"+actionName+"' not registered at ActionManager.");
+					}
 				}
 			}
 			else if (key == PROPERTY_DEFAULT_ACTION)



From timm at mail.berlios.de  Fri May 11 00:44:18 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 11 May 2007 00:44:18 +0200
Subject: [Dsa-hl-svn] r3437 - rl/trunk/engine/ui/src
Message-ID: <200705102244.l4AMiIFm025458@sheep.berlios.de>

Author: timm
Date: 2007-05-11 00:43:55 +0200 (Fri, 11 May 2007)
New Revision: 3437

Modified:
   rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp
Log:
removed "anschauen" button from GameObjectInfoWindow

Modified: rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp	2007-05-10 21:56:39 UTC (rev 3436)
+++ rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp	2007-05-10 22:43:55 UTC (rev 3437)
@@ -75,7 +75,11 @@
 		const ActionVector actions = mGameObject->getValidActions(mCharacter);
 		for (ActionVector::const_iterator it = actions.begin(); it != actions.end(); it++)
 		{
-			addActionButton(*it);
+            if ((*it)->getName() != GameObject::DEFAULT_VIEW_OBJECT_ACTION 
+                && (*it)->getName() != GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG)
+            {
+                addActionButton(*it);
+            }
 		}
 	}
 



From melven at mail.berlios.de  Fri May 11 18:41:43 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 11 May 2007 18:41:43 +0200
Subject: [Dsa-hl-svn] r3438 - rl/trunk/engine/ui/src
Message-ID: <200705111641.l4BGfhXn019808@sheep.berlios.de>

Author: melven
Date: 2007-05-11 18:41:31 +0200 (Fri, 11 May 2007)
New Revision: 3438

Modified:
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
some changes of the character-collisions: 
-the char can now overcome little obstacles and steps (like in regressionstest)
-char doesn't bounce any more

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-10 22:43:55 UTC (rev 3437)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-11 16:41:31 UTC (rev 3438)
@@ -993,7 +993,7 @@
             if( mViewMode == VM_FIRST_PERSON )
                 return 0;
 
-            setContactSoftness(1.0f);  // "weiche" Collision
+            setContactSoftness(1.0f);
             setContactElasticity(0.0f);
 
             return 1;
@@ -1018,34 +1018,38 @@
             AxisAlignedBox CharAab = mCharBody->getCollision()->getAABB();
             Real CharHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
             Real stepHeight = point.y - charPos.y;
-            if( stepHeight < 0.4f && mCharacterState.mHasFloorContact ||
-                stepHeight < 0.1f )
+/*
+            if( stepHeight < 0.5f && mCharacterState.mHasFloorContact ||
+                stepHeight < 0.2f )
+*/
+            if( stepHeight < 0.5f )
                 isFloorCollision = true;
 
             if ( isFloorCollision )
             {
                 mCharacterState.mHasFloorContact = true;
+                if(stepHeight > 0.1f)
+                    setContactNormalAcceleration(10);
+                setContactElasticity(0.0f);
             }
             else
             {
+                // what is the aim of this, this does nothing without an setContactTangentAcceleration, doesn't it?
+                //Vector3 velocity = mCharBody->getVelocity();
 
-                Vector3 velocity = mCharBody->getVelocity();
-
                 // calculate char velocity perpendicular to the contact normal
-                Vector3 tangentVel = velocity - normal * (normal.dotProduct(velocity));
+                //Vector3 tangentVel = velocity - normal * (normal.dotProduct(velocity));
 
                 // align the tangent at the contact point with the
                 // tangent velocity vector of the char
-                rotateTangentDirections(tangentVel);
+                //rotateTangentDirections(tangentVel);
+                
             }
 
 
-            // beinflusst die Sprungh?e!
-            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef?r um
-            // die angegebene Zahl h?er (eher 2*die angegebene Zahl oder so,
-            // vermutlich wieder framedauer abh?gig!)
-            setContactElasticity(0.3f); // was 0.3f
-            setContactSoftness(0.01f);
+            // perhaps ContactElasticity and ContactSoftness should not be overwritten
+            //setContactElasticity(?);
+            //setContactSoftness(?);
 
             setContactFrictionState(1, 0);
             setContactFrictionState(1, 1);



From timm at mail.berlios.de  Fri May 11 20:49:12 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 11 May 2007 20:49:12 +0200
Subject: [Dsa-hl-svn] r3439 - in rl/trunk/engine/ui: include src
Message-ID: <200705111849.l4BInCKS023350@sheep.berlios.de>

Author: timm
Date: 2007-05-11 20:49:09 +0200 (Fri, 11 May 2007)
New Revision: 3439

Modified:
   rl/trunk/engine/ui/include/ContainerContentWindow.h
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
Log:
Execute actions after double click/right mouse button click on item

Modified: rl/trunk/engine/ui/include/ContainerContentWindow.h
===================================================================
--- rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-05-11 16:41:31 UTC (rev 3438)
+++ rl/trunk/engine/ui/include/ContainerContentWindow.h	2007-05-11 18:49:09 UTC (rev 3439)
@@ -38,6 +38,8 @@
 		static int sItemCount;
 
 		bool handleItemDroppedOnContainer(const CEGUI::EventArgs& evt);
+        bool handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
+        bool handleItemDoubleClick(const CEGUI::EventArgs& evt, Item* item);
 		void initializeContent();
 		CEGUI::Window* createItemWindow(Item* item);
 	};

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-05-11 16:41:31 UTC (rev 3438)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-05-11 18:49:09 UTC (rev 3439)
@@ -24,6 +24,7 @@
 #include "Container.h"
 #include "InventoryWindow.h"
 #include "ItemDragContainer.h"
+#include "WindowFactory.h"
 
 using namespace CEGUI;
 
@@ -65,6 +66,14 @@
 					cegui_absdim(pos.first*30),
 					cegui_absdim(pos.second*30)));
 
+            itemWindow->subscribeEvent(
+                Window::EventMouseClick,
+                boost::bind(&ContainerContentWindow::handleItemMouseClick, this, _1, item));
+
+            itemWindow->subscribeEvent(
+                Window::EventMouseDoubleClick,
+                boost::bind(&ContainerContentWindow::handleItemDoubleClick, this, _1, item));
+
 			mContentWindow->addChildWindow(itemWindow);
 		}
 	}
@@ -152,4 +161,32 @@
 
 		return itemhandler;
 	}
+
+    bool ContainerContentWindow::handleItemMouseClick(const EventArgs& evt, Item* item)
+    {
+        const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);
+        if (mevt.button == RightButton)
+        {
+            WindowFactory::getSingleton().showActionChoice(item);
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    bool ContainerContentWindow::handleItemDoubleClick(const EventArgs& evt, Item* item)
+    {
+        const MouseEventArgs& mevt = static_cast<const MouseEventArgs&>(evt);
+        if (mevt.button == LeftButton)
+        {
+            item->doDefaultAction(NULL,NULL);
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
 }



From timm at mail.berlios.de  Fri May 11 21:51:56 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 11 May 2007 21:51:56 +0200
Subject: [Dsa-hl-svn] r3440 - rl/trunk/engine/ui/src
Message-ID: <200705111951.l4BJpuUr028651@sheep.berlios.de>

Author: timm
Date: 2007-05-11 21:51:53 +0200 (Fri, 11 May 2007)
New Revision: 3440

Modified:
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
Log:
changing from first person view to dialog: character stayed invisible

Modified: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-05-11 18:49:09 UTC (rev 3439)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-05-11 19:51:53 UTC (rev 3440)
@@ -95,6 +95,8 @@
 
     void DialogCharacterController::resume()
     {
+        mCharacterActor->setVisible(true);
+
         mCameraActor->getPhysicalThing()->freeze();
         mCharacterActor->getPhysicalThing()->freeze();
         Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());



From blakharaz at mail.berlios.de  Sat May 12 18:14:19 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 12 May 2007 18:14:19 +0200
Subject: [Dsa-hl-svn] r3441 - in tools/mesh_combiner: . include src
Message-ID: <200705121614.l4CGEJi5001552@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-12 18:14:14 +0200 (Sat, 12 May 2007)
New Revision: 3441

Added:
   tools/mesh_combiner/include/MeshCombinerPrerequisites.h
Modified:
   tools/mesh_combiner/include/MergeMesh.h
   tools/mesh_combiner/meshcombiner.vcproj
   tools/mesh_combiner/src/MergeMesh.cpp
Log:
Configuration for use as DLL

Modified: tools/mesh_combiner/include/MergeMesh.h
===================================================================
--- tools/mesh_combiner/include/MergeMesh.h	2007-05-11 19:51:53 UTC (rev 3440)
+++ tools/mesh_combiner/include/MergeMesh.h	2007-05-12 16:14:14 UTC (rev 3441)
@@ -1,12 +1,15 @@
 #ifndef __MergeMesh_H__
 #define __MergeMesh_H__
 
+#include "MeshCombinerPrerequisites.h"
+
 #include <vector>
 #include <OgreMesh.h>
 #include <OgreSkeleton.h>
 
-namespace rl {
-    class MergeMesh
+namespace rl 
+{
+    class _MCExport MergeMesh
 	{
 		public:
 			MergeMesh();
@@ -17,6 +20,7 @@
             Ogre::MeshPtr bake();
 		private: 
             const Ogre::String findSubmeshName( Ogre::MeshPtr m, Ogre::ushort sid ) const;
+			void log(const Ogre::String& message) const;
 
             Ogre::SkeletonPtr m_BaseSkeleton;
             std::vector< Ogre::MeshPtr > m_Meshes;

Added: tools/mesh_combiner/include/MeshCombinerPrerequisites.h
===================================================================
--- tools/mesh_combiner/include/MeshCombinerPrerequisites.h	2007-05-11 19:51:53 UTC (rev 3440)
+++ tools/mesh_combiner/include/MeshCombinerPrerequisites.h	2007-05-12 16:14:14 UTC (rev 3441)
@@ -0,0 +1,17 @@
+#ifndef __MeshCombinerPrerequisites_H__
+#define __MeshCombinerPrerequisites_H__
+
+#include <OgrePlatform.h>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+// Export control
+#   if defined( MESHCOMBINER_EXPORTS )
+#       define _MCExport __declspec( dllexport )
+#   else
+#       define _MCExport __declspec( dllimport )
+#   endif
+#else // Linux / Mac OSX etc
+#   define _MCExport
+#endif
+
+#endif // __MeshCombinerPrerequisites_H__

Modified: tools/mesh_combiner/meshcombiner.vcproj
===================================================================
--- tools/mesh_combiner/meshcombiner.vcproj	2007-05-11 19:51:53 UTC (rev 3440)
+++ tools/mesh_combiner/meshcombiner.vcproj	2007-05-12 16:14:14 UTC (rev 3441)
@@ -41,7 +41,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="0"
 				AdditionalIncludeDirectories="include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\ogrenew\Dependencies\include"
-				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;MESHCOMBINER_EXPORTS"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="3"
@@ -128,7 +128,7 @@
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories="include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\ogrenew\Dependencies\include"
-				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;MESHCOMBINER_EXPORTS"
 				RuntimeLibrary="2"
 				EnableEnhancedInstructionSet="1"
 				UsePrecompiledHeader="0"
@@ -187,6 +187,178 @@
 				CommandLine="copy $(TargetPath)  .\dist\$(TargetFileName)"
 			/>
 		</Configuration>
+		<Configuration
+			Name="Debug_DLL|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\ogrenew\Dependencies\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;MESHCOMBINER_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				BrowseInformation="1"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="OgreMain_d.lib"
+				OutputFile="lib\meshcombiner_d.dll"
+				Version="0.1d"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib\"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/meshcombiner.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy $(TargetPath)  .\dist\$(TargetFileName)"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release_DLL|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="3"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\ogrenew\Dependencies\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;MESHCOMBINER_EXPORTS"
+				RuntimeLibrary="2"
+				EnableEnhancedInstructionSet="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				AdditionalIncludeDirectories="/include"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="OgreMain.lib"
+				OutputFile="lib\meshcombiner.dll"
+				Version="0.1"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\dependencies\ogrenew\lib\"
+				GenerateDebugInformation="false"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				OptimizeForWindows98="1"
+				SetChecksum="true"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy $(TargetPath)  .\dist\$(TargetFileName)"
+			/>
+		</Configuration>
 	</Configurations>
 	<References>
 	</References>
@@ -230,6 +402,10 @@
 				RelativePath=".\include\MeshCombiner.h"
 				>
 			</File>
+			<File
+				RelativePath=".\include\MeshCombinerPrerequisites.h"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Ressourcendateien"

Modified: tools/mesh_combiner/src/MergeMesh.cpp
===================================================================
--- tools/mesh_combiner/src/MergeMesh.cpp	2007-05-11 19:51:53 UTC (rev 3440)
+++ tools/mesh_combiner/src/MergeMesh.cpp	2007-05-12 16:14:14 UTC (rev 3441)
@@ -28,19 +28,19 @@
 	{    
         if( mesh->getSkeleton().isNull() )
         {
-            MeshCombiner::getSingleton().log( "Skipped: " + mesh->getName() + " has no skeleton" );
-            return;
+			log( "Skipped: " + mesh->getName() + " has no skeleton" );
+		    return;
         }
 
         if( m_BaseSkeleton.isNull() )
         {
             m_BaseSkeleton = mesh->getSkeleton();                    
-            MeshCombiner::getSingleton().log( "Set: base skeleton (" + m_BaseSkeleton->getName()+")" );
+            log( "Set: base skeleton (" + m_BaseSkeleton->getName()+")" );
         }
 
         if( mesh->getSkeleton() != m_BaseSkeleton )
         {
-            MeshCombiner::getSingleton().log( "Skipped: " + mesh->getName() + " has other skeleton ("+ mesh->getSkeleton()->getName() +")" );
+	        log( "Skipped: " + mesh->getName() + " has other skeleton ("+ mesh->getSkeleton()->getName() +")" );
             return;
         }
 
@@ -62,7 +62,7 @@
 
     MeshPtr MergeMesh::bake()
     {    
-        MeshCombiner::getSingleton().log( 
+        log( 
              "Baking: New Mesh started" );
 
         MeshPtr mp = MeshManager::getSingleton().
@@ -73,7 +73,7 @@
         for( std::vector< Ogre::MeshPtr >::iterator it = m_Meshes.begin();
              it != m_Meshes.end(); ++it )
         {   
-            MeshCombiner::getSingleton().log( 
+            log( 
                 "Baking: adding submeshes for " + (*it)->getName() );
 
             // insert all submeshes
@@ -102,38 +102,39 @@
                 
                     // build bone assignments
                     SubMesh::BoneAssignmentIterator bit = sub->getBoneAssignmentIterator();
-                    while( bit.hasMoreElements() )
+                    while (bit.hasMoreElements())
                     {
                         VertexBoneAssignment vba = bit.getNext();
-                        newsub->addBoneAssignment( vba );
+                        newsub->addBoneAssignment(vba);
                     }
                 }
 
                 newsub->setMaterialName( sub->getMaterialName() );
 
-                MeshCombiner::getSingleton().log(  
-                    "Baking: adding submesh '" + name + "'  with material " + sub->getMaterialName() );
+                log("Baking: adding submesh '" + name + "'  with material " + sub->getMaterialName());
             } 
 
             // sharedvertices
-            if( (*it)->sharedVertexData != NULL )
+            if ((*it)->sharedVertexData)
             {
                 /// @todo merge with existing sharedVertexData
-                mp->sharedVertexData = (*it)->sharedVertexData->clone();
+                if (!mp->sharedVertexData)
+				{
+					mp->sharedVertexData = (*it)->sharedVertexData->clone();
+				}
 
                 Mesh::BoneAssignmentIterator bit = (*it)->getBoneAssignmentIterator();
-                while( bit.hasMoreElements() )
+                while (bit.hasMoreElements())
                 {
                     VertexBoneAssignment vba = bit.getNext();
-                    mp->addBoneAssignment( vba );
+                    mp->addBoneAssignment(vba);
                 }
             }
 
-            MeshCombiner::getSingleton().log( 
-                "Baking: adding bounds for " + (*it)->getName() );
+            log("Baking: adding bounds for " + (*it)->getName());
 
             // add bounds
-            totalBounds.merge( (*it)->getBounds() );
+            totalBounds.merge((*it)->getBounds());
         }           
         mp->_setBounds( totalBounds );
 
@@ -143,7 +144,7 @@
         /// @todo add parameters
         mp->buildEdgeList();
 
-        MeshCombiner::getSingleton().log( 
+        log( 
             "Baking: Finished" );
 
         return mp;
@@ -197,5 +198,13 @@
                     VertexDeclaration* decl = newsub->vertexData->vertexDeclaration;
                     VertexBufferBinding* bind = newsub->vertexData->vertexBufferBinding;*/
 
+
+	void MergeMesh::log(const Ogre::String& message) const
+	{
+		if (MeshCombiner::getSingletonPtr())
+		{
+			MeshCombiner::getSingleton().log(message);
+		}
+	}
 }
 



From josch at mail.berlios.de  Sun May 13 17:44:09 2007
From: josch at mail.berlios.de (josch at mail.berlios.de)
Date: Sun, 13 May 2007 17:44:09 +0200
Subject: [Dsa-hl-svn] r3442 - modules/common/dsa modules/common/scripts
	modules/regressiontest/scripts modules/regressiontest/scripts/maps
	rl/trunk/engine/core/include rl/trunk/engine/core/src
	rl/trunk/engine/script/swig rl/trunk/engine/ui/src
Message-ID: <200705131544.l4DFi9R9031386@sheep.berlios.de>

Author: josch
Date: 2007-05-13 17:43:41 +0200 (Sun, 13 May 2007)
New Revision: 3442

Modified:
   modules/common/dsa/gameobjectdefinitions.gof
   modules/common/scripts/globals.rb
   modules/common/scripts/torch.rb
   modules/regressiontest/scripts/SoundTest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
   rl/trunk/engine/core/include/Sound.h
   rl/trunk/engine/core/include/SoundManager.h
   rl/trunk/engine/core/include/SoundObject.h
   rl/trunk/engine/core/src/PlaySoundJob.cpp
   rl/trunk/engine/core/src/SoundManager.cpp
   rl/trunk/engine/core/src/SoundObject.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/ui/src/InputManager.cpp
Log:
- Made some changes to the sound system to let Ruby use classes SoundObject and Sound if the sound jobs aren't sufficent.
- SoundTest now works. Lighting the torches let you hear 3D sounds.
- Animations for the torches are still missing.

Modified: modules/common/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/common/dsa/gameobjectdefinitions.gof	2007-05-12 16:14:14 UTC (rev 3441)
+++ modules/common/dsa/gameobjectdefinitions.gof	2007-05-13 15:43:41 UTC (rev 3442)
@@ -27,8 +27,6 @@
 
 
 	<gameobjectclass classid="torch" baseclass="Torch">
-		<property name="classid" type="STRING" data="torch"/>
-		<property name="baseclass" type="STRING" data="Torch"/>
 		<property name="description" type="STRING" data="Eine Fackel"/>
 		<property name="geometrytype" type="STRING" data="convexhull"/>
 		<property name="meshfile" type="STRING" data="ins_fackel_01.mesh"/>

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2007-05-12 16:14:14 UTC (rev 3441)
+++ modules/common/scripts/globals.rb	2007-05-13 15:43:41 UTC (rev 3442)
@@ -22,6 +22,7 @@
 $GameEveMgr = GameEventManager.getSingleton();
 $AnimMgr = AnimationManager.getSingleton();
 $GOM = GameObjectManager.getSingleton();
+$SM = SoundManager.getSingleton();
 
 class HeroPosWriter
   def initialize()

Modified: modules/common/scripts/torch.rb
===================================================================
--- modules/common/scripts/torch.rb	2007-05-12 16:14:14 UTC (rev 3441)
+++ modules/common/scripts/torch.rb	2007-05-13 15:43:41 UTC (rev 3442)
@@ -5,11 +5,14 @@
 # einiger Klassen f??r Instanzen anderer Klassen nachgenutzt werden?
 # Inwiefern ist Deferred Construction sinnvoll?
 load "embed.rb"
+require 'gameobjectprops.rb'
+require 'jobs/soundjobs.rb'
+require 'jobs/animationjobs.rb'
 
 # Die Aktion f??r das Anz??nden der Fackel.
 class LightTorchAction < Action
-    def initialize
-        super("Anz??nden", "Die Fackel anz??nden f??r mehr Licht und so.");
+    def initialize()
+        super("lighttorch", "Die Fackel anz??nden f??r mehr Licht und so.");
     end
     
     # Die Methode pr??ft, ob die Aktion ??berhaupt angeboten wird.
@@ -29,9 +32,8 @@
         # an der Stelle nur dumm und macht was Ruby sagt.
         
         torchActor = torch.getActor();
-        torchActor.getChildBySlotAndIndex(Slots.SLOT_FAR_END, 0).activate();
-        torchActor.getChildByName("TorchSparks").activate();
-        torchActor.getChildByName("TorchCrackle").activate();
+        #torchActor.getChildByName("TorchSparks").activate();
+        #torchActor.getChildByName("TorchCrackle").activate();
         # Activation sollte folgenderma??en geregelt sein:
         #       ist Child activated, so wird er angezeigt/erklingt
         #       wenn Parent-Activation true ist, sonst nicht
@@ -40,7 +42,8 @@
         
         #TODO timer setzen, damit die Fackel nach Ablauf ihrer Lebensdauer
         # ausgeht.
-        
+        torch.sound.getSound().setPosition(torchActor.getPosition())
+        torch.sound.play()
         torch.setLit(true);
     end
 end
@@ -48,7 +51,7 @@
 # Die Aktion f??r das L??schen der Fackel.
 class PutoutTorchAction < Action
     def initialize
-        super("L??schen", "Die Fackel l??schen f??r Verstecken und so.");
+        super("putouttorch", "Die Fackel l??schen f??r Verstecken und so.");
     end
     
     # Die Methode pr??ft, ob die Aktion ??berhaupt angeboten wird.
@@ -68,9 +71,8 @@
         # an der Stelle nur dumm und macht was Ruby sagt.
         
         torchActor = torch.getActor();
-        torchActor.getChildBySlotAndIndex(Slots.SLOT_FAR_END, 0).deactivate();
-        torchActor.getChildByName("TorchSparks").deactivate();
-        torchActor.getChildByName("TorchCrackle").deactivate();
+        #torchActor.getChildByName("TorchSparks").deactivate();
+        #torchActor.getChildByName("TorchCrackle").deactivate();
         # Activation sollte folgenderma??en geregelt sein:
         #       ist Child activated, so wird er angezeigt/erklingt
         #       wenn Parent-Activation true ist, sonst nicht
@@ -79,29 +81,32 @@
         
         #TODO timer setzen, damit die Fackel nach Ablauf ihrer Lebensdauer
         # ausgeht.
-        
+        torch.sound.stop();
         torch.setLit(false);
     end
 end
 
 # TODO Physikalische Attribute etc..
 # TODO Persistenz *schreck*
-class Torch < Item
-
+class Torch < GameObject
     include GameObjectProperties
     
     def initialize(id)
-        super(id);
+        super(id)
     end
     
     def setLit(lit)
-        @_prop_Lit = lit;
+        @_prop_Lit = lit
     end
     
     def lit?
-        @_prop_Lit;
+        @_prop_Lit
     end
     
+    def sound
+        @_prop_Sound
+    end
+    
     def setProperty(name, value)
         if name == "sound"
             @_prop_Sound = value
@@ -109,11 +114,17 @@
             @_prop_Lit = value
         elsif name == "lightable"
             @_prop_Lightable = value
+        else
+            super(name, value)
         end
     end
     
     def placeIntoScene()
         super()
+        sound = $SM.createSound("feuer_knisternd_01.ogg")
+        sound.setLooping(true)
+        sound.set3d(true)
+        @_prop_Sound = SoundObject.new(sound, getId().to_s())
         addActions()
     end
     

Modified: modules/regressiontest/scripts/SoundTest.rb
===================================================================
--- modules/regressiontest/scripts/SoundTest.rb	2007-05-12 16:14:14 UTC (rev 3441)
+++ modules/regressiontest/scripts/SoundTest.rb	2007-05-13 15:43:41 UTC (rev 3442)
@@ -1,5 +1,4 @@
 require 'testcase.rb'
-#require 'math.rb'
 require 'torch.rb'
 
 class SoundTest < TestCase
@@ -12,6 +11,12 @@
     def initialize(center)
         super(center)
   
+        min_base = [-@@radius, 0.05, -@@radius]
+        max_base = [@@radius, 0.3, @@radius]
+        base = $AM.createBoxPrimitiveActor("SoundTestBase",
+                                           min_base, max_base, "alpha_blue")
+        base.placeIntoScene(center);
+
         step = 2 * PI / @@torchcount
         0.step(2 * PI, step) do |radian|
             x = cos(radian) * @@radius
@@ -19,6 +24,7 @@
             fackel = $GOM.createGameObject("torch")
             fackel.setDescription("Fackel" + radian.to_s)
             fackel.setPosition(rel_pos([x, @@height, y]))
+            fackel.setLit(true)
             fackel.placeIntoScene()
         end
         

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-05-12 16:14:14 UTC (rev 3441)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-05-13 15:43:41 UTC (rev 3442)
@@ -50,7 +50,7 @@
 InventoryTest.new([0, 0, 10])
 JobSequenceTest.new([5, 0, -5])
 EffectTest.new([5, 0, 5])
-SoundTest.new([10, 0, 10])
+SoundTest.new([15, 0, 10])
 LightzoneTest.new([-10, 0, -5])
 MapLoadingTest.new([-5, 0, -10])
 

Modified: rl/trunk/engine/core/include/Sound.h
===================================================================
--- rl/trunk/engine/core/include/Sound.h	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/core/include/Sound.h	2007-05-13 15:43:41 UTC (rev 3442)
@@ -43,7 +43,7 @@
         public EventCaster<SoundEvent>, public EventSource
     {
     public:
-        // Einige Standardwerte f?r Soundpriorit?ten.
+        // Einige Standardwerte f??r Soundpriorit??ten.
         enum SOUND_PRIORITY {
             PRIO_SPEECH = 30,
             PRIO_MUSIC = 75,

Modified: rl/trunk/engine/core/include/SoundManager.h
===================================================================
--- rl/trunk/engine/core/include/SoundManager.h	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/core/include/SoundManager.h	2007-05-13 15:43:41 UTC (rev 3442)
@@ -25,12 +25,12 @@
 #include <list>
 
 #include "GameTask.h"
+#include "SoundDriver.h"
 
 namespace rl {
 
 class Actor;
 class ListenerObject;
-class SoundDriver;
 class SoundManager;
 class SoundUpdateTask;
 
@@ -56,7 +56,7 @@
         SoundManager();
         virtual ~SoundManager();
 
-        /// Den aktiven Listener zur?ckgeben.
+        /// Den aktiven Listener zurckgeben.
         ListenerObject* getListener() const;
         /// Creates the listener actor.
         Actor* createListenerActor();
@@ -87,7 +87,7 @@
 
         /// 3D-Sound aktualisieren.
         void update();
-        /// Den aktiven Treiber zur?ckgeben.
+        /// Den aktiven Treiber zurckgeben.
         SoundDriver* getActiveDriver() const;
         /// Den aktiven Treiber setzen.
         void setActiveDriver(SoundDriver *driver);
@@ -100,6 +100,11 @@
         virtual void run( Ogre::Real elapsedTime );
 
         virtual const Ogre::String& getName() const;
+        
+        // Delegate sound creation to the driver
+        Sound* createSound(const Ogre::String& res, SoundType type=ST_SAMPLE);
+        Sound* createSound(const SoundResourcePtr& res, SoundType type=ST_SAMPLE);
+        void destroySound(Sound*);
 
     protected:
         virtual Ogre::Resource* createImpl(const Ogre::String& name, Ogre::ResourceHandle handle,

Modified: rl/trunk/engine/core/include/SoundObject.h
===================================================================
--- rl/trunk/engine/core/include/SoundObject.h	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/core/include/SoundObject.h	2007-05-13 15:43:41 UTC (rev 3442)
@@ -27,7 +27,7 @@
 
     class Sound;
     
-    /** Klasse f?r alle Soundobjekte, die man an einen Aktor
+    /** Klasse fr alle Soundobjekte, die man an einen Aktor
      *  heften kann. Zwischen Actor und ActorControlledObject
      *  besteht eine 1:1-Beziehung.
      */
@@ -39,9 +39,9 @@
         
         /**
          * Interne Methode. Wird vom Aktor aufgerufen, wenn sich dessen
-         * Status ge?ndert hat. (Position, Orientierung, etc)
+         * Status gendert hat. (Position, Orientierung, etc)
          * Die Standardimplementierung macht nichts, kann aber
-         * von abgeleiteten Klassen ?berschrieben werden.
+         * von abgeleiteten Klassen berschrieben werden.
          */
         virtual void _update();
         
@@ -55,7 +55,7 @@
 		bool is3d() const;
 		void set3d( bool is3d );
 
-        /// Gibt zur?ck ob der Sound geloopt werden soll 
+        /// Gibt zurck ob der Sound geloopt werden soll 
         bool isLooping() const;
         /// Setzt ob der Sound geloopt werden soll 
         void setLooping( bool looping );
@@ -65,7 +65,7 @@
         bool isPaused() const;
         /// Stoppt den Sound.
         virtual void stop();
-		/// Setzt die Lautstaerke (1.0 = volle Lautst?rke)
+		/// Setzt die Lautstaerke (1.0 = volle Lautstrke)
 		void setVolume(float volume = 1.0);
         // Sets the priority of this sound
         void setPriority(const int priority);
@@ -74,12 +74,12 @@
 
 		float getLength() const;
 
-		/// L?dt den Ton
+		/// Ldt den Ton
 		virtual void load();
-        /// Entl?dt den Sound.
+        /// Entldt den Sound.
         virtual void unload();
         
-        void play();
+        void play(bool destroyWhenDone=false);
 
         /// Starte den Sound
         void start();

Modified: rl/trunk/engine/core/src/PlaySoundJob.cpp
===================================================================
--- rl/trunk/engine/core/src/PlaySoundJob.cpp	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/core/src/PlaySoundJob.cpp	2007-05-13 15:43:41 UTC (rev 3442)
@@ -27,7 +27,7 @@
     PlaySound2dJob::PlaySound2dJob(const String& sound, Real volume, int priority)
         : Job(false, true), mSound(NULL), mExecuted(false)
     {
-        mSound = SoundManager::getSingleton().getActiveDriver()->createSound(sound, ST_SAMPLE);
+        mSound = SoundManager::getSingleton().createSound(sound, ST_SAMPLE);
         mSound->set3d(false);
         mSound->setVolume(volume);
         mSound->setLooping(false);
@@ -40,7 +40,7 @@
         // because else the sound gets destroyed automatically.
         if(!mExecuted)
         {
-            SoundManager::getSingleton().getActiveDriver()->destroySound(mSound);
+            SoundManager::getSingleton().destroySound(mSound);
         }
     }
 
@@ -54,7 +54,7 @@
     PlaySound3dJob::PlaySound3dJob(const String& sound, const Ogre::Vector3& pos, Real volume, int priority)
         : Job(false, true), mSound(NULL), mExecuted(false)
     {
-        mSound = SoundManager::getSingleton().getActiveDriver()->createSound(sound, ST_SAMPLE);
+        mSound = SoundManager::getSingleton().createSound(sound, ST_SAMPLE);
         mSound->set3d(true);
         mSound->setPosition(pos);
         mSound->setVolume(volume);
@@ -68,7 +68,7 @@
         // because else the sound gets destroyed automatically.
         if(!mExecuted)
         {
-            SoundManager::getSingleton().getActiveDriver()->destroySound(mSound);
+            SoundManager::getSingleton().destroySound(mSound);
         }
     }
 

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-05-13 15:43:41 UTC (rev 3442)
@@ -347,5 +347,45 @@
     return NAME;
 }
 
+/**
+ * @author JoSch
+ * @date 20-04-2007
+ * Delegate sound creation to active driver
+ */
+Sound* SoundManager::createSound(const Ogre::String& res, SoundType type)
+{
+    if (getActiveDriver() != NULL)
+    {
+        return getActiveDriver()->createSound(res, type);
+    }
+    return NULL;
+}
+    
+/**
+ * @author JoSch
+ * @date 20-04-2007
+ * Delegate sound creation to active driver
+ */
+Sound* SoundManager::createSound(const SoundResourcePtr& res, SoundType type)
+{
+    if (getActiveDriver() != NULL)
+    {
+        return getActiveDriver()->createSound(res, type);
+    }
+    return NULL;
+}
 
+/**
+ * @author JoSch
+ * @date 20-04-2007
+ * Delegate sound destruction to active driver
+ */
+void SoundManager::destroySound(Sound* sound)
+{
+    if (getActiveDriver() != NULL)
+    {
+        getActiveDriver()->destroySound(sound);
+    }
 }
+
+}

Modified: rl/trunk/engine/core/src/SoundObject.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundObject.cpp	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/core/src/SoundObject.cpp	2007-05-13 15:43:41 UTC (rev 3442)
@@ -30,7 +30,7 @@
 namespace rl {
    
 /**
- * @param sound. Der Sound, Besitz wird ?bernommen.
+ * @param sound. Der Sound, Besitz wird bernommen.
  * @author JoSch
  * @date 03-11-2005
  */   
@@ -96,9 +96,9 @@
     }
 }
 
-void SoundObject::play( )
+void SoundObject::play(bool destroyWhenDone)
 {
-    getSound()->play();
+    getSound()->play(destroyWhenDone);
     if (is3d())
     {
 	   _update();

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-05-13 15:43:41 UTC (rev 3442)
@@ -430,7 +430,10 @@
 class SoundObject : public ActorControlledObject
 {
 public:
-	void play( );
+    SoundObject(rl::Sound *sound, const Ogre::String &name);
+    virtual ~SoundObject();
+    
+  	void play(bool destroyWhenDone=false);
 
 	void load();
 	void unload();
@@ -697,7 +700,7 @@
 private:
 	Sound(const SoundResourcePtr& res);
 public:
-    // Einige Standardwerte f?r Soundpriorit?ten.
+    // Einige Standardwerte fr Soundprioritten.
     enum SOUND_PRIORITY {
             PRIO_SPEECH = 30,
             PRIO_MUSIC = 75,
@@ -757,8 +760,21 @@
     
     // Sind wir gueltig
     bool isValid() const;
+    
+    bool is3d();
+    void set3d(bool is3d);
 };
 
+class SoundManager
+{
+public:
+
+    SoundManager();
+    static SoundManager& getSingleton(void);
+    Sound* createSound(const Ogre::String& res, rl::SoundType type=ST_SAMPLE);
+    void destroySound(Sound*);
+};
+
 class GameLoop
 {
 private:

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-05-12 16:14:14 UTC (rev 3441)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-05-13 15:43:41 UTC (rev 3442)
@@ -108,7 +108,7 @@
             pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_EXCLUSIVE")));
             pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_FOREGROUND")));
         #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-            pl.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
+        //    pl.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
         //    pl.insert(std::make_pair(std::string("x11_keyboard_grab"), std::string("false")));
         #endif
 



From vincent22 at mail.berlios.de  Mon May 14 22:51:50 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Mon, 14 May 2007 22:51:50 +0200
Subject: [Dsa-hl-svn] r3443 - in rl/trunk/engine/rules: include src
Message-ID: <200705142051.l4EKpo4s022714@sheep.berlios.de>

Author: vincent22
Date: 2007-05-14 22:51:48 +0200 (Mon, 14 May 2007)
New Revision: 3443

Modified:
   rl/trunk/engine/rules/include/GameObjectManager.h
   rl/trunk/engine/rules/src/GameObjectManager.cpp
Log:
Added the method getAllGameObjects which returns a list of all GOs.

Modified: rl/trunk/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectManager.h	2007-05-13 15:43:41 UTC (rev 3442)
+++ rl/trunk/engine/rules/include/GameObjectManager.h	2007-05-14 20:51:48 UTC (rev 3443)
@@ -49,6 +49,7 @@
 
         GameObject* getGameObject(unsigned int id) const;
         GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
+        std::list<const GameObject*> getAllGameObjects() const;
         void setGameObjectFactory(GameObjectFactory* gof);
         void loadProperties(const Ogre::String& module);
 

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-13 15:43:41 UTC (rev 3442)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-14 20:51:48 UTC (rev 3443)
@@ -86,6 +86,22 @@
 
         return NULL;
     }
+     
+    std::list<const GameObject*> GameObjectManager::getAllGameObjects() const
+    {
+        std::list<const GameObject*> gos;      
+        std::map<unsigned int, GameObject*>::const_iterator it;
+        
+        //
+        //    Run through all GOs and put them into the list
+        //
+        for( it=mGameObjects.begin(); it!=mGameObjects.end(); ++it )
+        {
+            gos.push_back(it->second);
+        }
+        
+        return gos;
+    }
 
     unsigned int GameObjectManager::generateId()
     {
@@ -93,11 +109,11 @@
     }
 
     GameObject* GameObjectManager::createGameObject(
-		const Ogre::String& classId, unsigned int id)
+        const Ogre::String& classId, unsigned int id)
     {
-		unsigned int goId;
+        unsigned int goId;
 
-		if (id != GameObject::NO_OBJECT_ID)
+        if (id != GameObject::NO_OBJECT_ID)
         {
             GameObject* goInMap = getGameObject(id);
 



From vincent22 at mail.berlios.de  Tue May 15 20:50:11 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Tue, 15 May 2007 20:50:11 +0200
Subject: [Dsa-hl-svn] r3444 - in rl/trunk/engine/rules: include src
Message-ID: <200705151850.l4FIoB9h018758@sheep.berlios.de>

Author: vincent22
Date: 2007-05-15 20:50:07 +0200 (Tue, 15 May 2007)
New Revision: 3444

Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
Log:
The classname of the GameObject is now a string member in the gameobject. The GOManager sets the classname after the construction of the GO.

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2007-05-14 20:51:48 UTC (rev 3443)
+++ rl/trunk/engine/rules/include/GameObject.h	2007-05-15 18:50:07 UTC (rev 3444)
@@ -45,34 +45,37 @@
           public PropertyHolder
     {
     public:
-    	typedef std::vector<std::pair<Action*, int> > ActionOptionVector;
-		static const unsigned int NO_OBJECT_ID = 0;
+        typedef std::vector<std::pair<Action*, int> > ActionOptionVector;
+        static const unsigned int NO_OBJECT_ID = 0;
         
         static const Ogre::String CLASS_NAME;
 
         static const Ogre::String PROPERTY_CLASS_ID;
         static const Ogre::String PROPERTY_OBJECT_ID;
         static const Ogre::String PROPERTY_BASE_CLASS;
-		static const Ogre::String PROPERTY_POSITION; 
+        static const Ogre::String PROPERTY_POSITION; 
         static const Ogre::String PROPERTY_ORIENTATION; 
         static const Ogre::String PROPERTY_NAME;
         static const Ogre::String PROPERTY_DESCRIPTION; 
         static const Ogre::String PROPERTY_MESHFILE; 
         static const Ogre::String PROPERTY_GEOMETRY_TYPE; 
         static const Ogre::String PROPERTY_MASS; 
-		static const Ogre::String PROPERTY_ACTIONS; 
-		static const Ogre::String PROPERTY_DEFAULT_ACTION;
+        static const Ogre::String PROPERTY_ACTIONS; 
+        static const Ogre::String PROPERTY_DEFAULT_ACTION;
 
-		static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
 
         GameObject(unsigned int id);
         virtual ~GameObject();
 
-		virtual GameObject* clone();
+        virtual GameObject* clone();
 
         int getId() const;
 
+        const Ogre::String getClassName() const;
+        void setClassName(Ogre::String classname);
+        
         const CeGuiString getName() const;
         void setName(CeGuiString name);
 
@@ -88,39 +91,39 @@
         const Ogre::Real getMass() const;
         void setMass(const Ogre::Real mass);
 
-		void addAction(Action* action, int option = Action::ACT_NORMAL);
+        void addAction(Action* action, int option = Action::ACT_NORMAL);
         void addActionInGroup(Action* action, ActionGroup* group, int option = Action::ACT_NORMAL);
         void removeAction(Action* action);
-	
-		void setActor(Actor* actor);
-		Actor* getActor();
+    
+        void setActor(Actor* actor);
+        Actor* getActor();
 
-		/**
-		 * Get all valid actions a character can perfom on this game object
-		 * 
-		 * @param actor the character
-		 * @return a vector of actions
-		 */
+        /**
+         * Get all valid actions a character can perfom on this game object
+         * 
+         * @param actor the character
+         * @return a vector of actions
+         */
         const ActionVector getValidActions(Creature* actor) const;
-		virtual Action* getDefaultAction(Creature* actor) const;
+        virtual Action* getDefaultAction(Creature* actor) const;
 
         /** Trigger an action of this game object
          *  @param actionName the action's name
          *  @param actor the "user" of this game object, can be <code>NULL</code> sein, 
-				   if the action wasn't triggered by someone (e.g. by time)
+                   if the action wasn't triggered by someone (e.g. by time)
          *  @param target the action's target (can be <code>NULL</code> if no other game objects are involved)
          */
         void doAction(const CeGuiString actionName,
                       Creature* actor,
                       GameObject* target);
 
-		void doAction(const CeGuiString actionName);
+        void doAction(const CeGuiString actionName);
 
-		void doAction(Action* action,
+        void doAction(Action* action,
                       Creature* actor,
                       GameObject* target);
-					  
-		bool activateAction(Action* action,
+                      
+        bool activateAction(Action* action,
                       Creature* actor,
                       GameObject* target);
 
@@ -128,7 +131,7 @@
 
         void setPosition(const Ogre::Vector3& position);
         void setOrientation(const Ogre::Quaternion& orientation);
-	    const Ogre::Quaternion& getOrientation() const;
+        const Ogre::Quaternion& getOrientation() const;
         const Ogre::Vector3& getPosition() const;
 
         /// Soll der Aktor ?berhaupt leuchten?
@@ -148,9 +151,9 @@
         void removeFromScene();
 
         unsigned long getQueryFlags() const;
-		void addQueryFlag(unsigned long queryflag);
+        void addQueryFlag(unsigned long queryflag);
 
-		virtual void onStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onStateChange(GameObjectState oldState, GameObjectState newState);
 
     protected:
         int mId;
@@ -159,6 +162,7 @@
         CeGuiString mName;
         CeGuiString mDescription;
         CeGuiString mMeshfile;
+        Ogre::String mClassName;
         
         Actor* mActor;
         
@@ -171,23 +175,23 @@
         Actor* createActor();
         void destroyActor();
 
-		void doPlaceIntoScene();
-		void doRemoveFromScene();
+        void doPlaceIntoScene();
+        void doRemoveFromScene();
 
-	private:
-		static int sNextGameObjectId;	
+    private:
+        static int sNextGameObjectId;    
 
-		ActionOptionVector mActions;
+        ActionOptionVector mActions;
         Ogre::Vector3 mPosition;
         Ogre::Quaternion mOrientation;
         Ogre::Real mMass;
-		CeGuiString mDefaultAction;
+        CeGuiString mDefaultAction;
         GeometryType mGeometryType;
 
-		ActionOptionVector::iterator findAction(ActionOptionVector::iterator begin,
+        ActionOptionVector::iterator findAction(ActionOptionVector::iterator begin,
             ActionOptionVector::iterator end, const CeGuiString actionName);
-		ActionOptionVector::iterator findAction(ActionOptionVector::iterator
-            begin, ActionOptionVector::iterator end, const Action* action);	
+        ActionOptionVector::iterator findAction(ActionOptionVector::iterator
+            begin, ActionOptionVector::iterator end, const Action* action);    
     };
 }
 

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-05-14 20:51:48 UTC (rev 3443)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-05-15 18:50:07 UTC (rev 3444)
@@ -31,7 +31,7 @@
 
 namespace rl
 {
-	const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION = "viewobject";
+    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION = "viewobject";
     const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG = "viewobjectdebug";
 
     const Ogre::String GameObject::CLASS_NAME = "GameObject";
@@ -46,27 +46,27 @@
     const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = "geometrytype"; 
     const Ogre::String GameObject::PROPERTY_MASS = "mass"; 
     const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
-	const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
+    const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
 
     GameObject::GameObject(unsigned int id)
-		:   mId(id),
+        :   mId(id),
             mName(""),
             mDescription(""),
-			mMeshfile(""),
+            mMeshfile(""),
             mQueryFlags(QUERYFLAG_GAMEOBJECT),
-			mHighlightingEnabled(true),
-			mActor(NULL),
+            mHighlightingEnabled(true),
+            mActor(NULL),
             mActions(),
             mPosition(Ogre::Vector3::ZERO),
             mOrientation(Ogre::Quaternion::IDENTITY),
             mMass(0),
             mGeometryType(GT_NONE),
-			mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
-			mState(GOS_LOADED)
+            mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
+            mState(GOS_LOADED)
     {
         // Standardactions registrieren
-		Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
-		if (defaultAction != NULL)
+        Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
+        if (defaultAction != NULL)
         {
             addAction(defaultAction);
         }
@@ -76,30 +76,40 @@
         //if( CoreSubsystem::getSingleton().getDeveloperMode() )
         //{
             defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION_DEBUG);
-		    if (defaultAction != NULL)
+            if (defaultAction != NULL)
             {
                 addAction(defaultAction);
             }
         //}
 
-		// Eventsource erzeugen
-		setObject(this);
+        // Eventsource erzeugen
+        setObject(this);
     }
 
     GameObject::~GameObject(void)
     {
-	}
+    }
 
-	GameObject* GameObject::clone()
-	{
-		Throw(OperationNotSupportedException, "clone not yet implemented.");
-	}
+    GameObject* GameObject::clone()
+    {
+        Throw(OperationNotSupportedException, "clone not yet implemented.");
+    }
 
     int GameObject::getId() const
     {
         return mId;
     }
 
+    const Ogre::String GameObject::getClassName() const
+    {
+        return mClassName;
+    }
+    
+    void GameObject::setClassName(Ogre::String classname)
+    {
+        mClassName = classname;
+    }
+        
     const CeGuiString GameObject::getName() const
     {
         return mName;
@@ -137,41 +147,41 @@
             Throw(NullPointerException, "Parameter action ist NULL.");
         }
 
-		mActions.push_back(make_pair(action, option));	
-		LOG_MESSAGE(Logger::RULES,
-			"Bei GameObject #"+Ogre::StringConverter::toString(mId)+
-			" ("+getName()+") wurde Aktion "+action->getName().c_str()+" hinzugef?gt.");
+        mActions.push_back(make_pair(action, option));    
+        LOG_MESSAGE(Logger::RULES,
+            "Bei GameObject #"+Ogre::StringConverter::toString(mId)+
+            " ("+getName()+") wurde Aktion "+action->getName().c_str()+" hinzugef?gt.");
     }
 
-	void GameObject::addActionInGroup(Action* action, ActionGroup* group, int option)
+    void GameObject::addActionInGroup(Action* action, ActionGroup* group, int option)
     {
         addAction(action, option);
-		action->setGroup(group);
-	}
+        action->setGroup(group);
+    }
 
     void GameObject::removeAction(Action* action)
     {
-		ActionOptionVector::iterator it = findAction(mActions.begin(), mActions.end(), action);
+        ActionOptionVector::iterator it = findAction(mActions.begin(), mActions.end(), action);
         if (it != mActions.end())
         {
             mActions.erase(it);
         }
     }
-	
+    
     const ActionVector GameObject::getValidActions(Creature* actor) const
     {
-		ActionVector actions;
-		for (ActionOptionVector::const_iterator it = mActions.begin(); it != mActions.end(); ++it)
-		{
-			LOG_MESSAGE(Logger::RULES, "Untersuche Aktion "+(*it).first->getName());
-			if ((*it).second == Action::ACT_DISABLED)
-				continue;
-			//if ((*it).second > ACT_NEEDS_TALENT)
-			if (actor != NULL && !(*it).first->canDo(const_cast<GameObject*>(this), actor)) // Aktion nicht m?glich
-				continue;
-				
-			actions.push_back((*it).first);
-		}
+        ActionVector actions;
+        for (ActionOptionVector::const_iterator it = mActions.begin(); it != mActions.end(); ++it)
+        {
+            LOG_MESSAGE(Logger::RULES, "Untersuche Aktion "+(*it).first->getName());
+            if ((*it).second == Action::ACT_DISABLED)
+                continue;
+            //if ((*it).second > ACT_NEEDS_TALENT)
+            if (actor != NULL && !(*it).first->canDo(const_cast<GameObject*>(this), actor)) // Aktion nicht m?glich
+                continue;
+                
+            actions.push_back((*it).first);
+        }
         return actions;
     }
 
@@ -179,10 +189,10 @@
                               Creature* actor,
                               GameObject* target)
     {
-		ActionOptionVector::const_iterator it = 
+        ActionOptionVector::const_iterator it = 
             findAction(mActions.begin(), mActions.end(), actionName);
 
-		if (it == mActions.end())
+        if (it == mActions.end())
         {
             LOG_ERROR(
                 Logger::RULES, 
@@ -190,22 +200,22 @@
         }
         else
         {
-		    doAction((*it).first, actor, target);
+            doAction((*it).first, actor, target);
         }
     }
 
-	void GameObject::doAction(const CeGuiString actionName)
-	{
-		doAction(actionName, NULL, NULL);
-	}
+    void GameObject::doAction(const CeGuiString actionName)
+    {
+        doAction(actionName, NULL, NULL);
+    }
 
-	void GameObject::doAction(Action* action,
+    void GameObject::doAction(Action* action,
                               Creature* actor,
                               GameObject* target)
-	{
-		action->doAction(this, actor, target);
-	}
-	
+    {
+        action->doAction(this, actor, target);
+    }
+    
     void GameObject::doDefaultAction(Creature* actor, GameObject* target)
     {
         Action* action = getDefaultAction(actor);
@@ -221,72 +231,72 @@
         }
     }
 
-	bool GameObject::activateAction(Action* action,
+    bool GameObject::activateAction(Action* action,
                       Creature* actor,
                       GameObject* target)
-	{
-		doAction(action, actor, target);
-		return true;
-	}
+    {
+        doAction(action, actor, target);
+        return true;
+    }
 
-	GameObject::ActionOptionVector::iterator 
-		GameObject::findAction(
-			GameObject::ActionOptionVector::iterator begin, 
-			GameObject::ActionOptionVector::iterator end, 
-			const CeGuiString actionName)
-	{
-		for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
-		{
-			Action* action = (*iter).first;
+    GameObject::ActionOptionVector::iterator 
+        GameObject::findAction(
+            GameObject::ActionOptionVector::iterator begin, 
+            GameObject::ActionOptionVector::iterator end, 
+            const CeGuiString actionName)
+    {
+        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
+        {
+            Action* action = (*iter).first;
 
-			if (action->getName().compare(actionName) == 0)
-				return iter;
-		}
-		return end;
-	}
+            if (action->getName().compare(actionName) == 0)
+                return iter;
+        }
+        return end;
+    }
 
-	GameObject::ActionOptionVector::iterator 
-		GameObject::findAction(
-			GameObject::ActionOptionVector::iterator begin, 
-			GameObject::ActionOptionVector::iterator end, 
-			const Action* action)
-	{
-		for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
-			if ((*iter).first == action)
-				return iter;
+    GameObject::ActionOptionVector::iterator 
+        GameObject::findAction(
+            GameObject::ActionOptionVector::iterator begin, 
+            GameObject::ActionOptionVector::iterator end, 
+            const Action* action)
+    {
+        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
+            if ((*iter).first == action)
+                return iter;
 
-		return end;
-	}
-	
-	void GameObject::setActor(Actor* actor)
-	{
-		if (mActor != actor)
-		{
-			if (mActor != NULL)
-			{
-				mActor->setGameObject(NULL);
+        return end;
+    }
+    
+    void GameObject::setActor(Actor* actor)
+    {
+        if (mActor != actor)
+        {
+            if (mActor != NULL)
+            {
+                mActor->setGameObject(NULL);
                 mActor->setQueryFlags(0);
-			}
+            }
 
-			if (actor != NULL)
-			{
-				if (actor->isInScene())
-				{
-					actor->setPosition(mPosition);
-					actor->setOrientation(mOrientation);
+            if (actor != NULL)
+            {
+                if (actor->isInScene())
+                {
+                    actor->setPosition(mPosition);
+                    actor->setOrientation(mOrientation);
                     actor->setQueryFlags(mQueryFlags);
-				}
-				actor->setGameObject(this);
-			}
-			
-			mActor = actor;
-		}
-	}
-	
-	Actor* GameObject::getActor()
-	{
-		return mActor;
-	}
+                }
+                actor->setGameObject(this);
+            }
+            
+            mActor = actor;
+        }
+    }
+    
+    Actor* GameObject::getActor()
+    {
+        return mActor;
+    }
 
     bool GameObject::isHighlightingEnabled()
     {
@@ -304,16 +314,16 @@
         mHighlightingEnabled = highlightenabled;
     }
 
-	Action* GameObject::getDefaultAction(Creature* actor) const
-	{
-		return ActionManager::getSingleton().getAction(mDefaultAction);
-	}
+    Action* GameObject::getDefaultAction(Creature* actor) const
+    {
+        return ActionManager::getSingleton().getAction(mDefaultAction);
+    }
 
     void GameObject::setHighlighted(bool highlight)
     {
         if (mHighlightingEnabled && mActor != NULL)
         {
-			mActor->setHighlighted(highlight, getName());
+            mActor->setHighlighted(highlight, getName());
         }
     }
 
@@ -449,7 +459,7 @@
             }
             else if (key == PROPERTY_GEOMETRY_TYPE)
             {
-				setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));			
+                setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));            
             }
             else if (key == PROPERTY_MASS)
             {
@@ -466,26 +476,26 @@
             }
             else if (key == PROPERTY_ACTIONS)
             {
-				std::vector<Property> vecVal = value.toArray();
-				for (std::vector<Property>::iterator it = vecVal.begin(); it != vecVal.end(); it++)
-				{
-					Ogre::String actionName = (*it).toString().c_str();
-					Action* act = ActionManager::getSingleton().getAction(actionName);
+                std::vector<Property> vecVal = value.toArray();
+                for (std::vector<Property>::iterator it = vecVal.begin(); it != vecVal.end(); it++)
+                {
+                    Ogre::String actionName = (*it).toString().c_str();
+                    Action* act = ActionManager::getSingleton().getAction(actionName);
 
-					if (act != NULL)
-					{
-						addAction(act);
-					}
-					else
-					{
-						LOG_ERROR(Logger::RULES, "'"+actionName+"' not registered at ActionManager.");
-					}
-				}
-			}
-			else if (key == PROPERTY_DEFAULT_ACTION)
-			{
-				mDefaultAction = value.toString().c_str();
-			}
+                    if (act != NULL)
+                    {
+                        addAction(act);
+                    }
+                    else
+                    {
+                        LOG_ERROR(Logger::RULES, "'"+actionName+"' not registered at ActionManager.");
+                    }
+                }
+            }
+            else if (key == PROPERTY_DEFAULT_ACTION)
+            {
+                mDefaultAction = value.toString().c_str();
+            }
             else
             {
                 LOG_WARNING(
@@ -555,15 +565,15 @@
         }
     }
 
-	void GameObject::placeIntoScene()
-	{
-		setState(GOS_IN_SCENE);
-	}
+    void GameObject::placeIntoScene()
+    {
+        setState(GOS_IN_SCENE);
+    }
 
-	void GameObject::removeFromScene()
-	{
-		setState(GOS_LOADED);
-	}
+    void GameObject::removeFromScene()
+    {
+        setState(GOS_LOADED);
+    }
 
     void GameObject::doPlaceIntoScene()
     {
@@ -579,7 +589,7 @@
                 GameObjectState tmpState = mState;
                 mState = GOS_IN_SCENE;
                 GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
-				onStateChange(tmpState, GOS_IN_SCENE);
+                onStateChange(tmpState, GOS_IN_SCENE);
             }
             else {
                 LOG_ERROR(
@@ -627,20 +637,20 @@
             //Statechange event is triggered in this function
             doPlaceIntoScene();
         }
-		else
-		{
-			LOG_ERROR(
-				Logger::RULES, 
-				"GameObject '" + getName() 
-				+ "' could not change state from "
-				+ Ogre::StringConverter::toString(mState) + " to "
-				+ Ogre::StringConverter::toString(targetstate));
-		}
+        else
+        {
+            LOG_ERROR(
+                Logger::RULES, 
+                "GameObject '" + getName() 
+                + "' could not change state from "
+                + Ogre::StringConverter::toString(mState) + " to "
+                + Ogre::StringConverter::toString(targetstate));
+        }
     }
 
-	void GameObject::onStateChange(GameObjectState oldState, GameObjectState newState)
-	{
-	}
+    void GameObject::onStateChange(GameObjectState oldState, GameObjectState newState)
+    {
+    }
 
     GameObjectState GameObject::getState() const
     {
@@ -652,8 +662,8 @@
         return mQueryFlags;
     }
 
-	void GameObject::addQueryFlag(unsigned long queryflag)
-	{
-		mQueryFlags |= queryflag;
-	}
+    void GameObject::addQueryFlag(unsigned long queryflag)
+    {
+        mQueryFlags |= queryflag;
+    }
 }

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-14 20:51:48 UTC (rev 3443)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-15 18:50:07 UTC (rev 3444)
@@ -139,6 +139,7 @@
                 classname, 
                 goId);
         
+        go->setClassName(classname);
         go->setProperties(ps);
         mGameObjects[goId] = go;
         return go;



From vincent22 at mail.berlios.de  Tue May 15 20:51:26 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Tue, 15 May 2007 20:51:26 +0200
Subject: [Dsa-hl-svn] r3445 - in rl/trunk/engine/ui: include src
Message-ID: <200705151851.l4FIpQVW018924@sheep.berlios.de>

Author: vincent22
Date: 2007-05-15 20:51:23 +0200 (Tue, 15 May 2007)
New Revision: 3445

Modified:
   rl/trunk/engine/ui/include/SaveLoadWindow.h
   rl/trunk/engine/ui/src/SaveLoadWindow.cpp
Log:
If the Save button is pressed all gameobjects that must be saved are printed into the logfile.

Modified: rl/trunk/engine/ui/include/SaveLoadWindow.h
===================================================================
--- rl/trunk/engine/ui/include/SaveLoadWindow.h	2007-05-15 18:50:07 UTC (rev 3444)
+++ rl/trunk/engine/ui/include/SaveLoadWindow.h	2007-05-15 18:51:23 UTC (rev 3445)
@@ -56,6 +56,10 @@
         virtual void initialize();
         
     private:
+        bool handleLoadEvent();
+        bool handleSaveEvent();
+        bool handleDeleteEvent();
+        
         CEGUI::MultiColumnList     *mSaveGameTable;     //!< SaveGame table
         CEGUI::Editbox             *mFilename;         //!< Filename for the savegame 
     };

Modified: rl/trunk/engine/ui/src/SaveLoadWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-05-15 18:50:07 UTC (rev 3444)
+++ rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-05-15 18:51:23 UTC (rev 3445)
@@ -24,6 +24,8 @@
 #include <CEGUIWindowManager.h>
 #include <elements/CEGUIListboxTextItem.h>
 #include <Exception.h>
+#include <GameObjectManager.h>
+#include <GameObject.h>
 
 #include "SaveLoadWindow.h"
 
@@ -49,6 +51,27 @@
         
         centerWindow();
 
+        getPushButton("SaveLoadWindow/ButtonSheet/LoadButton")->subscribeEvent(
+        CEGUI::Window::EventMouseClick,
+        boost::bind(
+            &SaveLoadWindow::handleLoadEvent,
+            this
+        ));
+        
+        getPushButton("SaveLoadWindow/ButtonSheet/SaveButton")->subscribeEvent(
+        CEGUI::Window::EventMouseClick,
+        boost::bind(
+            &SaveLoadWindow::handleSaveEvent,
+            this
+        ));
+        
+        getPushButton("SaveLoadWindow/ButtonSheet/DeleteButton")->subscribeEvent(
+        CEGUI::Window::EventMouseClick,
+        boost::bind(
+            &SaveLoadWindow::handleDeleteEvent,
+            this
+        ));
+        
         bindDestroyWindowToXButton();
         bindDestroyWindowToClick(getWindow("SaveLoadWindow/ButtonSheet/CancelButton"));
         
@@ -67,5 +90,42 @@
         //mSaveGameTable->autoSizeColumnHeader(0);
         //mSaveGameTable->autoSizeColumnHeader(1);
     }
+    
+    //------------------------------------------------------- LoadEvent
 
+    bool SaveLoadWindow::handleLoadEvent() 
+    {
+        LOG_MESSAGE(Logger::UI, "Load Button pressed");
+        return true;        
+    }
+    
+    //------------------------------------------------------- SaveEvent
+
+    bool SaveLoadWindow::handleSaveEvent() 
+    {
+        LOG_MESSAGE(Logger::UI, "Save Button pressed");
+        
+        std::list<const GameObject*>::const_iterator it;
+        std::list<const GameObject*> gos;
+        gos = GameObjectManager::getSingleton().getAllGameObjects();
+        
+        LOG_MESSAGE(Logger::UI, "Following GOs must be saved:");
+        for( it=gos.begin(); it!=gos.end(); ++it )
+        {
+            //const CeGuiString test = (*it)->getName();
+            LOG_MESSAGE(Logger::UI, "Class: " + (*it)->getClassName() +
+                " Name: " + (*it)->getName());    
+        }
+        
+        return true;        
+    }
+
+    //------------------------------------------------------- DeleteEvent
+
+    bool SaveLoadWindow::handleDeleteEvent() 
+    {
+        LOG_MESSAGE(Logger::UI, "Delete Button pressed");
+        return true;
+    }
+
 } // namespace rl



From vincent22 at mail.berlios.de  Tue May 15 21:37:01 2007
From: vincent22 at mail.berlios.de (vincent22 at mail.berlios.de)
Date: Tue, 15 May 2007 21:37:01 +0200
Subject: [Dsa-hl-svn] r3446 - in rl/trunk/engine: rules/include rules/src
	ui/src
Message-ID: <200705151937.l4FJb1ww022700@sheep.berlios.de>

Author: vincent22
Date: 2007-05-15 21:36:57 +0200 (Tue, 15 May 2007)
New Revision: 3446

Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/ui/src/SaveLoadWindow.cpp
Log:
I saved the classname instead of the classId in the GameObject, now its correct.

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2007-05-15 18:51:23 UTC (rev 3445)
+++ rl/trunk/engine/rules/include/GameObject.h	2007-05-15 19:36:57 UTC (rev 3446)
@@ -73,8 +73,8 @@
 
         int getId() const;
 
-        const Ogre::String getClassName() const;
-        void setClassName(Ogre::String classname);
+        const Ogre::String getClassId() const;
+        void setClassId(Ogre::String classId);
         
         const CeGuiString getName() const;
         void setName(CeGuiString name);
@@ -162,7 +162,7 @@
         CeGuiString mName;
         CeGuiString mDescription;
         CeGuiString mMeshfile;
-        Ogre::String mClassName;
+        Ogre::String mClassId;
         
         Actor* mActor;
         

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-05-15 18:51:23 UTC (rev 3445)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-05-15 19:36:57 UTC (rev 3446)
@@ -100,14 +100,14 @@
         return mId;
     }
 
-    const Ogre::String GameObject::getClassName() const
+    const Ogre::String GameObject::getClassId() const
     {
-        return mClassName;
+        return mClassId;
     }
     
-    void GameObject::setClassName(Ogre::String classname)
+    void GameObject::setClassId(Ogre::String classId)
     {
-        mClassName = classname;
+        mClassId = classId;
     }
         
     const CeGuiString GameObject::getName() const

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-15 18:51:23 UTC (rev 3445)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-15 19:36:57 UTC (rev 3446)
@@ -139,7 +139,7 @@
                 classname, 
                 goId);
         
-        go->setClassName(classname);
+        go->setClassId(classId);
         go->setProperties(ps);
         mGameObjects[goId] = go;
         return go;

Modified: rl/trunk/engine/ui/src/SaveLoadWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-05-15 18:51:23 UTC (rev 3445)
+++ rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-05-15 19:36:57 UTC (rev 3446)
@@ -113,7 +113,7 @@
         for( it=gos.begin(); it!=gos.end(); ++it )
         {
             //const CeGuiString test = (*it)->getName();
-            LOG_MESSAGE(Logger::UI, "Class: " + (*it)->getClassName() +
+            LOG_MESSAGE(Logger::UI, "ClassId: " + (*it)->getClassId() +
                 " Name: " + (*it)->getName());    
         }
         



From blakharaz at mail.berlios.de  Wed May 16 11:33:56 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 16 May 2007 11:33:56 +0200
Subject: [Dsa-hl-svn] r3447 - in rl/trunk/engine: common/include common/src
	ui/src
Message-ID: <200705160933.l4G9Xu4m011142@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-16 11:33:40 +0200 (Wed, 16 May 2007)
New Revision: 3447

Modified:
   rl/trunk/engine/common/include/Properties.h
   rl/trunk/engine/common/include/Property.h
   rl/trunk/engine/common/src/Properties.cpp
   rl/trunk/engine/common/src/PropertyReader.cpp
   rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
Log:
Provide associative arrays (maps) as properties (key is CEGUI string, value is any property), needed to rename PropertyMap since its keys are Ogre::String


Modified: rl/trunk/engine/common/include/Properties.h
===================================================================
--- rl/trunk/engine/common/include/Properties.h	2007-05-15 19:36:57 UTC (rev 3446)
+++ rl/trunk/engine/common/include/Properties.h	2007-05-16 09:33:40 UTC (rev 3447)
@@ -18,13 +18,14 @@
 
 #include "CommonPrerequisites.h"
 #include "Property.h"
-
+ 
 namespace rl {
 
     class PropertySet;
     class PropertySetPtr;
-    typedef std::map<const Ogre::String, Property> PropertyMap;
 
+    typedef std::map<const Ogre::String, Property> PropertySetMap;
+
     class _RlCommonExport PropertyHolder
     {
     public:
@@ -43,11 +44,11 @@
         virtual const Property getProperty(const Ogre::String& key) const;
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
-        const PropertyMap::const_iterator begin() const;
-        const PropertyMap::const_iterator end() const;
+        const PropertySetMap::const_iterator begin() const;
+        const PropertySetMap::const_iterator end() const;
         
     private:
-        PropertyMap mProperties;
+        PropertySetMap mProperties;
 	};
 
     class _RlCommonExport PropertySetPtr :

Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2007-05-15 19:36:57 UTC (rev 3446)
+++ rl/trunk/engine/common/include/Property.h	2007-05-16 09:33:40 UTC (rev 3447)
@@ -20,6 +20,7 @@
 
 #include <boost/any.hpp>
 #include <OgreSharedPtr.h>
+#include <map>
 
 #include "Exception.h"
 #include "Tripel.h"
@@ -64,11 +65,14 @@
         } \
     }
 
+	class Property;
 
+	typedef std::map<CeGuiString, Property> PropertyMap;
+
     class _RlCommonExport Property
     {
     public:
-        Property();
+		Property();
 
         PropertyMethod(Bool, const bool&);
         PropertyMethod(String, const CeGuiString&);
@@ -79,6 +83,7 @@
         PropertyMethod(IntTriple, const Tripel<int>);
         PropertyMethod(IntPair, const IntPair);
 		PropertyMethod(Array, const std::vector<Property>);
+		PropertyMethod(Map, const PropertyMap);
 
     private:
         boost::any mValue;

Modified: rl/trunk/engine/common/src/Properties.cpp
===================================================================
--- rl/trunk/engine/common/src/Properties.cpp	2007-05-15 19:36:57 UTC (rev 3446)
+++ rl/trunk/engine/common/src/Properties.cpp	2007-05-16 09:33:40 UTC (rev 3447)
@@ -25,7 +25,7 @@
 
     void PropertyHolder::setProperties(const PropertySet* props)
     {
-        for (PropertyMap::const_iterator it = props->begin();
+        for (PropertySetMap::const_iterator it = props->begin();
             it != props->end(); it++)
         {
             setProperty((*it).first, (*it).second);
@@ -47,7 +47,7 @@
 
     const Property PropertySet::getProperty(const Ogre::String& key) const
     {
-        PropertyMap::const_iterator it = mProperties.find(key);
+        PropertySetMap::const_iterator it = mProperties.find(key);
         if (it == mProperties.end())
         {
             Throw(rl::RuntimeException, "Property "+key+" not found.");
@@ -66,12 +66,12 @@
         return new PropertySet(this);
     }
 
-    const PropertyMap::const_iterator PropertySet::begin() const
+    const PropertySetMap::const_iterator PropertySet::begin() const
     {
         return mProperties.begin();
     }
 
-    const PropertyMap::const_iterator PropertySet::end() const
+    const PropertySetMap::const_iterator PropertySet::end() const
     {
         return mProperties.end();
     }

Modified: rl/trunk/engine/common/src/PropertyReader.cpp
===================================================================
--- rl/trunk/engine/common/src/PropertyReader.cpp	2007-05-15 19:36:57 UTC (rev 3446)
+++ rl/trunk/engine/common/src/PropertyReader.cpp	2007-05-16 09:33:40 UTC (rev 3447)
@@ -193,16 +193,14 @@
 	else if (type == "ARRAY")
 	{
 		std::vector<Property> vecVal;
-		DOMNode* curChild = domElem->getFirstChild();
-		while (curChild != NULL)
+		for (DOMNode* curChild  = domElem->getFirstChild(); curChild != NULL;
+			curChild = curChild->getNextSibling())
 		{
 			if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
 			{
 				PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
 				vecVal.push_back(entry.second);
 			}
-
-			curChild = curChild->getNextSibling();
 		}
 		prop = Property(vecVal);
 	}
@@ -219,6 +217,21 @@
         }
         prop = Property(intpairVal);
     }
+	else if (type == "MAP")
+	{
+		PropertyMap mapVal;
+		for (DOMNode* curChild  = domElem->getFirstChild(); curChild != NULL;
+			curChild = curChild->getNextSibling());
+		{
+			if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
+			{
+				CeGuiString key = XmlHelper::getAttributeValueAsString(curChild, "name");
+				PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
+				mapVal[key] = entry.second;
+			}
+		}
+		prop = Property(mapVal);
+	}
 
     return std::make_pair(key, prop);
 }

Modified: rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-05-15 19:36:57 UTC (rev 3446)
+++ rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-05-16 09:33:40 UTC (rev 3447)
@@ -75,7 +75,7 @@
         int row = 0;
         //  Iterate through all properties and add a row for
         //  every Entry
-        for( PropertyMap::const_iterator propIter = props->begin();
+        for( PropertySetMap::const_iterator propIter = props->begin();
             propIter != props->end(); propIter++ )
         {
             Ogre::String key = propIter->first;



From blakharaz at mail.berlios.de  Wed May 16 11:53:56 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 16 May 2007 11:53:56 +0200
Subject: [Dsa-hl-svn] r3448 - rl/trunk/engine/common/src
Message-ID: <200705160953.l4G9ruRd012965@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-16 11:53:54 +0200 (Wed, 16 May 2007)
New Revision: 3448

Modified:
   rl/trunk/engine/common/src/PropertyReader.cpp
Log:
Fix


Modified: rl/trunk/engine/common/src/PropertyReader.cpp
===================================================================
--- rl/trunk/engine/common/src/PropertyReader.cpp	2007-05-16 09:33:40 UTC (rev 3447)
+++ rl/trunk/engine/common/src/PropertyReader.cpp	2007-05-16 09:53:54 UTC (rev 3448)
@@ -221,7 +221,7 @@
 	{
 		PropertyMap mapVal;
 		for (DOMNode* curChild  = domElem->getFirstChild(); curChild != NULL;
-			curChild = curChild->getNextSibling());
+			curChild = curChild->getNextSibling())
 		{
 			if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
 			{



From blakharaz at mail.berlios.de  Wed May 16 12:02:11 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 16 May 2007 12:02:11 +0200
Subject: [Dsa-hl-svn] r3449 - rl/trunk/engine/common/src
Message-ID: <200705161002.l4GA2B0S013710@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-16 12:02:09 +0200 (Wed, 16 May 2007)
New Revision: 3449

Modified:
   rl/trunk/engine/common/src/PropertyReader.cpp
Log:
Fixed, now properly :)


Modified: rl/trunk/engine/common/src/PropertyReader.cpp
===================================================================
--- rl/trunk/engine/common/src/PropertyReader.cpp	2007-05-16 09:53:54 UTC (rev 3448)
+++ rl/trunk/engine/common/src/PropertyReader.cpp	2007-05-16 10:02:09 UTC (rev 3449)
@@ -225,8 +225,9 @@
 		{
 			if (curChild->getNodeType() == DOMNode::ELEMENT_NODE)
 			{
-				CeGuiString key = XmlHelper::getAttributeValueAsString(curChild, "name");
-				PropertyEntry entry = processProperty(static_cast<DOMElement*>(curChild));
+				DOMElement* curElem = static_cast<DOMElement*>(curChild);
+				CeGuiString key = XmlHelper::getAttributeValueAsString(curElem, "name");
+				PropertyEntry entry = processProperty(curElem);
 				mapVal[key] = entry.second;
 			}
 		}



From blakharaz at mail.berlios.de  Thu May 17 09:08:20 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 17 May 2007 09:08:20 +0200
Subject: [Dsa-hl-svn] r3450 - in rl/trunk: . engine/common/include
	engine/common/src engine/core engine/core/include
	engine/core/src engine/script/swig tools
Message-ID: <200705170708.l4H78KPh027620@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-17 09:08:08 +0200 (Thu, 17 May 2007)
New Revision: 3450

Added:
   rl/trunk/engine/core/include/MergeableMeshObject.h
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
Modified:
   rl/trunk/configure.in
   rl/trunk/engine/common/include/Logger.h
   rl/trunk/engine/common/src/Logger.cpp
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/ActorManager.h
   rl/trunk/engine/core/include/CoreDefines.h
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/core/src/ActorManager.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/Makefile.am
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/tools/copy_dependencies.bat
Log:
Use the meshmagick lib to provide "construction kit" meshes

Modified: rl/trunk/configure.in
===================================================================
--- rl/trunk/configure.in	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/configure.in	2007-05-17 07:08:08 UTC (rev 3450)
@@ -114,6 +114,9 @@
 # DSA4Werkzeug
 PKG_CHECK_MODULES(Dsa4Wz, Dsa4Wz >= 1.33.0)
 
+# meshmagick libraries
+PKG_CHECK_MODULES(meshmagick, meshmagick >= 0.4.0)
+
 # XERCES
 AC_CHECK_HEADERS(xercesc/util/XercesVersion.hpp, ,
     [AC_MSG_ERROR([cannot find libxerces headers]) ])

Modified: rl/trunk/engine/common/include/Logger.h
===================================================================
--- rl/trunk/engine/common/include/Logger.h	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/common/include/Logger.h	2007-05-17 07:08:08 UTC (rev 3450)
@@ -78,6 +78,8 @@
 		bool isErrorPresent() const;
 		void resetErrorState();
 		const Ogre::String& getErrorLog() const;
+
+		Ogre::Log* _getLog() const;
 	private:
 		void log(const LogLevel level, const Ogre::String& msg );
 

Modified: rl/trunk/engine/common/src/Logger.cpp
===================================================================
--- rl/trunk/engine/common/src/Logger.cpp	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/common/src/Logger.cpp	2007-05-17 07:08:08 UTC (rev 3450)
@@ -179,4 +179,9 @@
 	return mErrorBuffer;
 }
 
+Ogre::Log* Logger::_getLog() const
+{
+	return mLog;
 }
+
+}

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-05-17 07:08:08 UTC (rev 3450)
@@ -47,7 +47,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include"
+				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -82,12 +82,12 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt_d.lib OgreMain_d.lib xerces-c_2D.lib CEGUIBase_d.lib Newton.lib"
+				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt_d.lib OgreMain_d.lib xerces-c_2D.lib CEGUIBase_d.lib Newton.lib meshmagick_d.lib"
 				ShowProgress="0"
 				OutputFile="./lib/$(ConfigurationName)/RlCore.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib"
 				IgnoreDefaultLibraryNames=""
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				GenerateDebugInformation="true"
@@ -159,7 +159,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include"
+				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include"
 				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
 				StringPooling="false"
 				ExceptionHandling="1"
@@ -193,11 +193,11 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib xerces-c_2.lib CEGUIBase.lib OgreMain.lib Newton.lib"
+				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib xerces-c_2.lib CEGUIBase.lib OgreMain.lib Newton.lib meshmagick.lib"
 				OutputFile="./lib/$(ConfigurationName)/RlCore.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib"
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				ProgramDatabaseFile=""
 				SubSystem="2"
@@ -264,7 +264,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include"
+				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include"
 				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
 				StringPooling="false"
 				ExceptionHandling="1"
@@ -298,11 +298,11 @@
 				Name="VCLinkerTool"
 				IgnoreImportLibrary="true"
 				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib xerces-c_2.lib CEGUIBase.lib OgreMain.lib Newton.lib"
+				AdditionalDependencies="RlCommon.lib msvcrt-ruby18.lib OgreNewt.lib xerces-c_2.lib CEGUIBase.lib OgreMain.lib Newton.lib meshmagick.lib"
 				OutputFile="$(OutDir)/RlCore.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="..\common\lib\Release;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib\Release;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib"
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(TargetDir)$(TargetName).pdb"
@@ -457,10 +457,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\LightFadeJob.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\LightObject.h"
 				>
 			</File>
@@ -477,6 +473,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\MergeableMeshObject.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\MeshAnimation.h"
 				>
 			</File>
@@ -710,10 +710,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\LightFadeJob.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\LightObject.cpp"
 				>
 			</File>
@@ -730,6 +726,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\MergeableMeshObject.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\MeshAnimation.cpp"
 				>
 			</File>

Modified: rl/trunk/engine/core/include/ActorManager.h
===================================================================
--- rl/trunk/engine/core/include/ActorManager.h	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/include/ActorManager.h	2007-05-17 07:08:08 UTC (rev 3450)
@@ -32,7 +32,7 @@
 
     typedef std::map<const Ogre::String,Actor*> ActorPtrMap;
     typedef std::pair<const Ogre::String,Actor*> ActorPtrPair;
-
+	
     class _RlCoreExport ActorManager : public Ogre::Singleton<ActorManager>
     {
     public:
@@ -47,8 +47,13 @@
         Actor* createListenerActor(const Ogre::String& name);
         Actor* createCameraActor(const Ogre::String& name);
         Actor* createEmptyActor(const Ogre::String& name);
-        Actor* createMeshActor(const Ogre::String& name,const Ogre::String& meshname,
+        Actor* createMeshActor(const Ogre::String& name, const Ogre::String& meshname,
             GeometryType geomType = GT_NONE,
+            Ogre::Real mass = 1.0,
+			bool mergeable = false);
+		Actor* createMeshActor(const Ogre::String& name, const Ogre::String& basemeshname, 
+			const MeshPartMap& meshname,
+            GeometryType geomType = GT_NONE,
             Ogre::Real mass = 1.0);
         Actor* createParticleSystemActor(const Ogre::String& name, 
             const Ogre::String& partname);

Modified: rl/trunk/engine/core/include/CoreDefines.h
===================================================================
--- rl/trunk/engine/core/include/CoreDefines.h	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/include/CoreDefines.h	2007-05-17 07:08:08 UTC (rev 3450)
@@ -30,6 +30,7 @@
         GT_PYRAMID = 6
     };
 
+	typedef std::map<Ogre::String, Ogre::String> MeshPartMap;
 }
 
 #endif // __CoreConstants_H__

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/include/Makefile.am	2007-05-17 07:08:08 UTC (rev 3450)
@@ -32,6 +32,7 @@
 	LineSetPrimitive.h \
 	ListenerMovable.h \
 	ListenerObject.h \
+	MergeableMeshObject.h \
 	MeshAnimation.h \
 	MeshObject.h \
 	MovableText.h \

Added: rl/trunk/engine/core/include/MergeableMeshObject.h
===================================================================
--- rl/trunk/engine/core/include/MergeableMeshObject.h	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/include/MergeableMeshObject.h	2007-05-17 07:08:08 UTC (rev 3450)
@@ -0,0 +1,52 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __MergeableMeshObject_H__
+#define __MergeableMeshObject_H__
+
+#include "CorePrerequisites.h"
+
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <map>
+
+#include "CoreDefines.h"
+#include "MeshObject.h"
+
+namespace rl
+{
+	class _RlCoreExport MergeableMeshObject : public MeshObject
+	{
+	public:
+		MergeableMeshObject(const Ogre::String& name, const Ogre::String& meshname);
+		~MergeableMeshObject();
+
+		void addSubmesh(const Ogre::String& partname, const Ogre::String& meshfile);
+		void removeSubmesh(const Ogre::String& partToRemove);
+		void replaceSubmesh(const Ogre::String& partToReplace, const Ogre::String& substituteMeshname);
+		void setBaseMeshPart(const Ogre::String& partname);
+
+	private:
+		Ogre::MeshPtr mBaseMesh;
+		MeshPartMap mMeshes;
+		Ogre::String mCombinedMeshName;
+
+		void switchTo(const Ogre::MeshPtr& newMesh);
+		void updateMesh();
+	};
+
+}
+
+#endif //__MergeableMeshObject_H__

Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2007-05-17 07:08:08 UTC (rev 3450)
@@ -23,6 +23,7 @@
 #include "LightObject.h"
 #include "ListenerMovable.h"
 #include "ListenerObject.h"
+#include "MergeableMeshObject.h"
 #include "MeshObject.h"
 #include "BoxPrimitive.h"
 #include "MovableText.h"
@@ -315,17 +316,73 @@
         return actor;
     }
 
+    Actor* ActorManager::createMeshActor(const String& name, const Ogre::String& basemeshname, 
+		const MeshPartMap& meshparts, GeometryType geomType, Ogre::Real mass)
+	{
+		if (meshparts.empty())
+		{
+			return NULL;
+		}
+
+        const String&  uniquename = nextUniqueName(name);
+        Actor* actor = NULL;
+
+        try
+        {
+			
+			MergeableMeshObject* mmo = new MergeableMeshObject(uniquename, basemeshname);
+
+			for (MeshPartMap::const_iterator partIt = meshparts.begin(); partIt != meshparts.end(); ++partIt)
+			{
+				if (partIt->second == basemeshname)
+				{
+					mmo->setBaseMeshPart(partIt->first);
+				}
+				mmo->addSubmesh(partIt->first, partIt->second);
+			}
+		
+			PhysicalThing* pt = PhysicsManager::getSingleton()
+				.createPhysicalThing(geomType, mmo, mass);
+
+			actor = new Actor(uniquename, mmo, pt);
+			mActors.insert(ActorPtrPair(uniquename,actor)); 
+		}
+        catch (Ogre::Exception& e)
+        {
+            LOG_ERROR(Logger::CORE, "ActorManager - Mesh parts for actor '"
+                + uniquename + "' could not be created. Reason: "
+                + e.getFullDescription());
+        }
+        catch (rl::Exception& e)
+        {
+            LOG_ERROR(Logger::CORE, "ActorManager - Mesh parts for actor '"
+                + uniquename + "' could not be created. Reason: "
+                + e.getMessage());
+        }
+        return actor;
+	}
+
+
     Actor* ActorManager::createMeshActor(const String& name, const String& meshname,
-        GeometryType geomType, Ogre::Real mass)
+        GeometryType geomType, Ogre::Real mass, bool mergeable)
     {
         const String&  uniquename = nextUniqueName(name);
         Actor* actor = NULL;
 
         try
         {
-            MeshObject* mo = new MeshObject(uniquename, meshname);
+			MeshObject* mo = NULL;
+
+			if (mergeable)
+			{
+				mo = new MergeableMeshObject(uniquename, meshname);
+			}
+			else
+			{
+				mo = new MeshObject(uniquename, meshname);
+			}
             PhysicalThing* pt = PhysicsManager::getSingleton()
-                .createPhysicalThing( geomType, mo, mass);
+                .createPhysicalThing(geomType, mo, mass);
 
             actor = new Actor(uniquename, mo, pt);
             mActors.insert(ActorPtrPair(uniquename,actor)); 

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-05-17 07:08:08 UTC (rev 3450)
@@ -23,6 +23,7 @@
 #include <OgreConfigFile.h>
 #include <OgreMeshManager.h>
 #include <OgreBillboardParticleRenderer.h>
+#include <OgreEnvironment.h>
 
 #include "ActorManager.h"
 #include "AnimationManager.h"
@@ -83,6 +84,7 @@
     {
         mCoreEventCaster.removeEventListeners();
 
+		delete meshmagick::OgreEnvironment::getSingletonPtr();
         delete mZoneManager;
         delete mGameEventManager;
 		delete mWorld;
@@ -284,6 +286,9 @@
 		mZoneManager = new ZoneManager();
         LOG_MESSAGE(Logger::CORE,"ZoneManager erzeugt");
 
+		new meshmagick::OgreEnvironment();
+		meshmagick::OgreEnvironment::getSingleton().initialize(false, Logger::getSingleton()._getLog());
+
         return true;
     }
 

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/src/Makefile.am	2007-05-17 07:08:08 UTC (rev 3450)
@@ -1,10 +1,10 @@
 # Default values, if configuration file is missing (hard coded)
 AM_CPPFLAGS = -DRL_MODULEDIR=\"$(RL_MODULEDIR)\" -DOGRE_PLUGINDIR=\"$(OGRE_PLUGINDIR)\"
 
-INCLUDES = $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(CEGUI_CFLAGS) $(STLPORT_CFLAGS) -I../include -I../../common/include -I../include/nulldriver
+INCLUDES = $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(CEGUI_CFLAGS) $(STLPORT_CFLAGS) -I../include -I../../common/include -I../include/nulldriver $(meshmagick_CFLAGS)
 
 lib_LTLIBRARIES = libRlCore.la
-libRlCore_la_LDFLAGS = $(OGRE_LIBS) $(CEGUI_LIBS) $(RUBY_LIBS) $(LIBS)
+libRlCore_la_LDFLAGS = $(OGRE_LIBS) $(CEGUI_LIBS) $(RUBY_LIBS) $(LIBS) -lmeshmagick
 libRlCore_la_SOURCES = \
 	Actor.cpp \
 	ActorControlledObject.cpp \
@@ -36,6 +36,7 @@
 	LineSetPrimitive.cpp \
 	ListenerObject.cpp \
 	ListenerMovable.cpp \
+	MergeableMeshObject.cpp \
 	MeshAnimation.cpp \
 	MeshObject.cpp \
 	MovableText.cpp \
@@ -57,7 +58,7 @@
 	SoundEvents.cpp \
 	SoundResource.cpp \
 	TrackAnimation.cpp \
-	World.cpp \
+	World.cpp \
 	Zone.cpp \
 	ZoneManager.cpp \
 	nulldriver/NullDriver.cpp \

Added: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-05-17 07:08:08 UTC (rev 3450)
@@ -0,0 +1,126 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+#include "MergeableMeshObject.h"
+
+#include <MeshMergeTool.h>
+#include <OgreMeshManager.h>
+#include <OgreNode.h>
+#include <OgreSceneNode.h>
+#include <OgreSkeletonManager.h>
+#include <OgreTagPoint.h>
+
+#include "CoreSubsystem.h"
+#include "World.h"
+
+using namespace Ogre;
+using meshmagick::MeshMergeTool;
+
+namespace rl
+{
+	MergeableMeshObject::MergeableMeshObject(const Ogre::String& name, const Ogre::String& meshname)
+		: MeshObject(name, meshname),
+		mMeshes(),
+		mCombinedMeshName()
+	{
+		mBaseMesh = getEntity()->getMesh();
+	}
+
+	MergeableMeshObject::~MergeableMeshObject()
+	{
+	}
+
+	void MergeableMeshObject::addSubmesh(const Ogre::String& partname, const Ogre::String& meshfile)
+	{
+		mMeshes[partname] = meshfile;
+		updateMesh();
+	}
+
+	void MergeableMeshObject::updateMesh()
+	{
+		Ogre::String newMeshName = "";
+		for (MeshPartMap::const_iterator it = mMeshes.begin(); it != mMeshes.end(); ++it)
+		{
+			newMeshName += "-" + (*it).second;
+		}
+
+		if (mCombinedMeshName != newMeshName)
+		{
+			MeshPtr newMesh = MeshManager::getSingleton().getByName(newMeshName);
+			
+			if (newMesh.isNull())
+			{
+				MeshMergeTool mm;
+				for (MeshPartMap::const_iterator it = mMeshes.begin(); it != mMeshes.end(); ++it)
+				{
+					String curMeshfile = (*it).second;
+					MeshPtr meshToAdd = MeshManager::getSingleton().load(curMeshfile, "regressiontest"); ///@todo this is just for testing
+					mm.addMesh(meshToAdd);
+				}
+				
+				newMesh = mm.bake(newMeshName);
+			}
+
+			switchTo(newMesh);
+
+			mCombinedMeshName = newMeshName;
+		}
+	}
+
+	void MergeableMeshObject::setBaseMeshPart(const Ogre::String& partname)
+	{
+		mMeshes[partname] = mBaseMesh->getName();
+	}
+
+	void MergeableMeshObject::replaceSubmesh(const Ogre::String& partToReplace, const Ogre::String& substituteMeshname)
+	{
+		///@todo check if submesh exists
+		mMeshes[partToReplace] = substituteMeshname;
+		updateMesh();
+	}
+
+	void MergeableMeshObject::removeSubmesh(const Ogre::String& partToRemove)
+	{
+		///@todo MergeableMeshObject::removeSubmesh
+	}
+
+	void MergeableMeshObject::switchTo(const MeshPtr& newMesh)
+	{
+		Entity* oldEnt = getEntity();
+		Entity* newEnt = CoreSubsystem::getSingletonPtr()->getWorld()
+			->getSceneManager()->createEntity(oldEnt->getName()+"_", newMesh->getName());
+		
+		Node* parentNode = oldEnt->getParentNode();
+		if (parentNode != NULL)
+		{
+			TagPoint* tp = dynamic_cast<TagPoint*>(parentNode);
+			if (tp != NULL)
+			{
+				tp->setChildObject(newEnt);
+			}
+		}
+
+		SceneNode* parentSceneNode = oldEnt->getParentSceneNode();
+		if (parentSceneNode != NULL)
+		{
+			parentSceneNode->detachObject(oldEnt);
+			parentSceneNode->attachObject(newEnt);
+		}
+
+		mMovableObject = newEnt;
+		CoreSubsystem::getSingletonPtr()->getWorld()
+			->getSceneManager()->destroyEntity(oldEnt);
+	}
+}

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-05-17 07:08:08 UTC (rev 3450)
@@ -21,6 +21,7 @@
 #include "ActorManager.h"
 #include "Actor.h"
 #include "MeshObject.h"
+#include "MergeableMeshObject.h"
 #include "SoundObject.h"
 #include "SoundManager.h"
 #include "ListenerObject.h"
@@ -58,7 +59,7 @@
 #include "PlayAnimationJob.h"
 #include "Zone.h"
 #include "ZoneManager.h"
-#include "LightFadeJob.h"
+//#include "LightFadeJob.h"
 #undef message
 #undef send
 %}

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-05-17 07:08:08 UTC (rev 3450)
@@ -64,6 +64,11 @@
     rl::ActorControlledObject **ppActorControlledObject =
         reinterpret_cast<rl::ActorControlledObject**>(ptr);
 
+    rl::MergeableMeshObject *pMergeableMeshObject=dynamic_cast<rl::MergeableMeshObject*>(*ppActorControlledObject);
+    if (pMergeableMeshObject) {
+        *ptr=reinterpret_cast<void*>(pMergeableMeshObject);
+        return SWIGTYPE_p_rl__MergeableMeshObject;
+    }
     rl::MeshObject *pMeshObject=dynamic_cast<rl::MeshObject*>(*ppActorControlledObject);
     if (pMeshObject) {
         *ptr=reinterpret_cast<void*>(pMeshObject);
@@ -133,7 +138,8 @@
     rl::Actor* createLightActor(const Ogre::String& name, rl::LightObject::LightTypes type );
 	rl::Actor* createMeshActor(const Ogre::String& name, const Ogre::String& meshname,
 		    rl::GeometryType geom = rl::GT_NONE,
-		    Ogre::Real density=1.0);
+		    Ogre::Real mass = 0.0,
+		    bool mergeable = false);
 	rl::Actor* createBoxPrimitiveActor(const Ogre::String& name,
             const Ogre::Vector3& minCorner, const Ogre::Vector3& maxCorner,
             const Ogre::String& materialName = "", Ogre::Real mass = 0.0);
@@ -384,11 +390,11 @@
     rl::Actor* getActor();
 };
 
-class PhysicalObject : public ActorControlledObject
+class PhysicalObject : public rl::ActorControlledObject
 {
 };
 
-class MeshObject : public PhysicalObject
+class MeshObject : public rl::PhysicalObject
 {
 private:
     MeshObject(const Ogre::String& name, const Ogre::String& meshname);
@@ -409,9 +415,20 @@
     bool getCastShadows (void) const;    
 };
 
-class LightObject : public ActorControlledObject
+class MergeableMeshObject : public rl::MeshObject
 {
 private:
+    MergeableMeshObject(const Ogre::String& name, const Ogre::String& meshname);
+public:
+	void addSubmesh(const Ogre::String& meshname, const Ogre::String& meshfile);
+	void removeSubmesh(const Ogre::String& submeshToRemove);
+	void replaceSubmesh(const Ogre::String& submeshToReplace, const Ogre::String& substituteMeshname);
+	void setBaseMeshPart(const Ogre::String& partname);
+};
+
+class LightObject : public rl::ActorControlledObject
+{
+private:
     LightObject(const Ogre::String& name, rl::LightObject::LightTypes type);
 public:
 	enum LightTypes { LT_POINT, LT_DIRECTIONAL, LT_SPOTLIGHT };
@@ -427,7 +444,7 @@
 };
 
 
-class SoundObject : public ActorControlledObject
+class SoundObject : public rl::ActorControlledObject
 {
 public:
     SoundObject(rl::Sound *sound, const Ogre::String &name);
@@ -460,7 +477,7 @@
 	rl::Sound* getSound();
 };
 
-class ParticleSystemObject : public ActorControlledObject
+class ParticleSystemObject : public rl::ActorControlledObject
 {
 public:
      void setActive(bool active);
@@ -468,7 +485,7 @@
 	 ParticleSystemObject(const Ogre::String& name, const Ogre::String& partSys );
 };
 
-class CameraObject : public PhysicalObject
+class CameraObject : public rl::PhysicalObject
 {
 private:
     CameraObject(const Ogre::String& name);
@@ -858,15 +875,15 @@
     bool execute(Ogre::Real time);
 };
 
-class LightFadeJob : public rl::Job
-{
-public:
-    LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse, 
-        const Ogre::ColourValue& targetSpecular, Ogre::Real duration = 1.0f);
+//class LightFadeJob : public rl::Job
+//{
+//public:
+//    LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse, 
+//        const Ogre::ColourValue& targetSpecular, Ogre::Real duration = 1.0f);
+//
+//    virtual bool execute(Ogre::Real time);
+//};
 
-    virtual bool execute(Ogre::Real time);
-};
-
 class JobScheduler
 {
 public:

Modified: rl/trunk/tools/copy_dependencies.bat
===================================================================
--- rl/trunk/tools/copy_dependencies.bat	2007-05-16 10:02:09 UTC (rev 3449)
+++ rl/trunk/tools/copy_dependencies.bat	2007-05-17 07:08:08 UTC (rev 3450)
@@ -66,3 +66,6 @@
 
 copy "%RL_ROOT%\Dependencies\cppunit\lib\cppunit_dll.dll" "%RL_DIST%"
 copy "%RL_ROOT%\Dependencies\cppunit\lib\cppunitd_dll.dll" "%RL_DIST%"
+
+copy "%RL_ROOT%\Dependencies\meshmagick\lib\*.dll" "%RL_DIST%"
+



From blakharaz at mail.berlios.de  Thu May 17 09:10:13 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 17 May 2007 09:10:13 +0200
Subject: [Dsa-hl-svn] r3451 - modules/regressiontest/dsa
	rl/trunk/engine/rules/include rl/trunk/engine/rules/src
Message-ID: <200705170710.l4H7ADPT027752@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-17 09:10:07 +0200 (Thu, 17 May 2007)
New Revision: 3451

Added:
   modules/regressiontest/dsa/mapmeshparttest.gof
Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/src/GameObject.cpp
Log:
Properties for "mesh construction kit" parts

Added: modules/regressiontest/dsa/mapmeshparttest.gof
===================================================================
--- modules/regressiontest/dsa/mapmeshparttest.gof	2007-05-17 07:08:08 UTC (rev 3450)
+++ modules/regressiontest/dsa/mapmeshparttest.gof	2007-05-17 07:10:07 UTC (rev 3451)
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+    <gameobjectclass classid="M.C.K. test object" baseclass="GameObject">
+        <property name="name" type="STRING" data="M.C.K. Test object"/>
+        <property name="description" type="STRING" data="This is the testing object for the M.C.K."/>
+        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="meshparts" type="MAP">
+            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
+            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long01_normal.mesh"/>
+            <property name="leg" type="STRING" data="men_human_female_leg_pants01_long.mesh"/>
+            <property name="feet" type="STRING" data="men_human_female_feet_boots01.mesh"/>
+        </property>
+    </gameobjectclass>
+
+    <gameobjectclass classid="M.C.K. test creature" baseclass="Creature">
+        <property name="name" type="STRING" data="M.C.K. Test creature"/>
+        <property name="description" type="STRING" data="This is the testing creature for the M.C.K."/>
+        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="meshparts" type="MAP">
+            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
+            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long01_normal.mesh"/>
+            <property name="leg" type="STRING" data="men_human_female_leg_pants01_long.mesh"/>
+            <property name="feet" type="STRING" data="men_human_female_feet_boots01.mesh"/>
+        </property>
+    </gameobjectclass>
+
+    <gameobjectclass classid="M.C.K. test item 1" baseclass="Item">
+        <property name="name" type="STRING" data="M.C.K. Test item I"/>
+        <property name="description" type="STRING" data="This is the 1st testing item for the M.C.K."/>
+        <property name="meshfile" type="STRING" data="men_human_female_armor_garethplatte.mesh"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="M.C.K. test item 2" baseclass="Item">
+        <property name="name" type="STRING" data="M.C.K. Test item II"/>
+        <property name="description" type="STRING" data="This is the 2nd testing item for the M.C.K."/>
+        <property name="meshfile" type="STRING" data="men_human_female_armor_kroetenhaut.mesh"/>
+    </gameobjectclass>
+
+</GameObjectDefinitions>

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2007-05-17 07:08:08 UTC (rev 3450)
+++ rl/trunk/engine/rules/include/GameObject.h	2007-05-17 07:10:07 UTC (rev 3451)
@@ -58,7 +58,8 @@
         static const Ogre::String PROPERTY_NAME;
         static const Ogre::String PROPERTY_DESCRIPTION; 
         static const Ogre::String PROPERTY_MESHFILE; 
-        static const Ogre::String PROPERTY_GEOMETRY_TYPE; 
+  		static const Ogre::String PROPERTY_MESHPARTS; 
+		static const Ogre::String PROPERTY_GEOMETRY_TYPE; 
         static const Ogre::String PROPERTY_MASS; 
         static const Ogre::String PROPERTY_ACTIONS; 
         static const Ogre::String PROPERTY_DEFAULT_ACTION;
@@ -162,6 +163,7 @@
         CeGuiString mName;
         CeGuiString mDescription;
         CeGuiString mMeshfile;
+		MeshPartMap mMeshParts;
         Ogre::String mClassId;
         
         Actor* mActor;

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-05-17 07:08:08 UTC (rev 3450)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-05-17 07:10:07 UTC (rev 3451)
@@ -43,6 +43,7 @@
     const Ogre::String GameObject::PROPERTY_NAME = "name"; 
     const Ogre::String GameObject::PROPERTY_DESCRIPTION = "description"; 
     const Ogre::String GameObject::PROPERTY_MESHFILE = "meshfile"; 
+	const Ogre::String GameObject::PROPERTY_MESHPARTS = "meshparts"; 
     const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = "geometrytype"; 
     const Ogre::String GameObject::PROPERTY_MASS = "mass"; 
     const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
@@ -53,6 +54,7 @@
             mName(""),
             mDescription(""),
             mMeshfile(""),
+			mMeshParts(),
             mQueryFlags(QUERYFLAG_GAMEOBJECT),
             mHighlightingEnabled(true),
             mActor(NULL),
@@ -425,6 +427,16 @@
         {
             prop.setValue(mMass);
         }
+		else if (key == PROPERTY_MESHPARTS)
+		{
+			PropertyMap map;
+			for (MeshPartMap::const_iterator
+					it = mMeshParts.begin(); it != mMeshParts.end(); ++it)
+			{
+				map[(*it).first] = Property((*it).second);
+			}
+			prop.setValue(map);
+		}
         else
         {
             Throw(IllegalArgumentException, key + " is not a property of this gameobject ("+mName.c_str()+")");
@@ -457,6 +469,15 @@
             {
                 setMeshfile(value.toString());
             }
+            else if (key == PROPERTY_MESHPARTS)
+            {
+				PropertyMap map = value.toMap();
+				for (PropertyMap::const_iterator 
+					it = map.begin(); it != map.end(); ++it)
+				{
+					mMeshParts[(*it).first.c_str()] = (*it).second.toString().c_str();
+				}
+            }
             else if (key == PROPERTY_GEOMETRY_TYPE)
             {
                 setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));            
@@ -519,6 +540,7 @@
         ps->setProperty(PROPERTY_POSITION, Property(getPosition()));
         ps->setProperty(PROPERTY_ORIENTATION, Property(getOrientation()));
         ps->setProperty(PROPERTY_MESHFILE, Property(mMeshfile));
+        ps->setProperty(PROPERTY_MESHPARTS, getProperty(PROPERTY_MESHPARTS));
         ps->setProperty(PROPERTY_GEOMETRY_TYPE, Property(mGeometryType));
         ps->setProperty(PROPERTY_MASS, Property(mMass));
 
@@ -530,24 +552,40 @@
         if (mActor == NULL)
         {
             Ogre::String actorName = Ogre::StringConverter::toString(mId);
+			Actor* actor = NULL;
 
+			if (mMeshfile.empty() && mMeshParts.empty())
+			{
+				LOG_ERROR(
+					Logger::RULES, 
+					"Neither mesh file nor mesh parts are set on gameobject '" + getName()
+					+ "' (id: " + getId() + "). Can't create actor!");
+			}
+			else if (!mMeshParts.empty())
+			{
+				actor = ActorManager::getSingleton().createMeshActor(
+						actorName,
+						mMeshfile.c_str(),
+						mMeshParts,
+						mGeometryType,
+						mMass);
+			}
+			else
+			{
+				actor = ActorManager::getSingleton().createMeshActor(
+						actorName,
+						mMeshfile.c_str(),
+						mGeometryType,
+						mMass);
+			}
 
-            Actor* actor = ActorManager::getSingleton().createMeshActor(
-                    actorName,
-                    mMeshfile.c_str(),
-                    mGeometryType,
-                    mMass);
-
-            if (actor == NULL)
-            {
-                LOG_ERROR(
-                    Logger::RULES, 
-                    "Error creating actor '"
-                    + actorName
-                    + "' with mesh file "
-                    + mMeshfile);
-            }
-
+			if (actor == NULL)
+			{
+				LOG_ERROR(
+					Logger::RULES, 
+					"Error creating actor '"
+					+ actorName	+ "'.");
+			}
             return actor;
         }
         else



From blakharaz at mail.berlios.de  Thu May 17 09:11:10 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 17 May 2007 09:11:10 +0200
Subject: [Dsa-hl-svn] r3452 - modules/regressiontest/maps
	modules/regressiontest/scripts
	modules/regressiontest/scripts/maps rl/trunk/engine/rules
	rl/trunk/engine/rules/include rl/trunk/engine/rules/src
	rl/trunk/engine/script/swig
Message-ID: <200705170711.l4H7BAk2027894@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-17 09:10:59 +0200 (Thu, 17 May 2007)
New Revision: 3452

Added:
   modules/regressiontest/scripts/MergeableMeshTest.rb
Modified:
   modules/regressiontest/maps/regressiontest.scene
   modules/regressiontest/scripts/maps/regressiontest.rb
   modules/regressiontest/scripts/moduleconfig.rb
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/GameObjectManager.h
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/rules/src/Slot.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Added submesh slots to inventory

Modified: modules/regressiontest/maps/regressiontest.scene
===================================================================
--- modules/regressiontest/maps/regressiontest.scene	2007-05-17 07:10:07 UTC (rev 3451)
+++ modules/regressiontest/maps/regressiontest.scene	2007-05-17 07:10:59 UTC (rev 3452)
@@ -1,14 +1,8 @@
-<scene formatVersion="0.2.0">
+<scene formatVersion="0.4.0">
     <nodes>
-        <node>
+        <entity meshfile="regressiontest_floorplane.mesh">
             <position x="0.0" y="0.0" z="0.0" />
             <scale x="1.0" y="1.0" z="1.0" />
-            <entity meshFile="regressiontest_floorplane.mesh"/>
-        </node>
-        <node>
-            <position x="10.0" y="0.0" z="0.0" />
-            <scale x="1.0" y="1.0" z="1.0" />
-            <entity meshFile="held.mesh"/>
-        </node>
+        </entity>
     </nodes>
 </scene>

Added: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-17 07:10:07 UTC (rev 3451)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-17 07:10:59 UTC (rev 3452)
@@ -0,0 +1,31 @@
+require 'globals.rb'
+
+class MergeableMeshTest < TestCase
+    def initialize(center)
+        super(center)
+
+        $SCRIPT.log("MergeableMeshTest Start");
+
+        test_obj1 = $GOM.createGameObject("mesh construction kit test object")
+        test_obj1.setPosition(center)
+        test_obj1.placeIntoScene();
+
+
+        test_obj2 = $GOM.createGameObject("mesh construction kit test creature")
+        test_obj2.setPosition(rel_pos([1, 0, 0]))
+        test_obj2.placeIntoScene();
+        test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
+        test_obj2.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_item = $GOM.createGameObject("mesh construction kit test item 1")
+        test_obj2.getInventory().hold(test_item, "Torso")
+
+
+        test_obj3 = $GOM.createGameObject("mesh construction kit test creature")
+        test_obj3.setPosition(rel_pos([2, 0, 0]))
+        test_obj3.placeIntoScene();
+        test_obj3.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
+        test_obj3.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_item2 = $GOM.createGameObject("mesh construction kit test item 2")
+        test_obj3.getInventory().hold(test_item2, "Torso")
+    end
+end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-05-17 07:10:07 UTC (rev 3451)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-05-17 07:10:59 UTC (rev 3452)
@@ -15,6 +15,7 @@
 require 'effecttest.rb'
 require 'LightzoneTest.rb'
 require 'MapLoadingTest.rb'
+require 'MergeableMeshTest.rb'
 
 # Physik aktivieren
 $PM.setEnabled(true)
@@ -38,21 +39,22 @@
 
 $SCRIPT.log("Hero ready")
 
-$SCRIPT.log("map 'regressiontest' initialisiert.");
+$SCRIPT.log("begin tests.");
 
-DoorTest.new([0.0, 0.0, -5.0])
-#GameObjectCreationTest.new([5, 0, 0])
-#GameObjectStatesTest.new([0, 0, 5])
-NpcTest.new([-5, 0, 5])
-NpcCapsuleTest.new([0, 0, 5])
-TimeTest.new([-5, 0, -5])
+         DoorTest.new([0, 0, -5])
+          NpcTest.new([-5, 0, 5])
+   NpcCapsuleTest.new([0, 0, 5])
+         TimeTest.new([-5, 0, -5])
 ErrorHandlingTest.new([-10, 0, 5])
-InventoryTest.new([0, 0, 10])
-JobSequenceTest.new([5, 0, -5])
-EffectTest.new([5, 0, 5])
-SoundTest.new([15, 0, 10])
-LightzoneTest.new([-10, 0, -5])
-MapLoadingTest.new([-5, 0, -10])
+    InventoryTest.new([0, 0, 10])
+  JobSequenceTest.new([5, 0, -5])
+       EffectTest.new([5, 0, 5])
+        SoundTest.new([10, 0, 10])
+    LightzoneTest.new([-10, 0, -5])
+   MapLoadingTest.new([-5, 0, -10])
+MergeableMeshTest.new([10, 0, 0])
 
 
 $SCRIPT.log("tests initialisiert.");
+
+$SCRIPT.log("map 'regressiontest' initialisiert.");

Modified: modules/regressiontest/scripts/moduleconfig.rb
===================================================================
--- modules/regressiontest/scripts/moduleconfig.rb	2007-05-17 07:10:07 UTC (rev 3451)
+++ modules/regressiontest/scripts/moduleconfig.rb	2007-05-17 07:10:59 UTC (rev 3452)
@@ -22,7 +22,7 @@
     end
 
     def start()
-        $CORE.loadMap("Octree", "regressiontest.scene", "regressiontest")
+        MapLoader.new("regressiontest").loadMap("regressiontest.scene")
         load "regressiontest.rb"
         $World = $CORE.getWorld();
     end

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-05-17 07:10:07 UTC (rev 3451)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-05-17 07:10:59 UTC (rev 3452)
@@ -535,10 +535,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\MapLoader.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\ObjectStateChangeEvent.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectManager.h	2007-05-17 07:10:07 UTC (rev 3451)
+++ rl/trunk/engine/rules/include/GameObjectManager.h	2007-05-17 07:10:59 UTC (rev 3452)
@@ -27,6 +27,7 @@
 namespace rl
 {
     class GameObject;
+	class Property;
     class PropertySet;
 
     class _RlRulesExport GameObjectFactory
@@ -49,6 +50,8 @@
 
         GameObject* getGameObject(unsigned int id) const;
         GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
+		GameObject* createGameObjectFromProperty(const Property& goProp);
+		Property toProperty(const GameObject* const co) const;
         std::list<const GameObject*> getAllGameObjects() const;
         void setGameObjectFactory(GameObjectFactory* gof);
         void loadProperties(const Ogre::String& module);

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-05-17 07:10:07 UTC (rev 3451)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-05-17 07:10:59 UTC (rev 3452)
@@ -20,6 +20,7 @@
 #include "RulesPrerequisites.h"
 
 #include "Container.h"
+#include "Properties.h"
 
 namespace rl {
 
@@ -30,12 +31,11 @@
 /**
  * @brief Verwaltet das Inventar des Charakters
  */
-class _RlRulesExport Inventory
+class _RlRulesExport Inventory : public PropertyHolder
 {
 public:
-///////////////////////////////////////////////////////////////////////////////
-// Typedefs
 
+	static const Ogre::String PROPERTY_CONTENT;
 	/** 
 	* @brief Eine Liste mit Zeigern auf Items
 	**/
@@ -49,8 +49,6 @@
 	Inventory(Creature* owner);
 	virtual ~Inventory();
 
-///////////////////////////////////////////////////////////////////////////////
-// Methoden
 
 	/**
 	* Liefert alle Items im Inventar inm einer Liste
@@ -85,11 +83,15 @@
     void ready(Item* item);
 
     Item* getItem(const CeGuiString& slotName) const;
-    void addSlot(const CeGuiString& name, const Ogre::String& bone, int itemMask);
+    void addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, bool boneSlot = true);
     const SlotMap& getAllSlots() const;
 
 	Creature* getOwner() const;
 
+	virtual const Property getProperty(const Ogre::String& key) const;
+    virtual void setProperty(const Ogre::String& key, const Property& value);
+    virtual PropertySet* getAllProperties() const;
+
 private:
 	bool mValuesUpToDate;
 	Ogre::Real mCurrentWeight;

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-17 07:10:07 UTC (rev 3451)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-05-17 07:10:59 UTC (rev 3452)
@@ -15,6 +15,8 @@
 */
 #include "GameObjectManager.h"
 
+#include <CEGUIPropertyHelper.h>
+
 #include "Armor.h"
 #include "CoreSubsystem.h"
 #include "Container.h"
@@ -145,6 +147,27 @@
         return go;
     }
 
+	GameObject* GameObjectManager::createGameObjectFromProperty(const Property& goProp)
+	{
+		CeGuiString serializedString = goProp.toString();
+
+		CeGuiString::size_type posDivider = serializedString.find("|");
+		
+		if (posDivider != CeGuiString::npos)
+		{
+			Ogre::String classId(serializedString.substr(0, posDivider).c_str());
+			unsigned int goid = CEGUI::PropertyHelper::stringToUint(serializedString.substr(posDivider));
+			return createGameObject(classId, goid);
+		}
+		
+		return NULL;
+	}
+
+	Property GameObjectManager::toProperty(const GameObject* const go) const
+	{
+		return Property(go->getClassId() + "|" + CEGUI::PropertyHelper::uintToString(go->getId()));
+	}
+
     PropertySet* GameObjectManager::getClassProperties(const Ogre::String& classId)
     {
         ClassPropertyMap::const_iterator it = mClassProperties.find(classId);

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-05-17 07:10:07 UTC (rev 3451)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-05-17 07:10:59 UTC (rev 3452)
@@ -24,12 +24,15 @@
 #include "Creature.h"
 #include "Eigenschaft.h"
 #include "Slot.h"
+#include "GameObjectManager.h"
 
 using namespace std;
 
 namespace rl
 {
 
+	const Ogre::String Inventory::PROPERTY_CONTENT = "content";
+
     /**
        Just to remember all parts of the inventory
 
@@ -212,17 +215,75 @@
     {
     }
 
-    void Inventory::addSlot(const CeGuiString& name, const Ogre::String& bone, int itemMask)
+    void Inventory::addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, bool boneSlot)
     {
         if (mSlots.find(name) != mSlots.end())
         {
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+name.c_str()+"' already exists.");
         }
-        mSlots[name] = new BoneSlot(mOwner, name, itemMask, bone);
+
+		if (boneSlot)
+		{
+			mSlots[name] = new BoneSlot(mOwner, name, itemMask, meshpartname);
+		}
+		else
+		{
+			mSlots[name] = new SubmeshSlot(mOwner, name, itemMask, meshpartname);
+		}
     }
 
     const Inventory::SlotMap& Inventory::getAllSlots() const
     {
         return mSlots;
     }
+
+	const Property Inventory::getProperty(const Ogre::String& key) const
+	{
+		Property prop;
+		if (key == Inventory::PROPERTY_CONTENT)
+		{
+			PropertyMap contentProp;
+
+			SlotMap slots = getAllSlots();
+			for (SlotMap::const_iterator it = slots.begin(); it != slots.end(); ++it)
+			{
+				Slot* curSlot = (*it).second;
+				if (curSlot->getItem())
+				{
+					contentProp[(*it).first] = 
+						GameObjectManager::getSingleton().toProperty(curSlot->getItem());
+				}
+			}
+
+			prop.setValue(contentProp);
+		}
+		return prop;
+	}
+    
+	void Inventory::setProperty(const Ogre::String& key, const Property& value)
+	{
+		if (key == Inventory::PROPERTY_CONTENT)
+		{
+			PropertyMap bonesContent = value.toMap();
+			for (PropertyMap::const_iterator it = bonesContent.begin();
+				it != bonesContent.end(); ++it)
+			{
+				Item* item = dynamic_cast<Item*>(
+					GameObjectManager::getSingleton().createGameObjectFromProperty(
+						(*it).second));
+				if (item)
+				{
+					hold(item, (*it).first);
+				}
+			}
+		}
+	}
+
+    PropertySet* Inventory::getAllProperties() const
+	{
+		PropertySet* ps = new PropertySet();
+		ps->setProperty(Inventory::PROPERTY_CONTENT, getProperty(Inventory::PROPERTY_CONTENT));
+		return ps;
+	}
+
 }

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-05-17 07:10:07 UTC (rev 3451)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-05-17 07:10:59 UTC (rev 3452)
@@ -19,6 +19,7 @@
 #include "Creature.h"
 #include "Item.h"
 #include "MeshObject.h"
+#include "MergeableMeshObject.h"
 
 namespace rl {
 
@@ -83,6 +84,15 @@
 
     void SubmeshSlot::setItem(Item* item)
     {
-        ///@todo: use meshcombiner API
+		///@todo: move to actor
+		MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
+			mOwner->getActor()->getControlledObject());
+		if (mmo != NULL)
+		{
+			item->setState(GOS_IN_POSSESSION);
+			mmo->replaceSubmesh(
+				mSubmesh, 
+				item->getMeshfile().c_str());
+		}
     }
 } // namespace rl

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-05-17 07:10:07 UTC (rev 3451)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-05-17 07:10:59 UTC (rev 3452)
@@ -580,7 +580,7 @@
     private:
         Inventory(rl::Creature* owner);
     public:
-        void addSlot(const rl::CeGuiString& name, const Ogre::String& bone, int itemMask);
+		void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemMask, bool boneSlot = true);
         rl::Item* getItem(const rl::CeGuiString& slotName) const;
         void hold(rl::Item* item, const rl::CeGuiString& slot);
         void dropItem(const rl::CeGuiString& slotName);



From blakharaz at mail.berlios.de  Thu May 17 13:40:54 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 17 May 2007 13:40:54 +0200
Subject: [Dsa-hl-svn] r3453 - modules/regressiontest/dsa
	modules/regressiontest/scripts rl/trunk/engine/core/src
	rl/trunk/engine/rules/include rl/trunk/engine/rules/src
Message-ID: <200705171140.l4HBesVe029271@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-17 13:40:48 +0200 (Thu, 17 May 2007)
New Revision: 3453

Modified:
   modules/regressiontest/dsa/mapmeshparttest.gof
   modules/regressiontest/scripts/MergeableMeshTest.rb
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/Slot.cpp
Log:
* Fix error in tests
* Reset MergeableMeshObject part to standard value if an item is removed from a slot 

Modified: modules/regressiontest/dsa/mapmeshparttest.gof
===================================================================
--- modules/regressiontest/dsa/mapmeshparttest.gof	2007-05-17 07:10:59 UTC (rev 3452)
+++ modules/regressiontest/dsa/mapmeshparttest.gof	2007-05-17 11:40:48 UTC (rev 3453)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <GameObjectDefinitions>
 
-    <gameobjectclass classid="M.C.K. test object" baseclass="GameObject">
+    <gameobjectclass classid="mesh construction kit test object" baseclass="GameObject">
         <property name="name" type="STRING" data="M.C.K. Test object"/>
         <property name="description" type="STRING" data="This is the testing object for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
@@ -15,7 +15,7 @@
         </property>
     </gameobjectclass>
 
-    <gameobjectclass classid="M.C.K. test creature" baseclass="Creature">
+    <gameobjectclass classid="mesh construction kit test creature" baseclass="Creature">
         <property name="name" type="STRING" data="M.C.K. Test creature"/>
         <property name="description" type="STRING" data="This is the testing creature for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
@@ -29,13 +29,13 @@
         </property>
     </gameobjectclass>
 
-    <gameobjectclass classid="M.C.K. test item 1" baseclass="Item">
+    <gameobjectclass classid="mesh construction kit test item 1" baseclass="Item">
         <property name="name" type="STRING" data="M.C.K. Test item I"/>
         <property name="description" type="STRING" data="This is the 1st testing item for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_armor_garethplatte.mesh"/>
     </gameobjectclass>
 
-    <gameobjectclass classid="M.C.K. test item 2" baseclass="Item">
+    <gameobjectclass classid="mesh construction kit test item 2" baseclass="Item">
         <property name="name" type="STRING" data="M.C.K. Test item II"/>
         <property name="description" type="STRING" data="This is the 2nd testing item for the M.C.K."/>
         <property name="meshfile" type="STRING" data="men_human_female_armor_kroetenhaut.mesh"/>

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-17 07:10:59 UTC (rev 3452)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-17 11:40:48 UTC (rev 3453)
@@ -16,8 +16,8 @@
         test_obj2.placeIntoScene();
         test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
         test_obj2.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
-        test_item = $GOM.createGameObject("mesh construction kit test item 1")
-        test_obj2.getInventory().hold(test_item, "Torso")
+        test_item2 = $GOM.createGameObject("mesh construction kit test item 1")
+        test_obj2.getInventory().hold(test_item2, "Torso")
 
 
         test_obj3 = $GOM.createGameObject("mesh construction kit test creature")
@@ -25,7 +25,17 @@
         test_obj3.placeIntoScene();
         test_obj3.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
         test_obj3.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
-        test_item2 = $GOM.createGameObject("mesh construction kit test item 2")
-        test_obj3.getInventory().hold(test_item2, "Torso")
+        test_item3 = $GOM.createGameObject("mesh construction kit test item 2")
+        test_obj3.getInventory().hold(test_item3, "Torso")
+        
+        test_obj4 = $GOM.createGameObject("mesh construction kit test creature")
+        test_obj4.setPosition(rel_pos([3, 0, 0]))
+        test_obj4.placeIntoScene();
+        test_obj4.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
+        test_obj4.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_item4 = $GOM.createGameObject("mesh construction kit test item 2")
+        test_obj4.getInventory().hold(test_item4, "Torso")
+        test_obj4.getInventory().dropItem("Torso")
+        
     end
 end

Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-05-17 07:10:59 UTC (rev 3452)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-05-17 11:40:48 UTC (rev 3453)
@@ -93,7 +93,19 @@
 
 	void MergeableMeshObject::removeSubmesh(const Ogre::String& partToRemove)
 	{
-		///@todo MergeableMeshObject::removeSubmesh
+		MeshPartMap::iterator it = mMeshes.find(partToRemove);
+		if (it != mMeshes.end())
+		{
+			mMeshes.erase(it);
+		}
+		else
+		{
+			LOG_ERROR(
+				Logger::CORE, 
+				"Could not remove part '"
+				 + partToRemove + "' from mergeable mesh '"
+				 + getMeshName() + "'. Part not found.");
+		}
 	}
 
 	void MergeableMeshObject::switchTo(const MeshPtr& newMesh)

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2007-05-17 07:10:59 UTC (rev 3452)
+++ rl/trunk/engine/rules/include/GameObject.h	2007-05-17 11:40:48 UTC (rev 3453)
@@ -86,6 +86,8 @@
         const CeGuiString getMeshfile() const;
         void setMeshfile(CeGuiString meshfile);
 
+		const MeshPartMap& getMeshParts() const;
+
         const GeometryType getGeometryType() const;
         void setGeometryType(GeometryType type);
 

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-05-17 07:10:59 UTC (rev 3452)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-05-17 11:40:48 UTC (rev 3453)
@@ -142,6 +142,11 @@
         mMeshfile = meshfile;
     }
 
+	const MeshPartMap& GameObject::getMeshParts() const
+	{
+		return mMeshParts;
+	}
+
     void GameObject::addAction(Action* action, int option)
     {
         if (action == NULL)

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-05-17 07:10:59 UTC (rev 3452)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-05-17 11:40:48 UTC (rev 3453)
@@ -84,15 +84,33 @@
 
     void SubmeshSlot::setItem(Item* item)
     {
-		///@todo: move to actor
+		//@todo: move to actor
 		MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
 			mOwner->getActor()->getControlledObject());
 		if (mmo != NULL)
 		{
-			item->setState(GOS_IN_POSSESSION);
-			mmo->replaceSubmesh(
-				mSubmesh, 
-				item->getMeshfile().c_str());
+			if (item == NULL)
+			{
+				MeshPartMap::const_iterator it = mOwner->getMeshParts().find(mSubmesh);
+				if (it != mOwner->getMeshParts().end())
+				{
+					mmo->replaceSubmesh(
+						mSubmesh,
+						(*it).second);
+				}
+				mItem = NULL;
+			}
+			else
+			{
+				if (isAllowed(item))
+				{			
+					item->setState(GOS_IN_POSSESSION);
+					mmo->replaceSubmesh(
+						mSubmesh, 
+						item->getMeshfile().c_str());
+					mItem = item;
+				}
+			}
 		}
     }
 } // namespace rl



From blakharaz at mail.berlios.de  Thu May 17 23:22:26 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 17 May 2007 23:22:26 +0200
Subject: [Dsa-hl-svn] r3454 - modules/common/models
Message-ID: <200705172122.l4HLMQns025784@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-17 23:21:36 +0200 (Thu, 17 May 2007)
New Revision: 3454

Added:
   modules/common/models/men_human_female.skeleton
   modules/common/models/men_human_female_armor_garethplatte.mesh
   modules/common/models/men_human_female_armor_kroetenhaut.mesh
   modules/common/models/men_human_female_feet_boots01.mesh
   modules/common/models/men_human_female_hair_long01_normal.mesh
   modules/common/models/men_human_female_hand_nude.mesh
   modules/common/models/men_human_female_head02.mesh
   modules/common/models/men_human_female_leg_pants01_long.mesh
   modules/common/models/men_human_female_torso.mesh
Log:
Added missing mesh parts

Added: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female.skeleton
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_armor_garethplatte.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_armor_garethplatte.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_armor_kroetenhaut.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_armor_kroetenhaut.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_feet_boots01.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_feet_boots01.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_hair_long01_normal.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_hair_long01_normal.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_hand_nude.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_hand_nude.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_head02.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_head02.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_leg_pants01_long.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_leg_pants01_long.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_torso.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From blakharaz at mail.berlios.de  Fri May 18 16:12:27 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 18 May 2007 16:12:27 +0200
Subject: [Dsa-hl-svn] r3455 - in modules: common/materials
	common/materials/model common/models regressiontest/scripts
Message-ID: <200705181412.l4IECRFo018805@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-18 16:03:04 +0200 (Fri, 18 May 2007)
New Revision: 3455

Added:
   modules/common/materials/men_human_female_armor_garethplatte.mesh.material
   modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
   modules/common/materials/men_human_female_feet_boots01.mesh.material
   modules/common/materials/men_human_female_hair_long01_normal.mesh.material
   modules/common/materials/men_human_female_hand_nude.mesh.material
   modules/common/materials/men_human_female_head02.mesh.material
   modules/common/materials/men_human_female_leg_pants01_long.mesh.material
   modules/common/materials/men_human_female_torso.mesh.material
   modules/common/materials/model/men_human_female_hair_long_01.png
   modules/common/materials/model/men_human_female_hand.png
   modules/common/materials/model/men_human_female_head02.png
   modules/common/materials/model/obj_boots01.png
   modules/common/materials/model/obj_kroetenhaut.png
   modules/common/materials/model/obj_pants01.png
   modules/common/materials/model/obj_plattediffuse.png
   modules/common/materials/model/obj_shortsleeve02_diffuse.png
Modified:
   modules/common/models/men_human_female_armor_garethplatte.mesh
   modules/common/models/men_human_female_armor_kroetenhaut.mesh
   modules/common/models/men_human_female_feet_boots01.mesh
   modules/common/models/men_human_female_hair_long01_normal.mesh
   modules/common/models/men_human_female_hand_nude.mesh
   modules/common/models/men_human_female_head02.mesh
   modules/common/models/men_human_female_leg_pants01_long.mesh
   modules/common/models/men_human_female_torso.mesh
   modules/regressiontest/scripts/MergeableMeshTest.rb
Log:
Textures for mergeable mesh test, started animation in regressiontest (is badly damaged)

Added: modules/common/materials/men_human_female_armor_garethplatte.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,17 @@
+
+material men_human_female_armor_garethplatte
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture obj_plattediffuse.png
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,17 @@
+
+material men_human_female_armor_kroetenhaut
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture obj_kroetenhaut.png
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/men_human_female_feet_boots01.mesh.material
===================================================================
--- modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,18 @@
+
+material men_human_female_feet_boots_01
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture obj_boots01.png
+				tex_coord_set 1
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/men_human_female_hair_long01_normal.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,17 @@
+
+material men_human_female_hair_long_01_normal
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture men_human_female_hair_long_01.png
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/men_human_female_hand_nude.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hand_nude.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_hand_nude.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,17 @@
+
+material men_human_female_hand_nude
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture men_human_female_hand.png
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/men_human_female_head02.mesh.material
===================================================================
--- modules/common/materials/men_human_female_head02.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_head02.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,17 @@
+
+material men_human_female_head_02
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture men_human_female_head02.png
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/men_human_female_leg_pants01_long.mesh.material
===================================================================
--- modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,17 @@
+
+material men_human_female_legs_pants_01_long
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture obj_pants01.png
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/men_human_female_torso.mesh.material
===================================================================
--- modules/common/materials/men_human_female_torso.mesh.material	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/common/materials/men_human_female_torso.mesh.material	2007-05-18 14:03:04 UTC (rev 3455)
@@ -0,0 +1,18 @@
+
+material men_human_female_torso
+{
+	technique
+	{
+		pass
+		{
+
+			texture_unit
+			{
+				texture obj_shortsleeve02_diffuse.png
+				tex_coord_set 1
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/model/men_human_female_hair_long_01.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_hair_long_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_hand.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_hand.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/men_human_female_head02.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_head02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_boots01.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_boots01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_kroetenhaut.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_kroetenhaut.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_pants01.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_pants01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_plattediffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_plattediffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/obj_shortsleeve02_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/obj_shortsleeve02_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/models/men_human_female_armor_garethplatte.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_kroetenhaut.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_feet_boots01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hair_long01_normal.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hand_nude.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_head02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_leg_pants01_long.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-17 21:21:36 UTC (rev 3454)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-18 14:03:04 UTC (rev 3455)
@@ -14,12 +14,12 @@
         test_obj2 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj2.setPosition(rel_pos([1, 0, 0]))
         test_obj2.placeIntoScene();
+#        test_obj2.getActor().getControlledObject().startAnimation("walk")
         test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
         test_obj2.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
         test_item2 = $GOM.createGameObject("mesh construction kit test item 1")
         test_obj2.getInventory().hold(test_item2, "Torso")
 
-
         test_obj3 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj3.setPosition(rel_pos([2, 0, 0]))
         test_obj3.placeIntoScene();
@@ -27,7 +27,8 @@
         test_obj3.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
         test_item3 = $GOM.createGameObject("mesh construction kit test item 2")
         test_obj3.getInventory().hold(test_item3, "Torso")
-        
+        test_obj3.getActor().getControlledObject().startAnimation("walk")
+
         test_obj4 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj4.setPosition(rel_pos([3, 0, 0]))
         test_obj4.placeIntoScene();
@@ -36,6 +37,6 @@
         test_item4 = $GOM.createGameObject("mesh construction kit test item 2")
         test_obj4.getInventory().hold(test_item4, "Torso")
         test_obj4.getInventory().dropItem("Torso")
-        
+
     end
 end



From pnyx at mail.berlios.de  Sat May 19 10:40:50 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sat, 19 May 2007 10:40:50 +0200
Subject: [Dsa-hl-svn] r3456 - modules/common/models
Message-ID: <200705190840.l4J8eofE004920@sheep.berlios.de>

Author: pnyx
Date: 2007-05-19 10:40:12 +0200 (Sat, 19 May 2007)
New Revision: 3456

Added:
   modules/common/models/men_human_female_feet_boots_01.mesh
   modules/common/models/men_human_female_hair_long_01_normal.mesh
   modules/common/models/men_human_female_head_02.mesh
   modules/common/models/men_human_female_leg_pants_01_long.mesh
Removed:
   modules/common/models/men_human_female_feet_boots01.mesh
   modules/common/models/men_human_female_hair_long01_normal.mesh
   modules/common/models/men_human_female_head02.mesh
   modules/common/models/men_human_female_leg_pants01_long.mesh
Modified:
   modules/common/models/men_human_female.skeleton
   modules/common/models/men_human_female_armor_garethplatte.mesh
   modules/common/models/men_human_female_armor_kroetenhaut.mesh
   modules/common/models/men_human_female_hand_nude.mesh
   modules/common/models/men_human_female_torso.mesh
Log:
Fixed animation and mesh names

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_garethplatte.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_kroetenhaut.mesh
===================================================================
(Binary files differ)

Deleted: modules/common/models/men_human_female_feet_boots01.mesh
===================================================================
(Binary files differ)

Added: modules/common/models/men_human_female_feet_boots_01.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_feet_boots_01.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: modules/common/models/men_human_female_hair_long01_normal.mesh
===================================================================
(Binary files differ)

Added: modules/common/models/men_human_female_hair_long_01_normal.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_hair_long_01_normal.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/models/men_human_female_hand_nude.mesh
===================================================================
(Binary files differ)

Deleted: modules/common/models/men_human_female_head02.mesh
===================================================================
(Binary files differ)

Added: modules/common/models/men_human_female_head_02.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_head_02.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: modules/common/models/men_human_female_leg_pants01_long.mesh
===================================================================
(Binary files differ)

Added: modules/common/models/men_human_female_leg_pants_01_long.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/men_human_female_leg_pants_01_long.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)



From blakharaz at mail.berlios.de  Sat May 19 12:09:55 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 19 May 2007 12:09:55 +0200
Subject: [Dsa-hl-svn] r3457 - in modules/regressiontest: dsa scripts
Message-ID: <200705191009.l4JA9tMt011172@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-19 12:09:51 +0200 (Sat, 19 May 2007)
New Revision: 3457

Modified:
   modules/regressiontest/dsa/mapmeshparttest.gof
   modules/regressiontest/scripts/MergeableMeshTest.rb
Log:
Adapt to renamed models and animation

Modified: modules/regressiontest/dsa/mapmeshparttest.gof
===================================================================
--- modules/regressiontest/dsa/mapmeshparttest.gof	2007-05-19 08:40:12 UTC (rev 3456)
+++ modules/regressiontest/dsa/mapmeshparttest.gof	2007-05-19 10:09:51 UTC (rev 3457)
@@ -8,10 +8,10 @@
         <property name="meshparts" type="MAP">
             <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
             <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
-            <property name="head" type="STRING" data="men_human_female_head02.mesh"/>
-            <property name="hair" type="STRING" data="men_human_female_hair_long01_normal.mesh"/>
-            <property name="leg" type="STRING" data="men_human_female_leg_pants01_long.mesh"/>
-            <property name="feet" type="STRING" data="men_human_female_feet_boots01.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
+            <property name="leg" type="STRING" data="men_human_female_leg_pants_01_long.mesh"/>
+            <property name="feet" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
         </property>
     </gameobjectclass>
 
@@ -22,10 +22,10 @@
         <property name="meshparts" type="MAP">
             <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
             <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
-            <property name="head" type="STRING" data="men_human_female_head02.mesh"/>
-            <property name="hair" type="STRING" data="men_human_female_hair_long01_normal.mesh"/>
-            <property name="leg" type="STRING" data="men_human_female_leg_pants01_long.mesh"/>
-            <property name="feet" type="STRING" data="men_human_female_feet_boots01.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
+            <property name="leg" type="STRING" data="men_human_female_leg_pants_01_long.mesh"/>
+            <property name="feet" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
         </property>
     </gameobjectclass>
 

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-19 08:40:12 UTC (rev 3456)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-19 10:09:51 UTC (rev 3457)
@@ -14,7 +14,7 @@
         test_obj2 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj2.setPosition(rel_pos([1, 0, 0]))
         test_obj2.placeIntoScene();
-#        test_obj2.getActor().getControlledObject().startAnimation("walk")
+#        test_obj2.getActor().getControlledObject().startAnimation("Walk")
         test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
         test_obj2.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
         test_item2 = $GOM.createGameObject("mesh construction kit test item 1")
@@ -27,7 +27,7 @@
         test_obj3.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
         test_item3 = $GOM.createGameObject("mesh construction kit test item 2")
         test_obj3.getInventory().hold(test_item3, "Torso")
-        test_obj3.getActor().getControlledObject().startAnimation("walk")
+        test_obj3.getActor().getControlledObject().startAnimation("Walk")
 
         test_obj4 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj4.setPosition(rel_pos([3, 0, 0]))



From pnyx at mail.berlios.de  Sat May 19 13:03:35 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Sat, 19 May 2007 13:03:35 +0200
Subject: [Dsa-hl-svn] r3458 - modules/common/models
Message-ID: <200705191103.l4JB3ZN2020871@sheep.berlios.de>

Author: pnyx
Date: 2007-05-19 13:03:32 +0200 (Sat, 19 May 2007)
New Revision: 3458

Modified:
   modules/common/models/men_human_female_hair_long_01_normal.mesh
   modules/common/models/men_human_female_hand_nude.mesh
Log:
hair and hands fixed

Modified: modules/common/models/men_human_female_hair_long_01_normal.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hand_nude.mesh
===================================================================
(Binary files differ)



From melven at mail.berlios.de  Sun May 20 01:19:45 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 20 May 2007 01:19:45 +0200
Subject: [Dsa-hl-svn] r3459 - in rl/trunk/engine/core: include src
Message-ID: <200705192319.l4JNJj0b006606@sheep.berlios.de>

Author: melven
Date: 2007-05-20 01:19:35 +0200 (Sun, 20 May 2007)
New Revision: 3459

Modified:
   rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
   rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
Log:
overloaded the execute function in order to specify a vector with multiple materials (needed in MovementCharacterController)

Modified: rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2007-05-19 11:03:32 UTC (rev 3458)
+++ rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2007-05-19 23:19:35 UTC (rev 3459)
@@ -19,6 +19,8 @@
 
 #include "CorePrerequisites.h"
 #include <OgreNewt.h>
+#include <vector>
+#include <utility>
 
 namespace rl {
     struct _RlCoreExport RaycastInfo
@@ -35,6 +37,8 @@
     class _RlCoreExport PhysicsMaterialRaycast : OgreNewt::Raycast
     {
     public:
+        typedef std::vector<const OgreNewt::MaterialID*> MaterialVector;
+
         PhysicsMaterialRaycast();
 
         /** executes the Raycast
@@ -47,10 +51,21 @@
         */
         RaycastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
             const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool invertmat = false);
+        
+        /** executes the Raycast
+        * @param world OgreNewt-World
+        * @param materials a vector with pairs of a material and a boolean value, that describes if this material should be matched or not
+        * If this param is NULL, every material will be found
+        * @param startpt start-point of the cast
+        * @param endpt end-point of the cast
+        */
+        RaycastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
+            const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool invertmat = false);
 
         bool userCallback(OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID);
     private:
         RaycastInfo mInfo;
+        const MaterialVector *mMaterialVector;
         const OgreNewt::MaterialID* mMaterial;
         bool mGetNearest;
         bool mInvertMat;

Modified: rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2007-05-19 11:03:32 UTC (rev 3458)
+++ rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2007-05-19 23:19:35 UTC (rev 3459)
@@ -28,6 +28,7 @@
     RaycastInfo PhysicsMaterialRaycast::execute(OgreNewt::World* world, const MaterialID* material,
         const Vector3& start, const Vector3& end, bool invertmat)
     {
+        mMaterialVector = NULL;
         mMaterial = material;
         mInvertMat = invertmat;
 
@@ -41,23 +42,75 @@
         return mInfo;
     }
 
+    RaycastInfo PhysicsMaterialRaycast::execute(OgreNewt::World* world, const MaterialVector* materials,
+        const Vector3& start, const Vector3& end, bool invertmat)
+    {
+        mMaterialVector = materials;
+        mMaterial = NULL;
+        mInvertMat = invertmat;
+
+        mInfo.mBody = 0;
+        mInfo.mDistance = 1.1;
+        mInfo.mNormal = Vector3::ZERO;
+        
+        mGetNearest = false;
+        go(world, start, end);
+        
+        return mInfo;
+    }
+
     bool PhysicsMaterialRaycast::userCallback(Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID)
     {
-        if( mMaterial == NULL )
+        if( body->getMaterialGroupID() == NULL )
         {
             mInfo.mBody = body;
             mInfo.mDistance = distance;
             mInfo.mNormal = normal;
             mGetNearest = true;
+            LOG_MESSAGE(Logger::CORE, "Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!");
         }
-        else if (body->getMaterialGroupID() && 
-            (body->getMaterialGroupID()->getID() == mMaterial->getID() && !mInvertMat ||
-             body->getMaterialGroupID()->getID() != mMaterial->getID() && mInvertMat))
+        else
         {
-            mInfo.mBody = body;
-            mInfo.mDistance = distance;
-            mInfo.mNormal = normal;
-            mGetNearest = true;
+            if( mMaterial == NULL && mMaterialVector == NULL)
+            {
+                mInfo.mBody = body;
+                mInfo.mDistance = distance;
+                mInfo.mNormal = normal;
+                mGetNearest = true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body->getMaterialGroupID()->getID() == mMaterial->getID() && !mInvertMat ||
+                    body->getMaterialGroupID()->getID() != mMaterial->getID() && mInvertMat)
+                {
+                    mInfo.mBody = body;
+                    mInfo.mDistance = distance;
+                    mInfo.mNormal = normal;
+                    mGetNearest = true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector->begin(); iter != mMaterialVector->end(); iter++)
+                {
+                    if (body->getMaterialGroupID()->getID() == (*iter)->getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found && !mInvertMat || !found && mInvertMat )
+                {
+                    mInfo.mBody = body;
+                    mInfo.mDistance = distance;
+                    mInfo.mNormal = normal;
+                    mGetNearest = true;
+                }
+            }
         }
         return mGetNearest;
     }



From melven at mail.berlios.de  Sun May 20 12:52:06 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 20 May 2007 12:52:06 +0200
Subject: [Dsa-hl-svn] r3460 - in rl/trunk/engine: rules rules/include
	rules/src ui/include ui/src
Message-ID: <200705201052.l4KAq6LO029405@sheep.berlios.de>

Author: melven
Date: 2007-05-20 12:51:25 +0200 (Sun, 20 May 2007)
New Revision: 3460

Added:
   rl/trunk/engine/rules/include/MovingCreature.h
   rl/trunk/engine/rules/include/MovingCreatureManager.h
   rl/trunk/engine/rules/src/MovingCreature.cpp
   rl/trunk/engine/rules/src/MovingCreatureManager.cpp
Modified:
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/RulesSubsystem.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/ui/include/MovementCharacterController.h
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
new movement-system:
MovingCreature and MovingCreatureManager provide an interface for simply setting the "movement" of a creature. Each "movement" has its own class. All the stuff related to moving a creature (like force, contactCallback and animations) is now done in these classes, so the movement-functions in creature are not needed any more.

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-05-20 10:51:25 UTC (rev 3460)
@@ -345,6 +345,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\MovingCreature.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\MovingCreatureManager.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\ObjectStateChangeEvent.cpp"
 				>
 			</File>
@@ -535,6 +543,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\MovingCreature.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\MovingCreatureManager.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\ObjectStateChangeEvent.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/include/Creature.h	2007-05-20 10:51:25 UTC (rev 3460)
@@ -674,91 +674,7 @@
             virtual void setProperty(const Ogre::String& key, const Property& value);
             virtual PropertySet* getAllProperties() const;
 
-
-            /**
-             * Berechnet die taktische Geschwindigkeit bei der angegebenen Bewegungsart (siehe Basisbox S.112 ff).
-             * Eventuelle Athletikproben werden hier nicht miteinbezogen!
-             * Die Wirkung der Modifikatoren h???gt von den Eigenschaften der Kreatur ab!
-             * Eine gezogene Waffe (bedeutet Aufmerksamkeit) msste hier auch miteinbezogen werden.
-             * Eigentlich sind die Modifikatoren laut Regelwerk nur fr strategische Bewegung gedacht,
-             * aber man k???nte sie auch gut hier einbauen zum Ausspielen von Vorteilen wie Gel???dekundig
-             * @param movementType Flag fr die Art der Bewegung
-             * @param modified Gibt an, ob die Behinderung und ???nliches miteinbezogen werden soll, 
-             *  bei zu geringerer Au gibt dies auch eine geringere Geschwindigkeit zurck
-             * @param modifikatoren Flags fr verschiedene Modifikatoren wie Gel???de und Wetter
-             * @retval Berechnete Geschwindigkeit, kann diese Bewegung nicht ausgefhrt werden, ist der Wert 0
-             *  Bei Sprngen ist die Angabe die H???e oder die Weite des Sprungs, bei Drehungen die Umdrehungen pro Sekunde
-            **/
-            float getTaktischeGeschwindigkeitsBasis(int movementType, bool modified, int modifikatoren = 0);
-            // die Reihenfolger der Definitionen hier ist wichtig!
-            static const int BEWEGUNG_NONE = 0;
-            //static const int BEWEGUNG_FALLEN = -1 ?
-            // schlie???n sich gegenseitig aus
-            static const int BEWEGUNG_GEHEN = 1; // bitte das hier nicht ???dern, ohne sich der Folgen in MovementCharacterController bewusst zu sein!
-            static const int BEWEGUNG_JOGGEN = 2;
-            static const int BEWEGUNG_LAUFEN = 4;
-            static const int BEWEGUNG_RENNEN = 8;
-            //static const int BEWEGUNG_SCHWIMMEN = 6;
-            //static const int BEWEGUNG_TAUCHEN = 7;
-            // schlie???n sich gegenseitig aus
-            static const int BEWEGUNG_WEITSPRUNG = 16;
-            static const int BEWEGUNG_HOCHSPRUNG = 32;
-            //static const int BEWEGUNG_PRAEZISER_SPRUNG = 24;
-            static const int BEWEGUNG_SCHLEICHEN = 64; //allgemein fr den Versuch leise zu sein?
-            // k???nen miteinander kombiniert werden
-            static const int BEWEGUNG_RUECKWAERTS = 128;
-            static const int BEWEGUNG_SEITWAERTS = 256;
-            // k???nen nicht miteinander kombiniert werden
-            static const int BEWEGUNG_DREHEN = 512;
-            static const int BEWEGUNG_UMDREHEN = 1024;
-            //static const int BEWEGUNG_BALANCIEREN = 1024;
-            //static const int BEWEGUNG_FLUCHT = 2048; //weiterrennen auch bei zu niedriger AU?
-            //...
-            // folgendes sinnvoll? siehe taktische und strategische Bewegung
-            //static const int BEWEGUNG_MOD_NONE = 0;
-            //static const int BEWEGUNG_MOD_REICHSSTRASSE = 1;
-            //static const int BEWEGUNG_MOD_STADT = 2;
-            //static const int BEWEGUNG_MOD_OFFENES_GELAENDE = 4;
-            //static const int BEWEGUNG_MOD_STEILER_ABHANG = 8; // ? ...
-
-
-            /**
-             * Gibt an, ob die angegebene taktische Bewegungsart im Moment berhaupt m???lich ist.
-             * (Ausdauer und Talentwerte hoch genug?)
-            **/
-            bool canUseTaktischeBewegung(int movementType);
-
-
-            /**
-             * Fhrt eine taktische Bewegung aus, das bedeutet, es werden falls n???ig Proben abgelegt
-             * und die Ver???derungen der AU und LE berechnet; fr Richtungs???derungen (Drehung) beim Laufen/etc
-             * muss die Funktion zweimal aufgerufen werden, einmal um die Laufgeschwindigkeit und einmal um die 
-             * Rotationsgeschwindigkeit zu ermitteln 
-             * (das bedeutet auch, dass sobald eine Drehung angegeben wird, nur die Auswirkungen der Drehung, 
-             * nicht der restlichen Bewegung ermittelt werden)
-             * @param movementType Flag fr die Art der Bewegung
-             * @param modifikator Flags fr die Umgebung
-             * @param time Die Dauer der Bewegung; hier sind kurze Zeiten vorgesehen (Dauer einer Frame)
-             * @param patzer Falls eine Probe ben???igt wird, gibt dies die briggebliebenen TaW an.
-             *  Ein negativer Wert steht fr einen Patzer; je kleiner der Wert, desto schlimmer sollten die
-             *  Auswirkungen ausfallen!
-             * @param probenErschwernis Um diesen Wert sind alle ben???igten Proben erschwert, dient vor allem
-             *  dazu, erschwerte Schleichen-Proben oder ???nliches zu erm???lichen!
-             * @retval Berechnete Geschwindigkeit (alle Ergebnisse von Talentproben einbezogen)
-            **/
-            float doTaktischeBewegung(int movementType, float time, int& patzer, int probenErschwernis = 0, int modifikatoren = 0);
-
-            /**
-             * Fragt den aktuellen Bewegungstyp ab.
-            **/
-            int getTaktischeBewegung(void) const;
-
-            /**
-             * Setzt den aktuellen Bewegungstyp. Wird ebenfalls in doTaktischeBewegung getan!
-            **/
-            void setTaktischeBewegung(int type);
-
-            void setAlignment(Alignment);
+             void setAlignment(Alignment);
             Alignment getAlignment() const;
 
         protected:

Added: rl/trunk/engine/rules/include/MovingCreature.h
===================================================================
--- rl/trunk/engine/rules/include/MovingCreature.h	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/include/MovingCreature.h	2007-05-20 10:51:25 UTC (rev 3460)
@@ -0,0 +1,244 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+
+
+#ifndef __MovingCreature_H__
+#define __MovingCreature_H__
+
+#include "RulesPrerequisites.h"
+#include "PhysicsController.h"
+#include "PhysicsGenericContactCallback.h"
+#include "Creature.h"
+#include "Actor.h"
+#include <map>
+
+
+
+namespace rl
+{
+    class AbstractMovement;
+    class MovingCreatureManager;
+
+    /** 
+     * This class provides an interface to control the movement of a creature.
+     * It handles all nessessary things like animations and calculates the movement speed.
+     */
+    class _RlRulesExport MovingCreature :
+        public PhysicsController,
+        public PhysicsGenericContactCallback
+    {
+    public:
+        /** Constructor.
+		 * @param creature the creature of the bot/char
+		 * @param actor the actor of the bot/char
+		 */
+        MovingCreature(Creature *character);
+        ~MovingCreature();
+
+        /**
+         * This function is not intented to be called directly
+         * @retval true, if this MovingCreature still needs to be called every frame
+         */
+        bool run(Ogre::Real elapsedTime);
+
+        /// Newton force and torque callback
+        void OnApplyForceAndTorque(PhysicalThing* thing);
+
+        /// Newton contact callback called by the movingCreatureManager
+        int userProcess();
+
+        Creature *getCreature() {return mCreature;}
+
+        /** 
+         * the different movements a creature can perform, 
+         * there must be an adequate movement-class
+         * (derived from AbstractMovement)
+         */
+        typedef enum
+        {
+            // these movements can be used
+            MT_NONE,
+            MT_STEHEN,
+            MT_GEHEN,
+            MT_JOGGEN,
+            MT_LAUFEN,
+            MT_RENNEN,
+            MT_RUECKWAERTS_GEHEN,
+            MT_RUECKWAERTS_JOGGEN,
+            MT_SEITWAERTS_GEHEN,
+            MT_SCHLEICHEN,
+            MT_HOCHSPRUNG,
+            MT_WEITSPRUNG,
+            // these movements are only for internal purposes and should not be used directly
+            // instead use one of the movements above
+            MT_DREHEN
+        } MovementType;
+
+        /// The generalization of the place (in the air, on the floor, in the water...)
+        typedef enum { 
+            AL_AIRBORNE, // the creature is floating/falling in the air
+            AL_FLOOR // the creature is standing/lying/moving/... on the floor
+        } AbstractLocation;
+
+        /**
+         * sets wether the creature is airborne or not
+         * this is done by this class itself every frame, so using this method does probably not
+         * have the desired effect
+         */
+        void setAbstractLocation(AbstractLocation type) {mAbstractLocation = type;}
+
+        AbstractLocation getAbstractLocation() const {return mAbstractLocation;}
+
+
+        /**
+         * the most important function: sets a new movement or changes the direction or rotation of a movement
+         * if this movement isn't possible, the fallback-movement is called.
+         * The movement doesn't change until another movement is set, so it is not necessary to call this function 
+         * every frame. Only the rotation is resettet to zero every new frame!
+         * @param type the id of the movement
+         * @param direction if the direction isn't possible (see AbstractMovement::isDirectionPossible), only a "part" of the direction is applied
+         * @param rotation like above
+         * @retval false signifies that the change to this movement was not possible (possibly because the present movement forbade it)
+         */
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+
+
+        MovementType getMovementId() const;
+        Ogre::Vector3 getDirection() const {return mDirection;}
+
+        /// This function does probably not return the expected value, because the rotation is resetted every frame!
+        Ogre::Vector3 getRotation() const {return mRotation;}
+
+        /// This function can return NULL
+        AbstractMovement *getMovement() {return mMovement;}
+
+        /// This function can return NULL
+        AbstractMovement *getMovementFromId(MovementType id);
+
+        // some methods used by movements
+        int getCurrentGS() const;
+        Ogre::Vector3 getVelocity() const; // in local axes
+        Ogre::Vector3 getOmega() const;
+        void setAnimation(const Ogre::String &name, 
+                          Ogre::Real speed = 1, 
+                          unsigned int timesToPlay = 0, 
+                          const Ogre::String &collisionName = "" // the name of the animation the collision is based on
+                          );
+
+
+    protected:
+        Creature *mCreature;
+        AbstractLocation mAbstractLocation;
+        
+        
+        AbstractMovement *mMovement;
+        Ogre::Vector3 mDirection;
+        Ogre::Vector3 mRotation;
+
+        typedef std::map<MovementType, AbstractMovement*> MovementMap;
+        MovementMap mMovementMap;
+
+        // in order to copy the contactcallback members correctly;
+        friend class MovingCreatureManager;
+    };
+
+    /// this is the base class of all movements
+    class AbstractMovement : 
+        public OgreNewt::ContactCallback
+    {
+    public:
+        AbstractMovement(MovingCreature *movingCreature) : mMovingCreature(movingCreature) {}
+
+        /// returns the id of this movement
+        virtual MovingCreature::MovementType getId() const = 0;
+
+        /// returns the id of the movement that is used, if this movement isn't possible (any more)
+        virtual MovingCreature::MovementType getFallBackMovement() const = 0;
+
+        /**
+         * this method calculates the basis velocity (without any changes due to Talentproben etc)
+         * @param velocity this parameter returns the calculated "velocity" ( m/s, rpm, or width/height of a jump)
+         * @retval false indicates, that this movement isn't possible, so the calculated values can be incorrect
+         */
+        virtual bool calculateBaseVelocity(Ogre::Real &velocity) = 0;
+
+        /**
+         * this method specifies, if the movement is possible
+         */
+        virtual bool isPossible() const = 0;
+
+        /**
+         * this method is called, when this movement is currently used to enable 
+         * an individual procession of collisions contacts for each movement
+         */
+        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
+
+        /**
+         * this method is called by OnApplyTorqueAndForceCallback of the MovingCreature
+         * the PhysicalThing can be acquired via the Creature
+         */
+        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep) = 0;
+
+        /**
+         * this method indicates if it is possible to change to the specified movement at this moment
+         */
+        virtual bool canChangeToMovement(MovingCreature::MovementType id) {return true;}
+
+        /**
+         * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
+         */
+        virtual void requestChangeToMovement(MovingCreature::MovementType id) {}
+
+        /**
+         * here all the stuff not (directly) relating the physics should be done
+         * this function is called every frame if this movement is activated and the
+         * Creature is in an active moving state. It is important to handle all 
+         * "Talentproben" etc here and not in the physics function!
+         * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
+         * @retval true indicates that the creature should remain active (in order to activate it use MovingCreatureManager::setActive)
+         */
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
+
+        /**
+         * this function is called if this movement is activated.
+         * it can be used to determine if a new "Talentprobe" is needed
+         */
+        virtual void activate() {}
+
+        /**
+         * this function is called every time this movement is deactivated.
+         */
+        virtual void deactivate() {}
+
+        /**
+         * this method is used to get to know if a movement can be used with a certain direction
+         * @retval true if this movement can be used with the direction, false otherwise
+         * @param direction (in local axes); if this function returns false, this variable contains another valid direction (constructed from the given direction)
+         */
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const = 0;
+
+        /**
+         * this method is used to get to know if the given rotation can be used with this movement
+         * @retval true if the creature can perform this rotation with this movement
+         * @param rotation (in local axes and rpm); if the function returns false, this variable contains another valid rotation (constructed from the given rotation)
+         */
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const = 0;
+
+    protected:
+        MovingCreature *mMovingCreature;
+    };
+}
+#endif

Added: rl/trunk/engine/rules/include/MovingCreatureManager.h
===================================================================
--- rl/trunk/engine/rules/include/MovingCreatureManager.h	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/include/MovingCreatureManager.h	2007-05-20 10:51:25 UTC (rev 3460)
@@ -0,0 +1,83 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+
+
+#ifndef __MovingCreatureManager_H__
+#define __MovingCreatureManager_H__
+
+#include "RulesPrerequisites.h"
+#include "GameTask.h"
+#include "PhysicsGenericContactCallback.h"
+#include <vector>
+#include <map>
+
+
+
+namespace rl
+{
+    class MovingCreature;
+
+    class _RlRulesExport MovingCreatureManager : 
+        public GameTask,
+        public Ogre::Singleton<MovingCreatureManager>,
+        public PhysicsGenericContactCallback
+    {
+    public:
+        MovingCreatureManager();
+        ~MovingCreatureManager();
+
+        /**
+         * adds a new movingCreature, this function is not intended to be used directly; 
+         * each MovingCreature is automatically added. a creature is always added in a
+         * idle state
+         */
+        void add(MovingCreature *movingCreature);
+
+        /**
+         * removes a movingCreature, this function is not intended to be used directly, 
+         * destroy the movingCreature instead.
+         */
+        void remove(MovingCreature *movingCreature);
+
+        void run(Ogre::Real elapsedTime);
+
+        /**
+         * Sets a movingCreature in an active state, this means that it is updated every
+         * frame. This must be the case, if the creature is moving. If a creature is in an
+         * idle state, it is only updated less often
+         */
+        void setActive(MovingCreature* movingCreature);
+
+        const Ogre::String & getName() const {return mName;}
+
+        // Newton Contact Callback
+        int userProcess();
+    protected:
+        typedef std::vector<MovingCreature*> MovingCreatureVector;
+        MovingCreatureVector mActiveCreatures;
+        MovingCreatureVector mIdleCreatures;
+        MovingCreatureVector mAddToActiveCreatures;
+        Ogre::Real mUpdateIdleTime;
+        Ogre::Real mTimeSinceLastIdleUpdate;
+        Ogre::String mName;
+
+        typedef std::map<OgreNewt::Body*,MovingCreature*> MovingCreatureBodyMap;
+        MovingCreatureBodyMap mMovingCreatureFromBody;
+    };
+}
+
+
+#endif

Modified: rl/trunk/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/trunk/engine/rules/include/RulesSubsystem.h	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/include/RulesSubsystem.h	2007-05-20 10:51:25 UTC (rev 3460)
@@ -27,6 +27,7 @@
     class ActionManager;
     class CombatManager;
     class DsaManager;
+    class MovingCreatureManager;
     class TimerManager;
     class XdimlLoader;
 
@@ -44,6 +45,7 @@
         ActionManager* mActionManager;
         CombatManager* mCombatManager;
         DsaManager* mDsaManager;
+        MovingCreatureManager *mMovingCreatureManager;
         TimerManager* mTimerManager;
         XdimlLoader* mXdimlLoader;
     };

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-05-20 10:51:25 UTC (rev 3460)
@@ -1008,519 +1008,4 @@
 
         return ps;
     }
-
-    int Creature::getTaktischeBewegung(void) const
-    {
-        return mMovementType;
-    }
-
-    void Creature::setTaktischeBewegung(int type)
-    {
-        mMovementType = type;
-    }
-
-
-    bool Creature::canUseTaktischeBewegung(int movementType)
-    {
-        if( movementType == BEWEGUNG_NONE )
-        {
-            return true;
-        }
-        // kann sich die Kreatur ueberhaupt bewegen?
-        ///@todo What other Stati prohibit creature  movement? Paralyzed? Incapacitated? Sleep? etc.
-        ///@todo Crouching still possible, even if immobilized.
-        if (getStatus() & Effect::STATUS_IMMOBILE)
-        {
-          //CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Immobile!\"");
-          return false;
-        }
-
-        if( getAu() <= 1 )
-            return false;
-
-
-
-        if( movementType & BEWEGUNG_SCHLEICHEN )
-        {
-            // if( getragenes Gewicht > 2*KK ) return false
-            if( movementType & 
-                (BEWEGUNG_RENNEN | BEWEGUNG_LAUFEN | BEWEGUNG_JOGGEN |
-                BEWEGUNG_HOCHSPRUNG | BEWEGUNG_WEITSPRUNG | BEWEGUNG_UMDREHEN) 
-                )
-            {
-                return false;
-            }
-
-        }
-        else if( movementType & BEWEGUNG_SEITWAERTS )
-        {
-            if( movementType & 
-                (BEWEGUNG_RENNEN | BEWEGUNG_JOGGEN |
-                BEWEGUNG_HOCHSPRUNG | BEWEGUNG_WEITSPRUNG | BEWEGUNG_UMDREHEN)
-                )
-            {
-                return false;
-            }
-        }
-        else if( (movementType & BEWEGUNG_HOCHSPRUNG) || (movementType & BEWEGUNG_WEITSPRUNG) )
-        {
-            // if( getragenes Gewicht > KK ) return false
-            if( getAu() < 6.0 || getAu() < getAuBasis()/3.0 )
-                return false;
-        }
-
-
-
-        if( (movementType & BEWEGUNG_DREHEN) ||
-            (movementType & BEWEGUNG_UMDREHEN))
-        {
-        }
-        else if( movementType & BEWEGUNG_RENNEN )
-        {
-            // if( getragenes Gewicht > KK ) return false
-            // getCurrentBE() > ?
-            if( getAu() < 6.0 || getAu() < getAuBasis()/3.0 )
-                return false;
-        }
-        else if( movementType & BEWEGUNG_LAUFEN )
-        {
-            // if( getragenes Gewicht > 1.5*KK ) return false
-            if( getAu() < 6.0 )
-                return false;
-        }
-        else if( movementType & BEWEGUNG_JOGGEN )
-        {
-            // if( getragenes Gewicht > 2*KK ) return false
-            if( getAu() < 6.0 )
-                return false;
-        }
-        else if( movementType & BEWEGUNG_GEHEN )
-        {
-        }    
-
-        return true;
-    }
-
-
-
-
-    float Creature::getTaktischeGeschwindigkeitsBasis(int movementType, bool modified, int modifikatoren)
-    {
-        static float factorJoggen = 2.0;
-        // Bewegung nicht m??glich!
-        if( !canUseTaktischeBewegung(movementType) )
-            return 0;
-
-
-		int act_gs = getWert(WERT_GS);
-        if( modified )
-            act_gs -= getCurrentBe();
-        if( act_gs < 1 )
-            act_gs = 1;
-
-        float velocity = 0;
-
-
-        // drehen ist ein sonderfall! angabe der Rotationsgeschwindigkeit in Umdrehungen pro Sekunde
-        if( (movementType & BEWEGUNG_DREHEN) ||
-            (movementType & BEWEGUNG_UMDREHEN) )
-        {
-            if( movementType & BEWEGUNG_UMDREHEN )
-                velocity = 0.5;
-            else
-                velocity = 0.3;
-            //if( modified )
-            //    velocity -= getCurrentBe()/getEigenschaft("GE");
-            if( movementType & BEWEGUNG_SCHLEICHEN )
-                velocity *= 0.5;
-            return velocity;
-        }
-
-
-
-
-        if( movementType & BEWEGUNG_SCHLEICHEN )
-        {
-            if( !(movementType & BEWEGUNG_GEHEN) && !(movementType & BEWEGUNG_JOGGEN) &&
-                !(movementType & BEWEGUNG_RENNEN) && !(movementType & BEWEGUNG_LAUFEN) )
-            {
-                return 0;
-            }
-            if( (movementType & BEWEGUNG_RUECKWAERTS) || (movementType & BEWEGUNG_SEITWAERTS) )
-                return 1;
-            if( modified && getCurrentBe() > 1 )
-                return 1;
-            
-            return 2;
-        }
-        else if( movementType & BEWEGUNG_WEITSPRUNG )
-        {
-            float mod;
-            if( movementType & BEWEGUNG_RENNEN )
-                mod = 1;
-            else if( movementType & BEWEGUNG_LAUFEN )
-                mod = 0.6;
-            else if( movementType & BEWEGUNG_JOGGEN )
-                mod = 0.5;
-            else
-                mod = 0.3;
-            velocity = mod*(getEigenschaft("GE") + getEigenschaft("KK")) / 5.0;
-
-            if( modified )
-            {
-                // steht nicht in den Regeln aber finde ich sinnvoll
-                // velocityBase *= (1 - getrageneLast/KK);
-                // steht in den Regeln: pro Ersch??pfung ein KK abziehen
-                if( mErschoepfung > getEigenschaft("KO") )
-                    velocity -= mod*(mErschoepfung - getEigenschaft("KO")) / 5.0;
-                // steht nicht in den Regeln, aber finde ich sinnvoll
-                if( getAu() < getAuBasis() / 3.0 )
-                    velocity -= mod*(getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 5.0;
-            }
-            if( movementType & BEWEGUNG_SCHLEICHEN )
-            {
-                velocity *= 0.3;
-            }
-            if( movementType & BEWEGUNG_RUECKWAERTS )
-            {
-                velocity *= 0.3;
-            }
-            return velocity;
-        }
-        else if( movementType & BEWEGUNG_HOCHSPRUNG )
-        {
-            velocity = (getEigenschaft("GE") + getEigenschaft("KK")) / 4.0 / 5.0;
-            
-            if( modified )
-            {
-                // steht nicht in den Regeln aber finde ich sinnvoll
-                // velocityBase *= (1 - getrageneLast/KK);
-                // steht in den Regeln: pro Ersch??pfung ein KK abziehen
-                if( mErschoepfung > getEigenschaft("KO") )
-                    velocity -= (mErschoepfung - getEigenschaft("KO")) / 4.0 / 5.0;
-                // steht nicht in den Regeln, aber finde ich sinnvoll
-                if( getAu() < getAuBasis() / 3.0 )
-                    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 4.0 / 5.0;
-            }
-            if( movementType & BEWEGUNG_SCHLEICHEN )
-            {
-                velocity *= 0.3;
-            }
-            return velocity;
-        }
-
-
-        if( movementType & BEWEGUNG_RUECKWAERTS )
-        {
-            if( (movementType & BEWEGUNG_RENNEN) ||
-                (movementType & BEWEGUNG_LAUFEN) ||
-                (movementType & BEWEGUNG_JOGGEN) )
-            {
-                velocity = 0.6 * act_gs / factorJoggen;
-            }
-            else if( (movementType & BEWEGUNG_GEHEN) )
-            {
-                velocity = 0.6 * act_gs / 3.6;
-            }
-
-            if( movementType & BEWEGUNG_SCHLEICHEN )
-            {
-                velocity = 0.3 * act_gs / 3.6;
-            }
-            return velocity;
-        }
-        else if( movementType & BEWEGUNG_SEITWAERTS )
-        {
-            if( (movementType & BEWEGUNG_RENNEN) || 
-                (movementType & BEWEGUNG_LAUFEN) ||
-                (movementType & BEWEGUNG_JOGGEN) )
-            {
-                velocity = 0.8 * act_gs / factorJoggen;
-            }
-            else if( movementType & BEWEGUNG_GEHEN )
-            {
-                velocity = 0.8 * act_gs / 3.6;
-            }
-            
-            if( movementType & BEWEGUNG_SCHLEICHEN )
-            {
-                velocity = 0.4 * act_gs / 3.6;
-            }            
-            return velocity;
-        }
-
-
-
-        if( movementType & BEWEGUNG_SCHLEICHEN )
-        {
-            if( !(movementType & BEWEGUNG_GEHEN) && !(movementType & BEWEGUNG_JOGGEN) &&
-                !(movementType & BEWEGUNG_RENNEN) && !(movementType & BEWEGUNG_LAUFEN) )
-            {
-                return 0;
-            }
-            if( modified && getCurrentBe() > 1 )
-                return 1;
-            
-            return 2;
-        }
-
-
-        if( movementType & BEWEGUNG_RENNEN )
-        {
-            velocity = act_gs;
-        }
-        else if( movementType & BEWEGUNG_LAUFEN )
-        {
-            velocity = act_gs / 2.0;
-        }
-        else if( movementType & BEWEGUNG_JOGGEN )
-        {
-            velocity = act_gs / 3.0;
-        }
-        else if( movementType & BEWEGUNG_GEHEN )
-        {
-            velocity = act_gs / 3.6;
-        }
-        else
-        {
-            velocity = 0;
-        }
-        return velocity;
-    }
-
-
-
-    float Creature::doTaktischeBewegung(int movementType, Ogre::Real time, int& patzer, int probenErschwernis, int modifikatoren)
-    {
-        // damit bei einem Sprint immer nur eine Probe gemacht wird!
-        static int lastProbeTaW = 0;
-        static Ogre::Real lastProbeTime = 0;
-        static int lastMovementType = 0;
-        lastProbeTime -= time;
-        bool movementTypeChanged = false;
-        if( movementType != lastMovementType ) // das System l??sst sich durch Zwischendurch nicht rennen austricksen!!!!
-            movementTypeChanged = true;
-        lastMovementType = movementType;
-        
-        const int regenerateAuModifier_Gehen = 2;
-        const float regenerateAuFactor_Gehen = 0.5;
-        const int regenerateAuModifier_Stehen = 1;
-        const float regenerateAuFactor_Stehen = 0.75;
-
-
-
-
-        float velocity = getTaktischeGeschwindigkeitsBasis(movementType, true, modifikatoren);
-
-
-        setTaktischeBewegung(movementType);
-
-        
-
-
-        if( movementType & BEWEGUNG_DREHEN )
-        {
-            return velocity;
-        }
-
-
-
-        if( movementType & BEWEGUNG_SCHLEICHEN )
-        {
-//
-/*
-            try // schleichen wirklich hier machen?
-            {
-                patzer = doTalentprobe("Schleichen", probenErschwernis);
-            }
-            catch(OutOfRangeException err)
-            {
-                patzer = RESULT_MISSERFOLG;
-            }
-*/
-            return velocity;
-        }
-        else if( movementType & BEWEGUNG_WEITSPRUNG )
-        {
-            try
-            {
-                patzer = doTalentprobe("Athletik", probenErschwernis);
-                if( patzer > 0 )
-                {
-                    if( patzer == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        velocity += getTalent("Athletik") / 25.0;
-                    }
-                    else if( patzer == RESULT_AUTOERFOLG )
-                    {
-                        velocity += getTalent("Athletik") / 50.0;
-                    }
-                    else
-                    {
-                        velocity += patzer / 50.0;
-                    }
-                }
-            }
-            catch(OutOfRangeException err)
-            {
-                patzer = 0;
-            }
-            // Ausdauerverbrauch: eigentlich 1, aber ich denke das ist zu hoch
-            damageAu(2./3);
-            return velocity;
-        }
-        else if( movementType & BEWEGUNG_HOCHSPRUNG )
-        {
-            try
-            {
-                patzer = doTalentprobe("Athletik", probenErschwernis);
-                if( patzer > 0 )
-                {
-                    if( patzer == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        velocity += getTalent("Athletik") / 12.5;
-                    }
-                    else if( patzer == RESULT_AUTOERFOLG )
-                    {
-                        velocity += getTalent("Athletik") / 25.0;
-                    }
-                    else
-                    {
-                        velocity += patzer / 25.0;
-                    }
-                }
-            }
-            catch(OutOfRangeException err)
-            {
-                patzer = 0;
-            }
-            // Ausdauerverbrauch:
-            damageAu(2./3);
-            return velocity;
-        }
-
-
-        if( movementType & BEWEGUNG_RUECKWAERTS )
-        {
-            if( (movementType & BEWEGUNG_RENNEN) || 
-                (movementType & BEWEGUNG_LAUFEN) ||
-                (movementType & BEWEGUNG_JOGGEN) )
-            {
-            }
-            else if( movementType & BEWEGUNG_GEHEN )
-            {
-            }
-            return velocity;
-        }
-        else if( movementType & BEWEGUNG_SEITWAERTS )
-        {
-            if( (movementType & BEWEGUNG_RENNEN) || 
-                (movementType & BEWEGUNG_LAUFEN) ||
-                (movementType & BEWEGUNG_JOGGEN) )
-            {
-            }
-            else if( movementType & BEWEGUNG_GEHEN )
-            {
-            }
-            
-            return velocity;
-        }
-
-
-
-        if( movementType & BEWEGUNG_RENNEN )
-        {
-            // f??r Rennen Athletik-probe -> h??here Geschwindigkeit
-            try
-            {
-                if( lastProbeTime <= 0 || movementTypeChanged)
-                {
-                	int lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
-                    patzer = (int)lastProbeTaW;
-                    lastProbeTime = getAuMax();
-                }
-                else
-                {
-                    // wird nur einmal angerechnet ?
-                    patzer = 0;
-                }
-                if( lastProbeTaW > 0 )
-                {
-                    if( lastProbeTaW == RESULT_AUTOERFOLG )
-                    {
-                        velocity += getTalent("Athletik") * 0.2;
-                    }
-                    else if( lastProbeTaW == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        velocity += getTalent("Athletik") * 0.3;
-                    }
-                    else
-                    {
-                        velocity += lastProbeTaW;
-                    }
-                }
-                damageAu(time/1.5);
-            }
-            catch(OutOfRangeException err)
-            {
-                patzer = 0;
-            }
-        }
-        else if( movementType & BEWEGUNG_LAUFEN )
-        {
-            // f??r Laufen, Athletik-Probe weniger Ausdauer-Verbrauch
-            float timePerAu = 180;
-            try
-            {
-                if( lastProbeTime <= 0 || movementTypeChanged )
-                {
-                    lastProbeTaW = doTalentprobe("Athletik", probenErschwernis);
-                    patzer = lastProbeTaW;
-                    lastProbeTime = Date::ONE_SPIELRUNDE;
-                }
-                else
-                {
-                    // wird nur einmal angerechnet ?
-                    patzer = 0;
-                }
-                if( lastProbeTaW > 0 )
-                {
-                    if( lastProbeTaW == RESULT_AUTOERFOLG )
-                    {
-                        timePerAu += getTalent("Athletik") * 5;
-                    }
-                    else if( lastProbeTime == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        timePerAu += getTalent("Athletik") * 10;
-                    }
-                    else
-                    {
-                        timePerAu += lastProbeTaW * 5;
-                    }
-                }
-                damageAu(time/timePerAu);
-            }
-            catch(OutOfRangeException err)
-            {
-                patzer = 0;
-            }
-        }
-        else if( movementType & BEWEGUNG_JOGGEN )
-        {
-        }
-        else if( movementType & BEWEGUNG_GEHEN )
-        {
-            regenerateAu(regenerateAuModifier_Gehen, regenerateAuFactor_Gehen, time);
-        }
-        else
-        {
-            // rumstehen
-            regenerateAu(regenerateAuModifier_Stehen, regenerateAuFactor_Stehen, time);
-        }
-
-        return velocity;
-    }
-
-
-
 }

Added: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-20 10:51:25 UTC (rev 3460)
@@ -0,0 +1,1194 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+
+
+#include "Actor.h"
+#include "Creature.h"
+#include "DsaManager.h"
+#include "MeshAnimation.h"
+#include "MeshObject.h"
+#include "MovingCreature.h"
+#include "MovingCreatureManager.h"
+#include "PhysicsManager.h"
+#include "PhysicalThing.h"
+
+
+
+using namespace Ogre;
+using namespace std;
+
+namespace rl
+{
+
+    class Stehen : public AbstractMovement
+    {
+    public:
+        Stehen(MovingCreature *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_STEHEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
+        virtual void activate()
+        {
+            getRotationMovement()->activate();
+        }
+        virtual void deactivate()
+        {
+            getRotationMovement()->deactivate();
+        }
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = 0.0f; 
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            return 
+                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getCreature()->getAu() > 0 &&
+                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_DEAD | Effect::STATUS_UNCONSCIOUS | Effect::STATUS_SLEEPING));
+        }
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        {
+            getRotationMovement()->calculateForceAndTorque(force, torque, timestep);
+
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+            body->getMassMatrix(mass, inertia);
+
+            Vector3 vel = mMovingCreature->getVelocity();
+            Real delay (2 * PhysicsManager::getSingleton().getMaxTimestep());
+            if(vel.squaredLength() > mVelocity.squaredLength())
+                delay *= 1.5;
+            force = mass * (mVelocity - vel) / delay;
+        }
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            direction.normalise();
+            Real velocity;
+            calculateBaseVelocity(velocity);
+            mVelocity = direction * velocity;
+            applyAuChanges(elapsedTime);
+            setAnimation(elapsedTime);
+            if( rotation != Vector3::ZERO )
+                if( getRotationMovement()->isPossible() )
+                    return getRotationMovement()->run(elapsedTime, direction, rotation);
+            return false;
+        }
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            Real omegaY = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega().y;
+            if( omegaY > Degree(20).valueRadians() )
+                mMovingCreature->setAnimation("drehen_links");
+            else
+            {
+                if( omegaY < Degree(-20).valueRadians() )
+                    mMovingCreature->setAnimation("drehen_rechts");
+                else
+                    mMovingCreature->setAnimation("idle");                            
+            }
+        }
+        virtual void applyAuChanges(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
+        }
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
+        {
+            Vector3 oldDirection(direction);
+            direction = Vector3::ZERO;
+            return oldDirection == Vector3::ZERO;
+        }
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
+        {
+            return getRotationMovement()->isRotationPossible(rotation);
+        }
+    protected:
+        Ogre::Vector3 mVelocity;
+        virtual AbstractMovement* getRotationMovement() const
+        {
+            static AbstractMovement *stehen_drehen(NULL);
+
+            if( stehen_drehen == NULL)
+            {                
+                stehen_drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+            }
+            if( stehen_drehen == NULL )
+            {
+                Throw(NullPointerException, "Konnte Movement mit der Id MT_STEHEN_DREHEN nicht finden.");
+            }
+            return stehen_drehen;
+        }
+    };
+
+    class Drehen : public AbstractMovement
+    {
+    public:
+        Drehen(MovingCreature *creature) : AbstractMovement(creature), mYaw(0)
+        {
+            mRotLinearSpringK = 600.0f;
+            Real relationCoefficient = 1.0f;
+            mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
+        }
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_DREHEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = 0.3f;
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            return 
+                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getCreature()->getAu() > 1 &&
+                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
+        }
+        virtual void activate()
+        {
+            mYaw = mMovingCreature->getCreature()->getActor()->getWorldOrientation().getYaw();
+        }
+        virtual void deactivate()
+        {
+        }
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        {
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+            body->getMassMatrix(mass, inertia);
+
+            Quaternion orientation = mMovingCreature->getCreature()->getActor()->getWorldOrientation();
+            // Calculate angular velocity
+            // We first need the yaw rotation from actual yaw to desired yaw
+            Vector3 src = orientation*Vector3::UNIT_Z;
+            src.y = 0;
+            Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
+            dst.y = 0;
+            Radian yaw = src.getRotationTo(dst, Vector3::UNIT_Y).getYaw();
+
+            // using a spring system to apply the rotation
+            Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
+            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
+            omega.x = omega.z = 0;
+            Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
+            torque = mass * springAcc;
+        }
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            mYaw += Radian(rotation.y);
+            while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
+            while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
+            return rotation.y != 0.0f;
+        }
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
+        {
+            Vector3 oldDirection(direction);
+            direction = Vector3::ZERO;
+            return oldDirection == Vector3::ZERO;
+        }
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
+        {
+            Vector3 oldRotation(rotation);
+            rotation.x = rotation.y = 0;
+            return oldRotation.x == 0 && oldRotation.y == 0;
+        }
+    protected:
+        Ogre::Radian mYaw;
+        Ogre::Real mRotLinearDampingK, mRotLinearSpringK;
+    };
+
+
+    class Gehen : public Stehen
+    {
+    public:
+        Gehen(MovingCreature *creature) : Stehen(creature) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_GEHEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 3.6f; 
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            return 
+                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR && 
+                mMovingCreature->getCreature()->getAu() > 1 &&
+                !(mMovingCreature->getCreature()->getStatus() & Effect::STATUS_IMMOBILE);
+        }
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            Stehen::run(elapsedTime, direction, rotation);
+            return true;
+        }
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
+        {
+            Vector3 oldDirection(direction);
+            direction.x = direction.y = 0;
+            if( direction.z > 0 )
+                direction.z = 0;
+            return oldDirection.x == 0 && oldDirection.y == 0 && oldDirection.z > 0;
+        }
+        virtual void applyAuChanges(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
+        }
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->setAnimation("gehen");
+        }
+    };
+
+    class Joggen : public Gehen
+    {
+    public:
+        Joggen(MovingCreature *creature) : Gehen(creature) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_JOGGEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_GEHEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 2.8f; 
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            return Gehen::isPossible() &&
+                mMovingCreature->getCreature()->getAu() > 6;
+        }
+        virtual void applyAuChanges(Ogre::Real elapsedTime) {} // empty
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->setAnimation("rennen");
+        }
+    };
+
+    class Laufen : public Gehen
+    {
+    public:
+        Laufen(MovingCreature *creature) : Gehen(creature), mTimePerAu(1), mLastProbe(0) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_LAUFEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_JOGGEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 2.0f; 
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            if( mMovingCreature->getMovement() == this )
+                return Gehen::isPossible() &&
+                    mMovingCreature->getCreature()->getAu() > 6;
+            else
+                return Gehen::isPossible() &&
+                    mMovingCreature->getCreature()->getAu() > 10;
+        }
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            doTalentProbeIfNecessary();
+            return Gehen::run(elapsedTime, direction, rotation);
+        }
+        virtual void applyAuChanges(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->getCreature()->damageAu(elapsedTime/mTimePerAu);
+        }
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->setAnimation("rennen");
+        }
+        virtual void activate()
+        {
+            doTalentProbeIfNecessary();
+        }
+        virtual void doTalentProbeIfNecessary()
+        {
+            Date now = DsaManager::getSingleton().getCurrentDate();
+            if( mLastProbe + Date::ONE_SPIELRUNDE >= now || mLastProbe == 0 )
+            {
+                mTimePerAu = 180;
+                try
+                {
+                    mLastProbe = now;
+                    int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
+                    if( taw == RESULT_AUTOERFOLG )
+                    {
+                        mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 5;
+                    }
+                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 10;
+                    }
+                    else
+                    {
+                        mTimePerAu += taw * 5;
+                    }
+                }
+                catch(OutOfRangeException)
+                {
+                    mTimePerAu = 180;
+                }
+            }
+        }
+    protected:
+        Real mTimePerAu;
+        Date mLastProbe;
+    };
+
+
+    class Rennen : public Gehen
+    {
+    public:
+        Rennen(MovingCreature *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RENNEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_LAUFEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS(); 
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            if( mMovingCreature->getMovement() == this )
+                return Gehen::isPossible() &&
+                    mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.3 &&
+                    mMovingCreature->getCreature()->getAu() > 6;
+            else
+                return Gehen::isPossible() &&
+                    mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.5 &&
+                    mMovingCreature->getCreature()->getAu() > 10;
+        }
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            doTalentProbeIfNecessary();
+            bool ret = Gehen::run(elapsedTime, direction, rotation);
+            mVelocity += mVelocityImprovement;
+            return ret;
+        }
+        virtual void applyAuChanges(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->getCreature()->damageAu(elapsedTime/1.5);
+        }
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->setAnimation("rennen");
+        }
+        virtual void activate()
+        {
+            doTalentProbeIfNecessary();
+        }
+        virtual void doTalentProbeIfNecessary()
+        {
+            Date now = DsaManager::getSingleton().getCurrentDate();
+            if( mLastProbe + mMovingCreature->getCreature()->getAuMax() * Date::ONE_SECOND >= now || mLastProbe == 0)
+            {
+                mVelocityImprovement = 0;
+                try
+                {
+                    mLastProbe = now;
+                    int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
+                    if( taw == RESULT_AUTOERFOLG )
+                    {
+                        mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.2;
+                    }
+                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.3;
+                    }
+                    else
+                    {
+                        mVelocityImprovement += taw * 0.1;
+                    }
+                }
+                catch(OutOfRangeException)
+                {
+                    mVelocityImprovement = 0;
+                }
+            }
+        }
+    protected:
+        Real mVelocityImprovement;
+        Date mLastProbe;
+    };
+
+    class RueckwaertsGehen : public Gehen
+    {
+    public:
+        RueckwaertsGehen(MovingCreature *creature) : Gehen(creature) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 4.0; 
+            return isPossible();
+        }
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->setAnimation("gehen_rueckwaerts");
+        }
+    };
+
+    class RueckwaertsJoggen : public Joggen
+    {
+    public:
+        RueckwaertsJoggen(MovingCreature *creature) : Joggen(creature) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_JOGGEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 3.2; 
+            return isPossible();
+        }
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            mMovingCreature->setAnimation("rennen");
+        }
+    };
+
+
+    class SeitwaertsGehen : public Gehen
+    {
+    public:
+        SeitwaertsGehen(MovingCreature *creature) : Gehen(creature), mLeft(true) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SEITWAERTS_GEHEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 4.0; 
+            return isPossible();
+        }
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
+        {
+            Vector3 oldDirection(direction);
+            direction.z = direction.y = 0;
+            return oldDirection.z == 0 && oldDirection.y == 0;
+        }
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            mLeft = direction.x < 0;
+            return Gehen::run(elapsedTime, direction, rotation);
+        }
+        virtual void setAnimation(Ogre::Real elapsedTime)
+        {
+            if( mLeft )
+                mMovingCreature->setAnimation("seitwaerts_links");
+            else
+                mMovingCreature->setAnimation("seitwaerts_rechts");
+        }
+    protected:
+        bool mLeft;
+    };
+
+    class Schleichen : public Gehen
+    {
+    public:
+        Schleichen(MovingCreature *creature) : Gehen(creature), mState(UP), mTimer(0) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SCHLEICHEN;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = mMovingCreature->getCurrentGS() / 6.0; 
+            return isPossible();
+        }
+        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            if( mState == UPTODOWN )
+            {
+                mTimer += elapsedTime;
+                if( mTimer > 0.5f )
+                    mState = DOWN;
+            }
+            if( mState == UP )
+            {
+                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+            }
+            if( mState == DOWNTOUP )
+            {
+                mTimer += elapsedTime;
+                if( mTimer > 0.5f )
+                    mState = UP;
+            }
+            if( mState == DOWN )
+            {
+                setAnimation(elapsedTime);
+                direction.normalise();
+                Real velocity;
+                calculateBaseVelocity(velocity);
+                mVelocity = direction * velocity;
+                if( direction == Vector3::ZERO )
+                    mMovingCreature->setAnimation("hocke_idle");
+                else
+                    mMovingCreature->setAnimation("hocke_gehen");
+                applyAuChanges(elapsedTime);
+                if( rotation != Vector3::ZERO )
+                    if( getRotationMovement()->isPossible() )
+                        getRotationMovement()->run(elapsedTime, direction, rotation);
+            }
+            else
+                mVelocity = Vector3::ZERO;
+            return true;
+        }
+        void applyAuChanges(Ogre::Real elapsedTime) {}
+        virtual void setAnimation(Ogre::Real elapsedTime) {} // is not used
+        virtual void activate()
+        {
+            mState = UPTODOWN;
+            mMovingCreature->setAnimation("idle_zu_hocke",1,1,"idle");
+            mTimer = 0;
+        }
+        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        {
+            return mState == UP;
+        }
+        virtual void requestChangeToMovement(MovingCreature::MovementType id)
+        {
+            if( mState == DOWN )
+            {
+                mState = DOWNTOUP;
+                mMovingCreature->setAnimation("hocke_zu_stehen",1,1,"idle");
+                mTimer = 0;
+            }
+        }
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Real mTimer;
+    };
+
+
+    class Hochsprung : public AbstractMovement
+    {
+    public:
+        Hochsprung(MovingCreature *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_HOCHSPRUNG;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual void activate()
+        {
+            mState = DOWNTOUP;
+            mMovingCreature->setAnimation("idle_absprung",1,1,"idle");
+            mTimer = 0;
+            calculateBaseVelocity(mHeight);
+
+            try
+            {
+                int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
+                if( taw > 0 )
+                {
+                    if( taw == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 12.5;
+                    }
+                    else if( taw == RESULT_AUTOERFOLG )
+                    {
+                        mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
+                    }
+                    else
+                    {
+                        mHeight += taw / 25.0;
+                    }
+                }
+            }
+            catch(OutOfRangeException err)
+            {
+            }
+            mMovingCreature->getCreature()->damageAu(2./3);
+        }
+        virtual void deactivate()
+        {
+        }
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") + 
+                        mMovingCreature->getCreature()->getEigenschaft("KK")) / 4.0 / 5.0;
+
+            // steht nicht in den Regeln aber finde ich sinnvoll
+            // velocityBase *= (1 - getrageneLast/KK);
+            // steht in den Regeln: pro Ersch?pfung ein KK abziehen
+            //if( mErschoepfung > getEigenschaft("KO") )
+            //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 4.0 / 5.0;
+            // steht nicht in den Regeln, aber finde ich sinnvoll
+            //if( getAu() < getAuBasis() / 3.0 )
+            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 4.0 / 5.0;
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            if( mMovingCreature->getMovement() == this )
+                return
+                    (mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR ||
+                    mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE) &&
+                    mMovingCreature->getCreature()->getAu() > 6 &&
+                    !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
+            else
+                return 
+                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getCreature()->getAu() > 10 &&
+                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
+                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
+        }
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        {
+            if( mJumpNow )
+            {
+                mJumpNow = false;
+
+                Real mass;
+                Vector3 inertia;
+                OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+                body->getMassMatrix(mass, inertia);
+
+                Real m = mass;
+                Real g = PhysicsManager::getSingleton().getGravity().length();
+                Real t = timestep;
+                Real h = mHeight;
+                Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
+                force = Vector3(0,
+                    jumpForce,
+                    0);
+                mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+            }
+        }
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            if( mState == DOWN )
+            {
+                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+            }
+            if( mState == UPTODOWN )
+            {
+                mTimer += elapsedTime;
+                if( mTimer >= 0.5f )
+                {
+                    mState = DOWN;
+                }
+            }
+            if( mState == UP )
+            {
+                mTimer += elapsedTime;
+                if( mTimer < 0.5f )
+                {
+                    mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                }
+                else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
+                {
+                    mState = UPTODOWN;
+                    mMovingCreature->setAnimation("idle_sprung_landung", 1, 1, "idle");
+                    mTimer = 0;
+                }
+            }
+            if( mState == DOWNTOUP )
+            {
+                mTimer += elapsedTime;
+                if( mTimer >= 0.5f )
+                {
+                    mState = UP;
+                    mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
+                    //mMovingCreature->setAnimation("idle_sprung");
+                    mJumpNow = true;
+                    mTimer = 0;
+                }
+            }
+            return false;
+        }
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
+        {
+            Vector3 oldDirection(direction);
+            direction.z = direction.x = 0;
+            if(direction.y < 0)
+                direction.y = 0;
+            return oldDirection.x == 0 && oldDirection.z == 0 && oldDirection.y > 0;
+        }
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
+        {
+            return false;
+        }
+        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        {
+            return mState == DOWN;
+        }
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mHeight;
+        bool mJumpNow;
+        Ogre::Real mTimer;
+    };
+
+
+    class Weitsprung : public AbstractMovement
+    {
+    public:
+        Weitsprung(MovingCreature *creature) : AbstractMovement(creature), mState(DOWN), mWidth(0), mJumpNow(false), mTimer(0) {}
+        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_WEITSPRUNG;}
+        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual void activate()
+        {
+            mState = DOWNTOUP;
+            mMovingCreature->setAnimation("rennen_absprung",1,1,"rennen");
+            mTimer = 0;
+            calculateBaseVelocity(mWidth);
+
+            try
+            {
+                int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
+                if( taw > 0 )
+                {
+                    if( taw == RESULT_SPEKT_AUTOERFOLG )
+                    {
+                        mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
+                    }
+                    else if( taw == RESULT_AUTOERFOLG )
+                    {
+                        mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 50.0;
+                    }
+                    else
+                    {
+                        mWidth += taw / 50.0;
+                    }
+                }
+            }
+            catch(OutOfRangeException err)
+            {
+            }
+            mMovingCreature->getCreature()->damageAu(2./3);
+        }
+        virtual void deactivate()
+        {
+        }
+        virtual bool calculateBaseVelocity(Real &velocity)
+        {
+            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") + 
+                        mMovingCreature->getCreature()->getEigenschaft("KK")) / 5.0;
+
+            // steht nicht in den Regeln aber finde ich sinnvoll
+            // velocityBase *= (1 - getrageneLast/KK);
+            // steht in den Regeln: pro Ersch?pfung ein KK abziehen
+            //if( mErschoepfung > getEigenschaft("KO") )
+            //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 5.0;
+            // steht nicht in den Regeln, aber finde ich sinnvoll
+            //if( getAu() < getAuBasis() / 3.0 )
+            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 5.0;
+            return isPossible();
+        }
+        virtual bool isPossible() const
+        {
+            if( mMovingCreature->getMovement() == this )
+                return
+                    (mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR ||
+                    mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE) &&
+                    mMovingCreature->getCreature()->getAu() > 6 &&
+                    !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
+            else
+                return 
+                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getCreature()->getAu() > 10 &&
+                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
+                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
+        }
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        {
+            if( mJumpNow )
+            {
+                mJumpNow = false;
+
+                Real mass;
+                Vector3 inertia;
+                OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+                body->getMassMatrix(mass, inertia);
+
+
+                Real m = mass;
+                Real g = PhysicsManager::getSingleton().getGravity().length();
+                Real v0 = mMovingCreature->getVelocity().length();
+                Real t = timestep;
+                Real s = mWidth;
+                Real jumpForcezy = 
+                    m*g/4 - v0*m /2 /t + 
+                    Math::Sqrt( 
+                        v0*v0 * m*m  -
+                        v0 * m*m *g *t +
+                        m*m * g*g * t*t /4 +
+                        2 * s * m*m *g
+                               )/2/t;
+                force += Vector3(0,jumpForcezy,-jumpForcezy);
+                mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+            }
+        }
+        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
+        {
+            if( mState == DOWN )
+            {
+                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+            }
+            if( mState == UPTODOWN )
+            {
+                mTimer += elapsedTime;
+                if( mTimer >= 0.5f )
+                {
+                    mState = DOWN;
+                }
+            }
+            if( mState == UP )
+            {
+                mTimer += elapsedTime;
+                if( mTimer < 0.5f )
+                {
+                    mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                }
+                else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
+                {
+                    mState = UPTODOWN;
+                    mMovingCreature->setAnimation("rennen_sprung_landung", 1, 1, "rennen");
+                    mTimer = 0;
+                }
+            }
+            if( mState == DOWNTOUP )
+            {
+                mTimer += elapsedTime;
+                if( mTimer >= 0.5f )
+                {
+                    mState = UP;
+                    mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
+                    //mMovingCreature->setAnimation("rennen_sprung");
+                    mJumpNow = true;
+                    mTimer = 0;
+                }
+            }
+            return false;
+        }
+        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
+        {
+            Vector3 oldDirection(direction);
+            direction.x = 0;
+            if(direction.y <= 0 || direction.z >= 0)
+                direction.y = direction.z = 0;
+            return oldDirection.x == 0 && oldDirection.z < 0 && oldDirection.y > 0;
+        }
+        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
+        {
+            return false;
+        }
+        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        {
+            return mState == DOWN;
+        }
+    protected:
+        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
+        Ogre::Real mWidth;
+        bool mJumpNow;
+        Ogre::Real mTimer;
+    };
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    MovingCreature::MovingCreature(Creature *creature) :
+        mCreature(creature),
+        mAbstractLocation(AL_AIRBORNE),
+        mMovement(NULL),
+        mDirection(Vector3::ZERO),
+        mRotation(Vector3::ZERO)
+    {
+        MovingCreatureManager::getSingleton().add(this);
+        
+        const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID("character");
+        mCreature->getActor()->getPhysicalThing()->setMaterialID(material);
+
+        mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
+
+
+        std::pair<MovementType, AbstractMovement*> movementPair;
+        movementPair.first = MT_NONE;
+        movementPair.second = NULL;
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_DREHEN;
+        movementPair.second = new Drehen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_STEHEN;
+        movementPair.second = new Stehen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_GEHEN;
+        movementPair.second = new Gehen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_JOGGEN;
+        movementPair.second = new Joggen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_LAUFEN;
+        movementPair.second = new Laufen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_RENNEN;
+        movementPair.second = new Rennen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_RUECKWAERTS_GEHEN;
+        movementPair.second = new RueckwaertsGehen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_RUECKWAERTS_JOGGEN;
+        movementPair.second = new RueckwaertsJoggen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_SEITWAERTS_GEHEN;
+        movementPair.second = new SeitwaertsGehen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_SCHLEICHEN;
+        movementPair.second = new Schleichen (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_HOCHSPRUNG;
+        movementPair.second = new Hochsprung (this);
+        mMovementMap.insert(movementPair);
+        movementPair.first = MT_WEITSPRUNG;
+        movementPair.second = new Weitsprung (this);
+        mMovementMap.insert(movementPair);
+    }
+
+    MovingCreature::~MovingCreature()
+    {
+        MovementMap::iterator iter;
+        for(iter = mMovementMap.begin(); iter != mMovementMap.end(); iter++)
+            delete iter->second;
+        mMovementMap.erase(mMovementMap.begin(), mMovementMap.end());
+
+        mCreature->getActor()->getPhysicalThing()->setPhysicsController(NULL);
+
+        MovingCreatureManager::getSingleton().remove(this);
+    }
+
+    MovingCreature::MovementType MovingCreature::getMovementId() const
+    {
+        if (mMovement == NULL) 
+            return MT_NONE; 
+        else 
+            return mMovement->getId();
+    }
+
+    int MovingCreature::getCurrentGS() const
+    {
+        int act_gs = mCreature->getWert(Creature::WERT_GS);
+        ///@todo wy does this not work
+        //act_gs -= mCreature->getWert(Creature::WERT_BE);
+        return max(act_gs,1);
+    }
+
+    void MovingCreature::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName)
+    {
+        static Ogre::String lastName("");
+        static Ogre::String lastCollisionName("");
+        static Real lastSpeed(1);
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
+        PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
+        
+        if( lastName != name)
+        {
+            const Ogre::String *pCollisionName = &collisionName;
+            if( collisionName == "" )
+                pCollisionName = &name;
+
+            if( *pCollisionName != lastCollisionName )
+            {
+                pt->fitToPose(*pCollisionName);
+                lastCollisionName = *pCollisionName;
+            }
+            mesh->stopAllAnimations();
+
+
+            mesh->startAnimation(name, speed, timesToPlay);
+            lastName = name;
+            lastSpeed = speed;
+        }
+        else
+        {
+            if( lastSpeed != speed )
+            {
+                MeshAnimation *meshAnim = mesh->getAnimation(name);
+                meshAnim->setSpeed(speed);
+                lastSpeed = speed;
+            }
+        }
+    }
+
+    Ogre::Vector3 MovingCreature::getVelocity() const
+    {
+        return 
+            mCreature->getActor()->getPhysicalThing()->getOrientation().Inverse() *
+            mCreature->getActor()->getPhysicalThing()->_getBody()->getVelocity();
+    }
+
+    Ogre::Vector3 MovingCreature::getOmega() const
+    {
+        return mCreature->getActor()->getPhysicalThing()->_getBody()->getOmega();
+    }
+
+    bool MovingCreature::run(Real elapsedTime)
+    {
+        if(mMovement != NULL)
+        {
+            if( !mMovement->isPossible() )
+            {
+                setMovement(mMovement->getFallBackMovement(), mDirection, mRotation);
+                if( mMovement == NULL )
+                    return false;
+            }
+
+            Vector3 rotation(mRotation);
+            mRotation = Vector3::ZERO;
+            return mMovement->run(elapsedTime, mDirection, rotation);
+        }
+        return false;
+    }
+
+    void MovingCreature::OnApplyForceAndTorque(PhysicalThing* thing)
+    {
+        Vector3 force, torque;
+        OgreNewt::Body *body = thing->_getBody();
+        force = Vector3::ZERO;
+        torque = Vector3::ZERO;
+        OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+        Real timestep = world->getTimeStep();
+        Real mass;
+        Vector3 inertia;
+        body->getMassMatrix(mass, inertia);
+
+        if(mMovement != NULL)
+        {
+            mMovement->calculateForceAndTorque(force, torque, timestep);
+            force = thing->getOrientation() * force;
+        }
+        else
+        {
+            // don't move
+            force = - mass * body->getVelocity() / 1 * timestep;
+            force.y = 0;
+        }
+        force += mass * PhysicsManager::getSingleton().getGravity();
+        body->setForce(force);
+        body->setTorque(torque);
+    }
+
+    int MovingCreature::userProcess()
+    {
+        // own collision handling (floor, in order to get information for mAbstractLocation)
+        Vector3 point;
+        Vector3 normal;
+        getContactPositionAndNormal(point, normal);
+
+        // determine if this contact is with the floor.
+        // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
+        Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
+
+        Vector3 charPos;
+        Quaternion charOri;
+        mCreature->getActor()->getPhysicalThing()->_getBody()->getPositionOrientation(charPos, charOri);
+        bool isFloorCollision(false);
+
+        //AxisAlignedBox CharAab = mCharBody->getCollision()->getAABB();
+        //Real charHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
+        Real stepHeight = point.y - charPos.y;
+
+        if( stepHeight < 0.5f )
+            isFloorCollision = true;
+
+        static Real lastFloorContact(0.0f);
+        if ( isFloorCollision )
+        {
+            setAbstractLocation(AL_FLOOR);
+            if(stepHeight > 0.1f)
+                setContactNormalAcceleration(10);
+            setContactElasticity(0.0f);
+            lastFloorContact = 0.0f;
+        }
+        else
+        {
+            lastFloorContact += PhysicsManager::getSingleton()._getNewtonWorld()->getTimeStep();
+            if(lastFloorContact >= 2.2f || getAbstractLocation() == AL_AIRBORNE)
+                setAbstractLocation(AL_AIRBORNE);
+        }
+
+
+        if(mMovement != NULL)
+        {
+            // i hope this will copy the protected members of the contact callback
+            OgreNewt::ContactCallback *movement = mMovement;
+            *movement = (OgreNewt::ContactCallback)(*this);
+            return movement->userProcess();
+        }
+
+        // return one to tell Newton we want to accept this contact
+        return 1;
+    }
+
+    AbstractMovement *MovingCreature::getMovementFromId(MovingCreature::MovementType id)
+    {
+        MovementMap::iterator iter = mMovementMap.find(id);
+        if(iter == mMovementMap.end())
+        {
+            Throw(IllegalArgumentException, "Der angegebene Bewegungstyp wurde nicht gefunden.");
+        }
+        return iter->second;
+    }
+
+
+    bool MovingCreature::setMovement(MovementType type, Vector3 direction, Vector3 rotation)
+    {
+        if( mMovement != NULL )
+        {
+            if( mMovement->getId() == type )
+            {
+                MovingCreatureManager::getSingleton().setActive(this);
+                mDirection = direction;
+                mRotation = rotation;
+                return true;
+            }
+        }
+
+        if( mMovement != NULL )
+        {
+            if( !mMovement->canChangeToMovement(type) )
+            {
+                mMovement->requestChangeToMovement(type);
+                return false;
+            }
+        }
+
+        AbstractMovement *movement = getMovementFromId(type);
+
+
+        while(movement != NULL)
+        {
+            if(movement->isPossible())
+            {
+                MovingCreatureManager::getSingleton().setActive(this); // runs the old movement if idle!
+                if(mMovement != NULL)
+                    mMovement->deactivate();
+                mMovement = movement;
+                mMovement->activate();
+                mDirection = direction;
+                mRotation = rotation;
+                return true;
+            }
+
+            movement = getMovementFromId(movement->getFallBackMovement());
+        }
+
+        return false;
+    }
+}

Added: rl/trunk/engine/rules/src/MovingCreatureManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreatureManager.cpp	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/src/MovingCreatureManager.cpp	2007-05-20 10:51:25 UTC (rev 3460)
@@ -0,0 +1,228 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+
+
+#include "Actor.h"
+#include "Creature.h"
+#include "GameTask.h"
+#include "GameLoop.h"
+#include "Exception.h"
+#include "MovingCreatureManager.h"
+#include "MovingCreature.h"
+
+
+using namespace Ogre;
+using namespace std;
+
+
+template<> rl::MovingCreatureManager* Singleton<rl::MovingCreatureManager>::ms_Singleton = 0;
+
+
+namespace rl
+{
+    MovingCreatureManager::MovingCreatureManager() :
+            mUpdateIdleTime(1.0f),
+            mTimeSinceLastIdleUpdate(0.0f),
+            mName("MovingCreatureManager")
+    {
+        GameLoop::getSingleton().addTask(this, GameLoop::TG_LOGIC);
+
+        PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
+        // the material of moving creatures
+        const OgreNewt::MaterialID *char_mat = physicsManager->createMaterialID("character");
+
+        const OgreNewt::MaterialID *def_mat = physicsManager->createMaterialID("default");
+        const OgreNewt::MaterialID *level_mat = physicsManager->createMaterialID("level");
+
+        physicsManager->createMaterialPair(char_mat, def_mat)->setContactCallback(this);
+        physicsManager->createMaterialPair(char_mat, level_mat)->setContactCallback(this);
+    }
+
+    MovingCreatureManager::~MovingCreatureManager()
+    {
+        PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
+        const OgreNewt::MaterialID *char_mat = physicsManager->getMaterialID("character");
+
+        const OgreNewt::MaterialID *def_mat = physicsManager->getMaterialID("default");
+        const OgreNewt::MaterialID *level_mat = physicsManager->getMaterialID("level");
+
+        physicsManager->resetMaterialPair(char_mat, def_mat);
+        physicsManager->resetMaterialPair(char_mat, level_mat);
+
+
+        GameLoop::getSingleton().removeTask(this);
+    }
+
+    void MovingCreatureManager::add(MovingCreature *movingCreature)
+    {
+        if(movingCreature == NULL)
+        {
+            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
+        }
+
+        MovingCreatureVector::const_iterator iter;
+        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
+        {
+            if( (*iter) == movingCreature )
+            {
+                Throw(IllegalArgumentException, "MovingCreature wird schon vom MovingCreatureManager verwaltet.");
+            }
+        }
+        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
+        {
+            if( (*iter) == movingCreature )
+            {
+                Throw(IllegalArgumentException, "MovingCreature wird schon vom MovingCreatureManager verwaltet.");
+            }
+        }
+
+        mMovingCreatureFromBody.insert(make_pair(
+            movingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody(),
+            movingCreature));
+        mIdleCreatures.push_back(movingCreature);
+    }
+
+
+    void MovingCreatureManager::remove(MovingCreature *movingCreature)
+    {
+        if(movingCreature == NULL)
+        {
+            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
+        }
+
+        MovingCreatureBodyMap::iterator body_iter = mMovingCreatureFromBody.find(
+            movingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody());
+
+        if( body_iter == mMovingCreatureFromBody.end() )
+        {
+            Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
+        }
+
+        mMovingCreatureFromBody.erase(body_iter);
+
+
+        MovingCreatureVector::iterator iter;
+        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
+        {
+            if( (*iter) == movingCreature )
+            {
+                mIdleCreatures.erase(iter);
+                return;
+            }
+        }
+        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
+        {
+            if( (*iter) == movingCreature )
+            {
+                mActiveCreatures.erase(iter);
+                return;
+            }
+        }
+        for(iter = mAddToActiveCreatures.begin(); iter != mAddToActiveCreatures.end(); iter++)
+        {
+            if( (*iter) == movingCreature )
+            {
+                mAddToActiveCreatures.erase(iter);
+                return;
+            }
+        }
+
+
+        Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
+    }
+
+    void MovingCreatureManager::run(Real elapsedTime)
+    {
+        mTimeSinceLastIdleUpdate += elapsedTime;
+
+
+        MovingCreatureVector::iterator iter;
+        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter ++)
+        {
+            (*iter)->run(elapsedTime);
+        }
+
+        if( mTimeSinceLastIdleUpdate >= mUpdateIdleTime )
+        {
+            for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
+            {
+                (*iter)->run(mTimeSinceLastIdleUpdate);
+            }
+            mTimeSinceLastIdleUpdate = 0.0f;
+        }
+    }
+
+
+    void MovingCreatureManager::setActive(MovingCreature* movingCreature)
+    {
+        if(movingCreature == NULL)
+        {
+            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
+        }
+
+        // we cannot simply add the item to the other list, since it needs to be updated first!!
+        // i hope there are no errors, if this update is not at the proposed time in the game loop
+        // since it is not executed with the other runs!!!
+
+        MovingCreatureVector::iterator iter;
+        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
+        {
+            if( *iter == movingCreature )
+            {
+                movingCreature->run(mTimeSinceLastIdleUpdate);
+
+                mActiveCreatures.push_back(movingCreature);
+                mIdleCreatures.erase(iter);
+                return;
+            }
+        }
+
+        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
+        {
+            if( *iter == movingCreature )
+            {
+                LOG_DEBUG(Logger::RULES, "Die angegebene MovingCreature ist schon aktiv.");
+                return;
+            }
+        }
+
+
+        Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
+    }
+
+
+    int MovingCreatureManager::userProcess()
+    {
+        MovingCreatureBodyMap::iterator iter;
+        iter = mMovingCreatureFromBody.find(m_body0);
+
+        if( iter == mMovingCreatureFromBody.end() )
+        {
+            iter = mMovingCreatureFromBody.find(m_body1);
+
+            if( iter == mMovingCreatureFromBody.end() )
+            {
+                LOG_ERROR(Logger::RULES, "Der Kollisionsk?rper konnte keiner Creature zugeordner werden.");
+                return 1;
+            }
+        }
+
+        // i hope this will copy the protected members of the contact callback
+        OgreNewt::ContactCallback *movingCreature = iter->second;
+        *movingCreature = (OgreNewt::ContactCallback)(*this);
+        return movingCreature->userProcess();
+    }
+}

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-05-20 10:51:25 UTC (rev 3460)
@@ -21,6 +21,7 @@
 //#include "XdimlLoader.h"
 #include "DsaDataLoader.h"
 #include "Logger.h"
+#include "MovingCreatureManager.h"
 #include "TimerManager.h"
 #include "GameObjectManager.h"
 #include "QuestBook.h"
@@ -34,6 +35,7 @@
         mActionManager(NULL),
         mCombatManager(NULL),
         mDsaManager(NULL),
+        mMovingCreatureManager(NULL),
         mTimerManager(NULL),
         mXdimlLoader(NULL)
     {
@@ -48,7 +50,9 @@
 		LOG_MESSAGE(Logger::RULES, "CombatManager erzeugt");
         mDsaManager = new DsaManager();
 		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
-		mTimerManager = new TimerManager(); 
+        mMovingCreatureManager = new MovingCreatureManager();
+		LOG_MESSAGE(Logger::RULES, "MovingCreatureManager erzeugt");
+        mTimerManager = new TimerManager(); 
 		LOG_MESSAGE(Logger::RULES, "TimerManager erzeugt");
 		resetQuestBook();
 		LOG_MESSAGE(Logger::RULES, "Questverwaltung erzeugt");
@@ -66,6 +70,7 @@
         delete mQuestBook;
         delete mTimerManager;
         delete mDsaManager;
+        delete mMovingCreatureManager;
         delete mCombatManager;
         delete mActionManager;
         delete mXdimlLoader;

Modified: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-05-20 10:51:25 UTC (rev 3460)
@@ -19,6 +19,7 @@
 
 #include "UiPrerequisites.h"
 #include "GameTask.h"
+#include "MovingCreature.h"
 #include "PhysicsController.h"
 #include "PhysicsGenericContactCallback.h"
 #include "CharacterController.h"
@@ -85,34 +86,16 @@
 
     protected:
         virtual void doCreatePrimitive();
+        MovingCreature *mMovingCreature;
 
     private:
 
 		/// private struct for holding state info of the controller
 		struct CharacterState
 		{
-            //typedef enum {Stand, Crouch, StandToCrouch, CrouchToStand, Falling, Jumping, StartJump, EndJump} Pose;
-			CharacterState();
-            //Pose mPose;
-			bool mIsAirBorne;
-            bool mHasFloorContact;
-			//bool mStartJumpLong;
-            //bool mStartJumpHigh;
-            bool mStartJump;
-            Ogre::Real mJumpWidthHeight;
-
-			Ogre::Real mJumpTimer;
-
-			Ogre::Vector3 mDesiredVel;
-
+            CharacterState();
 			int mCurrentMovementState;
 			int mLastMovementState;
-            bool beginSneak;
-            bool endSneak;
-            bool beginJump;
-            bool endJump;
-            enum {HOCHSPRUNG, WEITSPRUNG /*, PRAEZISER_SPRUNG*/}
-                        jumpType;
 		};
 
         static Ogre::String msDebugWindowPageName;
@@ -123,7 +106,6 @@
         /// optimal distance to the character
         Ogre::Real mDesiredDistance;
         std::pair<Ogre::Real, Ogre::Real> mDistanceRange;
-        Ogre::Degree mYaw;
         Ogre::Degree mCamYaw; // f?r VM_FREE_CAMERA
         Ogre::Degree mCamVirtualYaw; // helps to simulate strafe+forward/backward movement
         Ogre::Degree mPitch;
@@ -134,10 +116,7 @@
         Ogre::Radian mRotationSpeed;
         Ogre::Real mMouseSensitivity;
         bool mInvertedMouse; // like in old games
-        Ogre::Real mSpeedModifier;
 
-		Ogre::Vector3 mGravitation;
-
         ViewMode mViewMode;
 
         int mObstractedFrameCount;
@@ -149,14 +128,12 @@
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 
+
         /// Camera Spring-Damping System (smooth movement) spring-factor
         Ogre::Real mLinearSpringK;
         /// Camera Spring-Damping System (smooth movement) damping-factor
         Ogre::Real mLinearDampingK;
-        /// Character rotation Spring-Damping System (smooth movement) spring-factor
-        Ogre::Real mRotLinearSpringK;
-        /// Character rotation Spring-Damping System (smooth movement) spring-factor
-        Ogre::Real mRotLinearDampingK;
+
         /// with this velocity the optimal Position of the cam moves away from the char
         Ogre::Real mCamMoveAwayVelocity;
         /// if there was no collision of the cam for this time, the cam can securely move backward
@@ -166,14 +143,15 @@
 
         void updateSelection();
         bool isEnemyNear();
-        //void updateCharacterState(int movement, Ogre::Real elapsedTime);
-        void updateCharacterState(Ogre::Real elapsedTime);
+
+
         void updateCameraLookAt(Ogre::Real elapsedTime);
-        //void updateAnimationState(int &movement); // this can also modify movement, if needed
 
-        void interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor);
+        void updateCharacter(Ogre::Real elapsedTime);
 
+        //void interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor);
 
+
         /** Does all camera-stuff, moves the camera to the right position 
         * and does pathfinding (in a very simple way)
         * @warning this does only work well, if the character's material is not used for other objects!

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-19 23:19:35 UTC (rev 3459)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-20 10:51:25 UTC (rev 3460)
@@ -24,6 +24,7 @@
 #include <OgreCamera.h>
 #include <OgreSceneNode.h>
 #include <OgreSceneQuery.h>
+#include <utility>
 
 #include "Actor.h"
 #include "ActorManager.h"
@@ -58,29 +59,19 @@
     String MovementCharacterController::msDebugWindowPageName = "MovementCharacterController";
 
     MovementCharacterController::CharacterState::CharacterState()
-        : mIsAirBorne(false),
-        mHasFloorContact(false),
-        mStartJump(false),
-        mJumpWidthHeight(0),
-        mJumpTimer(0.0),
-        mDesiredVel(Vector3::ZERO),
+        :
         mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE),
-        beginSneak(false),
-        endSneak(false),
-        beginJump(false),
-        endJump(false)
+        mLastMovementState(MOVE_NONE)
     {
-
     }
 
     MovementCharacterController::MovementCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : CharacterController(cmdMapper, camera, character),
+        mMovingCreature(NULL),
         mCharacterState(),
         mDesiredDistance(2.00),
         mDistanceRange(0.60, 7.00),
-        mYaw(180),
         mCamYaw(0),
         mCamVirtualYaw(0),
         mPitch(20),
@@ -91,20 +82,15 @@
         mCamMoveAwayVelocity(4.0f),
         mCamMoveAwayStartTime(0.25f),
         mCamMoveAwayRange(8.0f),
-        mRotLinearSpringK(600.0f),
-        mRotLinearDampingK(Math::NEG_INFINITY),
         mLookAtOffset(),
         mRotationSpeed(Degree(120.0f)),
         mMouseSensitivity(4.0f),
-        mSpeedModifier(1.0f),
         mViewMode(VM_THIRD_PERSON),
-//        mMaxDelay(1.0/20.0),
         mObstractedFrameCount(0),
         mObstractedTime(0.0f),
         mCameraJammedFrameCount(0),
         mCameraJammedTime(0.0f),
         mRaycast(new PhysicsMaterialRaycast()),
-        mGravitation(),
         mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
         mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
             QUERYFLAG_CREATURE)
@@ -112,7 +98,6 @@
         DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
 
 
-        mGravitation = PhysicsManager::getSingleton().getGravity();
         mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
         mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
 
@@ -123,7 +108,6 @@
         // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
         Real relationCoefficient = 1.0f;
         mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-        mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
 
         // Offset for the look at point,
         // so the cam does look at the characters head instead of the feet.
@@ -162,18 +146,28 @@
     //------------------------------------------------------------------------
     void MovementCharacterController::pause()
     {
+        if( mMovingCreature != NULL )
+        {
+            delete mMovingCreature;
+            mMovingCreature = NULL;
+        }
+
         // actors aren't controlled anymore
-        mCharacterActor->getPhysicalThing()->setPhysicsController(NULL);
+        //mCharacterActor->getPhysicalThing()->setPhysicsController(NULL);
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-        // Char<->Level collision back to default
+        // cam<->Level collision back to default
         PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("default"));
-        // Char<->Default collision back to default
+        // cam<->Default collision back to default
         PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
 
+
         // Unhighlight selected object, if any.
         GameObject* go = mSelector.getFirstSelectedObject();
         if (go != NULL && go->isHighlighted())
@@ -185,6 +179,9 @@
     //------------------------------------------------------------------------
     void MovementCharacterController::resume()
     {
+        if( mMovingCreature == NULL )
+            mMovingCreature = new MovingCreature(mCharacter);
+
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacter);
         mSelector.track(mCharacter);
@@ -197,27 +194,30 @@
 
         // The actor should be controlled manually,
         // so let the PM prepare it accordingly
-        mCharacterActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID("character"));
-        mCharacterActor->getPhysicalThing()->setPhysicsController(this);
+        //mCharacterActor->getPhysicalThing()->setMaterialID(
+        //    PhysicsManager::getSingleton().getMaterialID("character"));
+        //mCharacterActor->getPhysicalThing()->setPhysicsController(this);
         mCameraActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID("character"));
+            PhysicsManager::getSingleton().createMaterialID("camera"));
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
 
-        // We also handle char<->level, char<->default collision from now on
-        PhysicsManager::getSingleton().getMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("default"))->setContactCallback(this);
-        PhysicsManager::getSingleton().getMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+        PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("level"))->setContactCallback(this);
-        
+        PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"))->setContactCallback(this);
+
         // Fit Collision proxy to idle anim
         mCharacterActor->getPhysicalThing()->fitToPose("idle");
 
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        mesh->stopAllAnimations();
-        mesh->startAnimation("idle");
+        //MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        //mesh->stopAllAnimations();
+        //mesh->startAnimation("idle");
 
         setViewMode(VM_THIRD_PERSON);
     }
@@ -225,11 +225,25 @@
     //------------------------------------------------------------------------
     void MovementCharacterController::run(Real elapsedTime)
     {
-        updateCharacterState(elapsedTime);
+        InputManager* im = InputManager::getSingletonPtr();
+
+        updateCharacter(elapsedTime);
         updateCameraLookAt(elapsedTime);
         updateSelection();
 
 
+
+        // camera pitch
+        if (mInvertedMouse)
+            mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+        else
+            mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+        if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
+        if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
+
+
+
+
         // Do we need to reset the Camera?
         Vector3 charPos = mCharacterActor->getWorldPosition();
         Quaternion charOri = mCharacterActor->getWorldOrientation();
@@ -273,613 +287,134 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::updateCharacterState(Ogre::Real elapsedTime)
+    void MovementCharacterController::updateCharacter(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
-        mCharacterState.mDesiredVel = Vector3::ZERO;
-        int patzer = 0;
-        int movement = mCharacterState.mCurrentMovementState;
-        int creatureMovement = mCharacter->getTaktischeBewegung();
-        bool blockMovement (false);
-
-
-
-
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        PhysicalThing* pt = mCharacterActor->getPhysicalThing();
-        static std::string lastAnimation("");
-        std::string newAnimation("idle");
-        Real animSpeed = 1;
-        static Real lastSpeed = 1;
-        unsigned int animTimesToPlay = 0;
-		//Real gs = mCharacter->getWert(Creature::WERT_GS);
-        static String lastCollisionPose = "";
-        String collisionPose = "idle";
-
-        // the different factors used to calculate the animation-speed from the character-speed
-        const Real factor_hocke_gehen = 0.7;
-        const Real factor_drehen_idle = 0.6;
-        const Real factor_gehen = 0.5;
-        const Real factor_gehen_rueckwaerts = 0.7;
-        const Real factor_rennen = 0.25;
-        const Real factor_rennen_absprung = 0.25;
-        const Real factor_rennen_sprung_landung = 0.6;
-        const Real factor_rennen_sprung = 0.25;
-        const Real factor_gehen_seitwaerts = 0.9;
-
-
-
-
-        Vector3 charVelocity, charOmega;
-        charOmega = mCharBody->getOmega();
-        charVelocity = mCharBody->getVelocity();
-        Real vel = charVelocity.length();
-
-
-
-
-        //  --------------------------- sneaking-behaviour ----------------------------
+        if( mMovingCreature != NULL )
         {
-            if( (!(creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) && 
-                movement & MOVE_SNEAK) || 
-                mCharacterState.beginSneak )
-            {
-                mCharacterState.beginSneak = true;
-            }
-            if( (!(movement & MOVE_SNEAK) && 
-                creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) || 
-                mCharacterState.endSneak)
-            {
-                mCharacterState.endSneak = true;
-            }
+            int movement = mCharacterState.mCurrentMovementState;
+            Degree rotation(0);
 
-            if( mCharacterState.beginSneak )
+            AbstractMovement *drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+            Real baseVelocity = 0;
+            if( drehen->calculateBaseVelocity(baseVelocity) )
             {
-                newAnimation = "idle_zu_hocke";
+                Degree baseVel(baseVelocity*360);
+                if (movement & TURN_LEFT)
+                    rotation = elapsedTime * baseVel;
+                if (movement & TURN_RIGHT)
+                    rotation = -elapsedTime * baseVel;
 
-                MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
-                if (meshAnim->getTimePlayed() >= meshAnim->getLength())
+                // mouse
+                if( !im->isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
                 {
-                    creatureMovement |= Creature::BEWEGUNG_SCHLEICHEN;
-                    mCharacter->setTaktischeBewegung(creatureMovement);
-                    mCharacterState.beginSneak = false;
+                    if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                    {
+                        rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
+                    }
                 }
-                else
-                {
-                    collisionPose = "idle";
-                    animTimesToPlay = 1;
-                    blockMovement = true;
 
-                    mCharacter->doTaktischeBewegung(Creature::BEWEGUNG_NONE, elapsedTime, patzer);
-                }
 
-                // interpolate camera offset
-                Real factor = meshAnim->getTimePlayed() / meshAnim->getLength();
-                interpolateAnimationLookAtOffset("idle", "hocke_idle", factor);
-            }
-
-            if( creatureMovement & Creature::BEWEGUNG_SCHLEICHEN )
-            {
-                newAnimation = "hocke_idle";
-                collisionPose = newAnimation;
-            }
-
-            if( mCharacterState.endSneak )
-            {
-                creatureMovement &= ~Creature::BEWEGUNG_SCHLEICHEN;
-                mCharacter->setTaktischeBewegung(creatureMovement);
-                newAnimation = "hocke_zu_stehen";
-
-
-                MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
-                if (meshAnim->getTimePlayed() >= meshAnim->getLength())
+                // virtual yaw
+                Degree newVirtualYaw(0);
+                if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                    ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
                 {
-                    newAnimation = "idle";
-                    mCharacterState.endSneak = false;
+                    newVirtualYaw = Degree(45);
                 }
-                else
+                if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                    ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
                 {
-                    collisionPose = "idle";
-                    animTimesToPlay = 1;
-                    blockMovement = true;
-
-                    mCharacter->doTaktischeBewegung(Creature::BEWEGUNG_NONE, elapsedTime, patzer);
+                    newVirtualYaw = Degree(-45);
                 }
-
-                // interpolate camera-offset
-                Real factor = meshAnim->getTimePlayed() / meshAnim->getLength();
-                interpolateAnimationLookAtOffset("hocke_idle", "idle", factor);
+                if( mCamVirtualYaw != newVirtualYaw )
+                {
+                    rotation += mCamVirtualYaw - newVirtualYaw;
+                    mCamVirtualYaw = newVirtualYaw;
+                }
             }
-        }
-        //  --------------------------- sneaking-behaviour -------------------------
 
 
 
-
-
-        // ------------------ walking, jogging, running etc ------------------------
-        if( !blockMovement )
-        {
-
-            int newCreatureMovement = 
-                creatureMovement & ~
-                    (Creature::BEWEGUNG_RENNEN |
-                    Creature::BEWEGUNG_LAUFEN | 
-                    Creature::BEWEGUNG_JOGGEN |
-                    Creature::BEWEGUNG_GEHEN | 
-                    Creature::BEWEGUNG_RUECKWAERTS |
-                    Creature::BEWEGUNG_SEITWAERTS |
-                    Creature::BEWEGUNG_DREHEN |
-                    Creature::BEWEGUNG_UMDREHEN
-                    );
-
-            if( movement & MOVE_RUN && movement & MOVE_RUN_LOCK )
-                newCreatureMovement |= Creature::BEWEGUNG_RENNEN;
-            else if( movement & MOVE_RUN_LOCK )
-                newCreatureMovement |= Creature::BEWEGUNG_LAUFEN;
-            else if( !(movement & MOVE_RUN) )
-                newCreatureMovement |= Creature::BEWEGUNG_JOGGEN;
-            else
-                newCreatureMovement |= Creature::BEWEGUNG_GEHEN;
-
-            if( movement & MOVE_FORWARD )
-                ;
-            else if( movement & MOVE_BACKWARD )
-                newCreatureMovement |= Creature::BEWEGUNG_RUECKWAERTS;
-            else if( movement & MOVE_RIGHT || movement & MOVE_LEFT )
-                newCreatureMovement |= Creature::BEWEGUNG_SEITWAERTS;
-
-
-            // check if new Movement is possible
-            if( newCreatureMovement & Creature::BEWEGUNG_RENNEN )
+            if( movement & MOVE_SNEAK )
             {
-                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
-                {
-                    newCreatureMovement &= ~Creature::BEWEGUNG_RENNEN;
-                    newCreatureMovement |= Creature::BEWEGUNG_LAUFEN;
-                }
+                Vector3 direction(Vector3::ZERO);
+                if (movement & MOVE_FORWARD)
+                    direction.z = -1;
+                else if( movement & MOVE_BACKWARD)
+                    direction.z = 1;
+                mMovingCreature->setMovement(
+                    MovingCreature::MT_SCHLEICHEN,
+                    direction,
+                    Vector3(0, rotation.valueRadians(), 0) );
             }
-
-            if( newCreatureMovement & Creature::BEWEGUNG_LAUFEN )
+            else if( movement & MOVE_JUMP )
             {
-                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
+                MovingCreature::MovementType type = MovingCreature::MT_HOCHSPRUNG;
+                Vector3 direction = Vector3::UNIT_Y;
+                if( movement & MOVE_FORWARD )
                 {
-                    newCreatureMovement &= ~Creature::BEWEGUNG_LAUFEN;
-                    newCreatureMovement |= Creature::BEWEGUNG_JOGGEN;
+                    type = MovingCreature::MT_WEITSPRUNG;
+                    direction += Vector3::NEGATIVE_UNIT_Z;
                 }
+                mMovingCreature->setMovement(
+                    type,
+                    direction,
+                    Vector3(0, rotation.valueRadians(), 0) );
             }
-            
-            if( newCreatureMovement & Creature::BEWEGUNG_JOGGEN )
+            else if( movement & MOVE_FORWARD )
             {
-                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
+                MovingCreature::MovementType type = MovingCreature::MT_GEHEN;
+                if( movement & MOVE_RUN_LOCK )
                 {
-                    newCreatureMovement &= ~Creature::BEWEGUNG_JOGGEN;
-                    newCreatureMovement |= Creature::BEWEGUNG_GEHEN;
-                }
-            }
-            
-            if( newCreatureMovement & Creature::BEWEGUNG_GEHEN )
-            {
-                if( !mCharacter->canUseTaktischeBewegung(newCreatureMovement) )
-                {
-                    // character exhausted?
-                    blockMovement = true;
-                    newAnimation = "idle";
-                    newCreatureMovement &= ~Creature::BEWEGUNG_GEHEN;
-                    newCreatureMovement |= Creature::BEWEGUNG_NONE;
-                    mCharacter->doTaktischeBewegung(newCreatureMovement, elapsedTime, patzer);
-                }
-            }
-
-            if( !blockMovement )
-            {
-                // not handled movements:
-                if( movement & MOVE_FORWARD && movement & MOVE_BACKWARD ||
-                    movement & MOVE_LEFT && movement & MOVE_RIGHT )
-                {
-                }
-                else if( (movement & MOVE_FORWARD || movement & MOVE_BACKWARD) && // this also handles strafe+forward/backward
-                         (newCreatureMovement & Creature::BEWEGUNG_LAUFEN ||
-                          newCreatureMovement & Creature::BEWEGUNG_JOGGEN ||
-                          newCreatureMovement & Creature::BEWEGUNG_RENNEN ) )
-                {
-                    newAnimation = "rennen";
-                    if( movement & MOVE_FORWARD )
-                    {
-                        mCharacterState.mDesiredVel.z = -1;
-                        animSpeed = factor_rennen;
-                    }
+                    if( movement & MOVE_RUN )
+                        type = MovingCreature::MT_RENNEN;
                     else
-                    {
-                        mCharacterState.mDesiredVel.z = 1;
-                        animSpeed = -factor_rennen;
-                    }
+                        type = MovingCreature::MT_LAUFEN;
                 }
-                else if( movement & MOVE_FORWARD )
+                else
                 {
-                    newAnimation = "gehen";
-                    animSpeed = factor_gehen;
-                    mCharacterState.mDesiredVel.z = -1;
-                }
-                else if( movement & MOVE_BACKWARD )
-                {
-                    newAnimation = "gehen_rueckwaerts";
-                    animSpeed = factor_gehen_rueckwaerts;
-                    mCharacterState.mDesiredVel.z = 1;
-                }
-                else if( movement & MOVE_LEFT )
-                {
-                    newAnimation = "seitwaerts_links";
-                    animSpeed = factor_gehen_seitwaerts;
-                    mCharacterState.mDesiredVel.x = -1;
-                }
-                else if( movement & MOVE_RIGHT )
-                {
-                    newAnimation = "seitwaerts_rechts";
-                    animSpeed = factor_gehen_seitwaerts;
-                    mCharacterState.mDesiredVel.x = 1;
-                }
-
-
-
-
-                // ---------- jumping-behaviour (and falling?) ---------
-                {
-                    if( !((creatureMovement & Creature::BEWEGUNG_SCHLEICHEN) || 
-                        blockMovement || mCharacterState.beginJump ||
-                        (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG) ||
-                        (creatureMovement & Creature::BEWEGUNG_WEITSPRUNG)) &&
-                        movement & MOVE_JUMP)
-                    {
-                        if( mCharacterState.mDesiredVel.squaredLength() > 0 )
-                        {
-                            if( movement & MOVE_FORWARD )
-                            {
-                                mCharacterState.beginJump = true;
-                                mCharacterState.jumpType = CharacterState::WEITSPRUNG;
-                                creatureMovement = newCreatureMovement;
-                            }
-                        }
-                        else
-                        {
-                            mCharacterState.beginJump = true;
-                            mCharacterState.jumpType = CharacterState::HOCHSPRUNG;
-                            creatureMovement = newCreatureMovement;
-                        }
-                    }
-
-
-                    if( (creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG ||
-                        creatureMovement & Creature::BEWEGUNG_WEITSPRUNG  ) &&
-                        !mCharacterState.beginJump )
-                    {
-                        if( !mCharacterState.mIsAirBorne )
-                            mCharacterState.endJump = true;
-                    }
-
-
-                    static Real timeJumpKeyPressed (0.0);
-                    if( mCharacterState.beginJump && (movement & MOVE_JUMP) )
-                        timeJumpKeyPressed += elapsedTime;
+                    if( movement & MOVE_RUN )
+                        type = MovingCreature::MT_GEHEN;
                     else
-                        timeJumpKeyPressed = 0;
-
-
-
-
-                    if( mCharacterState.beginJump )
-                    {
-                        blockMovement = true;
-                        if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
-                        {
-                            newAnimation = "rennen_absprung";
-                            animSpeed = factor_rennen_sprung * vel;
-                        }
-                        else // HOCHSPRUNG
-                        {
-                            newAnimation = "idle_absprung";
-
-                        }
-                        animTimesToPlay = 1;
-                        
-
-                        MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
-                        if (meshAnim->getTimePlayed() >= meshAnim->getLength())
-                        {
-                            mCharacterState.beginJump = false;
-                            
-                            if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
-                            {
-                                if( mCharacter->canUseTaktischeBewegung(creatureMovement | Creature::BEWEGUNG_WEITSPRUNG) )
-                                {
-                                    Real jumpWidth = 
-                                        mCharacter->doTaktischeBewegung(
-                                                creatureMovement | Creature::BEWEGUNG_WEITSPRUNG,
-                                                elapsedTime,
-                                                patzer);
-
-                                    mCharacterState.mJumpWidthHeight = jumpWidth;
-                                    mCharacterState.mStartJump = true;
-                                }
-                            }
-                            else
-                            {
-                                if( mCharacter->canUseTaktischeBewegung(creatureMovement | Creature::BEWEGUNG_HOCHSPRUNG) )
-                                {
-                                    Real jumpHeight = 
-                                        mCharacter->doTaktischeBewegung(
-                                                creatureMovement | Creature::BEWEGUNG_HOCHSPRUNG,
-                                                elapsedTime,
-                                                patzer);
-
-                                    mCharacterState.mJumpWidthHeight = jumpHeight;
-                                    mCharacterState.mStartJump = true;
-                                }
-                            }
-
-                            if( timeJumpKeyPressed < 0.1f )
-                                timeJumpKeyPressed = 0.1f;
-                            Real factor = timeJumpKeyPressed / meshAnim->getLength();
-                            if (factor > 1.0f)
-                                factor = 1.0f;
-
-
-                            mCharacterState.mJumpWidthHeight *= factor;
-                        }
-                        else
-                        {
-                            mCharacterState.mDesiredVel = Vector3::ZERO;
-                            if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
-                            {
-                                mCharacterState.mDesiredVel.z = -1;
-                                Real vel = mCharacter->doTaktischeBewegung(
-                                    creatureMovement, elapsedTime, patzer);
-                                mCharacterState.mDesiredVel *= vel;
-                            }
-                            else
-                            {
-                                mCharacter->setTaktischeBewegung(creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG);
-                            }
-                        }
-                    }
-                    else
-                    {
-                        if( creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG )
-                        {
-                            blockMovement = true;
-                            newAnimation = "idle_sprung";
-                        }
-                        else
-                        if( creatureMovement & Creature::BEWEGUNG_WEITSPRUNG )
-                        {
-                            blockMovement = true;
-                            newAnimation = "rennen_sprung";
-                            animSpeed = vel * factor_rennen_sprung;
-                        }
-                    }
-
-
-                    if( mCharacterState.endJump )
-                    {
-                        mCharacterState.mDesiredVel = Vector3::ZERO;
-
-                        blockMovement = true;
-                        if( mCharacterState.jumpType == CharacterState::WEITSPRUNG )
-                        {
-                            newAnimation = "rennen_sprung_landung";
-                            animSpeed = factor_rennen_sprung * vel;
-
-                            // schneller oder gleich schnell weiterlaufen
-                            if( movement & MOVE_FORWARD )
-                            {
-                                int dummy = Creature::BEWEGUNG_GEHEN |
-                                            Creature::BEWEGUNG_LAUFEN |
-                                            Creature::BEWEGUNG_JOGGEN |
-                                            Creature::BEWEGUNG_RENNEN;
-                                if( (newCreatureMovement & dummy) >=
-                                    (creatureMovement & dummy) )
-                                {
-                                    blockMovement = false;
-                                    mCharacterState.mDesiredVel.z = -1;
-                                    newCreatureMovement &= ~Creature::BEWEGUNG_WEITSPRUNG;
-                                }
-                                    
-                            }
-                        }
-                        else // HOCHSPRUNG
-                        {
-                            newAnimation = "idle_sprung_landung";
-                        }
-                        animTimesToPlay = 1;
-                        
-
-                        MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
-                        if (meshAnim->getTimePlayed() >= meshAnim->getLength())
-                        {
-                            mCharacterState.endJump = false;
-                            creatureMovement &= ~Creature::BEWEGUNG_HOCHSPRUNG & ~Creature::BEWEGUNG_WEITSPRUNG;
-                            mCharacter->setTaktischeBewegung(creatureMovement);
-                        }
-                    }
-
-
+                        type = MovingCreature::MT_JOGGEN;
                 }
-                // ------ jumping-behaviour ----------
-
-
-
-                // only do something, if the char does not jump
-                if( !blockMovement )
-                {
-                    Real vel;
-                    if( mCharacterState.mDesiredVel.squaredLength() == 0 )
-                    {
-                        newCreatureMovement &= ~(
-                                Creature::BEWEGUNG_RENNEN |
-                                Creature::BEWEGUNG_LAUFEN | 
-                                Creature::BEWEGUNG_JOGGEN |
-                                Creature::BEWEGUNG_GEHEN | 
-                                Creature::BEWEGUNG_RUECKWAERTS |
-                                Creature::BEWEGUNG_SEITWAERTS |
-                                Creature::BEWEGUNG_DREHEN |
-                                Creature::BEWEGUNG_UMDREHEN
-                                );
-                    }
-                    vel = mCharacter->doTaktischeBewegung(newCreatureMovement, elapsedTime, patzer);
-                    creatureMovement = newCreatureMovement;
-                    
-                    mCharacterState.mDesiredVel *= vel;
-                    animSpeed *= vel;
-
-                    // some special cases:
-                    if( newCreatureMovement & Creature::BEWEGUNG_SCHLEICHEN &&
-                        vel > 0 )
-                    {
-                        newAnimation = "hocke_gehen";
-                        animSpeed = vel*factor_hocke_gehen;
-                    }
-                }
-
-
-
-
-                // this simulates going right-forward or left-forward or right/left - backward
-                Degree newCharVirtualYaw (0); 
-                if( (movement & MOVE_FORWARD && movement & MOVE_LEFT) ||
-                    (movement & MOVE_BACKWARD && movement & MOVE_RIGHT) )
-                {
-                    newCharVirtualYaw = Degree(45);
-                }
-                else if( (movement & MOVE_FORWARD && movement & MOVE_RIGHT) ||
-                         (movement & MOVE_BACKWARD && movement & MOVE_LEFT) )
-                {
-                    newCharVirtualYaw = Degree(-45);
-                }
-                else // no strafing
-                {
-                    newCharVirtualYaw = Degree(0);
-                }
-
-                if( newCharVirtualYaw != -mCamVirtualYaw )
-                {
-                    mYaw += mCamVirtualYaw;
-                    mYaw += newCharVirtualYaw;
-                    mCamVirtualYaw = -newCharVirtualYaw;
-                }
+                mMovingCreature->setMovement(
+                    type,
+                    Vector3(0,0,-1), 
+                    Vector3(0, rotation.valueRadians(), 0) );
             }
-        }
-        // ------------------ walking, jogging, running etc ------------------------
-
-
-
-
-        // ---------------------------- turning + direction changing ---------------
-
-        if( !blockMovement )
-        {
-
-            Degree rotation;
-            // keyboard
-            if (movement & TURN_LEFT)
-                rotation = -elapsedTime * Degree(360.0f) * mCharacter->doTaktischeBewegung(
-                    creatureMovement | Creature::BEWEGUNG_DREHEN, elapsedTime, patzer);
-            if (movement & TURN_RIGHT)
-                rotation = elapsedTime * Degree(360.0f) * mCharacter->doTaktischeBewegung(
-                    mCharacter->getTaktischeBewegung() | Creature::BEWEGUNG_DREHEN, elapsedTime, patzer);
-
-            // mouse
-            if( !im->isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+            else if (movement & MOVE_BACKWARD )
             {
-                if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
-                {
-                    rotation = mMouseSensitivity/3.0 * Degree(im->getMouseRelativeX());
-
-
-                    if( rotation != Degree(0) || mCharBody->getOmega().squaredLength() > 0.1 )
-                        rotation = rotation * mCharacter->doTaktischeBewegung( 
-                                        mCharacter->getTaktischeBewegung() | Creature::BEWEGUNG_DREHEN, elapsedTime, patzer);
-                }
+                MovingCreature::MovementType type = MovingCreature::MT_RUECKWAERTS_GEHEN;
+                if( movement & MOVE_RUN )
+                    type = MovingCreature::MT_RUECKWAERTS_JOGGEN;
+                mMovingCreature->setMovement(
+                    type,
+                    Vector3(0,0,1), 
+                    Vector3(0, rotation.valueRadians(), 0) );
             }
-
-
-            static bool lastTurning(false);
-            if( mCharacter->getTaktischeBewegung() == Creature::BEWEGUNG_DREHEN &&
-                (rotation <= Degree(-2) || rotation >= Degree(2) || lastTurning) )
+            else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
             {
-                lastTurning = true;
-                if( charOmega.y > 0 )
-                    newAnimation = "drehen_links";
-                else
-                    newAnimation = "drehen_rechts";
-                
-                animSpeed = factor_drehen_idle * charOmega.y;
+                Vector3 direction = Vector3::UNIT_X;
+                if( movement & MOVE_LEFT )
+                    direction = Vector3::NEGATIVE_UNIT_X;
+                mMovingCreature->setMovement(
+                    MovingCreature::MT_SEITWAERTS_GEHEN,
+                    direction, 
+                    Vector3(0, rotation.valueRadians(), 0) );
             }
             else
-                lastTurning = false;
-
-
-            mYaw -= rotation;
-            while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
-            while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
-        }
-
-        if (mInvertedMouse)
-            mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-        else
-            mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-        if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-        if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
-
-        // ---------------------------- turning + direction changing ---------------
-
-
-
-
-
-        // ---------------------------- show animation -----------------------------
-        if (newAnimation != "" && newAnimation != "drehen_links" && newAnimation != "drehen_rechts" )
-        {
-            // nur schneller nicht langsamer ausfhren!
-            if (animSpeed < 1) animSpeed = 1;
-
-            if (lastAnimation != newAnimation)
             {
-                if (collisionPose != lastCollisionPose)
-                {
-                    pt->fitToPose(collisionPose);
-                    lastCollisionPose = collisionPose;
-                }
-                mesh->stopAllAnimations();
-
-
-                // animations with zero-length can't be played
-                if( newAnimation == "idle_sprung" ||
-                    newAnimation == "rennen_sprung" )
-                {
-                    newAnimation = "idle";
-                    animSpeed = 1;
-                }
-
-
-
-                mesh->startAnimation(newAnimation, animSpeed, animTimesToPlay);
-                lastAnimation = newAnimation;
-                lastSpeed = animSpeed;
+                mMovingCreature->setMovement(
+                    MovingCreature::MT_STEHEN, 
+                    Vector3(0,0,0),
+                    Vector3(0, rotation.valueRadians(), 0) );
             }
-            else
-            {
-                if ( lastSpeed != animSpeed ) // Geschwindigkeits???derung
-                {
-                    MeshAnimation *meshAnim = mesh->getAnimation(newAnimation);
-                    meshAnim->setSpeed(animSpeed);
-                    lastSpeed = animSpeed;
-                }
-            }
         }
-
     }
 
-
+    // ------------------------------------------------------------------------
     void MovementCharacterController::updateCameraLookAt(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
@@ -906,9 +441,9 @@
         SceneNode* cameraNode = mCameraActor->_getSceneNode();
 
         Vector3 charPos;
-        Quaternion charOri(mYaw, Vector3::UNIT_Y);
+        charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
         Quaternion virtualCamOri;
-        charPos = mCharacterActor->getWorldPosition();
         virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
 
 
@@ -974,238 +509,35 @@
         }
     }
 
-    //------------------------------------------------------------------------
-    // adopted from the chararcter demo in the newton sdk
-    // copyright 2000-2004
-    // By Julio Jerez
+
+    // -------------------------------------------------------------
+    // character collision moved to MovingCreature(Manager)
     int MovementCharacterController::userProcess()
     {
-        if ((m_body0 == mCamBody && m_body1 == mCharBody)
-            || (m_body0 == mCharBody && m_body1 == mCamBody))
-        {
-            // No collision between char and camera
+        // only camera collision
+    
+        if( mViewMode == VM_FIRST_PERSON )
             return 0;
-        }
-        else if (m_body0 == mCamBody || m_body1 == mCamBody)
-        {
-            // this is camera collision
 
-            if( mViewMode == VM_FIRST_PERSON )
-                return 0;
+        setContactSoftness(1.0f);
+        setContactElasticity(0.0f);
 
-            setContactSoftness(1.0f);
-            setContactElasticity(0.0f);
-
-            return 1;
-        }
-        else if (m_body0 == mCharBody || m_body1 == mCharBody)
-        {
-            // this is character collision
-            Vector3 point;
-            Vector3 normal;
-            getContactPositionAndNormal(point, normal);
-
-            // determine if this contact is with the floor.
-            // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
-            Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
-
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody->getPositionOrientation(charPos, charOri);
-            bool isFloorCollision(false);
-
-            //if( charPos.y > point.y && angle < Degree(50.0f)  )
-            AxisAlignedBox CharAab = mCharBody->getCollision()->getAABB();
-            Real CharHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
-            Real stepHeight = point.y - charPos.y;
-/*
-            if( stepHeight < 0.5f && mCharacterState.mHasFloorContact ||
-                stepHeight < 0.2f )
-*/
-            if( stepHeight < 0.5f )
-                isFloorCollision = true;
-
-            if ( isFloorCollision )
-            {
-                mCharacterState.mHasFloorContact = true;
-                if(stepHeight > 0.1f)
-                    setContactNormalAcceleration(10);
-                setContactElasticity(0.0f);
-            }
-            else
-            {
-                // what is the aim of this, this does nothing without an setContactTangentAcceleration, doesn't it?
-                //Vector3 velocity = mCharBody->getVelocity();
-
-                // calculate char velocity perpendicular to the contact normal
-                //Vector3 tangentVel = velocity - normal * (normal.dotProduct(velocity));
-
-                // align the tangent at the contact point with the
-                // tangent velocity vector of the char
-                //rotateTangentDirections(tangentVel);
-                
-            }
-
-
-            // perhaps ContactElasticity and ContactSoftness should not be overwritten
-            //setContactElasticity(?);
-            //setContactSoftness(?);
-
-            setContactFrictionState(1, 0);
-            setContactFrictionState(1, 1);
-        }
-
-        // return one to tell Newton we want to accept this contact
         return 1;
     }
 
     //------------------------------------------------------------------------
-    // adopted from the chararcter demo in the newton sdk
-    // copyright 2000-2004
-    // By Julio Jerez
+    // character callback moved to MovingCreature
     void MovementCharacterController::OnApplyForceAndTorque(PhysicalThing* thing)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        OgreNewt::Body* body = thing->_getBody();
-        //static Vector3 lastDirVector = Vector3::ZERO;
-        static Vector3 lastForce = Vector3::ZERO;
-        //static bool doCollisionStep = false;
-        //static Vector3 collisionStepPos;
-        //static int curCollisionStep;
-
-        // Get the current world timestep
         Real timestep = world->getTimeStep();
 
-        if (body == mCamBody)
-        {
-            calculateCamera(timestep);
-        }
-        else
-        {
-            mCharacterState.mJumpTimer += timestep;
-            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum "Sprung fhren"
-            if( !mCharacterState.mHasFloorContact )
-                timeSinceLastFloorContact += timestep;
-            else
-                timeSinceLastFloorContact = 0.0f;
+        calculateCamera(timestep);
 
 
 
 
-            // apply character force
-            Vector3 position;
-            Quaternion orientation;
-            body->getPositionOrientation(position, orientation);
-
-            // get the charater mass
-            Real mass;
-            Vector3 inertia;
-            body->getMassMatrix(mass, inertia);
-
-            // apply gravity
-            Vector3 force = Vector3::ZERO;
-            force = mass * mGravitation;
-
-            // Get the velocity vector
-            Vector3 currentVel = body->getVelocity();
-
-            // Gravity is applied above, so not needed here
-            // prevent adding a counter force against gravity
-            //if (currentVel.y < 0.0f || mCharacterState.mJumpTimer < 2.0f)
-            currentVel.y = 0.0f;
-
-            if( (mCharacterState.mHasFloorContact && mCharacterState.mJumpTimer > 0.1f) ||
-                ( timeSinceLastFloorContact < 2.2f && !mCharacterState.mIsAirBorne ) )
-                mCharacterState.mIsAirBorne = false;
-            else
-                mCharacterState.mIsAirBorne = true;
-
-
-            if( !mCharacterState.mIsAirBorne )
-            {
-
-                if( mCharacterState.mStartJump )
-                {
-                    int creatureMovement = mCharacter->getTaktischeBewegung();
-
-                    if( creatureMovement & Creature::BEWEGUNG_HOCHSPRUNG )
-                    {
-                        Real height = mCharacterState.mJumpWidthHeight;
-                        Real m = mass;
-                        Real g = mGravitation.length();
-                        Real t = timestep;
-                        Real h = height;
-                        Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
-                        force += Vector3(0,
-                            jumpForce,
-                            0);
-                    }
-                    else // weitsprung
-                    {
-                        Real width = mCharacterState.mJumpWidthHeight;
-                        Real m = mass;
-                        Real g = mGravitation.length();
-                        Real v0 = currentVel.x;
-                        Real t = timestep;
-                        Real s = width;
-                        Real jumpForcezy = 
-                            m*g/4 - v0*m /2 /t + 
-                            Math::Sqrt( 
-                                v0*v0 * m*m  -
-                                v0 * m*m *g *t +
-                                m*m * g*g * t*t /4 +
-                                2 * s * m*m *g
-                                       )/2/t;
-                        force += orientation * Vector3(0,jumpForcezy,-jumpForcezy);
-                    }
-
-                    mCharacterState.mStartJump = false;
-                    mCharacterState.mIsAirBorne = true;
-                    mCharacterState.mJumpTimer = 0;
-                }
-                else
-                {
-                    Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh???gig von der framerate!
-                    if( mCharacterState.mDesiredVel.squaredLength() < currentVel.squaredLength() )
-                        delay *= 4;
-                    force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
-                }
-            }
-
-
-            body->setForce(force);
-            lastForce = force;
-            // Assume we are air borne.
-            // Might be set to true in the collision callback
-            mCharacterState.mHasFloorContact = false;
-
-
-
-
-
-
-
-            // Calculate angular velocity
-            // We first need the yaw rotation from actual yaw to desired yaw
-            Vector3 src = orientation*Vector3::UNIT_Z;
-            src.y = 0;
-            Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
-            dst.y = 0;
-            Radian yaw = src.getRotationTo(dst, Vector3::UNIT_Y).getYaw();
-
-
-            // using a spring system to apply the rotation
-            Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
-            Vector3 omega = mCharBody->getOmega();
-            omega.x = omega.z = 0;
-            // should not set directly orientation!
-            Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
-            //body->setOmega(Vector3(0, newOmega, 0)); // omega sollte nicht direkt gesetzt werden
-            body->setTorque( mass * springAcc );
-        }
-
-
-
+        ///@todo move to MovingCreature?
         SceneNode* node = mCharacterActor->_getSceneNode();
         std::ostringstream ss;
         Vector3 bodpos, playpos = node->getPosition();
@@ -1224,10 +556,8 @@
             << "camera actor orientation : " << mCameraActor->getWorldOrientation() << std::endl
             << "camera actor : " << mCameraActor->getWorldPosition() << std::endl
             << "camera body pos : " << bodpos << std::endl
-            << "is airborne: " << (mCharacterState.mIsAirBorne ? "true" : "false") << std::endl
-            << "start jump : " << (mCharacterState.mStartJump ? "true" : "false")  << std::endl
-            << "jump timer : " << mCharacterState.mJumpTimer << std::endl
-            << "force : " << lastForce << std::endl;
+            << "camera distance : " << mDesiredDistance << std::endl
+            << "is airborne: " << (mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE ? "true" : "false") << std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
@@ -1236,10 +566,9 @@
     //------------------------------------------------------------------------
     void MovementCharacterController::calculateCamera(const Ogre::Real& timestep)
     {
-        Vector3 charPos;
-        Quaternion charOri(mYaw, Vector3::UNIT_Y);
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
         Quaternion virtualCamOri;
-        charPos = mCharacterActor->getWorldPosition();
         virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
 
 
@@ -1293,8 +622,11 @@
 
             // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
             // so zur optimalen kommen
-            const OgreNewt::MaterialID* materialId =
-                mCharBody->getMaterialGroupID();
+            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
+            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
+            PhysicsMaterialRaycast::MaterialVector materialVector;
+            materialVector.push_back(charMaterialId);
+            materialVector.push_back(camMaterialId);
 //                PhysicsManager::getSingleton()._getLevelMaterialID();
             OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
 
@@ -1305,14 +637,14 @@
 
             RaycastInfo infoCastOptPos = mRaycast->execute(
                 world,
-                materialId,
+                &materialVector,
                 camPos + camRadius * normToOptCamPos, // Gr???e der Kamera einbeziehen
                 optimalCamPos + camRadius * normToOptCamPos,
                 true); // Gr???e der Kamera einbeziehen
 
             RaycastInfo infoCastChar = mRaycast->execute(
                 world,
-                materialId,
+                &materialVector,
                 camPos,
                 charPos,
                 true);
@@ -1350,7 +682,7 @@
                     {
                         infoCastNewPos = mRaycast->execute(
                             world,
-                            materialId,
+                            &materialVector,
                             camPos + camRadius * normToOptCamPos, // Gr???e der Kamera!
                             temp,
                             true);
@@ -1402,9 +734,9 @@
                     {
                         RaycastInfo info = mRaycast->execute(
                             world,
-                            materialId,
+                            &materialVector,
                             camPos,
-                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ] ,
+                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
                             true);
 
                         if( !info.mBody )
@@ -1435,7 +767,7 @@
                     {
                         RaycastInfo info = mRaycast->execute(
                             world,
-                            materialId,
+                            &materialVector,
                             camPos,
                             charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
                             true);
@@ -1456,7 +788,6 @@
                 isPathfinding = false;
             }
 
-
             Vector3 diff = camPos - optimalCamPos;
 
             Vector3 cameraVelocity;
@@ -1483,10 +814,9 @@
     {
         Vector3 targetCamPos;
 
-        Vector3 charPos;
-        Quaternion charOri(mYaw, Vector3::UNIT_Y);
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
         Quaternion virtualCamOri;
-        charPos = mCharacterActor->getWorldPosition();
         virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
 
 
@@ -1567,7 +897,7 @@
                     endRay[i],
                     true);
 
-                if( info.mBody )
+                if( info.mBody && info.mBody != mCamBody )
                 {
                     CollisionFound = true;
                     Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
@@ -1737,13 +1067,15 @@
             mPitchRange.first = Degree(-75);
             mPitchRange.second = Degree(85);
             mPitch = Degree(30);
-            mCamYaw = mYaw;
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
             LOG_MESSAGE(Logger::UI, "Switch to free camera view");
             resetCamera();
         }
     }
 
     //------------------------------------------------------------------------
+/*
+    // not used at the moment!
     void MovementCharacterController::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
     {
         AxisAlignedBox aab;
@@ -1776,6 +1108,7 @@
             mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
         }
     }
+*/
 
     //------------------------------------------------------------------------
     MovementCharacterController::ViewMode MovementCharacterController::getViewMode()
@@ -1805,19 +1138,9 @@
             mCharacterActor->setVisible(false);
         else
             mCharacterActor->setVisible(true);
-
-        // also reset the char
-        mCharacterState.mCurrentMovementState = 0;
-        mCharacterState.mDesiredVel = Vector3::ZERO;
-        mCharacterState.mHasFloorContact = true;
-        mCharacterState.mIsAirBorne = true;
-        mCharacterState.mStartJump = false;
-        mCharacterState.mJumpTimer = 0;
-        mCharacter->setTaktischeBewegung(Creature::BEWEGUNG_NONE);
-        mCharacterState.beginJump = false;
-        mCharacterState.endJump = false;
-        mCharacterState.beginSneak = false;
-        mCharacterState.endSneak = false;
+        
+        LOG_MESSAGE(Logger::UI, "Camera resetted.");
+        ///@todo remove this
         mCharacter->modifyAu(100);
     }
 
@@ -1917,7 +1240,6 @@
         LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
         lineSet->clear();
         lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-        lineSet->addLine(Vector3::ZERO, mGravitation * 0.1, ColourValue::Green);
     }
 
     //------------------------------------------------------------------------



From chrber at mail.berlios.de  Sun May 20 14:19:01 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Sun, 20 May 2007 14:19:01 +0200
Subject: [Dsa-hl-svn] r3461 - in rl/trunk/engine/rules: include src
Message-ID: <200705201219.l4KCJ1uf013478@sheep.berlios.de>

Author: chrber
Date: 2007-05-20 14:18:57 +0200 (Sun, 20 May 2007)
New Revision: 3461

Modified:
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Makefile.am
Log:
Added the four new files
Corrected dos line endings in one of the makefiles


Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-05-20 10:51:25 UTC (rev 3460)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-05-20 12:18:57 UTC (rev 3461)
@@ -20,6 +20,8 @@
 	Inventory.h \
 	JournalEntry.h \
 	Kampftechnik.h \
+	MovingCreatureManager.h \
+	MovingCreature.h \
 	ObjectStateChangeEvent.h \
 	ObjectStateChangeEventSource.h \
 	ObjectStateChangeListener.h \

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-05-20 10:51:25 UTC (rev 3460)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-05-20 12:18:57 UTC (rev 3461)
@@ -1,48 +1,50 @@
-INCLUDES = $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(CEGUI_CFLAGS) $(STLPORT_CFLAGS) -I../include -I../../common/include -I../../core/include
-
-lib_LTLIBRARIES = libRlRules.la
-libRlRules_la_LDFLAGS = $(RUBY_LIBS) $(OGRE_LIBS) $(CEGUI_LIBS) $(LIBS)
-libRlRules_la_SOURCES = \
-	Action.cpp \
-	ActionManager.cpp \
-	Armor.cpp \
-	Combat.cpp \
-	CombatManager.cpp \
-	Container.cpp \
-	Creature.cpp \
-	Date.cpp \
-	DsaDataLoader.cpp \
-	DsaManager.cpp \
-	Effect.cpp \
-	EffectManager.cpp \
-	Eigenschaft.cpp \
-	EigenschaftenStateSet.cpp \
-	GameObject.cpp \
-	GameObjectManager.cpp \
-	Item.cpp \
-	Inventory.cpp \
-	JournalEntry.cpp \
-	Kampftechnik.cpp \
-	ObjectStateChangeEvent.cpp \
-	ObjectStateChangeEventSource.cpp \
-	ObjectStateChangeListener.cpp \
-	Person.cpp \
-	Quest.cpp \
-	QuestBook.cpp \
-	QuestEvent.cpp \
-	QuestListener.cpp \
-	RulesSubsystem.cpp \
+INCLUDES = $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(CEGUI_CFLAGS) $(STLPORT_CFLAGS) -I../include -I../../common/include -I../../core/include
+
+lib_LTLIBRARIES = libRlRules.la
+libRlRules_la_LDFLAGS = $(RUBY_LIBS) $(OGRE_LIBS) $(CEGUI_LIBS) $(LIBS)
+libRlRules_la_SOURCES = \
+	Action.cpp \
+	ActionManager.cpp \
+	Armor.cpp \
+	Combat.cpp \
+	CombatManager.cpp \
+	Container.cpp \
+	Creature.cpp \
+	Date.cpp \
+	DsaDataLoader.cpp \
+	DsaManager.cpp \
+	Effect.cpp \
+	EffectManager.cpp \
+	Eigenschaft.cpp \
+	EigenschaftenStateSet.cpp \
+	GameObject.cpp \
+	GameObjectManager.cpp \
+	Item.cpp \
+	Inventory.cpp \
+	JournalEntry.cpp \
+	Kampftechnik.cpp \
+	MovingCreatureManager.cpp \
+	MovingCreature.cpp \
+	ObjectStateChangeEvent.cpp \
+	ObjectStateChangeEventSource.cpp \
+	ObjectStateChangeListener.cpp \
+	Person.cpp \
+	Quest.cpp \
+	QuestBook.cpp \
+	QuestEvent.cpp \
+	QuestListener.cpp \
+	RulesSubsystem.cpp \
 	SelectionHelper.cpp \
 	Selector.cpp \
-	Slot.cpp \
-	SonderfertigkeitenStateSet.cpp \
-	StateSet.cpp \
-	Talent.cpp \
-	Talentgruppe.cpp \
-	TalentStateSet.cpp \
-	TimerEvent.cpp \
-	TimerEventSource.cpp \
-	TimerListener.cpp \
-	TimerManager.cpp  \
-	Weapon.cpp \
+	Slot.cpp \
+	SonderfertigkeitenStateSet.cpp \
+	StateSet.cpp \
+	Talent.cpp \
+	Talentgruppe.cpp \
+	TalentStateSet.cpp \
+	TimerEvent.cpp \
+	TimerEventSource.cpp \
+	TimerListener.cpp \
+	TimerManager.cpp  \
+	Weapon.cpp \
 	ZauberStateSet.cpp



From melven at mail.berlios.de  Sun May 20 19:34:03 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 20 May 2007 19:34:03 +0200
Subject: [Dsa-hl-svn] r3462 - rl/trunk/engine/rules/src
Message-ID: <200705201734.l4KHY3n0013363@sheep.berlios.de>

Author: melven
Date: 2007-05-20 19:33:56 +0200 (Sun, 20 May 2007)
New Revision: 3462

Modified:
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
removed some small bugs (counter force to gravitation etc)

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-20 12:18:57 UTC (rev 3461)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-20 17:33:56 UTC (rev 3462)
@@ -73,6 +73,7 @@
             if(vel.squaredLength() > mVelocity.squaredLength())
                 delay *= 1.5;
             force = mass * (mVelocity - vel) / delay;
+            force.y = 0;
         }
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {
@@ -292,7 +293,7 @@
                     mMovingCreature->getCreature()->getAu() > 6;
             else
                 return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > 10;
+                    mMovingCreature->getCreature()->getAu() > 8;
         }
         virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {
@@ -366,7 +367,7 @@
             else
                 return Gehen::isPossible() &&
                     mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.5 &&
-                    mMovingCreature->getCreature()->getAu() > 10;
+                    mMovingCreature->getCreature()->getAu() > 8;
         }
         virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {
@@ -631,7 +632,7 @@
             else
                 return 
                 mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 10 &&
+                mMovingCreature->getCreature()->getAu() > 8 &&
                 mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
         }
@@ -688,11 +689,11 @@
             if( mState == DOWNTOUP )
             {
                 mTimer += elapsedTime;
-                if( mTimer >= 0.5f )
+                if( mTimer >= 0.25f )
                 {
                     mState = UP;
                     mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
-                    //mMovingCreature->setAnimation("idle_sprung");
+                    //mMovingCreature->setAnimation("idle_sprung"); // we also don't need this animation!
                     mJumpNow = true;
                     mTimer = 0;
                 }
@@ -789,7 +790,7 @@
             else
                 return 
                 mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 10 &&
+                mMovingCreature->getCreature()->getAu() > 8 &&
                 mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
         }
@@ -853,7 +854,7 @@
             if( mState == DOWNTOUP )
             {
                 mTimer += elapsedTime;
-                if( mTimer >= 0.5f )
+                if( mTimer >= 0.3f )
                 {
                     mState = UP;
                     mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);



From melven at mail.berlios.de  Sun May 20 20:01:55 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 20 May 2007 20:01:55 +0200
Subject: [Dsa-hl-svn] r3463 - in rl/trunk/engine: rules/src ui/src
Message-ID: <200705201801.l4KI1t79015642@sheep.berlios.de>

Author: melven
Date: 2007-05-20 20:01:41 +0200 (Sun, 20 May 2007)
New Revision: 3463

Modified:
   rl/trunk/engine/rules/src/MovingCreature.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
-the player only tries to jump if it is possible
-strange behaviour if creature jumps after rotating removed

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-20 17:33:56 UTC (rev 3462)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-20 18:01:41 UTC (rev 3463)
@@ -638,15 +638,15 @@
         }
         virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
         {
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+            body->getMassMatrix(mass, inertia);
+
             if( mJumpNow )
             {
                 mJumpNow = false;
 
-                Real mass;
-                Vector3 inertia;
-                OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-                body->getMassMatrix(mass, inertia);
-
                 Real m = mass;
                 Real g = PhysicsManager::getSingleton().getGravity().length();
                 Real t = timestep;
@@ -657,6 +657,9 @@
                     0);
                 mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
             }
+
+            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
+            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
         }
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {
@@ -710,6 +713,7 @@
         }
         virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
         {
+            rotation = Vector3::ZERO;
             return false;
         }
         virtual bool canChangeToMovement(MovingCreature::MovementType id)
@@ -796,16 +800,15 @@
         }
         virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
         {
+            Real mass;
+            Vector3 inertia;
+            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
+            body->getMassMatrix(mass, inertia);
+
             if( mJumpNow )
             {
                 mJumpNow = false;
 
-                Real mass;
-                Vector3 inertia;
-                OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-                body->getMassMatrix(mass, inertia);
-
-
                 Real m = mass;
                 Real g = PhysicsManager::getSingleton().getGravity().length();
                 Real v0 = mMovingCreature->getVelocity().length();
@@ -822,6 +825,9 @@
                 force += Vector3(0,jumpForcezy,-jumpForcezy);
                 mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
             }
+
+            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
+            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
         }
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
         {
@@ -875,6 +881,7 @@
         }
         virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
         {
+            rotation = Vector3::ZERO;
             return false;
         }
         virtual bool canChangeToMovement(MovingCreature::MovementType id)

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-20 17:33:56 UTC (rev 3462)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-05-20 18:01:41 UTC (rev 3463)
@@ -348,7 +348,8 @@
                     direction,
                     Vector3(0, rotation.valueRadians(), 0) );
             }
-            else if( movement & MOVE_JUMP )
+            else if( movement & MOVE_JUMP && 
+                mMovingCreature->getMovementFromId(MovingCreature::MT_HOCHSPRUNG)->isPossible() )
             {
                 MovingCreature::MovementType type = MovingCreature::MT_HOCHSPRUNG;
                 Vector3 direction = Vector3::UNIT_Y;



From blakharaz at mail.berlios.de  Sun May 20 22:11:56 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 20 May 2007 22:11:56 +0200
Subject: [Dsa-hl-svn] r3464 - in modules/regressiontest: maps scripts/maps
Message-ID: <200705202011.l4KKBuV0003254@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-20 22:11:53 +0200 (Sun, 20 May 2007)
New Revision: 3464

Modified:
   modules/regressiontest/maps/regressiontest.scene
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
regressiontest: Place hero object in scene

Modified: modules/regressiontest/maps/regressiontest.scene
===================================================================
--- modules/regressiontest/maps/regressiontest.scene	2007-05-20 18:01:41 UTC (rev 3463)
+++ modules/regressiontest/maps/regressiontest.scene	2007-05-20 20:11:53 UTC (rev 3464)
@@ -4,5 +4,9 @@
             <position x="0.0" y="0.0" z="0.0" />
             <scale x="1.0" y="1.0" z="1.0" />
         </entity>
+        <gameobject class="hero" id="1" state="IN_SCENE">
+			<position x="0" y="0.0" z="0"/>
+		</gameobject>
+        
     </nodes>
 </scene>

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-05-20 18:01:41 UTC (rev 3463)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-05-20 20:11:53 UTC (rev 3464)
@@ -22,16 +22,8 @@
 
 $SCRIPT.log("init map 'regressiontest'...")
 
-$SCRIPT.log("Create hero")
-$hero = $GOM.createGameObject("hero", 1);
-
-$SCRIPT.log("Place hero into scene")
-#$hero.setPosition([0.0, 1.0, 0.0]);
-$hero.setState(GOS_IN_SCENE)
-
-
-
 $SCRIPT.log("Prepare hero for being the active character")
+$hero = $GOM.getGameObject(1);
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")



From blakharaz at mail.berlios.de  Sun May 20 22:13:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 20 May 2007 22:13:18 +0200
Subject: [Dsa-hl-svn] r3465 - rl/trunk/engine/core/src
Message-ID: <200705202013.l4KKDIwX003434@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-20 22:13:01 +0200 (Sun, 20 May 2007)
New Revision: 3465

Modified:
   rl/trunk/engine/core/src/MeshObject.cpp
Log:
replace exception by error log when an animation is not available

Modified: rl/trunk/engine/core/src/MeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MeshObject.cpp	2007-05-20 20:11:53 UTC (rev 3464)
+++ rl/trunk/engine/core/src/MeshObject.cpp	2007-05-20 20:13:01 UTC (rev 3465)
@@ -143,8 +143,9 @@
         }
         catch(Ogre::Exception&) 
         {
-            Throw(IllegalArgumentException,
+			LOG_ERROR(Logger::CORE,
                 animName + " is not a valid AnimationState of " + mMeshName + ".");
+			return NULL;
         }
 
         return AnimationManager::getSingleton().addMeshAnimation(



From blakharaz at mail.berlios.de  Sun May 20 22:15:53 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 20 May 2007 22:15:53 +0200
Subject: [Dsa-hl-svn] r3466 - rl/trunk/engine/core/src
Message-ID: <200705202015.l4KKFrhZ003584@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-20 22:15:45 +0200 (Sun, 20 May 2007)
New Revision: 3466

Modified:
   rl/trunk/engine/core/src/PhysicalThing.cpp
Log:
Avoid crash if an animation is not available for creating a pose

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-05-20 20:13:01 UTC (rev 3465)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-05-20 20:15:45 UTC (rev 3466)
@@ -329,7 +329,7 @@
             CollisionMap::iterator it = mPoseCollisions.find(animName);
             if (it == mPoseCollisions.end())
             {
-                Entity* entity = dynamic_cast<MeshObject*>(mPhysicalObject)->getEntity();
+                Entity* entity = meshObject->getEntity();
                 MeshObject *tempMesh = NULL;
 
                 // the problem fixed and it's source:
@@ -340,9 +340,9 @@
 
 				// check if this is a 'animated' state we have to create the convex hull for ...
 
-				if (animName != "") {
+				if (animName != "" && meshObject->hasAnimation(animName)) {
 					// Duplicating the MeshObject and animate it into the animName pose
-					tempMesh = dynamic_cast<MeshObject*>(mPhysicalObject)->createPosedCopy(animName);
+					tempMesh = meshObject->createPosedCopy(animName);
 
 					entity = tempMesh->getEntity();
 				}



From blakharaz at mail.berlios.de  Sun May 20 22:20:24 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 20 May 2007 22:20:24 +0200
Subject: [Dsa-hl-svn] r3467 - in rl/trunk/engine: core/src rules/src
Message-ID: <200705202020.l4KKKOMa003742@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-20 22:20:17 +0200 (Sun, 20 May 2007)
New Revision: 3467

Modified:
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
   rl/trunk/engine/rules/src/Slot.cpp
Log:
Small fixes:
* update MergeableMeshObject when removing a SubmeshSlot
* only merge meshes when they are in scene (think about delayed state change: what to do when the merge is first and then the mesh is placed into scene)

Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-05-20 20:15:45 UTC (rev 3466)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-05-20 20:20:17 UTC (rev 3467)
@@ -97,6 +97,7 @@
 		if (it != mMeshes.end())
 		{
 			mMeshes.erase(it);
+			updateMesh();
 		}
 		else
 		{

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-05-20 20:15:45 UTC (rev 3466)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-05-20 20:20:17 UTC (rev 3467)
@@ -84,31 +84,38 @@
 
     void SubmeshSlot::setItem(Item* item)
     {
-		//@todo: move to actor
-		MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
-			mOwner->getActor()->getControlledObject());
-		if (mmo != NULL)
+		///@todo: what to do if actor is null?
+		if (mOwner->getActor() != NULL)
 		{
-			if (item == NULL)
+			MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
+				mOwner->getActor()->getControlledObject());
+			if (mmo != NULL)
 			{
-				MeshPartMap::const_iterator it = mOwner->getMeshParts().find(mSubmesh);
-				if (it != mOwner->getMeshParts().end())
+				if (item == NULL)
 				{
-					mmo->replaceSubmesh(
-						mSubmesh,
-						(*it).second);
+					MeshPartMap::const_iterator it = mOwner->getMeshParts().find(mSubmesh);
+					if (it != mOwner->getMeshParts().end())
+					{
+						mmo->replaceSubmesh(
+							mSubmesh,
+							(*it).second);
+					}
+					else
+					{
+						mmo->removeSubmesh(mSubmesh);
+					}
+					mItem = NULL;
 				}
-				mItem = NULL;
-			}
-			else
-			{
-				if (isAllowed(item))
-				{			
-					item->setState(GOS_IN_POSSESSION);
-					mmo->replaceSubmesh(
-						mSubmesh, 
-						item->getMeshfile().c_str());
-					mItem = item;
+				else
+				{
+					if (isAllowed(item))
+					{			
+						item->setState(GOS_IN_POSSESSION);
+						mmo->replaceSubmesh(
+							mSubmesh, 
+							item->getMeshfile().c_str());
+						mItem = item;
+					}
 				}
 			}
 		}



From blakharaz at mail.berlios.de  Sun May 20 22:21:46 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 20 May 2007 22:21:46 +0200
Subject: [Dsa-hl-svn] r3468 - in modules/regressiontest: dsa scripts
Message-ID: <200705202021.l4KKLks3003795@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-20 22:21:36 +0200 (Sun, 20 May 2007)
New Revision: 3468

Added:
   modules/regressiontest/scripts/mckhero.rb
Modified:
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/MergeableMeshTest.rb
   modules/regressiontest/scripts/moduleconfig.rb
Log:
Started using a mesh construction kit hero

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-05-20 20:20:17 UTC (rev 3467)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-05-20 20:21:36 UTC (rev 3468)
@@ -1,6 +1,21 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <GameObjectDefinitions>
 
+    <gameobjectclass classid="mckhero" baseclass="MCKHero">
+		<property name="geometrytype" type="STRING" data="ellipsoid" />
+		<property name="mass" type="REAL" data="75"/>
+		<property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
+        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+        <property name="meshparts" type="MAP">
+            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
+            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
+            <property name="leg" type="STRING" data="men_human_female_leg_pants_01_long.mesh"/>
+            <property name="feet" type="STRING" data="men_human_female_feet_boots_01.mesh"/>
+        </property>
+	</gameobjectclass>
+
     <gameobjectclass classid="Holzscheit" baseclass="GameObject">
         <property name="name" type="STRING" data="Holzscheit"/>        
         <property name="description" type="STRING" data="Greater log of time check. (Very rare)"/>

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-20 20:20:17 UTC (rev 3467)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-05-20 20:21:36 UTC (rev 3468)
@@ -4,7 +4,7 @@
     def initialize(center)
         super(center)
 
-        $SCRIPT.log("MergeableMeshTest Start");
+        $SCRIPT.log(">MergeableMeshTest Start");
 
         test_obj1 = $GOM.createGameObject("mesh construction kit test object")
         test_obj1.setPosition(center)
@@ -16,27 +16,39 @@
         test_obj2.placeIntoScene();
 #        test_obj2.getActor().getControlledObject().startAnimation("Walk")
         test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-        test_obj2.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_obj2.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
+        test_obj2.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, false);
         test_item2 = $GOM.createGameObject("mesh construction kit test item 1")
-        test_obj2.getInventory().hold(test_item2, "Torso")
+        test_obj2.getInventory().hold(test_item2, "Armor")
 
         test_obj3 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj3.setPosition(rel_pos([2, 0, 0]))
         test_obj3.placeIntoScene();
         test_obj3.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-        test_obj3.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_obj3.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
+        test_obj3.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, false);
         test_item3 = $GOM.createGameObject("mesh construction kit test item 2")
-        test_obj3.getInventory().hold(test_item3, "Torso")
+        test_obj3.getInventory().hold(test_item3, "Armor")
         test_obj3.getActor().getControlledObject().startAnimation("Walk")
 
         test_obj4 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj4.setPosition(rel_pos([3, 0, 0]))
         test_obj4.placeIntoScene();
         test_obj4.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-        test_obj4.getInventory().addSlot("Torso", "torso", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_obj4.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
+        test_obj4.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, false);
         test_item4 = $GOM.createGameObject("mesh construction kit test item 2")
-        test_obj4.getInventory().hold(test_item4, "Torso")
-        test_obj4.getInventory().dropItem("Torso")
+        test_obj4.getInventory().hold(test_item4, "Armor")
+        test_obj4.getInventory().dropItem("Armor")
 
+        $SCRIPT.log("Give swords to all creatures.");
+        sword2 = $GOM.createGameObject("shortsword");
+        test_obj2.getInventory().hold(sword2, "Right Hand");
+        sword3 = $GOM.createGameObject("shortsword");
+        test_obj3.getInventory().hold(sword3, "Right Hand");
+        sword4 = $GOM.createGameObject("shortsword");
+        test_obj4.getInventory().hold(sword4, "Right Hand");
+
+        $SCRIPT.log(">MergeableMeshTest End");
     end
 end

Added: modules/regressiontest/scripts/mckhero.rb
===================================================================
--- modules/regressiontest/scripts/mckhero.rb	2007-05-20 20:20:17 UTC (rev 3467)
+++ modules/regressiontest/scripts/mckhero.rb	2007-05-20 20:21:36 UTC (rev 3468)
@@ -0,0 +1,58 @@
+load "embed.rb"
+
+class MCKHero < Person
+    def initialize(id)
+        super(id);
+        addQueryFlag(RlScript::QUERYFLAG_PLAYER)
+		    setName("Alrike");
+		    setDescription("Heldin von Berufung");
+		    $SCRIPT.log("Gute Eigenschaften zuweisen...");
+
+        setEigenschaft("MU", 12);
+        setEigenschaft("KL", 8);
+        setEigenschaft("IN", 9);
+        setEigenschaft("CH", 10);
+        setEigenschaft("FF", 11);
+        setEigenschaft("GE", 12);
+        setEigenschaft("KO", 13); #KO
+        setEigenschaft("KK", 14); #KK
+		setWert(Creature::WERT_MOD_LE, 10); # LE-Mod
+
+		$SCRIPT.log("LeP und AuP auff?llen");
+        modifyLe(1000, false); # LeP = LE
+        modifyAu(1000); # Au = voll
+        #modifyLe(-20); # 10 LeP abziehen
+
+		$SCRIPT.log("Talente hinzuf?gen");
+		addTalent("Athletik", 3);
+		#addTalent("K?rperbeherrschung", 3);
+
+        $SCRIPT.log("Heldenaktor beschreiben...");
+        setProperty("meshfile", "men_alrike.mesh")
+		setProperty("physicsbody", PhysicsManager::GT_ELLIPSOID)
+		setProperty("mass", 75.0);
+	
+		$SCRIPT.log("Inventar konfigurieren.");
+		inv = getInventory();
+		inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);
+		inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING);
+		inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_ALL_ITEMS);
+		inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_ALL_ITEMS);
+		inv.addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
+		inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS);
+    inv.addSlot("Armor", "torso", Item::ITEMTYPE_ARMOR, false);
+
+		#addSounds()
+        $SCRIPT.log("done.");
+    end
+
+    def addSounds
+        heroActor = getActor()
+        soundActor = $AM.createSoundSampleActor(heroActor.getName()+"_schlucken","schlucken.ogg");
+        heroActor.attachToSlot(soundActor, "huefte");
+        @mSchmerzSchreiSound = $AM.createSoundSampleActor("SchmerzSchreiSound","schmerz_schrei_au_01.ogg");
+        heroActor.attachToSlot(@mSchmerzSchreiSound, "huefte"); 
+    end
+
+end
+

Modified: modules/regressiontest/scripts/moduleconfig.rb
===================================================================
--- modules/regressiontest/scripts/moduleconfig.rb	2007-05-20 20:20:17 UTC (rev 3467)
+++ modules/regressiontest/scripts/moduleconfig.rb	2007-05-20 20:21:36 UTC (rev 3468)
@@ -22,9 +22,10 @@
     end
 
     def start()
+        require "mckhero.rb"
+        require "hero.rb"
         MapLoader.new("regressiontest").loadMap("regressiontest.scene")
         load "regressiontest.rb"
-        $World = $CORE.getWorld();
     end
 end
 



From blakharaz at mail.berlios.de  Mon May 21 23:43:56 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 21 May 2007 23:43:56 +0200
Subject: [Dsa-hl-svn] r3469 - rl/trunk/engine/common/include
Message-ID: <200705212143.l4LLhudt006077@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-21 23:43:51 +0200 (Mon, 21 May 2007)
New Revision: 3469

Modified:
   rl/trunk/engine/common/include/Property.h
Log:
Added implicit type conversions to property types and helper functions for handling property maps


Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2007-05-20 20:21:36 UTC (rev 3468)
+++ rl/trunk/engine/common/include/Property.h	2007-05-21 21:43:51 UTC (rev 3469)
@@ -63,12 +63,58 @@
                 rl::WrongFormatException, \
                 "Wrong property type for to##Name (type is "+ Ogre::String(mValue.type().name())+") " + (mValue.empty()?"EMPTY!":"not empty")); \
         } \
+    }\
+    operator Type() const \
+    {\
+        return to##Name();\
     }
 
 	class Property;
 
+	typedef std::vector<Property> PropertyVector;
 	typedef std::map<CeGuiString, Property> PropertyMap;
 
+    template<typename T> PropertyMap convertToPropertyMap(const std::map<const CeGuiString, typename T>& input)
+    {
+        PropertyMap map;
+        for (std::map<const CeGuiString, typename T>::const_iterator it =
+            input.begin(); it != input.end(); ++it)
+        {
+            map[it->first] = Property(it->second);
+        }
+        return map;
+    }
+
+    template<typename T> PropertyMap convertToPropertyMap(const std::map<const Ogre::String, typename T>& input)
+    {
+        PropertyMap map;
+        for (std::map<const Ogre::String, typename T>::const_iterator it =
+            input.begin(); it != input.end(); ++it)
+        {
+            map[it->first] = Property(it->second);
+        }
+        return map;
+    }
+
+    template<typename T> void convertToMap(
+        const PropertyMap& propmap, std::map<const Ogre::String, typename T>& output)
+    {
+        for (PropertyMap::const_iterator it = propmap.begin(); it != propmap.end(); ++it)
+        {
+            output[it->first.c_str()] = it->second;
+        }
+    }
+    
+    template<typename T> void convertToMap(
+        const PropertyMap& propmap, std::map<const CeGuiString, typename T>& output)
+    {
+        for (PropertyMap::const_iterator it = propmap.begin(); it != propmap.end(); ++it)
+        {
+            output[it->first] = it->second;
+        }
+    }
+    
+
     class _RlCommonExport Property
     {
     public:
@@ -82,7 +128,7 @@
         PropertyMethod(Quaternion, const Ogre::Quaternion&);
         PropertyMethod(IntTriple, const Tripel<int>);
         PropertyMethod(IntPair, const IntPair);
-		PropertyMethod(Array, const std::vector<Property>);
+		PropertyMethod(Array, const PropertyVector);
 		PropertyMethod(Map, const PropertyMap);
 
     private:



From blakharaz at mail.berlios.de  Mon May 21 23:48:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 21 May 2007 23:48:18 +0200
Subject: [Dsa-hl-svn] r3470 - in rl/trunk/engine: ai/src script/swig ui/src
Message-ID: <200705212148.l4LLmIV5006352@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-21 23:48:14 +0200 (Mon, 21 May 2007)
New Revision: 3470

Modified:
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/script/swig/TypeRlProperty.swig
   rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
Log:
Use PropertyVector typedef


Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-05-21 21:43:51 UTC (rev 3469)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-05-21 21:48:14 UTC (rev 3470)
@@ -151,11 +151,11 @@
         Property behaviorProperty = creature->getProperty(Creature::PROPERTY_BEHAVIOURS);
         if (behaviorProperty.isArray())
         {
-            std::vector<Property> behaviors = behaviorProperty.toArray();
+            PropertyVector behaviors = behaviorProperty.toArray();
             if (!behaviors.empty())
             {
                 Agent* agent = createAgent(AGENT_STD_NPC, creature);
-                for (std::vector<Property>::const_iterator it = behaviors.begin(),
+                for (PropertyVector::const_iterator it = behaviors.begin(),
                     end = behaviors.end(); it != end; ++it)
                 {
                     if (it->isString())

Modified: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-05-21 21:43:51 UTC (rev 3469)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-05-21 21:48:14 UTC (rev 3470)
@@ -131,9 +131,9 @@
     }
     else if (input.isArray())
     {
-		std::vector<rl::Property> vec = input.toArray();
+		PropertyVector vec = input.toArray();
 		VALUE rval = rb_ary_new();
-		for (std::vector<rl::Property>::const_iterator it = vec.begin();
+		for (PropertyVector::const_iterator it = vec.begin();
 			it != vec.end(); it++)
 		{
 			rb_ary_push(rval, rl::convertPropertyToValue(*it));

Modified: rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-05-21 21:43:51 UTC (rev 3469)
+++ rl/trunk/engine/ui/src/GameObjectPropsWindow.cpp	2007-05-21 21:48:14 UTC (rev 3470)
@@ -510,12 +510,11 @@
         mTabPane->addTab(newTable);
 
         // Get access to the vector
-        std::vector<Property> vProp = prop.toArray();
-        std::vector<Property>::iterator it;
-
+        PropertyVector vProp = prop.toArray();
+        
         // Iterate through the vector entries and add them
         // to the table
-        for(it = vProp.begin(); it != vProp.end(); it++)
+        for(PropertyVector::const_iterator it = vProp.begin(); it != vProp.end(); it++)
         {
             // Check for Int
             if( it->isInt() )



From blakharaz at mail.berlios.de  Mon May 21 23:49:23 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 21 May 2007 23:49:23 +0200
Subject: [Dsa-hl-svn] r3471 - in rl/trunk/engine/rules: include src
Message-ID: <200705212149.l4LLnN7l006399@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-21 23:49:08 +0200 (Mon, 21 May 2007)
New Revision: 3471

Modified:
   rl/trunk/engine/rules/include/Container.h
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/include/Weapon.h
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/rules/src/Item.cpp
   rl/trunk/engine/rules/src/Weapon.cpp
Log:
Save state in properties


Modified: rl/trunk/engine/rules/include/Container.h
===================================================================
--- rl/trunk/engine/rules/include/Container.h	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/include/Container.h	2007-05-21 21:49:08 UTC (rev 3471)
@@ -24,6 +24,7 @@
 namespace rl
 {
     typedef std::set<Item*> ItemSet;
+	typedef std::pair<unsigned int, unsigned int> UintPair;
 
     /// Behaelter fr Items.
     class _RlRulesExport Container : public Item
@@ -34,33 +35,44 @@
         static const Ogre::String PROPERTY_VOLUME;
         static const Ogre::String PROPERTY_CAPACITY;
         static const Ogre::String PROPERTY_CONTENT;
+        static const Ogre::String PROPERTY_CONTENT_OBJECTS;
+        static const Ogre::String PROPERTY_CONTENT_POSITIONS;
 
+		/** Creates a new container
+		 * @param id the gameobject ID
+		 */
         Container(unsigned int id);
         virtual ~Container(void);
 
-        /// Fassungsvermoegen in Unzen
+		/// Get the weight capacity (in Stein)
         Ogre::Real getCapacity() const;
 
-        /// Fassungsvermoegen in Unzen
+		/// Set the weight capacity (in Stein)
         void setCapacity(Ogre::Real capacity);
 
-		// Volumen in x (breite) * y (hoehe)
+		/// Set the "volume" to x (width) * y (height) spaces
 		void setVolume(unsigned int x, unsigned int y);
-        std::pair<unsigned int, unsigned int> getVolume() const;
 
-        /// ist dieser Gegenstand ein Container
+		/// Get the container's "volume" spaces
+		UintPair getVolume() const;
+
+        /** Returns whether this item is a container
+		 * @return always <code>true</code>
+		 */
         virtual bool isContainer() const;
 
 		/// Liefert Gesamtgewicht des Inhalts.
         Ogre::Real getContentWeight() const;
-        virtual Ogre::Real getWeight() const;
 
+		virtual Ogre::Real getMass() const;
+
 		/**
 		 * Add an item to the container's content
 		 * @param item the item
 		 * @return <code>true</code> if adding was successful, <code>false</code> otherwise (e.g. not enough space)
 		 */
         bool addItem(Item* item);
+		bool addItem(Item* item, UintPair position);
         void removeItem(Item* item);
 
         ItemSet getItems() const;
@@ -72,14 +84,14 @@
         void putItemAt(Item* item, unsigned int x, unsigned int y);
         bool canPlaceAt(Item* item, unsigned int xPos, unsigned int yPos) const;
         void setItemPosition(Item* item, unsigned int xPos, unsigned int yPos);
-        std::pair<unsigned int,unsigned int> getItemPosition(Item* item) const;
+        UintPair getItemPosition(Item* item) const;
 
         virtual const Property getProperty(const Ogre::String& key) const;
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
 
     private:
-		static const std::pair<unsigned int, unsigned int> NO_SPACE_FOR_ITEM;
+		static const UintPair NO_SPACE_FOR_ITEM;
 
         Ogre::Real mCapacity;
 		std::pair<unsigned int,unsigned int> mVolume;
@@ -90,10 +102,14 @@
 
         ItemSet mItems;
 
-        std::map<Item*, std::pair<unsigned int, unsigned int> > mItemPositions;
+        std::map<Item*, UintPair> mItemPositions;
 
-        std::pair<unsigned int, unsigned int> findPositionWithEnoughSpace(std::pair<unsigned int, unsigned int> space) const;
-        bool checkSpace(unsigned int xStart, unsigned int yStart, std::pair<unsigned int,unsigned int> space) const;
+        std::pair<unsigned int, unsigned int> 
+			findPositionWithEnoughSpace(UintPair space) const;
+        bool checkSpace(
+			unsigned int xStart, 
+			unsigned int yStart, 
+			UintPair space) const;
     };
 }
 

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/include/Creature.h	2007-05-21 21:49:08 UTC (rev 3471)
@@ -110,6 +110,20 @@
             static const Ogre::String CLASS_NAME;
             static const Ogre::String PROPERTY_BEHAVIOURS;
 			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
+            static const Ogre::String PROPERTY_CURRENT_LE;
+            static const Ogre::String PROPERTY_CURRENT_AE;
+            static const Ogre::String PROPERTY_CURRENT_AU;
+            static const Ogre::String PROPERTY_CURRENT_FATIGUE;
+            static const Ogre::String PROPERTY_EFFECTS;
+            static const Ogre::String PROPERTY_EIGENSCHAFTEN;
+            static const Ogre::String PROPERTY_TALENTE;
+            static const Ogre::String PROPERTY_KAMPFTECHNIKEN;
+            static const Ogre::String PROPERTY_VORTEILE;
+            static const Ogre::String PROPERTY_NACHTEILE;
+            static const Ogre::String PROPERTY_SF;
+            static const Ogre::String PROPERTY_WERTE;
+            static const Ogre::String PROPERTY_AP;
+            static const Ogre::String PROPERTY_INVENTORY;
 
 			typedef std::string Wert;
 
@@ -768,7 +782,6 @@
             /// Verwaltet die Effekte die auf die Kreatur wirken.
             EffectManager* mEffectManager;
             /// Zeigt auf die gerade aktive Waffe.
-            Weapon* mActiveWeapon;
             EigenschaftMap mEigenschaften;
             TalentMap mTalente;
             KampftechnikMap mKampftechniken;
@@ -779,7 +792,7 @@
             Ap mAp;
             /// Zeigt auf das Inventar der Kreatur.
             Inventory* mInventory;
-        Ogre::String mInventoryWindowType;
+            Ogre::String mInventoryWindowType;
 
             Property mBehaviours;
 

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/include/Item.h	2007-05-21 21:49:08 UTC (rev 3471)
@@ -61,15 +61,9 @@
 		Item(unsigned int id);
         virtual ~Item(void);
 
-	    void setWeight(Ogre::Real weight);
-        Ogre::Real getWeight() const;
-
 		void setItemType(ItemType itemType);
 		ItemType getItemType() const;
 
-		void setPrice(int price);
-		int getPrice() const;
- 
 		const CeGuiString getImageName() const;
 		void setImageName(const CeGuiString name);
 
@@ -90,13 +84,8 @@
         virtual PropertySet* getAllProperties() const;
 
     protected:
-        /// Masse in Unzen.
-        Ogre::Real mWeight;
 		ItemType mItemType;
 
-		// Der Standard-Preis (kann variiert werden) in Silbertalern
-		unsigned int mPrice;
-
 		CeGuiString mImageName;
 
 		std::pair<int,int> mSize;

Modified: rl/trunk/engine/rules/include/Weapon.h
===================================================================
--- rl/trunk/engine/rules/include/Weapon.h	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/include/Weapon.h	2007-05-21 21:49:08 UTC (rev 3471)
@@ -22,37 +22,44 @@
 
 namespace rl
 {
-	/// Objekte die sich mit Kampffertigkeiten einsetzen lassen
+	/// Weapons are objects which can be used with combat talents
 	class _RlRulesExport Weapon : public Item
 	{
 	public:
 		enum Distanzklasse 
 		{
-			DK_H=0,
-			DK_N,
-			DK_S,
-			DK_P
+			DK_H = 0,
+			DK_N = 1,
+			DK_S = 2,
+			DK_P = 4
 		};
 
         static const Ogre::String CLASS_NAME;
 
+        static const Ogre::String PROPERTY_TP;
+        static const Ogre::String PROPERTY_TP_KK;
+        static const Ogre::String PROPERTY_TP_BF;
+        static const Ogre::String PROPERTY_TP_INI;
+        static const Ogre::String PROPERTY_TP_WM;
+        static const Ogre::String PROPERTY_TP_DK;
+        static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
+
 		Weapon (unsigned int id);
         virtual ~Weapon(void);
 
-		const CeGuiString getDescription() const;
-
 		void setTp(int d6, int d20, int mod);
 		const Tripel<int>& getTp() const;
 		void setTpKk(int base, int step);
 		const std::pair<int, int>& getTpKk() const;
 		void setBf(int newBf);
-		int getBf();
+		int getBf() const;
 		void setIni(int newIni);
-		int getIni();
+		int getIni() const;
 		void setWm(std::pair<int, int>& newWm);
 		const std::pair<int,int>& getWm() const;
-		void setDk(Distanzklasse newDk);
-		Distanzklasse getDk();
+		void setDk(int newDk);
+		int getDk() const;
+        bool hasDk(Distanzklasse dk) const;
 		void setKampftechnik(const CeGuiString newKampftechnik);
 		const CeGuiString getKampftechnik() const;
 
@@ -66,7 +73,7 @@
 		int mBf;
 		int mIni;
 		std::pair<int, int> mWm;
-		Distanzklasse mDk;
+		int mDk;
 		CeGuiString mKampftechnik;
 	};
 }

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-05-21 21:49:08 UTC (rev 3471)
@@ -15,20 +15,26 @@
  */
 
 #include "Container.h"
+
+#include <algorithm>
+
 #include "Exception.h"
+#include "GameObjectManager.h"
 #include "Item.h"
-#include <algorithm>
 
 using namespace std;
 
 namespace rl {
 
-	const std::pair<unsigned int, unsigned int> Container::NO_SPACE_FOR_ITEM = make_pair(1999999999, 1999999999);
+	const UintPair Container::NO_SPACE_FOR_ITEM = make_pair(1999999999, 1999999999);
 
     const Ogre::String Container::CLASS_NAME = "Container";
 
     const Ogre::String Container::PROPERTY_CAPACITY = "capacity";
     const Ogre::String Container::PROPERTY_VOLUME = "volume";
+	const Ogre::String Container::PROPERTY_CONTENT = "content";
+    const Ogre::String Container::PROPERTY_CONTENT_OBJECTS = "objects";
+    const Ogre::String Container::PROPERTY_CONTENT_POSITIONS = "positions";
 
     Container::Container(unsigned int id)
         : Item(id),
@@ -67,7 +73,7 @@
         Ogre::Real rval = 0;
         for (ItemSet::const_iterator it = mItems.begin(); it != mItems.end(); it++)
         {
-            rval += (*it)->getWeight();
+            rval += (*it)->getMass();
         }
         return rval;
     }
@@ -84,12 +90,23 @@
 
     bool Container::addItem(Item* item)
     {
+        return addItem(item, findPositionWithEnoughSpace(item->getSize()));
+    }
+
+    bool Container::addItem(Item* item, UintPair position)
+    {
         if(item == NULL)
         {
             Throw(NullPointerException, "Item ist null.");
         }
 
-        pair<unsigned int, unsigned int> pos = findPositionWithEnoughSpace(item->getSize());
+
+        UintPair pos = position;
+		if (!canPlaceAt(item, pos.first, pos.second))
+		{		
+			pos = findPositionWithEnoughSpace(item->getSize());
+		}
+
 		if (pos != NO_SPACE_FOR_ITEM)
 		{
 			mItemPositions[item] = pos;
@@ -169,9 +186,9 @@
         mItemPositions[item] = make_pair(xPos, yPos);
     }
 
-	std::pair<unsigned int, unsigned int> Container::getItemPosition(Item* item) const
+	UintPair Container::getItemPosition(Item* item) const
     {
-		std::map<Item*, std::pair<unsigned int, unsigned int> >::const_iterator it = 
+		std::map<Item*, UintPair >::const_iterator it = 
 			mItemPositions.find(item);
         if (it == mItemPositions.end())
         {
@@ -181,7 +198,7 @@
 		return (*it).second;
     }
 
-    pair<unsigned int, unsigned int> Container::findPositionWithEnoughSpace(pair<unsigned int, unsigned int> space) const
+    UintPair Container::findPositionWithEnoughSpace(UintPair space) const
     {
 		for (unsigned int x = 0; x < mVolume.first; x++)
         {
@@ -225,11 +242,11 @@
 
     Item* Container::getItemAt(unsigned int x, unsigned int y) const
     {
-        for (map<Item*, pair<unsigned int, unsigned int> >::const_iterator iter = mItemPositions.begin(); 
+        for (map<Item*, UintPair >::const_iterator iter = mItemPositions.begin(); 
             iter != mItemPositions.end(); iter++)
         {
             Item* item = (*iter).first;
-            pair<unsigned int, unsigned int> pos = (*iter).second;
+            UintPair pos = (*iter).second;
 
             if (pos.first <= x 
                 && pos.second <= y 
@@ -243,9 +260,9 @@
         return NULL;
     }
 
-    Ogre::Real Container::getWeight() const
+    Ogre::Real Container::getMass() const
     {
-        return mWeight + getContentWeight();
+		return Item::getMass() + getContentWeight();
     }
 
     void Container::setProperty(const Ogre::String &key, const rl::Property &value)
@@ -265,6 +282,23 @@
         {
             mVolume = value.toIntPair();
         }
+		else if (key == Container::PROPERTY_CONTENT)
+        {
+			PropertyMap contentMap = value.toMap();
+			PropertyVector objects = contentMap[Container::PROPERTY_CONTENT_OBJECTS].toArray();
+			PropertyVector positions = contentMap[Container::PROPERTY_CONTENT_POSITIONS].toArray();
+
+			for (size_t idx = 0; idx < objects.size(); ++idx)
+			{
+				Property curObjProp = objects[idx];
+				UintPair curObjPos = positions[idx].toIntPair();
+
+				Item* cur = dynamic_cast<Item*>(
+					GameObjectManager::getSingleton().createGameObjectFromProperty(curObjProp));
+
+				addItem(cur, curObjPos);				
+			}
+        }
         else
         {
             Item::setProperty(key, value);
@@ -281,6 +315,25 @@
         {
             return Property(make_pair((int)mVolume.first, (int)mVolume.second));
         }
+		else if (key == Container::PROPERTY_CONTENT)
+        {
+			PropertyVector positions;
+			PropertyVector objects;
+
+			for (ItemSet::const_iterator it = mItems.begin(); it != mItems.end(); ++it)
+			{
+				Item* cur = *it;
+				UintPair pos = getItemPosition(cur);
+				objects.push_back(GameObjectManager::getSingleton().toProperty(cur));
+				positions.push_back(Property(pos));
+			}
+
+			PropertyMap contentMap;
+			contentMap[Container::PROPERTY_CONTENT_OBJECTS] = objects;
+			contentMap[Container::PROPERTY_CONTENT_POSITIONS] = positions;
+
+			return Property(contentMap);			
+        }
         else
         {
             return Item::getProperty(key);
@@ -292,6 +345,7 @@
         PropertySet* ps = Item::getAllProperties();
         ps->setProperty(Container::PROPERTY_CAPACITY, Property(mCapacity));
         ps->setProperty(Container::PROPERTY_VOLUME, Property(make_pair((int)mVolume.first, (int)mVolume.second)));
+		ps->setProperty(Container::PROPERTY_CONTENT, getProperty(Container::PROPERTY_CONTENT));
 
         return ps;
     }

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-05-21 21:49:08 UTC (rev 3471)
@@ -37,11 +37,24 @@
 namespace rl
 {
     const Ogre::String Creature::CLASS_NAME = "Creature";
+
     const Ogre::String Creature::PROPERTY_BEHAVIOURS = "behaviours";
-    
     const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype"; 
+    const Ogre::String Creature::PROPERTY_CURRENT_LE;
+    const Ogre::String Creature::PROPERTY_CURRENT_AE;
+    const Ogre::String Creature::PROPERTY_CURRENT_AU;
+    const Ogre::String Creature::PROPERTY_CURRENT_FATIGUE;
+    const Ogre::String Creature::PROPERTY_EFFECTS;
+    const Ogre::String Creature::PROPERTY_EIGENSCHAFTEN;
+    const Ogre::String Creature::PROPERTY_TALENTE;
+    const Ogre::String Creature::PROPERTY_KAMPFTECHNIKEN;
+    const Ogre::String Creature::PROPERTY_VORTEILE;
+    const Ogre::String Creature::PROPERTY_NACHTEILE;
+    const Ogre::String Creature::PROPERTY_SF;
+    const Ogre::String Creature::PROPERTY_WERTE;
+    const Ogre::String Creature::PROPERTY_AP;
+    const Ogre::String Creature::PROPERTY_INVENTORY;
 
-
     // some targets
 	const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
 	const std::string Creature::ALL_TALENTE = "alle Talente";
@@ -67,7 +80,6 @@
 		mCurrentLe(0),
         mCurrentAu(0),
         mCurrentAe(0),
-	mActiveWeapon(NULL),
 		mInventory(NULL),
 		mEigenschaften(),
 		mWerte(),
@@ -978,6 +990,70 @@
         {
             mInventoryWindowType = value.toString().c_str();
         }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            mCurrentLe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            mCurrentAe = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            mCurrentAu = value.toInt();
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            mErschoepfung = value.toInt();
+        }
+        //else if (key == Creature::PROPERTY_EFFECTS)
+        //{
+        //    mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
+        //}
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            mEigenschaften.clear();
+            convertToMap(value.toMap(), mEigenschaften);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            mTalente.clear();
+            convertToMap(value.toMap(), mTalente);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            mKampftechniken.clear();
+            convertToMap(value.toMap(), mKampftechniken);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            mVorteile.clear();
+            convertToMap(value.toMap(), mVorteile);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            mNachteile.clear();
+            convertToMap(value.toMap(), mNachteile);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            mWerte.clear();
+            convertToMap(value.toMap(), mWerte);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            IntPair ip = value.toIntPair();
+            mAp.total = ip.first;
+            mAp.used = ip.second;
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            mInventory->setProperty(Inventory::PROPERTY_CONTENT, value);
+        }
         else
         {
             GameObject::setProperty(key, value);
@@ -994,6 +1070,68 @@
         {
             return Property(mInventoryWindowType);
         }
+        else if (key == Creature::PROPERTY_CURRENT_LE)
+        {
+            return Property(mCurrentLe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AE)
+        {
+            return Property(mCurrentAe);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_AU)
+        {
+            return Property(mCurrentAu);
+        }
+        else if (key == Creature::PROPERTY_CURRENT_FATIGUE)
+        {
+            return Property(mErschoepfung);
+        }
+        //else if (key == Creature::PROPERTY_EFFECTS)
+        //{
+        //    return Property(mEffectManager->getProperty(Creature::PROPERTY_EFFECTS));
+        //}
+        else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_TALENTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mTalente);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_KAMPFTECHNIKEN)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mKampftechniken);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_VORTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mVorteile);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_NACHTEILE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mNachteile);
+            return Property(map);
+        }
+//        else if (key == Creature::PROPERTY_SF)
+//        {
+            ///@todo Sonderfertigkeiten
+//        }
+        else if (key == Creature::PROPERTY_WERTE)
+        {
+            PropertyMap map = rl::convertToPropertyMap(mWerte);
+            return Property(map);
+        }
+        else if (key == Creature::PROPERTY_AP)
+        {
+            return Property(make_pair(mAp.total, mAp.used));
+        }
+        else if (key == Creature::PROPERTY_INVENTORY)
+        {
+            return mInventory->getProperty(Inventory::PROPERTY_CONTENT);
+        }
         else
         {
             return GameObject::getProperty(key);
@@ -1005,6 +1143,20 @@
         PropertySet* ps = GameObject::getAllProperties();
         ps->setProperty(Creature::PROPERTY_BEHAVIOURS, mBehaviours);
         ps->setProperty(Creature::PROPERTY_INVENTORY_WINDOW_TYPE, Property(mInventoryWindowType));
+        ps->setProperty(Creature::PROPERTY_CURRENT_LE, getProperty(Creature::PROPERTY_CURRENT_LE));
+        ps->setProperty(Creature::PROPERTY_CURRENT_AE, getProperty(Creature::PROPERTY_CURRENT_AE));
+        ps->setProperty(Creature::PROPERTY_CURRENT_AU, getProperty(Creature::PROPERTY_CURRENT_AU));
+        ps->setProperty(Creature::PROPERTY_CURRENT_FATIGUE, getProperty(Creature::PROPERTY_CURRENT_FATIGUE));
+        //ps->setProperty(Creature::PROPERTY_EFFECTS, getProperty(Creature::PROPERTY_EFFECTS));
+        ps->setProperty(Creature::PROPERTY_EIGENSCHAFTEN, getProperty(Creature::PROPERTY_EIGENSCHAFTEN));
+        ps->setProperty(Creature::PROPERTY_TALENTE, getProperty(Creature::PROPERTY_TALENTE));
+        ps->setProperty(Creature::PROPERTY_KAMPFTECHNIKEN, getProperty(Creature::PROPERTY_KAMPFTECHNIKEN));
+        ps->setProperty(Creature::PROPERTY_VORTEILE, getProperty(Creature::PROPERTY_VORTEILE));
+        ps->setProperty(Creature::PROPERTY_NACHTEILE, getProperty(Creature::PROPERTY_NACHTEILE));
+        //ps->setProperty(Creature::PROPERTY_SF, getProperty(Creature::PROPERTY_SF));
+        ps->setProperty(Creature::PROPERTY_WERTE, getProperty(Creature::PROPERTY_WERTE));
+        ps->setProperty(Creature::PROPERTY_AP, getProperty(Creature::PROPERTY_AP));
+        ps->setProperty(Creature::PROPERTY_INVENTORY, getProperty(Creature::PROPERTY_INVENTORY));
 
         return ps;
     }

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-05-21 21:49:08 UTC (rev 3471)
@@ -502,8 +502,8 @@
             }
             else if (key == PROPERTY_ACTIONS)
             {
-                std::vector<Property> vecVal = value.toArray();
-                for (std::vector<Property>::iterator it = vecVal.begin(); it != vecVal.end(); it++)
+                PropertyVector vecVal = value.toArray();
+                for (PropertyVector::const_iterator it = vecVal.begin(); it != vecVal.end(); it++)
                 {
                     Ogre::String actionName = (*it).toString().c_str();
                     Action* act = ActionManager::getSingleton().getAction(actionName);

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-05-21 21:49:08 UTC (rev 3471)
@@ -136,7 +136,7 @@
 
 		while (it != items.end())
 		{
-			totalWeight += (*it)->getWeight();
+			totalWeight += (*it)->getMass();
 
 			it++;
 		}

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-05-21 21:49:08 UTC (rev 3471)
@@ -31,7 +31,6 @@
 
     Item::Item(unsigned int id)
         : GameObject(id),
-		mWeight(0),
 		mItemType(ITEMTYPE_OTHER),
 		mImageName(""),
 		mSize(pair<int,int>(1,1))
@@ -43,16 +42,6 @@
     {
     }
 	
-    void Item::setWeight(Ogre::Real weight)
-    {
-        mWeight = weight;
-    }
-
-    Ogre::Real Item::getWeight() const
-    {
-        return mWeight;
-    }
-
 	void Item::setItemType(ItemType itemType)
 	{
 		mItemType = itemType;
@@ -73,16 +62,6 @@
 		return mImageName;
 	}
 
-	void Item::setPrice(int price)
-	{
-		mPrice = price;
-	}
-	
-	int Item::getPrice() const
-	{
-		return mPrice;
-	}
-
 	bool Item::isContainer() const
 	{
 		return false;

Modified: rl/trunk/engine/rules/src/Weapon.cpp
===================================================================
--- rl/trunk/engine/rules/src/Weapon.cpp	2007-05-21 21:48:14 UTC (rev 3470)
+++ rl/trunk/engine/rules/src/Weapon.cpp	2007-05-21 21:49:08 UTC (rev 3471)
@@ -22,9 +22,23 @@
 namespace rl
 {
     const Ogre::String Weapon::CLASS_NAME = "Weapon";
+    const Ogre::String Weapon::PROPERTY_TP = "TP";
+    const Ogre::String Weapon::PROPERTY_TP_KK = "TPKK";
+    const Ogre::String Weapon::PROPERTY_TP_BF = "BF";
+    const Ogre::String Weapon::PROPERTY_TP_INI = "INI";
+    const Ogre::String Weapon::PROPERTY_TP_WM = "WM";
+    const Ogre::String Weapon::PROPERTY_TP_DK = "DK";
+    const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = "KT";
 
 	Weapon::Weapon(unsigned int id)
-		: Item(id)
+		: Item(id),
+        mTp(0, 0, 0),
+		mTpKk(0, 0),
+		mBf(0),
+		mIni(0),
+		mWm(0, 0),
+        mDk(DK_H),
+        mKampftechnik("")
 	{
         mQueryFlags |= QUERYFLAG_WEAPON;
 	}
@@ -62,7 +76,7 @@
 		mBf = newBf;
 	}
 
-	int Weapon::getBf()
+	int Weapon::getBf() const
 	{
 		return mBf;
 	}
@@ -72,7 +86,7 @@
 		mIni = newIni;
 	}
 
-	int Weapon::getIni()
+	int Weapon::getIni() const
 	{
 		return mIni;
 	}
@@ -87,16 +101,21 @@
 		return mWm;
 	}
 
-	void Weapon::setDk(Weapon::Distanzklasse newDk)
+	void Weapon::setDk(int newDk)
 	{
 		mDk = newDk;
 	}
 
-	Weapon::Distanzklasse Weapon::getDk()
+	int Weapon::getDk() const
 	{
 		return mDk;
 	}
 
+    bool Weapon::hasDk(Weapon::Distanzklasse newDk) const
+    {
+        return (mDk & newDk) == newDk;
+    }
+
 	void Weapon::setKampftechnik(const CeGuiString newKampftechnik)
 	{
 		mKampftechnik = newKampftechnik;
@@ -109,36 +128,87 @@
 
     void Weapon::setProperty(const Ogre::String &key, const rl::Property &value)
     {
-        //if (key == Weapon::PROPERTY_IMAGENAME)
-        //{
-        //    mImageName = value.toString();
-        //}
-        //else
-        //{
+        if (key == Weapon::PROPERTY_TP)
+        {
+            mTp = value.toIntTriple();
+        }
+        else if (key == Weapon::PROPERTY_TP_KK)
+        {
+            mTpKk = value.toIntPair();
+        }
+        else if (key == Weapon::PROPERTY_TP_BF)
+        {
+            mBf = value.toInt();
+        }
+        else if (key == Weapon::PROPERTY_TP_INI)
+        {
+            mIni = value.toInt();
+        }
+        else if (key == Weapon::PROPERTY_TP_WM)
+        {
+            mWm = value.toIntPair();
+        }
+        else if (key == Weapon::PROPERTY_TP_DK)
+        {
+            mDk = value.toInt();
+        }
+        else if (key == Weapon::PROPERTY_TP_KAMPFTECHNIK)
+        {
+            mKampftechnik = value.toString();
+        }
+        else 
+        {
             Item::setProperty(key, value);
-        //}
+        }
     }
 
     const Property Weapon::getProperty(const Ogre::String &key) const
     {
-        //if (key == Item::PROPERTY_IMAGENAME)
-        //{
-        //    return Property(mImageName);
-        //}
-        //else
-        //{
+        if (key == Weapon::PROPERTY_TP)
+        {
+            return Property(mTp);
+        }
+        else if (key == Weapon::PROPERTY_TP_KK)
+        {
+            return Property(mTpKk);
+        }
+        else if (key == Weapon::PROPERTY_TP_BF)
+        {
+            return Property(mBf);
+        }
+        else if (key == Weapon::PROPERTY_TP_INI)
+        {
+            return Property(mIni);
+        }
+        else if (key == Weapon::PROPERTY_TP_WM)
+        {
+            return Property(mWm);
+        }
+        else if (key == Weapon::PROPERTY_TP_DK)
+        {
+            return Property(mDk);
+        }
+        else if (key == Weapon::PROPERTY_TP_KAMPFTECHNIK)
+        {
+            return Property(mKampftechnik);
+        }
+        else
+        {
             return Item::getProperty(key);
-        //}
+        }
     }
 
     PropertySet* Weapon::getAllProperties() const
     {
         PropertySet* ps = Item::getAllProperties();
-        //ps->setProperty(Item::PROPERTY_IMAGENAME, Property(mImageName));
-        //ps->setProperty(Item::PROPERTY_SIZE, Property(mSize));
+        ps->setProperty(Weapon::PROPERTY_TP, Property(mTp));
+        ps->setProperty(Weapon::PROPERTY_TP_KK, Property(mTpKk));
+        ps->setProperty(Weapon::PROPERTY_TP_BF, Property(mBf));
+        ps->setProperty(Weapon::PROPERTY_TP_INI, Property(mIni));
+        ps->setProperty(Weapon::PROPERTY_TP_WM, Property(mWm));
+        ps->setProperty(Weapon::PROPERTY_TP_DK, Property(mDk));
+        ps->setProperty(Weapon::PROPERTY_TP_KAMPFTECHNIK, Property(mKampftechnik));
 
         return ps;
     }
-
 }
-



From pnyx at mail.berlios.de  Tue May 22 11:04:43 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 22 May 2007 11:04:43 +0200
Subject: [Dsa-hl-svn] r3472 - modules/common/models
Message-ID: <200705220904.l4M94hVm008955@sheep.berlios.de>

Author: pnyx
Date: 2007-05-22 11:04:41 +0200 (Tue, 22 May 2007)
New Revision: 3472

Modified:
   modules/common/models/waf_kurzschwert_01.mesh
Log:
kurzschwert ohne Bone, Pivot am Griff

Modified: modules/common/models/waf_kurzschwert_01.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Tue May 22 11:32:19 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 22 May 2007 11:32:19 +0200
Subject: [Dsa-hl-svn] r3473 - modules/common/models
Message-ID: <200705220932.l4M9WJtE011135@sheep.berlios.de>

Author: pnyx
Date: 2007-05-22 11:32:19 +0200 (Tue, 22 May 2007)
New Revision: 3473

Modified:
   modules/common/models/waf_kurzschwert_01.mesh
Log:
changed orientation

Modified: modules/common/models/waf_kurzschwert_01.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Tue May 22 11:38:52 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 22 May 2007 11:38:52 +0200
Subject: [Dsa-hl-svn] r3474 - modules/common/models
Message-ID: <200705220938.l4M9cqef011669@sheep.berlios.de>

Author: pnyx
Date: 2007-05-22 11:38:42 +0200 (Tue, 22 May 2007)
New Revision: 3474

Modified:
   modules/common/models/waf_kurzschwert_01.mesh
Log:
Bounding Box fixed

Modified: modules/common/models/waf_kurzschwert_01.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Tue May 22 12:15:49 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 22 May 2007 12:15:49 +0200
Subject: [Dsa-hl-svn] r3475 - modules/common/models
Message-ID: <200705221015.l4MAFnPE014797@sheep.berlios.de>

Author: pnyx
Date: 2007-05-22 12:15:48 +0200 (Tue, 22 May 2007)
New Revision: 3475

Modified:
   modules/common/models/waf_kurzschwert_01.mesh
Log:
fixed orientation, yet again.. ;D

Modified: modules/common/models/waf_kurzschwert_01.mesh
===================================================================
(Binary files differ)



From timm at mail.berlios.de  Tue May 22 20:46:42 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 22 May 2007 20:46:42 +0200
Subject: [Dsa-hl-svn] r3476 - in rl/trunk/engine: ai ai/include ai/src
	script/swig
Message-ID: <200705221846.l4MIkgHq030336@sheep.berlios.de>

Author: timm
Date: 2007-05-22 20:46:26 +0200 (Tue, 22 May 2007)
New Revision: 3476

Added:
   rl/trunk/engine/ai/include/CreatureWalkPathJob.h
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/LandmarkPath.h
   rl/trunk/engine/ai/src/Landmark.cpp
   rl/trunk/engine/ai/src/LandmarkPath.cpp
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Added CreatureWalkPathJob and ruby interface for CreatureWalkPathJob. CreatureWalkPathJob is a job for letting a creature walk to Landmarks.

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-05-22 18:46:26 UTC (rev 3476)
@@ -325,6 +325,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\CreatureWalkPathJob.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\Landmark.cpp"
 				>
 			</File>
@@ -403,6 +407,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\CreatureWalkPathJob.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\FuzzyState.h"
 				>
 			</File>

Added: rl/trunk/engine/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-05-22 18:46:26 UTC (rev 3476)
@@ -0,0 +1,50 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+
+#ifndef __CreatureWalkPathJob_H__
+#define __CreatureWalkPathJob_H__
+
+#include "AiPrerequisites.h"
+
+#include "Landmark.h"
+#include "LandmarkPath.h"
+
+#include "Job.h"
+#include "MovingCreature.h"
+
+namespace rl
+{
+    class _RlAiExport CreatureWalkPathJob : public Job
+    {
+    public:
+        CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark);
+        virtual ~CreatureWalkPathJob();
+
+        void addLandmark(const Ogre::String& name, const Ogre::Vector3& position);
+        void addLandmark(Landmark* lm);
+
+        virtual bool execute(Ogre::Real time);
+    private:
+        LandmarkPath mLandmarkPath;
+        Ogre::String mName;
+        MovingCreature* mMovingCreature;
+
+        Landmark* mCurrentLandmark;
+        Landmark* mNextLandmark;
+    };
+}
+
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/ai/include/LandmarkPath.h
===================================================================
--- rl/trunk/engine/ai/include/LandmarkPath.h	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/ai/include/LandmarkPath.h	2007-05-22 18:46:26 UTC (rev 3476)
@@ -25,14 +25,17 @@
 	class _RlAiExport LandmarkPath
 	{
 	public:
+        typedef std::deque<Landmark*> LandmarkList;
+
 		LandmarkPath(const Ogre::String& name);
 		~LandmarkPath();
 
 		void addPoint(const Ogre::String& name, const Ogre::Vector3& position);
 		void addPoint(Landmark* lm);
-
+        
+        LandmarkList getPoints();
 	private:
-		std::list<Landmark*> mPoints;
+		LandmarkList mPoints;
 		Ogre::String mName;
 	};
 }

Added: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-22 18:46:26 UTC (rev 3476)
@@ -0,0 +1,67 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+
+#include "CreatureWalkPathJob.h"
+
+namespace rl
+{
+    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark) : Job(true, true), 
+        mLandmarkPath("LandmarkPath" + name)
+    {
+        mMovingCreature = movingCreature;
+        //addLandmark(startLandmark);
+        mCurrentLandmark = new Landmark(name + "_startup",mMovingCreature->getCreature()->getPosition());
+        mNextLandmark = startLandmark;
+        //mMovingCreature->getCreature()->setPosition(startLandmark->getPosition());
+    }
+
+    CreatureWalkPathJob::~CreatureWalkPathJob()
+    {
+    }
+
+    bool CreatureWalkPathJob::execute(Ogre::Real time)
+    {
+        if (mLandmarkPath.getPoints().size() > 0 && mMovingCreature->getCreature()->getPosition() == mNextLandmark->getPosition())
+        {
+            mCurrentLandmark = mNextLandmark;
+            mNextLandmark = mLandmarkPath.getPoints().front();
+            mLandmarkPath.getPoints().pop_front();
+        }
+        else if (mMovingCreature->getCreature()->getPosition() != mNextLandmark->getPosition())
+        {
+            Ogre::Vector3 creatureViewVector = mMovingCreature->getCreature()->getOrientation() * Ogre::Vector3::NEGATIVE_UNIT_Z;
+            Ogre::Vector3 diffTrack = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
+            /*if (diffTrack.dotProduct(creatureViewVector) < 0.5)
+            {
+
+            }*/
+            mMovingCreature->setMovement(MovingCreature::MT_GEHEN,diffTrack,Ogre::Vector3(0,0,0));
+            if(diffTrack.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getPosition()))
+                mMovingCreature->getCreature()->setPosition(mNextLandmark->getPosition());        
+        }
+        return false;
+    }
+
+    void CreatureWalkPathJob::addLandmark(const Ogre::String& name, const Ogre::Vector3& position)
+    {
+        mLandmarkPath.addPoint(name, position);
+    }
+
+    void CreatureWalkPathJob::addLandmark(Landmark* lm)
+    {
+        mLandmarkPath.addPoint(lm);
+    }
+}
\ No newline at end of file

Modified: rl/trunk/engine/ai/src/Landmark.cpp
===================================================================
--- rl/trunk/engine/ai/src/Landmark.cpp	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/ai/src/Landmark.cpp	2007-05-22 18:46:26 UTC (rev 3476)
@@ -21,4 +21,14 @@
 		: mName(name), mPosition(position)
 	{
 	}
+
+    const Ogre::String& Landmark::getName() const
+    {
+        return mName;
+    }
+
+    const Ogre::Vector3& Landmark::getPosition() const
+    {
+        return mPosition;
+    }
 }

Modified: rl/trunk/engine/ai/src/LandmarkPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-05-22 18:46:26 UTC (rev 3476)
@@ -38,4 +38,9 @@
 	{
 		mPoints.push_back(lm);
 	}
+
+    LandmarkPath::LandmarkList LandmarkPath::getPoints()
+    {
+        return mPoints;
+    }
 }

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-05-22 18:46:26 UTC (rev 3476)
@@ -30,4 +30,7 @@
 #include "WayPointNode.h"
 #include "WayPointGraph.h"
 #include "WayPointGraphManager.h"
+#include "Landmark.h"
+#include "LandmarkPath.h"
+#include "CreatureWalkPathJob.h"
 %}
\ No newline at end of file

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-05-22 18:46:26 UTC (rev 3476)
@@ -245,6 +245,33 @@
 		rl::WayPointGraph* createWayPointGraph();
 	};
 	
+	class Landmark
+	{
+	public:
+		Landmark(const Ogre::String& name, const Ogre::Vector3& position);
+		const Ogre::String& getName() const;
+		const Ogre::Vector3& getPosition() const;
+	};
+	
+	class LandmarkPath
+	{
+	public:
+		typedef std::deque<Landmark*> LandmarkList;
+		LandmarkPath(const Ogre::String& name);
+
+		void addPoint(const Ogre::String& name, const Ogre::Vector3& position);
+		void addPoint(Landmark* lm);
+        LandmarkList getPoints();
+	};
+	
+	class CreatureWalkPathJob : public Job
+    {
+    public:
+        CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark);
+
+        void addLandmark(const Ogre::String& name, const Ogre::Vector3& position);
+        void addLandmark(Landmark* lm);
+    };
 } // Namespace
 
 %{

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-05-22 18:46:26 UTC (rev 3476)
@@ -50,4 +50,5 @@
 #include "TimerListener.h"
 #include "Tripel.h"
 #include "Weapon.h"
+#include "MovingCreature.h"
 %}

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-05-22 10:15:48 UTC (rev 3475)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-05-22 18:46:26 UTC (rev 3476)
@@ -730,6 +730,58 @@
 
         rl::TimerEventSource* getSource() const;
     };
+    
+    class AbstractMovement;
+    class MovingCreatureManager;
+
+    class MovingCreature : public PhysicsController, PhysicsGenericContactCallback
+    {
+    public:
+        MovingCreature(Creature *character); 
+        
+        typedef enum
+        {
+            // these movements can be used
+            MT_NONE,
+            MT_STEHEN,
+            MT_GEHEN,
+            MT_JOGGEN,
+            MT_LAUFEN,
+            MT_RENNEN,
+            MT_RUECKWAERTS_GEHEN,
+            MT_RUECKWAERTS_JOGGEN,
+            MT_SEITWAERTS_GEHEN,
+            MT_SCHLEICHEN,
+            MT_HOCHSPRUNG,
+            MT_WEITSPRUNG,
+            // these movements are only for internal purposes and should not be used directly
+            // instead use one of the movements above
+            MT_DREHEN
+        } MovementType;
+        
+        typedef enum { 
+            AL_AIRBORNE,
+            AL_FLOOR
+        } AbstractLocation;
+        
+        Creature *getCreature();
+        void setAbstractLocation(AbstractLocation type);
+        AbstractLocation getAbstractLocation() const;
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        MovementType getMovementId() const;
+        Ogre::Vector3 getDirection() const;
+        Ogre::Vector3 getRotation() const;
+        AbstractMovement *getMovement();
+        AbstractMovement *getMovementFromId(MovementType id);
+        int getCurrentGS() const;
+        Ogre::Vector3 getVelocity() const;
+        Ogre::Vector3 getOmega() const;
+        void setAnimation(const Ogre::String &name, 
+                          Ogre::Real speed = 1, 
+                          unsigned int timesToPlay = 0, 
+                          const Ogre::String &collisionName = ""
+                          );
+    };
 } // Namespace
 
 %{



From timm at mail.berlios.de  Tue May 22 20:52:49 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 22 May 2007 20:52:49 +0200
Subject: [Dsa-hl-svn] r3477 - in modules/combattest: dsa scripts/maps
Message-ID: <200705221852.l4MIqndI030770@sheep.berlios.de>

Author: timm
Date: 2007-05-22 20:52:42 +0200 (Tue, 22 May 2007)
New Revision: 3477

Modified:
   modules/combattest/dsa/gameobjectdefinitions.gof
   modules/combattest/scripts/maps/combattest.rb
Log:
Added the CreatureWalkPathJob to combattest.rb

Modified: modules/combattest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/combattest/dsa/gameobjectdefinitions.gof	2007-05-22 18:46:26 UTC (rev 3476)
+++ modules/combattest/dsa/gameobjectdefinitions.gof	2007-05-22 18:52:42 UTC (rev 3477)
@@ -14,4 +14,14 @@
     	<property type="STRING" data="AvoidObstaclesBehaviour"/>
     </property>
   </gameobjectclass>
+  <gameobjectclass classid="Wolf2" baseclass="Creature">
+    <property name="classid" type="STRING" data="Wolf2"/>
+    <property name="baseclass" type="STRING" data="Creature"/>
+    <property name="name" type="STRING" data="Wolf"/>
+    <property name="description" type="STRING" data="Ein gef?hrlicher, ganz gef?hrlicher, wirklich extrem gef?hrlicher Wolf. Aber er hat ein schwaches Herz."/>
+    <property name="description_dead" type="STRING" data="Ein sehr toter Wolf"/>
+    <property name="meshfile" type="STRING" data="tie_wolf_01.mesh"/>
+    <property name="mass" type="REAL" data="30"/>
+    <property name="geometrytype" type="STRING" data="sphere"/>
+  </gameobjectclass>
 </GameObjectDefinitions>

Modified: modules/combattest/scripts/maps/combattest.rb
===================================================================
--- modules/combattest/scripts/maps/combattest.rb	2007-05-22 18:46:26 UTC (rev 3476)
+++ modules/combattest/scripts/maps/combattest.rb	2007-05-22 18:52:42 UTC (rev 3477)
@@ -1,3 +1,5 @@
+load 'embed.rb'
+
 require 'player.rb'
 require 'hero.rb'
 
@@ -24,5 +26,14 @@
 wolf.setPosition [0.0,0.0,-5.0]
 wolf.setAlignment(Creature::ALIGNMENT_ENEMY)
 
+wolf2 = $GOM.createGameObject("Wolf2")
+wolf2.placeIntoScene
+wolf2.setPosition [0.0,0.0,-3.0]
+wolf2.setAlignment(Creature::ALIGNMENT_ENEMY)
+
+_movingCreature = MovingCreature.new(wolf2)
+
+_job = CreatureWalkPathJob.new("TestWalkJob", _movingCreature, Landmark.new("point", [2.0, 0.0, -10.0]))
+
 $SCRIPT.log("map 'combattest' initialisiert.")
 



From timm at mail.berlios.de  Tue May 22 21:10:37 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 22 May 2007 21:10:37 +0200
Subject: [Dsa-hl-svn] r3478 - in rl/trunk/engine/ai: include src
Message-ID: <200705221910.l4MJAbj7032126@sheep.berlios.de>

Author: timm
Date: 2007-05-22 21:10:27 +0200 (Tue, 22 May 2007)
New Revision: 3478

Modified:
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/src/Makefile.am
Log:
Makefiles updated for CreatureWalkPathJob

CreatureWalkPathJob IS STILL UNCOMPLETE, it won't work

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-05-22 18:52:42 UTC (rev 3477)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-05-22 19:10:27 UTC (rev 3478)
@@ -9,6 +9,7 @@
 	AStarHeuristic.h \
 	AStarNodePool.h \
 	AStarWayPointNode.h \
+	CreatureWalkPathJob.h \
 	FuzzyState.h \
 	FuzzyStateMachine.h \
 	Landmark.h \

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-05-22 18:52:42 UTC (rev 3477)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-05-22 19:10:27 UTC (rev 3478)
@@ -13,6 +13,7 @@
 	AStarHeuristic.cpp \
 	AStarNodePool.cpp \
 	AStarWayPointNode.cpp \
+	CreatureWalkPathJob.cpp \
 	FuzzyState.cpp \
 	FuzzyStateMachine.cpp \
 	Landmark.cpp \



From melven at mail.berlios.de  Tue May 22 21:42:00 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 22 May 2007 21:42:00 +0200
Subject: [Dsa-hl-svn] r3479 - in rl/trunk/engine/rules: include src
Message-ID: <200705221942.l4MJg02u001473@sheep.berlios.de>

Author: melven
Date: 2007-05-22 21:41:53 +0200 (Tue, 22 May 2007)
New Revision: 3479

Modified:
   rl/trunk/engine/rules/include/MovingCreature.h
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
removed programming error (wrong pointer after the end of dialogcharactercontroller)

Modified: rl/trunk/engine/rules/include/MovingCreature.h
===================================================================
--- rl/trunk/engine/rules/include/MovingCreature.h	2007-05-22 19:10:27 UTC (rev 3478)
+++ rl/trunk/engine/rules/include/MovingCreature.h	2007-05-22 19:41:53 UTC (rev 3479)
@@ -143,7 +143,6 @@
         Creature *mCreature;
         AbstractLocation mAbstractLocation;
         
-        
         AbstractMovement *mMovement;
         Ogre::Vector3 mDirection;
         Ogre::Vector3 mRotation;
@@ -153,6 +152,16 @@
 
         // in order to copy the contactcallback members correctly;
         friend class MovingCreatureManager;
+
+    private:
+        // only used in setAnimation
+        Ogre::String mLastAnimationName;
+        Ogre::String mLastCollisionName;
+        Ogre::Real mLastAnimationSpeed;
+
+        // only used in userProcess
+        Ogre::Real mLastFloorContact;
+
     };
 
     /// this is the base class of all movements

Modified: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-22 19:10:27 UTC (rev 3478)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-05-22 19:41:53 UTC (rev 3479)
@@ -36,7 +36,7 @@
     class Stehen : public AbstractMovement
     {
     public:
-        Stehen(MovingCreature *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO) {}
+        Stehen(MovingCreature *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO), mRotationMovement(NULL) {}
         virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_STEHEN;}
         virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
         virtual void activate()
@@ -117,19 +117,18 @@
         }
     protected:
         Ogre::Vector3 mVelocity;
+        mutable AbstractMovement *mRotationMovement;
         virtual AbstractMovement* getRotationMovement() const
         {
-            static AbstractMovement *stehen_drehen(NULL);
-
-            if( stehen_drehen == NULL)
+            if( mRotationMovement == NULL)
             {                
-                stehen_drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+                mRotationMovement = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
             }
-            if( stehen_drehen == NULL )
+            if( mRotationMovement == NULL )
             {
                 Throw(NullPointerException, "Konnte Movement mit der Id MT_STEHEN_DREHEN nicht finden.");
             }
-            return stehen_drehen;
+            return mRotationMovement;
         }
     };
 
@@ -917,7 +916,11 @@
         mAbstractLocation(AL_AIRBORNE),
         mMovement(NULL),
         mDirection(Vector3::ZERO),
-        mRotation(Vector3::ZERO)
+        mRotation(Vector3::ZERO),
+        mLastAnimationName(""),
+        mLastCollisionName(""),
+        mLastAnimationSpeed(1),
+        mLastFloorContact(0)
     {
         MovingCreatureManager::getSingleton().add(this);
         
@@ -999,37 +1002,34 @@
 
     void MovingCreature::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName)
     {
-        static Ogre::String lastName("");
-        static Ogre::String lastCollisionName("");
-        static Real lastSpeed(1);
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
         PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
         
-        if( lastName != name)
+        if( mLastAnimationName != name)
         {
             const Ogre::String *pCollisionName = &collisionName;
             if( collisionName == "" )
                 pCollisionName = &name;
 
-            if( *pCollisionName != lastCollisionName )
+            if( *pCollisionName != mLastCollisionName )
             {
                 pt->fitToPose(*pCollisionName);
-                lastCollisionName = *pCollisionName;
+                mLastCollisionName = *pCollisionName;
             }
             mesh->stopAllAnimations();
 
 
             mesh->startAnimation(name, speed, timesToPlay);
-            lastName = name;
-            lastSpeed = speed;
+            mLastAnimationName = name;
+            mLastAnimationSpeed = speed;
         }
         else
         {
-            if( lastSpeed != speed )
+            if( mLastAnimationSpeed != speed )
             {
                 MeshAnimation *meshAnim = mesh->getAnimation(name);
                 meshAnim->setSpeed(speed);
-                lastSpeed = speed;
+                mLastAnimationSpeed = speed;
             }
         }
     }
@@ -1115,19 +1115,18 @@
         if( stepHeight < 0.5f )
             isFloorCollision = true;
 
-        static Real lastFloorContact(0.0f);
         if ( isFloorCollision )
         {
             setAbstractLocation(AL_FLOOR);
             if(stepHeight > 0.1f)
                 setContactNormalAcceleration(10);
             setContactElasticity(0.0f);
-            lastFloorContact = 0.0f;
+            mLastFloorContact = 0.0f;
         }
         else
         {
-            lastFloorContact += PhysicsManager::getSingleton()._getNewtonWorld()->getTimeStep();
-            if(lastFloorContact >= 2.2f || getAbstractLocation() == AL_AIRBORNE)
+            mLastFloorContact += PhysicsManager::getSingleton()._getNewtonWorld()->getTimeStep();
+            if(mLastFloorContact >= 2.2f || getAbstractLocation() == AL_AIRBORNE)
                 setAbstractLocation(AL_AIRBORNE);
         }
 



From blakharaz at mail.berlios.de  Tue May 22 21:57:21 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 22 May 2007 21:57:21 +0200
Subject: [Dsa-hl-svn] r3480 - rl/trunk/engine/common/include
Message-ID: <200705221957.l4MJvLZt002762@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-22 21:57:19 +0200 (Tue, 22 May 2007)
New Revision: 3480

Modified:
   rl/trunk/engine/common/include/Property.h
Log:
Fix GCC build


Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2007-05-22 19:41:53 UTC (rev 3479)
+++ rl/trunk/engine/common/include/Property.h	2007-05-22 19:57:19 UTC (rev 3480)
@@ -71,13 +71,44 @@
 
 	class Property;
 
-	typedef std::vector<Property> PropertyVector;
-	typedef std::map<CeGuiString, Property> PropertyMap;
+    typedef std::vector<Property> PropertyVector;
+    typedef std::map<CeGuiString, Property> PropertyMap;
+    
+    class _RlCommonExport Property
+    {
+    public:
+		Property();
 
-    template<typename T> PropertyMap convertToPropertyMap(const std::map<const CeGuiString, typename T>& input)
+        PropertyMethod(Bool, const bool&);
+        PropertyMethod(String, const CeGuiString&);
+        PropertyMethod(Int, const int&);
+        PropertyMethod(Real, const Ogre::Real&);
+        PropertyMethod(Vector3, const Ogre::Vector3&);
+        PropertyMethod(Quaternion, const Ogre::Quaternion&);
+        PropertyMethod(IntTriple, const Tripel<int>);
+        PropertyMethod(IntPair, const IntPair);
+		PropertyMethod(Array, const PropertyVector);
+		PropertyMethod(Map, const PropertyMap);
+
+    private:
+        boost::any mValue;
+    };
+
+    class _RlCommonExport PropertyPtr :
+        public Ogre::SharedPtr<Property>
     {
+    public:
+        PropertyPtr() : Ogre::SharedPtr<Property>() {}
+        explicit PropertyPtr(Property* rep) : Ogre::SharedPtr<Property>(rep) {}
+        PropertyPtr(const PropertyPtr& res) : Ogre::SharedPtr<Property>(res) {}
+    protected:
+        void destroy() { Ogre::SharedPtr<Property>::destroy(); }
+    };
+
+    template<typename T> PropertyMap convertToPropertyMap(const std::map<const CeGuiString, T>& input)
+    {
         PropertyMap map;
-        for (std::map<const CeGuiString, typename T>::const_iterator it =
+        for (typename std::map<const CeGuiString, T>::const_iterator it =
             input.begin(); it != input.end(); ++it)
         {
             map[it->first] = Property(it->second);
@@ -85,10 +116,10 @@
         return map;
     }
 
-    template<typename T> PropertyMap convertToPropertyMap(const std::map<const Ogre::String, typename T>& input)
+    template<typename T> PropertyMap convertToPropertyMap(const std::map<const Ogre::String, T>& input)
     {
         PropertyMap map;
-        for (std::map<const Ogre::String, typename T>::const_iterator it =
+        for (typename std::map<const Ogre::String, T>::const_iterator it =
             input.begin(); it != input.end(); ++it)
         {
             map[it->first] = Property(it->second);
@@ -97,7 +128,7 @@
     }
 
     template<typename T> void convertToMap(
-        const PropertyMap& propmap, std::map<const Ogre::String, typename T>& output)
+        const PropertyMap& propmap, std::map<const Ogre::String, T>& output)
     {
         for (PropertyMap::const_iterator it = propmap.begin(); it != propmap.end(); ++it)
         {
@@ -106,7 +137,7 @@
     }
     
     template<typename T> void convertToMap(
-        const PropertyMap& propmap, std::map<const CeGuiString, typename T>& output)
+        const PropertyMap& propmap, std::map<const CeGuiString, T>& output)
     {
         for (PropertyMap::const_iterator it = propmap.begin(); it != propmap.end(); ++it)
         {
@@ -115,37 +146,6 @@
     }
     
 
-    class _RlCommonExport Property
-    {
-    public:
-		Property();
-
-        PropertyMethod(Bool, const bool&);
-        PropertyMethod(String, const CeGuiString&);
-        PropertyMethod(Int, const int&);
-        PropertyMethod(Real, const Ogre::Real&);
-        PropertyMethod(Vector3, const Ogre::Vector3&);
-        PropertyMethod(Quaternion, const Ogre::Quaternion&);
-        PropertyMethod(IntTriple, const Tripel<int>);
-        PropertyMethod(IntPair, const IntPair);
-		PropertyMethod(Array, const PropertyVector);
-		PropertyMethod(Map, const PropertyMap);
-
-    private:
-        boost::any mValue;
-    };
-
-    class _RlCommonExport PropertyPtr :
-        public Ogre::SharedPtr<Property>
-    {
-    public:
-        PropertyPtr() : Ogre::SharedPtr<Property>() {}
-        explicit PropertyPtr(Property* rep) : Ogre::SharedPtr<Property>(rep) {}
-        PropertyPtr(const PropertyPtr& res) : Ogre::SharedPtr<Property>(res) {}
-    protected:
-        void destroy() { Ogre::SharedPtr<Property>::destroy(); }
-    };
-
 } // namespace rl
 
 #endif //__Property_H__



From pnyx at mail.berlios.de  Wed May 23 13:57:42 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 23 May 2007 13:57:42 +0200
Subject: [Dsa-hl-svn] r3481 - modules/common/materials/programs
Message-ID: <200705231157.l4NBvg8e026951@sheep.berlios.de>

Author: pnyx
Date: 2007-05-23 13:57:37 +0200 (Wed, 23 May 2007)
New Revision: 3481

Added:
   modules/common/materials/programs/TerrainVColorBlending.material
   modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source
   modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
Log:
TeTerrain VertexColor shader added

Added: modules/common/materials/programs/TerrainVColorBlending.material
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending.material	2007-05-22 19:57:19 UTC (rev 3480)
+++ modules/common/materials/programs/TerrainVColorBlending.material	2007-05-23 11:57:37 UTC (rev 3481)
@@ -0,0 +1,108 @@
+
+//DirectX 9.0 HLSL Vertex Shader vs_2_0
+vertex_program TerrainVColorBlending_Vertex_Shader hlsl
+{
+	source TerrainVColorBlending_Vertex_Shader.program.source
+	target vs_2_0
+	entry_point vs_main
+}
+
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program TerrainVColorBlending_Pixel_Shader hlsl
+{
+	source TerrainVColorBlending_Pixel_Shader.program.source
+	target ps_2_0
+	entry_point ps_main
+}
+
+
+material TerrainVColorBlending
+{
+	technique
+	{
+
+		pass
+		{
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref TerrainVColorBlending_Pixel_Shader
+			{
+
+				param_named scale_Detail4 float 0.050000 // Alpha
+			}
+			
+			
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref TerrainVColorBlending_Vertex_Shader
+			{
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named Light_Ambient float4 0.000000 0.000000 0.000000 1.000000
+				
+				//Lights:
+				param_named_auto Light_Attenuation0 light_attenuation 0
+				param_named_auto Light_Attenuation1 light_attenuation 1
+				
+				param_named_auto Light_Color0  light_diffuse_colour 0
+				param_named_auto Light_Color1  light_diffuse_colour 1
+				
+				param_named_auto Light_Position0 light_position 0
+				param_named_auto Light_Position1 light_position 1
+
+				
+				
+				
+				
+				param_named scale_Texture0 float 0.018000 // Schwarz
+				param_named scale_Detail0 float 0.020000
+
+				param_named scale_Texture1 float 0.007000 // Rot
+				param_named scale_Detail1 float 0.020000
+
+				param_named scale_Texture2 float 0.008500 // Gruen
+				param_named scale_Detail2 float 0.060000
+
+				param_named scale_Texture3 float 0.008000 // Blau
+				param_named scale_Detail3 float 0.050000
+
+				param_named scale_Texture4 float 0.016000 // Alpha 
+														  // fuer scale_Detail4 siehe Oben (Pixelshader)
+								
+			}
+			//Texture Schwarz
+			texture_unit
+			{
+				texture_alias black
+				texture nat_felsen_01.dds 2d
+			}
+			//Texture Rot
+			texture_unit
+			{
+				texture_alias red
+				texture nat_gras_01.dds 2d
+			}
+			//Texture Gruen
+			texture_unit
+			{
+				texture_alias green
+				texture nat_steingrund_01.dds 2d
+			}
+			//Texture Blau
+			texture_unit
+			{
+				texture_alias blue
+				texture nat_erdboden_01.dds 2d
+			}
+			//Texture Alpha
+			texture_unit
+			{
+				texture_alias alpha
+				texture Tiles.dds 2d
+			}
+			//Lightingmap
+			texture_unit
+			{
+				texture_alias Lightingmap
+				texture Lightingmap2.png 2d
+			}
+		}
+	}
+}

Added: modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source	2007-05-22 19:57:19 UTC (rev 3480)
+++ modules/common/materials/programs/TerrainVColorBlending_Pixel_Shader.program.source	2007-05-23 11:57:37 UTC (rev 3481)
@@ -0,0 +1,36 @@
+uniform sampler Texture0;
+uniform sampler Texture1;
+uniform sampler Texture2;
+uniform sampler Texture3;
+uniform sampler Texture4;
+uniform sampler Texture5;
+
+uniform float scale_Detail4;
+
+float4 ps_main(float4 Color: COLOR0,
+               float4 UV0 : TEXCOORD0,
+               float4 UV1 : TEXCOORD1,
+               float4 UV2 : TEXCOORD2,
+               float4 UV3 : TEXCOORD3,
+               float4 UV4 : TEXCOORD4,
+               float4 Light:COLOR1) : COLOR0
+{   
+   
+///*   
+
+
+   
+   float4 TexColor = float4(tex2D(Texture0,UV0.xy).rgb,tex2D(Texture0,UV0.zw).a);
+   TexColor = lerp(TexColor,float4(tex2D(Texture1,UV1.xy).rgb,tex2D(Texture1,UV1.zw).a),Color.r);
+   TexColor = lerp(TexColor,float4(tex2D(Texture2,UV2.xy).rgb,tex2D(Texture2,UV2.zw).a),Color.g);
+   TexColor = lerp(TexColor,float4(tex2D(Texture3,UV3.xy).rgb,tex2D(Texture3,UV3.zw).a),Color.b);
+   TexColor = lerp(float4(tex2D(Texture4,UV4.xy).rgb,tex2D(Texture4,UV4.zw * scale_Detail4).a),TexColor,Color.a);
+   
+
+  return TexColor * (TexColor.a+ 0.5) * (tex2D(Texture5,UV4.zw) + Light);
+  //return float4(Color.aaaa);
+
+}
+
+
+

Added: modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-05-22 19:57:19 UTC (rev 3480)
+++ modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-05-23 11:57:37 UTC (rev 3481)
@@ -0,0 +1,85 @@
+float4x4 matViewProjection;
+
+uniform float scale_Texture0;
+uniform float scale_Texture1;
+uniform float scale_Texture2;
+uniform float scale_Texture3;
+uniform float scale_Texture4;
+
+uniform float scale_Detail0;
+uniform float scale_Detail1;
+uniform float scale_Detail2;
+uniform float scale_Detail3;
+
+uniform float4 Light_Ambient;
+uniform float4 Light_Color0;
+uniform float4 Light_Position0;
+uniform float4 Light_Attenuation0;
+
+uniform float4 Light_Color1;
+uniform float4 Light_Position1;
+uniform float4 Light_Attenuation1;
+
+
+struct VS_OUTPUT 
+{
+   float4 Position : POSITION0;
+   float4 Color:   COLOR0;
+   float4 UV0 : TEXCOORD0;
+   float4 UV1 : TEXCOORD1;
+   float4 UV2 : TEXCOORD2;
+   float4 UV3 : TEXCOORD3;
+   float4 UV4 : TEXCOORD4;
+   float4 Light: COLOR1;
+};
+
+VS_OUTPUT vs_main( float4 Position : POSITION0,
+                   float4 Color:COLOR0,
+                   float2 UV:TEXCOORD0,
+                   float3 Normal: NORMAL)
+{
+   VS_OUTPUT Output;
+   UV = Position.xz /4;
+   
+   Output.UV0 = float4(UV*scale_Texture0,UV*scale_Detail0);
+   Output.UV1 = float4(UV*scale_Texture1,UV*scale_Detail1);
+   Output.UV2 = float4(UV*scale_Texture2,UV*scale_Detail2);
+   Output.UV3 = float4(UV*scale_Texture3,UV*scale_Detail3);
+   Output.UV4 = float4(UV*scale_Texture4,UV);
+   
+   
+   Output.Position = mul( matViewProjection, Position );
+   
+   Output.Color = Color;
+   
+   // ######## Light 0 #########
+   float3 LightDir0 = Light_Position0 - Position * Light_Position0.w;
+   float Dist0 = length(LightDir0);
+   LightDir0 /= Dist0;
+   
+   float DistAttn0 = saturate(1/(Light_Attenuation0.y +
+                                Light_Attenuation0.z * Dist0 +
+                                Light_Attenuation0.w * Dist0 * Dist0));
+   float AngleAttn0= saturate(dot(Normal,LightDir0));
+   
+   
+   // ######## Light 1 #########
+   float3 LightDir1 = Light_Position1 - Position * Light_Position1.w;
+   float Dist1 = length(LightDir1);
+   LightDir1 /= Dist1;
+   
+   float DistAttn1 = saturate(1/(Light_Attenuation1.y +
+                                Light_Attenuation1.z * Dist0 +
+                                Light_Attenuation1.w * Dist1 * Dist1));
+   float AngleAttn1= saturate(dot(Normal,LightDir1));
+   
+   
+   // Light Output
+   Output.Light = (Light_Ambient-0.5 + ((Light_Color0 * DistAttn0 * AngleAttn0) + (Light_Color1 * DistAttn1 * AngleAttn1))*1.25);
+   
+   return( Output );
+   
+}
+
+
+



From pnyx at mail.berlios.de  Wed May 23 14:03:11 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 23 May 2007 14:03:11 +0200
Subject: [Dsa-hl-svn] r3482 - modules/common/materials/programs
Message-ID: <200705231203.l4NC3B2K028028@sheep.berlios.de>

Author: pnyx
Date: 2007-05-23 14:03:09 +0200 (Wed, 23 May 2007)
New Revision: 3482

Modified:
   modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
Log:
copy'n'paste fehler behoben

Modified: modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-05-23 11:57:37 UTC (rev 3481)
+++ modules/common/materials/programs/TerrainVColorBlending_Vertex_Shader.program.source	2007-05-23 12:03:09 UTC (rev 3482)
@@ -69,7 +69,7 @@
    LightDir1 /= Dist1;
    
    float DistAttn1 = saturate(1/(Light_Attenuation1.y +
-                                Light_Attenuation1.z * Dist0 +
+                                Light_Attenuation1.z * Dist1 +
                                 Light_Attenuation1.w * Dist1 * Dist1));
    float AngleAttn1= saturate(dot(Normal,LightDir1));
    



From blakharaz at mail.berlios.de  Fri May 25 07:48:09 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 25 May 2007 07:48:09 +0200
Subject: [Dsa-hl-svn] r3483 - in rl/trunk/engine: common/include common/src
	core/src script/swig
Message-ID: <200705250548.l4P5m9CG002706@sheep.berlios.de>

Author: blakharaz
Date: 2007-05-25 07:48:04 +0200 (Fri, 25 May 2007)
New Revision: 3483

Modified:
   rl/trunk/engine/common/include/XmlResource.h
   rl/trunk/engine/common/src/XmlResource.cpp
   rl/trunk/engine/core/src/MeshObject.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlUi.swig
Log:
Removed unnecessary reinterpret_cast

Modified: rl/trunk/engine/common/include/XmlResource.h
===================================================================
--- rl/trunk/engine/common/include/XmlResource.h	2007-05-23 12:03:09 UTC (rev 3482)
+++ rl/trunk/engine/common/include/XmlResource.h	2007-05-25 05:48:04 UTC (rev 3483)
@@ -54,7 +54,7 @@
 
     private:
         XERCES_CPP_NAMESPACE::MemBufInputSource* mXmlBuffer;
-        char* mCharBuffer;
+        XMLByte* mCharBuffer;
     };
 
     class _RlCommonExport XmlPtr :

Modified: rl/trunk/engine/common/src/XmlResource.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlResource.cpp	2007-05-23 12:03:09 UTC (rev 3482)
+++ rl/trunk/engine/common/src/XmlResource.cpp	2007-05-25 05:48:04 UTC (rev 3483)
@@ -44,10 +44,11 @@
 	DataStreamPtr ds = Ogre::ResourceGroupManager::getSingleton().openResource(mName, mGroup);
 	mSize = ds->size();
 	
-	mCharBuffer = new char[mSize];
+	mCharBuffer = new XMLByte[mSize];
 	ds->read(mCharBuffer, mSize);
 
-	mXmlBuffer = new MemBufInputSource(reinterpret_cast<XMLByte*>(mCharBuffer),
+	mXmlBuffer = new MemBufInputSource(
+        mCharBuffer,
 	    static_cast<const unsigned int>(mSize), "rl::XmlResourceManager");
 }
 

Modified: rl/trunk/engine/core/src/MeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MeshObject.cpp	2007-05-23 12:03:09 UTC (rev 3482)
+++ rl/trunk/engine/core/src/MeshObject.cpp	2007-05-25 05:48:04 UTC (rev 3483)
@@ -67,7 +67,7 @@
 
     Entity* MeshObject::getEntity() const
     {
-        return reinterpret_cast<Entity*>(mMovableObject);
+        return static_cast<Entity*>(mMovableObject);
     }
 
     AxisAlignedBox MeshObject::getDefaultSize() const

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-05-23 12:03:09 UTC (rev 3482)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-05-25 05:48:04 UTC (rev 3483)
@@ -245,12 +245,12 @@
 		rl::WayPointGraph* createWayPointGraph();
 	};
 	
-	class Landmark
-	{
-	public:
-		Landmark(const Ogre::String& name, const Ogre::Vector3& position);
-		const Ogre::String& getName() const;
-		const Ogre::Vector3& getPosition() const;
+	class Landmark
+	{
+	public:
+		Landmark(const Ogre::String& name, const Ogre::Vector3& position);
+		const Ogre::String& getName() const;
+		const Ogre::Vector3& getPosition() const;
 	};
 	
 	class LandmarkPath
@@ -280,27 +280,27 @@
     rl::AStarHeuristic **ppAStarHeuristic = reinterpret_cast<rl::AStarHeuristic**>(ptr);
 
     rl::ManhattanDistance *pManhattanDistance=dynamic_cast<rl::ManhattanDistance*>(*ppAStarHeuristic);
-    if( pManhattanDistance )
+    if (pManhattanDistance)
     {
-        *ptr=reinterpret_cast<void*>(pManhattanDistance);
+        *ptr=pManhattanDistance;
         return SWIGTYPE_p_rl__ManhattanDistance;
     }
     rl::DiagonalDistance *pDiagonalDistance=dynamic_cast<rl::DiagonalDistance*>(*ppAStarHeuristic);
-    if( pDiagonalDistance )
+    if (pDiagonalDistance)
     {
-        *ptr=reinterpret_cast<void*>(pDiagonalDistance);
+        *ptr=pDiagonalDistance;
         return SWIGTYPE_p_rl__DiagonalDistance;
     }
     rl::EuclideanDistance *pEuclideanDistance=dynamic_cast<rl::EuclideanDistance*>(*ppAStarHeuristic);
-    if( pEuclideanDistance )
+    if (pEuclideanDistance)
     {
-        *ptr=reinterpret_cast<void*>(pEuclideanDistance);
+        *ptr=pEuclideanDistance;
         return SWIGTYPE_p_rl__EuclideanDistance;
     }
     rl::EuclideanDistanceSquared *pEuclideanDistanceSquared=dynamic_cast<rl::EuclideanDistanceSquared*>(*ppAStarHeuristic);
-    if( pEuclideanDistanceSquared )
+    if (pEuclideanDistanceSquared)
     {
-        *ptr=reinterpret_cast<void*>(pEuclideanDistanceSquared);
+        *ptr=pEuclideanDistanceSquared;
         return SWIGTYPE_p_rl__EuclideanDistanceSquared;
     }
    
@@ -316,9 +316,9 @@
     rl::AStarCosts **ppAStarCosts = reinterpret_cast<rl::AStarCosts**>(ptr);
 
     rl::AStarCostsDefault *pAStarCostsDefault=dynamic_cast<rl::AStarCostsDefault*>(*ppAStarCosts);
-    if( pAStarCostsDefault )
+    if (pAStarCostsDefault)
     {
-        *ptr=reinterpret_cast<void*>(pAStarCostsDefault);
+        *ptr=pAStarCostsDefault;
         return SWIGTYPE_p_rl__AStarCostsDefault;
     }
    

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-05-23 12:03:09 UTC (rev 3482)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-05-25 05:48:04 UTC (rev 3483)
@@ -20,8 +20,8 @@
     rl::GameAreaType **ppGameAreaType = reinterpret_cast<rl::GameAreaType **>(ptr);
     
     rl::GameSphereAreaType *pGameSphereAreaType = dynamic_cast<rl::GameSphereAreaType*>(*ppGameAreaType);
-    if(pGameSphereAreaType){
-      *ptr=reinterpret_cast<void*>(pGameSphereAreaType);
+    if (pGameSphereAreaType){
+      *ptr=pGameSphereAreaType;
       return SWIGTYPE_p_rl__GameSphereAreaType;
     }    
     
@@ -37,18 +37,18 @@
     rl::BaseAnimation **ppBaseAnimation = reinterpret_cast<rl::BaseAnimation **>(ptr);
     
     rl::FadeAnimation *pFadeAnimation = dynamic_cast<rl::FadeAnimation*>(*ppBaseAnimation);
-    if(pFadeAnimation){
-      *ptr=reinterpret_cast<void*>(pFadeAnimation);
+    if (pFadeAnimation){
+      *ptr=pFadeAnimation;
       return SWIGTYPE_p_rl__FadeAnimation;
     }    
     rl::MeshAnimation *pMeshAnimation = dynamic_cast<rl::MeshAnimation*>(*ppBaseAnimation);
-    if(pMeshAnimation){
-      *ptr=reinterpret_cast<void*>(pMeshAnimation);
+    if (pMeshAnimation){
+      *ptr=pMeshAnimation;
       return SWIGTYPE_p_rl__MeshAnimation;
     }    
     rl::TrackAnimation *pTrackAnimation = dynamic_cast<rl::TrackAnimation*>(*ppBaseAnimation);
-    if(pTrackAnimation){
-      *ptr=reinterpret_cast<void*>(pTrackAnimation);
+    if (pTrackAnimation){
+      *ptr=pTrackAnimation;
       return SWIGTYPE_p_rl__TrackAnimation;
     }  
     
@@ -66,32 +66,32 @@
 
     rl::MergeableMeshObject *pMergeableMeshObject=dynamic_cast<rl::MergeableMeshObject*>(*ppActorControlledObject);
     if (pMergeableMeshObject) {
-        *ptr=reinterpret_cast<void*>(pMergeableMeshObject);
+        *ptr=pMergeableMeshObject;
         return SWIGTYPE_p_rl__MergeableMeshObject;
     }
     rl::MeshObject *pMeshObject=dynamic_cast<rl::MeshObject*>(*ppActorControlledObject);
     if (pMeshObject) {
-        *ptr=reinterpret_cast<void*>(pMeshObject);
+        *ptr=pMeshObject;
         return SWIGTYPE_p_rl__MeshObject;
     }
     rl::CameraObject *pCameraObject=dynamic_cast<rl::CameraObject*>(*ppActorControlledObject);
     if (pCameraObject) {
-        *ptr=reinterpret_cast<void*>(pCameraObject);
+        *ptr=pCameraObject;
         return SWIGTYPE_p_rl__CameraObject;
     }
     rl::LightObject *pLightObject=dynamic_cast<rl::LightObject*>(*ppActorControlledObject);
     if (pLightObject) {
-        *ptr=reinterpret_cast<void*>(pLightObject);
+        *ptr=pLightObject;
         return SWIGTYPE_p_rl__LightObject;
     }
     rl::ParticleSystemObject *pParticleSystemObject=dynamic_cast<rl::ParticleSystemObject*>(*ppActorControlledObject);
     if (pParticleSystemObject) {
-        *ptr=reinterpret_cast<void*>(pParticleSystemObject);
+        *ptr=pParticleSystemObject;
         return SWIGTYPE_p_rl__ParticleSystemObject;
     }
     rl::SoundObject *pSoundObject=dynamic_cast<rl::SoundObject*>(*ppActorControlledObject);
     if (pSoundObject) {
-        *ptr=reinterpret_cast<void*>(pSoundObject);
+        *ptr=pSoundObject;
         return SWIGTYPE_p_rl__SoundObject;
     }
     return 0;
@@ -105,18 +105,18 @@
       
     
     rl::PlayAnimationJob *pPlayAnimationJob = dynamic_cast<rl::PlayAnimationJob*>(*ppJob);
-    if(pPlayAnimationJob){
-      *ptr=reinterpret_cast<void*>(pPlayAnimationJob);
+    if (pPlayAnimationJob){
+      *ptr=pPlayAnimationJob;
       return SWIGTYPE_p_rl__PlayAnimationJob;
     }    
     rl::PlaySound3dJob *pPlaySound3dJob = dynamic_cast<rl::PlaySound3dJob*>(*ppJob);
-    if(pPlaySound3dJob){
-      *ptr=reinterpret_cast<void*>(pPlaySound3dJob);
+    if (pPlaySound3dJob){
+      *ptr=pPlaySound3dJob;
       return SWIGTYPE_p_rl__PlaySound3dJob;
     }    
     rl::PlaySound2dJob *pPlaySound2dJob = dynamic_cast<rl::PlaySound2dJob*>(*ppJob);
-    if(pPlaySound2dJob){
-      *ptr=reinterpret_cast<void*>(pPlaySound2dJob);
+    if (pPlaySound2dJob){
+      *ptr=pPlaySound2dJob;
       return SWIGTYPE_p_rl__PlaySound2dJob;
     }  
     

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-05-23 12:03:09 UTC (rev 3482)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-05-25 05:48:04 UTC (rev 3483)
@@ -779,8 +779,7 @@
         void setAnimation(const Ogre::String &name, 
                           Ogre::Real speed = 1, 
                           unsigned int timesToPlay = 0, 
-                          const Ogre::String &collisionName = ""
-                          );
+                          const Ogre::String &collisionName = "");
     };
 } // Namespace
 
@@ -791,32 +790,32 @@
 
     rl::Person *pPerson=dynamic_cast<rl::Person*>(*ppGameObject);
     if (pPerson) {
-        *ptr=reinterpret_cast<void*>(pPerson);
+        *ptr=pPerson;
         return SWIGTYPE_p_rl__Person;
     }
     rl::Creature *pCreature=dynamic_cast<rl::Creature*>(*ppGameObject);
     if (pCreature) {
-        *ptr=reinterpret_cast<void*>(pCreature);
+        *ptr=pCreature;
         return SWIGTYPE_p_rl__Creature;
     }
     rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(*ppGameObject);
     if (pWeapon) {
-        *ptr=reinterpret_cast<void*>(pWeapon);
+        *ptr=pWeapon;
         return SWIGTYPE_p_rl__Weapon;
     }
     rl::Armor *pArmor=dynamic_cast<rl::Armor*>(*ppGameObject);
     if (pArmor) {
-        *ptr=reinterpret_cast<void*>(pArmor);
+        *ptr=pArmor;
         return SWIGTYPE_p_rl__Armor;
     }
     rl::Container *pContainer=dynamic_cast<rl::Container*>(*ppGameObject);
     if (pContainer) {
-        *ptr=reinterpret_cast<void*>(pContainer);
+        *ptr=pContainer;
         return SWIGTYPE_p_rl__Container;
     }
     rl::Item *pItem=dynamic_cast<rl::Item*>(*ppGameObject);
     if (pItem) {
-        *ptr=reinterpret_cast<void*>(pItem);
+        *ptr=pItem;
         return SWIGTYPE_p_rl__Item;
     }
     return 0;

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-05-23 12:03:09 UTC (rev 3482)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-05-25 05:48:04 UTC (rev 3483)
@@ -143,7 +143,7 @@
     rl::CutsceneCharacterController *pCutSceneCC =
         dynamic_cast<rl::CutsceneCharacterController*>(*ppCharacterController);
     if (pCutSceneCC != NULL) {
-        *ptr=reinterpret_cast<void*>(pCutSceneCC);
+        *ptr=pCutSceneCC;
         return SWIGTYPE_p_rl__CutsceneCharacterController;
     }
     return 0;



From timm at mail.berlios.de  Fri May 25 10:44:42 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 25 May 2007 10:44:42 +0200
Subject: [Dsa-hl-svn] r3484 - in rl/trunk/engine: ai/include ai/src core/src
	script/swig
Message-ID: <200705250844.l4P8igoX013553@sheep.berlios.de>

Author: timm
Date: 2007-05-25 10:44:38 +0200 (Fri, 25 May 2007)
New Revision: 3484

Modified:
   rl/trunk/engine/ai/include/CreatureWalkPathJob.h
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Just an interim report of the CreatureWalkPathJob and some clean up

Modified: rl/trunk/engine/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-05-25 05:48:04 UTC (rev 3483)
+++ rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-05-25 08:44:38 UTC (rev 3484)
@@ -30,14 +30,30 @@
     class _RlAiExport CreatureWalkPathJob : public Job
     {
     public:
+       /** Constructor
+        * @param name the name of the Job
+        * @param movingCreature the job has to know a moving creature
+        * @param startLandmark first landmark, the moving creature has to go to
+        */
         CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark);
+        //destructor
         virtual ~CreatureWalkPathJob();
 
+        //adds an additional landmark the moving creature has to go to
         void addLandmark(const Ogre::String& name, const Ogre::Vector3& position);
         void addLandmark(Landmark* lm);
 
+       /**
+        * This function is not intented to be called directly
+        * @retval false, if the job is not done
+        */
         virtual bool execute(Ogre::Real time);
+
+        // @retval the moving creature controlled by this object
+        MovingCreature* getMovingCreature();
     private:
+        void updateCreature(Ogre::Real time);
+
         LandmarkPath mLandmarkPath;
         Ogre::String mName;
         MovingCreature* mMovingCreature;

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-25 05:48:04 UTC (rev 3483)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-25 08:44:38 UTC (rev 3484)
@@ -21,6 +21,7 @@
     CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark) : Job(true, true), 
         mLandmarkPath("LandmarkPath" + name)
     {
+        //the moving creature moves from the current position to the landmark
         mMovingCreature = movingCreature;
         //addLandmark(startLandmark);
         mCurrentLandmark = new Landmark(name + "_startup",mMovingCreature->getCreature()->getPosition());
@@ -48,10 +49,10 @@
             {
 
             }*/
-            mMovingCreature->setMovement(MovingCreature::MT_GEHEN,diffTrack,Ogre::Vector3(0,0,0));
-            if(diffTrack.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getPosition()))
-                mMovingCreature->getCreature()->setPosition(mNextLandmark->getPosition());        
+            mMovingCreature->setMovement(MovingCreature::MT_GEHEN,diffTrack,Ogre::Vector3(0,0,0));        
         }
+
+        updateCreature(time);
         return false;
     }
 
@@ -64,4 +65,34 @@
     {
         mLandmarkPath.addPoint(lm);
     }
+
+    MovingCreature* CreatureWalkPathJob::getMovingCreature()
+    {
+        return mMovingCreature;
+    }
+
+    void CreatureWalkPathJob::updateCreature(Ogre::Real time)
+    {
+        //executes the movements from movingCreature on the creature
+        Quaternion rotation;
+        Vector3 translation;
+
+        //@todo: calculate translation and rotation
+        AbstractMovement* _rotate = mMovingCreature->getMovementId(MovingCreature::MT_DREHEN);
+        Real baseVelRot = 0;
+        AbstractMovement* _translate = mMovingCreature->getMovementId(MovingCreature::MT_JOGGEN);
+        Real baseVelTrans = 0;
+
+        if(_rotate->calculateBaseVelocity(baseVelRot))
+        {
+            //@todo
+        }
+        if(_translate->calculateBaseVelocity(baseVelTrans))
+        {
+            //@todo
+        }
+        //make sure that the creature can't fail the landmark
+        if(diffTrack.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getPosition()) < 0)
+            mMovingCreature->getCreature()->setPosition(mNextLandmark->getPosition());
+    }
 }
\ No newline at end of file

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2007-05-25 05:48:04 UTC (rev 3483)
+++ rl/trunk/engine/core/src/Actor.cpp	2007-05-25 08:44:38 UTC (rev 3484)
@@ -734,6 +734,7 @@
     {
         if (highlight != mHighlighted)
         {
+            //@todo: blue ring or something signifies the highlighted object
             //getControlledObject()->setHighlighted(highlight);
             mHighlighted = highlight;
         }

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-05-25 05:48:04 UTC (rev 3483)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-05-25 08:44:38 UTC (rev 3484)
@@ -731,9 +731,6 @@
         rl::TimerEventSource* getSource() const;
     };
     
-    class AbstractMovement;
-    class MovingCreatureManager;
-
     class MovingCreature : public PhysicsController, PhysicsGenericContactCallback
     {
     public:
@@ -759,21 +756,11 @@
             MT_DREHEN
         } MovementType;
         
-        typedef enum { 
-            AL_AIRBORNE,
-            AL_FLOOR
-        } AbstractLocation;
-        
         Creature *getCreature();
-        void setAbstractLocation(AbstractLocation type);
-        AbstractLocation getAbstractLocation() const;
         bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
         MovementType getMovementId() const;
         Ogre::Vector3 getDirection() const;
         Ogre::Vector3 getRotation() const;
-        AbstractMovement *getMovement();
-        AbstractMovement *getMovementFromId(MovementType id);
-        int getCurrentGS() const;
         Ogre::Vector3 getVelocity() const;
         Ogre::Vector3 getOmega() const;
         void setAnimation(const Ogre::String &name, 



From timm at mail.berlios.de  Fri May 25 10:51:54 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 25 May 2007 10:51:54 +0200
Subject: [Dsa-hl-svn] r3485 - rl/trunk/engine/ai/src
Message-ID: <200705250851.l4P8psX8014186@sheep.berlios.de>

Author: timm
Date: 2007-05-25 10:51:49 +0200 (Fri, 25 May 2007)
New Revision: 3485

Modified:
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
Log:
Some fixes...

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-25 08:44:38 UTC (rev 3484)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-25 08:51:49 UTC (rev 3485)
@@ -74,14 +74,14 @@
     void CreatureWalkPathJob::updateCreature(Ogre::Real time)
     {
         //executes the movements from movingCreature on the creature
-        Quaternion rotation;
-        Vector3 translation;
+        Ogre::Quaternion rotation;
+        Ogre::Vector3 translation;
 
         //@todo: calculate translation and rotation
-        AbstractMovement* _rotate = mMovingCreature->getMovementId(MovingCreature::MT_DREHEN);
-        Real baseVelRot = 0;
-        AbstractMovement* _translate = mMovingCreature->getMovementId(MovingCreature::MT_JOGGEN);
-        Real baseVelTrans = 0;
+        AbstractMovement* _rotate = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+        Ogre::Real baseVelRot = 0;
+        AbstractMovement* _translate = mMovingCreature->getMovementFromId(MovingCreature::MT_JOGGEN);
+        Ogre::Real baseVelTrans = 0;
 
         if(_rotate->calculateBaseVelocity(baseVelRot))
         {
@@ -92,7 +92,8 @@
             //@todo
         }
         //make sure that the creature can't fail the landmark
+        Ogre::Vector3 diffTrack = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
         if(diffTrack.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getPosition()) < 0)
             mMovingCreature->getCreature()->setPosition(mNextLandmark->getPosition());
     }
-}
\ No newline at end of file
+}



From timm at mail.berlios.de  Mon May 28 19:42:06 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 28 May 2007 19:42:06 +0200
Subject: [Dsa-hl-svn] r3486 - rl/trunk/engine/ai/src
Message-ID: <200705281742.l4SHg6qQ021870@sheep.berlios.de>

Author: timm
Date: 2007-05-28 19:42:03 +0200 (Mon, 28 May 2007)
New Revision: 3486

Modified:
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
Log:
updated CreatureWalkPathJob

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-25 08:51:49 UTC (rev 3485)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-28 17:42:03 UTC (rev 3486)
@@ -23,10 +23,8 @@
     {
         //the moving creature moves from the current position to the landmark
         mMovingCreature = movingCreature;
-        //addLandmark(startLandmark);
         mCurrentLandmark = new Landmark(name + "_startup",mMovingCreature->getCreature()->getPosition());
         mNextLandmark = startLandmark;
-        //mMovingCreature->getCreature()->setPosition(startLandmark->getPosition());
     }
 
     CreatureWalkPathJob::~CreatureWalkPathJob()
@@ -35,24 +33,26 @@
 
     bool CreatureWalkPathJob::execute(Ogre::Real time)
     {
-        if (mLandmarkPath.getPoints().size() > 0 && mMovingCreature->getCreature()->getPosition() == mNextLandmark->getPosition())
+        if (mMovingCreature->getCreature()->getPosition() == mNextLandmark->getPosition())
         {
-            mCurrentLandmark = mNextLandmark;
-            mNextLandmark = mLandmarkPath.getPoints().front();
-            mLandmarkPath.getPoints().pop_front();
+            if (mLandmarkPath.getPoints().size())
+            {
+                mCurrentLandmark = mNextLandmark;
+                mNextLandmark = mLandmarkPath.getPoints().front();
+                mLandmarkPath.getPoints().pop_front();
+            }
+            else
+            {
+                mCurrentLandmark = mNextLandmark;
+                //@todo
+            }
+            
         }
-        else if (mMovingCreature->getCreature()->getPosition() != mNextLandmark->getPosition())
+        else if (mCurrentLandmark != mNextLandmark)
         {
-            Ogre::Vector3 creatureViewVector = mMovingCreature->getCreature()->getOrientation() * Ogre::Vector3::NEGATIVE_UNIT_Z;
-            Ogre::Vector3 diffTrack = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
-            /*if (diffTrack.dotProduct(creatureViewVector) < 0.5)
-            {
-
-            }*/
-            mMovingCreature->setMovement(MovingCreature::MT_GEHEN,diffTrack,Ogre::Vector3(0,0,0));        
+            updateCreature(time);
         }
 
-        updateCreature(time);
         return false;
     }
 
@@ -73,27 +73,35 @@
 
     void CreatureWalkPathJob::updateCreature(Ogre::Real time)
     {
-        //executes the movements from movingCreature on the creature
-        Ogre::Quaternion rotation;
-        Ogre::Vector3 translation;
-
+        LOG_MESSAGE("JOB","CreatureWalkPathJob::updateCreature");
         //@todo: calculate translation and rotation
-        AbstractMovement* _rotate = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+        AbstractMovement* rotate = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
         Ogre::Real baseVelRot = 0;
-        AbstractMovement* _translate = mMovingCreature->getMovementFromId(MovingCreature::MT_JOGGEN);
+        AbstractMovement* translate = mMovingCreature->getMovementFromId(MovingCreature::MT_RENNEN);
         Ogre::Real baseVelTrans = 0;
+        Ogre::Radian rotation(time) ;
+        Ogre::Vector3 direction = Ogre::Vector3(0,0,0);
 
-        if(_rotate->calculateBaseVelocity(baseVelRot))
+        if(rotate->calculateBaseVelocity(baseVelRot))
         {
+            Ogre::Vector3 creatureViewVector = mMovingCreature->getCreature()->getOrientation() * Ogre::Vector3::NEGATIVE_UNIT_Z;
+            Ogre::Radian baseVelRotRad(baseVelRot * 2 * Ogre::Math::PI);
             //@todo
         }
-        if(_translate->calculateBaseVelocity(baseVelTrans))
-        {
+        //if(translate->calculateBaseVelocity(baseVelTrans))
+        //{
+        direction = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
             //@todo
-        }
+        //}
+
+        LOG_MESSAGE("Movement", "Vec3 " + Ogre::StringConverter::toString(direction) 
+            + " Set Movement " + Ogre::StringConverter::toString(
+            mMovingCreature->setMovement(MovingCreature::MT_GEHEN, direction, Ogre::Vector3(0,rotation.valueRadians(),0))));
+        //mMovingCreature->setAnimation("rennen");
+
         //make sure that the creature can't fail the landmark
-        Ogre::Vector3 diffTrack = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
-        if(diffTrack.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getPosition()) < 0)
+        //Ogre::Vector3 diffTrack = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
+        if(direction.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getPosition()) < 0)
             mMovingCreature->getCreature()->setPosition(mNextLandmark->getPosition());
     }
 }



From timm at mail.berlios.de  Tue May 29 20:48:17 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 29 May 2007 20:48:17 +0200
Subject: [Dsa-hl-svn] r3487 - rl/trunk/engine/ai/src
Message-ID: <200705291848.l4TImHr5032127@sheep.berlios.de>

Author: timm
Date: 2007-05-29 20:48:10 +0200 (Tue, 29 May 2007)
New Revision: 3487

Modified:
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
Log:
updated CreatureWalkPathJob

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-28 17:42:03 UTC (rev 3486)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-05-29 18:48:10 UTC (rev 3487)
@@ -33,7 +33,8 @@
 
     bool CreatureWalkPathJob::execute(Ogre::Real time)
     {
-        if (mMovingCreature->getCreature()->getPosition() == mNextLandmark->getPosition())
+        if (mMovingCreature->getCreature()->getActor()->getPosition().x == mNextLandmark->getPosition().x 
+            && mMovingCreature->getCreature()->getActor()->getPosition().y == mNextLandmark->getPosition().y)
         {
             if (mLandmarkPath.getPoints().size())
             {
@@ -73,35 +74,30 @@
 
     void CreatureWalkPathJob::updateCreature(Ogre::Real time)
     {
-        LOG_MESSAGE("JOB","CreatureWalkPathJob::updateCreature");
-        //@todo: calculate translation and rotation
-        AbstractMovement* rotate = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
-        Ogre::Real baseVelRot = 0;
-        AbstractMovement* translate = mMovingCreature->getMovementFromId(MovingCreature::MT_RENNEN);
-        Ogre::Real baseVelTrans = 0;
-        Ogre::Radian rotation(time) ;
-        Ogre::Vector3 direction = Ogre::Vector3(0,0,0);
+        //Max AU ist 0, deswegen erstmal vorl?ufig:
+        if(mMovingCreature->getCreature()->getAu() < 2.0f)
+            mMovingCreature->getCreature()->modifyAu(2,true);
 
-        if(rotate->calculateBaseVelocity(baseVelRot))
+        Ogre::Vector3 direction = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
+
+        Ogre::Vector3 creatureViewVector = mMovingCreature->getCreature()->getActor()->getOrientation() * Ogre::Vector3::NEGATIVE_UNIT_Z;
+        if(creatureViewVector.normalisedCopy().dotProduct(direction.normalisedCopy())  < 0.99)
         {
-            Ogre::Vector3 creatureViewVector = mMovingCreature->getCreature()->getOrientation() * Ogre::Vector3::NEGATIVE_UNIT_Z;
-            Ogre::Radian baseVelRotRad(baseVelRot * 2 * Ogre::Math::PI);
-            //@todo
+            //rotate until creature looks into the direction it wants to go to
+            //@todo: rotate
+            Ogre::Real rotate = Ogre::Math::ACos(creatureViewVector.normalisedCopy().dotProduct(direction.normalisedCopy())).valueRadians();
+            mMovingCreature->setMovement(MovingCreature::MT_STEHEN, Ogre::Vector3(0,0,0),Ogre::Vector3(0,rotate,0));
+            //bool result = mMovingCreature->setMovement(MovingCreature::MT_STEHEN, Ogre::Vector3(0,0,0), Ogre::Vector3(0,0.5,0));
         }
-        //if(translate->calculateBaseVelocity(baseVelTrans))
-        //{
-        direction = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
-            //@todo
-        //}
+        else
+        {
+            //move creature to the target
+            mMovingCreature->setMovement(MovingCreature::MT_GEHEN, direction, Ogre::Vector3(0,0,0));
+        }
 
-        LOG_MESSAGE("Movement", "Vec3 " + Ogre::StringConverter::toString(direction) 
-            + " Set Movement " + Ogre::StringConverter::toString(
-            mMovingCreature->setMovement(MovingCreature::MT_GEHEN, direction, Ogre::Vector3(0,rotation.valueRadians(),0))));
-        //mMovingCreature->setAnimation("rennen");
-
         //make sure that the creature can't fail the landmark
         //Ogre::Vector3 diffTrack = mNextLandmark->getPosition() - mCurrentLandmark->getPosition();
-        if(direction.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getPosition()) < 0)
-            mMovingCreature->getCreature()->setPosition(mNextLandmark->getPosition());
+        if(direction.dotProduct(mNextLandmark->getPosition()-mMovingCreature->getCreature()->getActor()->getPosition()) < 0)
+            mMovingCreature->getCreature()->getActor()->setPosition(mNextLandmark->getPosition());
     }
 }



From timm at mail.berlios.de  Tue May 29 20:51:25 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 29 May 2007 20:51:25 +0200
Subject: [Dsa-hl-svn] r3488 - in modules/combattest: dsa scripts/maps
Message-ID: <200705291851.l4TIpPLg032387@sheep.berlios.de>

Author: timm
Date: 2007-05-29 20:51:17 +0200 (Tue, 29 May 2007)
New Revision: 3488

Modified:
   modules/combattest/dsa/gameobjectdefinitions.gof
   modules/combattest/scripts/maps/combattest.rb
Log:
Test data for CreatureWalkPathJob

Modified: modules/combattest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/combattest/dsa/gameobjectdefinitions.gof	2007-05-29 18:48:10 UTC (rev 3487)
+++ modules/combattest/dsa/gameobjectdefinitions.gof	2007-05-29 18:51:17 UTC (rev 3488)
@@ -14,6 +14,7 @@
     	<property type="STRING" data="AvoidObstaclesBehaviour"/>
     </property>
   </gameobjectclass>
+  
   <gameobjectclass classid="Wolf2" baseclass="Creature">
     <property name="classid" type="STRING" data="Wolf2"/>
     <property name="baseclass" type="STRING" data="Creature"/>

Modified: modules/combattest/scripts/maps/combattest.rb
===================================================================
--- modules/combattest/scripts/maps/combattest.rb	2007-05-29 18:48:10 UTC (rev 3487)
+++ modules/combattest/scripts/maps/combattest.rb	2007-05-29 18:51:17 UTC (rev 3488)
@@ -1,5 +1,6 @@
 load 'embed.rb'
 
+require 'globals.rb'
 require 'player.rb'
 require 'hero.rb'
 
@@ -9,7 +10,7 @@
 $SCRIPT.log("init map 'regressiontest'...")
 
 $SCRIPT.log("Create hero")
-$hero = $GOM.createGameObject("hero", 1);
+$hero = $GOM.createGameObject("hero", 1)
 
 $SCRIPT.log("Place hero into scene")
 $hero.placeIntoScene()
@@ -31,9 +32,12 @@
 wolf2.setPosition [0.0,0.0,-3.0]
 wolf2.setAlignment(Creature::ALIGNMENT_ENEMY)
 
-_movingCreature = MovingCreature.new(wolf2)
+movingCreature = MovingCreature.new(wolf2)
 
-_job = CreatureWalkPathJob.new("TestWalkJob", _movingCreature, Landmark.new("point", [2.0, 0.0, -10.0]))
+job = CreatureWalkPathJob.new("TestWalkJob", movingCreature, Landmark.new("point", [0.0, 0.0, -10.0]))
+job.addLandmark("1",[5.0,0.0,-20.0])
+job.addLandmark("2",[5.0,0.0,-15.0])
+$JS.addJob(job);
 
 $SCRIPT.log("map 'combattest' initialisiert.")
 



From melven at mail.berlios.de  Wed May 30 23:31:55 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 30 May 2007 23:31:55 +0200
Subject: [Dsa-hl-svn] r3489 - rl/trunk/engine/ui/src
Message-ID: <200705302131.l4ULVtjJ007493@sheep.berlios.de>

Author: melven
Date: 2007-05-30 23:31:44 +0200 (Wed, 30 May 2007)
New Revision: 3489

Modified:
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
Log:
Removed bug (movement not possible after switching to FreeFlightCharacterController)

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-05-29 18:51:17 UTC (rev 3488)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-05-30 21:31:44 UTC (rev 3489)
@@ -65,12 +65,15 @@
 
         // Char<->Level collision back to default
         PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("default"));
         // Char<->Default collision back to default
         PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
     }
 
     void FreeFlightCharacterController::resume()
@@ -86,11 +89,14 @@
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
         // We also handle char<->level, char<->default collision from now on (camera=char!)
         PhysicsManager::getSingleton().getMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("default"))->setContactCallback(this);
         PhysicsManager::getSingleton().getMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
+            PhysicsManager::getSingleton().getMaterialID("camera"),
             PhysicsManager::getSingleton().getMaterialID("level"))->setContactCallback(this);
+        PhysicsManager::getSingleton().getMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"))->setContactCallback(this);
 
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
         if( mesh != NULL )



