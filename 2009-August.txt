From twel at mail.berlios.de  Mon Aug  3 14:30:07 2009
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Mon, 3 Aug 2009 14:30:07 +0200
Subject: [Dsa-hl-svn] r4950 - dependencies/OgreNewt/cmake
Message-ID: <200908031230.n73CU7PY005310@sheep.berlios.de>

Author: twel
Date: 2009-08-03 14:30:05 +0200 (Mon, 03 Aug 2009)
New Revision: 4950

Modified:
   dependencies/OgreNewt/cmake/FindNewton.cmake
Log:
added new ArchLinux path to NEWTON_INCLUDE_SEARCH_DIRS

Modified: dependencies/OgreNewt/cmake/FindNewton.cmake
===================================================================
--- dependencies/OgreNewt/cmake/FindNewton.cmake	2009-07-17 12:48:49 UTC (rev 4949)
+++ dependencies/OgreNewt/cmake/FindNewton.cmake	2009-08-03 12:30:05 UTC (rev 4950)
@@ -20,6 +20,7 @@
 ELSE(WIN32)
 	SET(NEWTON_INCLUDE_SEARCH_DIRS
 	    /usr/include
+	    /usr/include/newtonSDK
 	    /usr/local/include
 	    /opt/newton/include
 	    /opt/include INTERNAL)



From twel at mail.berlios.de  Mon Aug  3 16:08:19 2009
From: twel at mail.berlios.de (twel at mail.berlios.de)
Date: Mon, 3 Aug 2009 16:08:19 +0200
Subject: [Dsa-hl-svn] r4951 - in rl/trunk: . cmake
Message-ID: <200908031408.n73E8JLF031711@sheep.berlios.de>

Author: twel
Date: 2009-08-03 16:08:17 +0200 (Mon, 03 Aug 2009)
New Revision: 4951

Added:
   rl/trunk/cmake/FindNewton.cmake
Modified:
   rl/trunk/CMakeLists.txt
Log:
added cmake checks for Newton, but does not yet pass the correct include path to the build-Makefile

Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-08-03 12:30:05 UTC (rev 4950)
+++ rl/trunk/CMakeLists.txt	2009-08-03 14:08:17 UTC (rev 4951)
@@ -30,6 +30,7 @@
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
 FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
+FIND_PACKAGE(Newton 2.0 REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(Ruby REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)

Added: rl/trunk/cmake/FindNewton.cmake
===================================================================
--- rl/trunk/cmake/FindNewton.cmake	2009-08-03 12:30:05 UTC (rev 4950)
+++ rl/trunk/cmake/FindNewton.cmake	2009-08-03 14:08:17 UTC (rev 4951)
@@ -0,0 +1,119 @@
+# Find Newton
+#
+# This module defines
+#  NEWTON_FOUND
+#  NEWTON_INCLUDE_DIR
+#  NEWTON_LIBRARY
+#
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# On a new cmake run, we do not need to be verbose
+IF(NEWTON_INCLUDE_DIR AND NEWTON_LIBRARY)
+	SET(NEWTON_FIND_QUIETLY TRUE)
+ENDIF(NEWTON_INCLUDE_DIR AND NEWTON_LIBRARY)
+
+IF(WIN32)
+
+ELSE(WIN32)
+	SET(NEWTON_INCLUDE_SEARCH_DIRS
+	    /usr/include
+	    /usr/include/newtonSDK
+	    /usr/local/include
+	    /opt/newton/include
+	    /opt/include INTERNAL)
+	SET(NEWTON_LIBRARY_SEARCH_DIRS
+	    /usr/lib
+	    /usr/lib64
+	    /usr/local/lib
+	    /usr/local/lib64
+	    /opt/newton/lib
+	    /opt/newton/lib64 INTERNAL)
+	SET(NEWTON_INC_DIR_SUFFIXES PATH_SUFFIXES newton)
+ENDIF(WIN32)
+
+IF (NOT NEWTON_FIND_QUIETLY)
+	MESSAGE(STATUS "Checking for Newton")
+ENDIF(NOT NEWTON_FIND_QUIETLY)
+
+# Search for header files and libraries
+FIND_PATH(NEWTON_INCLUDE_DIR Newton.h
+          PATHS ${NEWTON_INCLUDE_SEARCH_DIRS}
+          PATH_SUFFIXES ${NEWTON_INC_DIR_SUFFIXES})
+
+FIND_LIBRARY(NEWTON_LIBRARY Newton
+             PATHS ${NEWTON_LIBRARY_SEARCH_DIRS}
+             PATH_SUFFIXES ${NEWTON_LIB_DIR_SUFFIXES})
+
+SET(NEWTON_INCLUDE_DIR ${NEWTON_INCLUDE_DIR} CACHE STRING "Directory containing Newton header files")
+SET(NEWTON_LIBRARY ${NEWTON_LIBRARY} CACHE STRING "Library name of Newton library")
+
+IF(NEWTON_INCLUDE_DIR AND NEWTON_LIBRARY)
+	SET(NEWTON_FOUND TRUE)
+ENDIF(NEWTON_INCLUDE_DIR AND NEWTON_LIBRARY)
+
+IF(NEWTON_INCLUDE_DIR)
+	# Extract the library version from the header file
+	FILE(READ "${NEWTON_INCLUDE_DIR}/Newton.h" _NEWTON_NEWTON_H_CONTENTS)
+	# Check if header contains version information
+	STRING(REGEX MATCH "NEWTON_MAJOR_VERSION"
+	       NEWTON_VERSION_EXISTS "${_NEWTON_NEWTON_H_CONTENTS}")
+	IF("${NEWTON_VERSION_EXISTS}" STREQUAL "NEWTON_MAJOR_VERSION")
+		STRING(REGEX REPLACE ".*#define NEWTON_MAJOR_VERSION ([0-9]+).*" "\\1"
+		       NEWTON_MAJOR_VERSION "${_NEWTON_NEWTON_H_CONTENTS}")
+		STRING(REGEX REPLACE ".*#define NEWTON_MINOR_VERSION ([0-9]+).*" "\\1"
+		       NEWTON_MINOR_VERSION "${_NEWTON_NEWTON_H_CONTENTS}")
+		SET(NEWTON_VERSION "${NEWTON_MAJOR_VERSION}.${NEWTON_MINOR_VERSION}")
+
+		# Newton API beta version checks
+		STRING(REGEX MATCH "NewtonCollisionGetUserID"
+		       NEWTON_BETA19_API "${_NEWTON_NEWTON_H_CONTENTS}")
+		IF(NOT "${NEWTON_BETA19_API}" STREQUAL "NewtonCollisionGetUserID")
+			MESSAGE(SEND_ERROR "Newton 2.0 versions before beta19 are not supported.")
+		ELSE(NOT "${NEWTON_BETA19_API}" STREQUAL "NewtonCollisionGetUserID")
+			SET(NEWTON_VERSION "${NEWTON_VERSION}-beta19")
+		ENDIF(NOT "${NEWTON_BETA19_API}" STREQUAL "NewtonCollisionGetUserID")
+	ELSE("${NEWTON_VERSION_EXISTS}" STREQUAL "NEWTON_MAJOR_VERSION")
+		# We assume Newton 1.53
+		SET(NEWTON_VERSION "1.53")
+	ENDIF("${NEWTON_VERSION_EXISTS}" STREQUAL "NEWTON_MAJOR_VERSION")
+
+	# Compare installed and required version
+	IF(Newton_FIND_VERSION)
+		# Major and minor version are required
+		IF(NOT DEFINED Newton_FIND_VERSION_MINOR)
+			MESSAGE(SEND_ERROR "When requesting a specific version of Newton, you must provide at least the major and minor version numbers, e.g., 2.0")
+		ENDIF(NOT DEFINED Newton_FIND_VERSION_MINOR)
+
+		# Exact version match requested
+		IF(Newton_FIND_VERSION_EXACT)
+			IF(NOT "${NEWTON_VERSION}" VERSION_EQUAL "${Newton_FIND_VERSION}")
+				SET(NEWTON_FOUND FALSE)
+				MESSAGE(SEND_ERROR "Required version of Newton ${Newton_FIND_VERSION}, but you have Newton ${NEWTON_VERSION} installed.")
+			ENDIF(NOT "${NEWTON_VERSION}" VERSION_EQUAL "${Newton_FIND_VERSION}")
+		ELSE(Newton_FIND_VERSION_EXACT)
+			IF("${NEWTON_VERSION}" VERSION_LESS "${Newton_FIND_VERSION}")
+				SET(NEWTON_FOUND FALSE)
+				MESSAGE(STATUS "Detected version of Newton ${NEWTON_VERSION} is too old. At least version ${Newton_FIND_VERSION} is required.")
+			ENDIF("${NEWTON_VERSION}" VERSION_LESS "${Newton_FIND_VERSION}")
+		ENDIF(Newton_FIND_VERSION_EXACT)
+	ENDIF(Newton_FIND_VERSION)
+
+ENDIF(NEWTON_INCLUDE_DIR)
+
+IF(NEWTON_FOUND)
+	IF(NOT NEWTON_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries: ${NEWTON_LIBRARY}")
+		MESSAGE(STATUS "  includes: ${NEWTON_INCLUDE_DIR}")
+		MESSAGE(STATUS "  version: ${NEWTON_VERSION}")
+	ENDIF(NOT NEWTON_FIND_QUIETLY)
+ELSE(NEWTON_FOUND)
+	IF(NOT NEWTON_LIBRARY)
+		MESSAGE(SEND_ERROR, "Newton library could not be found.")
+	ENDIF(NOT NEWTON_LIBRARY)
+	IF(NOT NEWTON_INCLUDE_DIR)
+		MESSAGE(SEND_ERROR "Newton include files could not be found.")
+	ENDIF(NOT NEWTON_INCLUDE_DIR)
+ENDIF(NEWTON_FOUND)



From melven at mail.berlios.de  Fri Aug 21 18:33:52 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 21 Aug 2009 18:33:52 +0200
Subject: [Dsa-hl-svn] r4953 - in rl/trunk/engine: core/src ui/src
Message-ID: <200908211633.n7LGXqY0007178@sheep.berlios.de>

Author: melven
Date: 2009-08-21 18:33:32 +0200 (Fri, 21 Aug 2009)
New Revision: 4953

Modified:
   rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
   rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/PhysicsRagDoll.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
updated to newton 2.07


Modified: rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-08-21 16:29:49 UTC (rev 4952)
+++ rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-08-21 16:33:32 UTC (rev 4953)
@@ -390,7 +390,7 @@
                         Ogre::Matrix4 transformation = oldInvTransformation*newTransformation;
 
                         OgreNewt::ConvexModifierCollision *convexModCol = new OgreNewt::ConvexModifierCollision(
-                                PhysicsManager::getSingleton()._getNewtonWorld(),convexCacheIt->second.col);
+                                PhysicsManager::getSingleton()._getNewtonWorld(),convexCacheIt->second.col, 0);
                         convexModCol->setScalarMatrix(transformation);
 
                         // set the convexcollision-ptr, so centerOfMass and inertia can be calculated
@@ -538,7 +538,7 @@
         // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
         OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
-            aabb.getSize(), orientation, offsetInGlobalSpace));
+            aabb.getSize(), 0, orientation, offsetInGlobalSpace));
 
        return rval;
     }
@@ -552,7 +552,7 @@
 
         OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
-            aabb.getSize(), orientation, offsetInGlobalSpace));
+            aabb.getSize(), 0, orientation, offsetInGlobalSpace));
 
        return rval;
     }
@@ -571,7 +571,7 @@
         // a sphere primitiv has got its coordinate system at its center, so shift it with radius
         OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
-            Vector3(radius, radius, radius), orientation, offsetInGlobalSpace));
+            Vector3(radius, radius, radius), 0, orientation, offsetInGlobalSpace));
  
        return rval;
     }
@@ -592,7 +592,7 @@
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
         OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
-            s, orientation, offsetInGlobalSpace));
+            s, 0, orientation, offsetInGlobalSpace));
 
        return rval;
     }
@@ -615,7 +615,7 @@
         // additionally it is x axis aligned, so rotate it 90 degrees around z axis
         OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
-            radius, height, orientation, offsetInGlobalSpace));
+            radius, height, 0, orientation, offsetInGlobalSpace));
 
         return rval;
     }
@@ -632,7 +632,7 @@
         // calculate the convex hull of the animated mesh
         OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
                     PhysicsManager::getSingleton()._getNewtonWorld(),
-                    entity, orientation, offsetInGlobalSpace));
+                    entity, 0, orientation, offsetInGlobalSpace));
 
         return rval;
     }
@@ -705,7 +705,7 @@
         {
             rval = OgreNewt::CollisionPtr( new OgreNewt::CollisionPrimitives::TreeCollision(
                         PhysicsManager::getSingleton()._getNewtonWorld(),
-                        entity, true ));
+                        entity, true, 0 ));
 
             if( !nocache )
             {

Modified: rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-08-21 16:29:49 UTC (rev 4952)
+++ rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-08-21 16:33:32 UTC (rev 4953)
@@ -32,32 +32,28 @@
         Actor* a1 = NULL;
         Actor* a2 = NULL;
 
-        try
-        {
+        if( contactJoint.getBody0()->getUserData().getType() == typeid(Actor*) )
             a1 = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
-        }
-        catch(...)
-        {
-            LOG_WARNING(Logger::CORE, "Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess");
-        }
-        try
-        {
+        if( contactJoint.getBody1()->getUserData().getType() == typeid(Actor*) )
             a2 = Ogre::any_cast<Actor*>(contactJoint.getBody1()->getUserData());
-        }
-        catch(...)
-        {
-            LOG_WARNING(Logger::CORE, "Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess");
-        }
 
-        if (a1 && a1->getPhysicalThing()->getContactListener())
+        PhysicalThing *pt1 = NULL;
+        PhysicalThing *pt2 = NULL;
+
+        if( a1 )
+            pt1 = a1->getPhysicalThing();
+        if( a2 )
+            pt2 = a2->getPhysicalThing();
+
+        if (pt1 && pt1->getContactListener())
         {
-            a1->getPhysicalThing()->getContactListener()->
-                contactOccured(a1->getPhysicalThing(), a2->getPhysicalThing());
+            pt1->getContactListener()->
+                contactOccured(pt1, pt2);
         }
-        if (a2 && a2->getPhysicalThing()->getContactListener())
+        if (pt2 && pt2->getContactListener())
         {
-            a2->getPhysicalThing()->getContactListener()->
-                contactOccured(a2->getPhysicalThing(), a1->getPhysicalThing());
+            pt2->getContactListener()->
+                contactOccured(pt1, pt2);
         }
     }
 }

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-08-21 16:29:49 UTC (rev 4952)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-08-21 16:33:32 UTC (rev 4953)
@@ -343,7 +343,7 @@
                 collision = collisions[0];
                 break;
             default:
-                collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions));
+                collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions, 0));
                 break;
         }
 

Modified: rl/trunk/engine/core/src/PhysicsRagDoll.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-08-21 16:29:49 UTC (rev 4952)
+++ rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-08-21 16:33:32 UTC (rev 4953)
@@ -59,23 +59,23 @@
 	switch (shape)
 	{
 	case PhysicsRagDoll::RagBone::BS_BOX:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CAPSULE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, 0, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, 0, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CYLINDER:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, 0, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_ELLIPSOID:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size, 0 ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONVEXHULL:
@@ -83,7 +83,7 @@
 		break;
 
 	default:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
 		break;
 	}
 
@@ -246,7 +246,7 @@
 	//////////////////////////////////////////////////////////////////////////////////
     OgreNewt::ConvexCollisionPtr col;
     if( numVerts > 0 )
-    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts ));
+    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts, 0 ));
 
 	delete []verts;
 

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-08-21 16:29:49 UTC (rev 4952)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-08-21 16:33:32 UTC (rev 4953)
@@ -66,7 +66,7 @@
 		mCharacterActor->getPhysicalThing()->unfreeze();
 
 // for testing the OgreNewt player controller
-//        delete mOgreNewtPlayerController;
+        delete mOgreNewtPlayerController;
 
         mOgreNewtPlayerController = NULL;
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
@@ -90,7 +90,7 @@
 		mCharacterActor->getPhysicalThing()->freeze();
 
 // for testing the OgreNewt player controller
-//        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
+        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody, 0.4);
 
         resetCamera();
 
@@ -175,6 +175,8 @@
                     mCameraActor->getPosition()
                     + mCameraActor->getWorldOrientation() * Vector3::NEGATIVE_UNIT_Z * 2
                     - 1.5 * Vector3::UNIT_Y);
+                mCharacterActor->getPhysicalThing()->setVelocity(Vector3::ZERO);
+                mCharacterActor->getPhysicalThing()->_getBody()->setOmega(Vector3::ZERO);
             }
         }
 
@@ -220,8 +222,8 @@
         if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
         if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
 
-//if( mCollisionsEnabled )
-//    mOgreNewtPlayerController->setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
+if( mCollisionsEnabled )
+    mOgreNewtPlayerController->setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
 
         mCameraActor->setOrientation(Quaternion::IDENTITY);
         mCameraActor->yaw(mYaw.valueDegrees());
@@ -243,13 +245,13 @@
         if( mCollisionsEnabled )
         {
             CreatureControllerManager::getSingleton().detachController(mCharacter);
-            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor->getPhysicalThing());
-            PhysicsManager::getSingleton().createPhysicsProxy_RagDoll(mCharacterActor->getPhysicalThing());
+//            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor->getPhysicalThing());
+//            PhysicsManager::getSingleton().createPhysicsProxy_RagDoll(mCharacterActor->getPhysicalThing());
         }
         else
         {
-            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor->getPhysicalThing());
-            PhysicsManager::getSingleton().createPhysicsProxy(mCharacterActor->getPhysicalThing());
+//            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor->getPhysicalThing());
+//            PhysicsManager::getSingleton().createPhysicsProxy(mCharacterActor->getPhysicalThing());
             CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
         }
 

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2009-08-21 16:29:49 UTC (rev 4952)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2009-08-21 16:33:32 UTC (rev 4953)
@@ -136,31 +136,8 @@
         mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
             boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
 
-        // Kamera-Groesse beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-            mCameraActor->getControlledObject());
-        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-        camRadius *= 1.1f;
-        Vector3 verts[80];
-        int k = 0;
-        for(int i = 0; i < 16; i++)
-        {
-            int n;
-            n = abs(abs(i-8)-8)+1;
-            for(int j = 0; j < n; j++)
-            {
-                Real h = (i-7.5f)/7.5f;
-                Degree angle(360.0f/(n+1)*j);
-                Real rad = Math::Sqrt(1-h*h);
-                verts[k++] = camRadius*Vector3(rad*Math::Cos(angle),rad*Math::Sin(angle),h);
-            }
-        }
-        //! TODO: remove this workaround (newton-bug: "spheres don't cast"!)
-        mCameraCastCollision = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80));
-        //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody->getWorld(), Vector3::UNIT_SCALE * camRadius);
-        // we could use the real collision of the camera here...
+        mCameraCastCollision = boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(mCamBody->getCollision());
+        RlAssert1( mCameraCastCollision );
     }
 
     //------------------------------------------------------------------------



From melven at mail.berlios.de  Fri Aug 21 18:33:52 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 21 Aug 2009 18:33:52 +0200
Subject: [Dsa-hl-svn] r4952 - in dependencies/OgreNewt: demos
	demos/Demo01_TheBasics demos/Demo02_Joints
	demos/Demo03_CollisionCallbacks demos/Demo04_Raycasting
	demos/Demo05_SimpleVehicle demos/Demo06_SimpleBuoyancy
	demos/Demo07_CustomJoints demos/Demo08_RagdollExample
	demos/Demo09_PlayerController inc src
Message-ID: <200908211633.n7LGXqqP007180@sheep.berlios.de>

Author: melven
Date: 2009-08-21 18:29:49 +0200 (Fri, 21 Aug 2009)
New Revision: 4952

Added:
   dependencies/OgreNewt/demos/Demo09_PlayerController/
   dependencies/OgreNewt/demos/Demo09_PlayerController/CMakeLists.txt
   dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h
   dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.h
   dependencies/OgreNewt/demos/Demo09_PlayerController/demo09.cpp
Modified:
   dependencies/OgreNewt/demos/CMakeLists.txt
   dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp
   dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp
   dependencies/OgreNewt/inc/OgreNewt.h
   dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h
   dependencies/OgreNewt/inc/OgreNewt_Body.h
   dependencies/OgreNewt/inc/OgreNewt_Collision.h
   dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt/inc/OgreNewt_Joint.h
   dependencies/OgreNewt/inc/OgreNewt_PlayerController.h
   dependencies/OgreNewt/inc/OgreNewt_World.h
   dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp
   dependencies/OgreNewt/src/OgreNewt_Body.cpp
   dependencies/OgreNewt/src/OgreNewt_Collision.cpp
   dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
   dependencies/OgreNewt/src/OgreNewt_Joint.cpp
   dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
   dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
   dependencies/OgreNewt/src/OgreNewt_World.cpp
Log:
-updated to newton 2.07


Modified: dependencies/OgreNewt/demos/CMakeLists.txt
===================================================================
--- dependencies/OgreNewt/demos/CMakeLists.txt	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/CMakeLists.txt	2009-08-21 16:29:49 UTC (rev 4952)
@@ -62,5 +62,6 @@
 ADD_SUBDIRECTORY(Demo06_SimpleBuoyancy)
 ADD_SUBDIRECTORY(Demo07_CustomJoints)
 ADD_SUBDIRECTORY(Demo08_RagdollExample)
+ADD_SUBDIRECTORY(Demo09_PlayerController)
 
 PRINT_ENABLED_FEATURES()

Modified: dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -55,7 +55,7 @@
 
 	// here's where we make a collision shape for the physics.  note that we use the same size as
 	// above.
-	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(m_World, 2.5, 5));
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(m_World, 2.5, 5, 0));
 
 	// now we make a new rigid body based on this collision shape.
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );

Modified: dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -80,7 +80,7 @@
 			//ent->setNormaliseNormals(true);
 
 			// again, make the collision shape.
-			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(m_World, 1, 1));
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(m_World, 1, 1, 0));
 			
 			// then make the rigid body.
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
@@ -125,6 +125,10 @@
         debug.stopRaycastRecording();
     }
 
+
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 		return false;
 

Modified: dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -73,7 +73,7 @@
 	// using the new "SceneParser" TreeCollision primitive.  this will automatically parse an entire tree of
 	// SceneNodes (parsing all children), and add collision for all meshes in the tree.
 	OgreNewt::CollisionPrimitives::TreeCollisionSceneParser* stat_col = new OgreNewt::CollisionPrimitives::TreeCollisionSceneParser( m_World );
-	stat_col->parseScene( floornode, true );
+	stat_col->parseScene( floornode, true, 0 );
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, OgreNewt::CollisionPtr(stat_col) );
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
 	delete stat_col;
@@ -162,7 +162,7 @@
 	box1node->setScale( size );
 //	box1->setNormaliseNormals(true);
 
-	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 

Modified: dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -74,7 +74,7 @@
 			ent->setMaterialName( "Simple/dirt01" );
 //			ent->setNormaliseNormals(true);
 
-			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) ));
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1), 0 ));
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
@@ -112,6 +112,10 @@
 
 
 
+
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 		return false;
 

Modified: dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -27,7 +27,7 @@
 	mNode->setScale( size );
 
 	// create the collision object for the conveyor belt.
-	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
 	mBody = new OgreNewt::Body( world, col, conveyorType );
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
 	delete col;

Modified: dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -79,7 +79,7 @@
 	floor->setCastShadows( false );
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 	
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
@@ -125,7 +125,7 @@
 	mFrameListener = new OgreNewtonFrameListener( mWindow, mCamera, mSceneMgr, m_World);
 	mRoot->addFrameListener(mFrameListener);
 
-	mNewtonListener = new OgreNewt::BasicFrameListener( mWindow, m_World, 60 );
+	mNewtonListener = new OgreNewt::BasicFrameListener( mWindow, m_World, 600 );
 	mRoot->addFrameListener(mNewtonListener);
 }
 

Modified: dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -68,7 +68,7 @@
 
 		ent->setMaterialName( "Simple/BumpyMetal" );
 
-		OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
+		OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size, 0 ));
 		OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
         Ogre::Vector3 inertia, offset;
@@ -106,6 +106,10 @@
 
 
 
+
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 		return false;
 

Modified: dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -75,7 +75,7 @@
 
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
 	delete col;
@@ -176,7 +176,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 

Modified: dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -180,6 +180,10 @@
 
 
 
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
+
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 		return false;
 

Modified: dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -48,7 +48,7 @@
 	floor->setCastShadows( false );
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floornode, false );
+	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floornode, false, 0 );
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 	delete col;
 	

Modified: dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo05_SimpleVehicle/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -74,7 +74,7 @@
 
 			ent->setMaterialName( "Simple/dirt01" );
 
-			OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) );
+			OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1), 0 );
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
 			Ogre::Vector3 inertia = OgreNewt::MomentOfInertia::CalcSphereSolid( 10.0, 1.0 );
@@ -140,6 +140,10 @@
 
 
 
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
+
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 	{
 		if (mCar)

Modified: dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -75,7 +75,7 @@
 
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
 	delete col;
@@ -193,7 +193,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 

Modified: dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -165,7 +165,7 @@
     {
         debug.showDebugInformation();
         debug.startRaycastRecording();
-        debug.clearRaycastsRecorded();
+        //debug.clearRaycastsRecorded();
     }
     else
     {
@@ -176,6 +176,10 @@
 
 
 
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
+
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 		return false;
 
@@ -214,12 +218,15 @@
 	Ogre::Vector3 dragForce = ((campt - bodpt) * mass * 8.0) - me->getVelocity();
 
 	// draw a 3D line between these points for visual effect :)
+    /*
 	remove3DLine();
 	mDragLine->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
 	mDragLine->position( campt );
 	mDragLine->position( bodpt );
+    // ---------------------------- I get an error here using multithreading... -------------------------------
 	mDragLine->end();
 	mDragLineNode->attachObject( mDragLine );
+    */
 
 
 	// Add the force!

Modified: dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -74,7 +74,7 @@
 	// using the new "SceneParser" TreeCollision primitive.  this will automatically parse an entire tree of
 	// SceneNodes (parsing all children), and add collision for all meshes in the tree.
 	OgreNewt::CollisionPrimitives::TreeCollisionSceneParser* stat_col = new OgreNewt::CollisionPrimitives::TreeCollisionSceneParser( m_World );
-	stat_col->parseScene( floornode, true );
+	stat_col->parseScene( floornode, true, 0 );
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, OgreNewt::CollisionPtr(stat_col) );
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
 	delete stat_col;
@@ -162,7 +162,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 

Modified: dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -73,7 +73,7 @@
 
 			ent->setMaterialName( "Simple/dirt01" );
 
-			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) ));
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1), 0 ));
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
 			Ogre::Vector3 inertia, offset;
@@ -111,6 +111,10 @@
 
 
 
+
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 		return false;
 

Modified: dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -49,7 +49,7 @@
 	floor->setCastShadows( false );
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 #ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
 	delete col;
@@ -99,7 +99,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size, 0 ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 

Modified: dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -87,7 +87,7 @@
 
 			ent->setMaterialName( "Simple/dirt01" );
 
-			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) ));
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1), 0 ));
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
 			Ogre::Vector3 inertia, offset;
@@ -185,6 +185,8 @@
 
 
 
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
 
 	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
 		return false;

Modified: dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -36,23 +36,23 @@
 	switch (shape)
 	{
 	case RagDoll::RagBone::BS_BOX:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
 		break;
 
 	case RagDoll::RagBone::BS_CAPSULE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, 0, orient, pos ));
 		break;
 
 	case RagDoll::RagBone::BS_CONE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, 0, orient, pos ));
 		break;
 
 	case RagDoll::RagBone::BS_CYLINDER:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, 0, orient, pos ));
 		break;
 
 	case RagDoll::RagBone::BS_ELLIPSOID:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size, 0 ));
 		break;
 
 	case RagDoll::RagBone::BS_CONVEXHULL:
@@ -60,7 +60,7 @@
 		break;
 
 	default:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
 		break;
 	}
 
@@ -212,7 +212,7 @@
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
-	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts ));
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts, 0 ));
 
 	delete []verts;
 

Added: dependencies/OgreNewt/demos/Demo09_PlayerController/CMakeLists.txt
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/CMakeLists.txt	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/CMakeLists.txt	2009-08-21 16:29:49 UTC (rev 4952)
@@ -0,0 +1,5 @@
+ADD_EXECUTABLE(Demo09_PlayerController demo09.cpp OgreNewtonApplication.cpp OgreNewtonFrameListener.cpp)
+
+TARGET_LINK_LIBRARIES(Demo09_PlayerController ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARIES} ${OIS_LIBRARIES} ${CEGUIOGRE_LIBRARIES})
+
+#INSTALL(TARGETS Demo09_PlayerController RUNTIME DESTINATION ${CMAKE_SOURCE_DIR}/bin)

Added: dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -0,0 +1,239 @@
+/*
+	OgreNewt library - connecting Ogre and Newton!
+
+	Demo09_PlayerController
+*/
+#include "OgreNewtonApplication.h"
+#include "OgreNewtonFrameListener.h"
+
+#include <OgreNewt.h>
+#include <OgreNewt_BasicFrameListener.h>
+
+
+OgreNewtonApplication::OgreNewtonApplication(void)
+{
+	// create OgreNewt world.
+	m_World = new OgreNewt::World();
+    mPlayer = NULL;
+
+	mEntityCount = 0;
+
+}
+
+OgreNewtonApplication::~OgreNewtonApplication(void)
+{
+	// destroy world.
+    if( mPlayer )
+        delete mPlayer;
+	delete m_World;
+}
+
+
+
+void OgreNewtonApplication::createScene()
+{
+
+	// setup CEGUI
+	mGUIRenderer = new CEGUI::OgreCEGUIRenderer( mWindow, Ogre::RENDER_QUEUE_OVERLAY, false, 3000, mSceneMgr );
+	new CEGUI::System( mGUIRenderer );
+
+	// load up CEGUI stuff...
+	try
+	{
+		using namespace CEGUI;
+		CEGUI::Logger::getSingleton().setLoggingLevel( CEGUI::Informative );
+
+		CEGUI::SchemeManager::getSingleton().loadScheme((CEGUI::utf8*)"TaharezLookSkin.scheme");
+        CEGUI::System::getSingleton().setDefaultMouseCursor((CEGUI::utf8*)"TaharezLook", (CEGUI::utf8*)"MouseArrow");
+        CEGUI::System::getSingleton().setDefaultFont((CEGUI::utf8*)"BlueHighway-10");
+
+		CEGUI::Window* sheet = CEGUI::WindowManager::getSingleton().createWindow( (CEGUI::utf8*)"DefaultWindow", (CEGUI::utf8*)"root_wnd" );
+		CEGUI::System::getSingleton().setGUISheet( sheet );
+
+		//makeGUI();
+		//setupGUI();
+	
+	}
+	catch (CEGUI::Exception)
+	{}
+
+
+	// sky box.
+	mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");
+	
+	// shadows on!
+	mSceneMgr->setShadowTechnique( Ogre::SHADOWTYPE_STENCIL_ADDITIVE );
+
+
+	// floor object!
+	Entity* floor;
+	SceneNode* floornode;
+	floor = mSceneMgr->createEntity("Floor", "simple_terrain.mesh" );
+	floornode = mSceneMgr->getRootSceneNode()->createChildSceneNode( "FloorNode" );
+	floornode->attachObject( floor );
+	floor->setMaterialName( "Simple/BeachStones" );
+	floor->setCastShadows( false );
+
+	
+
+
+	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true, 0 ));
+	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
+#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
+	delete col;
+#endif
+	
+	//floornode->setScale( siz );
+	bod->attachNode( floornode );
+	bod->setPositionOrientation( Ogre::Vector3(0.0,-10.0,0.0), Ogre::Quaternion::IDENTITY );
+
+
+	// make a simple rope.
+	Ogre::Vector3 size(3,1.0,1.0);
+	Ogre::Vector3 pos(0,1,0);
+	Ogre::Quaternion orient = Ogre::Quaternion::IDENTITY;
+
+	// loop through, making bodies and connecting them.
+	OgreNewt::Body* parent = NULL;
+	OgreNewt::Body* child = NULL;
+
+	for (int x=0;x<8;x++)
+	{
+		// make the next box.
+		child = makeSimpleBox(size, pos, orient);
+
+		// now make a new joint connecting this to the last box.
+		OgreNewt::Joint* joint;
+
+		// make the joint right between the bodies...
+		
+
+		if (parent)
+		{
+			joint = new OgreNewt::BasicJoints::BallAndSocket( m_World, child, parent, pos-Ogre::Vector3(size.x/2,0,0) );
+		}
+		else
+		{
+			// no parent, this is the first joint, so just pass NULL as the parent, to stick it to the "world"
+			joint = new OgreNewt::BasicJoints::BallAndSocket( m_World, child, NULL, pos-Ogre::Vector3(size.x/2,0,0) );
+		}
+
+		// offset pos a little more.
+		pos += Ogre::Vector3(size.x,0,0);
+
+		// save the last body for the next loop!
+		parent = child;
+	}
+
+	for (int i=0; i<15;i++)
+	{
+		pos = Ogre::Vector3( 10-rand()%20, 4+rand()%2, 10-rand()%20 );
+		size = Ogre::Vector3( 1+rand()%3, 1+rand()%3, 1+rand()%3 );
+
+		OgreNewt::Body* bod = makeSimpleBox( size, pos, orient );
+	}
+
+    makePlayer();
+
+	
+	// position camera
+	mCamera->setPosition(0.0, -3.0, 23.0);
+
+	//make a light
+	Ogre::Light* light;
+
+	light = mSceneMgr->createLight( "Light1" );
+	light->setType( Ogre::Light::LT_POINT );
+	light->setPosition( Ogre::Vector3(0.0, 100.0, 100.0) );
+
+
+
+}
+
+
+void OgreNewtonApplication::createFrameListener()
+{
+	mFrameListener = new OgreNewtonFrameListener( mWindow, mCamera, mSceneMgr, m_World, mPlayer);
+	mRoot->addFrameListener(mFrameListener);
+
+	mNewtonListener = new OgreNewt::BasicFrameListener( mWindow, m_World, 60 );
+	mRoot->addFrameListener(mNewtonListener);
+}
+
+void OgreNewtonApplication::destroyScene()
+{
+	CEGUI::System* sys = CEGUI::System::getSingletonPtr();
+	delete sys;
+
+	// CEGUI Cleanup
+	delete mGUIRenderer;
+}
+
+
+OgreNewt::Body* OgreNewtonApplication::makeSimpleBox( Ogre::Vector3& size, Ogre::Vector3& pos, Ogre::Quaternion& orient )
+{
+	Entity* box1;
+	SceneNode* box1node;
+
+	box1 = mSceneMgr->createEntity( "Entity"+Ogre::StringConverter::toString(mEntityCount++), "box.mesh" );
+	box1node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
+	box1node->attachObject( box1 );
+	box1node->setScale( size );
+
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size, 0 ));
+	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
+
+
+	// base mass on the size of the object.
+	Ogre::Real mass = size.x * size.y * size.z * 2.5;
+	// calculate the inertia based on box formula and mass
+	Ogre::Vector3 inertia, offset;
+    col->calculateInertialMatrix(inertia, offset);
+
+#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
+	delete col;
+#endif
+				
+	bod->attachNode( box1node );
+	bod->setMassMatrix( mass, mass*inertia );
+    bod->setCenterOfMass(offset);
+	bod->setStandardForceCallback();
+
+	box1->setMaterialName( "Simple/BumpyMetal" );
+
+
+	bod->setPositionOrientation( pos, orient );
+
+	return bod;
+}
+
+void OgreNewtonApplication::makePlayer()
+{
+    Entity* ellipsoid;
+    SceneNode* node;
+
+    ellipsoid = mSceneMgr->createEntity( "PlayerControllerEntity", "ellipsoid.mesh");
+    node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
+    node->attachObject( ellipsoid );
+    node->setScale(Ogre::Vector3(1,2.5,1));
+    
+    OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,2.5,1), 0 ));
+    OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
+    Ogre::Vector3 inertia, offset;
+    col->calculateInertialMatrix(inertia, offset);
+#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
+	delete col;
+#endif
+    bod->attachNode(node);
+    bod->setMassMatrix( 50, 50*inertia );
+    bod->setCenterOfMass(offset);
+    bod->setStandardForceCallback();
+
+    ellipsoid->setMaterialName("Simple/dirt01");
+
+    bod->setPositionOrientation(Ogre::Vector3(0,20,20), Ogre::Quaternion::IDENTITY);
+
+    mPlayer = new OgreNewt::PlayerController(bod, 0.4);
+}
+

Added: dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonApplication.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -0,0 +1,47 @@
+#pragma once
+
+
+#include <ExampleApplication.h>
+#include <OgreNewt.h>
+
+// CEGUI has issues with the Ogre memory manager, this seems to fix it for now.
+//#include <OgreNoMemoryMacros.h>
+#include <CEGUI/CEGUI.h>
+//#include <OgreMemoryMacros.h>
+
+
+#include <OgreCEGUIRenderer.h>
+#include <OgreCEGUIResourceProvider.h>
+
+
+
+
+class OgreNewtonApplication :
+	public ExampleApplication
+{
+public:
+	OgreNewtonApplication(void);
+	~OgreNewtonApplication(void);
+
+protected:
+	void createFrameListener();
+	void createScene();
+
+	void destroyScene();
+
+	// our custom function to simplify making simpe dynamics rigid body boxes.
+	OgreNewt::Body* makeSimpleBox( Ogre::Vector3& size, Ogre::Vector3& pos, Ogre::Quaternion& orient );
+
+    void makePlayer();
+
+private:
+	OgreNewt::World* m_World;
+    OgreNewt::PlayerController *mPlayer;
+	
+	Ogre::FrameListener* mNewtonListener;
+
+	int mEntityCount;
+
+	CEGUI::OgreCEGUIRenderer* mGUIRenderer;
+};
+

Added: dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -0,0 +1,79 @@
+#include "OgreNewtonFrameListener.h"
+
+
+//#include <OgreNoMemoryMacros.h>
+#include <CEGUI/CEGUI.h>
+//#include <OgreMemoryMacros.h>
+
+
+OgreNewtonFrameListener::OgreNewtonFrameListener(RenderWindow* win, Camera* cam, SceneManager* mgr, OgreNewt::World* W, OgreNewt::PlayerController *player) :
+		ExampleFrameListener(win,cam)
+{
+	m_World = W;
+	mSceneMgr = mgr;
+    mPlayer = player;
+
+    OgreNewt::Debugger &debug(m_World->getDebugger());
+    debug.init(mgr);
+}
+
+OgreNewtonFrameListener::~OgreNewtonFrameListener(void)
+{
+}
+
+bool OgreNewtonFrameListener::frameStarted(const FrameEvent &evt)
+{
+	mKeyboard->capture();
+	mMouse->capture();
+
+
+
+    // player movement uhjk zi
+    Ogre::Real forwardSpeed, sideSpeed;
+    Ogre::Radian heading;
+    mPlayer->getVelocity(forwardSpeed, sideSpeed, heading);
+    forwardSpeed = 0;
+    sideSpeed = 0;
+    if(mKeyboard->isKeyDown(OIS::KC_U))
+        forwardSpeed += 6.0;
+    if(mKeyboard->isKeyDown(OIS::KC_J))
+        forwardSpeed -= 5.0;
+    if(mKeyboard->isKeyDown(OIS::KC_H))
+        sideSpeed -= 5.0;
+    if(mKeyboard->isKeyDown(OIS::KC_K))
+        sideSpeed += 5.0;
+    if(mKeyboard->isKeyDown(OIS::KC_Z))
+        heading += Degree(90)/60.0;
+    if(mKeyboard->isKeyDown(OIS::KC_I))
+        heading -= Degree(90)/60.0;
+
+    mPlayer->setVelocity(forwardSpeed, sideSpeed, heading);
+
+
+    OgreNewt::Debugger& debug(m_World->getDebugger());
+    if (mKeyboard->isKeyDown(OIS::KC_F3))
+    {
+        //debug.showDebugInformation();
+        debug.startRaycastRecording();
+        debug.clearRaycastsRecorded();
+    }
+    else
+    {
+        //debug.hideDebugInformation();
+        debug.clearRaycastsRecorded();
+        debug.stopRaycastRecording();
+    }
+
+debug.startRaycastRecording();
+
+
+    if (mKeyboard->isKeyDown(OIS::KC_T))
+        m_World->setThreadCount( m_World->getThreadCount() % 2 + 1);
+
+
+	if (mKeyboard->isKeyDown(OIS::KC_ESCAPE))
+		return false;
+
+	return true;
+}
+

Added: dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.h
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -0,0 +1,69 @@
+#pragma once
+#include "ExampleFrameListener.h"
+#include <OgreNewt.h>
+#include <OIS.h>
+#include <CEGUI.h>
+
+
+class OgreNewtonFrameListener :
+	public ExampleFrameListener,
+    public OIS::KeyListener,
+    public OIS::MouseListener
+{
+protected:
+	OgreNewt::World* m_World;
+	SceneManager* mSceneMgr;
+	int count;
+    OgreNewt::PlayerController* mPlayer;
+public:
+	OgreNewtonFrameListener(RenderWindow* win, Camera* cam, SceneManager* mgr, OgreNewt::World* W, OgreNewt::PlayerController* player);
+	~OgreNewtonFrameListener(void);
+
+	bool frameStarted(const FrameEvent &evt);
+
+	bool mouseMoved (const OIS::MouseEvent &e)
+	{
+		CEGUI::System::getSingleton().injectMouseMove( e.state.X.rel, e.state.Y.rel );
+		return true;
+	}
+
+	bool keyPressed( const OIS::KeyEvent &arg )
+	{
+		CEGUI::System::getSingleton().injectKeyDown( arg.key );
+		CEGUI::System::getSingleton().injectChar( arg.text );
+		return true;
+	}
+
+	bool keyReleased( const OIS::KeyEvent &arg )
+	{
+		CEGUI::System::getSingleton().injectKeyUp( arg.key );
+		return true;
+	}
+
+	bool mousePressed (const OIS::MouseEvent &e, OIS::MouseButtonID id)
+	{
+		CEGUI::System::getSingleton().injectMouseButtonDown(convertOISMouseButtonToCegui(id));
+		return true;
+	}
+
+	bool mouseReleased (const OIS::MouseEvent &e, OIS::MouseButtonID id)
+	{
+		CEGUI::System::getSingleton().injectMouseButtonUp(convertOISMouseButtonToCegui(id));
+		return true;		
+	}
+
+protected:
+	CEGUI::MouseButton convertOISMouseButtonToCegui(int id)
+	{
+		switch (id)
+		{
+			case 0: return CEGUI::LeftButton;
+			case 1: return CEGUI::RightButton;
+			case 2:	return CEGUI::MiddleButton;
+			case 3: return CEGUI::X1Button;
+			default: return CEGUI::LeftButton;
+		}
+
+	}
+};
+

Added: dependencies/OgreNewt/demos/Demo09_PlayerController/demo09.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/demo09.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/demo09.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -0,0 +1,33 @@
+
+/*
+	Demo09_PlayerController
+
+	by melven
+*/
+
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
+
+#include "OgreNewtonApplication.h"
+
+
+#ifdef WIN32
+INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
+#else
+int main(int argc, char**argv)
+#endif
+{
+    // Create application object
+    OgreNewtonApplication app;
+
+    try {
+        app.go();
+    } catch( Ogre::Exception& e ) {
+		printf( "An Error HAS OCCURED: %s", e.getFullDescription().c_str() );
+    }
+
+    return 0;
+}
+

Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -9,9 +9,9 @@
 
     main header file.
 
-    current version:  2.00  ( I only raised the version number to indicate that this is for Newton2.0! )
+    current version:  2.04.0
 
-        Newton version: 2.0 beta (31.01.2009)
+        Newton version: 2.04 (beta)
 
         Ogre version: Shoggoth (1.6.x)
 
@@ -41,7 +41,7 @@
 #include "OgreNewt_BodyInAABBIterator.h"
 #include "OgreNewt_Debugger.h"
 
-/*! \mainpage OgreNewt Library version 2.00
+/*! \mainpage OgreNewt Library version 2.06.0 (for newton version 2.06)
 
     \section into_sec Introduction
 
@@ -52,8 +52,6 @@
     Problems and missing features in this version
         - HeightFieldCollision
         - PlayerController not finished
-        - the convexcast seems to have difficulties with more than one contact (I've segfault when debugging it with the OgreNewt::Debugger...)
-          I added a hack, it only creates one contact at the maximum at the moment! <-- this is probably due to an error in newton
         - this library supports the newton functions for multithreading but there are several functions/classes in this
           library itself, that are not thread safe (I don't need multiple threads)
           especially the world-updates are not threadsafe in ogre (see newton forum, someone posted a solution there!)
@@ -69,6 +67,14 @@
     \section new New in this version
 
     New in this version
+        - CustomJoint:
+            - added globalToLocal function
+            - feedbackCollector callback
+        - first attempts to support multithreading
+            - update the nodes of the bodies after the newton world update, because Ogre doesn't support multithreaded access to nodes
+            - linux: added a pthread-mutex for Ogre in OgreNewt::World, so it can be used for access to Ogre from multiple threads
+        - updated to newton 2.04 -- interface breaking changes (not compatible with newton 2.03!)
+        - set the collision id when creating a collision
         - this version uses cmake > 2.6.2!
         - shared pointers for collisions, if you don't want to use shared pointers define OGRENEWT_NO_COLLISION_SHAREDPTR
         - uses Ogre::Any instead of void* as userdata, if you want to use void* define OGRENEWT_NO_OGRE_ANY
@@ -83,6 +89,7 @@
               (call world->getDebugger() / world->getBodyInAABBIterator() to use these classes!)
         - added support for trigger-volumes (ConvexCollision::setAsTriggerVolume ...)
         - added support for convexcasts
+            - more than one contacts are now supported (removed the hack that prevented a segfault due to an error in newton)
         - added additional debugging features:
             - raycast/convexcast debugging
             - information about each body as billboard above it

Modified: dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt_BasicJoints.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -490,6 +490,28 @@
         Ogre::Quaternion mLocalOrient1;
     };
 
+    //! CustomDryRollingFriction
+    /*!
+     * This joint is usefully to simulate the rolling friction of a rolling ball over a flat surface.
+     * Normally this is not important for non spherical objects, but for games like poll, pinball, bolling, golf
+     * or any other where the movement of balls is the main objective the rolling friction is a real big problem.
+    */
+    /* // not tested yet
+    class _OgreNewtExport CustomDryRollingFriction : public OgreNewt::CustomJoint
+    {
+        public:
+            CustomDryRollingFriction( OgreNewt::Body* child, Ogre::Real radius, Ogre::Real rollingFrictionCoefficient );
+            ~CustomDryRollingFriction();
+
+            void submitConstraint( Ogre::Real timestep, int threadIndex );
+
+        private:
+            Ogre::Real mFrictionCoefficient;
+            Ogre::Real mFrictionTorque;
+            OgreNewt::Body* mChild;
+    };
+    */
+
 }   // end NAMESPACE PrebuiltCustomJoints
 
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -179,8 +179,9 @@
         generally in a physics engine you shouldn't directly set the location/rotation of a Body, because this defies physics laws.  this command exists to set up bodies initially.
         \param orient quaternion representing body orientation in world space.
         \param pos vector representing body position in world space. 
+        \param threadIndex only set the thread-index if you don't want the node to be updated immediatly but queued (Ogre doesn't support modifying nodes from several threads)
     */
-    void setPositionOrientation( const Ogre::Vector3& pos, const Ogre::Quaternion& orient );
+    void setPositionOrientation( const Ogre::Vector3& pos, const Ogre::Quaternion& orient , int threadIndex = -1);
 
     //! set the mass and inertia for the body.
     /*!
@@ -409,6 +410,21 @@
     */
     NewtonCollision *getNewtonCollision() const { return NewtonBodyGetCollision( m_body ); }
 
+    //! Call this to signify that the position/orientation of the attached node needs to be updated
+    /*!
+     * This function actually adds this body to a list of bodies that need to be updated. This is done automaticalle after the next world update
+     * using the updateNode method.
+     * This function is needed for multithreading support
+     * \param forceNodeUpdate even request an update if there's already an update request
+    */
+    void requestNodeUpdate(int threadIndex, bool forceNodeUpdate = false);
+
+    //! Return if an node update was requested
+    bool isNodeUpdateNeeded() const {return m_nodeupdateneeded;}
+
+    //! update the position of the node (if attached) and sets m_nodeupdateneeded to false
+    void updateNode();
+
 protected:
 
     NewtonBody*                     m_body;
@@ -424,6 +440,7 @@
     
     int                             m_type;
     Ogre::Node*                     m_node;
+    bool                            m_nodeupdateneeded;
 
     ForceCallback                   m_forcecallback;
     TransformCallback               m_transformcallback;

Modified: dependencies/OgreNewt/inc/OgreNewt_Collision.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -69,12 +69,13 @@
     */
     const World* getWorld() const {return m_world;}
 
-    //! set a user ID for collision callback identification
-    /*!
-        you can set different IDs for each piece in a compound collision object, and then use these IDs in a collision callback to
-        determine which part is currently colliding.
-    */
-    void setUserID( unsigned id ) const { NewtonCollisionSetUserID( m_col, id); }
+//    this is not possible any more (since newton 2.04), you can only set the id when creating the collision
+//    //! set a user ID for collision callback identification
+//    /*!
+//        you can set different IDs for each piece in a compound collision object, and then use these IDs in a collision callback to
+//        determine which part is currently colliding.
+//    */
+//    void setUserID( unsigned id ) const { NewtonCollisionSetUserID( m_col, id); }
 
     //! get user ID, for collision callback identification
     unsigned getUserID() const { return NewtonCollisionGetUserID( m_col ); }
@@ -156,7 +157,7 @@
     ConvexModifierCollision( const OgreNewt::World* world );
 
     //! constructor
-    ConvexModifierCollision( const OgreNewt::World* world, const OgreNewt::ConvexCollisionPtr col );
+    ConvexModifierCollision( const OgreNewt::World* world, const OgreNewt::ConvexCollisionPtr col, int id );
 
     //! destructor
     ~ConvexModifierCollision();

Modified: dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -15,6 +15,7 @@
 
 #include "OgreNewt_Prerequisites.h"
 #include "OgreNewt_Collision.h"
+#include "OgreNewt_MaterialID.h"
 
 
 // OgreNewt namespace.  all functions and classes use this namespace.
@@ -54,10 +55,11 @@
             /*!
                 \param world pointer to OgreNewt::World
                 \param size vector representing width, height, depth
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
             */
-            Box( const World* world, const Ogre::Vector3& size, 
+            Box( const World* world, const Ogre::Vector3& size,  int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO );
 
             //! destructor
@@ -80,10 +82,11 @@
                 for a sphere, pass the same radius for all 3 axis.
                 \param world pointer to OgreNewt::World
                 \param size vector representing radius for all 3 axis
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
             */
-            Ellipsoid(const World* world, const Ogre::Vector3& size, 
+            Ellipsoid(const World* world, const Ogre::Vector3& size, int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO );
 
             //! destructor
@@ -107,10 +110,11 @@
                 \param world pointer to OgreNewt::World
                 \param radius radius of the cylinder (Y and Z axis)
                 \param height height of the cylinder (X axis)
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
             */
-            Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+            Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO );
 
             //! destructor
@@ -134,10 +138,11 @@
                 \param world pointer to OgreNewt::World
                 \param radius radius of the capsule (Y and Z axis)
                 \param height height of the capsule (X axis)
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
             */
-            Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
+            Capsule( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO );
 
             //! destructor
@@ -161,10 +166,11 @@
                 \param world pointer to OgreNewt::World
                 \param radius radius of the cone (Y and Z axis)
                 \param height height of the cone (X axis)
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
             */
-            Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
+            Cone( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO );
 
             //! destructor
@@ -188,10 +194,11 @@
                 \param world pointer to OgreNewt::World
                 \param radius radius of the chamfer cylinder (Y and Z axis)
                 \param height height of the chamfer cylinder (X axis)
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
             */
-            ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+            ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO );
 
             //! destructor
@@ -215,15 +222,16 @@
             //! constructor
             /*!
                 Overloaded constructor.  pass an Entity*, and it will use its vertex data. if it is attached to Node*, the collision
-                will be scaled apperently (entity->getParentNode()->getScale())
+                will be scaled apperently (entity->getParentNode()->getScale()), but if the scale changes, you need to adopt your collision by yourself
                 \param world pointer to the OgreNewt::World
-                \param node pointer to an Ogre::SceneNode with a single entity attached
+                \param ent pointer to an Ogre::Entity
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
                 \parem tolerance a tolerance passed to newton
                 \param forceScale if set to something else then (0,0,0), the value of this argument will be used as scale instead of the parent-node's scale
             */
-            ConvexHull( const World* world, Ogre::Entity* ent, 
+            ConvexHull( const World* world, Ogre::Entity* ent, int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO, Ogre::Real tolerance = 0.001f , const Ogre::Vector3& forceScale = Ogre::Vector3::ZERO);
 
             /*!
@@ -231,11 +239,12 @@
                 \param world pointer to the OgreNewt::World
                 \param verts pointer to an array of Ogre::Vector3's that contain vertex position data
                 \param vertcount number ot vetices in the array
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
                 \param tolerance a tolerance passed to newton
             */
-            ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount,
+            ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount,int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO, Ogre::Real tolerance = 0.001f );
 
             //! destructor
@@ -266,8 +275,9 @@
                 \param world pointer to the OgreNewt::World
                 \param ent pointer to an Ogre::Entitiy, if it is attached to a node, the scale of the parent node is used
                 \param optimize bool whether you want to optimize the collision or not.
+                \param id an id for this shape, can be received with collision->getUserId()
             */
-            TreeCollision( const World* world, Ogre::Entity* ent, bool optimize, FaceWinding fw = FW_DEFAULT );
+            TreeCollision( const World* world, Ogre::Entity* ent, bool optimize, int id, FaceWinding fw = FW_DEFAULT );
 
             //! constructor
             /*!
@@ -279,8 +289,9 @@
                 \param vertices pointer to array of vertices (positions only).
                 \param indices pointer to array of indices.
                 \param optimize bool whether you want to optimize the collision or not.
+                \param id an id for this shape, can be received with collision->getUserId()
             */
-            TreeCollision( const World* world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, FaceWinding fw = FW_DEFAULT); 
+            TreeCollision( const World* world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, int id, FaceWinding fw = FW_DEFAULT); 
 
             //! constructor
             /*!
@@ -291,14 +302,15 @@
                 \param vertices pointer to array of Ogre::Vector3 vertices (positions only)
                 \param indexData pointer to Ogre::IndexData for the mesh
                 \param optimize bool whether you want to optimize the collision or not.
+                \param id an id for this shape, can be received with collision->getUserId()
             */
-            TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, FaceWinding fw = FW_DEFAULT);
+            TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, int id, FaceWinding fw = FW_DEFAULT);
 
             //! destructor
             virtual ~TreeCollision() {}
 
             //! start a tree collision creation
-            void start();
+            void start(int id);
 
             //! add a poly to the tree collision
             /*!
@@ -345,7 +357,7 @@
             ~TreeCollisionSceneParser() {}
 
             //! parse the scene.
-            void parseScene( Ogre::SceneNode* startNode, bool optimize = true, FaceWinding fw = FW_DEFAULT );
+            void parseScene( Ogre::SceneNode* startNode, int id, bool optimize = true, FaceWinding fw = FW_DEFAULT );
 
         protected:
 
@@ -387,8 +399,9 @@
                 collision shapes.
                 \param world pointer to the OgreNewt::World
                 \param col_array std::vector of pointers to existing collision objects.
+                \param id an id for this shape, can be received with collision->getUserId()
             */
-            CompoundCollision( const World* world, std::vector<OgreNewt::CollisionPtr> col_array );
+            CompoundCollision( const World* world, std::vector<OgreNewt::CollisionPtr> col_array, int id );
 
             //! destructor
             ~CompoundCollision() {}
@@ -418,11 +431,12 @@
             /*!
                 \param world pointer to the OgreNewt::World
                 \param size Ogre::Vector3 size.
+                \param id an id for this shape, can be received with collision->getUserId()
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
                 \param tolerance a tolerance passed to newton
             */
-            Pyramid( const World* world, const Ogre::Vector3& size,
+            Pyramid( const World* world, const Ogre::Vector3& size, int id,
                 const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO, Ogre::Real tolerance = 0.001f );
 
             //! destructor

Modified: dependencies/OgreNewt/inc/OgreNewt_Joint.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -125,6 +125,8 @@
     //! must be over-written for a functioning joint.
     virtual void submitConstraint( Ogre::Real timeStep, int threadIndex ) = 0;
 
+    //! can be overwritten, empty as default
+    virtual void feedbackCollector( Ogre::Real timeSte, int threadIndex ) {}
 
     //! find the local orientation and position of the joint with regards to the 2 bodies in the joint.
     void pinAndDirToLocal( const Ogre::Vector3& pinpt, const Ogre::Vector3& pindir, Ogre::Quaternion& localOrient0, Ogre::Vector3& localPos0, Ogre::Quaternion& localOrient1, Ogre::Vector3& localPos1 ) const;
@@ -132,6 +134,9 @@
     //! find the global orientation and position of the joint with regards to the a body in the joint.
     void localToGlobal( const Ogre::Quaternion& localOrient, const Ogre::Vector3& localPos, Ogre::Quaternion& globalOrient, Ogre::Vector3& globalPos, int bodyIndex = 0 ) const;
 
+    //! find the local orientation and position of the joint with regards to the a body in the joint.
+    void globalToLocal( const Ogre::Quaternion& localOrient, const Ogre::Vector3& localPos, Ogre::Quaternion& globalOrient, Ogre::Vector3& globalPos, int bodyIndex = 0 ) const;
+
     //! add a linear row to the constraint.
     void addLinearRow( const Ogre::Vector3& pt0, const Ogre::Vector3& pt1, const Ogre::Vector3& dir ) const;
 
@@ -177,6 +182,7 @@
     //! newton callback.  used internally.
     static void _CDECL newtonSubmitConstraint( const NewtonJoint* me, float timeStep, int threadIndex );
     static void _CDECL newtonGetInfo( const NewtonJoint* me, NewtonJointRecord* info );
+    static void _CDECL newtonFeedbackCollector( const NewtonJoint* me, float timeStep, int threadIndex );
 
 };
 

Modified: dependencies/OgreNewt/inc/OgreNewt_PlayerController.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_PlayerController.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt_PlayerController.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -28,25 +28,44 @@
 class _OgreNewtExport PlayerController : public CustomJoint
 {
 public:
+    //! state of the player
+    enum PlayerState
+    {
+        PS_ONLAND,
+        PS_ONFREEFALL,
+        PS_ONILLEGALRAMP
+    };
+
+    typedef std::vector<OgreNewt::Body*> BodyVector;
+
     //! constructor
-    PlayerController(OgreNewt::Body* child);
+    /*!
+     * \param localFrame this is the player frame in global Space (x: side, y: up, -z forward)
+    */
+    PlayerController(OgreNewt::Body* child, Ogre::Real stairHeight, Ogre::Real kinematicCushion = 1.0f/64.0f, const Ogre::Matrix3& localFrame = Ogre::Matrix3::IDENTITY);
     virtual ~PlayerController();
 
     //! get controlled body
     OgreNewt::Body* getControlledBody() const {return m_body;}
 
     //! set the characters velocity, the -Speed-values can be negative, sideSpeed positiv means move to the right, heading is in absolute space
-    void setVelocity(Ogre::Real forwardSpeed, Ogre::Real sideSpeed, Ogre::Degree heading);
+    void setVelocity(Ogre::Real forwardSpeed, Ogre::Real sideSpeed, Ogre::Radian heading);
 
     //! get currently set velocity
     void getVelocity(Ogre::Real &forwardSpeed, Ogre::Real& sideSpeed, Ogre::Radian& heading) const;
 
     //! set maximum step height (as absolute value)
-    void setMaxStepHeight(Ogre::Real maxStepHeight);
+    void setStairHeight(Ogre::Real stairHeight);
 
     //! get currently set maximum step height
-    Ogre::Real getMaxStepHeight() const;
+    Ogre::Real getStairHeight() const;
 
+    //! set kinematic cushion
+    void setKinematicCushion(Ogre::Real cushion);
+
+    //! get currently set kinematic cushioin
+    Ogre::Real getKinematicCushion() const;
+
     //! set maximum slope
     void setMaxSlope(Ogre::Radian maxSlope);
 
@@ -59,120 +78,96 @@
     //! get currently set restitution
     Ogre::Real getRestitution() const;
 
-    // not supported yet
-    // set up-vector pin
-    //void setPinVector(Ogre::Vector3 upVector);
-    // get currently set up-vector pin
-    //Ogre::Vector3 getPinVector() const;
+    //! retrieve player state
+    PlayerState getPlayerState() const;
 
-    //! is the body currently in the air (jumpin?)
-    bool isInJumpState() const;
+    //! set player state, use this only in order to reset the player
+    void setPlayerState(PlayerState state);
 
-    //! can be overwritten to specify if a body can be pushed away by this character
-    virtual bool canPushBody(const OgreNewt::Body *hitBody) const {return true;}
-
     //! overwritten function from CustomJoint, must *NOT* be overwritten
     virtual void submitConstraint( Ogre::Real timestep, int threadindex );
 
+    //! overwritten function from CustomJoint, must *NOT* be overwritten
+    virtual void feedbackCollector( Ogre::Real timestep, int threadindex );
+
+    //! udate player controller geometry, call this if the shape of the controlled body has changed...
+    void updateGeometry();
+
 protected:
     OgreNewt::Body *m_body; // we need this again, because in the joint it's constant!
 
-    Ogre::Real m_forwardSpeed, m_sideSpeed, m_maxStepHeight, m_restitution;
+    Ogre::Matrix4 m_localFrame;
+    Ogre::Real m_forwardSpeed, m_sideSpeed, m_stairHeight, m_restitution, m_kinematicCushion, m_maxRadius;
     Ogre::Radian m_heading, m_maxSlope;
-    Ogre::Vector3 m_upVector;
 
-    bool m_isInJumpState;
-    OgreNewt::ConvexCollisionPtr m_verticalSensorShape;
-    OgreNewt::ConvexCollisionPtr m_horizontalSensorShape;
-    OgreNewt::ConvexCollisionPtr m_dynamicsSensorShape;
+    PlayerState m_playerState;
+    Ogre::Vector3 m_gravity;
+    OgreNewt::ConvexCollisionPtr m_bodySensorShape;
+    OgreNewt::ConvexCollisionPtr m_stairSensorShape;
+    OgreNewt::ConvexCollisionPtr m_bodyFloorSensorShape;
 
-    virtual bool convexStaticCastPreFilter(OgreNewt::Body *body);
-    virtual bool convexDynamicCastPreFilter(OgreNewt::Body *body);
-    virtual bool convexAllBodyCastPreFilter(OgreNewt::Body *body);
-    virtual bool findFloorCastPreFilter(OgreNewt::Body *body);
+    virtual bool convexStaticCastPreFilter(OgreNewt::Body *body, BodyVector filterBodies);
+    virtual bool convexAllBodyCastPreFilter(OgreNewt::Body *body, BodyVector filterBodies);
 
-    // helper function, used internally
-    void getPlayerHeightAndRadius(Ogre::Real &height, Ogre::Real &radius);
-
     // parameters for the updateSenesorShapes-function, these are set in the constructor!
     Ogre::Real m_staticRadiusFactor, m_dynamicRadiusFactor, m_floorFinderRadiusFactor, m_maxPlayerHeightPaddFactor;
-    int m_sensorShapeSegments;
-    // internal values, only used in updateSensorShapes!
-    Ogre::Real m_lastPlayerHeight, m_lastPlayerRadius, m_lastSensorHeight;
-    // helper function
-    void updateSensorShapes();
 
 
     // other parameters
+    int m_sensorShapeSegments;
     int m_maxCollisionsIteration;
     int m_maxContactsCount;
 
     // variables used in submitConstraint
     Ogre::Quaternion m_lastOri;
 
-private:
-    // we need overloaded versions of the raycasts...
-    class FindFloorRaycast : public OgreNewt::BasicRaycast
-    {
-        public:
-            FindFloorRaycast(PlayerController *pc, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool sorted) :
-                    BasicRaycast(pc->getControlledBody()->getWorld(), startpt, endpt, sorted),
-                    m_parent(pc)
-                {}
 
-            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->findFloorCastPreFilter(body);}
-        private:
-            OgreNewt::PlayerController* m_parent;
-    };
+    // kinematic motion: (called from feedbackCollector)
+    void playerOnLand( Ogre::Real timestep, int threadindex );
+    void playerOnFreeFall( Ogre::Real timestep, int threadindex );
+    void playerOnIllegalRamp( Ogre::Real timestep, int threadindex );
 
+    // calculate velocity (see if the player can move there etc)
+    Ogre::Vector3 calculateVelocity(const Ogre::Vector3& targetVel, Ogre::Real timestep, const Ogre::Vector3& upDir, Ogre::Real elevation, int threadindex);
+    
+
+private:
+    // we need overloaded versions of the raycasts...
     class StaticConvexCast : public OgreNewt::BasicConvexcast
     {
         public:
             StaticConvexCast(PlayerController *pc) : m_parent(pc) {}
 
             void go(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt,
-                    const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
+                    const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread, BodyVector filterBodies = BodyVector())
             {
+                m_filterBodies = filterBodies;
                 go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);
             }
 
-            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexStaticCastPreFilter(body);}
+            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexStaticCastPreFilter(body, m_filterBodies);}
         private:
             OgreNewt::PlayerController* m_parent;
+            BodyVector m_filterBodies;
             using BasicConvexcast::go;
     };
 
-    class DynamicConvexCast : public OgreNewt::BasicConvexcast
-    {
-        public:
-            DynamicConvexCast(PlayerController *pc) : m_parent(pc) {}
-
-            void go(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt,
-                    const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
-            {
-                go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);
-            }
-
-            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexDynamicCastPreFilter(body);}
-        private:
-            OgreNewt::PlayerController* m_parent;
-            using BasicConvexcast::go;
-    };
-
     class AllBodyConvexCast : public OgreNewt::BasicConvexcast
     {
         public:
             AllBodyConvexCast(PlayerController *pc) : m_parent(pc) {}
 
             void go(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt,
-                    const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
+                    const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread, BodyVector filterBodies = BodyVector())
             {
+                m_filterBodies = filterBodies;
                 go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);
             }
 
-            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexAllBodyCastPreFilter(body);}
+            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexAllBodyCastPreFilter(body, m_filterBodies);}
         private:
             OgreNewt::PlayerController* m_parent;
+            BodyVector m_filterBodies;
             using BasicConvexcast::go;
     };
 };

Modified: dependencies/OgreNewt/inc/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_World.h	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/inc/OgreNewt_World.h	2009-08-21 16:29:49 UTC (rev 4952)
@@ -11,6 +11,9 @@
 #ifndef _INCLUDE_OGRENEWT_WORLD
 #define _INCLUDE_OGRENEWT_WORLD
 
+#ifndef WIN32
+#include <pthread.h>
+#endif
 
 #include "OgreNewt_Prerequisites.h"
 #include "OgreNewt_BodyInAABBIterator.h"
@@ -64,7 +67,7 @@
 
 public:
     //! Standard Constructor, creates the world.
-    World();
+    World( NewtonAllocMemory newtonAlloc = NULL, NewtonFreeMemory newtonFree = NULL );
 
     //! Standard Destructor, destroys the world.
     ~World();       
@@ -127,6 +130,13 @@
     */
     void setPlatformArchitecture( int mode ) { NewtonSetPlatformArchitecture( m_world, mode ); }
 
+    //! get the architecture used for physics calculations.
+    /*!
+        \param description returns a description-string for the currently used mode
+        \return int representing the current mode
+    */
+    int getPlatformArchitecture(Ogre::String& description) { char desc[265]; int mode = NewtonGetPlatformArchitecture( m_world, desc ); description = desc; return mode;}
+
     //! get the number of bodies in the simulation.
     /*!
         returns the number of bodies in the simulation.
@@ -139,17 +149,20 @@
     //! multithread settings
     void setMultithreadSolverOnSingleIsland( int mode ) { NewtonSetMultiThreadSolverOnSingleIsland( m_world, mode ); }
 
-    //! set the number of threads for the physics simulation to use.
+    //! get multithread settings
+    int getMultithreadSolverOnSingleIsland( ) const { return NewtonGetMultiThreadSolverOnSingleIsland( m_world ); }
+
+    //! set the number of threads for the physics simulation to use, don't do this while world update
     void setThreadCount(int threads) { NewtonSetThreadsCount( m_world, threads ); }
 
     //! get the number of threads the simulation is using.
     int getThreadCount() const { return NewtonGetThreadsCount( m_world ); }
 
     //! notify an entrance to a critical section of code.
-    void criticalSectionLock() { NewtonWorldCriticalSectionLock( m_world ); }
+    void criticalSectionLock() const { NewtonWorldCriticalSectionLock( m_world ); }
 
     //! notify the exit of a critical section of code.
-    void cricicalSectionUnlock() { NewtonWorldCriticalSectionUnlock( m_world ); }
+    void criticalSectionUnlock() const { NewtonWorldCriticalSectionUnlock( m_world ); }
 
     //! set minimum framerate
     void setMinimumFrameRate( Ogre::Real frame ) { NewtonSetMinimumFrameRate( m_world, frame ); }
@@ -205,17 +218,50 @@
     */
     Debugger& getDebugger() const {return *m_debugger;}
 
+    //! adds an update request for the body, this means that after the next world update the function body->updateNode will be called, if the bodie needs updating
+    void addBodyUpdateNodeRequest( int threadIndex, OgreNewt::Body* body ) const ;
+
+
+#ifndef WIN32
+    //! notify an entrance to a critical section of code concerning Ogre (and only concerning Ogre!)
+    /*!
+     * This function is only used in OgreNewt and can be used by the user, it is independent of Ogre's own thread support...
+    */
+    void ogreCriticalSectionLock() const { pthread_mutex_lock(&m_ogreMutex); }
+
+    //! notify the exit of a critical section of code concerning Ogre (and only concerning Ogre!)
+    /*!
+     * This function is only used in OgreNewt and can be used by the user, it is independent of Ogre's own thread support...
+    */
+    void ogreCriticalSectionUnlock() const { pthread_mutex_unlock(&m_ogreMutex); }
+
+    //! notify an entrance to a critical section of code concerning Ogre (and only concerning Ogre!)
+    /*!
+     * This function is only used in OgreNewt and can be used by the user, it is independent of Ogre's own thread support...
+     * \return true if not already locked
+    */
+    // bool ogreCriticalSectionTryLock() const { return (EBUSY != pthread_mutex_trylock(&m_ogreMutex)); }
+#endif
+
 protected:
     
     NewtonWorld* m_world;
     MaterialID* m_defaultMatID;
 
     LeaveWorldCallback m_leaveCallback;
-    
+
     BodyInAABBIterator m_bodyInAABBIterator;
 
+    typedef std::vector< OgreNewt::Body* > BodyVector;
+    typedef std::vector< BodyVector > BodyVectorVector;
+    mutable BodyVectorVector m_bodyUpdateNodeRequests;
+
     mutable Debugger* m_debugger;
 
+#ifndef WIN32
+    mutable pthread_mutex_t m_ogreMutex;
+#endif
+
 private:
 
     static void _CDECL newtonLeaveWorld( const NewtonBody* body, int threadIndex );

Modified: dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -604,8 +604,53 @@
     addAngularRow( angle, globalOrient0 * Ogre::Vector3::UNIT_X );
 }
 
+/*
+CustomDryRollingFriction::CustomDryRollingFriction( OgreNewt::Body* child, Ogre::Real radius, Ogre::Real rollingFrictionCoefficient ) :
+    OgreNewt::CustomJoint(1, child, NULL),
+    mChild(child)
+{
+    Ogre::Real mass;
+    Ogre::Vector3 inertia;
 
+    child->getMassMatrix( mass, inertia );
 
+    mFrictionCoefficient =  rollingFrictionCoefficient;
+    mFrictionTorque = inertia.x * radius;
+}
+
+CustomDryRollingFriction::~CustomDryRollingFriction()
+{
+}
+
+
+// copied from CustomDryRollingFriction joint in newton
+void CustomDryRollingFriction::submitConstraint( Ogre::Real timestep, int threadIndex )
+{
+    Ogre::Vector3 omega;
+    Ogre::Real omegaMag;
+    Ogre::Real torqueFriction;
+
+
+    omega = mChild->getOmega();
+    omegaMag = omega.length();
+
+    if( omegaMag > 0.1f )
+    {
+        addAngularRow(Ogre::Radian(0), omega.normalisedCopy());
+        setRowAcceleration( -omegaMag/timestep );
+        torqueFriction = mFrictionTorque*mFrictionCoefficient;
+        setRowMinimumFriction(-torqueFriction);
+        setRowMaximumFriction(torqueFriction);
+    }
+    else
+    {
+        mChild->setOmega(omega*0.2f);
+    }
+
+}
+*/
+
+
 }   // end NAMESPACE PrebuiltCustomJoints
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_Body.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -23,6 +23,8 @@
     m_transformcallback = NULL;
     m_buoyancycallback = NULL;
 
+    m_nodeupdateneeded = false;
+
     m_body = NewtonCreateBody( m_world->getNewtonWorld(), col->getNewtonCollision() ); 
 
     NewtonBodySetUserData( m_body, this );
@@ -100,8 +102,7 @@
 
 void Body::standardTransformCallback( OgreNewt::Body* me, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, int threadIndex )
 {
-    me->m_node->setOrientation( orient );
-    me->m_node->setPosition( pos );
+    me->requestNodeUpdate(threadIndex);
 }
 
 
@@ -140,11 +141,16 @@
     m_node = node;
     if (m_body)
     {
-        setCustomTransformCallback( &Body::standardTransformCallback );
+        if( m_node )
+            setCustomTransformCallback( &Body::standardTransformCallback );
+        else
+            setCustomTransformCallback( NULL );
+
+        updateNode();
     }
 }
 
-void Body::setPositionOrientation( const Ogre::Vector3& pos, const Ogre::Quaternion& orient )
+void Body::setPositionOrientation( const Ogre::Vector3& pos, const Ogre::Quaternion& orient, int threadIndex)
 {
     if (m_body)
     {
@@ -155,8 +161,10 @@
 
         if (m_node)
         {
-            m_node->setOrientation( orient );
-            m_node->setPosition( pos );
+            if( threadIndex != -1 )
+                requestNodeUpdate(threadIndex);
+            else
+                updateNode();
         }
     }
 }
@@ -342,7 +350,10 @@
     Ogre::Quaternion bodyorient;
     getPositionOrientation( bodypos, bodyorient );
 
-    Ogre::Vector3 topoint = pos - bodypos;
+    Ogre::Vector3 localMassCenter = getCenterOfMass();
+    Ogre::Vector3 globalMassCenter = bodyorient * localMassCenter;
+
+    Ogre::Vector3 topoint = pos - bodypos - globalMassCenter;
     Ogre::Vector3 torque = topoint.crossProduct( force );
 
     addForce( force );
@@ -371,7 +382,41 @@
     return NULL;
 }
 
+void Body::requestNodeUpdate( int threadIndex, bool forceNodeUpdate )
+{
+    if( !m_node )
+        return;
 
+    if( m_nodeupdateneeded && !forceNodeUpdate )
+        return;
+
+    m_nodeupdateneeded = true;
+
+    m_world->addBodyUpdateNodeRequest( threadIndex, this );
+}
+
+void Body::updateNode()
+{
+    m_nodeupdateneeded = false;
+
+    if( !m_node )
+        return;
+
+    Ogre::Vector3 pos;
+    Ogre::Quaternion orient;
+    getPositionOrientation(pos, orient);
+
+#ifndef WIN32
+    m_world->ogreCriticalSectionLock();
+#endif
+    m_node->setPosition(pos);
+    m_node->setOrientation(orient);
+#ifndef WIN32
+    m_world->ogreCriticalSectionUnlock();
+#endif
+}
+
+
 // --------------------------------------------------------------------------------------
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_Collision.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Collision.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_Collision.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -70,9 +70,9 @@
 {
 }
 
-ConvexModifierCollision::ConvexModifierCollision(const World* world, const ConvexCollisionPtr col) : ConvexCollision(world)
+ConvexModifierCollision::ConvexModifierCollision(const World* world, const ConvexCollisionPtr col, int id) : ConvexCollision(world)
 {
-    m_col = NewtonCreateConvexHullModifier( world->getNewtonWorld(), col->getNewtonCollision() );
+    m_col = NewtonCreateConvexHullModifier( world->getNewtonWorld(), col->getNewtonCollision(), id );
 }
 
 ConvexModifierCollision::~ConvexModifierCollision()

Modified: dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -30,13 +30,13 @@
         Box::Box(const World* world) : ConvexCollision( world )
         {}
 
-        Box::Box( const World* world, const Ogre::Vector3& size, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
+        Box::Box( const World* world, const Ogre::Vector3& size, int id, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
         {
             float matrix[16];
 
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
-            m_col = NewtonCreateBox( m_world->getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &matrix[0] );
+            m_col = NewtonCreateBox( m_world->getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, id, &matrix[0] );
         }
 
 
@@ -45,13 +45,13 @@
         Ellipsoid::Ellipsoid(const World* world) : ConvexCollision( world )
         {}
 
-        Ellipsoid::Ellipsoid( const World* world, const Ogre::Vector3& size, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
+        Ellipsoid::Ellipsoid( const World* world, const Ogre::Vector3& size, int id, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
         {
             float matrix[16];
 
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
-            m_col = NewtonCreateSphere( m_world->getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &matrix[0] );
+            m_col = NewtonCreateSphere( m_world->getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, id, &matrix[0] );
         }
 
 
@@ -59,14 +59,14 @@
         Cylinder::Cylinder(const World* world) : ConvexCollision( world )
         {}
 
-        Cylinder::Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+        Cylinder::Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                                     const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
         {
             float matrix[16];
 
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
-            m_col = NewtonCreateCylinder( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
+            m_col = NewtonCreateCylinder( m_world->getNewtonWorld(), (float)radius, (float)height, id, &matrix[0] );
         }
 
 
@@ -74,14 +74,14 @@
         Capsule::Capsule(const World* world) : ConvexCollision( world )
         {}
 
-        Capsule::Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
+        Capsule::Capsule( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                                     const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
         {
             float matrix[16];
 
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
-            m_col = NewtonCreateCapsule( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
+            m_col = NewtonCreateCapsule( m_world->getNewtonWorld(), (float)radius, (float)height, id, &matrix[0] );
         }
 
 
@@ -89,28 +89,28 @@
         Cone::Cone(const World* world) : ConvexCollision( world )
         {}
 
-        Cone::Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
+        Cone::Cone( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                                     const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
         {
             float matrix[16];
 
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
-            m_col = NewtonCreateCone( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
+            m_col = NewtonCreateCone( m_world->getNewtonWorld(), (float)radius, (float)height, id, &matrix[0] );
         }
 
         // OgreNewt::CollisionPrimitives::ChamferCylinder
         ChamferCylinder::ChamferCylinder(const World* world) : ConvexCollision( world )
         {}
 
-        ChamferCylinder::ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
+        ChamferCylinder::ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, int id,
                                     const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
         {
             float matrix[16];
 
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
-            m_col = NewtonCreateChamferCylinder( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
+            m_col = NewtonCreateChamferCylinder( m_world->getNewtonWorld(), (float)radius, (float)height, id, &matrix[0] );
         }
 
 
@@ -119,7 +119,7 @@
         ConvexHull::ConvexHull(const World* world) : ConvexCollision( world )
         {}
 
-        ConvexHull::ConvexHull( const World* world, Ogre::Entity* obj, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance, const Ogre::Vector3& forceScale ) : ConvexCollision( world )
+        ConvexHull::ConvexHull( const World* world, Ogre::Entity* obj, int id, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance, const Ogre::Vector3& forceScale ) : ConvexCollision( world )
         {
             Ogre::Vector3 scale(1.0,1.0,1.0);
             
@@ -235,7 +235,7 @@
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
     
             //okay, let's try making the ConvexHull!
-            m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), (int)total_verts, (float*)&vertices[0].x, sizeof(Ogre::Vector3), tolerance, &matrix[0] );
+            m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), (int)total_verts, (float*)&vertices[0].x, sizeof(Ogre::Vector3), tolerance, id, &matrix[0] );
 
             delete []vertices;
 
@@ -243,13 +243,13 @@
 
 
         // OgreNewt::CollisionPrimitives::ConvexHull
-        ConvexHull::ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance ) : ConvexCollision( world )
+        ConvexHull::ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount, int id, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance ) : ConvexCollision( world )
         {
             float matrix[16];
             OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
             //make the collision primitive.
-            m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), vertcount, (float*)&verts[0].x, sizeof(Ogre::Vector3), tolerance, &matrix[0]);
+            m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), vertcount, (float*)&verts[0].x, sizeof(Ogre::Vector3), tolerance, id, &matrix[0]);
         }
 
 
@@ -260,11 +260,11 @@
         }
 
 
-        TreeCollision::TreeCollision( const World* world, Ogre::Entity* obj, bool optimize, FaceWinding fw ) : Collision( world )
+        TreeCollision::TreeCollision( const World* world, Ogre::Entity* obj, bool optimize, int id, FaceWinding fw ) : Collision( world )
         {
             Ogre::Vector3 scale;
 
-            start();
+            start(id);
 
             Ogre::MeshPtr mesh = obj->getMesh();
 
@@ -394,9 +394,9 @@
         }
 
 
-        TreeCollision::TreeCollision(const OgreNewt::World *world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, FaceWinding fw) : OgreNewt::Collision( world )
+        TreeCollision::TreeCollision(const OgreNewt::World *world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize, int id, FaceWinding fw) : OgreNewt::Collision( world )
         {
-            start();
+            start(id);
  
             int numPolys = numIndices / 3;
  
@@ -435,9 +435,9 @@
         }
 
 
-        TreeCollision::TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, FaceWinding fw) : Collision( world )
+        TreeCollision::TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize, int id, FaceWinding fw) : Collision( world )
         {
-            start();
+            start(id);
 
             unsigned int numPolys = indexData->indexCount / 3;
             Ogre::HardwareIndexBufferSharedPtr hwIndexBuffer=indexData->indexBuffer;
@@ -499,9 +499,9 @@
         } 
 
 
-        void TreeCollision::start()
+        void TreeCollision::start(int id)
         {
-            m_col = NewtonCreateTreeCollision( m_world->getNewtonWorld() );
+            m_col = NewtonCreateTreeCollision( m_world->getNewtonWorld(), id );
             NewtonTreeCollisionBeginBuild( m_col );
         }
 
@@ -546,11 +546,11 @@
         {
         }
         
-        void TreeCollisionSceneParser::parseScene( Ogre::SceneNode *startNode, bool optimize, FaceWinding fw)
+        void TreeCollisionSceneParser::parseScene( Ogre::SceneNode *startNode, int id, bool optimize, FaceWinding fw)
         {
             count = 0;
 
-            start();
+            start(id);
 
             // parse the individual nodes.
             Ogre::Quaternion rootOrient = Ogre::Quaternion::IDENTITY;
@@ -720,7 +720,7 @@
         CompoundCollision::CompoundCollision(const World* world) : Collision( world )
         {}
         
-        CompoundCollision::CompoundCollision( const World* world, std::vector<OgreNewt::CollisionPtr> col_array ) : Collision( world )
+        CompoundCollision::CompoundCollision( const World* world, std::vector<OgreNewt::CollisionPtr> col_array, int id ) : Collision( world )
         {
             //get the number of elements.
             unsigned int num = col_array.size();
@@ -733,7 +733,7 @@
                 array[i] = (NewtonCollision*)col_array[i]->getNewtonCollision();
             }
 
-            m_col = NewtonCreateCompoundCollision( world->getNewtonWorld(), num, array );
+            m_col = NewtonCreateCompoundCollision( world->getNewtonWorld(), num, array, id );
 
 
             delete[] array;
@@ -744,7 +744,7 @@
         Pyramid::Pyramid(const World* world) : ConvexCollision( world )
         {}
 
-        Pyramid::Pyramid( const World* world, const Ogre::Vector3& size, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance ) : ConvexCollision( world )
+        Pyramid::Pyramid( const World* world, const Ogre::Vector3& size, int id, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance ) : ConvexCollision( world )
         {
             float matrix[16];
 
@@ -773,7 +773,7 @@
             vertices [idx++] = 0.0f;
 
             //make the collision primitive.
-            m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), 5, vertices, sizeof(float)*3, tolerance, &matrix[0]);
+            m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), 5, vertices, sizeof(float)*3, tolerance, id, &matrix[0]);
 
 
             delete []vertices;

Modified: dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -284,7 +284,6 @@
 {
     m_recordraycasts = true;
     m_markhitbodies = markhitbodies;
-    clearRaycastsRecorded();
 }
 
 bool Debugger::isRaycastRecording()
@@ -339,7 +338,6 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__Raycastline__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
-    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_raycol);
@@ -347,7 +345,14 @@
     line->position(endpt);
     line->end();
 
-    m_raycastsnode->attachObject(line);    
+#ifndef WIN32
+    m_world->ogreCriticalSectionLock();
+#endif
+    mRecordedRaycastObjects.push_back(line);
+    m_raycastsnode->attachObject(line);
+#ifndef WIN32
+    m_world->ogreCriticalSectionUnlock();
+#endif
 }
 
 void Debugger::addConvexRay(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3 &startpt, const Ogre::Quaternion &colori, const Ogre::Vector3 &endpt)
@@ -360,7 +365,6 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__Convexcastlines__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
-    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_convexcol);
@@ -397,7 +401,16 @@
 
 
     line->end();
+
+
+#ifndef WIN32
+    m_world->ogreCriticalSectionLock();
+#endif
+    mRecordedRaycastObjects.push_back(line);
     m_raycastsnode->attachObject(line);
+#ifndef WIN32
+    m_world->ogreCriticalSectionUnlock();
+#endif
 }
 
 void Debugger::addDiscardedBody(const OgreNewt::Body* body)
@@ -413,7 +426,6 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__DiscardedBody__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
-    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_prefilterdiscardedcol);
@@ -423,7 +435,16 @@
     NewtonCollisionForEachPolygonDo( body->getCollision()->getNewtonCollision() , &matrix[0], newtonPerPoly, line );
 
     line->end();
+
+
+#ifndef WIN32
+    m_world->ogreCriticalSectionLock();
+#endif
+    mRecordedRaycastObjects.push_back(line);
     m_raycastsnode->attachObject(line);
+#ifndef WIN32
+    m_world->ogreCriticalSectionUnlock();
+#endif
 }
 
 void Debugger::addHitBody(const OgreNewt::Body* body)
@@ -439,7 +460,6 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__HitBody__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
-    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_hitbodycol);
@@ -449,7 +469,15 @@
     NewtonCollisionForEachPolygonDo( body->getCollision()->getNewtonCollision() , &matrix[0], newtonPerPoly, line );
 
     line->end();
+
+#ifndef WIN32
+    m_world->ogreCriticalSectionLock();
+#endif
+    mRecordedRaycastObjects.push_back(line);
     m_raycastsnode->attachObject(line);
+#ifndef WIN32
+    m_world->ogreCriticalSectionUnlock();
+#endif
 }
 
 }   // end namespace OgreNewt

Modified: dependencies/OgreNewt/src/OgreNewt_Joint.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Joint.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_Joint.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -62,6 +62,7 @@
 
     NewtonJointSetUserData (m_joint, this);
     NewtonJointSetDestructor (m_joint, destructor);
+    NewtonUserJointSetFeedbackCollectorCallback( m_joint, CustomJoint::newtonFeedbackCollector );
 
 }
 
@@ -118,8 +119,32 @@
     globalOrient = bodyOrient * localOrient;
 }
 
-    
 
+void CustomJoint::globalToLocal( const Ogre::Quaternion& globalOrient, const Ogre::Vector3& globalPos, Ogre::Quaternion& localOrient, Ogre::Vector3& localPos, int bodyIndex ) const
+{
+    localOrient = Ogre::Quaternion::IDENTITY;
+    localPos= Ogre::Vector3::ZERO;
+
+    const Body* bdy = NULL;
+    if (bodyIndex == 0)
+        bdy = m_body0;
+    else if (m_body1)
+        bdy = m_body1;
+
+    Ogre::Quaternion bodyOrient = Ogre::Quaternion::IDENTITY;
+    Ogre::Vector3 bodyPos = Ogre::Vector3::ZERO;
+
+    if (bdy)
+        bdy->getPositionOrientation( bodyPos, bodyOrient );
+
+    Ogre::Quaternion bodyOrientInv = bodyOrient.Inverse();
+
+    localOrient = bodyOrientInv * globalOrient;
+    localPos = bodyOrientInv * (globalPos - bodyPos);
+}
+
+
+
 void CustomJoint::addLinearRow( const Ogre::Vector3& pt0, const Ogre::Vector3& pt1, const Ogre::Vector3& dir ) const
 {
     NewtonUserJointAddLinearRow( m_joint, &pt0.x, &pt1.x, &dir.x );
@@ -187,7 +212,14 @@
     j->submitConstraint( (Ogre::Real)timeStep, threadIndex );
 }
 
+void _CDECL CustomJoint::newtonFeedbackCollector( const NewtonJoint* me, float timeStep, int threadIndex )
+{
+    CustomJoint* j = (CustomJoint*)NewtonJointGetUserData( me );
 
+    j->feedbackCollector( (Ogre::Real)timeStep, threadIndex );
+}
+
+
 void _CDECL CustomJoint::newtonGetInfo(const NewtonJoint *me, NewtonJointRecord *info)
 {
     CustomJoint* j = (CustomJoint*)NewtonJointGetUserData( me );

Modified: dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -1,704 +1,680 @@
-#include "OgreNewt_PlayerController.h"
-#include "OgreNewt_Tools.h"
-#include "OgreNewt_Collision.h"
-#include "OgreNewt_CollisionPrimitives.h"
-#include "OgreNewt_World.h"
-
-#include <vector>
-#include <iostream>
-
-namespace OgreNewt
-{
-
-PlayerController::PlayerController(OgreNewt::Body * child) :
-    CustomJoint(6, child, NULL),
-    m_body(child)
-{
-    // initialize some non settable parameters
-    m_maxCollisionsIteration = 8;
-    m_maxContactsCount = 16;
-    // initialize settable values
-    m_forwardSpeed = 0;
-    m_sideSpeed = 0;
-    m_heading = Ogre::Radian(0);
-    Ogre::Real playerHeight, playerRadius;
-    getPlayerHeightAndRadius(playerHeight, playerRadius);
-    m_maxStepHeight = playerHeight / 4;
-    m_maxSlope = Ogre::Degree(45);
-    m_restitution = 0;
-    m_upVector = Ogre::Vector3::UNIT_Y;
-    m_isInJumpState = false;
-
-    Ogre::Vector3 pos;
-    m_body->getPositionOrientation(pos, m_lastOri);
-
-
-
-    // initialize sensor-shape parameters
-    m_staticRadiusFactor = 1.125f;
-    m_dynamicRadiusFactor = 1.5f;
-    m_floorFinderRadiusFactor = 1.0f;
-    m_maxPlayerHeightPaddFactor = 0.01f;
-    m_sensorShapeSegments = 32;
-#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
-    m_verticalSensorShape = NULL;
-    m_horizontalSensorShape = NULL;
-    m_dynamicsSensorShape = NULL;
-#endif
-
-
-    updateSensorShapes();
-}
-
-PlayerController::~PlayerController()
-{
-#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
-    if( m_verticalSensorShape )
-        delete m_verticalSensorShape;
-    if( m_horizontalSensorShape )
-        delete m_horizontalSensorShape;
-    if( m_dynamicsSensorShape )
-        delete m_dynamicsSensorShape;
-#endif
-}
-
-void PlayerController::updateSensorShapes()
-{
-    Ogre::Real newPlayerRadius, newPlayerHeight, newSensorHeight;
-    // is this the first time, this function gets calles?
-    if( m_verticalSensorShape == NULL )
-    {
-        // initialize values, so they aren't arbitrary!
-        m_lastPlayerRadius = newPlayerRadius = 0;
-        m_lastPlayerHeight = newPlayerHeight = 0;
-        m_lastSensorHeight = newSensorHeight = 0;
-    }
-
-    // calculate new Values:
-    getPlayerHeightAndRadius(newPlayerHeight, newPlayerRadius);
-    newPlayerHeight += newPlayerHeight * m_maxPlayerHeightPaddFactor;
-    newSensorHeight = (newPlayerHeight - m_maxStepHeight) * 0.5f;
-
-
-    // do we need to update the shapes?
-    if( m_verticalSensorShape == NULL || 
-        abs( newPlayerHeight - m_lastPlayerHeight ) > 0.04f ||
-        abs( newSensorHeight - m_lastSensorHeight ) > 0.04f ||
-        abs( newPlayerRadius - m_lastPlayerRadius ) > 0.04f )
-    {
-#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
-        // delete old ones
-        if( m_verticalSensorShape )
-            delete m_verticalSensorShape;
-        if( m_horizontalSensorShape )
-            delete m_horizontalSensorShape;
-        if( m_dynamicsSensorShape )
-            delete m_dynamicsSensorShape;
-#endif
-
-        m_lastPlayerRadius = newPlayerRadius;
-        m_lastSensorHeight = newSensorHeight;
-        m_lastPlayerHeight = newPlayerHeight;
-
-        
-        Ogre::Vector3 *dynamicsSensorPoints = new Ogre::Vector3[m_sensorShapeSegments*2];
-        Ogre::Vector3 *verticalSensorPoints = new Ogre::Vector3[m_sensorShapeSegments*2];
-        Ogre::Vector3 *horizontalSensorPoints = new Ogre::Vector3[m_sensorShapeSegments*2];
-
-        for( int i = 0; i < m_sensorShapeSegments; i++)
-        {
-            Ogre::Real x, z;
-            x = m_lastPlayerRadius * Ogre::Math::Cos( Ogre::Degree( 360.0f * i / m_sensorShapeSegments ) );
-            z = m_lastPlayerRadius * Ogre::Math::Sin( Ogre::Degree( 360.0f * i / m_sensorShapeSegments ) );
-
-            dynamicsSensorPoints[i].x = x * m_dynamicRadiusFactor;
-            dynamicsSensorPoints[i].y = m_lastPlayerHeight * 0.45f;
-            dynamicsSensorPoints[i].z = z * m_dynamicRadiusFactor;
-            dynamicsSensorPoints[i + m_sensorShapeSegments].x =  dynamicsSensorPoints[i].x;
-            dynamicsSensorPoints[i + m_sensorShapeSegments].y = -dynamicsSensorPoints[i].y;
-            dynamicsSensorPoints[i + m_sensorShapeSegments].z =  dynamicsSensorPoints[i].z;
-            verticalSensorPoints[i].x = x * m_floorFinderRadiusFactor;
-            verticalSensorPoints[i].y = m_lastSensorHeight;
-            verticalSensorPoints[i].z = z * m_floorFinderRadiusFactor;
-            verticalSensorPoints[i + m_sensorShapeSegments].x =  verticalSensorPoints[i].x;
-            verticalSensorPoints[i + m_sensorShapeSegments].y = -verticalSensorPoints[i].y;
-            verticalSensorPoints[i + m_sensorShapeSegments].z =  verticalSensorPoints[i].z;
-            horizontalSensorPoints[i].x = x * m_staticRadiusFactor;
-            horizontalSensorPoints[i].y = m_lastSensorHeight;
-            horizontalSensorPoints[i].z = z * m_staticRadiusFactor;
-            horizontalSensorPoints[i + m_sensorShapeSegments].x =  horizontalSensorPoints[i].x;
-            horizontalSensorPoints[i + m_sensorShapeSegments].y = -horizontalSensorPoints[i].y;
-            horizontalSensorPoints[i + m_sensorShapeSegments].z =  horizontalSensorPoints[i].z;
-        }
-
-        m_verticalSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), verticalSensorPoints, 2*m_sensorShapeSegments));
-        m_horizontalSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), horizontalSensorPoints, 2*m_sensorShapeSegments));
-        m_dynamicsSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), dynamicsSensorPoints, 2*m_sensorShapeSegments));
-
-        delete[] dynamicsSensorPoints;
-        delete[] verticalSensorPoints;
-        delete[] horizontalSensorPoints;
-    }
-
-}
-
-
-void PlayerController::getPlayerHeightAndRadius(Ogre::Real &height, Ogre::Real &radius)
-{
-    Ogre::AxisAlignedBox aab = m_body->getAABB();
-    height = aab.getMaximum().y - aab.getMinimum().y;
-
-    Ogre::Real rx = aab.getMaximum().x - aab.getMinimum().x;
-    Ogre::Real rz = aab.getMaximum().z - aab.getMinimum().z;
-    radius = std::max(rx,rz) / 2.0f;
-
-    //! TODO: the aabb seems to be too big
-// height *= 0.9f;
-// radius *= 0.5f;
-}
-
-
-bool PlayerController::convexStaticCastPreFilter(OgreNewt::Body *body)
-{
-    Ogre::Real mass;
-    Ogre::Vector3 inertia;
-    body->getMassMatrix(mass, inertia);
-
-    return (mass == 0.0f && body != m_body);
-}
-
-
-bool PlayerController::convexDynamicCastPreFilter(OgreNewt::Body *body)
-{
-    Ogre::Real mass;
-    Ogre::Vector3 inertia;
-    body->getMassMatrix(mass, inertia);
-
-    return (mass > 0.0f && body != m_body);
-}
-
-
-bool PlayerController::convexAllBodyCastPreFilter(OgreNewt::Body *body)
-{
-    return (body != m_body);
-}
-
-
-bool PlayerController::findFloorCastPreFilter(OgreNewt::Body *body)
-{
-    return (body != m_body);
-}
-
-
-void PlayerController::setVelocity(Ogre::Real forwardSpeed, Ogre::Real sideSpeed, Ogre::Degree heading)
-{
-    m_forwardSpeed = forwardSpeed;
-    m_sideSpeed = sideSpeed;
-    m_heading = heading;
-    m_body->unFreeze();
-}
-
-/*
-// helper class
-class HitBodyCache : public BasicConvexcast::ConvexcastContactInfo
-{
-    public:
-        Ogre::Vector3 mVel;
-        Ogre::Vector3 mOmega;
-        HitBodyCache() {}
-        HitBodyCache(const BasicConvexcast::ConvexcastContactInfo& info) :
-            BasicConvexcast::ConvexcastContactInfo(info)
-        {
-            mVel = mBody->getVelocity();
-            mOmega = mBody->getOmega();
-        }
-};
-
-// helper class
-class HitBodyVector : public std::vector<HitBodyCache>
-{
-    public:
-        void getCollidingBodiesFromConvexcast(const BasicConvexcast& cast)
-        {
-            // find first contact with each body and cache it
-            resize(0);
-            for(int i = 0; i < size(); i++)
-            {
-                int j;
-                for( j = 0; j < size(); j++ )
-                {
-                    if( cast.getInfoAt(i).mBody == at(j).mBody )
-                        break;
-                }
-                if( j == size() )
-                    push_back(HitBodyCache(cast.getInfoAt(0)));
-            }
-        }
-};
-*/
-
-// helper class
-class HitBodyVector : public std::vector<Body*>
-{
-    public:
-        void getCollidingBodiesFromConvexcast(const BasicConvexcast& cast)
-        {
-            // find first contact with each body and cache it
-            resize(0);
-            for(int i = 0; i < size(); i++)
-            {
-                Body* body = cast.getInfoAt(i).mBody;
-                int j;
-                for( j = 0; j < size(); j++ )
-                {
-                    if( body == at(j) )
-                        break;
-                }
-                if( j == size() )
-                    push_back(body);
-            }
-        }
-};
-
-
-void PlayerController::submitConstraint( Ogre::Real timestep, int threadindex )
-{
-
-    Ogre::Vector3 pos;
-    Ogre::Quaternion ori;
-    Ogre::Real mass;
-    Ogre::Vector3 inertia;
-    Ogre::Vector3 vel;
-    Ogre::Vector3 omega;
-    Ogre::Vector3 torqueAcc;
-
-    m_body->getPositionOrientation(pos,ori);
-    m_body->getMassMatrix(mass, inertia);
-    vel = m_body->getVelocity();
-    omega = m_body->getOmega();
-    torqueAcc = m_body->getTorqueAcceleration();
-
-
-    // ----- "up vector joint" -----
-    Ogre::Quaternion yawOri;
-    yawOri.FromAngleAxis(ori.getYaw(), Ogre::Vector3::UNIT_Y);
-    Ogre::Vector3 yawX = yawOri * Ogre::Vector3::UNIT_X;
-    Ogre::Vector3 yawZ = yawOri * Ogre::Vector3::UNIT_Z;
-    Ogre::Radian relAngleErrorX, relAngleErrorZ;
-    Ogre::Vector3 dirErrorX, dirErrorZ;
-    ori.xAxis().getRotationTo(yawX, yawZ).ToAngleAxis(relAngleErrorX, dirErrorX);
-    ori.zAxis().getRotationTo(yawZ, yawX).ToAngleAxis(relAngleErrorZ, dirErrorZ);
-    if( abs(relAngleErrorX.valueRadians()) < 0.001f )
-        addAngularRow(Ogre::Radian(0.0f), yawZ);
-    else
-        addAngularRow(relAngleErrorX, dirErrorX);
-    if( abs(relAngleErrorZ.valueRadians()) < 0.001f )
-        addAngularRow(Ogre::Radian(0.0f), yawX);
-    else
-        addAngularRow(relAngleErrorZ, dirErrorZ);
-
-
-    // ----------- calculate torque -----------
-    Ogre::Quaternion targetOri;
-    targetOri.FromAngleAxis(m_heading, Ogre::Vector3::UNIT_Y);
-    Ogre::Radian yawDiff = ((ori*Ogre::Vector3::UNIT_Z).getRotationTo(targetOri*Ogre::Vector3::UNIT_Z)).getYaw();
-    Ogre::Real turnOmega = yawDiff.valueRadians() / timestep;
-    Ogre::Vector3 torque = Ogre::Vector3::UNIT_Y * ((turnOmega - omega.y) * inertia.y/timestep - torqueAcc.y);
-    m_body->addTorque(torque);
-
-
-
-    // ----------- find floor -----------
-    //! perhaps calculate SLOPE differently, a convexcast with a rotated box should do it, but we'll see if it is needed!
-    Ogre::Vector3 findFloorCastP1 = pos - Ogre::Vector3::UNIT_Y*m_maxStepHeight;
-    // go a bit up from current position
-    Ogre::Vector3 findFloorCastP0 = pos + Ogre::Vector3::UNIT_Y*m_maxStepHeight;
-    FindFloorRaycast findFloorCast(this, findFloorCastP0, findFloorCastP1, true);
-    if( findFloorCast.getHitCount() > 0 )
-    {
-        // slope:
-        if( Ogre::Math::ASin(findFloorCast.getFirstHit().mNormal.y) < m_maxSlope )
-        {
-            // try some more raycasts...
-            FindFloorRaycast findFloorCast_0(this, findFloorCastP0+0.1*Ogre::Vector3::UNIT_X, findFloorCastP1+0.1*Ogre::Vector3::UNIT_X, true);
-            FindFloorRaycast findFloorCast_1(this, findFloorCastP0-0.1*Ogre::Vector3::UNIT_X, findFloorCastP1-0.1*Ogre::Vector3::UNIT_X, true);
-            FindFloorRaycast findFloorCast_2(this, findFloorCastP0+0.1*Ogre::Vector3::UNIT_Z, findFloorCastP1+0.1*Ogre::Vector3::UNIT_Z, true);
-            FindFloorRaycast findFloorCast_3(this, findFloorCastP0-0.1*Ogre::Vector3::UNIT_Z, findFloorCastP1-0.1*Ogre::Vector3::UNIT_Z, true);
-            if( findFloorCast_0.getHitCount() > 0 && Ogre::Math::ASin(findFloorCast_0.getFirstHit().mNormal.y) < m_maxSlope )
-            {
-                findFloorCastP0 += 0.1*Ogre::Vector3::UNIT_X;
-                findFloorCastP1 += 0.1*Ogre::Vector3::UNIT_X;
-                findFloorCast = findFloorCast_0;
-            }
-            else if( findFloorCast_1.getHitCount() > 0 && Ogre::Math::ASin(findFloorCast_1.getFirstHit().mNormal.y) < m_maxSlope )
-            {
-                findFloorCastP0 -= 0.1*Ogre::Vector3::UNIT_X;
-                findFloorCastP1 -= 0.1*Ogre::Vector3::UNIT_X;
-                findFloorCast = findFloorCast_1;
-            }
-            else if( findFloorCast_2.getHitCount() > 0 && Ogre::Math::ASin(findFloorCast_2.getFirstHit().mNormal.y) < m_maxSlope )
-            {
-                findFloorCastP0 += 0.1*Ogre::Vector3::UNIT_Z;
-                findFloorCastP1 += 0.1*Ogre::Vector3::UNIT_Z;
-                findFloorCast = findFloorCast_2;
-            }
-            else if( findFloorCast_3.getHitCount() > 0 && Ogre::Math::ASin(findFloorCast_3.getFirstHit().mNormal.y) < m_maxSlope )
-            {
-                findFloorCastP0 -= 0.1*Ogre::Vector3::UNIT_Z;
-                findFloorCastP1 -= 0.1*Ogre::Vector3::UNIT_Z;
-                findFloorCast = findFloorCast_3;
-            }
-        }
-        
-        if( Ogre::Math::ASin(findFloorCast.getFirstHit().mNormal.y) > m_maxSlope )
-        
-        {
-            // desired velocity
-            Ogre::Vector3 desiredVel = ori*(Ogre::Vector3::UNIT_Z * m_forwardSpeed + Ogre::Vector3::UNIT_Y*vel.y + Ogre::Vector3::UNIT_X * m_sideSpeed);
-
-            if( m_isInJumpState )
-                desiredVel = vel;
-            // ------------------------ here should be an else!! -------------------------
-            // only apply hitVel if we are not in the air, in the original this is different!
-            else
-            {
-
-                // hit-body:
-                Ogre::Vector3 hitPoint = findFloorCastP0 + (findFloorCastP1-findFloorCastP0) * findFloorCast.getFirstHit().mDistance;
-                Ogre::Vector3 hitOmega = findFloorCast.getFirstHit().mBody->getOmega();
-                Ogre::Vector3 hitVel = findFloorCast.getFirstHit().mBody->getVelocity();
-                Ogre::Vector3 hitPos;
-                Ogre::Quaternion hitOri;
-                findFloorCast.getFirstHit().mBody->getPositionOrientation(hitPos, hitOri);
-
-                hitVel += hitOmega * (hitPoint - hitPos).length();
-                desiredVel += hitVel;
-            }
-
-
-
-            // look ahead for obstacles in along the horizontal of the desired velocity
-            Ogre::Vector3 horizontalDesiredVel = desiredVel;
-            horizontalDesiredVel.y = 0;
-
-
-
-
-
-
-            // ----------------- DYNAMIC CONVEXCAST ---------------------
-
-            // first cast directly in front of the player
-            Ogre::Vector3 startCast = pos;
-            Ogre::Vector3 endCast = startCast;
-            DynamicConvexCast dynamicConvexCast(this);
-            HitBodyVector hitBodyVec;
-            hitBodyVec.reserve(m_maxContactsCount);
-/*
-            endCast = startCast + horizontalDesiredVel*timestep;
-            dynamicConvexCast.go(m_dynamicsSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
-
-            for(int iterations = 0; iterations < m_maxCollisionsIteration; iterations++)
-            {
-                bool velocCorrection;
-                Ogre::Real timeToFirstContact;
-                int numOfContacts;
-
-
-                numOfContacts = dynamicConvexCast.getContactsCount();
-                if( numOfContacts == 0 )
-                    break;
-
-                timeToFirstContact = (dynamicConvexCast.getInfoAt(0).mContactPoint - startCast).dotProduct(horizontalDesiredVel) / 
-                                     horizontalDesiredVel.squaredLength();
-                velocCorrection = false;
-
-
-                // correct velocity if the body cannot be pushed and calculate impulse if it can be pushed
-                for(int i = 0; i < numOfContacts; i++)
-                {
-                    Ogre::Real hitMass;
-                    Ogre::Vector3 hitInertia;
-                    Ogre::Vector3 hitNormal;
-                    Body* hitBody = dynamicConvexCast.getInfoAt(i).mBody;
-                    hitBody->getMassMatrix(hitMass, hitInertia);
-                    hitNormal = dynamicConvexCast.getInfoAt(i).mContactNormal;
-                    hitNormal.y = 0;
-                    hitNormal.normalise();
-
-                    if( !canPushBody(hitBody) )
-                    {
-                        Ogre::Real reboundVel, penetrationVel;
-                        Ogre::Real penetration;
-                        penetration = dynamicConvexCast.getInfoAt(i).mContactPenetration;
-                        penetration = std::max(penetration, 0.1f);
-                        penetrationVel = -0.5f/timestep * penetration;
-
-                        reboundVel = horizontalDesiredVel.dotProduct(hitNormal) * (1.0f+m_restitution) + penetrationVel;
-                        if( reboundVel < 0.0f )
-                        {
-                            velocCorrection = true;
-                            horizontalDesiredVel -= hitNormal*reboundVel;
-                        }
-                    }
-                    else // if( !canPushBody(body) )  -> can push body
-                    {
-                        Ogre::Real relVel, projVel, massWeigh, momentumDamper, playerNormalVel;
-                        Ogre::Vector3 hitCenterOfMass, hitPos, hitContactPointVel;
-                        Ogre::Quaternion hitOri;
-
-                        hitBody->getPositionOrientation(hitPos, hitOri);
-                        hitCenterOfMass = hitBody->getCenterOfMass();
-                        // calculate hitContactPointVel
-                        hitCenterOfMass = hitOri*hitCenterOfMass;
-                        hitContactPointVel = hitBody->getOmega() * (dynamicConvexCast.getInfoAt(i).mContactPoint - hitCenterOfMass);
-                        hitContactPointVel.y = 0.0f; //! WHY??
-                        hitContactPointVel += hitBody->getVelocity();
-
-                        massWeigh = mass / (mass + hitMass);
-                        massWeigh = std::min(massWeigh, 0.5f);
-
-                        projVel = hitContactPointVel.dotProduct(hitNormal);
-                        playerNormalVel = horizontalDesiredVel.dotProduct(hitNormal);
-                        relVel = playerNormalVel * massWeigh - projVel;
-                        if( relVel < 0.0f )
-                        {
-                            momentumDamper = 0.1f;
-                            velocCorrection = true;
-                            // correct horizontalDesiredVel
-                            horizontalDesiredVel -= hitNormal*( relVel * (1.0f - momentumDamper) + playerNormalVel*(1.0f - massWeigh) );
-
-                            //apply impulse to hit body
-                            hitBody->addImpulse(hitNormal*relVel*momentumDamper, hitCenterOfMass); // not the real CenterOffMass any more!
-                        }
-                    }
-                }
-
-
-
-                // now restore hit body state and apply a force to archive the hit impulse
-                hitBodyVec.getCollidingBodiesFromConvexcast(dynamicConvexCast);
-                for(int i = 0; i < hitBodyVec.size(); i++)
-                {
-                    Ogre::Real hitMass;
-                    Ogre::Vector3 hitInertia;
-                    Body* hitBody = hitBodyVec[i];
-                    hitBody->getMassMatrix(hitMass, hitInertia);
-
-                    if( canPushBody(hitBody) && mass > 1.0e-3f )
-                    {
-                        Ogre::Vector3 hitPos, force, torque;
-                        Ogre::Quaternion hitOri;
-
-                        hitBody->getPositionOrientation(hitPos, hitOri);
-                        
-                        // calculate the force and the torque to archive the desired push
-                        force = (vel - hitBody->getVelocity())*mass/timestep - hitBody->getForceAcceleration();
-                        hitBody->addForce(force);
-                        
-                        torque = (omega - hitBody->getOmega())/timestep * (hitOri*hitInertia) - hitBody->getTorqueAcceleration();
-                        hitBody->addTorque(torque);
-                    }
-                }
-
-
-                // has the horizontalDesiredVel changed, so we need a new cast?
-                if( timeToFirstContact > 0.01*timestep && velocCorrection )
-                {
-                    endCast = startCast + horizontalDesiredVel*timestep;
-                    dynamicConvexCast.go(m_dynamicsSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
-                }
-            }
-*/
-
-            // ----------------- STATIC CONVEXCAST ---------------------
-            StaticConvexCast staticConvexCast(this);
-            startCast.y += 0.5f*m_maxStepHeight;
-            endCast = startCast + horizontalDesiredVel*timestep;
-/*
-            staticConvexCast.go(m_horizontalSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
-            for(int iterations = 0; iterations < m_maxCollisionsIteration; iterations++)
-            {
-                bool velocCorrection;
-                Ogre::Real timeToFirstContact;
-                int numOfContacts;
-
-
-                numOfContacts = staticConvexCast.getContactsCount();
-                if( numOfContacts == 0 )
-                    break;
-
-                timeToFirstContact = (staticConvexCast.getInfoAt(0).mContactPoint - startCast).dotProduct(horizontalDesiredVel) / 
-                                     horizontalDesiredVel.squaredLength();
-                velocCorrection = false;
-
-
-                // correct velocity (like body that can't be pushed above!)
-                for(int i = 0; i < numOfContacts; i++)
-                {
-                    Ogre::Real hitMass;
-                    Ogre::Vector3 hitInertia;
-                    Ogre::Vector3 hitNormal;
-                    Ogre::Real reboundVel, penetrationVel;
-                    Ogre::Real penetration;
-
-                    Body* hitBody = staticConvexCast.getInfoAt(i).mBody;
-                    hitBody->getMassMatrix(hitMass, hitInertia);
-                    hitNormal = staticConvexCast.getInfoAt(i).mContactNormal;
-                    hitNormal.y = 0;
-                    hitNormal.normalise();
-
-                    penetration = staticConvexCast.getInfoAt(i).mContactPenetration;
-                    penetration = std::max(penetration, 0.1f);
-                    penetrationVel = -0.5f/timestep * penetration;
-
-                    reboundVel = horizontalDesiredVel.dotProduct(hitNormal) * (1.0f+m_restitution) + penetrationVel;
-                    if( reboundVel < 0.0f )
-                    {
-                        velocCorrection = true;
-                        horizontalDesiredVel -= hitNormal*reboundVel;
-                    }
-                }
-
-
-                // has the horizontalDesiredVel changed, so we need a new cast?
-                if( timeToFirstContact > 0.01*timestep && velocCorrection )
-                {
-                    endCast = startCast + horizontalDesiredVel*timestep;
-                    staticConvexCast.go(m_horizontalSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
-                }
-            }
-*/
-
-
-            // ----------------- STEP RECOGNITION AND GROUND TRACKING ---------------------
-            // now determine the ground tracking, predict the destination position
-            if( m_isInJumpState )
-            {
-                // player of in the air look ahead for the land
-                startCast = pos + horizontalDesiredVel*timestep + Ogre::Vector3::UNIT_Y*m_maxStepHeight*0.5f;
-                endCast = startCast - Ogre::Vector3::UNIT_Y*m_maxStepHeight;
-
-                staticConvexCast.go(m_verticalSensorShape, startCast, yawOri, endCast, 1, threadindex);
-                
-//! TODO: remove this... bug in newton?    
-Ogre::Real distanceToFirstHit = staticConvexCast.getDistanceToFirstHit();
-if( distanceToFirstHit > 0.01f )
-{
-
-                // found land
-                if( staticConvexCast.getContactsCount() > 0 )
-                {
-                    Ogre::Real dist, correctionVel;
-                    dist = - m_maxStepHeight * (0.5f - 1.0f*staticConvexCast.getDistanceToFirstHit());
-                    correctionVel = dist/timestep - vel.y;
-                    addLinearRow(pos, pos, Ogre::Vector3::UNIT_Y);
-                    setRowAcceleration(correctionVel/timestep);
-                    m_isInJumpState = false;
-                }
-}
-            }
-            else // m_isInJumpState
-            {
-                // player is moving on the ground, look ahead for stair steps
-                startCast = pos + horizontalDesiredVel*timestep + Ogre::Vector3::UNIT_Y*m_maxStepHeight;
-                endCast = startCast - Ogre::Vector3::UNIT_Y*m_maxStepHeight*2.0f;
-
-                AllBodyConvexCast allBodyConvexCast(this);
-                allBodyConvexCast.go(m_verticalSensorShape, startCast, yawOri, endCast, 1, threadindex);
-
-                if( allBodyConvexCast.getContactsCount() == 0 )
-                {
-                    //m_isInJumpState = true;
-                }
-                else
-                {
-                    m_isInJumpState = false;
-
-
-                    Ogre::Real distanceToFirstHit = allBodyConvexCast.getDistanceToFirstHit();
-                    // found "step"
-
-                    if( distanceToFirstHit < 0.01f )
-                    {
-                        // something when wrong because the vertical sensor shape is colliding
-                        // at origin of the predicted destination
-                        // this should never happens as a precaution set the vertical body velocity to zero
-                        Ogre::Vector3 vel = m_body->getVelocity();
-                        vel.y = 0.0f;
-                        m_body->setVelocity(vel);
-                    }
-                    else
-                    {
-                        Ogre::Real dist, correctionVel;
-                        // "the player will hit surface, make shure it is grounded" (?)
-                        dist = - m_maxStepHeight * (1.0f - 3.0f*distanceToFirstHit);
-/*
-                        // check if the contact violates the maxSlope constraint
-                        if( Ogre::Math::ASin( allBodyConvexCast.getInfoAt(0).mContactNormal.y ) < m_maxSlope )
-                        {
-                            // we are hitting stiff slope
-                            // cast a ray at the hit point to verify this is a face normal and not and edge of vertex normal
-                            // that can be pointing in the wrong direction
-                            Ogre::Vector3 hitPos, localNormal, origin, retCollisionLocalNormal, p0, p1;
-                            Ogre::Real retCollisionDist;
-                            int retCollisionColId;
-                            Ogre::Quaternion hitOri, hitOriInv;
-                            const OgreNewt::Collision* collision;
-                            
-                            Body* hitBody = allBodyConvexCast.getInfoAt(0).mBody;
-                            hitBody->getPositionOrientation(hitPos, hitOri);
-                            
-                            hitOriInv = hitOri.Inverse();
-                            localNormal = hitOriInv*allBodyConvexCast.getInfoAt(0).mContactNormal;
-                            origin = hitOriInv*(allBodyConvexCast.getInfoAt(0).mContactPoint - hitPos);
-                            
-                            collision = hitBody->getCollision();
-
-                            p0 = origin + localNormal*0.1f;
-                            p1 = origin - localNormal*0.1f;
-
-                            retCollisionDist = CollisionTools::CollisionRayCast(collision, p0, p1, retCollisionLocalNormal, retCollisionColId);
-                            if( retCollisionDist < 1.0f ) // this is always true
-                            {
-                                if( retCollisionLocalNormal.dotProduct(localNormal) < 0.9f ) // this is really an illegal slope
-                                {
-                                    horizontalDesiredVel = Ogre::Vector3::ZERO;
-                                    dist= 0.0f; // this sets correctionVel for steps to 0
-                                }
-                            }
-                            else
-                            {
-                                dist= 0.0f; // this sets correctionVel for steps to 0
-                            }
-                        }
-*/
-
-                        // move up for step
-
-                        correctionVel = dist / timestep - vel.y;
-std::cout << "distToFirstHit: " << distanceToFirstHit << "    \tdist: " << dist << "    \tvel.y: " << vel.y << "    \tCorrectionVel: " << correctionVel << std::endl;
-                        addLinearRow(pos, pos, Ogre::Vector3::UNIT_Y);
-                        setRowAcceleration( correctionVel / timestep );
-                    }
-                }
-            }
-
-
-            // calculate force needed for desired velocity
-            horizontalDesiredVel.y = 0.0f;
-            Ogre::Vector3 force = m_body->calculateInverseDynamicsForce(timestep, horizontalDesiredVel);
-            Ogre::Vector3 forceAcc = m_body->getForceAcceleration();
-            force -= forceAcc;
-            force.y = 0;
-            m_body->addForce(force);
-
-        }
-    }
-    
-
-}
-
-
-}   // end NAMESPACE OgreNewt
-
+#include "OgreNewt_PlayerController.h"
+#include "OgreNewt_Tools.h"
+#include "OgreNewt_Collision.h"
+#include "OgreNewt_CollisionPrimitives.h"
+#include "OgreNewt_World.h"
+
+#include <vector>
+#include <iostream>
+
+namespace OgreNewt
+{
+
+PlayerController::PlayerController(OgreNewt::Body * child, Ogre::Real stairHeight, Ogre::Real kinematicCushion, const Ogre::Matrix3& localFrame) :
+    CustomJoint(6, child, NULL),
+    m_body(child)
+{
+    // initialize some non settable parameters
+    m_maxCollisionsIteration = 8;
+    m_maxContactsCount = 16;
+    m_sensorShapeSegments = 32;
+
+#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
+    m_bodySensorShape = NULL;
+    m_stairSensorShape = NULL;
+    m_bodyFloorSensorShape = NULL;
+#endif
+
+
+    // initialize settable values
+    m_forwardSpeed = 0;
+    m_sideSpeed = 0;
+    m_heading = Ogre::Radian(0);
+    m_restitution = 0;
+    m_kinematicCushion = std::max(kinematicCushion, 1.0f/64.0f);
+    m_maxSlope = Ogre::Degree(30);
+    m_stairHeight = stairHeight;
+    m_playerState = PS_ONFREEFALL;
+    m_localFrame = localFrame;
+
+
+    updateGeometry();
+
+}
+
+
+void PlayerController::updateGeometry()
+{
+    m_localFrame.setScale( Ogre::Vector3::UNIT_SCALE );
+    m_localFrame.setTrans(  m_body->getCenterOfMass() );
+    Ogre::AxisAlignedBox playerAabb = m_body->getCollision()->getAABB( m_localFrame.extractQuaternion() );
+    Ogre::Real playerHeight = playerAabb.getSize().y;
+    Ogre::Real playerRadius = std::max(playerAabb.getSize().x, playerAabb.getSize().z);
+    
+    m_maxRadius = playerRadius + m_kinematicCushion;
+
+
+#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
+    // delete old ones
+    if( m_bodySensorShape )
+        delete m_bodySensorShape;
+    if( m_stairSensorShape )
+        delete m_stairSensorShape;
+    if( m_bodyFloorSensorShape )
+        delete m_bodyFloorSensorShape;
+#endif
+
+    std::vector<Ogre::Vector3> bodySensorPoints, stairSensorPoints, bodyFloorSensorPoints;
+    bodySensorPoints.resize(m_sensorShapeSegments*2);
+    stairSensorPoints.resize(m_sensorShapeSegments*2);
+    bodyFloorSensorPoints.resize(m_sensorShapeSegments*2);
+
+    Ogre::Real h0, h1, startHeight;
+    h0 = playerAabb.getMinimum().y;
+    h1 = playerAabb.getMaximum().y - m_stairHeight;
+    startHeight = h0 + m_stairHeight;
+
+
+    Ogre::Quaternion localOri = m_localFrame.extractQuaternion();
+    for( int i = 0; i < m_sensorShapeSegments; i++)
+    {
+        Ogre::Real x, z, fx, fz;
+        x = Ogre::Math::Cos( Ogre::Degree( (360.0f * i) / m_sensorShapeSegments ) );
+        z = Ogre::Math::Sin( Ogre::Degree( (360.0f * i) / m_sensorShapeSegments ) );
+
+        fx = playerRadius * x;
+        fz = playerRadius * z;
+
+        x = m_maxRadius * x;
+        z = m_maxRadius * z;
+
+        bodySensorPoints[i] = localOri * Ogre::Vector3(x, h0, z);
+        bodySensorPoints[i + m_sensorShapeSegments] = localOri * Ogre::Vector3(x, h1, z);
+
+        stairSensorPoints[i] = localOri * Ogre::Vector3(fx, h0, fz);
+        stairSensorPoints[i + m_sensorShapeSegments] = localOri * Ogre::Vector3(fx, h1, fz);
+
+        bodyFloorSensorPoints[i] = localOri * Ogre::Vector3(x, h0, z);
+        bodyFloorSensorPoints[i + m_sensorShapeSegments] = localOri * Ogre::Vector3(x, startHeight, z);
+
+    }
+
+
+    m_bodySensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), &bodySensorPoints[0], 2*m_sensorShapeSegments, 0));
+    m_stairSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), &stairSensorPoints[0], 2*m_sensorShapeSegments, 0));
+    m_bodyFloorSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), &bodyFloorSensorPoints[0], 2*m_sensorShapeSegments, 0));
+
+}
+
+
+PlayerController::~PlayerController()
+{
+#ifdef OGRENEWT_NO_COLLISION_SHAREDPTR
+    if( m_bodySensorShape )
+        delete m_bodySensorShape;
+    if( m_stairSensorShape )
+        delete m_stairSensorShape;
+    if( m_bodyFloorSensorShape )
+        delete m_bodyFloorSensorShape;
+#endif
+}
+
+
+
+bool PlayerController::convexStaticCastPreFilter(OgreNewt::Body *body, BodyVector filterBodies)
+{
+    Ogre::Real mass;
+    Ogre::Vector3 inertia;
+    body->getMassMatrix(mass, inertia);
+
+    //if( mass != 0.0f || body == m_body )
+    if( body == m_body )
+        return false;
+
+    for( int i = 0; i < filterBodies.size(); i++ )
+    {
+        if( body == filterBodies[i] )
+            return false;
+    }
+
+    return true;
+}
+
+
+bool PlayerController::convexAllBodyCastPreFilter(OgreNewt::Body *body, BodyVector filterBodies)
+{
+    if( body == m_body )
+        return false;
+
+    for( int i = 0; i < filterBodies.size(); i++ )
+    {
+        if( body == filterBodies[i] )
+            return false;
+    }
+
+    return true;
+}
+
+
+void PlayerController::setVelocity(Ogre::Real forwardSpeed, Ogre::Real sideSpeed, Ogre::Radian heading)
+{
+    m_forwardSpeed = forwardSpeed;
+    m_sideSpeed = sideSpeed;
+    m_heading = heading;
+    m_body->unFreeze();
+}
+
+
+void PlayerController::getVelocity(Ogre::Real& forwardSpeed, Ogre::Real& sideSpeed, Ogre::Radian& heading) const
+{
+    forwardSpeed = m_forwardSpeed;
+    sideSpeed = m_sideSpeed;
+    heading = m_heading;
+}
+
+
+void PlayerController::setStairHeight(Ogre::Real stairHeight)
+{
+    m_stairHeight = stairHeight;
+    updateGeometry();
+}
+
+
+Ogre::Real PlayerController::getStairHeight() const
+{
+    return m_stairHeight;
+}
+
+
+void PlayerController::setKinematicCushion(Ogre::Real cushion)
+{
+    m_kinematicCushion = std::max(cushion, 1.0f/64.0f);
+    updateGeometry();
+}
+
+
+Ogre::Real PlayerController::getKinematicCushion() const
+{
+    return m_kinematicCushion;
+}
+
+
+void PlayerController::setMaxSlope(Ogre::Radian maxSlope)
+{
+    m_maxSlope = maxSlope;
+}
+
+
+Ogre::Radian PlayerController::getMaxSlope() const
+{
+    return m_maxSlope;
+}
+
+
+void PlayerController::setRestitution(Ogre::Real restitution)
+{
+    m_restitution = restitution;
+}
+
+
+Ogre::Real PlayerController::getRestitution() const
+{
+    return m_restitution;
+}
+
+
+PlayerController::PlayerState PlayerController::getPlayerState() const
+{
+    return m_playerState;
+}
+
+void PlayerController::setPlayerState(PlayerController::PlayerState state)
+{
+    std::cout << "\n old player state: " << m_playerState << "    new player state: " << state << "\n";
+    m_playerState = state;
+}
+
+
+// helper class
+class HitBodyVector : public std::vector<Body*>
+{
+    public:
+        void getCollidingBodiesFromConvexcast(const BasicConvexcast& cast)
+        {
+            // find first contact with each body and cache it
+            resize(0);
+            for(int i = 0; i < size(); i++)
+            {
+                Body* body = cast.getInfoAt(i).mBody;
+                int j;
+                for( j = 0; j < size(); j++ )
+                {
+                    if( body == at(j) )
+                        break;
+                }
+                if( j == size() )
+                    push_back(body);
+            }
+        }
+};
+
+
+void PlayerController::submitConstraint( Ogre::Real timestep, int threadindex )
+{
+
+    Ogre::Vector3 pos;
+    Ogre::Quaternion ori;
+    Ogre::Real invMass;
+    Ogre::Vector3 invInertia;
+    Ogre::Vector3 frontDir, upDir, strafeDir;
+
+    m_body->getInvMass(invMass, invInertia);
+    m_body->getPositionOrientation(pos,ori);
+
+    Ogre::Quaternion localFrameRotation = m_localFrame.extractQuaternion();
+    frontDir = localFrameRotation * Ogre::Vector3::NEGATIVE_UNIT_Z;
+    upDir = localFrameRotation * Ogre::Vector3::UNIT_Y;
+    strafeDir = localFrameRotation * Ogre::Vector3::UNIT_X;
+
+
+
+    // save the gravity before the collision force is applied
+    m_gravity = m_body->getForceAcceleration();
+    m_gravity *= invMass;
+
+
+    // if the body has rotated by some amount, there will be a plane of rotation
+    Ogre::Vector3 realUp = ori*(localFrameRotation*Ogre::Vector3::UNIT_Y);
+    Ogre::Vector3 lateralDir = realUp.crossProduct(upDir);
+    Ogre::Real mag = lateralDir.length();
+    if( mag > 1.0e-3f)
+    {
+        // if the side vector is not zero, it means the body has rotated
+        lateralDir /= mag;
+        Ogre::Radian angle = Ogre::Math::ASin(mag);
+        // add an angular constraint to correct the error angle
+        addAngularRow(angle, lateralDir);
+
+
+        // in theory only one correction is needed, but this produces instability as the body may move sideway.
+        // a lateral correction prevent this from happening.
+        Ogre::Vector3 frontDir = lateralDir.crossProduct(upDir);
+        addAngularRow(Ogre::Radian(0), lateralDir);
+    }
+    else
+    {
+        // if the angle error is very small then two angular correction along the plane axis do the trick
+        addAngularRow( Ogre::Radian(0), strafeDir );
+        addAngularRow( Ogre::Radian(0), frontDir );
+    }
+
+
+    
+    // calculate/set velocity (more complicated velocity calculation is done in the "kinematic motion" functions (feedbackCollector, playerOnLand, playerOnFreeFall, playerOnIllegalSlope
+    if( m_playerState == PS_ONLAND )
+    {
+        Ogre::Vector3 vel = m_body->getVelocity();
+        Ogre::Vector3 desiredVel = frontDir* m_forwardSpeed + upDir * (vel.dotProduct(upDir)) + strafeDir * m_sideSpeed;
+        
+        m_body->setVelocity(desiredVel);
+    }
+}
+
+
+void PlayerController::feedbackCollector( Ogre::Real timestep, int threadIndex )
+{
+    Ogre::Vector3 pos, frontDir, upDir, targetFrontDir, targetOmega;
+    Ogre::Quaternion ori, localFrameRotation;
+    Ogre::Radian turnAngle, turnOmega;
+
+    localFrameRotation = m_localFrame.extractQuaternion();
+
+    m_body->getPositionOrientation(pos, ori);
+    frontDir = ori*(localFrameRotation*Ogre::Vector3::NEGATIVE_UNIT_Z);
+    upDir = ori*(localFrameRotation*Ogre::Vector3::UNIT_Y);
+
+    targetFrontDir = localFrameRotation*Ogre::Quaternion(m_heading, Ogre::Vector3::UNIT_Y)*Ogre::Vector3::NEGATIVE_UNIT_Z;
+    turnAngle = Ogre::Radian(Ogre::Math::ASin( std::min( std::max( frontDir.crossProduct(targetFrontDir).dotProduct(upDir), -1.0f), 1.0f)));
+    turnOmega = turnAngle / timestep;
+
+    targetOmega = turnOmega.valueRadians() * (localFrameRotation*Ogre::Vector3::UNIT_Y);
+    m_body->setOmega(targetOmega);
+
+
+
+
+    switch( m_playerState )
+    {
+        case PS_ONFREEFALL:
+            playerOnFreeFall(timestep, threadIndex);
+            break;
+        case PS_ONLAND:
+            playerOnLand(timestep, threadIndex );
+            break;
+        case PS_ONILLEGALRAMP:
+            playerOnIllegalRamp(timestep, threadIndex);
+            break;
+    }
+
+}
+
+
+Ogre::Vector3 PlayerController::calculateVelocity(const Ogre::Vector3& targetVel_, Ogre::Real timestep, const Ogre::Vector3& upDir, Ogre::Real elevation, int threadindex)
+{
+    int contactCount;
+    Ogre::Real hitParam, timestepInv(1.0f/timestep);
+    Ogre::Vector3 pos, targetVel(targetVel_), destination;
+    Ogre::Quaternion ori;
+    StaticConvexCast staticConvexCast(this);
+
+    m_body->getPositionOrientation(pos, ori);
+    pos += upDir*elevation;
+    destination = pos + timestep * targetVel;
+
+
+    // see if it hit an obstacle
+    staticConvexCast.go(m_bodySensorShape, pos, ori, destination, m_maxContactsCount, threadindex);
+    contactCount = staticConvexCast.getContactsCount();
+    for( int iterations = 0; iterations < m_maxCollisionsIteration && contactCount; iterations++ )
+    {
+        int flag;
+        Ogre::Real time;
+        flag = 0;
+
+        // if the player will hit an obstacle in this direction then we need to change the velocity direction
+        // we will declare a collision at the player origin.
+        Ogre::Vector3 step;
+        step = destination - pos;
+        Ogre::Vector3 obstaclePos;
+        obstaclePos = pos + step*staticConvexCast.getDistanceToFirstHit();
+
+        // calculate the travel time, and subtract from time remaining
+        time = staticConvexCast.getDistanceToFirstHit() * step.dotProduct(targetVel) / targetVel.squaredLength();
+        for(int i = 0; i < contactCount; i++ )
+        {
+            Ogre::Real reboundVel;
+            Ogre::Real penetrationVel;
+            BasicConvexcast::ConvexcastContactInfo info;
+            info = staticConvexCast.getInfoAt(i);
+
+            // flatten contact normal
+            info.mContactNormal -= upDir * upDir.dotProduct(info.mContactNormal);
+            info.mContactNormal.normalise();
+
+            // calculate the reflection velocity
+            penetrationVel = -0.5f*timestepInv*std::min( info.mContactPenetration, 0.1f );
+            reboundVel = targetVel.dotProduct(info.mContactNormal) * (1.0f + m_restitution) + penetrationVel;
+            if( reboundVel < 0.0f )
+            {
+                flag = 1;
+                targetVel -= reboundVel * info.mContactNormal;
+            }
+        }
+
+        contactCount = 0;
+        if( (time > 1.0e-2f * timestep) && flag )
+        {
+            destination = pos + targetVel * timestep;
+            staticConvexCast.go(m_bodySensorShape, pos, ori, destination, m_maxContactsCount, threadindex);
+            contactCount = staticConvexCast.getContactsCount();
+        }
+
+    }
+
+    return targetVel;
+}
+
+
+void PlayerController::playerOnFreeFall( Ogre::Real timestep, int threadIndex )
+{
+    Ogre::Vector3 pos, castTarget, castStart;
+    Ogre::Quaternion ori, localFrameRotation;
+    Ogre::Vector3 upDir, frontDir;
+    Ogre::Vector3 targetVel;
+    Ogre::Real dist;
+    StaticConvexCast staticConvexCast(this);
+
+    
+    m_body->getPositionOrientation(pos, ori);
+    upDir = ori*(localFrameRotation*Ogre::Vector3::UNIT_Y);
+    frontDir = ori*(localFrameRotation*Ogre::Vector3::NEGATIVE_UNIT_Z);
+
+    targetVel = m_body->getVelocity();
+    // make sure the velocity will not penetrate other bodies:
+    targetVel = calculateVelocity(targetVel, timestep, upDir, m_stairHeight, threadIndex);
+
+    // player of in free fall look ahead for land
+    dist = upDir.dotProduct(targetVel*timestep);
+
+    castStart = pos - upDir*m_kinematicCushion;
+    castTarget = castStart + upDir*dist;
+    staticConvexCast.go(m_bodyFloorSensorShape, castStart, ori, castTarget, 1, threadIndex);
+    if( staticConvexCast.getContactsCount() > 0 )
+    {
+std::cout << "\n found contact.\n";
+        // player is about to land, snap position to the ground
+        Ogre::Vector3 newPos = pos + upDir * staticConvexCast.getDistanceToFirstHit() * dist;
+        m_body->setPositionOrientation(newPos, ori);
+
+        Ogre::Vector3 contactNormal = staticConvexCast.getInfoAt(0).mContactNormal;
+        if( upDir.angleBetween( contactNormal ) > m_maxSlope )
+        {
+            setPlayerState(PS_ONILLEGALRAMP);
+        }
+        else
+        {
+            setPlayerState(PS_ONLAND);
+            targetVel -= upDir * upDir.dotProduct(targetVel);
+        }
+    }
+
+    m_body->setVelocity(targetVel);
+}
+
+
+
+void PlayerController::playerOnIllegalRamp( Ogre::Real timestep, int threadIndex )
+{
+    Ogre::Vector3 pos, realPos, castStart, castTarget;
+    Ogre::Quaternion ori, localFrameRotation;
+    Ogre::Vector3 upDir, frontDir;
+    Ogre::Vector3 targetVel, step;
+    StaticConvexCast staticConvexCast(this);
+    AllBodyConvexCast allBodyConvexCast(this);
+
+    localFrameRotation = m_localFrame.extractQuaternion();
+    
+    m_body->getPositionOrientation(pos, ori);
+    upDir = ori*(localFrameRotation*Ogre::Vector3::UNIT_Y);
+    frontDir = ori*(localFrameRotation*Ogre::Vector3::NEGATIVE_UNIT_Z);
+
+
+    targetVel = m_body->getVelocity();
+
+    //apply free fall gravity force to the body along the ramp
+    castStart = pos + upDir*m_stairHeight;
+    castTarget = pos - upDir*m_stairHeight;
+    staticConvexCast.go(m_bodyFloorSensorShape, castStart, ori, castTarget, m_maxContactsCount, threadIndex);
+    if( staticConvexCast.getContactsCount() > 0 )
+    {
+        targetVel -= m_gravity*timestep;
+        Ogre::Vector3 floorNormal = staticConvexCast.getInfoAt(0).mContactNormal;
+        Ogre::Vector3 gravityForce = m_gravity - floorNormal*(floorNormal.dotProduct(m_gravity));
+        targetVel -= floorNormal * floorNormal.dotProduct(m_gravity) + gravityForce * timestep;
+    }
+
+    // make sure the body velocity will not penetrate other bodies
+    targetVel = calculateVelocity(targetVel, timestep, upDir, m_stairHeight, threadIndex);
+
+
+    step = targetVel * timestep;
+    castStart = pos + step + upDir*(m_stairHeight - m_kinematicCushion);
+    castTarget = castStart - upDir * 2.0f * m_stairHeight;
+    allBodyConvexCast.go(m_bodyFloorSensorShape, castStart, ori, castTarget, 1, threadIndex);
+    if( allBodyConvexCast.getContactsCount() == 0 )
+    {
+        setPlayerState(PS_ONFREEFALL);
+    }
+    else
+    {
+        Ogre::Real dist = allBodyConvexCast.getDistanceToFirstHit();
+        if( dist <= 1.0e-3f )
+            ;
+        else
+        {
+            bool isFuturePosInRamp;
+            Ogre::Vector3 newPos;
+            
+            newPos = castStart + (castTarget - castStart)*dist - step + upDir * m_kinematicCushion;
+            m_body->setPositionOrientation(pos, ori);
+
+            Ogre::Vector3 floorNormal = allBodyConvexCast.getInfoAt(0).mContactNormal;
+
+            isFuturePosInRamp = upDir.angleBetween(floorNormal) > m_maxSlope;
+            if( !isFuturePosInRamp )
+            {
+                setPlayerState(PS_ONLAND);
+            }
+        }
+    }
+
+    m_body->setVelocity(targetVel);
+}
+
+
+void PlayerController::playerOnLand( Ogre::Real timestep, int threadIndex )
+{
+    Ogre::Vector3 pos, realPos, castStart, castTarget;
+    Ogre::Quaternion ori, localFrameRotation;
+    Ogre::Vector3 upDir, frontDir;
+    Ogre::Vector3 targetVel, step;
+    Ogre::Real distanceToFirstHit;
+    AllBodyConvexCast allBodyConvexCast(this);
+
+    localFrameRotation = m_localFrame.extractQuaternion();
+    
+    m_body->getPositionOrientation(pos, ori);
+    upDir = ori*(localFrameRotation*Ogre::Vector3::UNIT_Y);
+    frontDir = ori*(localFrameRotation*Ogre::Vector3::NEGATIVE_UNIT_Z);
+
+
+    targetVel = m_body->getVelocity();
+
+
+    // subtract gravity contribution
+    targetVel -= m_gravity*timestep;
+    // make sure the body velocity will not penetrate other bodies
+    targetVel = calculateVelocity(targetVel, timestep, upDir, m_stairHeight, threadIndex);
+
+    step = targetVel * timestep;
+
+    castStart = pos + step + upDir * (m_stairHeight - m_kinematicCushion);
+    castTarget = castStart - upDir * 2.0f * m_stairHeight;
+    allBodyConvexCast.go(m_bodyFloorSensorShape, castStart, ori, castTarget, 1, threadIndex);
+    distanceToFirstHit = allBodyConvexCast.getDistanceToFirstHit();
+    if( allBodyConvexCast.getContactsCount() == 0 )
+    {
+        setPlayerState(PS_ONFREEFALL);
+    }
+    else
+    {
+        if( distanceToFirstHit <= 1.0e-3f )
+            ;
+        else
+        {
+            bool isFuturePosInRamp;
+
+            Ogre::Vector3 floorNormal = allBodyConvexCast.getInfoAt(0).mContactNormal;
+
+            isFuturePosInRamp = upDir.angleBetween(floorNormal) > m_maxSlope;
+            if( !isFuturePosInRamp )
+            {
+                AllBodyConvexCast allBodyConvexCast2(this);
+                Ogre::Vector3 castStart2, castTarget2;
+                
+                castStart2 = pos + upDir*(m_stairHeight - m_kinematicCushion);
+                castTarget2 = castStart2 - upDir*2.0f*m_stairHeight;
+                BodyVector filterBodies;
+                filterBodies.push_back(allBodyConvexCast.getInfoAt(0).mBody);
+                
+                allBodyConvexCast2.go(m_bodyFloorSensorShape, castStart2, ori, castTarget2, 1, threadIndex, filterBodies);
+
+                if( distanceToFirstHit < allBodyConvexCast2.getDistanceToFirstHit() && allBodyConvexCast2.getContactsCount() > 0 )
+                {
+                    setPlayerState(PS_ONILLEGALRAMP);
+                }
+                else
+                {
+                    // the player hit the edge of a forbidden ramp
+
+                    int iterations, contactCount = 1;
+                    Ogre::Vector3 savedTargetVel;
+                    savedTargetVel = targetVel;
+                    for( iterations = 0; iterations < m_maxCollisionsIteration && contactCount; iterations++ )
+                    {
+                        Ogre::Real projectVel;
+                        Ogre::Vector3 castStart3, castTarget3;
+                        AllBodyConvexCast allBodyConvexCast3(this);
+
+                        floorNormal -= upDir*floorNormal.dotProduct(upDir);
+                        floorNormal.normalise();
+
+                        projectVel = targetVel.dotProduct(floorNormal);
+                        targetVel -= floorNormal * projectVel;
+
+                        step = targetVel * timestep;
+                        castStart3 = pos + step + upDir*(m_stairHeight - m_kinematicCushion);
+                        castTarget3 = castStart3 - upDir*2.0f * m_stairHeight;
+
+                        allBodyConvexCast3.go(m_bodyFloorSensorShape, castStart3, ori, castTarget3, 1, threadIndex, filterBodies);
+                        contactCount = allBodyConvexCast3.getContactsCount();
+                        if( contactCount > 0 )
+                        {
+                            distanceToFirstHit = allBodyConvexCast3.getDistanceToFirstHit();
+                            castStart = castStart3;
+                            castTarget = castTarget3;
+
+                            floorNormal = allBodyConvexCast3.getInfoAt(0).mContactNormal;
+                            filterBodies.push_back(allBodyConvexCast3.getInfoAt(0).mBody);
+                            
+                            if( upDir.angleBetween( floorNormal ) < m_maxSlope )
+                                contactCount = 1;
+                            else
+                                contactCount = 0;
+                        }
+                    }
+
+
+                    if( iterations >= m_maxCollisionsIteration )
+                    {
+                        Ogre::Vector3 targetVel1 = calculateVelocity(savedTargetVel, timestep, upDir, 0.0f, threadIndex);
+                        Ogre::Vector3 err = targetVel1 - targetVel;
+                        if( err.squaredLength() < 1.0e-6f )
+                        {
+                            setPlayerState(PS_ONILLEGALRAMP);
+                        }
+                        else
+                        {
+                            targetVel = targetVel1;
+                            distanceToFirstHit = 0.0f;
+                            step = Ogre::Vector3::ZERO;
+                            pos -= upDir*m_kinematicCushion;
+                        }
+                    }
+                    
+                }
+            }
+
+            Ogre::Vector3 newPos = pos + (castTarget - castStart)*distanceToFirstHit + upDir*m_kinematicCushion;
+            newPos -= step;
+            m_body->setPositionOrientation(newPos, ori);
+
+        }
+    }
+
+
+    m_body->setVelocity(targetVel);
+}
+
+}   // end NAMESPACE OgreNewt
+

Modified: dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -213,24 +213,14 @@
                 float matrix[16];
                 OgreNewt::Converters::QuatPosToMatrix(colori, startpt, &matrix[0] );
                 mFirstContactDistance = -1;
-#ifdef __APPLE__
+
+
                 mReturnInfoListLength = 
                     NewtonWorldConvexCast( world->getNewtonWorld(), &matrix[0], (float*)&endpt, col->getNewtonCollision(),
-                                               &mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
-                                               mReturnInfoList, mReturnInfoListSize);
-#else
-                mReturnInfoListLength = 
-                    NewtonWorldConvexCast( world->getNewtonWorld(), &matrix[0], (float*)&endpt, col->getNewtonCollision(),
                               &mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
                               mReturnInfoList, mReturnInfoListSize, threadIndex);
-#endif
-        
-                //! TODO: that's a hack here!!
-                if( mReturnInfoListLength > 0 )
-                {
-                    mReturnInfoListLength = 1;
-                }
 
+        
             if( world->getDebugger().isRaycastRecording() && world->getDebugger().isRaycastRecordingHitBodies() )
             {
                 Body* body;

Modified: dependencies/OgreNewt/src/OgreNewt_World.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_World.cpp	2009-08-03 14:08:17 UTC (rev 4951)
+++ dependencies/OgreNewt/src/OgreNewt_World.cpp	2009-08-21 16:29:49 UTC (rev 4952)
@@ -1,5 +1,6 @@
 #include "OgreNewt_World.h"
 #include "OgreNewt_MaterialID.h"
+#include "OgreNewt_Body.h"
 #include "OgreNewt_BodyInAABBIterator.h"
 
 namespace OgreNewt
@@ -7,12 +8,16 @@
 
 
 // Constructor
-World::World() :
+World::World(NewtonAllocMemory newtonAlloc, NewtonFreeMemory newtonFree) :
     m_bodyInAABBIterator(this)
 {
+#ifndef WIN32
+    pthread_mutex_init(&m_ogreMutex, 0);
+#endif
+
     m_limits = Ogre::AxisAlignedBox(Ogre::Vector3(-100,-100,-100), Ogre::Vector3(100,100,100));
 
-    m_world = NewtonCreate( NULL, NULL );
+    m_world = NewtonCreate( newtonAlloc, newtonFree );
 
     if (!m_world)
     {
@@ -54,9 +59,28 @@
 // update
 void World::update( Ogre::Real t_step )
 {
+    m_bodyUpdateNodeRequests.resize(getThreadCount());
+
+
     NewtonUpdate( m_world, (float)t_step );
+
+
+    for( BodyVectorVector::iterator it = m_bodyUpdateNodeRequests.begin(); it != m_bodyUpdateNodeRequests.end(); it++ )
+    {
+        for( BodyVector::iterator body = it->begin(); body != it->end(); body++ )
+        {
+            if( (*body)->isNodeUpdateNeeded() )
+                (*body)->updateNode();
+        }
+        it->clear();
+    }
 }
 
+void World::addBodyUpdateNodeRequest( int threadIndex, OgreNewt::Body* body ) const
+{
+    m_bodyUpdateNodeRequests.at(threadIndex).push_back(body);
+}
+
 void World::setWorldSize( const Ogre::Vector3& min, const Ogre::Vector3& max )
 {
     NewtonSetWorldSize( m_world, (float*)&min.x, (float*)&max.x );



From melven at mail.berlios.de  Sat Aug 22 16:25:19 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 22 Aug 2009 16:25:19 +0200
Subject: [Dsa-hl-svn] r4954 - in dependencies/OgreNewt: inc src
Message-ID: <200908221425.n7MEPJvw031446@sheep.berlios.de>

Author: melven
Date: 2009-08-22 16:25:07 +0200 (Sat, 22 Aug 2009)
New Revision: 4954

Modified:
   dependencies/OgreNewt/inc/OgreNewt.h
   dependencies/OgreNewt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
   dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
Log:
some work on the player controller and some minor changes


Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-08-21 16:33:32 UTC (rev 4953)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-08-22 14:25:07 UTC (rev 4954)
@@ -67,6 +67,8 @@
     \section new New in this version
 
     New in this version
+        - ConvexCast:
+            - added "NormalOnHitPoint"
         - CustomJoint:
             - added globalToLocal function
             - feedbackCollector callback

Modified: dependencies/OgreNewt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_RayCast.h	2009-08-21 16:33:32 UTC (rev 4953)
+++ dependencies/OgreNewt/inc/OgreNewt_RayCast.h	2009-08-22 14:25:07 UTC (rev 4954)
@@ -227,12 +227,13 @@
     class _OgreNewtExport ConvexcastContactInfo
     {
     public:
-        //Ogre::Real              mDistance;              //!< dist from point1 of the raycast, in range [0,1].
-        OgreNewt::Body*         mBody;                  //!< pointer to body intersected with
-        int                     mCollisionID;           //!< collision ID of the primitive hit by the ray (for compound collision bodies)
-        Ogre::Vector3           mContactNormal;         //!< normal of intersection.
-        Ogre::Vector3           mContactPoint;          //!< point of the contact in global space
-        Ogre::Real              mContactPenetration;    //!< contact penetration at collision point
+        //Ogre::Real              mDistance;                  //!< dist from point1 of the raycast, in range [0,1].
+        OgreNewt::Body*         mBody;                      //!< pointer to body intersected with
+        int                     mCollisionID;               //!< collision ID of the primitive hit by the ray (for compound collision bodies)
+        Ogre::Vector3           mContactNormal;             //!< normal of intersection.
+        Ogre::Vector3           mContactNormalOnHitPoint;   //!< surface normal at the surface of the hit body
+        Ogre::Vector3           mContactPoint;              //!< point of the contact in global space
+        Ogre::Real              mContactPenetration;        //!< contact penetration at collision point
 
         ConvexcastContactInfo();
         ~ConvexcastContactInfo();

Modified: dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-08-21 16:33:32 UTC (rev 4953)
+++ dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-08-22 14:25:07 UTC (rev 4954)
@@ -127,8 +127,7 @@
     Ogre::Vector3 inertia;
     body->getMassMatrix(mass, inertia);
 
-    //if( mass != 0.0f || body == m_body )
-    if( body == m_body )
+    if( mass != 0.0f || body == m_body )
         return false;
 
     for( int i = 0; i < filterBodies.size(); i++ )
@@ -500,7 +499,7 @@
         targetVel -= m_gravity*timestep;
         Ogre::Vector3 floorNormal = staticConvexCast.getInfoAt(0).mContactNormal;
         Ogre::Vector3 gravityForce = m_gravity - floorNormal*(floorNormal.dotProduct(m_gravity));
-        targetVel -= floorNormal * floorNormal.dotProduct(m_gravity) + gravityForce * timestep;
+        targetVel += gravityForce*timestep - floorNormal * floorNormal.dotProduct(targetVel);
     }
 
     // make sure the body velocity will not penetrate other bodies
@@ -586,8 +585,8 @@
 
             Ogre::Vector3 floorNormal = allBodyConvexCast.getInfoAt(0).mContactNormal;
 
-            isFuturePosInRamp = upDir.angleBetween(floorNormal) > m_maxSlope;
-            if( !isFuturePosInRamp )
+            isFuturePosInRamp = upDir.angleBetween(floorNormal) < m_maxSlope;
+            if( isFuturePosInRamp )
             {
                 AllBodyConvexCast allBodyConvexCast2(this);
                 Ogre::Vector3 castStart2, castTarget2;
@@ -599,7 +598,7 @@
                 
                 allBodyConvexCast2.go(m_bodyFloorSensorShape, castStart2, ori, castTarget2, 1, threadIndex, filterBodies);
 
-                if( distanceToFirstHit < allBodyConvexCast2.getDistanceToFirstHit() && allBodyConvexCast2.getContactsCount() > 0 )
+                if( distanceToFirstHit >= allBodyConvexCast2.getDistanceToFirstHit() && allBodyConvexCast2.getContactsCount() > 0 )
                 {
                     setPlayerState(PS_ONILLEGALRAMP);
                 }
@@ -610,7 +609,7 @@
                     int iterations, contactCount = 1;
                     Ogre::Vector3 savedTargetVel;
                     savedTargetVel = targetVel;
-                    for( iterations = 0; iterations < m_maxCollisionsIteration && contactCount; iterations++ )
+                    for( iterations = 0; (iterations < m_maxCollisionsIteration) && contactCount; iterations++ )
                     {
                         Ogre::Real projectVel;
                         Ogre::Vector3 castStart3, castTarget3;
@@ -658,14 +657,14 @@
                             targetVel = targetVel1;
                             distanceToFirstHit = 0.0f;
                             step = Ogre::Vector3::ZERO;
-                            pos -= upDir*m_kinematicCushion;
+                            castStart -= upDir*m_kinematicCushion;
                         }
                     }
                     
                 }
             }
 
-            Ogre::Vector3 newPos = pos + (castTarget - castStart)*distanceToFirstHit + upDir*m_kinematicCushion;
+            Ogre::Vector3 newPos = castStart + (castTarget - castStart)*distanceToFirstHit + upDir*m_kinematicCushion;
             newPos -= step;
             m_body->setPositionOrientation(newPos, ori);
 

Modified: dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-08-21 16:33:32 UTC (rev 4953)
+++ dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-08-22 14:25:07 UTC (rev 4954)
@@ -312,6 +312,9 @@
             info.mContactNormal.x = mReturnInfoList[hitnum].m_normal[0];
             info.mContactNormal.y = mReturnInfoList[hitnum].m_normal[1];
             info.mContactNormal.z = mReturnInfoList[hitnum].m_normal[2];
+            info.mContactNormalOnHitPoint.x = mReturnInfoList[hitnum].m_normalOnHitPoint[0];
+            info.mContactNormalOnHitPoint.y = mReturnInfoList[hitnum].m_normalOnHitPoint[1];
+            info.mContactNormalOnHitPoint.z = mReturnInfoList[hitnum].m_normalOnHitPoint[2];
             info.mContactPoint.x = mReturnInfoList[hitnum].m_point[0];
             info.mContactPoint.y = mReturnInfoList[hitnum].m_point[1];
             info.mContactPoint.z = mReturnInfoList[hitnum].m_point[2];



From melven at mail.berlios.de  Sat Aug 22 16:26:06 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 22 Aug 2009 16:26:06 +0200
Subject: [Dsa-hl-svn] r4955 - dependencies/OgreNewt/inc
Message-ID: <200908221426.n7MEQ6xU031602@sheep.berlios.de>

Author: melven
Date: 2009-08-22 16:26:05 +0200 (Sat, 22 Aug 2009)
New Revision: 4955

Modified:
   dependencies/OgreNewt/inc/OgreNewt.h
Log:
updated some missing comments


Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-08-22 14:25:07 UTC (rev 4954)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-08-22 14:26:05 UTC (rev 4955)
@@ -9,9 +9,9 @@
 
     main header file.
 
-    current version:  2.04.0
+    current version:  2.07.0
 
-        Newton version: 2.04 (beta)
+        Newton version: 2.07 (beta)
 
         Ogre version: Shoggoth (1.6.x)
 
@@ -41,7 +41,7 @@
 #include "OgreNewt_BodyInAABBIterator.h"
 #include "OgreNewt_Debugger.h"
 
-/*! \mainpage OgreNewt Library version 2.06.0 (for newton version 2.06)
+/*! \mainpage OgreNewt Library version 2.07.0 (for newton version 2.07)
 
     \section into_sec Introduction
 
@@ -52,15 +52,14 @@
     Problems and missing features in this version
         - HeightFieldCollision
         - PlayerController not finished
+        - player controller demo needs to be improved
         - this library supports the newton functions for multithreading but there are several functions/classes in this
           library itself, that are not thread safe (I don't need multiple threads)
-          especially the world-updates are not threadsafe in ogre (see newton forum, someone posted a solution there!)
         - the copied MovableText class (in Tools::OgreAddons) seems to have some graphics error (it's used
           to show the debugging information above each body)
         - I didn't test several features:
             - vehicle
             - joints
-            - collision-serializer
             - treecollision raycastcallback 
 
 
@@ -69,6 +68,9 @@
     New in this version
         - ConvexCast:
             - added "NormalOnHitPoint"
+        - added player controller demo
+        - updated to newton 2.07 -- interface breaking changes!
+            - added shape-id parameters for collisions (you need to set the shape id if you create the collision, cannot be changed later)
         - CustomJoint:
             - added globalToLocal function
             - feedbackCollector callback



From melven at mail.berlios.de  Sat Aug 22 23:01:28 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 22 Aug 2009 23:01:28 +0200
Subject: [Dsa-hl-svn] r4956 - in dependencies/OgreNewt:
	demos/Demo09_PlayerController inc src
Message-ID: <200908222101.n7ML1SOd031571@sheep.berlios.de>

Author: melven
Date: 2009-08-22 23:01:25 +0200 (Sat, 22 Aug 2009)
New Revision: 4956

Modified:
   dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/inc/OgreNewt.h
   dependencies/OgreNewt/inc/OgreNewt_Collision.h
   dependencies/OgreNewt/inc/OgreNewt_Tools.h
   dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
   dependencies/OgreNewt/src/OgreNewt_Tools.cpp
Log:
some work on the playercontroller etc


Modified: dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp	2009-08-22 14:26:05 UTC (rev 4955)
+++ dependencies/OgreNewt/demos/Demo09_PlayerController/OgreNewtonFrameListener.cpp	2009-08-22 21:01:25 UTC (rev 4956)
@@ -53,18 +53,17 @@
     OgreNewt::Debugger& debug(m_World->getDebugger());
     if (mKeyboard->isKeyDown(OIS::KC_F3))
     {
-        //debug.showDebugInformation();
         debug.startRaycastRecording();
         debug.clearRaycastsRecorded();
+        debug.showDebugInformation();
     }
     else
     {
-        //debug.hideDebugInformation();
         debug.clearRaycastsRecorded();
         debug.stopRaycastRecording();
+        debug.hideDebugInformation();
     }
 
-debug.startRaycastRecording();
 
 
     if (mKeyboard->isKeyDown(OIS::KC_T))

Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-08-22 14:26:05 UTC (rev 4955)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-08-22 21:01:25 UTC (rev 4956)
@@ -66,6 +66,8 @@
     \section new New in this version
 
     New in this version
+        - removed CollisionTools::CollisionCalculateAABB (because there's col->getAABB() ) and added a function to calculate the correct AABB
+          CollisionTools::CollisionCalculateFittingAABB
         - ConvexCast:
             - added "NormalOnHitPoint"
         - added player controller demo

Modified: dependencies/OgreNewt/inc/OgreNewt_Collision.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-08-22 14:26:05 UTC (rev 4955)
+++ dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-08-22 21:01:25 UTC (rev 4956)
@@ -84,6 +84,9 @@
     void makeUnique();
 
     //! get the Axis-Aligned Bounding Box for this collision shape.
+    /*!
+     * \warning The returned AABB can be too large! If you need an AABB that fits exactly use the OgreNewt::CollisionTools::CalculateFittingAABB function
+    */
     Ogre::AxisAlignedBox getAABB( const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO ) const;
 
     //! Returns the Collisiontype for this Collision

Modified: dependencies/OgreNewt/inc/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Tools.h	2009-08-22 14:26:05 UTC (rev 4955)
+++ dependencies/OgreNewt/inc/OgreNewt_Tools.h	2009-08-22 21:01:25 UTC (rev 4956)
@@ -163,10 +163,15 @@
             \param orient world orientation of the collision.
             \param pos world position of the collision.
         */
-        _OgreNewtExport Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::CollisionPtr& col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos );
+        _OgreNewtExport Ogre::AxisAlignedBox CollisionCalculateFittingAABB( const OgreNewt::CollisionPtr& col,
+                const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY,
+                const Ogre::Vector3& pos = Ogre::Vector3::ZERO );
 
-    }   // end namespace "ColliionTools"
+        //! Get a vertex of the collision in the given direction
+        _OgreNewtExport Ogre::Vector3 CollisionSupportVertex( const OgreNewt::CollisionPtr& col, const Ogre::Vector3& dir );
 
+    }   // end namespace "CollisionTools"
+
     namespace Springs
     {
     

Modified: dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-08-22 14:26:05 UTC (rev 4955)
+++ dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-08-22 21:01:25 UTC (rev 4956)
@@ -47,9 +47,9 @@
 {
     m_localFrame.setScale( Ogre::Vector3::UNIT_SCALE );
     m_localFrame.setTrans(  m_body->getCenterOfMass() );
-    Ogre::AxisAlignedBox playerAabb = m_body->getCollision()->getAABB( m_localFrame.extractQuaternion() );
+    Ogre::AxisAlignedBox playerAabb = CollisionTools::CollisionCalculateFittingAABB( m_body->getCollision(), m_localFrame.extractQuaternion() );
     Ogre::Real playerHeight = playerAabb.getSize().y;
-    Ogre::Real playerRadius = std::max(playerAabb.getSize().x, playerAabb.getSize().z);
+    Ogre::Real playerRadius = std::max(playerAabb.getSize().x, playerAabb.getSize().z) / 2.0f;
     
     m_maxRadius = playerRadius + m_kinematicCushion;
 
@@ -577,15 +577,13 @@
     }
     else
     {
-        if( distanceToFirstHit <= 1.0e-3f )
-            ;
-        else
+        if( distanceToFirstHit > 1.0e-3f )
         {
             bool isFuturePosInRamp;
 
             Ogre::Vector3 floorNormal = allBodyConvexCast.getInfoAt(0).mContactNormal;
 
-            isFuturePosInRamp = upDir.angleBetween(floorNormal) < m_maxSlope;
+            isFuturePosInRamp = upDir.angleBetween(floorNormal) > m_maxSlope;
             if( isFuturePosInRamp )
             {
                 AllBodyConvexCast allBodyConvexCast2(this);
@@ -636,7 +634,7 @@
                             floorNormal = allBodyConvexCast3.getInfoAt(0).mContactNormal;
                             filterBodies.push_back(allBodyConvexCast3.getInfoAt(0).mBody);
                             
-                            if( upDir.angleBetween( floorNormal ) < m_maxSlope )
+                            if( upDir.angleBetween( floorNormal ) > m_maxSlope )
                                 contactCount = 1;
                             else
                                 contactCount = 0;

Modified: dependencies/OgreNewt/src/OgreNewt_Tools.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2009-08-22 14:26:05 UTC (rev 4955)
+++ dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2009-08-22 21:01:25 UTC (rev 4956)
@@ -202,17 +202,35 @@
             return NewtonCollisionRayCast( col->getNewtonCollision(), &startPt.x, &endPt.x, &retNorm.x, &retColID );
         }
 
-        Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::CollisionPtr& col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos )
+        Ogre::AxisAlignedBox CollisionCalculateFittingAABB( const OgreNewt::CollisionPtr& col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos )
         {
-            float matrix[16];
-            Converters::QuatPosToMatrix( orient, pos, matrix );
-            Ogre::Vector3 min, max;
+            Ogre::Vector3 max, min;
 
-            NewtonCollisionCalculateAABB( col->getNewtonCollision(), matrix, &min.x, &max.x );
+            for( int i = 0; i < 3; i++ )
+            {
+                Ogre::Vector3 currentDir, supportVertex;
 
-            return Ogre::AxisAlignedBox( min, max );
+                currentDir = Ogre::Vector3::ZERO;
+                currentDir[i] = 1;
+                currentDir = orient*currentDir;
+                supportVertex = CollisionSupportVertex( col, currentDir ) - pos;
+                max[i] = supportVertex.dotProduct(currentDir);
+
+                currentDir *= -1.0f;
+                supportVertex = CollisionSupportVertex( col, currentDir ) - pos;
+                min[i] = -supportVertex.dotProduct(currentDir);
+            }
+
+            return Ogre::AxisAlignedBox(min, max);
         }
 
+        Ogre::Vector3 CollisionSupportVertex( const OgreNewt::CollisionPtr& col, const Ogre::Vector3& dir )
+        {
+            Ogre::Vector3 ret;
+            NewtonCollisionSupportVertex( col->getNewtonCollision(), &dir.x, &ret.x );
+            return ret;
+        }
+
     }   // end namespace "CollisionTools"
 
     namespace Springs



