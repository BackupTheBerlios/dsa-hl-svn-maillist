<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3788 - in rl/trunk/engine: common/include common/src	core/include core/src rules/include rules/src script/src script/swig
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-September/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3788%20-%20in%20rl/trunk/engine%3A%20common/include%20common/src%0A%09core/include%20core/src%20rules/include%20rules/src%20script/src%20script/swig&In-Reply-To=%3C200709021150.l82BoUCH013180%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000858.html">
   <LINK REL="Next"  HREF="000860.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3788 - in rl/trunk/engine: common/include common/src	core/include core/src rules/include rules/src script/src script/swig</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3788%20-%20in%20rl/trunk/engine%3A%20common/include%20common/src%0A%09core/include%20core/src%20rules/include%20rules/src%20script/src%20script/swig&In-Reply-To=%3C200709021150.l82BoUCH013180%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3788 - in rl/trunk/engine: common/include common/src	core/include core/src rules/include rules/src script/src script/swig">melven at mail.berlios.de
       </A><BR>
    <I>Sun Sep  2 13:50:30 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000858.html">[Dsa-hl-svn] r3787 - rl/trunk/engine/rules/src
</A></li>
        <LI>Next message: <A HREF="000860.html">[Dsa-hl-svn] r3789 - in modules: regressiontest/maps ruchin/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#859">[ date ]</a>
              <a href="thread.html#859">[ thread ]</a>
              <a href="subject.html#859">[ subject ]</a>
              <a href="author.html#859">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2007-09-02 13:49:51 +0200 (Sun, 02 Sep 2007)
New Revision: 3788

Modified:
   rl/trunk/engine/common/include/XmlHelper.h
   rl/trunk/engine/common/src/XmlHelper.cpp
   rl/trunk/engine/core/include/GameAreaEventSource.h
   rl/trunk/engine/core/include/GameAreaTypes.h
   rl/trunk/engine/core/include/GameEventManager.h
   rl/trunk/engine/core/include/Zone.h
   rl/trunk/engine/core/include/ZoneManager.h
   rl/trunk/engine/core/src/GameAreaEventSource.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/Zone.cpp
   rl/trunk/engine/core/src/ZoneManager.cpp
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/script/src/ZoneProcessor.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
-added hasTalent to creature for creaturecontroller to prevent problems if Talent &quot;Athletik&quot; does not exist
-adapted zones/areas:
now a zone can consist of different areas(you can also add holes by subtracting an area from a zone)
fixed inheritance of zone/ZoneManager
-added new zones/areas to zoneprocessor (wiki -&gt; mapformat)

Modified: rl/trunk/engine/common/include/XmlHelper.h
===================================================================
--- rl/trunk/engine/common/include/XmlHelper.h	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/common/include/XmlHelper.h	2007-09-02 11:49:51 UTC (rev 3788)
@@ -96,6 +96,14 @@
 	static CeGuiString getValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element);
 	
     /**
+	 * Ermittelt den Text eines Elementknotens
+	 *
+	 * @param element Das DOM-Element
+	 * @return Text innerhalb der Element-Tags, als CeGuiString
+	 */
+    static std::string getValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element);
+
+    /**
 	 * Setzt den Text eines Elementknotens, als UTF-8
 	 * vor Benutzung muss initializeTranscoder() aufgerufen werden
 	 *
@@ -135,6 +143,15 @@
 	static int getValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element);
 
     /**
+	 * Ermittelt den Text eines Elementknotens und parst ihn, 
+	 * um eine Ganzzahl daraus zu machen
+	 *
+	 * @param element Das DOM-Element
+	 * @return Zahl, die innerhalb der Element-Tags steht
+	 */
+    static Ogre::Real getValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element);
+
+    /**
 	 * Formt einen Ganzzahldubel in einen String um und setzt diesen als Wert
 	 *
 	 * @param element Das DOM-Element

Modified: rl/trunk/engine/common/src/XmlHelper.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlHelper.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/common/src/XmlHelper.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -84,6 +84,12 @@
 	return transcodeToString( element-&gt;getFirstChild()-&gt;getNodeValue() );
 }
 
+std::string XmlHelper::getValueAsStdString(DOMElement* element)
+{
+    RlAssert(element != NULL, &quot;XmlHelper::getValueAsStdString: Element must not be NULL&quot;);
+	return transcodeToStdString( element-&gt;getFirstChild()-&gt;getNodeValue() );
+}
+
 DOMElement* XmlHelper::setValueAsUtf8(DOMDocument* doc, DOMElement* element, utf8* value)
 {
     RlAssert(element != NULL, &quot;XmlHelper::setValueAsUtf8: Element must not be NULL&quot;);
@@ -312,6 +318,13 @@
 	return XMLString::parseInt(element-&gt;getFirstChild()-&gt;getNodeValue());
 }
 
+Ogre::Real XmlHelper::getValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element)
+{
+    RlAssert(element != NULL, &quot;XmlHelper::getValueAsInteger: Element must not be NULL&quot;);
+    return Ogre::StringConverter::parseReal(
+        transcodeToString(element-&gt;getFirstChild()-&gt;getNodeValue()).c_str());
+}
+
 DOMElement* XmlHelper::setValueAsIntegerPair(DOMDocument *doc, DOMElement *element, IntPair value)
 {
     RlAssert(element != NULL, &quot;XmlHelper::setValueAsIntegerPair: Element must not be NULL&quot;);

Modified: rl/trunk/engine/core/include/GameAreaEventSource.h
===================================================================
--- rl/trunk/engine/core/include/GameAreaEventSource.h	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/include/GameAreaEventSource.h	2007-09-02 11:49:51 UTC (rev 3788)
@@ -28,6 +28,7 @@
 
 namespace rl {
 
+class ZoneManager;
 /** 
  * GameAreaEventSource
  * Die Quelle f&#252;r Ereignisse die das betreten/verlassen eines Areals betreffen.
@@ -70,12 +71,18 @@
     bool hasListeners( ) const;
 
     /// Gibt die Art des Areals zur&#252;ck
-    GameAreaType* getGameAreaType() const { return mAreaType; };
+    GameAreaType* getGameAreaType() { return mAreaType; };
     /// Gibt die Actoren die bei der letzten Abfrage innerhalb des Areals waren zur&#252;ck
     const ActorMap&amp; getInsideAreaList() const { return mInsideAreaList; };
     /// Gibt den Actor zur&#252;ck, den das Areal umgibt
     Actor* getActor() const { return mActor; };
-private: 
+protected:
+    /// helps the zonemanager to associate zones with areas
+    friend class ZoneManager;
+    void setId(long id) {mId = id;}
+    long getId() const {return mId;}
+private:
+    long mId;
     /** Verteilt die Events an die angef&#252;gten Listener
     * F&#252;r jeden Actor wird ein einzelnes Ereigniss generiert, zuerst f&#252;r alle
     * verlassenden Actoren, dann f&#252;r die betretenden

Modified: rl/trunk/engine/core/include/GameAreaTypes.h
===================================================================
--- rl/trunk/engine/core/include/GameAreaTypes.h	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/include/GameAreaTypes.h	2007-09-02 11:49:51 UTC (rev 3788)
@@ -35,6 +35,7 @@
 class _RlCoreExport GameAreaType
 {
 public:
+    virtual ~GameAreaType();
     /** F&#252;hrt die Anfrage durch und sammelt die Aktoren innerhalb einer std::map 
      *  Key Wert ist der einzigartige Name des Actors
      *
@@ -67,11 +68,18 @@
     //virtual bool getShowDebug() const = 0;
 
     virtual OgreNewt::Body* getBody() { return NULL;}
+
+    virtual Ogre::Real getDistance(Actor* actor) = 0;
+
+    /// Der minimale abstand, den ein aktor von der zone haben muss, um die zone zu verlassen (um st&#228;ndige wechsel in und aus der zone zu vermeiden)
+    virtual Ogre::Real getTransitionDistance() const = 0;
+    virtual void setTransitionDistance(Ogre::Real dist) = 0;
 };
 
 /** GameSphereAreaType
 * Implementierung einer Kugelanfrage
 */
+/*
 class _RlCoreExport GameSphereAreaType : public GameAreaType
 {
 public:
@@ -80,7 +88,7 @@
      * @param center Das Zentrum der Kugel
      * @param radius Der Radius der Kugel
      * @param mask Die Anfrage Maske
-     */
+    
     GameSphereAreaType(Ogre::Vector3 center, Ogre::Real radius, unsigned long mask = 0xFFFFFFFF );
     /// Dekonstruktor
     virtual ~GameSphereAreaType();
@@ -105,10 +113,11 @@
     /// Die Kugel-Anfrage
     Ogre::SphereSceneQuery* mSphereQuery;
 };
+*/
 
-
 /// ein Problem k&#246;nnte die zeitliche Verschiebung um eine Framedauer sein, wenn position und orientation
 /// neu gesetzt werden, muss erst newton wieder upgedated werden!
+/// Von dieser Klasse muss abgleitet werden, sie definiert keinen eigenen body!
 class _RlCoreExport GameNewtonBodyAreaType : 
     public GameAreaType
 {
@@ -141,10 +150,16 @@
     virtual void resetFoundCollisions();
 
     virtual OgreNewt::Body* getBody() { return mBody;}
+
+    Ogre::Real getDistance(Actor* actor);
+
+    Ogre::Real getTransitionDistance() const;
+    void setTransitionDistance(Ogre::Real dist);
 protected:
     OgreNewt::Body* mBody;
     ActorMap mFoundActors;
     unsigned long mQueryMask;
+    Ogre::Real mTransitionDistance;
 };
 
 
@@ -154,11 +169,23 @@
 public:
     GameMeshAreaType(
             Ogre::Entity* entity,
-            const GeometryType&amp; geomType = GT_NONE,
-			Ogre::Vector3* offset = NULL,
-			Ogre::Quaternion* orientation = NULL);
+            GeometryType geomType = GT_CONVEXHULL,
+            Ogre::Vector3 offset = Ogre::Vector3::ZERO,
+            Ogre::Quaternion orientation = Ogre::Quaternion::IDENTITY);
 };
 
+class _RlCoreExport GameSimpleCollisionAreaType :
+    public GameNewtonBodyAreaType
+{
+public:
+    GameSimpleCollisionAreaType(
+            Ogre::AxisAlignedBox aabb,
+            GeometryType geomType = GT_BOX,
+            Ogre::Vector3 offset = Ogre::Vector3::ZERO,
+            Ogre::Quaternion orientation = Ogre::Quaternion::IDENTITY);
+};
+
+
 }
 
 #endif

Modified: rl/trunk/engine/core/include/GameEventManager.h
===================================================================
--- rl/trunk/engine/core/include/GameEventManager.h	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/include/GameEventManager.h	2007-09-02 11:49:51 UTC (rev 3788)
@@ -32,6 +32,7 @@
 
 class PhysicalThing;
 class GameNewtonBodyAreaType;
+class Zone;
 
 typedef std::set&lt;GameAreaEventSource*&gt; GameAreaEventSourceList;
 
@@ -61,13 +62,43 @@
     * @param actor Der Actor um den herum die Kugel aufgespannt werden soll
     * @param queryMask Die Maske um die SzenenAnfrage zu beschleunigen
     * @param radius Der Radius der Kugel
-    * @param list Der neu hinzuzuf&#252;gende Listener    
+    * @param list Der neu hinzuzuf&#252;gende Listener
+    * @param forceNew erstellt auf jeden Fall eine neue GameAreaEventSource (z.B. f&#252;r den ZoneManager)
+    * @retval Die GameAreaEventSource, der der Listener hinzugef&#252;gt wurde
     */
-    void addSphereAreaListener( Actor* actor, Ogre::Real radius,
-        GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
+    GameAreaEventSource* addSphereAreaListener( Actor* actor, Ogre::Real radius,
+        GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF, bool forceNew = false);
 
-	void addMeshAreaListener( Actor* meshactor, GeometryType geom, GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
+    /** F&#252;gt eine neue Mesh-Area hinzu und h&#228;ngt einen Listener an
+    *
+    * @param meshactor der meshactor um den herum die area gelegt werden soll
+    * @param geom der Geometrietype, sinnvoll w&#228;re GT_CONVEXHULL (eventuell GT_MESH)
+    * @param list Der neu hinzuzufpgende Listener
+    * @param queryMask Die Querymaske, welche Aktoren von der Area betroffen sind
+    * @param forceNew erstellt auf jeden Fall eine neue GameAreaEventSource (z.B. f&#252;r den ZoneManager)
+    * @retval Die GameAreaEventSource, der der Listener hinzugef&#252;gt wurde
+    */
+	GameAreaEventSource* addMeshAreaListener( Actor* meshactor, GeometryType geom, GameAreaListener* list, 
+        unsigned long queryMask = 0xFFFFFFFF, 
+        Ogre::Vector3 offset = Ogre::Vector3::ZERO, Ogre::Quaternion orientation = Ogre::Quaternion::IDENTITY,
+        bool forceNew = false);
 
+    /** F&#252;gt eine neue Area hinzu und h&#228;ngt einen Listener an
+    *
+    * @param actor Der Actor um den herum die Area aufgespannt werden soll
+    * @param aabb Die Gr&#246;&#223;e der Area
+    * @param geom der Geometrietype, m&#246;glich sind GT_BOX, GT_ELLIPSOID, GT_SPHERE, GT_PYRAMID
+    * @param list Der neu hinzuzufpgende Listener
+    * @param queryMask Die Querymaske, welche Aktoren von der Area betroffen sind
+    * @param forceNew erstellt auf jeden Fall eine neue GameAreaEventSource (z.B. f&#252;r den ZoneManager)
+    * @retval Die GameAreaEventSource, der der Listener hinzugef&#252;gt wurde
+    */
+	GameAreaEventSource* addAreaListener( Actor* actor, 
+        Ogre::AxisAlignedBox aabb, GeometryType geom, GameAreaListener* list, 
+        unsigned long queryMask = 0xFFFFFFFF, 
+        Ogre::Vector3 offset = Ogre::Vector3::ZERO, Ogre::Quaternion orientation = Ogre::Quaternion::IDENTITY,
+        bool forceNew = false);
+
     /** Entfernt an allen Areas diesen Listener
     *
     * @param list Der Listener an den GameAreaEventSource
@@ -76,6 +107,11 @@
     */
     void removeAreaListener( GameAreaListener* list );
 
+    /** Entfernt eine bestimmte GameAreaEventSource
+    *
+    */
+    void removeAreaEventSource( GameAreaEventSource *gam );
+
     /** Entfernt alle Areas die an einen Actor gekn&#252;pft sind
       *
       * @param actor Der Actor der GameAreaEventSource

Modified: rl/trunk/engine/core/include/Zone.h
===================================================================
--- rl/trunk/engine/core/include/Zone.h	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/include/Zone.h	2007-09-02 11:49:51 UTC (rev 3788)
@@ -17,20 +17,22 @@
 #define __Zone_H__
 
 #include &quot;CorePrerequisites.h&quot;
+#include &quot;GameEventManager.h&quot;  /* wegen GameAreaEventSourceList */
 
-#include &quot;GameAreaListener.h&quot;
 
 namespace rl {
 
 	class Actor;
 	class LightObject;
 	class Trigger;
+    class GameAreaEventSource;
+    class ZoneManager;
 
-	///@todo: Inheritance is wrong, Zone should be a GameAreaEventSource, ZoneManager a GameAreaListener
-	class _RlCoreExport Zone : public GameAreaListener
+    /// an abstraction of an zone, consisting of all GameAreaEventSources with the associated id
+    class _RlCoreExport Zone
 	{
 	public:
-		Zone(Actor* actor);
+        virtual ~Zone();
 
 		void addLight(Actor* light);
         void addSound(const Ogre::String&amp; name);
@@ -38,19 +40,23 @@
 		std::list&lt;Actor*&gt; getLights() const;
         std::list&lt;Ogre::String&gt; getSounds() const;
 		std::list&lt;Trigger*&gt; getTriggers() const;
-
-		Actor* getActor() const;
-
-		virtual void areaLeft(GameAreaEvent *anEvent);
-	    virtual void areaEntered(GameAreaEvent *anEvent);
-
+        void removeLight(Actor* light);
+        void removeSound(const Ogre::String&amp; name);
+        void removeTrigger(Trigger* trigger);
+        long getId() const {return mId;}
+    protected:
+        friend class ZoneManager;
+        Zone(long id);
+        void addEventSource(GameAreaEventSource* gam);
+        void removeEventSource(GameAreaEventSource* gam);
+        GameAreaEventSourceList&amp; getEventSources();
 	private:
+        long mId;
+        Zone();
 		std::list&lt;Actor*&gt; mLights;
 		std::list&lt;Ogre::String&gt; mSounds;
 		std::list&lt;Trigger*&gt; mTriggers;
-		Actor* mActor;
-
-		void deleteTriggers(const std::list&lt;Trigger*&gt;&amp; toDelete);
+        GameAreaEventSourceList mEventSources;
 	};
 
 }

Modified: rl/trunk/engine/core/include/ZoneManager.h
===================================================================
--- rl/trunk/engine/core/include/ZoneManager.h	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/include/ZoneManager.h	2007-09-02 11:49:51 UTC (rev 3788)
@@ -17,28 +17,62 @@
 #define __ZoneManager_H__
 
 #include &quot;CorePrerequisites.h&quot;
+#include &quot;CoreDefines.h&quot;
+#include &quot;GameAreaListener.h&quot;
 
 namespace rl
 {
     class Zone;
 
-    class _RlCoreExport ZoneManager : public Ogre::Singleton&lt;ZoneManager&gt;
+    class _RlCoreExport ZoneManager : 
+        public Ogre::Singleton&lt;ZoneManager&gt;,
+        public GameAreaListener
 	{
 	public:
 		ZoneManager();
 		~ZoneManager();
 
-        Zone* createZone(const Ogre::String&amp; name, const Ogre::Vector3&amp; position, const Ogre::Real radius, unsigned long queryflags);
-		Zone* getDefaultZone() const;
-		Zone* getZone(const Ogre::String&amp; name) const;
+        Zone* createZone(const Ogre::String&amp; name);
+        void destroyZone(const Ogre::String&amp; name);
+        /// Adds a new area to the zone
+        void addAreaToZone(const Ogre::String&amp; name, 
+            Ogre::AxisAlignedBox aabb, GeometryType geom,
+            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+        /// subtracts an area from the zone (it must ly in another area in this zone, else the beaviour is not defined)
+        void subtractAreaFromZone(const Ogre::String&amp; name, 
+            Ogre::AxisAlignedBox aabb, GeometryType geom,
+            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+        /// Adds a new mesh area to the zone
+        void addMeshAreaToZone(const Ogre::String&amp; name,
+            const Ogre::String&amp; meshname, GeometryType geom,
+            Ogre::Vector3 position,
+            Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+        /// subtracts a mesh-area from the zone (it must ly in another area in this zone, else the beaviour is not defined)
+        void subtractMeshAreaFromZone(const Ogre::String&amp; name,
+            const Ogre::String&amp; meshname, GeometryType geom,
+            Ogre::Vector3 position,
+            Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+		Zone* getDefaultZone();
+		Zone* getZone(const Ogre::String&amp; name);
+        Zone* getZone(long id);
 
-		void areaLeft(Zone* zone);
-	    void areaEntered(Zone* zone);
+		void areaLeft(GameAreaEvent* gae);
+	    void areaEntered(GameAreaEvent* gae);
 		
 	private:
 		std::map&lt;const Ogre::String, Zone*&gt; mZones;
+        std::map&lt;long, Zone*&gt; mZonesIdMap;
 		std::list&lt;Zone*&gt; mActiveZones;
 		Zone* mDefaultZone;
+        long mNextZoneId;
 
 		void switchLights();
 		void switchSounds();

Modified: rl/trunk/engine/core/src/GameAreaEventSource.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -65,11 +65,26 @@
         std::set_difference( currInside.begin(), currInside.end(),
             mInsideAreaList.begin(), mInsideAreaList.end(), enteredInsert );
 
+        // diejenigen die rausgefallen sind, aber noch nicht den noetigen abstand haben, wieder hinzufuegen
+        ActorMap reallyLeftMap;
+        ActorMap notReallyLeftMap;
+        ActorMap::iterator it = leftMap.begin();
+        for( ; it != leftMap.end(); it++ )
+        {
+            if( mAreaType-&gt;getDistance(it-&gt;second) &lt;= mAreaType-&gt;getTransitionDistance() )
+                notReallyLeftMap.insert( *it );
+            else
+                reallyLeftMap.insert( *it );
+        }
+
         // Die &#239;&#191;&#189;riggebliebenen in mInsideAreaList speichern
+        //mInsideAreaList = currInside + notReallyLeftMap;
         mInsideAreaList = currInside;
+        mInsideAreaList.insert(notReallyLeftMap.begin(), notReallyLeftMap.end());
+        
 
         // Die Neuen und die Rausgefallenen an die Listener dispatchen
-		doDispatchEvents( enteredMap, leftMap );
+		doDispatchEvents( enteredMap, reallyLeftMap );
     }
 
     void GameAreaEventSource::doDispatchEvents(

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -17,14 +17,21 @@
 
 #include &quot;GameAreaTypes.h&quot;
 
+#include &quot;Actor.h&quot;
 #include &quot;World.h&quot;
 #include &quot;CoreSubsystem.h&quot;
+#include &quot;Exception.h&quot;
 #include &quot;PhysicsManager.h&quot;
+#include &quot;PhysicalThing.h&quot;
 
 
 using namespace Ogre;
 
 namespace rl {
+    GameAreaType::~GameAreaType()
+    {
+    }
+
     void GameAreaType::addQueryFlag( unsigned long flag  )
     {
         setQueryMask(  getQueryMask() | flag );
@@ -38,7 +45,7 @@
 
 
 namespace rl {
-
+/*
     GameSphereAreaType::GameSphereAreaType(Vector3 center, Real radius, unsigned long mask)
     {
         mSphereQuery = CoreSubsystem::getSingleton().getWorld()-&gt;
@@ -99,12 +106,13 @@
     {
         return mSphereQuery-&gt;getSphere().getCenter( );
     }
+*/
 
 
 
-
     GameNewtonBodyAreaType::GameNewtonBodyAreaType() :
-        mBody(NULL)
+        mBody(NULL),
+        mTransitionDistance(0)
     {
     }
 
@@ -177,15 +185,49 @@
         return mFoundActors;
     }
 
+    Ogre::Real GameNewtonBodyAreaType::getDistance(Actor* actor)
+    {
+        if(!actor)
+            Throw(NullPointerException, &quot;Argument actor cannot be NULL!&quot;);
+        OgreNewt::World *world = 
+            PhysicsManager::getSingleton()._getNewtonWorld();
+        Vector3 retA, retB, retNorm;
+        Vector3 positionA;
+        Quaternion orientationA;
+        mBody-&gt;getPositionOrientation(positionA, orientationA);
+        int intRet = 
+            OgreNewt::CollisionTools::CollisionClosestPoint(
+                world,
+                mBody-&gt;getCollision(), orientationA, positionA,
+                actor-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision(),
+                actor-&gt;getOrientation(), actor-&gt;getPosition(),
+                retA, retB, retNorm);
+
+        if( intRet == 0 )
+            return 0;
+
+        return (retA - retB).length();
+    }
+
+    Ogre::Real GameNewtonBodyAreaType::getTransitionDistance() const
+    {
+        return mTransitionDistance;
+    }
+
+    void GameNewtonBodyAreaType::setTransitionDistance(Ogre::Real dist) 
+    {
+        mTransitionDistance = dist;
+    }
+
     GameMeshAreaType::GameMeshAreaType(
             Ogre::Entity* entity,
-            const GeometryType&amp; geomType,
-			Ogre::Vector3* offset,
-			Ogre::Quaternion* orientation)
+            GeometryType geomType,
+			Ogre::Vector3 offset,
+			Ogre::Quaternion orientation)
     {
         OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().createCollision(entity,
-            geomType, &quot;&quot;, offset, orientation);
+            PhysicsManager::getSingleton().getCollisionFactory()-&gt;createCollisionFromEntity(entity,
+            geomType, &amp;offset, &amp;orientation);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);
@@ -194,5 +236,22 @@
         mBody-&gt;setUserData(NULL);
     }
 
+    GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
+            Ogre::AxisAlignedBox aabb,
+            GeometryType geomType,
+            Ogre::Vector3 offset,
+            Ogre::Quaternion orientation)
+    {
+        OgreNewt::CollisionPtr col =
+            PhysicsManager::getSingleton().getCollisionFactory()-&gt;createCollisionFromAABB(
+            aabb, geomType, &amp;offset, &amp;orientation);
+        mBody = new OgreNewt::Body(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            col);
+        mBody-&gt;setMaterialGroupID(
+            PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
+        mBody-&gt;setUserData(NULL);
+    }
+
 }
 

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -21,8 +21,12 @@
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;MeshObject.h&quot;
 #include &quot;PhysicsManager.h&quot;
+#include &quot;Zone.h&quot;
 
 
+
+using namespace Ogre;
+
 template&lt;&gt; rl::GameEventManager* Ogre::Singleton&lt;rl::GameEventManager&gt;::ms_Singleton = 0;
 
 namespace rl {
@@ -54,11 +58,11 @@
         // remove collision callbacks
         PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
 
-        const OgreNewt::MaterialID *area_mat = physicsManager-&gt;createMaterialID(&quot;gamearea&quot;);
-        const OgreNewt::MaterialID *char_mat = physicsManager-&gt;createMaterialID(&quot;character&quot;);
-        const OgreNewt::MaterialID *def_mat = physicsManager-&gt;createMaterialID(&quot;default&quot;);
-        const OgreNewt::MaterialID *cam_mat = physicsManager-&gt;createMaterialID(&quot;camera&quot;);
-        const OgreNewt::MaterialID *lev_mat = physicsManager-&gt;createMaterialID(&quot;level&quot;);
+        const OgreNewt::MaterialID *area_mat = physicsManager-&gt;getMaterialID(&quot;gamearea&quot;);
+        const OgreNewt::MaterialID *char_mat = physicsManager-&gt;getMaterialID(&quot;character&quot;);
+        const OgreNewt::MaterialID *def_mat = physicsManager-&gt;getMaterialID(&quot;default&quot;);
+        const OgreNewt::MaterialID *cam_mat = physicsManager-&gt;getMaterialID(&quot;camera&quot;);
+        const OgreNewt::MaterialID *lev_mat = physicsManager-&gt;getMaterialID(&quot;level&quot;);
 
         physicsManager-&gt;resetMaterialPair(area_mat, char_mat);
         physicsManager-&gt;resetMaterialPair(area_mat, def_mat);
@@ -80,11 +84,18 @@
     }
 
 	/// @todo  Doppelte Aktoren nachnutzen??
-    void GameEventManager::addSphereAreaListener( Actor* actor, Ogre::Real radius,
-        GameAreaListener* list, unsigned long queryMask )
+    GameAreaEventSource* GameEventManager::addSphereAreaListener( Actor* actor, Ogre::Real radius,
+        GameAreaListener* list, unsigned long queryMask, bool forceNew )
     {
-        // Neues Areal erzeugen
-        GameAreaType* at = new GameSphereAreaType( actor-&gt;getWorldPosition(), radius, queryMask );
+        Ogre::AxisAlignedBox aabb;
+        aabb.setMaximum(radius, radius, radius);
+        aabb.setMaximum(-radius, -radius, -radius);
+        // neues areal ereugen
+        GameNewtonBodyAreaType* at = new GameSimpleCollisionAreaType(
+            aabb, GT_SPHERE);
+
+        at-&gt;setQueryMask(queryMask);
+
         // Event-Quelle erzeugen
         GameAreaEventSource* gam = new GameAreaEventSource( at, actor );
         // In die Menge einf&#252;gen
@@ -92,15 +103,23 @@
 		ScriptWrapper::getSingleton().owned( gam );
         // Und Listener anh&#228;ngen
         gam-&gt;addAreaListener( list );
+
+        // add to newton collision list
+        mBodyGameAreaMap.insert(std::make_pair(at-&gt;getBody(), at));
+
+        return gam;
     }
 
-    void GameEventManager::addMeshAreaListener( Actor* actor, GeometryType geom, GameAreaListener* list, unsigned long queryMask )
+    /// @todo  Doppelte Aktoren nachnutzen??
+    GameAreaEventSource* GameEventManager::addMeshAreaListener( 
+        Actor* actor, GeometryType geom, GameAreaListener* list, unsigned long queryMask, 
+        Vector3 offset, Quaternion orientation, bool forceNew )
     {
         // neues areal ereugen
         MeshObject* meshObj = static_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
 
         GameNewtonBodyAreaType* at = new GameMeshAreaType(
-            meshObj-&gt;getEntity(), geom);
+            meshObj-&gt;getEntity(), geom, offset, orientation);
 
         at-&gt;setQueryMask(queryMask);
 
@@ -114,8 +133,36 @@
 
         // add to newton collision list
         mBodyGameAreaMap.insert(std::make_pair(at-&gt;getBody(), at));
+
+        return gam;
     }
 
+    /// @todo  Doppelte Aktoren nachnutzen??
+    GameAreaEventSource* GameEventManager::addAreaListener(Actor* actor,
+        Ogre::AxisAlignedBox aabb, GeometryType geom, GameAreaListener* list, 
+        unsigned long queryMask, 
+        Vector3 offset, Quaternion orientation,
+        bool forceNew)
+    {
+        GameNewtonBodyAreaType* at = new GameSimpleCollisionAreaType(
+            aabb, geom, offset, orientation);
+
+        at-&gt;setQueryMask(queryMask);
+
+        // Event-Quelle erzeugen
+        GameAreaEventSource* gam = new GameAreaEventSource( at, actor );
+        // In die Menge einf&#252;gen
+        mAreaEventSources.insert( gam );
+		ScriptWrapper::getSingleton().owned( gam );
+        // Und Listener anh&#228;ngen
+        gam-&gt;addAreaListener( list );
+
+        // add to newton collision list
+        mBodyGameAreaMap.insert(std::make_pair(at-&gt;getBody(), at));
+
+        return gam;
+    }
+
     void GameEventManager::removeAreaListener( GameAreaListener* list )
     {
         GameAreaEventSourceList::iterator it;
@@ -136,6 +183,18 @@
         }
     }
 
+    void GameEventManager::removeAreaEventSource( GameAreaEventSource *gam )
+    {
+        GameAreaEventSourceList::iterator it = mAreaEventSources.find(gam);
+        if( it != mAreaEventSources.end() )
+        {
+            it = mQueuedDeletionSources.find(gam);
+            if( it == mQueuedDeletionSources.end() )
+                mQueuedDeletionSources.insert(gam);
+        }
+
+    }
+
     void GameEventManager::removeAllAreas( Actor* actor )
     {
         GameAreaEventSourceList::iterator it;
@@ -147,6 +206,7 @@
             if( gam-&gt;getActor() == actor )
             {
 				// Sp&#228;ter l&#246;schen
+
                 mQueuedDeletionSources.insert( gam );
             }
 
@@ -217,7 +277,7 @@
             return 0;
         }
 
-        LOG_WARNING(Logger::CORE, &quot;Der Kollisionsk&#246;rper konne keiner GameArea zugeordnet werden!&quot;);
+        LOG_WARNING(Logger::CORE, &quot;Der Kollisionsk&#246;rper konnte keiner GameArea zugeordnet werden!&quot;);
         return 0;
     }
 

Modified: rl/trunk/engine/core/src/Zone.cpp
===================================================================
--- rl/trunk/engine/core/src/Zone.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/src/Zone.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -26,51 +26,15 @@
 namespace rl
 {
 
-	Zone::Zone(Actor* actor)
-	 : GameAreaListener(),
-	   mActor(actor)
-	{
-	}
 
-	Actor* Zone::getActor() const
-	{
-		return mActor;
-	}
+    Zone::Zone(long id) : mId(id)
+    {
+    }
 
-	void Zone::areaLeft(GameAreaEvent *anEvent)
-	{
-		ZoneManager::getSingleton().areaLeft(this);
+    Zone::~Zone()
+    {
+    }
 
-		std::list&lt;Trigger*&gt; toDelete;
-		for (std::list&lt;Trigger*&gt;::iterator it = mTriggers.begin(); it != mTriggers.end(); ++it)
-		{
-			bool remove = (*it)-&gt;deactivate();
-			if (remove)
-			{
-				toDelete.push_back(*it);
-			}
-		}
-
-		deleteTriggers(toDelete);
-	}
-
-    void Zone::areaEntered(GameAreaEvent *anEvent)
-	{
-		ZoneManager::getSingleton().areaEntered(this);
-
-		std::list&lt;Trigger*&gt; toDelete;
-		for (std::list&lt;Trigger*&gt;::iterator it = mTriggers.begin(); it != mTriggers.end(); ++it)
-		{
-			bool remove = (*it)-&gt;activate();
-			if (remove)
-			{
-				toDelete.push_back(*it);
-			}
-		}
-
-		deleteTriggers(toDelete);
-	}
-
 	void Zone::addLight(Actor* lo)
 	{
 		if (lo != NULL)
@@ -87,6 +51,14 @@
 		}
 	}
 
+	void Zone::addTrigger(Trigger* trigger)
+	{
+		if (trigger != NULL)
+		{
+			mTriggers.push_back(trigger);
+		}
+	}
+
 	std::list&lt;Actor*&gt; Zone::getLights() const
 	{
 		std::list&lt;Actor*&gt; rval(mLights);
@@ -99,17 +71,66 @@
 		return rval;
 	}
 
+	std::list&lt;Trigger*&gt; Zone::getTriggers() const
+	{
+		std::list&lt;Trigger*&gt; rval(mTriggers);
+		return rval;
+	}
 
-	void Zone::deleteTriggers(const std::list&lt;Trigger*&gt;&amp; toDelete)
+    void Zone::removeLight(Actor *light)
+    {
+        if( !light )
+            Throw(NullPointerException, &quot;Light-Actor is NULL!&quot;);
+        std::list&lt;Actor*&gt;::iterator it = 
+            std::find(mLights.begin(), mLights.end(), light);
+        if( it == mLights.end() )
+            Throw(IllegalArgumentException, &quot;Could not find light-actor '&quot; + light-&gt;getName() + &quot;' in this zone!&quot;);
+
+        mLights.erase(it);
+    }
+
+    void Zone::removeSound(const Ogre::String&amp; sound)
+    {
+        std::list&lt;Ogre::String&gt;::iterator it = 
+            std::find(mSounds.begin(), mSounds.end(), sound);
+        if( it == mSounds.end() )
+            Throw(IllegalArgumentException, &quot;Could not find sound '&quot; + sound + &quot;' in this zone!&quot;);
+
+        mSounds.erase(it);
+    }
+
+    void Zone::removeTrigger(Trigger* trigger)
+    {
+        if( !trigger )
+            Throw(NullPointerException, &quot;Trigger is NULL!&quot;);
+        std::list&lt;Trigger*&gt;::iterator it = 
+            std::find(mTriggers.begin(), mTriggers.end(), trigger);
+        if( it == mTriggers.end() )
+            Throw(IllegalArgumentException, &quot;Could not find the Trigger in this zone!&quot;);
+
+        mTriggers.erase(it);
+    }
+
+    void Zone::addEventSource(GameAreaEventSource *gam)
+    {
+        if( gam != NULL )
+            mEventSources.insert(gam);
+    }
+
+    void Zone::removeEventSource(GameAreaEventSource *gam)
+    {
+        if( gam )
+        {
+            GameAreaEventSourceList::iterator it = mEventSources.find(gam);
+            if( it == mEventSources.end() )
+                LOG_ERROR(Logger::CORE, &quot;Could not find the GameAreaEventSource in this zone!&quot;);
+
+            mEventSources.erase(it);
+        }
+    }
+
+	GameAreaEventSourceList&amp; Zone::getEventSources()
 	{
-		for (std::list&lt;Trigger*&gt;::const_iterator it = toDelete.begin();
-			it != toDelete.end(); ++it)
-		{
-			const Trigger* cur = *it;
-
-			std::list&lt;Trigger*&gt;::iterator trigIt =
-				std::find(mTriggers.begin(), mTriggers.end(), cur);
-			mTriggers.erase(trigIt);
-		}
+		return mEventSources;
 	}
 }

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -22,6 +22,10 @@
 #include &quot;GameEventManager.h&quot;
 #include &quot;Zone.h&quot;
 
+
+using namespace Ogre;
+
+
 template&lt;&gt; rl::ZoneManager* Ogre::Singleton&lt;rl::ZoneManager&gt;::ms_Singleton = 0;
 
 namespace rl
@@ -30,32 +34,33 @@
 		: Ogre::Singleton&lt;ZoneManager&gt;()
 	{
 		// the default zone is active when no other Zone is active
-		mDefaultZone = new Zone(NULL);
+		mDefaultZone = new Zone(0);
+        mNextZoneId = 1;
 		mActiveZones.push_front(mDefaultZone);
 	}
 
 	ZoneManager::~ZoneManager()
 	{
+        GameEventManager::getSingleton().removeAreaListener(this);
+        GameEventManager::getSingleton().removeQueuedDeletionSources();
 		for (std::map&lt;const Ogre::String, Zone*&gt;::iterator it = mZones.begin(); it != mZones.end(); ++it)
 		{
 			Zone* curZone = (*it).second;
-			GameEventManager::getSingleton().removeAreaListener(curZone);
+            delete curZone;
 		}
-		GameEventManager::getSingleton().removeQueuedDeletionSources();
 		delete mDefaultZone;
 	}
 
-	Zone* ZoneManager::getDefaultZone() const
+	Zone* ZoneManager::getDefaultZone()
 	{
 		return mDefaultZone;
 	}
 
-	Zone* ZoneManager::getZone(const Ogre::String&amp; name) const
+	Zone* ZoneManager::getZone(const Ogre::String&amp; name)
 	{
 		std::map&lt;const Ogre::String, Zone*&gt;::const_iterator it = mZones.find(name);
 		if (it == mZones.end())
 		{
-			LOG_ERROR(Logger::CORE, &quot;Zone '&quot;+name+&quot;' not found.&quot;);
 			return NULL;
 		}
 		else
@@ -64,30 +69,198 @@
 		}
 	}
 
-    Zone* ZoneManager::createZone(const Ogre::String&amp; name, const Ogre::Vector3&amp; position, const Ogre::Real radius, unsigned long queryflags)
+	Zone* ZoneManager::getZone(long id)
 	{
+		std::map&lt;long, Zone*&gt;::const_iterator it = mZonesIdMap.find(id);
+		if (it == mZonesIdMap.end())
+		{
+			return NULL;
+		}
+		else
+		{
+			return (*it).second;
+		}
+	}
 
-		Actor* kugelDings = ActorManager::getSingleton().createEmptyActor(&quot;Light zone center&quot;);
-		kugelDings-&gt;placeIntoScene(position);
-		Zone* lz = new Zone(kugelDings);
-		mZones[name] = lz;
-		GameEventManager::getSingleton().addSphereAreaListener(kugelDings, radius, lz, queryflags);
+    Zone* ZoneManager::createZone(const Ogre::String&amp; name)
+	{
+        Zone* zone = new Zone(mNextZoneId);
+        mZonesIdMap[mNextZoneId] = zone;
+        mZones[name] = zone;
+        mNextZoneId++;
 
-		return lz;
+		return zone;
 	}
 
-	void ZoneManager::areaLeft(Zone* zone)
+    void ZoneManager::destroyZone(const Ogre::String&amp; name)
+    {
+        Zone* zone = getZone(name);
+        if(zone == NULL)
+            return;
+
+        //destroy all areas
+        GameAreaEventSourceList::iterator iter = zone-&gt;getEventSources().begin();
+        for( ; iter != zone-&gt;getEventSources().end(); iter++ )
+        {
+            // we have our own actors, remove them
+            ActorManager::getSingleton().destroyActor( (*iter)-&gt;getActor() );
+		    GameEventManager::getSingleton().removeAreaEventSource(
+                (*iter));
+        }
+
+        std::map&lt;const Ogre::String, Zone*&gt;::iterator it = mZones.find(name);
+        if( it != mZones.end() )
+            mZones.erase(it);
+
+        std::map&lt;long, Zone*&gt;::iterator it_ = mZonesIdMap.find(zone-&gt;getId());
+        if( it_ != mZonesIdMap.end() )
+            mZonesIdMap.erase(it_);
+
+        delete zone;
+    }
+
+    void ZoneManager::addAreaToZone(const Ogre::String&amp; name, 
+        AxisAlignedBox aabb, GeometryType geom,
+        Vector3 position, Vector3 offset, Quaternion orientation,
+        Real transitionDistance,
+        unsigned long queryflags)
+    {
+        Zone* zone = getZone(name);
+        if( !zone )
+            return;
+
+        Actor* actor = ActorManager::getSingleton().createEmptyActor(&quot;Zone_&quot;+name);
+        actor-&gt;placeIntoScene(position);
+
+        GameAreaEventSource* gam =
+            GameEventManager::getSingleton().addAreaListener(actor, 
+                aabb, geom, this, queryflags, offset, orientation, true);
+
+        gam-&gt;getGameAreaType()-&gt;setTransitionDistance(transitionDistance);
+        gam-&gt;setId(zone-&gt;getId());
+    }
+    
+    void ZoneManager::subtractAreaFromZone(const Ogre::String&amp; name, 
+        AxisAlignedBox aabb, GeometryType geom,
+        Vector3 position, Vector3 offset, Quaternion orientation,
+        Real transitionDistance,
+        unsigned long queryflags)
+    {
+        Zone* zone = getZone(name);
+        if( !zone )
+            return;
+
+        Actor* actor = ActorManager::getSingleton().createEmptyActor(&quot;Zone_Area_&quot;+name);
+        actor-&gt;placeIntoScene(position);
+
+        GameAreaEventSource* gam =
+            GameEventManager::getSingleton().addAreaListener(actor, 
+                aabb, geom, this, queryflags, offset, orientation, true);
+
+        gam-&gt;getGameAreaType()-&gt;setTransitionDistance(transitionDistance);
+        gam-&gt;setId( - (zone-&gt;getId())); // a negative id indicates to subtract this area from the zone
+    }
+
+    void ZoneManager::addMeshAreaToZone(const Ogre::String&amp; name,
+        const Ogre::String&amp; meshname, GeometryType geom,
+        Vector3 position,
+        Vector3 scale, Vector3 offset, Quaternion orientation,
+        Real transitionDistance,
+        unsigned long queryflags)
+    {
+        Zone* zone = getZone(name);
+        if( !zone )
+            return;
+
+        Actor *actor = ActorManager::getSingleton().createMeshActor(
+            &quot;Zone_MeshArea_&quot;+name+&quot;_&quot;+meshname, 
+            meshname, GT_NONE); // don't create physics-proxy
+        if(!actor)
+            return;
+
+        actor-&gt;placeIntoScene(position);
+        actor-&gt;setScale(scale.x, scale.y, scale.z);
+
+        GameAreaEventSource* gam =
+            GameEventManager::getSingleton().addMeshAreaListener(
+                actor, geom, this, queryflags, offset, orientation, true);
+
+        gam-&gt;getGameAreaType()-&gt;setTransitionDistance(transitionDistance);
+        gam-&gt;setId( zone-&gt;getId() );
+    }
+
+    void ZoneManager::subtractMeshAreaFromZone(const Ogre::String&amp; name,
+        const Ogre::String&amp; meshname, GeometryType geom,
+        Vector3 position,
+        Vector3 scale, Vector3 offset, Quaternion orientation,
+        Real transitionDistance,
+        unsigned long queryflags)
+    {
+        Zone* zone = getZone(name);
+        if( !zone )
+            return;
+
+        Actor *actor = ActorManager::getSingleton().createMeshActor(
+            &quot;Zone_MeshArea_&quot;+name+&quot;_&quot;+meshname, 
+            meshname, GT_NONE); // don't create physics-proxy
+        if(!actor)
+            return;
+
+        actor-&gt;placeIntoScene(position);
+        actor-&gt;setScale(scale.x, scale.y, scale.z);
+
+        GameAreaEventSource* gam =
+            GameEventManager::getSingleton().addMeshAreaListener(
+                actor, geom, this, queryflags, offset, orientation, true);
+
+        gam-&gt;getGameAreaType()-&gt;setTransitionDistance(transitionDistance);
+        gam-&gt;setId( - (zone-&gt;getId()) ); // a negative id indicates to subtract this area from the zone
+    }
+
+	void ZoneManager::areaLeft(GameAreaEvent* gae)
 	{
-		mActiveZones.remove(zone);
-		switchLights();
-		switchSounds();
+        long id = gae-&gt;getSource()-&gt;getId();
+        if( id != 0 )
+        {
+            if( id &gt; 0 )
+            {
+                Zone *zone = getZone(id);
+                if( zone )
+                    mActiveZones.remove(zone);
+            }
+            else
+            {
+                Zone *zone = getZone(-id); // means we have to subtract this area from the zone
+                if( zone )
+                    mActiveZones.push_front(zone);
+            }
+
+		    switchLights();
+		    switchSounds();
+        }
 	}
 
-	void ZoneManager::areaEntered(Zone* zone)
+	void ZoneManager::areaEntered(GameAreaEvent* gae)
 	{
-		mActiveZones.push_front(zone);
-		switchLights();
-		switchSounds();
+        long id = gae-&gt;getSource()-&gt;getId();
+        if( id != 0 )
+        {
+            if( id &gt; 0 )
+            {
+                Zone *zone = getZone(id);
+                if( zone )
+                    mActiveZones.push_front(zone);
+            }
+            else
+            {
+                Zone *zone = getZone(-id); // means we have to subtract this area from the zone
+                if( zone )
+                    mActiveZones.remove(zone);
+            }
+
+		    switchLights();
+		    switchSounds();
+        }
 	}
 
 	void ZoneManager::switchLights()

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/rules/include/Creature.h	2007-09-02 11:49:51 UTC (rev 3788)
@@ -349,6 +349,14 @@
              *  @throws InvalidArgumentException Das Talent konnte in \c mTalente
              *   nicht gefunden werden.
              */
+
+            /**
+                  * Gibt true zurueck, falls das Talent \a talentName \a gefunden wurde
+              * @param talentName Bezeichnet das Talent
+              * @param checkAusweichTalente Gibt an, ob ebenfalls nach Ausweichtalenten gesucht werden soll
+            */
+            bool hasTalent(const CeGuiString talentName, bool checkAusweichTalente = true);
+
             virtual int getTalent(const CeGuiString talentName);
             /**
                    *  Setzt den Wert des Talents \a talentName.

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -364,6 +364,29 @@
 		fireObjectStateChangeEvent();
     }
 
+    bool Creature::hasTalent(const CeGuiString talentName, bool ausweich)
+    {
+		checkEffects();
+        TalentMap::const_iterator it = mTalente.find(talentName);
+        if (it != mTalente.end())
+            return true;
+        /*
+        if( ausweich )
+        {
+            Talent::AusweichTalente ausweichTalente;
+            ausweichTalente =
+                DsaManager::getSingleton().getTalent(talentName)-&gt;getAusweichTalente();
+            Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
+            if (ausweichIt != ausweichTalente.end())
+            {
+                return true;
+            }
+        }
+        */
+		
+        return false;
+    }
+
     int Creature::getTalent(const CeGuiString talentName)
     {
         TalentMap::const_iterator it = mTalente.find(talentName);

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -432,7 +432,7 @@
             if( mLastProbe + Date::ONE_SPIELRUNDE &gt;= now || mLastProbe == 0 )
             {
                 mTimePerAu = 120; // was 180
-                try
+                if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
                 {
                     mLastProbe = now;
                     int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;,0);
@@ -449,7 +449,7 @@
                         mTimePerAu += taw * 5;
                     }
                 }
-                catch(IllegalArgumentException)
+                else
                 {
                     mTimePerAu = 120; // was 180
                 }
@@ -542,7 +542,7 @@
             if( mLastProbe + mMovingCreature-&gt;getCreature()-&gt;getAuMax() * Date::ONE_SECOND &gt;= now || mLastProbe == 0)
             {
                 mVelocityImprovement = 0;
-                try
+                if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
                 {
                     mLastProbe = now;
                     int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;,0);
@@ -559,7 +559,7 @@
                         mVelocityImprovement += taw * 0.1;
                     }
                 }
-                catch(IllegalArgumentException)
+                else
                 {
                     mVelocityImprovement = 0;
                 }
@@ -728,7 +728,7 @@
             mTimer = 0;
             calculateBaseVelocity(mHeight);
 
-            try
+            if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
             {
                 int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;, 0);
                 if( taw &gt; 0 )
@@ -747,7 +747,7 @@
                     }
                 }
             }
-            catch(IllegalArgumentException)
+            else
             {
             }
             mMovingCreature-&gt;getCreature()-&gt;damageAu(2./3);
@@ -896,22 +896,22 @@
             mTimer = 0;
             calculateBaseVelocity(mWidth);
 
-            try
+
+            // the person will only achieve this width if it is running
+            // retrieve run movement
+            AbstractMovement *run = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_RENNEN);
+            if( run != NULL )
             {
-                // the person will only achieve this width if it is running
-                // retrieve run movement
-                AbstractMovement *run = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_RENNEN);
-                if( run != NULL )
-                {
-                    Real vel(0);
-                    run-&gt;calculateBaseVelocity(vel);
-                    Real factor = -mMovingCreature-&gt;getVelocity().z / vel;
-                    factor = std::max(Real(0),factor);
-                    // without moving before, the width will be 1/3
-                    mWidth = mWidth/3. + mWidth * 2./3. * factor;
-                }
+                Real vel(0);
+                run-&gt;calculateBaseVelocity(vel);
+                Real factor = -mMovingCreature-&gt;getVelocity().z / vel;
+                factor = std::max(Real(0),factor);
+                // without moving before, the width will be 1/3
+                mWidth = mWidth/3. + mWidth * 2./3. * factor;
+            }
 
-
+            if( mMovingCreature-&gt;getCreature()-&gt;hasTalent(&quot;Athletik&quot;) )
+            {
                 int taw = mMovingCreature-&gt;getCreature()-&gt;doTalentprobe(&quot;Athletik&quot;, 0);
                 if( taw &gt; 0 )
                 {
@@ -929,9 +929,7 @@
                     }
                 }
             }
-            catch(IllegalArgumentException)
-            {
-            }
+
             mMovingCreature-&gt;getCreature()-&gt;damageAu(2./3);
         }
         virtual void deactivate()

Modified: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-09-02 11:49:51 UTC (rev 3788)
@@ -45,40 +45,122 @@
 				&amp;&amp; XmlHelper::hasNodeName(cur, &quot;zone&quot;))
             {
 				DOMElement* curZoneElem = static_cast&lt;DOMElement*&gt;(cur);
-				if (XmlHelper::hasAttribute(curZoneElem, &quot;type&quot;))
+				if (XmlHelper::hasAttribute(curZoneElem, &quot;name&quot;))
 				{
-					Ogre::String type = XmlHelper::getAttributeValueAsStdString(curZoneElem, &quot;type&quot;);
-					Zone* zone = NULL;
-					if (type == &quot;default&quot;)
-					{
-						zone = ZoneManager::getSingleton().getDefaultZone();
-					}
-					else if (type == &quot;mesh&quot;)
-					{
-						///@todo: zone = ZoneManager::getSingleton().createZone(...);
-					}
-					else if (type == &quot;sphere&quot;)
-					{
-						Vector3 center = Vector3::ZERO;
-						DOMElement* centerElem = XmlHelper::getChildNamed(curZoneElem, &quot;center&quot;);
-						if (centerElem != NULL)
-						{
-							center = XmlHelper::getValueAsVector3(centerElem);
-						}
+					Ogre::String name = XmlHelper::getAttributeValueAsStdString(curZoneElem, &quot;name&quot;);
+                    Zone* zone = NULL;
+                    if( name == &quot;default&quot; )
+                        zone = ZoneManager::getSingleton().getDefaultZone();
+                    else
+                    {
+                        // get the zone with that name or create one
+                        zone = ZoneManager::getSingleton().getZone(name);
+                        if( !zone )
+                            zone = ZoneManager::getSingleton().createZone(name);
 
-						Real radius = 1;
-						DOMElement* radiusElem = XmlHelper::getChildNamed(curZoneElem, &quot;radius&quot;);
-						if (radiusElem != NULL)
-						{
-							radius = XmlHelper::getAttributeValueAsReal(radiusElem, &quot;r&quot;);
-						}
+                        // multiple areas
+                        for(DOMNode* curArea = cur-&gt;getFirstChild(); curArea != NULL; curArea = curArea-&gt;getNextSibling())
+                        {
+                            if( curArea-&gt;getNodeType() == DOMNode::ELEMENT_NODE
+                                &amp;&amp; XmlHelper::hasNodeName(curArea, &quot;area&quot;) )
+                            {
+                                DOMElement *curAreaElem = static_cast&lt;DOMElement*&gt;(curArea);
+                                if( XmlHelper::hasAttribute(curAreaElem, &quot;type&quot;) )
+                                {
+                                    // type
+                                    Ogre::String type;
+                                    type = XmlHelper::getAttributeValueAsStdString(curAreaElem, &quot;type&quot;);
 
-						Ogre::String name = XmlHelper::getAttributeValueAsStdString(curZoneElem, &quot;name&quot;);
+                                    // add or subtract?
+                                    bool subtract = false;
+                                    if( XmlHelper::hasAttribute(curAreaElem, &quot;subtract&quot;) )
+                                        subtract = XmlHelper::getAttributeValueAsBool(curAreaElem, &quot;subtract&quot;);
 
-						zone = ZoneManager::getSingleton().createZone(
-							name, center, radius, QUERYFLAG_PLAYER);
-					}
+                                    // position
+                                    Vector3 position = Vector3::ZERO;
+                                    DOMElement* positionElem = XmlHelper::getChildNamed(curAreaElem, &quot;position&quot;);
+                                    if( positionElem != NULL )
+                                        position = XmlHelper::getValueAsVector3(positionElem);
 
+                                    //scale, rotation, offset
+                                    Vector3 scale = Vector3::UNIT_SCALE;
+                                    DOMElement* scaleElem = XmlHelper::getChildNamed(curAreaElem, &quot;scale&quot;);
+                                    if( scaleElem != NULL )
+                                        scale = XmlHelper::getValueAsVector3(scaleElem);
+
+                                    Vector3 offset = Vector3::ZERO;
+                                    DOMElement* offsetElem = XmlHelper::getChildNamed(curAreaElem, &quot;offset&quot;);
+                                    if( offsetElem != NULL )
+                                        offset = XmlHelper::getValueAsVector3(offsetElem);
+
+                                    Quaternion rotation = Quaternion::IDENTITY;
+                                    DOMElement* rotationElem = XmlHelper::getChildNamed(curAreaElem, &quot;rotation&quot;);
+                                    if( rotationElem != NULL )
+                                        rotation = XmlHelper::getValueAsQuaternion(rotationElem);
+
+                                    //transition distance
+                                    Real transitionDistance = 0;
+                                    DOMElement* transitionElem = XmlHelper::getChildNamed(curAreaElem, &quot;transition_distance&quot;);
+                                    if( transitionElem != NULL )
+                                        transitionDistance = XmlHelper::getValueAsReal(transitionElem);
+
+					            
+                                    if (type == &quot;mesh&quot;)
+    					            {
+                                        Ogre::String meshName;
+                                        if( XmlHelper::hasAttribute(curAreaElem, &quot;meshfile&quot;) )
+                                        {
+                                            meshName = XmlHelper::getAttributeValueAsStdString(curAreaElem, &quot;meshfile&quot;);
+                                            if( subtract )
+                                                ZoneManager::getSingleton().subtractMeshAreaFromZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            else
+                                                ZoneManager::getSingleton().addMeshAreaToZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                        }
+                                        else
+                                            LOG_ERROR(Logger::SCRIPT, &quot;an &lt;area&gt; element with type=\&quot;mesh\&quot; must have attribute 'meshfile'&quot;);
+                                    }
+    					            else
+                                    {
+                                        GeometryType geom = GT_NONE;
+                                        if (type == &quot;sphere&quot; )
+                                            geom = GT_SPHERE;
+                                        else if (type == &quot;box&quot; )
+                                            geom = GT_BOX;
+                                        else if (type == &quot;ellipsoid&quot; )
+                                            geom = GT_ELLIPSOID;
+                                        else if (type == &quot;pyramid&quot; )
+                                            geom = GT_PYRAMID;
+                                        else if (type == &quot;capsule&quot; )
+                                            geom = GT_CAPSULE;
+                                        else
+                                        {
+                                            LOG_ERROR(Logger::SCRIPT, &quot;Unknown area type '&quot; + type + &quot;' !&quot;);
+                                        }
+                                        if ( geom != GT_NONE )
+                                        {
+                                            Ogre::AxisAlignedBox aabb;
+                                            aabb.setMinimum( - scale / 2.0f);
+                                            aabb.setMaximum( + scale / 2.0f);
+
+                                            if( subtract )
+                                                ZoneManager::getSingleton().subtractAreaFromZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            else
+                                                ZoneManager::getSingleton().addAreaToZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                        }
+                                    }
+                                }
+                                else
+                                {
+                                    LOG_ERROR(Logger::SCRIPT, &quot;&lt;area&gt; elemt must have attribute 'type'&quot;);
+                                }
+                            }
+                        }
+                    }
+
 					if (zone != NULL)
 					{
 						for (DOMNode* cur = curZoneElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
@@ -111,12 +193,12 @@
 					}
 					else
 					{
-						LOG_ERROR(Logger::RULES, &quot;Zone of type '&quot;+type+&quot;' could not be processes.&quot;);
+						LOG_ERROR(Logger::SCRIPT, &quot;Zone named '&quot;+name+&quot;' could not be processes.&quot;);
 					}
 				}
 				else
 				{
-					LOG_ERROR(Logger::RULES, &quot;&lt;zone&gt; element must have attribute 'type'.&quot;);
+					LOG_ERROR(Logger::SCRIPT, &quot;&lt;zone&gt; element must have attribute 'name'.&quot;);
 				}
 			}
 		}

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-09-02 11:49:51 UTC (rev 3788)
@@ -14,7 +14,9 @@
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
 
+
 namespace rl {
+/*
 %{
 static swig_type_info *GameAreaType_dynamic_cast(void **ptr) {
     rl::GameAreaType *pGameAreaType = static_cast&lt;rl::GameAreaType *&gt;(*ptr);
@@ -29,9 +31,9 @@
 }
 %}
 DYNAMIC_CAST(SWIGTYPE_p_rl__GameAreaType, GameAreaType_dynamic_cast);
+*/
 
 
-
 %{
 static swig_type_info *BaseAnimation_dynamic_cast(void **ptr) {
     rl::BaseAnimation *pBaseAnimation = static_cast&lt;rl::BaseAnimation *&gt;(*ptr);
@@ -205,13 +207,14 @@
     const Ogre::Vector3&amp; getQueryPosition() const;
 };
 
+/*
 class GameSphereAreaType : public GameAreaType
 {
 private:
 	GameSphereAreaType( Ogre::Vector3, Ogre::Real, unsigned long mask = 0xFFFFFFFF );
 public:
 };
-
+*/
 class GameAreaEventSource
 {
 private: 
@@ -221,7 +224,7 @@
     void removeAreaListener( rl::GameAreaListener* list );
     bool hasListeners( ) const;
 
-    rl::GameAreaType* getGameAreaType() const;
+    rl::GameAreaType* getGameAreaType();
     // const ActorMap&amp; getInsideAreaList() const;
     rl::Actor* getActor() const;
 };
@@ -885,20 +888,59 @@
 
 class Zone
 {
-private:
-	Zone(Actor* actor);
 public:
 	void addLight(Actor* light);
-	void addSound(const Ogre::String&amp; sound);
+    void addSound(const Ogre::String&amp; name);
+	//void addTrigger(Trigger* trigger);
+	std::list&lt;Actor*&gt; getLights() const;
+    std::list&lt;Ogre::String&gt; getSounds() const;
+	//std::list&lt;Trigger*&gt; getTriggers() const;
+    void removeLight(Actor* light);
+    void removeSound(const Ogre::String&amp; name);
+    //void removeTrigger(Trigger* trigger);
+protected:
+    Zone(long id);
+private:
+    Zone();
 };
 
+
 class ZoneManager
 {
 public:
 	static const ZoneManager&amp; getSingleton();
-	Zone* createZone(const Ogre::String&amp; name, const Ogre::Vector3&amp; position, const Ogre::Real radius, unsigned long queryflags);
-	Zone* getDefaultZone() const;
-	Zone* getZone(const Ogre::String&amp; name) const;
+    rl::Zone* createZone(const Ogre::String&amp; name);
+    void destroyZone(const Ogre::String&amp; name);
+
+    void addAreaToZone(const Ogre::String&amp; name, 
+        Ogre::AxisAlignedBox aabb, rl::GeometryType geom,
+        Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+
+    void subtractAreaFromZone(const Ogre::String&amp; name, 
+        Ogre::AxisAlignedBox aabb, rl::GeometryType geom,
+        Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+
+    void addMeshAreaToZone(const Ogre::String&amp; name,
+        const Ogre::String&amp; meshname, rl::GeometryType geom,
+        Ogre::Vector3 position,
+        Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+
+    void subtractMeshAreaFromZone(const Ogre::String&amp; name,
+        const Ogre::String&amp; meshname, rl::GeometryType geom,
+        Ogre::Vector3 position,
+        Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+        
+	rl::Zone* getDefaultZone();
+	rl::Zone* getZone(const Ogre::String&amp; name);
+    rl::Zone* getZone(long id);
 };
 
 class  Trigger

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-09-01 22:12:20 UTC (rev 3787)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-09-02 11:49:51 UTC (rev 3788)
@@ -681,6 +681,7 @@
 
         
         void addTalent(const rl::CeGuiString talentName, int value=0);
+        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
         virtual int getTalent(const rl::CeGuiString talentName);
         virtual void setTalent(const rl::CeGuiString talentName, int value);
         virtual void modifyTalent(const rl::CeGuiString talentName, int mod);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000858.html">[Dsa-hl-svn] r3787 - rl/trunk/engine/rules/src
</A></li>
	<LI>Next message: <A HREF="000860.html">[Dsa-hl-svn] r3789 - in modules: regressiontest/maps ruchin/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#859">[ date ]</a>
              <a href="thread.html#859">[ thread ]</a>
              <a href="subject.html#859">[ subject ]</a>
              <a href="author.html#859">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
