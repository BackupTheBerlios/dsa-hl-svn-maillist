<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4722 - in dependencies/OgreNewt_ngt: . inc src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4722%20-%20in%20dependencies/OgreNewt_ngt%3A%20.%20inc%20src&In-Reply-To=%3C200901272132.n0RLWsc2022780%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001778.html">
   <LINK REL="Next"  HREF="001780.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4722 - in dependencies/OgreNewt_ngt: . inc src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4722%20-%20in%20dependencies/OgreNewt_ngt%3A%20.%20inc%20src&In-Reply-To=%3C200901272132.n0RLWsc2022780%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4722 - in dependencies/OgreNewt_ngt: . inc src">melven at mail.berlios.de
       </A><BR>
    <I>Tue Jan 27 22:32:54 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001778.html">[Dsa-hl-svn] r4721 - in rl/trunk/editors/Lockenwickler: .	_eric4project src src/media src/plugins ui files
</A></li>
        <LI>Next message: <A HREF="001780.html">[Dsa-hl-svn] r4723 - in rl/branches/newton20: .	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/plugins editors/Lockenwickler/ui	files engine/core engine/core/include engine/core/src	engine/rules/src engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1779">[ date ]</a>
              <a href="thread.html#1779">[ thread ]</a>
              <a href="subject.html#1779">[ subject ]</a>
              <a href="author.html#1779">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2009-01-27 22:32:51 +0100 (Tue, 27 Jan 2009)
New Revision: 4722

Added:
   dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h
   dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp
Modified:
   dependencies/OgreNewt_ngt/CMakeLists.txt
   dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt_ngt/src/OgreNewt_Body.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
Log:
-Debugger: added Ray- and Convexcast ability
-added Classes for PlayerController (not working yet, in fact half of the code is missing)


Modified: dependencies/OgreNewt_ngt/CMakeLists.txt
===================================================================
--- dependencies/OgreNewt_ngt/CMakeLists.txt	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/CMakeLists.txt	2009-01-27 21:32:51 UTC (rev 4722)
@@ -82,7 +82,8 @@
 src/OgreNewt_RayCast.cpp
 src/OgreNewt_Tools.cpp
 src/OgreNewt_Vehicle.cpp
-src/OgreNewt_World.cpp)
+src/OgreNewt_World.cpp
+src/OgreNewt_PlayerController.cpp)
 
 ADD_LIBRARY(OgreNewt SHARED ${OgreNewt_LIB_SRCS})
 
@@ -106,7 +107,7 @@
 inc/OgreNewt_ContactCallback.h inc/OgreNewt_Debugger.h inc/OgreNewt.h
 inc/OgreNewt_Joint.h inc/OgreNewt_MaterialID.h inc/OgreNewt_MaterialPair.h
 inc/OgreNewt_Prerequisites.h inc/OgreNewt_RayCast.h inc/OgreNewt_Tools.h
-inc/OgreNewt_Vehicle.h inc/OgreNewt_World.h
+inc/OgreNewt_Vehicle.h inc/OgreNewt_World.h inc/OgreNewt_PlayerController.h
 DESTINATION ${CMAKE_INSTALL_PREFIX}/include/OgreNewt)
 
 IF(NOT WIN32)

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h	2009-01-27 21:32:51 UTC (rev 4722)
@@ -321,6 +321,9 @@
 	//! get angular damping
 	Ogre::Vector3 getAngularDamping() const;
 
+    //! calculate force needed for given velocity
+    Ogre::Vector3 calculateInverseDynamicsForce(Ogre::Real timestep, Ogre::Vector3 desiredVelocity);
+
 	//! get the freeze threshold
 	//void getFreezeThreshold( Ogre::Real&amp; speed, Ogre::Real&amp; omega ) const { NewtonBodyGetFreezeTreshold( m_body, &amp;speed, &amp;omega ); }
 

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h	2009-01-27 21:32:51 UTC (rev 4722)
@@ -58,7 +58,36 @@
 
         //! set Material color
         void setMaterialColor(const MaterialID* mat, Ogre::ColourValue col);
-	
+
+        //! enable additional raycast-debugging (this also enables displaying of recorded raycasts!)
+        void startRaycastRecording(bool markhitbodies = false);
+
+        //! returns true, if currently recording raycasts
+        bool isRaycastRecording();
+
+        //! returns true, if hit bodies are currently recording
+        bool isRaycastRecordingHitBodies();
+
+        //! clears all raycasts, that are currently shown, should probably be done once per frame!
+        void clearRaycastsRecorded();
+
+        //! disables raycast-debugging
+        void stopRaycastRecording();
+
+        //! set the color of the raycast-debug-lines
+        void setRaycastRecordingColor(Ogre::ColourValue rayCol, Ogre::ColourValue convexCol, Ogre::ColourValue hitBodyCol, Ogre::ColourValue prefilterDiscardedBodyCol);
+
+        //! this function is used internally
+        void addRay(const Ogre::Vector3 &amp;startpt, const Ogre::Vector3 &amp;endpt);
+
+        //! this function is used internally
+        void addConvexRay(const OgreNewt::Collision* col, const Ogre::Vector3 &amp;startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3 &amp;endpt);
+
+        //! this function is used internally
+        void addDiscardedBody(const OgreNewt::Body* body);
+
+        //! this function is used internally
+        void addHitBody(const OgreNewt::Body* body);
 	protected:
 		Debugger();
 	
@@ -68,6 +97,12 @@
         MaterialIdColorMap      m_materialcolors;
         Ogre::ColourValue       m_defaultcolor;
 
+        // raycast-debugging
+        Ogre::SceneNode*        m_raycastsnode;
+        bool                    m_recordraycasts;
+        Ogre::ColourValue       m_raycol, m_convexcol, m_hitbodycol, m_prefilterdiscardedcol;
+        bool                    m_markhitbodies;
+
         struct BodyDebugData
         {
             BodyDebugData() : m_lastcol(NULL), m_node(NULL), m_lines(NULL), m_text(NULL), m_updated(false) {}

Added: dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h	2009-01-27 21:32:51 UTC (rev 4722)
@@ -0,0 +1,177 @@
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by melven
+
+*/
+#ifndef _INCLUDE_OGRENEWT_PLAYERCONTROLLER
+#define _INCLUDE_OGRENEWT_PLAYERCONTROLLER
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_Joint.h&quot;
+#include &quot;OgreNewt_Collision.h&quot;
+#include &quot;OgreNewt_RayCast.h&quot;
+
+
+namespace OgreNewt
+{
+
+//! PlayerController
+/*!
+    this class implements a player-controller based on the code of the CustomPlayerController-class in the Newton-CustomJoints library
+*/
+class _OgreNewtExport PlayerController : public CustomJoint
+{
+public:
+    //! constructor
+    PlayerController(OgreNewt::Body* child);
+    virtual ~PlayerController();
+
+    //! get controlled body
+    OgreNewt::Body* getControlledBody() const {return m_body;}
+
+    //! set the characters velocity, the -Speed-values can be negative, sideSpeed positiv means move to the right, heading is in absolute space
+    void setVelocity(Ogre::Real forwardSpeed, Ogre::Real sideSpeed, Ogre::Radian heading);
+
+    //! get currently set velocity
+    void getVelocity(Ogre::Real &amp;forwardSpeed, Ogre::Real&amp; sideSpeed, Ogre::Radian&amp; heading) const;
+
+    //! set maximum step height (as absolute value)
+    void setMaxStepHeight(Ogre::Real maxStepHeight);
+
+    //! get currently set maximum step height
+    Ogre::Real getMaxStepHeight() const;
+
+    //! set maximum slope
+    void setMaxSlope(Ogre::Radian maxSlope);
+
+    //! get currently set maximum slope
+    Ogre::Radian getMaxSlope() const;
+
+    //! set restitution (usually not needed!)
+    void setRestitution(Ogre::Real restitution);
+
+    //! get currently set restitution
+    Ogre::Real getRestitution() const;
+
+    //! set up-vector pin
+    void setPinVector(Ogre::Vector3 upVector);
+
+    //! get currently set up-vector pin
+    Ogre::Vector3 getPinVector() const;
+
+    //! is the body currently in the air (jumpin?)
+    bool isInJumpState() const;
+
+    //! can be overwritten to specify if a body can be pushed away by this character
+    virtual bool canPushBody(const OgreNewt::Body *hitBody) const {return true;}
+
+    //! overwritten function from CustomJoint, must *NOT* be overwritten
+    virtual void submitConstraint( Ogre::Real timestep, int threadindex );
+
+protected:
+    OgreNewt::Body *m_body; // we need this again, because in the joint it's constant!
+
+    Ogre::Real m_forwardSpeed, m_sideSpeed, m_maxStepHeight;
+    Ogre::Radian m_heading, m_maxSlope, m_restitution;
+    Ogre::Vector3 m_upVector;
+
+    bool m_isInJumpState;
+    OgreNewt::ConvexCollision* m_verticalSensorShape;
+    OgreNewt::ConvexCollision* m_horizontalSensorShape;
+    OgreNewt::ConvexCollision* m_dynamicsSensorShape;
+
+    virtual bool convexStaticCastPreFilter(OgreNewt::Body *body);
+    virtual bool convexDynamicCastPreFilter(OgreNewt::Body *body);
+    virtual bool convexAllBodyCastPreFilter(OgreNewt::Body *body);
+    virtual bool findFloorCastPreFilter(OgreNewt::Body *body);
+
+    // helper function, used internally
+    void getPlayerHeightAndRadius(Ogre::Real &amp;height, Ogre::Real &amp;radius);
+
+    // parameters for the updateSenesorShapes-function, these are set in the constructor!
+    Ogre::Real m_staticRadiusFactor, m_dynamicRadiusFactor, m_floorFinderRadiusFactor, m_maxPlayerHeightPaddFactor;
+    int m_sensorShapeSegments;
+    // internal values, only used in updateSensorShapes!
+    Ogre::Real m_lastPlayerHeight, m_lastPlayerRadius, m_lastSensorHeight;
+    // helper function
+    void updateSensorShapes();
+
+
+    // other parameters
+    int m_maxCollisionsIterations;
+
+    // variables used in submitConstraint
+    Ogre::Quaternion m_lastOri;
+
+private:
+    // we need overloaded versions of the raycasts...
+    class FindFloorRaycast : public OgreNewt::BasicRaycast
+    {
+        public:
+            FindFloorRaycast(PlayerController *pc, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted) :
+                    BasicRaycast(pc-&gt;getControlledBody()-&gt;getWorld(), startpt, endpt, sorted),
+                    m_parent(pc)
+                {}
+
+            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent-&gt;findFloorCastPreFilter(body);}
+        private:
+            OgreNewt::PlayerController* m_parent;
+    };
+
+    class StaticConvexCast : public OgreNewt::BasicConvexcast
+    {
+        public:
+            StaticConvexCast(PlayerController *pc, const OgreNewt::World* world,
+                             const OgreNewt::Collision* col, const Ogre::Vector3&amp; startpt,
+                             const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount) :
+                    BasicConvexcast(pc-&gt;getControlledBody()-&gt;getWorld(), col, startpt, colori, endpt, maxcontactscount),
+                    m_parent(pc)
+                {}
+
+            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent-&gt;convexStaticCastPreFilter(body);}
+        private:
+            OgreNewt::PlayerController* m_parent;
+    };
+
+    class DynamicConvexCast : public OgreNewt::BasicConvexcast
+    {
+        public:
+            DynamicConvexCast(PlayerController *pc, const OgreNewt::World* world,
+                             const OgreNewt::Collision* col, const Ogre::Vector3&amp; startpt,
+                             const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount) :
+                    BasicConvexcast(pc-&gt;getControlledBody()-&gt;getWorld(), col, startpt, colori, endpt, maxcontactscount),
+                    m_parent(pc)
+                {}
+
+            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent-&gt;convexDynamicCastPreFilter(body);}
+        private:
+            OgreNewt::PlayerController* m_parent;
+    };
+
+    class AllBodyConvexCast : public OgreNewt::BasicConvexcast
+    {
+        public:
+            AllBodyConvexCast(PlayerController *pc, const OgreNewt::World* world,
+                             const OgreNewt::Collision* col, const Ogre::Vector3&amp; startpt,
+                             const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount) :
+                    BasicConvexcast(pc-&gt;getControlledBody()-&gt;getWorld(), col, startpt, colori, endpt, maxcontactscount),
+                    m_parent(pc)
+                {}
+
+            virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent-&gt;convexAllBodyCastPreFilter(body);}
+        private:
+            OgreNewt::PlayerController* m_parent;
+    };
+};
+
+
+}	// end NAMESPACE OgreNewt
+
+
+#endif	// _INCLUDE_OGRENEWT_PLAYERCONTROLLER
+

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-01-27 21:32:51 UTC (rev 4722)
@@ -105,12 +105,13 @@
 	//! constructor
 	/*!
 		performs a raycast, then the results can be queried from the object after creation.
-		\param world pointer to the OgreNewt::World
-		\param startpt starting point of the ray in global space
-		\param endpt ending point of the ray in global space
-                \param sorted sort the results by distance
+        \param world pointer to the OgreNewt::World
+        \param startpt starting point of the ray in global space
+        \param endpt ending point of the ray in global space
+        \param sorted sort the results by distance
+        \param prefilter pointer to a prefilter function
 	*/
-	BasicRaycast( const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted );
+	BasicRaycast( const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted);
 	
 	//! destuctor.
 	~BasicRaycast();
@@ -138,7 +139,6 @@
 	typedef std::vector&lt;BasicRaycastInfo&gt; RaycastInfoList;
 
 	RaycastInfoList mRayList;
-
 };
 
 //! general convexcast
@@ -224,7 +224,6 @@
         //! empty constructor
         BasicConvexcast();
 
-
 	//! constructor
 	/*!
 		performs a raycast, then the results can be queried from the object after creation.
@@ -234,6 +233,7 @@
                 \param colori orientation of the collision in global space
 		\param endpt ending point of ray in global space
                 \param maxcontactscount maximum number of contacts that should be saved
+                \param prefilter pointer to a prefilter function
 	*/
 	BasicConvexcast( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount);
 

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Body.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Body.cpp	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Body.cpp	2009-01-27 21:32:51 UTC (rev 4722)
@@ -296,6 +296,15 @@
 	return ret;
 }
 
+Ogre::Vector3 Body::calculateInverseDynamicsForce(Ogre::Real timestep, Ogre::Vector3 desiredVelocity)
+{
+    Ogre::Vector3 ret;
+    NewtonBodyCalculateInverseDynamicsForce(m_body, timestep, &amp;desiredVelocity.x, &amp;ret.x);
+
+    return ret;
+}
+
+
 Ogre::Vector3 Body::getAngularDamping() const
 {
 	Ogre::Vector3 ret;

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp	2009-01-27 21:32:51 UTC (rev 4722)
@@ -11,6 +11,13 @@
 {
     m_debugnode = NULL;
     m_defaultcolor = Ogre::ColourValue::White;
+
+    m_recordraycasts = false;
+    m_markhitbodies = false;
+    m_raycol = Ogre::ColourValue::Green;
+    m_convexcol = Ogre::ColourValue::Blue;
+    m_hitbodycol = Ogre::ColourValue::Red;
+    m_prefilterdiscardedcol = Ogre::ColourValue::Black;
 }
 
 Debugger::~Debugger()
@@ -31,17 +38,23 @@
         m_debugnode = smgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(&quot;__OgreNewt__Debugger__Node__&quot;);
         //m_debuglines = new Ogre::ManualObject(&quot;__OgreNewt__Debugger__Lines__&quot;);
     }
+
+    if( !m_raycastsnode )
+    {
+        m_raycastsnode = smgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(&quot;__OgreNewt__Raycasts_Debugger__Node__&quot;);
+    }
 }
 
 void Debugger::deInit()
 {
 	if (m_debugnode)
 	{
-		m_debugnode-&gt;removeAndDestroyAllChildren();
+		m_debugnode-&gt;removeAllChildren();
 		m_debugnode-&gt;getParentSceneNode()-&gt;removeAndDestroyChild( m_debugnode-&gt;getName() );
 		m_debugnode = NULL;
 	}
 
+
         for(BodyDebugDataMap::iterator it = m_cachemap.begin(); it != m_cachemap.end(); it++)
         {
             Ogre::ManualObject* mo = it-&gt;second.m_lines;
@@ -49,6 +62,14 @@
                 delete mo;
         }
         m_cachemap.clear();
+
+    clearRaycastsRecorded();
+    if( m_raycastsnode )
+    {
+		m_raycastsnode-&gt;removeAndDestroyAllChildren();
+		m_raycastsnode-&gt;getParentSceneNode()-&gt;removeAndDestroyChild( m_debugnode-&gt;getName() );
+		m_raycastsnode = NULL;
+    }
 }
 
 
@@ -67,6 +88,12 @@
     {
         if( it-&gt;second.m_updated )
             newmap.insert(*it);
+        else
+        {
+            Ogre::ManualObject* mo = it-&gt;second.m_lines;
+            if( mo )
+                delete mo;
+        }
     }
     Debugger::getSingleton().m_cachemap.swap(newmap);
 }
@@ -74,7 +101,8 @@
 void Debugger::hideDebugInformation()
 {
 	// erase any existing lines!
-	m_debugnode-&gt;removeAllChildren();
+    if( m_debugnode )
+    	m_debugnode-&gt;removeAllChildren();
 }
 
 void Debugger::setMaterialColor(const MaterialID* mat, Ogre::ColourValue col)
@@ -177,7 +205,7 @@
         float matrix[16];
         Converters::QuatPosToMatrix(Ogre::Quaternion::IDENTITY, Ogre::Vector3::ZERO, &amp;matrix[0]);
         
-        NewtonCollisionForEachPolygonDo( NewtonBodyGetCollision(body), &amp;matrix[0], newtonPerPoly, data );
+        NewtonCollisionForEachPolygonDo( NewtonBodyGetCollision(body), &amp;matrix[0], newtonPerPoly, data-&gt;m_lines );
         
         data-&gt;m_lines-&gt;end();
         data-&gt;m_node-&gt;attachObject(data-&gt;m_lines);
@@ -186,7 +214,7 @@
 
 void _CDECL Debugger::newtonPerPoly( void* userData, int vertexCount, const float* faceVertec, int id )
 {
-        BodyDebugData* data = (BodyDebugData*)userData;
+    Ogre::ManualObject* lines = (Ogre::ManualObject*)userData;
 	Ogre::Vector3 p0, p1;
 
         if( vertexCount &lt; 2 )
@@ -200,12 +228,163 @@
 	{
 		p1 = Ogre::Vector3( faceVertec[(i*3) + 0], faceVertec[(i*3) + 1], faceVertec[(i*3) + 2] );
 
-		data-&gt;m_lines-&gt;position( p0 );
-		data-&gt;m_lines-&gt;position( p1 );
+		lines-&gt;position( p0 );
+		lines-&gt;position( p1 );
 
 		p0 = p1;
 	}
 }
 
+
+// ----------------- raycast-debugging -----------------------
+void Debugger::startRaycastRecording(bool markhitbodies)
+{
+    m_recordraycasts = true;
+    m_markhitbodies = markhitbodies;
+    clearRaycastsRecorded();
+}
+
+bool Debugger::isRaycastRecording()
+{
+    return m_recordraycasts;
+}
+
+bool Debugger::isRaycastRecordingHitBodies()
+{
+    return m_markhitbodies;
+}
+
+void Debugger::clearRaycastsRecorded()
+{
+    if( m_raycastsnode )
+    {
+        while( m_raycastsnode-&gt;numAttachedObjects() &gt; 0 )
+        {
+            delete m_raycastsnode-&gt;detachObject((unsigned short)0);
+        }
+
+        m_raycastsnode-&gt;detachAllObjects();
+    }
+}
+
+void Debugger::stopRaycastRecording()
+{
+    m_recordraycasts = false;
+}
+
+void Debugger::setRaycastRecordingColor(Ogre::ColourValue rayCol, Ogre::ColourValue convexCol, Ogre::ColourValue hitBodyCol, Ogre::ColourValue prefilterDiscardedBodyCol)
+{
+    m_raycol = rayCol;
+    m_convexcol = convexCol;
+    m_hitbodycol = hitBodyCol;
+    m_prefilterdiscardedcol = prefilterDiscardedBodyCol;
+}
+
+void Debugger::addRay(const Ogre::Vector3 &amp;startpt, const Ogre::Vector3 &amp;endpt)
+{
+    static int i = 0;
+    std::ostringstream oss;
+    oss &lt;&lt; &quot;__OgreNewt__Raycast_Debugger__Lines__Raycastline__&quot; &lt;&lt; i++ &lt;&lt; &quot;__&quot;;
+    Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+
+    line-&gt;begin(&quot;BaseWhiteNoLighting&quot;, Ogre::RenderOperation::OT_LINE_LIST );
+    line-&gt;colour(m_raycol);
+    line-&gt;position(startpt);
+    line-&gt;position(endpt);
+    line-&gt;end();
+
+    m_raycastsnode-&gt;attachObject(line);    
+}
+
+void Debugger::addConvexRay(const OgreNewt::Collision* col, const Ogre::Vector3 &amp;startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3 &amp;endpt)
+{
+    static int i = 0;
+    // lines from aab
+    std::ostringstream oss;
+    oss &lt;&lt; &quot;__OgreNewt__Raycast_Debugger__Lines__Convexcastlines__&quot; &lt;&lt; i++ &lt;&lt; &quot;__&quot;;
+    Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+
+    line-&gt;begin(&quot;BaseWhiteNoLighting&quot;, Ogre::RenderOperation::OT_LINE_LIST );
+    line-&gt;colour(m_convexcol);
+
+    // aab1
+    Ogre::AxisAlignedBox aab1 = col-&gt;getAABB(colori, startpt);
+    const Ogre::Vector3* corners1 = aab1.getAllCorners();
+    Ogre::AxisAlignedBox aab2 = col-&gt;getAABB(colori, endpt);
+    const Ogre::Vector3* corners2 = aab2.getAllCorners();
+    for(int i = 0; i &lt; 4; i++)
+    {
+        line-&gt;position(corners1[i]); line-&gt;position(corners1[(i+1)%4]);
+        line-&gt;position(corners1[i+4]); line-&gt;position(corners1[(i+1)%4+4]);
+        line-&gt;position(corners2[i]); line-&gt;position(corners2[(i+1)%4]);
+        line-&gt;position(corners2[i+4]); line-&gt;position(corners2[(i+1)%4+4]);
+        line-&gt;position(corners1[i]); line-&gt;position(corners2[i]);
+        line-&gt;position(corners1[i+4]); line-&gt;position(corners2[i+4]);
+    }
+    line-&gt;position(corners1[0]); line-&gt;position(corners1[6]);
+    line-&gt;position(corners1[1]); line-&gt;position(corners1[5]);
+    line-&gt;position(corners1[2]); line-&gt;position(corners1[4]);
+    line-&gt;position(corners1[3]); line-&gt;position(corners1[7]);
+    line-&gt;position(corners2[0]); line-&gt;position(corners2[6]);
+    line-&gt;position(corners2[1]); line-&gt;position(corners2[5]);
+    line-&gt;position(corners2[2]); line-&gt;position(corners2[4]);
+    line-&gt;position(corners2[3]); line-&gt;position(corners2[7]);
+
+    // bodies
+    float matrix[16];
+    Converters::QuatPosToMatrix(colori, startpt, &amp;matrix[0]);
+    NewtonCollisionForEachPolygonDo( col-&gt;getNewtonCollision(), &amp;matrix[0], newtonPerPoly, line );
+    Converters::QuatPosToMatrix(colori, endpt, &amp;matrix[0]);
+    NewtonCollisionForEachPolygonDo( col-&gt;getNewtonCollision(), &amp;matrix[0], newtonPerPoly, line );
+
+
+    line-&gt;end();
+    m_raycastsnode-&gt;attachObject(line);
+}
+
+void Debugger::addDiscardedBody(const OgreNewt::Body* body)
+{
+    static int i = 0;
+    float matrix[16];
+    Ogre::Vector3 pos;
+    Ogre::Quaternion ori;
+
+    std::ostringstream oss;
+    oss &lt;&lt; &quot;__OgreNewt__Raycast_Debugger__Lines__DiscardedBody__&quot; &lt;&lt; i++ &lt;&lt; &quot;__&quot;;
+    Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+
+    line-&gt;begin(&quot;BaseWhiteNoLighting&quot;, Ogre::RenderOperation::OT_LINE_LIST );
+    line-&gt;colour(m_prefilterdiscardedcol);
+
+    body-&gt;getPositionOrientation(pos, ori);
+    Converters::QuatPosToMatrix(ori, pos, &amp;matrix[0]);
+    NewtonCollisionForEachPolygonDo( body-&gt;getCollision()-&gt;getNewtonCollision() , &amp;matrix[0], newtonPerPoly, line );
+
+    line-&gt;end();
+    m_raycastsnode-&gt;attachObject(line);
+}
+
+void Debugger::addHitBody(const OgreNewt::Body* body)
+{
+    static int i = 0;
+    float matrix[16];
+    Ogre::Vector3 pos;
+    Ogre::Quaternion ori;
+
+    std::ostringstream oss;
+    oss &lt;&lt; &quot;__OgreNewt__Raycast_Debugger__Lines__HitBody__&quot; &lt;&lt; i++ &lt;&lt; &quot;__&quot;;
+    Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+
+    line-&gt;begin(&quot;BaseWhiteNoLighting&quot;, Ogre::RenderOperation::OT_LINE_LIST );
+    line-&gt;colour(m_hitbodycol);
+
+    body-&gt;getPositionOrientation(pos, ori);
+    Converters::QuatPosToMatrix(ori, pos, &amp;matrix[0]);
+    NewtonCollisionForEachPolygonDo( body-&gt;getCollision()-&gt;getNewtonCollision() , &amp;matrix[0], newtonPerPoly, line );
+
+    line-&gt;end();
+    m_raycastsnode-&gt;attachObject(line);
+}
+
 }	// end namespace OgreNewt
 

Added: dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp	2009-01-27 21:32:51 UTC (rev 4722)
@@ -0,0 +1,271 @@
+#include &lt;OgreNewt_PlayerController.h&gt;
+#include &lt;OgreNewt_Tools.h&gt;
+#include &lt;OgreNewt_CollisionPrimitives.h&gt;
+
+namespace OgreNewt
+{
+
+PlayerController::PlayerController(OgreNewt::Body * child) :
+    CustomJoint(6, child, NULL),
+    m_body(child)
+{
+    // initialize settable values
+    m_forwardSpeed = 0;
+    m_sideSpeed = 0;
+    m_heading = Ogre::Radian(0);
+    Ogre::Real playerHeight, playerRadius;
+    getPlayerHeightAndRadius(playerHeight, playerRadius);
+    m_maxStepHeight = playerHeight / 5;
+    m_maxSlope = Ogre::Degree(45);
+    m_restitution = 0;
+    m_upVector = Ogre::Vector3::UNIT_Y;
+    m_isInJumpState = false;
+
+    Ogre::Vector3 pos;
+    m_body-&gt;getPositionOrientation(pos, m_lastOri);
+
+
+
+    // initialize sensor-shape parameters
+    m_staticRadiusFactor = 1.125f;
+    m_dynamicRadiusFactor = 1.5f;
+    m_floorFinderRadiusFactor = 1.0f;
+    m_maxPlayerHeightPaddFactor = 0.01f;
+    m_sensorShapeSegments = 32;
+    m_verticalSensorShape = NULL;
+    m_horizontalSensorShape = NULL;
+    m_dynamicsSensorShape = NULL;
+
+
+    updateSensorShapes();
+}
+
+PlayerController::~PlayerController()
+{
+    if( m_verticalSensorShape )
+        delete m_verticalSensorShape;
+    if( m_horizontalSensorShape )
+        delete m_horizontalSensorShape;
+    if( m_dynamicsSensorShape )
+        delete m_dynamicsSensorShape
+;
+}
+
+void PlayerController::updateSensorShapes()
+{
+    Ogre::Real newPlayerRadius, newPlayerHeight, newSensorHeight;
+    // is this the first time, this function gets calles?
+    if( m_verticalSensorShape == NULL )
+    {
+        // initialize values, so they aren't arbitrary!
+        m_lastPlayerRadius = newPlayerRadius = 0;
+        m_lastPlayerHeight = newPlayerHeight = 0;
+        m_lastSensorHeight = newSensorHeight = 0;
+    }
+
+    // calculate new Values:
+    getPlayerHeightAndRadius(newPlayerHeight, newPlayerRadius);
+    newPlayerHeight += newPlayerHeight * m_maxPlayerHeightPaddFactor;
+    newSensorHeight = (newPlayerHeight - m_maxStepHeight) * 0.5f;
+
+
+    // do we need to update the shapes?
+    if( m_verticalSensorShape == NULL || 
+        abs( newPlayerHeight - m_lastPlayerHeight ) &gt; 0.04f ||
+        abs( newSensorHeight - m_lastSensorHeight ) &gt; 0.04f ||
+        abs( newPlayerRadius - m_lastPlayerRadius ) &gt; 0.04f )
+    {
+        // delete old ones
+        if( m_verticalSensorShape )
+            delete m_verticalSensorShape;
+        if( m_horizontalSensorShape )
+            delete m_horizontalSensorShape;
+        if( m_dynamicsSensorShape )
+            delete m_dynamicsSensorShape;
+
+        m_lastPlayerRadius = newPlayerRadius;
+        m_lastSensorHeight = newSensorHeight;
+        m_lastPlayerHeight = newPlayerHeight;
+
+        
+        Ogre::Vector3 *dynamicsSensorPoints = new Ogre::Vector3[m_sensorShapeSegments*2];
+        Ogre::Vector3 *verticalSensorPoints = new Ogre::Vector3[m_sensorShapeSegments*2];
+        Ogre::Vector3 *horizontalSensorPoints = new Ogre::Vector3[m_sensorShapeSegments*2];
+
+        for( int i = 0; i &lt; m_sensorShapeSegments; i++)
+        {
+            Ogre::Real x, z;
+            x = m_lastPlayerRadius * Ogre::Math::Cos( Ogre::Degree( 360.0f * i / m_sensorShapeSegments ) );
+            z = m_lastPlayerRadius * Ogre::Math::Sin( Ogre::Degree( 360.0f * i / m_sensorShapeSegments ) );
+
+            dynamicsSensorPoints[i].x = x * m_dynamicRadiusFactor;
+            dynamicsSensorPoints[i].y = m_lastPlayerHeight * 0.45f;
+            dynamicsSensorPoints[i].z = z * m_dynamicRadiusFactor;
+            dynamicsSensorPoints[i + m_sensorShapeSegments].x =  dynamicsSensorPoints[i].x;
+            dynamicsSensorPoints[i + m_sensorShapeSegments].y = -dynamicsSensorPoints[i].y;
+            dynamicsSensorPoints[i + m_sensorShapeSegments].z =  dynamicsSensorPoints[i].z;
+            verticalSensorPoints[i].x = x * m_floorFinderRadiusFactor;
+            verticalSensorPoints[i].y = m_lastSensorHeight;
+            verticalSensorPoints[i].z = z * m_floorFinderRadiusFactor;
+            verticalSensorPoints[i + m_sensorShapeSegments].x =  verticalSensorPoints[i].x;
+            verticalSensorPoints[i + m_sensorShapeSegments].y = -verticalSensorPoints[i].y;
+            verticalSensorPoints[i + m_sensorShapeSegments].z =  verticalSensorPoints[i].z;
+            horizontalSensorPoints[i].x = x * m_staticRadiusFactor;
+            horizontalSensorPoints[i].y = m_lastSensorHeight;
+            horizontalSensorPoints[i].z = z * m_staticRadiusFactor;
+            horizontalSensorPoints[i + m_sensorShapeSegments].x =  horizontalSensorPoints[i].x;
+            horizontalSensorPoints[i + m_sensorShapeSegments].y = -horizontalSensorPoints[i].y;
+            horizontalSensorPoints[i + m_sensorShapeSegments].z =  horizontalSensorPoints[i].z;
+        }
+
+        m_verticalSensorShape = new OgreNewt::CollisionPrimitives::ConvexHull(m_body-&gt;getWorld(), verticalSensorPoints, 2*m_sensorShapeSegments);
+        m_horizontalSensorShape = new OgreNewt::CollisionPrimitives::ConvexHull(m_body-&gt;getWorld(), horizontalSensorPoints, 2*m_sensorShapeSegments);
+        m_dynamicsSensorShape = new OgreNewt::CollisionPrimitives::ConvexHull(m_body-&gt;getWorld(), dynamicsSensorPoints, 2*m_sensorShapeSegments);
+
+        delete[] dynamicsSensorPoints;
+        delete[] verticalSensorPoints;
+        delete[] horizontalSensorPoints;
+    }
+
+}
+
+
+void PlayerController::getPlayerHeightAndRadius(Ogre::Real &amp;height, Ogre::Real &amp;radius)
+{
+    Ogre::AxisAlignedBox aab = m_body-&gt;getAABB();
+    height = aab.getMaximum().y - aab.getMinimum().y;
+
+    Ogre::Real rx = aab.getMaximum().x - aab.getMinimum().x;
+    Ogre::Real ry = aab.getMaximum().y - aab.getMinimum().y;
+    radius = std::max(rx,ry);
+}
+
+
+bool PlayerController::convexStaticCastPreFilter(OgreNewt::Body *body)
+{
+    Ogre::Real mass;
+    Ogre::Vector3 inertia;
+    body-&gt;getMassMatrix(mass, inertia);
+
+    return (mass == 0.0f &amp;&amp; body != m_body);
+}
+
+
+bool PlayerController::convexDynamicCastPreFilter(OgreNewt::Body *body)
+{
+    Ogre::Real mass;
+    Ogre::Vector3 inertia;
+    body-&gt;getMassMatrix(mass, inertia);
+
+    return (mass &gt; 0.0f &amp;&amp; body != m_body);
+}
+
+
+bool PlayerController::convexAllBodyCastPreFilter(OgreNewt::Body *body)
+{
+    return (body != m_body);
+}
+
+
+bool PlayerController::findFloorCastPreFilter(OgreNewt::Body *body)
+{
+    return (body != m_body);
+}
+
+
+void PlayerController::submitConstraint( Ogre::Real timestep, int threadindex )
+{
+
+    Ogre::Vector3 pos;
+    Ogre::Quaternion ori;
+    Ogre::Real mass;
+    Ogre::Vector3 inertia;
+    Ogre::Vector3 vel;
+    Ogre::Vector3 omega;
+    Ogre::Vector3 torqueAcc;
+
+    m_body-&gt;getPositionOrientation(pos,ori);
+    m_body-&gt;getMassMatrix(mass, inertia);
+    vel = m_body-&gt;getVelocity();
+    omega = m_body-&gt;getOmega();
+    torqueAcc = m_body-&gt;getTorqueAcceleration();
+
+    // ----------- &quot;up-vector-pin&quot; -----------
+    // get the plane of rotation
+    Ogre::Vector3 oriChangeVec;
+    Ogre::Radian oriChangeAngle;
+    Ogre::Quaternion oriDiffFromLast = (ori * m_lastOri.Inverse());
+    oriDiffFromLast.ToAngleAxis(oriChangeAngle, oriChangeVec);
+    if( abs(oriChangeAngle.valueRadians()) &gt; 1.0e-3 )
+    {
+        // correct angle
+        addAngularRow(oriChangeAngle, oriChangeVec);
+
+        // additional correction, see newton CustomPlayerController
+        Ogre::Vector3 frontDir = ori*oriChangeVec;
+        addAngularRow(Ogre::Radian(0.0f), oriChangeVec);
+    }
+    else
+    {
+        addAngularRow(Ogre::Radian(0.0f), ori.yAxis());
+        addAngularRow(Ogre::Radian(0.0f), ori.xAxis());
+    }
+
+    // ----------- calculate torque -----------
+    Ogre::Quaternion targetOri;
+    targetOri.FromAngleAxis(m_heading, Ogre::Vector3::UNIT_Y);
+    Ogre::Quaternion oriDiff = (targetOri * ori.Inverse());
+    Ogre::Real turnOmega  = oriDiff.getYaw().valueRadians() / timestep;
+    torqueAcc = ori.yAxis() * (torqueAcc.dotProduct(ori.yAxis()));
+    Ogre::Vector3 torque = ori.yAxis() * (turnOmega - omega.y * inertia.y/timestep - torqueAcc.y);
+    m_body-&gt;addTorque(torque);
+
+
+
+    // ----------- find floor -----------
+    Ogre::Vector3 p1 = pos - Ogre::Vector3::UNIT_Y*m_lastPlayerHeight;
+    FindFloorRaycast findFloorCast(this, pos, p1, true);
+    if( findFloorCast.getHitCount() &gt; 0 )
+    {
+        // slope:
+        if( Ogre::Math::ACos(findFloorCast.getFirstHit().mNormal.y) &gt; m_maxSlope )
+        
+        {
+            // desired velocity
+            Ogre::Vector3 desiredVel = ori*(Ogre::Vector3::UNIT_Z * m_forwardSpeed + Ogre::Vector3::UNIT_Y*vel.y + Ogre::Vector3::UNIT_X * m_sideSpeed);
+
+            if( m_isInJumpState )
+                desiredVel = vel;
+            // ------------------------ here should be an else!! -------------------------
+            // only apply hitVel if we are not in the air, in the original this is different!
+            else
+            {
+
+                // hit-body:
+                Ogre::Vector3 hitPoint = pos + (p1-pos) * findFloorCast.getFirstHit().mDistance;
+                Ogre::Vector3 hitOmega = findFloorCast.getFirstHit().mBody-&gt;getOmega();
+                Ogre::Vector3 hitVel = findFloorCast.getFirstHit().mBody-&gt;getVelocity();
+                Ogre::Vector3 hitPos;
+                Ogre::Quaternion hitOri;
+                findFloorCast.getFirstHit().mBody-&gt;getPositionOrientation(hitPos, hitOri);
+
+                hitVel += hitOmega * (hitPoint - hitPos).length();
+                desiredVel += hitVel;
+            }
+
+
+
+
+
+            // calculate force needed for desired velocity
+//            m_body-&gt;
+
+        }
+    }
+    
+
+}
+
+
+}	// end NAMESPACE OgreNewt
+

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-01-26 18:35:47 UTC (rev 4721)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-01-27 21:32:51 UTC (rev 4722)
@@ -1,5 +1,6 @@
 #include &quot;OgreNewt_RayCast.h&quot;
 #include &quot;OgreNewt_Tools.h&quot;
+#include &quot;OgreNewt_Debugger.h&quot;
 
 
 namespace OgreNewt
@@ -12,6 +13,10 @@
 
 	void Raycast::go(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt )
 	{
+        if( Debugger::getSingleton().isRaycastRecording() )
+        {
+            Debugger::getSingleton().addRay(startpt, endpt);
+        }
 		// perform the raycast!
 		NewtonWorldRayCast( world-&gt;getNewtonWorld(), (float*)&amp;startpt, (float*)&amp;endpt, OgreNewt::Raycast::newtonRaycastFilter, this, OgreNewt::Raycast::newtonRaycastPreFilter );
 	}
@@ -24,6 +29,13 @@
 		Body* bod = (Body*)NewtonBodyGetUserData( body );
 		Ogre::Vector3 normal = Ogre::Vector3( hitNormal[0], hitNormal[1], hitNormal[2] );
 
+
+        if( Debugger::getSingleton().isRaycastRecording() &amp;&amp; Debugger::getSingleton().isRaycastRecordingHitBodies() )
+        {
+            Debugger::getSingleton().addHitBody(bod);
+        }
+
+
 		if (me-&gt;userCallback( bod, intersectParam, normal, collisionID ))
 			return intersectParam;
 		else
@@ -41,7 +53,15 @@
 		if (me-&gt;userPreFilterCallback( bod ))
 			return 1;
 		else
+        {
+
+            if( Debugger::getSingleton().isRaycastRecording() &amp;&amp; Debugger::getSingleton().isRaycastRecordingHitBodies() )
+            {
+                Debugger::getSingleton().addDiscardedBody(bod);
+            }
+
 			return 0;
+        }
 	}
 
 
@@ -57,7 +77,8 @@
 	BasicRaycast::BasicRaycastInfo::~BasicRaycastInfo() {}
 
 
-	BasicRaycast::BasicRaycast(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted ) : Raycast() 
+	BasicRaycast::BasicRaycast(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted)
+        : Raycast()
 	{
 		go( world, startpt, endpt );
                 if( sorted )
@@ -143,6 +164,11 @@
 
 	void Convexcast::go(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;colori, const Ogre::Vector3&amp; endpt, int maxcontactscount)
 	{
+
+        if( Debugger::getSingleton().isRaycastRecording() )
+        {
+            Debugger::getSingleton().addConvexRay(col, startpt, colori, endpt);
+        }
                 // reserve memory
                 if( mReturnInfoListSize &lt; maxcontactscount )
                 {
@@ -161,6 +187,15 @@
                         NewtonWorldConvexCast( world-&gt;getNewtonWorld(), &amp;matrix[0], (float*)&amp;endpt, col-&gt;getNewtonCollision(),
                                                &amp;mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
                                                mReturnInfoList, mReturnInfoListSize );
+
+            if( Debugger::getSingleton().isRaycastRecording() &amp;&amp; Debugger::getSingleton().isRaycastRecordingHitBodies() )
+            {
+                for(int i = 0; i &lt; mReturnInfoListLength; i++)
+                {
+                    Body* body = (OgreNewt::Body*) NewtonBodyGetUserData(mReturnInfoList[i].m_hitBody);
+                    Debugger::getSingleton().addHitBody(body);
+                }
+            }
 	}
 
 	unsigned _CDECL Convexcast::newtonConvexcastPreFilter(const NewtonBody *body, const NewtonCollision *collision, void* userData)
@@ -173,7 +208,15 @@
 		if (me-&gt;userPreFilterCallback( bod ))
 			return 1;
 		else
+        {
+
+            if( Debugger::getSingleton().isRaycastRecording() &amp;&amp; Debugger::getSingleton().isRaycastRecordingHitBodies() )
+            {
+                Debugger::getSingleton().addDiscardedBody(bod);
+            }
+
 			return 0;
+        }
 	}
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001778.html">[Dsa-hl-svn] r4721 - in rl/trunk/editors/Lockenwickler: .	_eric4project src src/media src/plugins ui files
</A></li>
	<LI>Next message: <A HREF="001780.html">[Dsa-hl-svn] r4723 - in rl/branches/newton20: .	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/plugins editors/Lockenwickler/ui	files engine/core engine/core/include engine/core/src	engine/rules/src engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1779">[ date ]</a>
              <a href="thread.html#1779">[ thread ]</a>
              <a href="subject.html#1779">[ subject ]</a>
              <a href="author.html#1779">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
