<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4723 - in rl/branches/newton20: .	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/plugins editors/Lockenwickler/ui	files engine/core engine/core/include engine/core/src	engine/rules/src engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4723%20-%20in%20rl/branches/newton20%3A%20.%0A%09editors/Lockenwickler%20editors/Lockenwickler/_eric4project%0A%09editors/Lockenwickler/src%20editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/plugins%20editors/Lockenwickler/ui%0A%09files%20engine/core%20engine/core/include%20engine/core/src%0A%09engine/rules/src%20engine/ui/src&In-Reply-To=%3C200901272135.n0RLZOX7022990%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001779.html">
   <LINK REL="Next"  HREF="001781.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4723 - in rl/branches/newton20: .	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/plugins editors/Lockenwickler/ui	files engine/core engine/core/include engine/core/src	engine/rules/src engine/ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4723%20-%20in%20rl/branches/newton20%3A%20.%0A%09editors/Lockenwickler%20editors/Lockenwickler/_eric4project%0A%09editors/Lockenwickler/src%20editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/plugins%20editors/Lockenwickler/ui%0A%09files%20engine/core%20engine/core/include%20engine/core/src%0A%09engine/rules/src%20engine/ui/src&In-Reply-To=%3C200901272135.n0RLZOX7022990%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4723 - in rl/branches/newton20: .	editors/Lockenwickler editors/Lockenwickler/_eric4project	editors/Lockenwickler/src editors/Lockenwickler/src/media	editors/Lockenwickler/src/plugins editors/Lockenwickler/ui	files engine/core engine/core/include engine/core/src	engine/rules/src engine/ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Tue Jan 27 22:35:24 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001779.html">[Dsa-hl-svn] r4722 - in dependencies/OgreNewt_ngt: . inc src
</A></li>
        <LI>Next message: <A HREF="001781.html">[Dsa-hl-svn] r4724 - in dependencies/OgreNewt_ngt: inc src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1780">[ date ]</a>
              <a href="thread.html#1780">[ thread ]</a>
              <a href="subject.html#1780">[ subject ]</a>
              <a href="author.html#1780">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2009-01-27 22:35:12 +0100 (Tue, 27 Jan 2009)
New Revision: 4723

Added:
   rl/branches/newton20/editors/Lockenwickler/_eric4project/
   rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/newton20/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/newton20/editors/Lockenwickler/ui files/NewModuleWizard.ui
Removed:
   rl/branches/newton20/editors/Lockenwickler/.eric4project/
   rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/newton20/editors/Lockenwickler/src/SceneExplorer.py
Modified:
   rl/branches/newton20/CMakeLists.txt
   rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/newton20/editors/Lockenwickler/src/
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py
   rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py
   rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py
   rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py
   rl/branches/newton20/editors/Lockenwickler/src/ViewportGrid.py
   rl/branches/newton20/editors/Lockenwickler/src/media/
   rl/branches/newton20/editors/Lockenwickler/src/plugins/
   rl/branches/newton20/engine/core/CMakeLists.txt
   rl/branches/newton20/engine/core/include/PhysicsManager.h
   rl/branches/newton20/engine/core/src/PhysicsManager.cpp
   rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/branches/newton20/engine/rules/src/CreatureController.cpp
   rl/branches/newton20/engine/rules/src/StepRecognitionMovement.cpp
   rl/branches/newton20/engine/ui/src/MovementControlState.cpp
Log:
-implemented raycast-debugging (press l multiple times!)
-currently debugging camera-movement...
-merged changes from trunk


Modified: rl/branches/newton20/CMakeLists.txt
===================================================================
--- rl/branches/newton20/CMakeLists.txt	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/CMakeLists.txt	2009-01-27 21:35:12 UTC (rev 4723)
@@ -68,6 +68,7 @@
 FIND_PACKAGE(OIS REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
+FIND_PACKAGE(FMODEx REQUIRED)
 FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
 FIND_PACKAGE(OpenSteer REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)

Modified: rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,177 +1,179 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;!DOCTYPE Project SYSTEM &quot;Project-4.5.dtd&quot;&gt;
-&lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2008-11-09, 21:48:49 --&gt;
-&lt;!-- Copyright (C) 2008 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
-&lt;Project version=&quot;4.5&quot;&gt;
-  &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
-  &lt;ProjectType&gt;Qt4&lt;/ProjectType&gt;
-  &lt;Description&gt;Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.&lt;/Description&gt;
-  &lt;Version&gt;0.1&lt;/Version&gt;
-  &lt;Author&gt;Stefan Stammberger&lt;/Author&gt;
-  &lt;Email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A>&lt;/Email&gt;
-  &lt;Sources&gt;
-    &lt;Source&gt;src/Lockenwickler.py&lt;/Source&gt;
-    &lt;Source&gt;src/ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModelSelectionDialog.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModuleManager.py&lt;/Source&gt;
-    &lt;Source&gt;src/MovePivot.py&lt;/Source&gt;
-    &lt;Source&gt;src/ObjectPropertyWin.py&lt;/Source&gt;
-    &lt;Source&gt;src/OgreMainWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/OgreWidget.py&lt;/Source&gt;
-    &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
-    &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
-    &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/SceneExplorer.py&lt;/Source&gt;
-    &lt;Source&gt;src/Property.py&lt;/Source&gt;
-    &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
-    &lt;Source&gt;src/ObjectPropertyModel.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClass.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClassManager.py&lt;/Source&gt;
-    &lt;Source&gt;src/setup.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClassView.py&lt;/Source&gt;
-    &lt;Source&gt;src/MyRaySceneQueryListener.py&lt;/Source&gt;
-    &lt;Source&gt;src/GOStringEditor.py&lt;/Source&gt;
-    &lt;Source&gt;src/GOIntEditor.py&lt;/Source&gt;
-    &lt;Source&gt;src/CodeDump.py&lt;/Source&gt;
-    &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
-  &lt;/Sources&gt;
-  &lt;Forms&gt;
-    &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;
-    &lt;Form&gt;ui files/GOPropertyEditorDialogSTRING.ui&lt;/Form&gt;
-    &lt;Form&gt;ui files/NewModuleWizard.ui&lt;/Form&gt;
-  &lt;/Forms&gt;
-  &lt;Translations&gt;
-  &lt;/Translations&gt;
-  &lt;Resources&gt;
-  &lt;/Resources&gt;
-  &lt;Interfaces&gt;
-  &lt;/Interfaces&gt;
-  &lt;Others&gt;
-  &lt;/Others&gt;
-  &lt;MainScript&gt;src/Lockenwickler.py&lt;/MainScript&gt;
-  &lt;Vcs&gt;
-    &lt;VcsType&gt;Subversion&lt;/VcsType&gt;
-    &lt;VcsOptions&gt;
-      &lt;dict&gt;
-        &lt;key&gt;
-          &lt;string&gt;add&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;checkout&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;commit&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;diff&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;export&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;global&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;history&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;log&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;remove&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;status&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;tag&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;update&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-      &lt;/dict&gt;
-    &lt;/VcsOptions&gt;
-    &lt;VcsOtherData&gt;
-      &lt;dict&gt;
-        &lt;key&gt;
-          &lt;string&gt;standardLayout&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;bool&gt;True&lt;/bool&gt;
-        &lt;/value&gt;
-      &lt;/dict&gt;
-    &lt;/VcsOtherData&gt;
-  &lt;/Vcs&gt;
-  &lt;FiletypeAssociations&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ui&quot; type=&quot;FORMS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.idl&quot; type=&quot;INTERFACES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.qm&quot; type=&quot;TRANSLATIONS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ptl&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.pyw&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ui.h&quot; type=&quot;FORMS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ts&quot; type=&quot;TRANSLATIONS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.py&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.qrc&quot; type=&quot;RESOURCES&quot; /&gt;
-  &lt;/FiletypeAssociations&gt;
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
+&lt;!-- eric4 project file for project Lockenwickler --&gt;
+&lt;!-- Saved: 2009-01-26, 17:27:44 --&gt;
+&lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
+&lt;Project version=&quot;4.6&quot;&gt;
+  &lt;Language&gt;en&lt;/Language&gt;
+  &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
+  &lt;ProjectType&gt;Qt4&lt;/ProjectType&gt;
+  &lt;Description&gt;Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.&lt;/Description&gt;
+  &lt;Version&gt;0.1&lt;/Version&gt;
+  &lt;Author&gt;Stefan Stammberger&lt;/Author&gt;
+  &lt;Email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A>&lt;/Email&gt;
+  &lt;Sources&gt;
+    &lt;Source&gt;src/Lockenwickler.py&lt;/Source&gt;
+    &lt;Source&gt;src/ConsoleWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModelSelectionDialog.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModuleManager.py&lt;/Source&gt;
+    &lt;Source&gt;src/MovePivot.py&lt;/Source&gt;
+    &lt;Source&gt;src/ObjectPropertyWin.py&lt;/Source&gt;
+    &lt;Source&gt;src/OgreMainWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/OgreWidget.py&lt;/Source&gt;
+    &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
+    &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
+    &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/Property.py&lt;/Source&gt;
+    &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
+    &lt;Source&gt;src/ObjectPropertyModel.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClass.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClassManager.py&lt;/Source&gt;
+    &lt;Source&gt;src/setup.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClassView.py&lt;/Source&gt;
+    &lt;Source&gt;src/MyRaySceneQueryListener.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOStringEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOIntEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/CodeDump.py&lt;/Source&gt;
+    &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
+    &lt;Source&gt;src/Ui_NewModuleWizard.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModuleExplorer.py&lt;/Source&gt;
+  &lt;/Sources&gt;
+  &lt;Forms&gt;
+    &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;
+    &lt;Form&gt;ui files/GOPropertyEditorDialogSTRING.ui&lt;/Form&gt;
+    &lt;Form&gt;ui files/NewModuleWizard.ui&lt;/Form&gt;
+  &lt;/Forms&gt;
+  &lt;Translations&gt;
+  &lt;/Translations&gt;
+  &lt;Resources&gt;
+  &lt;/Resources&gt;
+  &lt;Interfaces&gt;
+  &lt;/Interfaces&gt;
+  &lt;Others&gt;
+  &lt;/Others&gt;
+  &lt;MainScript&gt;src/Lockenwickler.py&lt;/MainScript&gt;
+  &lt;Vcs&gt;
+    &lt;VcsType&gt;None&lt;/VcsType&gt;
+    &lt;VcsOptions&gt;
+      &lt;dict&gt;
+        &lt;key&gt;
+          &lt;string&gt;add&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;checkout&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;commit&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;diff&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;export&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;global&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;history&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;log&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;remove&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;status&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;tag&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;update&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+      &lt;/dict&gt;
+    &lt;/VcsOptions&gt;
+    &lt;VcsOtherData&gt;
+      &lt;dict&gt;
+        &lt;key&gt;
+          &lt;string&gt;standardLayout&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;bool&gt;True&lt;/bool&gt;
+        &lt;/value&gt;
+      &lt;/dict&gt;
+    &lt;/VcsOtherData&gt;
+  &lt;/Vcs&gt;
+  &lt;FiletypeAssociations&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ui&quot; type=&quot;FORMS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.idl&quot; type=&quot;INTERFACES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.qm&quot; type=&quot;TRANSLATIONS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ptl&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.pyw&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ui.h&quot; type=&quot;FORMS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ts&quot; type=&quot;TRANSLATIONS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.py&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.qrc&quot; type=&quot;RESOURCES&quot; /&gt;
+  &lt;/FiletypeAssociations&gt;
 &lt;/Project&gt;
\ No newline at end of file

Copied: rl/branches/newton20/editors/Lockenwickler/_eric4project (from rev 4722, rl/trunk/editors/Lockenwickler/_eric4project)

Deleted: rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,7 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;!DOCTYPE UserProject SYSTEM &quot;UserProject-4.0.dtd&quot;&gt;
-&lt;!-- eric4 user project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-01-26, 17:27:44 --&gt;
-&lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
-&lt;UserProject version=&quot;4.0&quot;&gt;
-&lt;/UserProject&gt;
\ No newline at end of file

Copied: rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q (from rev 4722, rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q)

Deleted: rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,15 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;!DOCTYPE Tasks SYSTEM &quot;Tasks-4.2.dtd&quot;&gt;
-&lt;!-- eric4 tasks file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-01-26, 17:27:44 --&gt;
-&lt;Tasks version=&quot;4.2&quot;&gt;
-  &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
-    &lt;Summary&gt;TODO: implement save here&lt;/Summary&gt;
-    &lt;Description&gt;&lt;/Description&gt;
-    &lt;Created&gt;2009-01-26, 17:23:59&lt;/Created&gt;
-    &lt;Resource&gt;
-      &lt;Filename&gt;src/Lockenwickler.py&lt;/Filename&gt;
-      &lt;Linenumber&gt;416&lt;/Linenumber&gt;
-    &lt;/Resource&gt;
-  &lt;/Task&gt;
-&lt;/Tasks&gt;
\ No newline at end of file

Copied: rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t (from rev 4722, rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t)


Property changes on: rl/branches/newton20/editors/Lockenwickler/src
___________________________________________________________________
Name: svn:ignore
   + ogre.cfg


Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,208 +1,209 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import *
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-import ogre.renderer.OGRE as og
-
-from GOStringEditor import *
-from GOIntEditor import *
-
-class GOCStringProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;STRING&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCRealProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;REAL&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCBoolProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;BOOL&quot;
-
-class GOCIntProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INT&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOIntEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCIntPairProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTPAIR&quot;
-
-class GOCIntTripleProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTTRIPPLE&quot;
-
-class GOCMapProperty():
-    def __init__(self, name):
-        self.name = name
-        self.childProperties = []
-
-    def getType(self):
-        return &quot;MAP&quot;
-
-# gameObjectClass is the id of the class itself
-# since a game object can be ingame more than once there is also a id for those
-class GameObjectRepresentation(og.UserDefinedObject):
-    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
-        og.UserDefinedObject.__init__(self)
-        self.inWorldId = inWorldId
-        self.gocName = gameObjectClass
-        self.node = node
-        self.meshFile = meshFile
-        self.state = &quot;IN_SCENE&quot;
-
-    def getType(self):
-        return &quot;GAME_OBJECT_REPRESENTATION&quot;
-
-    def setPosition(self, pos):
-        self.node.setPosition(pos)
-
-
-class GameObjectClass():
-    def __init__(self,  parentElement):
-        self.classid = parentElement.get(&quot;classid&quot;)
-        self.baseclass = parentElement.get(&quot;baseclass&quot;)
-
-        self.meshFile = None
-
-        self.properties = []
-
-        for property in parentElement:#.getiterator(&quot;property&quot;):
-            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
-                pass
-            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
-                self.properties.append(self.createPropertyMap(property))
-            else:
-                self.properties.append(self.createProperty(property))
-
-    def getType(self):
-        return &quot;GAME_OBJECT&quot;
-
-    def createPropertyMap(self, property):
-        propMap = GOCMapProperty(property.get(&quot;name&quot;))
-        for subProperty in property:
-            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
-                propMap.childProperties.append(self.createPropertyMap(property))
-            else:
-                for subProperty1 in property:
-                    propMap.childProperties.append(self.createProperty(subProperty1))
-
-        return propMap
-
-    def getMeshFileName(self):
-        if self.meshFile is None:
-            for prop in self.properties:
-                if prop.getType() == &quot;STRING&quot;:
-                    if prop.name == &quot;meshfile&quot;:
-                        self.meshFile = prop.data
-                        return self.meshFile
-            return None
-        else:
-            return self.meshFile
-
-
-    def createProperty(self, property):
-        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCStringProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCRealProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCBoolProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntPairProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntTripleProperty(name, data)
-        else:
-            print property.get(&quot;type&quot;)
-
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+#from elementtree.ElementTree import *
+from xml.etree.cElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from GOStringEditor import *
+from GOIntEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;STRING&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;REAL&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;BOOL&quot;
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INT&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOIntEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTPAIR&quot;
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTTRIPPLE&quot;
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return &quot;MAP&quot;
+
+# gameObjectClass is the id of the class itself
+# since a game object can be ingame more than once there is also a id for those
+class GameObjectRepresentation(og.UserDefinedObject):
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        og.UserDefinedObject.__init__(self)
+        self.inWorldId = inWorldId
+        self.gocName = gameObjectClass
+        self.node = node
+        self.meshFile = meshFile
+        self.state = &quot;IN_SCENE&quot;
+
+    def getType(self):
+        return &quot;GAME_OBJECT_REPRESENTATION&quot;
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get(&quot;classid&quot;)
+        self.baseclass = parentElement.get(&quot;baseclass&quot;)
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator(&quot;property&quot;):
+            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
+                pass
+            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return &quot;GAME_OBJECT&quot;
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get(&quot;name&quot;))
+        for subProperty in property:
+            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == &quot;STRING&quot;:
+                    if prop.name == &quot;meshfile&quot;:
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCStringProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCRealProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCBoolProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntPairProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get(&quot;type&quot;)
+
+
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,52 +1,53 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import parse
-
-from GameObjectClass import *
-
-class GameObjectClassManager():
-    def __init__(self):
-        self.fileDict = {}
-        self.callback = None
-
-    def parseGOFFiles(self, filePaths):
-        for filePath in filePaths:
-            tree = parse(filePath)
-            gocList = []
-            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
-                go = GameObjectClass(parent)
-                gocList.append(go)
-
-            self.fileDict[filePath] = gocList
-
-        if self.callback is not None:
-            self.callback(self.fileDict)
-
-    def getGameObjectWithClassId(self, id):
-        for key in self.fileDict:
-            for go in self.fileDict[key]:
-                if go.classid == id:
-                    return go
-
-        return None
-
-        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
-    def setGameObjectsViewUpdateCallback(self, callback):
-        self.callback = callback
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+#from elementtree.ElementTree import parse
+from xml.etree.cElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,445 +1,447 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-#sys.path.insert(0,'..')
-#import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from SceneExplorer import *
-from NewModuleWizard import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
-        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-        splash.setMask(pixmap.mask())
-        splash.showMessage(&quot;Starting...&quot;)
-        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
-        self.sceneExplorerWin = SceneExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
-        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
-            self.prefDialog.show()
-
-        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
-        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
-
-
-#        # Import Psyco if available
-#        try:
-#            import psyco
-#            psyco.full()
-#            #psyco.log()
-#            #psyco.profile()
-#        except ImportError:
-#            pass
-
-        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName(&quot;MainWindow&quot;)
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName(&quot;menubar&quot;)
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName(&quot;menuFile&quot;)
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName(&quot;menuView&quot;)
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName(&quot;statusbar&quot;)
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
-        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
-
-        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;filenew.png&quot;,  &quot;Open Module&quot;)
-        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
-
-        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
-        self.actionClose.setObjectName(&quot;actionQuit&quot;)
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
-        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
-
-        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
-        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
-
-        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
-        self.actionCut.setObjectName(&quot;actionCut&quot;)
-
-        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
-        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
-
-        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
-        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
-
-        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
-        self.actionMove.setObjectName(&quot;actionMove&quot;)
-
-        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleSceneExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Scene Explorer&quot;,  False)
-        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
-
-        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt + P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
-        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
-
-        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt + P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
-        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
-
-        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
-        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
-        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
-        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Scene Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
-        if platform.system() == &quot;Windows&quot;:
-            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
-        else:
-            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-
-        self.moduleName = &quot;&quot;
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-
-        og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-        self.moduleManager.pivot.hide()
-
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-
-    def actionOpenSlot(self):
-        self.moduleManager.openLoadModuleDialog(self.prefDialog.lineEdit.text(), self)
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self)
-        newModuleWiz.exec_()
-        return
-
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleSceneExplorer(self):
-        if self.sceneExplorerDock.isHidden():
-            self.sceneExplorerDock.show()
-        else:
-            self.sceneExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
-        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
-        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
-        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.sceneExplorerDock = QtGui.QDockWidget(self.tr(&quot;Scene Explorer&quot;), self)
-        self.sceneExplorerDock.setObjectName(&quot;SceneExplorerDockWindow&quot;)
-        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
-        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
-        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
-        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print&quot;&quot;
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == &quot;__main__&quot;:
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName(&quot;Team Pantheon&quot;)
-    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
-    app.setApplicationName(&quot;Lockenwickler&quot;)
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+ #################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import *
+from ModuleExplorer import *
+from NewModuleWizard import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage(&quot;Starting...&quot;)
+#        splash.show()
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
+        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
+            self.prefDialog.show()
+
+        self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        self.moduleManager.moduleExplorer = self.moduleExplorerWin
+        
+        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
+        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
+
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName(&quot;MainWindow&quot;)
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName(&quot;menubar&quot;)
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName(&quot;menuFile&quot;)
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName(&quot;menuView&quot;)
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName(&quot;statusbar&quot;)
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
+        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
+
+        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;filenew.png&quot;,  &quot;Open Module&quot;)
+        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
+
+        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
+        self.actionClose.setObjectName(&quot;actionQuit&quot;)
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
+        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
+
+        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
+        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
+
+        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
+        self.actionCut.setObjectName(&quot;actionCut&quot;)
+
+        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
+        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
+
+        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
+        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
+
+        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
+        self.actionMove.setObjectName(&quot;actionMove&quot;)
+
+        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleModuleExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Module Explorer&quot;,  False)
+        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
+        
+        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt + P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
+        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
+
+        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt + P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
+        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
+
+        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
+        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
+        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
+        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Module Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
+        if platform.system() == &quot;Windows&quot;:
+            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
+        else:
+            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+
+        self.moduleName = &quot;&quot;
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+
+        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+
+        og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+        self.moduleManager.pivot.hide()
+
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+
+    def actionOpenSlot(self):
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
+        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
+        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
+        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr(&quot;Module Explorer&quot;), self)
+        self.moduleExplorerDock.setObjectName(&quot;SceneExplorerDockWindow&quot;)
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
+        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
+        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
+        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyReleaseEvent(event)
+        pass
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print&quot;&quot;
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
+if __name__ == &quot;__main__&quot;:
+#    # Import Psyco if available
+#    try:
+##        import psyco
+##        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName(&quot;Team Pantheon&quot;)
+    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
+    app.setApplicationName(&quot;Lockenwickler&quot;)
+
+    form = Lockenwickler()
+    form.show()
+
+    sys.exit(app.exec_())
+

Copied: rl/branches/newton20/editors/Lockenwickler/src/ModuleExplorer.py (from rev 4722, rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,711 +1,754 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-
-import elementtree.ElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-
-#                &lt;zone name=&quot;Testzone&quot;&gt;
-#                        &lt;area type=&quot;sphere&quot;&gt;
-#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
-#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
-#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
-#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
-#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
-#                        &lt;/area&gt;
-#                        &lt;light name=&quot;red pointlight&quot;/&gt;
-#                        &lt;light name=&quot;green spotlight&quot;/&gt;
-#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
-#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
-#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
-#                        &lt;/trigger&gt;
-#                &lt;/zone&gt;
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager):
-        self.pathToMapFile = pathToFile
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-
-        xmlTree = xml.parse(pathToFile)
-        root = xmlTree.getroot()
-
-        if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
-            self.parseMapNodes(root.find(&quot;nodes&quot;))
-            #self.parseMapZones(root.find(&quot;zones&quot;))
-        else:
-            print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
-            return
-
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator(&quot;entity&quot;)
-        if len(nodes) &gt; 0:
-            self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator(&quot;light&quot;)
-        if len(nodes) &gt; 0:
-            self.createLights(nodes)
-
-        nodes = nodeElement.getiterator(&quot;sound&quot;)
-        if len(nodes) &gt; 0:
-            self.createSound(nodes)
-
-        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
-        if len(nodes) &gt; 0:
-            self.createGameObjects(nodes)
-
-        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
-        if len(nodes) &gt; 0:
-            self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib[&quot;name&quot;]
-            print entityName
-            meshFile = nodes.attrib[&quot;meshfile&quot;]
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == &quot;scale&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodeScale = og.Vector3(x, y, z)
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                continue
-
-            n = self.mapNode.createChild(entityName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib[&quot;name&quot;]
-            lightType = l.attrib[&quot;type&quot;]
-            lightVisible = bool(l.attrib[&quot;visible&quot;])
-            castShadows = bool(l.attrib[&quot;castShadows&quot;])
-            lightPosition = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationlinear = None
-            lightAttenuationQuadratic = None
-
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;colourDiffuse&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == &quot;colourSpecular&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == &quot;lightAttenuation&quot;:
-                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
-                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
-                    lightAttenuationlinear = float(t.attrib[&quot;linear&quot;])
-                    lightAttenuationQuadratic = float(t.attrib[&quot;quadratic&quot;])
-
-            e = self.sceneManager.createEntity(lightName, &quot;lightbulp.mesh&quot;)
-            n = self.mapNode.createChild(lightName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.setPosition(lightPosition)
-
-    def createSound(self, soundNodes):
-        raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib[&quot;class&quot;]
-            id = int(g.attrib[&quot;id&quot;])
-            state = g.attrib[&quot;state&quot;]
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == &quot;scale&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodeScale = og.Vector3(x, y, z)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                ent = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(id), str(meshFile))
-                dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-                if nodeScale:
-                    dropNode.setScale(nodeScale)
-
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                go.inWorldId = id
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        raise NotImplementedError
-        return
-
-class Scene():
-    def __init__(self):
-        return
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-        self.mapFiles = [] # a list in case the module has more than one map file
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-
-    def isCommon(self):
-        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Error: couldn't find module config&quot;)
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith(&quot;super(&quot;):
-                split = lStripped.split(&quot;,&quot;)
-                if split[2].strip() == unicode(&quot;true&quot;):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == &quot;end&quot;:
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    self.moduleDependencies.append(lStripped.split('&quot;')[1])
-
-            elif lStripped == &quot;def getDependencies()&quot;:
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-
-        self.isLoaded = True
-        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Error: couldn't find module config&quot;)
-            return
-
-        #for i, line in enumerate(f):
-            #lStripped = line.strip() #strip the whitespace away, not needed here
-
-        self.setResourcePaths()
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, &quot;maps/*.rlmap.xml&quot;)
-            maps = glob.glob(cmd)
-            for m in maps:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-
-            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
-            sceneFile = glob.glob(cmd)
-            #self.loadScenes(sceneFile)
-
-    def saveMaps(self):
-        return
-
-    def saveScenes(self):
-        return
-
-    def setResourcePaths(self, recurseFolder = &quot;&quot;):
-        if recurseFolder == &quot;&quot;:
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
-                self.setResourcePaths(curFile)
-            if os.path.isfile(curFile):
-                pass
-
-class ModuleManager():
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
-        self.gocManager = GameObjectClassManager()
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
-
-        self.mainModule = []
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-
-        self.listenerDings = MyRaySceneQueryListener()
-
-        self.lastRay = None
-#        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-        self.moduleConfigIsParsed = False
-
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
-
-        self.moduleConfigIsParsed = True
-
-    def openLoadModuleDialog(self, moduleConfigPath, lw):
-        self.moduleCfgPath = str(moduleConfigPath)
-        self.moduleFolder = str(moduleConfigPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog()
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
-        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-                m.load()
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-                self.mainModule = m
-
-        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
-        e.setMaterialName(&quot;Lockenwickler_Area&quot;)
-
-        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
-        e2.setMaterialName(&quot;Lockenwickler_Area&quot;)
-
-        n.attachObject(e)
-        n.attachObject(e2)
-        n.setScale(og.Vector3(10, 5, 20))
-
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-
-        if so is not None:
-            if not so.isPivot:
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
-#
-#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = &quot;&quot;
-        split = name.split(&quot;_&quot;)
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + &quot;_1&quot;
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if so.entity.getUserObject().getType() == &quot;GAME_OBJECT_REPRESENTATION&quot;:
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-                        newNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gameObjectRepresentationDict.append(newGO)
-                        newEntity.setUserObject(newGO)
-                        newGO.setPosition(og.Vector3(0, 0, 0))
-
-                        newSO = SelectionObject(newEntity, so.distance)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        self.dropCount += 1
-            else:
-                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-                entityName = self.incrementNameSuffixNumber(so.entity.getName())
-                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                newNode.attachObject(newEntity)
-                newNode.setPosition(so.entity.getParentNode().getPosition())
-                newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                newNode.setScale(so.entity.getParentNode().getScale())
-
-                newSO = SelectionObject(newEntity, so.distance)
-                newSO.setSelected(True)
-                newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) &lt; 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-        self.listenerDings.reset()
-        pass
-
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        pass
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-            dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print &quot;sd&quot;
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
-        self.dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+
+#                &lt;zone name=&quot;Testzone&quot;&gt;
+#                        &lt;area type=&quot;sphere&quot;&gt;
+#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
+#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
+#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
+#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
+#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
+#                        &lt;/area&gt;
+#                        &lt;light name=&quot;red pointlight&quot;/&gt;
+#                        &lt;light name=&quot;green spotlight&quot;/&gt;
+#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
+#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
+#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
+#                        &lt;/trigger&gt;
+#                &lt;/zone&gt;
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
+        mapName = mapName.split(&quot;/&quot;)
+        mapName = mapName[len(mapName) - 1].split(&quot;.&quot;)
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+
+        xmlTree = xml.parse(pathToFile)
+        root = xmlTree.getroot()
+
+        if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
+            self.parseMapNodes(root.find(&quot;nodes&quot;))
+            #self.parseMapZones(root.find(&quot;zones&quot;))
+        else:
+            print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
+            return
+
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator(&quot;entity&quot;)
+        
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator(&quot;light&quot;)
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator(&quot;sound&quot;)
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
+        self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib[&quot;name&quot;]
+            meshFile = nodes.attrib[&quot;meshfile&quot;]
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    posx = float(t.attrib[&quot;x&quot;])
+                    posy = float(t.attrib[&quot;y&quot;])
+                    posz = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                elif t.tag == &quot;scale&quot;:
+                    scalex = float(t.attrib[&quot;x&quot;])
+                    scaley = float(t.attrib[&quot;y&quot;])
+                    scalez = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
+                continue
+
+            n = self.mapNode.createChild(entityName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib[&quot;name&quot;]
+            lightType = l.attrib[&quot;type&quot;]
+            lightVisible = bool(l.attrib[&quot;visible&quot;])
+            castShadows = bool(l.attrib[&quot;castShadows&quot;])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationlinear = None
+            lightAttenuationQuadratic = None
+
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;colourDiffuse&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == &quot;colourSpecular&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == &quot;lightAttenuation&quot;:
+                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
+                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
+                    lightAttenuationlinear = float(t.attrib[&quot;linear&quot;])
+                    lightAttenuationQuadratic = float(t.attrib[&quot;quadratic&quot;])
+
+            e = self.sceneManager.createEntity(lightName, &quot;lightbulp.mesh&quot;)
+            n = self.mapNode.createChild(lightName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.setPosition(lightPosition)
+
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib[&quot;class&quot;]
+            id = int(g.attrib[&quot;id&quot;])
+            state = g.attrib[&quot;state&quot;]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == &quot;scale&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(id), str(meshFile))
+                dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager):
+        self.moduleRoot = moduleroot
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        
+        xmlTree = xml.parse(pathToFile)
+        root = xmlTree.getroot()
+        self.name = root.attrib[&quot;name&quot;]
+        
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        
+        maps = root.getiterator(&quot;map&quot;)
+        for m in maps:
+            mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
+            
+        for m in mappaths:
+            self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+            
+        #cmd = join(self.moduleRoot, &quot;maps/*.rlmap.xml&quot;)
+        #maps = glob.glob(cmd)
+        #for m in maps:
+            #self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Error: couldn't find module config&quot;)
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;super(&quot;):
+                split = lStripped.split(&quot;,&quot;)
+                if split[2].strip() == unicode(&quot;true&quot;):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == &quot;end&quot;:
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('&quot;')[1])
+
+            elif lStripped == &quot;def getDependencies()&quot;:
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Error: couldn't find module config&quot;)
+            return
+
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
+
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+
+    def loadScenes(self, sceneFiles):
+        for f in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, f, self.sceneManager, self.ogreRoot, self.gocManager))
+
+    def saveMaps(self):
+        return
+
+    def saveScenes(self):
+        return
+
+    def setResourcePaths(self, recurseFolder = &quot;&quot;):
+        if recurseFolder == &quot;&quot;:
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
+                self.setResourcePaths(curFile)
+            if os.path.isfile(curFile):
+                pass
+
+class ModuleManager():
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
+        self.moduleCfgPath = &quot;&quot;
+
+        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
+
+        self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.mainModule = []
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+
+        self.listenerDings = MyRaySceneQueryListener()
+
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
+
+        self.moduleConfigIsParsed = True
+
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
+        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                
+        self.moduleExplorer.updateView()
+#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+#        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
+#        e.setMaterialName(&quot;Lockenwickler_Area&quot;)
+#
+#        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
+#        e2.setMaterialName(&quot;Lockenwickler_Area&quot;)
+
+#        n.attachObject(e)
+#        n.attachObject(e2)
+#        n.setScale(og.Vector3(10, 5, 20))
+
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        self.listenerDings.reset()
+        self.lastRay = ray
+        self.listenerDings.currentRay = ray
+        self.raySceneQuery.Ray = ray
+        self.raySceneQuery.execute(self.listenerDings)
+
+        so = self.listenerDings.rayCastToPolygonLevel(ray)
+
+        if so is not None:
+            if not so.isPivot:
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+        if self.rayLine == None:
+            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
+            self.rayLine.setDynamic(True)
+            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+
+            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+        else:
+            self.rayLine.beginUpdate(0)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = &quot;&quot;
+        split = name.split(&quot;_&quot;)
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + &quot;_1&quot;
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == &quot;GAME_OBJECT_REPRESENTATION&quot;:
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) &lt; 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+        self.listenerDings.reset()
+        pass
+
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        pass
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+            dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print &quot;sd&quot;
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+        self.dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,218 +1,218 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import ogre.renderer.OGRE as og
-
-class Pivot():
-    def __init__(self,  sceneManager):
-        self.sceneManager = sceneManager
-        self.camera = self.sceneManager.getCamera(&quot;MainCam&quot;)
-
-        self.mode = None
-        self.isHidden = True
-
-        self.meshManager = og.MeshManager.getSingleton ()
-
-        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode(&quot;pivotNode&quot;)
-        self.__createMovePivot()
-        self.__createRotatePivot()
-        self.__createScalePivot()
-        self.hide()
-        self.setMoveMode()
-
-        self.moveDirection = None
-        self.isTransforming = False
-        self.selectionList = None
-
-    def __createMovePivot(self):
-        self.xMoveEntity = self.sceneManager.createEntity(&quot;EditorXArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.xMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthCheckEnabled(False)
-#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthWriteEnabled(False)
-        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
-        self.xMoveNode = self.pivotNode.createChildSceneNode()
-        self.xMoveNode.attachObject(self.xMoveEntity)
-        self.xMoveNode.translate(og.Vector3(2, 0, 0))
-        self.xMoveNode.rotate(og.Vector3.UNIT_Y,  og.Degree(90))
-
-#        plane = og.Plane (og.Vector3.UNIT_X, 0)
-#        self.meshManager.createPlane ('EditorXArrowSelectionPlane', 'General', plane, 5, 14, 1, 1, False, 1, 5, 5, (0, 0, 1))
-#        self.xMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorXArrowSelectionPlane', 'EditorXArrowSelectionPlane')
-#        self.xMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
-#        self.xMoveNodeSelectionPlane.attachObject (self.xMoveEntitySelectionPlane)
-#        self.xMoveNodeSelectionPlane.translate(og.Vector3(0, 0, 5))
-#        self.xMoveEntitySelectionPlane.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-
-
-
-        self.yMoveEntity = self.sceneManager.createEntity(&quot;EditorYArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.yMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
-        self.yMoveNode = self.pivotNode.createChildSceneNode()
-        self.yMoveNode.attachObject(self.yMoveEntity)
-        self.yMoveNode.translate(og.Vector3(0, 2, 0))
-        self.yMoveNode.rotate(og.Vector3.UNIT_X,  og.Degree(-90))
-        #self.yNode.showBoundingBox(True)
-
-#        plane = og.Plane (og.Vector3.UNIT_X, 0)
-#        self.meshManager.createPlane ('EditorYArrowSelectionPlane', 'General', plane, 14, 0, 1, 1, False, 1, 5, 5, (0, 0, 1))
-#        self.yMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorYArrowSelectionPlane', 'EditorYArrowSelectionPlane')
-#        self.yMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
-#        self.yMoveNodeSelectionPlane.attachObject (self.yMoveEntitySelectionPlane)
-#        self.yMoveNodeSelectionPlane.translate(og.Vector3(0, 5, 0))
-#        self.yMoveEntitySelectionPlane.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-
-
-        self.zMoveEntity = self.sceneManager.createEntity(&quot;EditorZArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.zMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
-        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
-        self.zMoveNode = self.pivotNode.createChildSceneNode()
-        self.zMoveNode.attachObject(self.zMoveEntity)
-        self.zMoveNode.translate(og.Vector3(0, 0, 2))
-        #self.zNode.showBoundingBox(True)
-
-        self.freeMoveEntity = self.sceneManager.createEntity(&quot;EditorFreeMoveArrow&quot;,  &quot;Pivot_FreeMover.mesh&quot;)
-        self.freeMoveEntity.setMaterialName(&quot;Lockenwickler_FreeMover&quot;)
-        self.freeMoveNode = self.pivotNode.createChildSceneNode()
-        self.freeMoveNode.attachObject(self.freeMoveEntity)
-
-
-    def __createRotatePivot(self):
-        self.xRotateEntity = self.sceneManager.createEntity(&quot;EditorXRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
-        self.xRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
-        self.xRotateNode = self.pivotNode.createChildSceneNode()
-        self.xRotateNode.attachObject(self.xRotateEntity)
-        #self.xRotateNode.translate(0, 0, -5)
-        self.xRotateNode.rotate(og.Vector3.UNIT_Y,  og.Degree(90))
-
-        self.yRotateEntity = self.sceneManager.createEntity(&quot;EditorYRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
-        self.yRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
-        self.yRotateNode = self.pivotNode.createChildSceneNode()
-        self.yRotateNode.attachObject(self.yRotateEntity)
-        #self.yRotateNode.translate(0, 0, -10)
-        self.yRotateNode.rotate(og.Vector3.UNIT_X,  og.Degree(90))
-
-        self.zRotateEntity = self.sceneManager.createEntity(&quot;EditorZRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
-        self.zRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
-        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
-        self.zRotateNode = self.pivotNode.createChildSceneNode()
-        self.zRotateNode.attachObject(self.zRotateEntity)
-
-
-    def __createScalePivot(self):
-        pass
-
-    def setPosition(self,  pos):
-        self.pivotNode.setPosition(pos)
-
-    def getPosition(self):
-        return self.pivotNode.getPosition()
-
-    def startTransforming(self, dirEntity, soList):
-        print &quot;dbg: transforming.....&quot;
-        self.moveDirection = dirEntity.getName()
-        self.selectionList = soList
-        self.isTransforming = True
-        pass
-
-    def stopTransforming(self):
-        self.isTransforming = False
-        pass
-
-    def hide(self):
-        self.pivotNode.removeAllChildren()
-        self.isHidden = True
-
-    def show(self):
-        self.hide()
-        if self.mode == 1:
-            self.pivotNode.addChild(self.xMoveNode)
-            self.pivotNode.addChild(self.yMoveNode)
-            self.pivotNode.addChild(self.zMoveNode)
-        elif self.mode == 2:
-            self.pivotNode.addChild(self.xRotateNode)
-            self.pivotNode.addChild(self.yRotateNode)
-            self.pivotNode.addChild(self.zRotateNode)
-        elif self.mode == 3:
-            return
-        self.isHidden = False
-
-    def setMoveMode(self):
-        self.hide()
-        self.mode = 1
-        self.pivotNode.addChild(self.xMoveNode)
-        self.pivotNode.addChild(self.yMoveNode)
-        self.pivotNode.addChild(self.zMoveNode)
-        pass
-
-    def setRotateMode(self):
-        self.hide()
-        self.mode = 2
-        self.pivotNode.addChild(self.xRotateNode)
-        self.pivotNode.addChild(self.yRotateNode)
-        self.pivotNode.addChild(self.zRotateNode)
-        pass
-
-    def settScaleMode(self):
-        pass
-
-    def onMouseMoved(self, globalX, globalY, incX, incY):
-        # move mode
-        if self.isTransforming:
-            if self.mode == 1:
-                transFactor = 0.1
-                transVec = og.Vector3()
-                if self.moveDirection == &quot;EditorXArrow&quot;:
-                    transVec = og.Vector3(-incX, 0.0 , 0.0)
-                elif self.moveDirection == &quot;EditorYArrow&quot;:
-                    transVec = og.Vector3(0.0, -incY, 0.0)
-                elif self.moveDirection == &quot;EditorZArrow&quot;:
-                    transVec = og.Vector3(0.0, 0.0, incX)
-
-                transVec = transVec * transFactor
-                for so in self.selectionList:
-                    so.entity.getParentNode().translate(transVec)
-
-                self.pivotNode.translate(transVec)
-
-            # rotate mode
-            elif self.mode == 2:
-                rotValue = (incX + incY) * 0.05
-
-                if self.moveDirection == &quot;EditorXRotator&quot;:
-                    for so in self.selectionList:
-                        so.entity.getParentNode().pitch(rotValue)
-                if self.moveDirection == &quot;EditorYRotator&quot;:
-                    for so in self.selectionList:
-                        so.entity.getParentNode().yaw(rotValue)
-                if self.moveDirection == &quot;EditorZRotator&quot;:
-                    for so in self.selectionList:
-                        so.entity.getParentNode().roll(rotValue)
-
-        self.update()
-
-    def update(self):
-        if not self.isHidden:
-            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
-            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import ogre.renderer.OGRE as og
+
+class Pivot():
+    def __init__(self,  sceneManager):
+        self.sceneManager = sceneManager
+        self.camera = self.sceneManager.getCamera(&quot;MainCam&quot;)
+
+        self.mode = None
+        self.isHidden = True
+
+        self.meshManager = og.MeshManager.getSingleton ()
+
+        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode(&quot;pivotNode&quot;)
+        self.__createMovePivot()
+        self.__createRotatePivot()
+        self.__createScalePivot()
+        self.hide()
+        self.setMoveMode()
+
+        self.moveDirection = None
+        self.isTransforming = False
+        self.selectionList = None
+
+    def __createMovePivot(self):
+        self.xMoveEntity = self.sceneManager.createEntity(&quot;EditorXArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.xMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthCheckEnabled(False)
+#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthWriteEnabled(False)
+        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.xMoveNode = self.pivotNode.createChildSceneNode()
+        self.xMoveNode.attachObject(self.xMoveEntity)
+        self.xMoveNode.translate(og.Vector3(2, 0, 0))
+        self.xMoveNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+
+#        plane = og.Plane (og.Vector3.UNIT_X, 0)
+#        self.meshManager.createPlane ('EditorXArrowSelectionPlane', 'General', plane, 5, 14, 1, 1, False, 1, 5, 5, (0, 0, 1))
+#        self.xMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorXArrowSelectionPlane', 'EditorXArrowSelectionPlane')
+#        self.xMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
+#        self.xMoveNodeSelectionPlane.attachObject (self.xMoveEntitySelectionPlane)
+#        self.xMoveNodeSelectionPlane.translate(og.Vector3(0, 0, 5))
+#        self.xMoveEntitySelectionPlane.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+
+
+
+        self.yMoveEntity = self.sceneManager.createEntity(&quot;EditorYArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.yMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.yMoveNode = self.pivotNode.createChildSceneNode()
+        self.yMoveNode.attachObject(self.yMoveEntity)
+        self.yMoveNode.translate(og.Vector3(0, 2, 0))
+        self.yMoveNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
+        #self.yNode.showBoundingBox(True)
+
+#        plane = og.Plane (og.Vector3().UNIT_X, 0)
+#        self.meshManager.createPlane ('EditorYArrowSelectionPlane', 'General', plane, 14, 0, 1, 1, False, 1, 5, 5, (0, 0, 1))
+#        self.yMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorYArrowSelectionPlane', 'EditorYArrowSelectionPlane')
+#        self.yMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
+#        self.yMoveNodeSelectionPlane.attachObject (self.yMoveEntitySelectionPlane)
+#        self.yMoveNodeSelectionPlane.translate(og.Vector3(0, 5, 0))
+#        self.yMoveEntitySelectionPlane.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+
+
+        self.zMoveEntity = self.sceneManager.createEntity(&quot;EditorZArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.zMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.zMoveNode = self.pivotNode.createChildSceneNode()
+        self.zMoveNode.attachObject(self.zMoveEntity)
+        self.zMoveNode.translate(og.Vector3(0, 0, 2))
+        #self.zNode.showBoundingBox(True)
+
+        self.freeMoveEntity = self.sceneManager.createEntity(&quot;EditorFreeMoveArrow&quot;,  &quot;Pivot_FreeMover.mesh&quot;)
+        self.freeMoveEntity.setMaterialName(&quot;Lockenwickler_FreeMover&quot;)
+        self.freeMoveNode = self.pivotNode.createChildSceneNode()
+        self.freeMoveNode.attachObject(self.freeMoveEntity)
+
+
+    def __createRotatePivot(self):
+        self.xRotateEntity = self.sceneManager.createEntity(&quot;EditorXRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
+        self.xRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.xRotateNode = self.pivotNode.createChildSceneNode()
+        self.xRotateNode.attachObject(self.xRotateEntity)
+        #self.xRotateNode.translate(0, 0, -5)
+        self.xRotateNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+
+        self.yRotateEntity = self.sceneManager.createEntity(&quot;EditorYRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
+        self.yRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.yRotateNode = self.pivotNode.createChildSceneNode()
+        self.yRotateNode.attachObject(self.yRotateEntity)
+        #self.yRotateNode.translate(0, 0, -10)
+        self.yRotateNode.rotate(og.Vector3().UNIT_X,  og.Degree(90))
+
+        self.zRotateEntity = self.sceneManager.createEntity(&quot;EditorZRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
+        self.zRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
+        self.zRotateNode = self.pivotNode.createChildSceneNode()
+        self.zRotateNode.attachObject(self.zRotateEntity)
+
+
+    def __createScalePivot(self):
+        pass
+
+    def setPosition(self,  pos):
+        self.pivotNode.setPosition(pos)
+
+    def getPosition(self):
+        return self.pivotNode.getPosition()
+
+    def startTransforming(self, dirEntity, soList):
+        print &quot;dbg: transforming.....&quot;
+        self.moveDirection = dirEntity.getName()
+        self.selectionList = soList
+        self.isTransforming = True
+        pass
+
+    def stopTransforming(self):
+        self.isTransforming = False
+        pass
+
+    def hide(self):
+        self.pivotNode.removeAllChildren()
+        self.isHidden = True
+
+    def show(self):
+        self.hide()
+        if self.mode == 1:
+            self.pivotNode.addChild(self.xMoveNode)
+            self.pivotNode.addChild(self.yMoveNode)
+            self.pivotNode.addChild(self.zMoveNode)
+        elif self.mode == 2:
+            self.pivotNode.addChild(self.xRotateNode)
+            self.pivotNode.addChild(self.yRotateNode)
+            self.pivotNode.addChild(self.zRotateNode)
+        elif self.mode == 3:
+            return
+        self.isHidden = False
+
+    def setMoveMode(self):
+        self.hide()
+        self.mode = 1
+        self.pivotNode.addChild(self.xMoveNode)
+        self.pivotNode.addChild(self.yMoveNode)
+        self.pivotNode.addChild(self.zMoveNode)
+        pass
+
+    def setRotateMode(self):
+        self.hide()
+        self.mode = 2
+        self.pivotNode.addChild(self.xRotateNode)
+        self.pivotNode.addChild(self.yRotateNode)
+        self.pivotNode.addChild(self.zRotateNode)
+        pass
+
+    def settScaleMode(self):
+        pass
+
+    def onMouseMoved(self, globalX, globalY, incX, incY):
+        # move mode
+        if self.isTransforming:
+            if self.mode == 1:
+                transFactor = 0.1
+                transVec = og.Vector3()
+                if self.moveDirection == &quot;EditorXArrow&quot;:
+                    transVec = og.Vector3(-incX, 0.0 , 0.0)
+                elif self.moveDirection == &quot;EditorYArrow&quot;:
+                    transVec = og.Vector3(0.0, -incY, 0.0)
+                elif self.moveDirection == &quot;EditorZArrow&quot;:
+                    transVec = og.Vector3(0.0, 0.0, incX)
+
+                transVec = transVec * transFactor
+                for so in self.selectionList:
+                    so.entity.getParentNode().translate(transVec)
+
+                self.pivotNode.translate(transVec)
+
+            # rotate mode
+            elif self.mode == 2:
+                rotValue = (incX + incY) * 0.05
+
+                if self.moveDirection == &quot;EditorXRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().pitch(rotValue)
+                if self.moveDirection == &quot;EditorYRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().yaw(rotValue)
+                if self.moveDirection == &quot;EditorZRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().roll(rotValue)
+
+        self.update()
+
+    def update(self):
+        if not self.isHidden:
+            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
+            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
+
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,306 +1,347 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity,  distance):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.distance = distance # the distance from camera at the time of selection
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
-    def __init__( self ):
-        super ( MyRaySceneQueryListener, self ).__init__()
-        self.previouseSelection = None
-        self.selectionList = []
-        self.previousSelected = -1
-        self.currentSelected = -1
-
-        self.mNormalList = []
-        self.mVertexList = []
-        self.mIndexList = []
-
-        self.currentRay = None
-        self.lastRay = None
-
-    # sort algorithm for the selection list
-    def sortCompareImp(self,  x,  y):
-        if x.distance &gt; y.distance:
-            return 1
-        elif x.distance == y.distance:
-            return 0
-        else: # x&lt;y
-            return -1
-
-    def queryResult ( self, entity, distance ):
-        #print &quot;dbg: &quot; + entity.getName()
-        if distance == 0.0: #camera is in the bounding box, ignore this selection
-            return True
-#        elif entity.getName() == &quot;rayLine&quot; :
-#            return True
-        elif entity.getName() == &quot;OgreMainWin::0::ViewportGrid&quot;:
-            return True
-        elif entity.isVisible() and entity.getName() == &quot;EditorXArrow&quot;:
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == &quot;EditorYArrow&quot;:
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == &quot;EditorZArrow&quot;:
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == &quot;EditorFreeMover&quot;:
-            return True
-        elif entity.getName() == &quot;EditorXRotator&quot; or entity.getName() == &quot;EditorYRotator&quot; or entity.getName() == &quot;EditorZRotator&quot;:
-            if entity.isVisible() and self.rayCastToPolygonLevelOnSingleMesh(self.currentRay,  entity):
-                so = SelectionObject(entity,  distance)
-                so.isPivot = True
-                self.selectionList.append(so)
-                return False
-            else:
-                return True
-        else:
-            so = SelectionObject(entity,  distance)
-            self.selectionList.append(so)
-
-        self.selectionList.sort(self.sortCompareImp)
-
-        return True
-
-    def reset(self):
-        self.previousSelected = -1
-        self.currentSelected = -1
-        del self.selectionList[:]
-        #self.selectionList = []
-
-#    def iterateEntityUnderMouse(self):
-#        self.previousSelected = self.currentSelected
-#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
-#            self.selectionList[self.currentSelected].setSelected(False)
-#
-#        self.currentSelected += 1
-#
-#        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
-#            self.currentSelected = 0
-#
-#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
-#            #print str(self.selectionList[self.currentSelected].distance) + &quot; &quot;  + self.selectionList[self.currentSelected].entity.getName()
-#            if self.rayCastToPolygonLevelOnCurrentSelection():
-#                self.selectionList[self.currentSelected].setSelected(True)
-#                return self.selectionList[self.currentSelected]
-
-
-    def getMeshInformation(self,  entity):
-        numVertices = 0
-        numIndices = 0
-        useSharedVertices = False
-
-        if not entity:
-            return False
-
-        pMesh = entity.getMesh()
-
-        pos =    entity.getParentNode().getWorldPosition()
-        orient = entity.getParentNode().getWorldOrientation()
-        scale =  entity.getParentNode().getScale()
-
-        for i in range ( pMesh.getNumSubMeshes() ):
-            pSubMesh = pMesh.getSubMesh(i)
-            if pSubMesh.useSharedVertices:
-                useSharedVertices = True
-            else:
-                numVertices += pSubMesh.vertexData.vertexCount
-            numIndices += pSubMesh.indexData.indexCount
-
-        if useSharedVertices:
-            numVertices += pMesh.sharedVertexData.vertexCount
-
-            storageclass = ctypes.c_float * 3
-            test=storageclass(0.0,  0.0,  0.0)
-#         mVertexList = new Point[numVertices];
-#         mIndexList = new unsigned int[numIndices];
-
-        self.mVertexList = []
-        self.mIndexList = []
-
-        ## Count the number of vertices and incides so we can Set them
-        indexCount = 0
-        vertListCount = 0
-
-        if useSharedVertices:
-            ## Real* pVertices (x, y, z order x numVertices)
-            elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-
-            if not elem:
-                ogre.Except(Exception.ERR_ITEM_NOT_FOUND, &quot;Can't find position elements in the &quot;
-                    &quot;mesh to be written!&quot;, &quot;MeshSerializerImpl.writeGeometry&quot;)
-
-            vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
-
-            ## need space for the 3 verticies
-            storageclass = ctypes.c_float * 3
-            test=storageclass(0.0,  0.0,  0.0)
-
-            for j in range ( pMesh.sharedVertexData.vertexCount ):
-                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctype.sizeof(ctype.c_float), ctype.addressof(test))
-                self.mVertexList.append( og.Vector3(test[0], test[1], test[2]) )
-                vertListCount+=1
-
-        for i in range ( pMesh.getNumSubMeshes() ):
-            pSubMesh = pMesh.getSubMesh(i)
-            if not pSubMesh.useSharedVertices:
-                ## Real* pVertices (x, y, z order x numVertices)
-                elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-
-                if not elem:
-                    og.Except(Exception.ERR_ITEM_NOT_FOUND, &quot;Can't find position elements in the &quot;
-                        &quot;mesh to be written!&quot;, &quot;MeshSerializerImpl.writeGeometry&quot;)
-
-                vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
-
-                ## need space for the verticies
-                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 6)
-                test=storageclass(0.0)
-
-                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 6 * ctypes.sizeof(ctypes.c_float), ctypes.addressof(test))
-
-                for j in range ( 0,  pSubMesh.vertexData.vertexCount * 6,  6):
-                    #print j
-                    p = og.Vector3(test[j], test[j+1], test[j+2])
-                    p /= scale
-                    p += pos
-                    p = orient * p
-                    self.mVertexList.append( p )
-                    vertListCount += 1
-
-            ibuf = pSubMesh.indexData.indexBuffer
-            ## need space for the verticies
-            storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
-            test2=storageclass()
-
-
-            ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
-            for j in range ( pSubMesh.indexData.indexCount ):
-                self.mIndexList.append (test2[j])   # unsigned short
-                indexCount += 1
-
-            ih = 0
-            for blah in self.mVertexList:
-                #print str(ih) + &quot;: &quot;  +  str(blah)
-                ih += 1
-
-#            for blah in self.mIndexList:
-#                print blah
-
-
-    # used when a new selection is made, meaning when not iterationg through the selected objects
-    def rayCastToPolygonLevel(self,  ray):
-        self.lastRay = ray
-
-        for so in self.selectionList:
-            if so.isPivot:
-                return so
-
-        if len(self.selectionList) &gt;= 1:
-            for so in self.selectionList:
-                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
-                    return so
-
-
-    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-        return True
-        self.getMeshInformation(entity)
-        name = entity.getName()
-        print &quot;dbg: &quot; + name
-
-        temp = []
-        for vec in self.mVertexList:
-            temp.append(vec.x)
-            temp.append(vec.y)
-            temp.append(vec.z)
-
-        globalPosition = entity.getParentNode().getWorldPosition()
-        globalOrientation = entity.getParentNode().getWorldOrientation()
-
-
-        i = 0
-        while i &lt;= (len(self.mIndexList) - 3):
-            verta = globalPosition + self.mVertexList[self.mIndexList[i]]
-            vertb = globalPosition + self.mVertexList[self.mIndexList[i+1]]
-            vertc = globalPosition + self.mVertexList[self.mIndexList[i+2]]
-
-            verta = globalOrientation * verta
-            vertb = globalOrientation * vertb
-            vertc = globalOrientation * vertc
-            normal = og.Math.calculateBasicFaceNormal(verta, vertb, vertc)
-
-            result = og.Math.intersects(ray, verta, vertb, vertc, True, True)
-            #result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-            #                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], normal,  True, True)
-
-            if result.first:
-                print &quot;dbg: Treffer!!!!!!!!!&quot;
-                return True
-
-            i += 3
-
-        return False
-
-    def rayCastToPolygonLevelOnCurrentSelection(self):
-        if len(self.selectionList) &gt;= 1:
-            self.getMeshInformation(self.selectionList[self.currentSelected].entity)
-
-            i = 0
-            while i &lt;= (len(self.mIndexList) - 3):
-                globalPosition = self.selectionList[self.currentSelected].entity.getParentNode().getPosition()
-                result = og.Math.intersects(self.lastRay, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
-
-                if result.first:
-                   return True
-
-                i += 3
-            return False
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import ctypes
+import ogre.renderer.OGRE as og
+import ogre.physics.OgreNewt as on
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity,  distance):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.distance = distance # the distance from camera at the time of selection
+        self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
+class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
+    def __init__( self ):
+        super ( MyRaySceneQueryListener, self ).__init__()
+        self.previouseSelection = None
+        self.selectionList = []
+        self.previousSelected = -1
+        self.currentSelected = -1
+
+        self.mNormalList = []
+        self.mVertexList = []
+        self.mIndexList = []
+
+        self.currentRay = None
+        self.lastRay = None
+
+        self.World = on.World()
+        self.World.setWorldSize(og.Vector3(-1000000, -1000000, -1000000), og.Vector3(1000000, 1000000, 1000000))
+
+    def __del__(self):
+        del self.World
+
+    # sort algorithm for the selection list
+    def sortCompareImp(self,  x,  y):
+        if x.distance &gt; y.distance:
+            return 1
+        elif x.distance == y.distance:
+            return 0
+        else: # x&lt;y
+            return -1
+
+    def queryResult ( self, entity, distance ):
+        #print &quot;dbg: &quot; + entity.getName()
+        if distance == 0.0: #camera is in the bounding box, ignore this selection
+            return True
+        elif entity.getName() == &quot;OgreMainWin::0::ViewportGrid&quot;:
+            return True
+        elif entity.getName() == &quot;rayLine&quot;:
+            return True
+        elif entity.isVisible() and entity.getName() == &quot;EditorXArrow&quot;:
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == &quot;EditorYArrow&quot;:
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == &quot;EditorZArrow&quot;:
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == &quot;EditorFreeMover&quot;:
+            return True
+        elif entity.getName() == &quot;EditorXRotator&quot; or entity.getName() == &quot;EditorYRotator&quot; or entity.getName() == &quot;EditorZRotator&quot;:
+            if entity.isVisible() and self.rayCastToPolygonLevelOnSingleMesh(self.currentRay,  entity):
+                so = SelectionObject(entity,  distance)
+                so.isPivot = True
+                self.selectionList.append(so)
+                return False
+            else:
+                return True
+        else:
+            so = SelectionObject(entity,  distance)
+            self.selectionList.append(so)
+
+        self.selectionList.sort(self.sortCompareImp)
+
+        return True
+
+    def reset(self):
+        self.previousSelected = -1
+        self.currentSelected = -1
+        del self.selectionList[:]
+        #self.selectionList = []
+
+    def rayCastToPolygonLevel(self,  ray):
+        self.lastRay = ray
+
+        for so in self.selectionList:
+            if so.isPivot:
+                return so
+
+        if len(self.selectionList) &gt;= 1:
+            for so in self.selectionList:
+                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
+                    return so
+
+
+    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
+        col = on.TreeCollision(self.World, entity.getParentNode(), False)
+        bod = on.Body(self.World, col)
+
+
+        start = ray.getOrigin()
+        end = ray.getPoint(10000)
+
+        retNorm = og.Vector3(0.0, 0.0, 0.0)
+
+        val = on.CollisionRayCast(col, start, end, retNorm)
+#        print val
+#
+#        print retNorm.x
+#        print retNorm.y
+#        print retNorm.z
+        del col
+        self.World.destroyAllBodies()
+        
+        if retNorm.x != 0.0 or retNorm.y != 0.0 or retNorm.z != 0.0:
+#           print &quot;yes&quot;
+           return True
+        else:
+#            print &quot;no&quot;
+            return False
+           
+        
+        
+
+#    def iterateEntityUnderMouse(self):
+#        self.previousSelected = self.currentSelected
+#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
+#            self.selectionList[self.currentSelected].setSelected(False)
+#
+#        self.currentSelected += 1
+#
+#        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
+#            self.currentSelected = 0
+#
+#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
+#            #print str(self.selectionList[self.currentSelected].distance) + &quot; &quot;  + self.selectionList[self.currentSelected].entity.getName()
+#            if self.rayCastToPolygonLevelOnCurrentSelection():
+#                self.selectionList[self.currentSelected].setSelected(True)
+#                return self.selectionList[self.currentSelected]
+
+
+#    def getMeshInformation(self,  entity):
+#        numVertices = 0
+#        numIndices = 0
+#        useSharedVertices = False
+#
+#        if not entity:
+#            return False
+#
+#        pMesh = entity.getMesh()
+#
+#        position =    entity.getParentNode()._getDerivedPosition()
+#        orient = entity.getParentNode()._getDerivedOrientation()
+#        scale =  entity.getParentNode().getScale()
+#
+#        for i in range ( pMesh.getNumSubMeshes() ):
+#            pSubMesh = pMesh.getSubMesh(i)
+#            if pSubMesh.useSharedVertices:
+#                useSharedVertices = True
+#            else:
+#                numVertices += pSubMesh.vertexData.vertexCount
+#            numIndices += pSubMesh.indexData.indexCount
+#
+#        if useSharedVertices:
+#            numVertices += pMesh.sharedVertexData.vertexCount
+#
+#            storageclass = ctypes.c_float * 3
+#            test=storageclass(0.0,  0.0,  0.0)
+##         mVertexList = new Point[numVertices];
+##         mIndexList = new unsigned int[numIndices];
+#
+#        self.mVertexList = []
+#        self.mIndexList = []
+#
+#        ## Count the number of vertices and incides so we can Set them
+#        indexCount = 0
+#        vertListCount = 0
+#
+#        if useSharedVertices:
+#            ## Real* pVertices (x, y, z order x numVertices)
+#            elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
+#
+#            if not elem:
+#                ogre.Except(Exception.ERR_ITEM_NOT_FOUND, &quot;Can't find position elements in the &quot;
+#                    &quot;mesh to be written!&quot;, &quot;MeshSerializerImpl.writeGeometry&quot;)
+#
+#            vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
+#
+#            ## need space for the 3 verticies
+#            storageclass = ctypes.c_float * 3
+#            test=storageclass(0.0,  0.0,  0.0)
+#
+#            for j in range ( pMesh.sharedVertexData.vertexCount ):
+#                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctype.sizeof(ctype.c_float), ctype.addressof(test))
+#                pt = og.Vector3(test[0], test[1], test[2])
+#                self.mVertexList.append( (orient * (pt * scale)) + position )
+#                vertListCount+=1
+#
+#        for i in range ( pMesh.getNumSubMeshes() ):
+#            pSubMesh = pMesh.getSubMesh(i)
+#            if not pSubMesh.useSharedVertices:
+#                ## Real* pVertices (x, y, z order x numVertices)
+#                elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
+#
+#                if not elem:
+#                    og.Except(Exception.ERR_ITEM_NOT_FOUND, &quot;Can't find position elements in the &quot;
+#                        &quot;mesh to be written!&quot;, &quot;MeshSerializerImpl.writeGeometry&quot;)
+#
+#                vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
+#
+#                ## need space for the verticies
+#                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 6)
+#                test=storageclass(0.0)
+#
+#                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 6 * ctypes.sizeof(ctypes.c_float), ctypes.addressof(test))
+#
+#                for j in range ( 0,  pSubMesh.vertexData.vertexCount * 6,  6):
+#                    #print j
+#                    pt = og.Vector3(test[j], test[j+1], test[j+2])
+#                    self.mVertexList.append( (orient * (pt * scale)) + position )
+#                    vertListCount += 1
+#
+#            ibuf = pSubMesh.indexData.indexBuffer
+#            ## need space for the verticies
+#            storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
+#            test2=storageclass()
+#
+#
+#            ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
+#            for j in range ( pSubMesh.indexData.indexCount ):
+#                self.mIndexList.append (test2[j])   # unsigned short
+#                indexCount += 1
+#
+#            ih = 0
+#            for blah in self.mVertexList:
+#                #print str(ih) + &quot;: &quot;  +  str(blah)
+#                ih += 1
+#
+#    def rayCastToPolygonLevel(self,  ray):
+#        self.lastRay = ray
+#
+#        for so in self.selectionList:
+#            if so.isPivot:
+#                return so
+#
+#        if len(self.selectionList) &gt;= 1:
+#            for so in self.selectionList:
+#                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
+#                    return so
+#
+#
+#    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
+#        self.getMeshInformation(entity)
+#        name = entity.getName()
+#        print &quot;dbg: &quot; + name
+#
+#        temp = []
+#        for vec in self.mVertexList:
+#            temp.append(vec.x)
+#            temp.append(vec.y)
+#            temp.append(vec.z)
+#
+#        globalPosition = entity.getParentNode()._getDerivedPosition()
+#        globalOrientation = entity.getParentNode()._getDerivedOrientation()
+#
+#
+#        i = 0
+#        while i &lt;= (len(self.mIndexList) - 3):
+#            verta = globalPosition + self.mVertexList[self.mIndexList[i]]
+#            vertb = globalPosition + self.mVertexList[self.mIndexList[i+1]]
+#            vertc = globalPosition + self.mVertexList[self.mIndexList[i+2]]
+#
+#            verta = globalOrientation * verta
+#            vertb = globalOrientation * vertb
+#            vertc = globalOrientation * vertc
+#            normal = og.Math.calculateBasicFaceNormal(verta, vertb, vertc)
+#
+#            result = og.Math.intersects(ray, verta, vertb, vertc, True, True)
+#            #result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
+#            #                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], normal,  True, True)
+#
+#            if result.first:
+#                #print &quot;dbg: Treffer!!!!!!!!!&quot;
+#                return True
+#
+#            i += 3
+#
+#        return False
+#
+#    def rayCastToPolygonLevelOnCurrentSelection(self):
+#        if len(self.selectionList) &gt;= 1:
+#            self.getMeshInformation(self.selectionList[self.currentSelected].entity)
+#
+#            i = 0
+#            while i &lt;= (len(self.mIndexList) - 3):
+#                globalPosition = self.selectionList[self.currentSelected].entity.getParentNode().getPosition()
+#                result = og.Math.intersects(self.lastRay, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
+#                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
+#
+#                if result.first:
+#                   return True
+#
+#                i += 3
+#            return False

Modified: rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,48 +1,146 @@
-# -*- coding: utf-8 -*-
-
-&quot;&quot;&quot;
-Module implementing NewModuleWizard.
-&quot;&quot;&quot;
-
-from PyQt4.QtGui import QDialog
-from PyQt4.QtCore import pyqtSignature
-
-from Ui_NewModuleWizard import Ui_Dialog
-
-class NewModuleWizard(QDialog, Ui_Dialog):
-    &quot;&quot;&quot;
-    Class documentation goes here.
-    &quot;&quot;&quot;
-    def __init__(self, moduleManager, parent = None):
-        &quot;&quot;&quot;
-        Constructor
-        &quot;&quot;&quot;
-
-        self.moduleManager = moduleManager
-
-        QDialog.__init__(self, parent)
-        self.setupUi(self)
-
-    @pyqtSignature(&quot;QString&quot;)
-    def on_moduleNameLineEdit_textChanged(self, p0):
-        return
-        # TODO: not implemented yet
-        #raise NotImplementedError
-
-    @pyqtSignature(&quot;&quot;)
-    def on_moduleNameLineEdit_returnPressed(self):
-
-        # TODO: not implemented yet
-        raise NotImplementedError
-
-    @pyqtSignature(&quot;&quot;)
-    def on_okButton_clicked(self):
-
-        # TODO: not implemented yet
-        raise NotImplementedError
-
-    @pyqtSignature(&quot;&quot;)
-    def on_cancelButton_pressed(self):
-        self.close()
-
-
+# -*- coding: utf-8 -*-
+
+&quot;&quot;&quot;
+Module implementing NewModuleWizard.
+&quot;&quot;&quot;
+
+import os
+import glob
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_NewModuleWizard import Ui_Dialog
+
+class NewModuleWizard(QDialog, Ui_Dialog):
+    &quot;&quot;&quot;
+    Class documentation goes here.
+    &quot;&quot;&quot;
+    def __init__(self, moduleManager, parent = None):
+       
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+
+        self.moduleManager = moduleManager
+        self.moduleManager.parseModuleConfig()
+        
+        for m in self.moduleManager.moduleList:
+            self.moduleDependenciesList.addItem(m.name)
+
+    @pyqtSignature(&quot;QString&quot;)
+    def on_moduleNameLineEdit_textChanged(self, p0):
+        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
+            self.sceneNameLineEdit.setEnabled(True)
+            self.mapNameLineEdit.setEnabled(True)
+            self.moduleDependenciesList.setEnabled(True)
+            self.scriptDependenciesList.setEnabled(True)
+            self.okButton.setEnabled(True)
+        else:
+            self.sceneNameLineEdit.setEnabled(False)
+            self.mapNameLineEdit.setEnabled(False)
+            self.moduleDependenciesList.setEnabled(False)
+            self.scriptDependenciesList.setEnabled(False)
+            self.okButton.setEnabled(False)
+    
+    def scanDirForScripts(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                self.scanDirForScripts(curFile)
+                continue
+            if os.path.isfile(curFile):
+                if file.endswith(&quot;.rb&quot;):
+                    self.scriptDependenciesList.addItem(dir + &quot;/&quot; + file)
+    
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleDependenciesList_itemSelectionChanged(self):
+        self.scriptDependenciesList.clear()
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        
+        for m in self.moduleDependenciesList.selectedItems():
+            path = os.path.join(modulePath, str(m.text()))
+            cmd = os.path.join(path + &quot;/scripts&quot;)
+            self.scanDirForScripts(cmd)
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_moduleNameLineEdit_returnPressed(self):
+        return
+            
+    @pyqtSignature(&quot;&quot;)
+    def on_mapNameLineEdit_returnPressed(self):
+        return
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_okButton_clicked(self):
+        f = open(self.moduleManager.moduleCfgPath, &quot;a&quot;)
+        f.write(&quot;module=&quot; + str(self.moduleNameLineEdit.text()) + &quot;\n&quot;)
+        f.close()
+        
+        modulePath = self.moduleManager.moduleCfgPath.replace(&quot;modules.cfg&quot;,  &quot;&quot;)
+        modulePath = str(modulePath + self.moduleNameLineEdit.text())
+        os.mkdir(modulePath)
+        os.mkdir(os.path.join(modulePath, &quot;dialogs&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;dsa&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;gui&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;materials/textures&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;models&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;quests&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;scripts/maps&quot;))
+        os.mkdir(os.path.join(modulePath, &quot;sound&quot;))
+        
+        mname = str(self.moduleNameLineEdit.text())
+        mdeps = &quot;&quot;
+        for m in self.moduleDependenciesList.selectedItems():
+            mdeps = mdeps + str(&quot;\&quot;&quot; + m.text() + &quot;\&quot;, &quot;)
+        mdeps = mdeps.strip(&quot;, &quot;)
+        
+        sdeps = &quot;&quot;
+        for s in self.scriptDependenciesList.selectedItems():
+            script = str(str(s.text()).replace(&quot;\\&quot;, &quot;/&quot;))
+            script = script.split(&quot;/&quot;)
+            script = script[len(script) - 1]
+            sdeps = sdeps + str(&quot;       require &quot; + script + &quot;\n&quot;)
+        
+        
+        f = open(os.path.join(modulePath, &quot;scripts\\&quot;) + &quot;moduleconfig.rb&quot;, &quot;w&quot;)
+        f.write(&quot;include RlScript\n&quot;)
+        f.write(&quot;\n\n&quot;)
+        f.write(&quot;class &quot; + mname.capitalize() + &quot;Module &lt; ContentModule\n&quot;)
+        f.write(&quot;    def initialize()\n&quot;)
+        f.write(&quot;        super(\&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, \&quot;&quot; + mname + &quot;\&quot;&quot; + &quot;, false, 200608012)\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getDependencies()\n&quot;)
+        f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getTextureLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getModelLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def getSoundLocation()\n&quot;)
+        f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
+        f.write(&quot;    end\n\n&quot;)
+        f.write(&quot;    def start()\n&quot;)
+        f.write(sdeps)
+        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n&quot;)
+        f.write(&quot;       $World = $CORE.getWorld();\n&quot;)
+        f.write(&quot;    end\n&quot;)
+        f.write(&quot;end\n\n&quot;)
+
+        f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
+        
+        self.moduleManager.resetParsedModuleConfig()
+        self.moduleManager.openLoadModuleDialog()
+        
+    @pyqtSignature(&quot;&quot;)
+    def on_cancelButton_pressed(self):
+        self.close()
+
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,120 +1,120 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-
-        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            import sip
-            info = self.x11Info()
-            disp =  str(sip.unwrapinstance(info.display()))
-            scr = str(info.screen())
-            win = str(int(self.winId()))
-            winHandle = disp + ':' + scr + ':' + win
-            self.renderParameters['parentWindowHandle'] = winHandle
-
-        renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
-                                                        False, self.renderParameters)
-
-        renderWindow.active = True
-        self.renderWindow = renderWindow
-
-        self.camera = self.sceneManager.createCamera(cameraName)
-        self.camera.NearClipDistance = 0.1
-
-        # Create focus node (camera always points at this)
-        self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-        self.camFocusNode.setFixedYawAxis(True, og.Vector3.UNIT_Y)
-        # camera node is offset a ways along the Z axis of focus node
-        self.camNode = self.camFocusNode.createChildSceneNode()
-        # fix yaw on this one too for when we manipulate it directly
-        self.camNode.setFixedYawAxis(True, og.Vector3.UNIT_Y)
-        self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-        self.camNode.attachObject(self.camera)
-
-        self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-        self.viewport.setClearEveryFrame(True)
-
-    def setBackgroundColor(self, colorValue):
-        self.viewport.BackgroundColour = colorValue
-
-    def resizeEvent(self, event):
-        self.renderWindow.resize(event.size().width(), event.size().height())
-        self.renderWindow.windowMovedOrResized()
-
-        if platform.system() == &quot;Linux&quot;:
-            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-        self.renderWindow.update(True)
-        self.ogreRoot.renderOneFrame()
-
-        if self.camera:
-            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z &lt; self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3&amp; trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+
+        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            import sip
+            info = self.x11Info()
+            disp =  str(sip.unwrapinstance(info.display()))
+            scr = str(info.screen())
+            win = str(int(self.winId()))
+            winHandle = disp + ':' + scr + ':' + win
+            self.renderParameters['parentWindowHandle'] = winHandle
+
+        renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
+                                                        False, self.renderParameters)
+
+        renderWindow.active = True
+        self.renderWindow = renderWindow
+
+        self.camera = self.sceneManager.createCamera(cameraName)
+        self.camera.NearClipDistance = 0.1
+
+        # Create focus node (camera always points at this)
+        self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+        self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+        # camera node is offset a ways along the Z axis of focus node
+        self.camNode = self.camFocusNode.createChildSceneNode()
+        # fix yaw on this one too for when we manipulate it directly
+        self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+        self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+        self.camNode.attachObject(self.camera)
+
+        self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+        self.viewport.setClearEveryFrame(True)
+
+    def setBackgroundColor(self, colorValue):
+        self.viewport.BackgroundColour = colorValue
+
+    def resizeEvent(self, event):
+        self.renderWindow.resize(event.size().width(), event.size().height())
+        self.renderWindow.windowMovedOrResized()
+
+        if platform.system() == &quot;Linux&quot;:
+            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+        self.renderWindow.update(True)
+        self.ogreRoot.renderOneFrame()
+
+        if self.camera:
+            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z &lt; self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3&amp; trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/SceneExplorer.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/SceneExplorer.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/SceneExplorer.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,34 +0,0 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-import ogre.renderer.OGRE as og
-
-class SceneExplorer(QWidget):
-    def __init__(self, parent=None):
-        QWidget.__init__(self, parent)
-        self.sceneTreeView = QTreeView()
-
-        vBoxLayout = QVBoxLayout()
-        vBoxLayout.addWidget(self.sceneTreeView)
-
-        self.setLayout(vBoxLayout)
-

Modified: rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,100 +1,100 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
-#
-# Created: Sun Nov  9 14:15:16 2008
-#      by: PyQt4 UI code generator 4.4.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_Dialog(object):
-    def setupUi(self, Dialog):
-        Dialog.setObjectName(&quot;Dialog&quot;)
-        Dialog.resize(675, 703)
-        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
-        self.gridLayout_3.setObjectName(&quot;gridLayout_3&quot;)
-        self.label = QtGui.QLabel(Dialog)
-        self.label.setObjectName(&quot;label&quot;)
-        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
-        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.moduleNameLineEdit.setObjectName(&quot;moduleNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
-        self.label_2 = QtGui.QLabel(Dialog)
-        self.label_2.setObjectName(&quot;label_2&quot;)
-        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
-        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.sceneNameLineEdit.setEnabled(False)
-        self.sceneNameLineEdit.setObjectName(&quot;sceneNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
-        self.label_3 = QtGui.QLabel(Dialog)
-        self.label_3.setObjectName(&quot;label_3&quot;)
-        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
-        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.mapNameLineEdit.setEnabled(False)
-        self.mapNameLineEdit.setObjectName(&quot;mapNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
-        self.groupBox = QtGui.QGroupBox(Dialog)
-        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
-        self.groupBox.setObjectName(&quot;groupBox&quot;)
-        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
-        self.gridLayout_2.setObjectName(&quot;gridLayout_2&quot;)
-        self.moduleDependenciesList = QtGui.QListView(self.groupBox)
-        self.moduleDependenciesList.setEnabled(False)
-        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.moduleDependenciesList.setObjectName(&quot;moduleDependenciesList&quot;)
-        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
-        self.groupBox_2 = QtGui.QGroupBox(Dialog)
-        self.groupBox_2.setObjectName(&quot;groupBox_2&quot;)
-        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
-        self.gridLayout.setObjectName(&quot;gridLayout&quot;)
-        self.scriptDependenciesList = QtGui.QListView(self.groupBox_2)
-        self.scriptDependenciesList.setEnabled(False)
-        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.scriptDependenciesList.setObjectName(&quot;scriptDependenciesList&quot;)
-        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
-        self.hboxlayout = QtGui.QHBoxLayout()
-        self.hboxlayout.setSpacing(6)
-        self.hboxlayout.setMargin(0)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
-        self.hboxlayout.addItem(spacerItem)
-        self.okButton = QtGui.QPushButton(Dialog)
-        self.okButton.setEnabled(False)
-        self.okButton.setObjectName(&quot;okButton&quot;)
-        self.hboxlayout.addWidget(self.okButton)
-        self.cancelButton = QtGui.QPushButton(Dialog)
-        self.cancelButton.setObjectName(&quot;cancelButton&quot;)
-        self.hboxlayout.addWidget(self.cancelButton)
-        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
-
-        self.retranslateUi(Dialog)
-        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.accept)
-        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.reject)
-        QtCore.QMetaObject.connectSlotsByName(Dialog)
-
-    def retranslateUi(self, Dialog):
-        Dialog.setWindowTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 1: Module Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label_2.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 2: Scene Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label_3.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 3: Map Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 4: Module Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox_2.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 5: Script Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.okButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;OK&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.cancelButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;Cancel&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-
-if __name__ == &quot;__main__&quot;:
-    import sys
-    app = QtGui.QApplication(sys.argv)
-    Dialog = QtGui.QDialog()
-    ui = Ui_Dialog()
-    ui.setupUi(Dialog)
-    Dialog.show()
-    sys.exit(app.exec_())
-
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
+#
+# Created: Sun Nov  9 14:15:16 2008
+#      by: PyQt4 UI code generator 4.4.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_Dialog(object):
+    def setupUi(self, Dialog):
+        Dialog.setObjectName(&quot;Dialog&quot;)
+        Dialog.resize(675, 703)
+        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
+        self.gridLayout_3.setObjectName(&quot;gridLayout_3&quot;)
+        self.label = QtGui.QLabel(Dialog)
+        self.label.setObjectName(&quot;label&quot;)
+        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
+        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.moduleNameLineEdit.setObjectName(&quot;moduleNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
+        self.label_2 = QtGui.QLabel(Dialog)
+        self.label_2.setObjectName(&quot;label_2&quot;)
+        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
+        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.sceneNameLineEdit.setEnabled(False)
+        self.sceneNameLineEdit.setObjectName(&quot;sceneNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
+        self.label_3 = QtGui.QLabel(Dialog)
+        self.label_3.setObjectName(&quot;label_3&quot;)
+        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
+        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.mapNameLineEdit.setEnabled(False)
+        self.mapNameLineEdit.setObjectName(&quot;mapNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
+        self.groupBox = QtGui.QGroupBox(Dialog)
+        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
+        self.groupBox.setObjectName(&quot;groupBox&quot;)
+        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
+        self.gridLayout_2.setObjectName(&quot;gridLayout_2&quot;)
+        self.moduleDependenciesList = QtGui.QListWidget(self.groupBox)
+        self.moduleDependenciesList.setEnabled(False)
+        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.moduleDependenciesList.setObjectName(&quot;moduleDependenciesList&quot;)
+        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
+        self.groupBox_2 = QtGui.QGroupBox(Dialog)
+        self.groupBox_2.setObjectName(&quot;groupBox_2&quot;)
+        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
+        self.gridLayout.setObjectName(&quot;gridLayout&quot;)
+        self.scriptDependenciesList = QtGui.QListWidget(self.groupBox_2)
+        self.scriptDependenciesList.setEnabled(False)
+        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.scriptDependenciesList.setObjectName(&quot;scriptDependenciesList&quot;)
+        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
+        self.hboxlayout = QtGui.QHBoxLayout()
+        self.hboxlayout.setSpacing(6)
+        self.hboxlayout.setMargin(0)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.hboxlayout.addItem(spacerItem)
+        self.okButton = QtGui.QPushButton(Dialog)
+        self.okButton.setEnabled(False)
+        self.okButton.setObjectName(&quot;okButton&quot;)
+        self.hboxlayout.addWidget(self.okButton)
+        self.cancelButton = QtGui.QPushButton(Dialog)
+        self.cancelButton.setObjectName(&quot;cancelButton&quot;)
+        self.hboxlayout.addWidget(self.cancelButton)
+        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
+
+        self.retranslateUi(Dialog)
+        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.accept)
+        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.reject)
+        QtCore.QMetaObject.connectSlotsByName(Dialog)
+
+    def retranslateUi(self, Dialog):
+        Dialog.setWindowTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 1: Module Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label_2.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 2: Scene Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label_3.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 3: Map Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 4: Module Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox_2.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 5: Script Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.okButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;OK&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.cancelButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;Cancel&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+
+if __name__ == &quot;__main__&quot;:
+    import sys
+    app = QtGui.QApplication(sys.argv)
+    Dialog = QtGui.QDialog()
+    ui = Ui_Dialog()
+    ui.setupUi(Dialog)
+    Dialog.show()
+    sys.exit(app.exec_())
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/ViewportGrid.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ViewportGrid.py	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/editors/Lockenwickler/src/ViewportGrid.py	2009-01-27 21:35:12 UTC (rev 4723)
@@ -1,525 +1,525 @@
-#-----------------------------------------------------------------------------
-#Copyright (c) 2007 Jeroen Dierckx
-#Python Version by Stefan Stammberger
-#
-#This program is free software you can redistribute it and/or modify it under
-#the terms of the GNU Lesser General Public License as published by the Free Software
-#Foundation either version 2 of the License, or (at your option) any later
-#version.
-#
-#This program is distributed in the hope that it will be useful, but WITHOUT
-#ANY WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS
-#FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
-#
-#You should have received a copy of the GNU Lesser General Public License along with
-#this program if not, write to the Free Software Foundation, Inc., 59 Temple
-#Place - Suite 330, Boston, MA 02111-1307, USA, or go to
-#<A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
-#-----------------------------------------------------------------------------
-
-import ogre.renderer.OGRE as og
-
-RL_BEHIND = 1
-INFRONT = 2
-
-class ViewportGrid(og.RenderTargetListener):
-    def __init__(self, pSceneMgr, pViewport):
-        super(ViewportGrid, self).__init__()
-
-        self.sceneManager = pSceneMgr
-        self.viewport = pViewport
-        self.enabled = False
-        self.layer = None
-
-        self.prevCamera = None
-        self.prevOrtho = False
-        self.prevCamPos = None
-        self.prevNear = None
-        self.prevOrtho = None
-        self.prevAspectRatio = None
-        self.bForceUpdate = True
-
-        self.pGrid = None
-        self.created = False
-        self.pNode = None
-
-        self.colour1 = og.ColourValue(0.7, 0.7, 0.7)
-        self.colour2 = og.ColourValue(0.7, 0.7, 0.7)
-        self.division = 10
-        self.perspSize = 100
-        self.renderScale = True
-        self.renderMiniAxes = True
-
-        self.sMatName = &quot;ViewportGrid&quot;
-
-        self.__createGrid()
-        self.setRenderLayer(RL_BEHIND)
-
-        # Add this as a render target listener
-        self.viewport.getTarget().addListener(self)
-
-
-    def getColour(self):
-        return colour1
-
-    def setColour(self, colour):
-        # Force alpha = 1 for the primary colour
-        self.colour1 = colour
-        self.colour1.a = 1.0
-        self.colour2 = colour1
-        self.forceUpdate()
-
-    #Grid division (the number of new lines that are created when zooming in).
-    def getDivision(self):
-        return division
-
-    def setDivision(self, division):
-        self.division = division
-        self.forceUpdate()
-
-    #//! Grid render layer (behind of in front of the objects).
-    def getRenderLayer(self):
-        return layer
-
-    def setRenderLayer(self, layer):
-        self.layer = layer
-
-        if self.layer == RL_BEHIND:
-            # Render just before the world geometry
-            self.pGrid.setRenderQueueGroup(og.RENDER_QUEUE_WORLD_GEOMETRY_1 - 1)
-        elif self.layer == RL_INFRONT:
-            # Render just before the overlays
-            self.pGrid.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-
-
-    def getPerspectiveSize(self):
-        return perspSize
-
-    def setPerspectiveSize(self, size):
-        self.perspSize = size
-        self.forceUpdate()
-
-#       //! Render scaling info? Defaults to true.
-#       //! @todo Implement this
-    def getRenderScale(self):
-        return renderScale
-
-    def setRenderScale(self, enabled = True):
-        self.renderScale = enabled
-        self.forceUpdate()
-
-#       //! Render mini axes? Defaults to true.
-#       //! @todo Implement this
-    def getRenderMiniAxes(self):
-        return renderMiniAxes
-
-    def setRenderMiniAxes(self, enabled = True):
-        self.renderMiniAxes = enabled
-        self.forceUpdate()
-
-    #// Enable / disable
-    def isEnabled(self):
-        return self.enabled
-
-    def enable(self):
-        self.enabled = True
-
-        if not self.pGrid.isAttached():
-            self.pNode.attachObject(self.pGrid)
-
-        self.forceUpdate()
-
-
-    def disable(self):
-        self.enabled = False
-
-        if self.pGrid.isAttached():
-            self.pNode.detachObject(self.pGrid)
-
-
-
-    def  toggle(self):
-        self.setEnabled(not self.enabled)
-
-    def setEnabled(self, enabled):
-        if enabled:
-            self.enable()
-        else:
-            self.disable()
-
-
-    def forceUpdate(self):
-        self.bForceUpdate = True
-
-    def preViewportUpdate(self, evt):
-       #TODO find out why evt.souce and self.viewport differ in their memory address
-       # if evt.source != self.viewport:
-           # return
-
-        self.pGrid.setVisible(True)
-
-        if self.enabled:
-            self.__update()
-
-    def postViewportUpdate(self, evt):
-       # if evt.source != self.viewport:
-           # return
-        self.pGrid.setVisible(False)
-
-    def __createGrid(self):
-        name = self.viewport.getTarget().getName() + &quot;::&quot;
-        name += str(self.viewport.getZOrder()) + &quot;::ViewportGrid&quot;
-
-        #// Create the manual object
-        self.pGrid = self.sceneManager.createManualObject(name)
-        self.pGrid.setDynamic(True)
-
-        #// Create the scene node (not attached yet)
-        self.pNode = self.sceneManager.getRootSceneNode().createChildSceneNode(name)
-        self.enabled = False
-
-        #// Make sure the material is created
-        #//! @todo Should we destroy the material somewhere?
-        matMgr = og.MaterialManager.getSingleton()
-        if not matMgr.resourceExists(self.sMatName):
-            pMaterial = matMgr.create(self.sMatName, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME)
-            pMaterial.setLightingEnabled(False)
-            pMaterial.setSceneBlending(og.SBT_TRANSPARENT_ALPHA)
-
-
-
-    def __destroyGrid(self):
-        self.sceneManager.destroyManualObject(self.pGrid)
-        self.pGrid = None
-
-        self.sceneManager.destroySceneNode(self.pNode.getName())
-        self.pNode = None
-
-
-    def __update(self):
-        if not self.enabled:
-            return
-
-        pCamera = self.viewport.getCamera()
-        if not pCamera:
-            return
-
-        # Check if an update is necessary
-        if not self.__checkUpdate() and not self.bForceUpdate:
-            return
-
-        if pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC:
-            self.__updateOrtho()
-        else:
-            self.__updatePersp()
-
-        self.bForceUpdate = False
-
-
-
-    def __updateOrtho(self):
-        # Screen dimensions
-        width = self.viewport.getActualWidth()
-        height = self.viewport.getActualHeight()
-
-        #Camera information
-        pCamera = pViewport.getCamera()
-        camPos = pCamera.getPosition()
-        camDir = pCamera.getDirection()
-        camUp = pCamera.getUp()
-        camRight = pCamera.getRight()
-
-        # Translation in grid space
-        dx = camPos.dotProduct(camRight)
-        dy = camPos.dotProduct(camUp)
-
-        # Frustum dimensions
-        # Note: Tan calculates the opposite side of a _right_ triangle given its angle, so we make sure it is one, and double the result
-        worldWidth = 2 * og.Math.Tan(pCamera.getFOVy() / 2) * pCamera.getAspectRatio() * pCamera.getNearClipDistance()
-        worldHeight = worldWidth / pCamera.getAspectRatio()
-        worldLeft = dx - worldWidth / 2
-        worldRight = dx + worldWidth / 2
-        worldBottom = dy - worldHeight / 2
-        worldTop = dy + worldHeight / 2
-
-        # Conversion values (note: same as working with the height values)
-        worldToScreen = width / worldWidth
-        screenToWorld = worldWidth / width
-
-        # TODO Treshold should be dependent on window width/height (min? max?) so there are no more then division full alpha-lines
-        treshold = 10 # Treshhold in pixels
-
-        # Calculate the spacing multiplier
-        mult = 0
-        exp = 0
-        temp = worldToScreen # 1 world unit
-        if worldToScreen &lt; treshold:
-            while temp &lt; treshold:
-                exp = exp +1
-                temp = temp * treshold # TODO maybe wrong
-
-            mult = og.Math.Pow(self.division, exp)
-        else:
-            while temp &gt; (self.division * treshold):
-                exp = exp +1
-                temp = temp / treshold # TODO maybe wrong
-
-            mult = og.Math.Pow(1.0 / self.division, exp)
-
-        # Interpolate alpha for (multiplied) spacing between treshold and division * treshold
-        self.colour2.a = worldToScreen * mult / (division * treshold - treshold)
-        if colour2.a &gt; 1.0:
-           self.colour2.a = 1.0
-
-        # Calculate the horizontal zero-axis color
-        camRightX = og.Math.Abs(camRight.x)
-        camRightY = og.Math.Abs(camRight.y)
-        camRightZ = og.Math.Abs(camRight.z)
-
-        if og.Math.RealEqual(camRightX, 1.0):
-            horAxisColor = og.ColourValue.Red
-        elif og.Math.RealEqual(camRightY, 1.0):
-            horAxisColor = og.ColourValue.Green
-        elif og.Math.RealEqual(camRightZ, 1.0):
-            horAxisColor = og.ColourValue.Blue
-        else:
-            horAxisColor = self.colour1
-
-        # Calculate the vertical zero-axis color
-        camUpX = og.Math.Abs(camUp.x)
-        camUpY = og.Math.Abs(camUp.y)
-        camUpZ = og.Math.Abs(camUp.z)
-
-        if og.Math.RealEqual(camUpX, 1.0):
-            horAxisColor = og.ColourValue.Red
-        elif og.Math.RealEqual(camUpY, 1.0):
-            horAxisColor = og.ColourValue.Green
-        elif og.Math.RealEqual(camUpZ, 1.0):
-            horAxisColor = og.ColourValue.Blue
-        else:
-            horAxisColor = self.colour1
-
-        # The number of lines
-        numLinesWidth = int((worldWidth / mult) + 1)
-        numLinesHeight = int((worldHeight / mult) + 1)
-
-        # Start creating or updating the grid
-        self.pGrid.estimateVertexCount(2 * numLinesWidth + 2 * numLinesHeight)
-        if created:
-            self.pGrid.beginUpdate(0)
-        else:
-            self.pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
-            self.created = True
-
-        # Vertical lines
-        startX = mult * int(worldLeft / mult)
-        x = startX
-        while x &lt;= worldRight:
-            # Get the right color for this line
-            if x == 0:
-                multX = x
-            elif x &lt; 0:
-                multX = int(x / mult - 0.5)
-            else:
-                multX = int(x / mult + 0.5)
-
-
-            if multX == 0:
-                colour = vertAxisColor
-            elif multX % (int(self.division)):
-                self.colour2
-            else:
-                self.colour1
-
-
-
-
-            # Add the line
-            self.pGrid.position(x, worldBottom, 0)
-            self.pGrid.colour(colour)
-            self.pGrid.position(x, worldTop, 0)
-            self.pGrid.colour(colour)
-
-            x += mult
-
-        # Horizontal lines
-        startY = mult * int(worldBottom / mult)
-        y = startY
-        while y &lt;= worldTop:
-            # Get the right color for this line
-            #multY = (y == 0) ? y : (y &lt; 0) ? int(y / mult - 0.5f) : int(y / mult + 0.5f)
-            if y == 0:
-                multY = y
-            elif y &lt; 0:
-                multY = int(y / mult - 0.5)
-            else:
-                multY = int(y / mult + 0.5)
-
-            #colour = (multY == 0) ? horAxisColor : (multY % int(division)) ? self.colour2 : self.colour1
-            if multY == 0:
-                colour = horAxisColor
-            elif multY % (int(self.division)):
-                self.colour2
-            else:
-                self.colour1
-
-            self.pGrid.position(worldLeft, y, 0)
-            self.pGrid.colour(colour)
-            self.pGrid.position(worldRight, y, 0)
-            self.pGrid.colour(colour)
-
-            y += mult
-
-        self.pGrid.end()
-
-        self.pNode.setOrientation(pCamera.getOrientation())
-
-
-    def __updatePersp(self):
-        #! @todo Calculate the spacing multiplier
-        mult = 1
-
-        #! @todo Interpolate alpha
-        self.colour2.a = 0.5
-        #if(colour2.a &gt; 1.0f) colour2.a = 1.0f
-
-        # Calculate the horizontal zero-axis color
-        horAxisColor = og.ColourValue.Red
-
-        # Calculate the vertical zero-axis color
-        vertAxisColor = og.ColourValue.Blue
-
-        # The number of lines
-        numLines = int(self.perspSize / mult) + 1
-
-        # Start creating or updating the grid
-        self.pGrid.estimateVertexCount(4 * numLines)
-        if self.created:
-            self.pGrid.beginUpdate(0)
-        else:
-            self.pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
-            self.created = True
-
-        # Vertical lines
-        start = mult * int(-self.perspSize / 2 / mult)
-        x = start
-        while x &lt;= (self.perspSize / 2):
-            # Get the right color for this line
-            #multX = (x == 0) ? x : (x &lt; 0) ? int(x / mult - 0.5f) : int(x / mult + 0.5f)
-            if x == 0:
-                multX = x
-            elif x &lt; 0:
-                multX = int(x / mult - 0.5)
-            else:
-                multX = int(x / mult +0.5)
-
-            #colour = (multX == 0) ? vertAxisColor : (multX % (int) self.division) ? self.colour2 : self.colour1
-            if multX == 0:
-                colour = vertAxisColor
-            elif multX % int(self.division):
-                colour = self.colour2
-            else:
-                colour = self.colour1
-
-            # Add the line
-            self.pGrid.position(x, 0, -self.perspSize / 2)
-            self.pGrid.colour(colour)
-            self.pGrid.position(x, 0, self.perspSize / 2)
-            self.pGrid.colour(colour)
-
-            x += mult
-
-        # Horizontal lines
-        y = start
-        while y &lt;= (self.perspSize / 2):
-            # Get the right color for this line
-            #multY = (y == 0) ? y : (y &lt; 0) ? int(y / mult - 0.5f) : int(y / mult + 0.5f)
-            if y == 0:
-                multY = y
-            elif y &lt; 0:
-                multY = int(y / mult - 0.5)
-            else:
-                multY = int(y / mult +0.5)
-
-            #colour = (multY == 0) ? horAxisColor : (multY % int(self.division)) ? self.colour2 : self.colour1
-            if multY == 0:
-                colour = horAxisColor
-            elif multY % int(self.division):
-                colour = self.colour2
-            else:
-                colour = self.colour1
-            # Add the line
-            self.pGrid.position(-self.perspSize / 2, 0, y)
-            self.pGrid.colour(colour)
-            self.pGrid.position(self.perspSize / 2, 0, y)
-            self.pGrid.colour(colour)
-
-            y += mult
-
-        self.pGrid.end()
-
-        # Normal orientation, grid in the X-Z plane
-        self.pNode.resetOrientation()
-
-
-    def __checkUpdate(self):
-        update = False
-
-        pCamera = self.viewport.getCamera()
-        if not pCamera:
-            return False
-
-        if pCamera is not self.prevCamera:
-            self.prevCamera = pCamera
-            update = True
-
-
-        ortho = (pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC)
-        if ortho is not self.prevOrtho:
-            self.prevOrtho = ortho
-            update = True
-
-            # Set correct material properties
-            pMaterial = og.MaterialManager.getSingleton().getByName(self.sMatName)
-
-            pMaterial.setDepthWriteEnabled(not ortho)
-            pMaterial.setDepthCheckEnabled(not ortho)
-
-        #return update || ortho ? checkUpdateOrtho() : checkUpdatePersp()
-        if update:
-            if ortho:
-                return self.__checkUpdateOrtho()
-            else:
-                return self.__checkUpdatePersp()
-
-        return False
-
-
-    def __checkUpdateOrtho(self):
-        update = False
-
-        pCamera = self.viewport.getCamera()
-        if not pCamera:
-            return False
-
-        if pCamera.getPosition() is not self.prevCamPos:
-            self.prevCamPos = pCamera.getPosition()
-            update = True
-
-        if pCamera.getNearClipDistance() is not self.prevNear:
-            self.prevNear = pCamera.getNearClipDistance()
-            update = True
-
-        if pCamera.getFOVy() is not self.prevOrtho:
-            self.prevOrtho = pCamera.getFOVy()
-            update = True
-
-        if pCamera.getAspectRatio() is not self.prevAspectRatio:
-            self.prevAspectRatio = pCamera.getAspectRatio()
-            update = True
-
-        return update
-
-
-    def __checkUpdatePersp(self):
-        return False
+#-----------------------------------------------------------------------------
+#Copyright (c) 2007 Jeroen Dierckx
+#Python Version by Stefan Stammberger
+#
+#This program is free software you can redistribute it and/or modify it under
+#the terms of the GNU Lesser General Public License as published by the Free Software
+#Foundation either version 2 of the License, or (at your option) any later
+#version.
+#
+#This program is distributed in the hope that it will be useful, but WITHOUT
+#ANY WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS
+#FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+#
+#You should have received a copy of the GNU Lesser General Public License along with
+#this program if not, write to the Free Software Foundation, Inc., 59 Temple
+#Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+#<A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
+#-----------------------------------------------------------------------------
+
+import ogre.renderer.OGRE as og
+
+RL_BEHIND = 1
+INFRONT = 2
+
+class ViewportGrid(og.RenderTargetListener):
+    def __init__(self, pSceneMgr, pViewport):
+        super(ViewportGrid, self).__init__()
+
+        self.sceneManager = pSceneMgr
+        self.viewport = pViewport
+        self.enabled = False
+        self.layer = None
+
+        self.prevCamera = None
+        self.prevOrtho = False
+        self.prevCamPos = None
+        self.prevNear = None
+        self.prevOrtho = None
+        self.prevAspectRatio = None
+        self.bForceUpdate = True
+
+        self.pGrid = None
+        self.created = False
+        self.pNode = None
+
+        self.colour1 = og.ColourValue(0.7, 0.7, 0.7)
+        self.colour2 = og.ColourValue(0.7, 0.7, 0.7)
+        self.division = 10
+        self.perspSize = 100
+        self.renderScale = True
+        self.renderMiniAxes = True
+
+        self.sMatName = &quot;ViewportGrid&quot;
+
+        self.__createGrid()
+        self.setRenderLayer(RL_BEHIND)
+
+        # Add this as a render target listener
+        self.viewport.getTarget().addListener(self)
+
+
+    def getColour(self):
+        return colour1
+
+    def setColour(self, colour):
+        # Force alpha = 1 for the primary colour
+        self.colour1 = colour
+        self.colour1.a = 1.0
+        self.colour2 = colour1
+        self.forceUpdate()
+
+    #Grid division (the number of new lines that are created when zooming in).
+    def getDivision(self):
+        return division
+
+    def setDivision(self, division):
+        self.division = division
+        self.forceUpdate()
+
+    #//! Grid render layer (behind of in front of the objects).
+    def getRenderLayer(self):
+        return layer
+
+    def setRenderLayer(self, layer):
+        self.layer = layer
+
+        if self.layer == RL_BEHIND:
+            # Render just before the world geometry
+            self.pGrid.setRenderQueueGroup(og.RENDER_QUEUE_WORLD_GEOMETRY_1 - 1)
+        elif self.layer == RL_INFRONT:
+            # Render just before the overlays
+            self.pGrid.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+
+
+    def getPerspectiveSize(self):
+        return perspSize
+
+    def setPerspectiveSize(self, size):
+        self.perspSize = size
+        self.forceUpdate()
+
+#       //! Render scaling info? Defaults to true.
+#       //! @todo Implement this
+    def getRenderScale(self):
+        return renderScale
+
+    def setRenderScale(self, enabled = True):
+        self.renderScale = enabled
+        self.forceUpdate()
+
+#       //! Render mini axes? Defaults to true.
+#       //! @todo Implement this
+    def getRenderMiniAxes(self):
+        return renderMiniAxes
+
+    def setRenderMiniAxes(self, enabled = True):
+        self.renderMiniAxes = enabled
+        self.forceUpdate()
+
+    #// Enable / disable
+    def isEnabled(self):
+        return self.enabled
+
+    def enable(self):
+        self.enabled = True
+
+        if not self.pGrid.isAttached():
+            self.pNode.attachObject(self.pGrid)
+
+        self.forceUpdate()
+
+
+    def disable(self):
+        self.enabled = False
+
+        if self.pGrid.isAttached():
+            self.pNode.detachObject(self.pGrid)
+
+
+
+    def  toggle(self):
+        self.setEnabled(not self.enabled)
+
+    def setEnabled(self, enabled):
+        if enabled:
+            self.enable()
+        else:
+            self.disable()
+
+
+    def forceUpdate(self):
+        self.bForceUpdate = True
+
+    def preViewportUpdate(self, evt):
+       #TODO find out why evt.souce and self.viewport differ in their memory address
+       # if evt.source != self.viewport:
+           # return
+
+        self.pGrid.setVisible(True)
+
+        if self.enabled:
+            self.__update()
+
+    def postViewportUpdate(self, evt):
+       # if evt.source != self.viewport:
+           # return
+        self.pGrid.setVisible(False)
+
+    def __createGrid(self):
+        name = self.viewport.getTarget().getName() + &quot;::&quot;
+        name += str(self.viewport.getZOrder()) + &quot;::ViewportGrid&quot;
+
+        #// Create the manual object
+        self.pGrid = self.sceneManager.createManualObject(name)
+        self.pGrid.setDynamic(True)
+
+        #// Create the scene node (not attached yet)
+        self.pNode = self.sceneManager.getRootSceneNode().createChildSceneNode(name)
+        self.enabled = False
+
+        #// Make sure the material is created
+        #//! @todo Should we destroy the material somewhere?
+        matMgr = og.MaterialManager.getSingleton()
+        if not matMgr.resourceExists(self.sMatName):
+            pMaterial = matMgr.create(self.sMatName, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME)
+            pMaterial.setLightingEnabled(False)
+            pMaterial.setSceneBlending(og.SBT_TRANSPARENT_ALPHA)
+
+
+
+    def __destroyGrid(self):
+        self.sceneManager.destroyManualObject(self.pGrid)
+        self.pGrid = None
+
+        self.sceneManager.destroySceneNode(self.pNode.getName())
+        self.pNode = None
+
+
+    def __update(self):
+        if not self.enabled:
+            return
+
+        pCamera = self.viewport.getCamera()
+        if not pCamera:
+            return
+
+        # Check if an update is necessary
+        if not self.__checkUpdate() and not self.bForceUpdate:
+            return
+
+        if pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC:
+            self.__updateOrtho()
+        else:
+            self.__updatePersp()
+
+        self.bForceUpdate = False
+
+
+
+    def __updateOrtho(self):
+        # Screen dimensions
+        width = self.viewport.getActualWidth()
+        height = self.viewport.getActualHeight()
+
+        #Camera information
+        pCamera = pViewport.getCamera()
+        camPos = pCamera.getPosition()
+        camDir = pCamera.getDirection()
+        camUp = pCamera.getUp()
+        camRight = pCamera.getRight()
+
+        # Translation in grid space
+        dx = camPos.dotProduct(camRight)
+        dy = camPos.dotProduct(camUp)
+
+        # Frustum dimensions
+        # Note: Tan calculates the opposite side of a _right_ triangle given its angle, so we make sure it is one, and double the result
+        worldWidth = 2 * og.Math.Tan(pCamera.getFOVy() / 2) * pCamera.getAspectRatio() * pCamera.getNearClipDistance()
+        worldHeight = worldWidth / pCamera.getAspectRatio()
+        worldLeft = dx - worldWidth / 2
+        worldRight = dx + worldWidth / 2
+        worldBottom = dy - worldHeight / 2
+        worldTop = dy + worldHeight / 2
+
+        # Conversion values (note: same as working with the height values)
+        worldToScreen = width / worldWidth
+        screenToWorld = worldWidth / width
+
+        # TODO Treshold should be dependent on window width/height (min? max?) so there are no more then division full alpha-lines
+        treshold = 10 # Treshhold in pixels
+
+        # Calculate the spacing multiplier
+        mult = 0
+        exp = 0
+        temp = worldToScreen # 1 world unit
+        if worldToScreen &lt; treshold:
+            while temp &lt; treshold:
+                exp = exp +1
+                temp = temp * treshold # TODO maybe wrong
+
+            mult = og.Math.Pow(self.division, exp)
+        else:
+            while temp &gt; (self.division * treshold):
+                exp = exp +1
+                temp = temp / treshold # TODO maybe wrong
+
+            mult = og.Math.Pow(1.0 / self.division, exp)
+
+        # Interpolate alpha for (multiplied) spacing between treshold and division * treshold
+        self.colour2.a = worldToScreen * mult / (division * treshold - treshold)
+        if colour2.a &gt; 1.0:
+           self.colour2.a = 1.0
+
+        # Calculate the horizontal zero-axis color
+        camRightX = og.Math.Abs(camRight.x)
+        camRightY = og.Math.Abs(camRight.y)
+        camRightZ = og.Math.Abs(camRight.z)
+
+        if og.Math.RealEqual(camRightX, 1.0):
+            horAxisColor = og.ColourValue().Red
+        elif og.Math.RealEqual(camRightY, 1.0):
+            horAxisColor = og.ColourValue().Green
+        elif og.Math.RealEqual(camRightZ, 1.0):
+            horAxisColor = og.ColourValue().Blue
+        else:
+            horAxisColor = self.colour1
+
+        # Calculate the vertical zero-axis color
+        camUpX = og.Math.Abs(camUp.x)
+        camUpY = og.Math.Abs(camUp.y)
+        camUpZ = og.Math.Abs(camUp.z)
+
+        if og.Math.RealEqual(camUpX, 1.0):
+            horAxisColor = og.ColourValue().Red
+        elif og.Math.RealEqual(camUpY, 1.0):
+            horAxisColor = og.ColourValue().Green
+        elif og.Math.RealEqual(camUpZ, 1.0):
+            horAxisColor = og.ColourValue().Blue
+        else:
+            horAxisColor = self.colour1
+
+        # The number of lines
+        numLinesWidth = int((worldWidth / mult) + 1)
+        numLinesHeight = int((worldHeight / mult) + 1)
+
+        # Start creating or updating the grid
+        self.pGrid.estimateVertexCount(2 * numLinesWidth + 2 * numLinesHeight)
+        if created:
+            self.pGrid.beginUpdate(0)
+        else:
+            self.pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
+            self.created = True
+
+        # Vertical lines
+        startX = mult * int(worldLeft / mult)
+        x = startX
+        while x &lt;= worldRight:
+            # Get the right color for this line
+            if x == 0:
+                multX = x
+            elif x &lt; 0:
+                multX = int(x / mult - 0.5)
+            else:
+                multX = int(x / mult + 0.5)
+
+
+            if multX == 0:
+                colour = vertAxisColor
+            elif multX % (int(self.division)):
+                self.colour2
+            else:
+                self.colour1
+
+
+
+
+            # Add the line
+            self.pGrid.position(x, worldBottom, 0)
+            self.pGrid.colour(colour)
+            self.pGrid.position(x, worldTop, 0)
+            self.pGrid.colour(colour)
+
+            x += mult
+
+        # Horizontal lines
+        startY = mult * int(worldBottom / mult)
+        y = startY
+        while y &lt;= worldTop:
+            # Get the right color for this line
+            #multY = (y == 0) ? y : (y &lt; 0) ? int(y / mult - 0.5f) : int(y / mult + 0.5f)
+            if y == 0:
+                multY = y
+            elif y &lt; 0:
+                multY = int(y / mult - 0.5)
+            else:
+                multY = int(y / mult + 0.5)
+
+            #colour = (multY == 0) ? horAxisColor : (multY % int(division)) ? self.colour2 : self.colour1
+            if multY == 0:
+                colour = horAxisColor
+            elif multY % (int(self.division)):
+                self.colour2
+            else:
+                self.colour1
+
+            self.pGrid.position(worldLeft, y, 0)
+            self.pGrid.colour(colour)
+            self.pGrid.position(worldRight, y, 0)
+            self.pGrid.colour(colour)
+
+            y += mult
+
+        self.pGrid.end()
+
+        self.pNode.setOrientation(pCamera.getOrientation())
+
+
+    def __updatePersp(self):
+        #! @todo Calculate the spacing multiplier
+        mult = 1
+
+        #! @todo Interpolate alpha
+        self.colour2.a = 0.5
+        #if(colour2.a &gt; 1.0f) colour2.a = 1.0f
+
+        # Calculate the horizontal zero-axis color
+        horAxisColor = og.ColourValue().Red
+
+        # Calculate the vertical zero-axis color
+        vertAxisColor = og.ColourValue().Blue
+
+        # The number of lines
+        numLines = int(self.perspSize / mult) + 1
+
+        # Start creating or updating the grid
+        self.pGrid.estimateVertexCount(4 * numLines)
+        if self.created:
+            self.pGrid.beginUpdate(0)
+        else:
+            self.pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
+            self.created = True
+
+        # Vertical lines
+        start = mult * int(-self.perspSize / 2 / mult)
+        x = start
+        while x &lt;= (self.perspSize / 2):
+            # Get the right color for this line
+            #multX = (x == 0) ? x : (x &lt; 0) ? int(x / mult - 0.5f) : int(x / mult + 0.5f)
+            if x == 0:
+                multX = x
+            elif x &lt; 0:
+                multX = int(x / mult - 0.5)
+            else:
+                multX = int(x / mult +0.5)
+
+            #colour = (multX == 0) ? vertAxisColor : (multX % (int) self.division) ? self.colour2 : self.colour1
+            if multX == 0:
+                colour = vertAxisColor
+            elif multX % int(self.division):
+                colour = self.colour2
+            else:
+                colour = self.colour1
+
+            # Add the line
+            self.pGrid.position(x, 0, -self.perspSize / 2)
+            self.pGrid.colour(colour)
+            self.pGrid.position(x, 0, self.perspSize / 2)
+            self.pGrid.colour(colour)
+
+            x += mult
+
+        # Horizontal lines
+        y = start
+        while y &lt;= (self.perspSize / 2):
+            # Get the right color for this line
+            #multY = (y == 0) ? y : (y &lt; 0) ? int(y / mult - 0.5f) : int(y / mult + 0.5f)
+            if y == 0:
+                multY = y
+            elif y &lt; 0:
+                multY = int(y / mult - 0.5)
+            else:
+                multY = int(y / mult +0.5)
+
+            #colour = (multY == 0) ? horAxisColor : (multY % int(self.division)) ? self.colour2 : self.colour1
+            if multY == 0:
+                colour = horAxisColor
+            elif multY % int(self.division):
+                colour = self.colour2
+            else:
+                colour = self.colour1
+            # Add the line
+            self.pGrid.position(-self.perspSize / 2, 0, y)
+            self.pGrid.colour(colour)
+            self.pGrid.position(self.perspSize / 2, 0, y)
+            self.pGrid.colour(colour)
+
+            y += mult
+
+        self.pGrid.end()
+
+        # Normal orientation, grid in the X-Z plane
+        self.pNode.resetOrientation()
+
+
+    def __checkUpdate(self):
+        update = False
+
+        pCamera = self.viewport.getCamera()
+        if not pCamera:
+            return False
+
+        if pCamera is not self.prevCamera:
+            self.prevCamera = pCamera
+            update = True
+
+
+        ortho = (pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC)
+        if ortho is not self.prevOrtho:
+            self.prevOrtho = ortho
+            update = True
+
+            # Set correct material properties
+            pMaterial = og.MaterialManager.getSingleton().getByName(self.sMatName)
+
+            pMaterial.setDepthWriteEnabled(not ortho)
+            pMaterial.setDepthCheckEnabled(not ortho)
+
+        #return update || ortho ? checkUpdateOrtho() : checkUpdatePersp()
+        if update:
+            if ortho:
+                return self.__checkUpdateOrtho()
+            else:
+                return self.__checkUpdatePersp()
+
+        return False
+
+
+    def __checkUpdateOrtho(self):
+        update = False
+
+        pCamera = self.viewport.getCamera()
+        if not pCamera:
+            return False
+
+        if pCamera.getPosition() is not self.prevCamPos:
+            self.prevCamPos = pCamera.getPosition()
+            update = True
+
+        if pCamera.getNearClipDistance() is not self.prevNear:
+            self.prevNear = pCamera.getNearClipDistance()
+            update = True
+
+        if pCamera.getFOVy() is not self.prevOrtho:
+            self.prevOrtho = pCamera.getFOVy()
+            update = True
+
+        if pCamera.getAspectRatio() is not self.prevAspectRatio:
+            self.prevAspectRatio = pCamera.getAspectRatio()
+            update = True
+
+        return update
+
+
+    def __checkUpdatePersp(self):
+        return False


Property changes on: rl/branches/newton20/editors/Lockenwickler/src/media
___________________________________________________________________
Name: svn:ignore
   + .Bpib
skelett.blend



Property changes on: rl/branches/newton20/editors/Lockenwickler/src/plugins
___________________________________________________________________
Name: svn:ignore
   + ParticleUniverse.dll
Plugin_BSPSceneManager.dll
Plugin_CgProgramManager.dll
Plugin_OctreeSceneManager.dll
Plugin_OctreeZone.dll
Plugin_ParticleFX.dll
Plugin_PCZSceneManager.dll
Plugin_TheoraVideoSystem.dll
RenderSystem_Direct3D9.dll
RenderSystem_GL.dll


Copied: rl/branches/newton20/editors/Lockenwickler/ui files/NewModuleWizard.ui (from rev 4722, rl/trunk/editors/Lockenwickler/ui files/NewModuleWizard.ui)

Modified: rl/branches/newton20/engine/core/CMakeLists.txt
===================================================================
--- rl/branches/newton20/engine/core/CMakeLists.txt	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/engine/core/CMakeLists.txt	2009-01-27 21:35:12 UTC (rev 4723)
@@ -7,7 +7,8 @@
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
 ${MESHMAGICK_INCLUDE_DIR}
-${RUBY_INCLUDE_PATH})
+${RUBY_INCLUDE_PATH}
+${FMODEX_INCLUDE_DIR})
 
 SET(RlCore_LIB_SRCS
 src/Actor.cpp
@@ -96,11 +97,11 @@
 
 ADD_LIBRARY(RlCore SHARED ${RlCore_LIB_SRCS})
 
-TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY})
+TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY} ${FMODEX_LIBRARY})
 
 SET_TARGET_PROPERTIES(RlCore PROPERTIES
 	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}
 	SOVERSION ${RL_MAJOR_VERSION}
 	DEFINE_SYMBOL RLCORE_EXPORTS)
 
-INSTALL(TARGETS RlCore LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
\ No newline at end of file
+INSTALL(TARGETS RlCore LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

Modified: rl/branches/newton20/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicsManager.h	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/engine/core/include/PhysicsManager.h	2009-01-27 21:35:12 UTC (rev 4723)
@@ -305,7 +305,7 @@
         OgreNewt::World* mWorld;
         //! the visualisation for physical behaviour (actually not the best)
         OgreNewt::Debugger* mNewtonDebugger;
-        //! debug mode: 0 no debugging, 1 show debug lines (freezed state), 2 show debug lines (update every frame)
+        //! debug mode: 0 no debugging, 1 show debug lines (freezed state), 2 show debug lines (update every frame), 3 show raycasts from one frame, 4 upda raycasts every frame
         int mDebugMode;
 
         //! factory for creating new collision primitives

Modified: rl/branches/newton20/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2009-01-27 21:35:12 UTC (rev 4723)
@@ -72,7 +72,7 @@
         : mEnabled(false),
         mNewtonDebugger(&amp;OgreNewt::Debugger::getSingleton()),
         mPhysicalThings(),
-        mDebugMode(false),
+        mDebugMode(0),
         mGravity(0, -9.81, 0),
         mTimeFactor(1.0f),
         mWorldAABB(Vector3(-100, -100, -100), Vector3(100, 100, 100)),
@@ -151,6 +151,12 @@
         //NewtonSetMinimumFrameRate(mWorld-&gt;getNewtonWorld(), 1./mMaxTimestep);
 
 
+        if( mDebugMode == 4 )
+        {
+            mNewtonDebugger-&gt;clearRaycastsRecorded();
+        }
+
+
         // Newton kann timesteps zwischen 1/20 und 1/600!
         mElapsed += elapsedTime * mTimeFactor;
         while( mElapsed &gt;= mMaxTimestep)
@@ -159,6 +165,7 @@
             // know if it's really neccessary
             GameEventManager::getSingleton().notifyNewtonWorldUpdate();
 
+
             mWorld-&gt;update(mMaxTimestep);
             mElapsed-=mMaxTimestep;
 #ifdef _DEBUG
@@ -202,6 +209,10 @@
         {
             mNewtonDebugger-&gt;showDebugInformation(mWorld);
         }
+        else if( mDebugMode == 3 )
+        {
+            mNewtonDebugger-&gt;stopRaycastRecording();
+        }
     }
 
 #ifdef _DEBUG
@@ -291,18 +302,29 @@
 
     void PhysicsManager::toggleDebugMode()
     {
-        mDebugMode = (mDebugMode+1)%3;
+        mNewtonDebugger-&gt;init(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager());
+        mDebugMode = (mDebugMode+1)%5;
         switch(mDebugMode)
         {
             case 0:
+                mNewtonDebugger-&gt;stopRaycastRecording();
+                mNewtonDebugger-&gt;clearRaycastsRecorded();
                 mNewtonDebugger-&gt;hideDebugInformation();
                 break;
             case 1:
-	        mNewtonDebugger-&gt;init(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager());
                 mNewtonDebugger-&gt;showDebugInformation(mWorld);
                 break;
+            case 2:
+                break;
+            case 3:
+                mNewtonDebugger-&gt;startRaycastRecording(true);
+                mNewtonDebugger-&gt;hideDebugInformation();
+                break;
+            case 4:
+                mNewtonDebugger-&gt;startRaycastRecording(true);
+                mNewtonDebugger-&gt;hideDebugInformation();
+                break;
             default:
-	        mNewtonDebugger-&gt;init(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager());
                 break;
         }
     }

Modified: rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp	2009-01-27 21:35:12 UTC (rev 4723)
@@ -109,6 +109,9 @@
 
     bool PhysicsMaterialRaycast::userCallback(Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID)
     {
+        mInfo.mBody = body;
+        mInfo.mDistance = distance;
+        mInfo.mNormal = normal;
         return true;
         /*
         if( body-&gt;getMaterialGroupID() == NULL )
@@ -158,9 +161,6 @@
 
                 if( found &amp;&amp; !mInvertMat || !found &amp;&amp; mInvertMat )
                 {
-                    mInfo.mBody = body;
-                    mInfo.mDistance = distance;
-                    mInfo.mNormal = normal;
                     mGetNearest = true;
                 }
             }
@@ -259,3 +259,4 @@
     }
 
 }
+

Modified: rl/branches/newton20/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/CreatureController.cpp	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/engine/rules/src/CreatureController.cpp	2009-01-27 21:35:12 UTC (rev 4723)
@@ -321,8 +321,8 @@
 		// find the distance to the floor:
                 // raycasts
                 PhysicsMaterialRaycast::MaterialVector materialVector;
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;)); // should we perhaps only use level here?
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;)); // should we perhaps only use level here?
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
 
                 Vector3 start = getCreature()-&gt;getPosition();
                 Vector3 end = start + Vector3::NEGATIVE_UNIT_Y*0.4;
@@ -330,7 +330,7 @@
                 RaycastInfo info = mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &amp;materialVector,
-                            start, end);
+                            start, end, false);
 
 		if( info.mBody == NULL )
 		{

Modified: rl/branches/newton20/engine/rules/src/StepRecognitionMovement.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/StepRecognitionMovement.cpp	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/engine/rules/src/StepRecognitionMovement.cpp	2009-01-27 21:35:12 UTC (rev 4723)
@@ -100,8 +100,8 @@
 
         // the materials that are triggered here
         PhysicsMaterialRaycast::MaterialVector materialVector;
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;)); // should we perhaps only use level here?
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;)); // should we perhaps only use level here?
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
 
 
 
@@ -115,7 +115,8 @@
                 PhysicsManager::getSingleton()._getNewtonWorld(),
                 &amp;materialVector,
                 start,
-                end);
+                end,
+                true);
         if(info.mBody)
         {
             mMoveToNextTarget = false;
@@ -151,7 +152,7 @@
                     mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &amp;materialVector,
-                            start, end);
+                            start, end, true);
 
                 // do we need to check bodies left and right of this ray? (step width?)
 

Modified: rl/branches/newton20/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2009-01-27 21:32:51 UTC (rev 4722)
+++ rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2009-01-27 21:35:12 UTC (rev 4723)
@@ -997,6 +997,8 @@
             materialVector.push_back( mCamBody-&gt;getMaterialGroupID() );
             OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
 
+OgreNewt::Debugger::getSingleton().init(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager());
+OgreNewt::Debugger::getSingleton().startRaycastRecording(true);
             ConvexcastInfo info = mConvexcast-&gt;execute(
                     world,
                     &amp;materialVector,
@@ -1005,6 +1007,7 @@
                     Quaternion::IDENTITY,
                     targetCamPos,
                     true);
+OgreNewt::Debugger::getSingleton().stopRaycastRecording();
 
             bool CollisionFound = false;
             if( info.mBody )


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001779.html">[Dsa-hl-svn] r4722 - in dependencies/OgreNewt_ngt: . inc src
</A></li>
	<LI>Next message: <A HREF="001781.html">[Dsa-hl-svn] r4724 - in dependencies/OgreNewt_ngt: inc src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1780">[ date ]</a>
              <a href="thread.html#1780">[ thread ]</a>
              <a href="subject.html#1780">[ subject ]</a>
              <a href="author.html#1780">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
