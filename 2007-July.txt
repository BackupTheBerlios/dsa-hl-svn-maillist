From blakharaz at mail.berlios.de  Mon Jul  2 16:34:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 2 Jul 2007 16:34:18 +0200
Subject: [Dsa-hl-svn] r3557 - rl/trunk/engine/ui/src
Message-ID: <200707021434.l62EYIvi024624@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-02 16:34:13 +0200 (Mon, 02 Jul 2007)
New Revision: 3557

Modified:
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
bug fixes (solved exception when dragging some object out and moving the mouse while its icon is still visible)


Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-06-27 22:06:24 UTC (rev 3556)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-02 14:34:13 UTC (rev 3557)
@@ -52,6 +52,7 @@
 
     InventoryWindow::~InventoryWindow()
     {
+		mWorldBackground->removeAllEvents();
     }
 
     void InventoryWindow::createSlotWindows(Inventory* inventory)
@@ -244,28 +245,35 @@
 			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
-			Vector2 targetPosWindow = dragcont->getPosition().asRelative(
-				getRoot()->getPixelSize());
+			Ogre::Vector3 targetPosWindow( 
+				dragcont->getPixelRect().d_left / getRoot()->getPixelSize().d_width,
+				dragcont->getPixelRect().d_top / getRoot()->getPixelSize().d_height,
+				-1);
 
 			if (dragcont->getItemParentContainer() != NULL)
 			{
 				dragcont->getItemParentContainer()->removeItem(item);
 				dragcont->getParent()->removeChildWindow(dragcont);
+				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont->getContentWindow());
 				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
-
 			}
 			else if (dragcont->getItemParentSlot() != "")
 			{
 				dragcont->getItemParentInventory()->dropItem(dragcont->getItemParentSlot());
 
 				dragcont->getParent()->removeChildWindow(dragcont);
+				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont->getContentWindow());
 				CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
 			}
+			else
+			{
+				destroyDragContainer(dragcont);
+			}
 
 			Ogre::Vector3 targetPosWorldSpace = 
 				mInventory->getOwner()->getPosition() 
 				+ mInventory->getOwner()->getOrientation()
-				* Ogre::Vector3(1-targetPosWindow.d_x, 1-targetPosWindow.d_y, -1); ///@todo check why coordinates are negative
+				* targetPosWindow; ///@todo check why coordinates are negative
 			item->placeIntoScene();
 			item->setPosition(targetPosWorldSpace);
 



From blakharaz at mail.berlios.de  Mon Jul  2 19:48:34 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 2 Jul 2007 19:48:34 +0200
Subject: [Dsa-hl-svn] r3558 - in rl/trunk/engine/ui: include src
Message-ID: <200707021748.l62HmYf2027373@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-02 19:48:24 +0200 (Mon, 02 Jul 2007)
New Revision: 3558

Modified:
   rl/trunk/engine/ui/include/WindowManager.h
   rl/trunk/engine/ui/src/AbstractWindow.cpp
   rl/trunk/engine/ui/src/WindowManager.cpp
Log:
Move window deletion operations (hide and destroy CEGUI window) into destructor of AbstractWindow since creation operation are in its c'tor


Modified: rl/trunk/engine/ui/include/WindowManager.h
===================================================================
--- rl/trunk/engine/ui/include/WindowManager.h	2007-07-02 14:34:13 UTC (rev 3557)
+++ rl/trunk/engine/ui/include/WindowManager.h	2007-07-02 17:48:24 UTC (rev 3558)
@@ -40,6 +40,7 @@
 		~WindowManager();
 
 		void registerWindow(AbstractWindow* window);
+		void unregisterWindow(AbstractWindow* window);
 		void destroyWindow(AbstractWindow* window);
 		void closeTopWindow();
 		bool handleMovedToFront(AbstractWindow* window);

Modified: rl/trunk/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-07-02 14:34:13 UTC (rev 3557)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-07-02 17:48:24 UTC (rev 3558)
@@ -76,6 +76,11 @@
 
 	AbstractWindow::~AbstractWindow()
 	{
+		mWindow->hide();
+		mWindow->removeAllEvents();
+		WindowManager::getSingleton().unregisterWindow(this);
+		getRoot()->removeChildWindow(mWindow);
+		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
 	}
 
 	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2007-07-02 14:34:13 UTC (rev 3557)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2007-07-02 17:48:24 UTC (rev 3558)
@@ -37,6 +37,14 @@
 
 	WindowManager::~WindowManager()
 	{
+		for(std::list<AbstractWindow*>::iterator it = mWindowList.begin(); it != mWindowList.end(); it++)
+		{
+			AbstractWindow* window = *it;
+			LOG_MESSAGE(Logger::UI, "Delete window "+window->getName());
+			//AbstractWindow::getRoot()->removeChildWindow(window->getWindow());
+			//CEGUI::WindowManager::getSingleton().destroyWindow(window->getWindow());
+		}
+		mWindowList.clear();
 	}
 	
 	void WindowManager::registerWindow(AbstractWindow* window)
@@ -44,15 +52,14 @@
 		mWindowList.push_back(window);
 	}
 
-	void WindowManager::destroyWindow(AbstractWindow* window)
+	void WindowManager::unregisterWindow(AbstractWindow* window)
 	{
 		mWindowList.remove(window);
-		window->getWindow()->hide();
-		AbstractWindow::getRoot()->removeChildWindow(window->getWindow());
-		CEGUI::WindowManager::getSingleton().destroyWindow(window->getWindow());
+	}
 
-		///@todo memory leak, aber destroyWindow macht sonst Probleme (heap corruption)
-		//delete window;		
+	void WindowManager::destroyWindow(AbstractWindow* window)
+	{
+		delete window;
 	}
 
 	void WindowManager::closeTopWindow()



From tanis at mail.berlios.de  Mon Jul  2 21:32:39 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 21:32:39 +0200
Subject: [Dsa-hl-svn] r3559 - in rl/trunk/engine: ai/include ai/src
	script/swig
Message-ID: <200707021932.l62JWdb7004294@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 21:31:44 +0200 (Mon, 02 Jul 2007)
New Revision: 3559

Modified:
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
Removed unused and depracated code from AI. Everything still works as before.

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-07-02 17:48:24 UTC (rev 3558)
+++ rl/trunk/engine/ai/include/Agent.h	2007-07-02 19:31:44 UTC (rev 3559)
@@ -26,7 +26,6 @@
 	class DialogCharacter;
 	class Creature;
 	class Actor;
-//	class PerceptionPool;
 
 	/** Represents a single entity that has got AI.
 	 * Instantiated objects are normally registered with AgentManager.
@@ -47,10 +46,6 @@
 		 */
 		Agent(Creature* character, SteeringVehicle* vehicle);
 
-		/** deprecated
-		 */
-		Agent(DialogCharacter* character);
-
 		/** explicit virtual destructor
 		 */
 		virtual ~Agent(void);
@@ -93,18 +88,6 @@
 		 */
         Creature* getControlledCreature() const;
 
-//		PerceptionPool* getPerceptionPool();
-
-		//! deprecated - for DialogBot
-		bool isDialogActive();
-
-		/** Function invoked by PhysicsManager whenever force/torque is to be
-		 * applied to the creature stored.
-		 * @param thing PhysicalThing that is responsible for the creature.
-		 */
-        // physcs handled by movingcreature
-		//virtual void OnApplyForceAndTorque(PhysicalThing* thing);
-
 	protected:
 		//! stores the type of the agent (Player, NPC, ...)
 		AgentManager::AgentType mType;
@@ -114,10 +97,6 @@
 		SteeringVehicle* mVehicle;
 		//! stores the creature whose AI is simulated
 		Creature* mCreature;
-
-		//! deprecated - for DialogBot
-		DialogCharacter* mDialogBot;
-//		PerceptionPool* mPerceptionPool;
 	};
 
 	inline AgentManager::AgentType Agent::getType()

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-07-02 17:48:24 UTC (rev 3558)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-07-02 19:31:44 UTC (rev 3559)
@@ -18,7 +18,6 @@
 
 #include <OgreSingleton.h>
 #include "AiPrerequisites.h"
-//#include "PhysicsController.h"
 #include "GameTask.h"
 #include "GameObjectStateListener.h"
 #include "FuzzyState.h"
@@ -49,7 +48,6 @@
 		: public Ogre::Singleton<AgentManager>,
 		  public GameTask,
           public GameObjectStateListener
-  	//	  public PhysicsController,
 		  
 	{
 	public:
@@ -80,10 +78,6 @@
 		 */
 		Agent* createAgent(AgentType type, Creature* character);
 
-		//! deprecated - should be removed in the long run.
-		//! Hint: it's deprecated
-		Agent* createAgent(DialogCharacter* character);
-
         //! Destroys an Agent and all its behaviours. (if any)
         void destroyAgent(Agent*);
 

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-07-02 17:48:24 UTC (rev 3558)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-07-02 19:31:44 UTC (rev 3559)
@@ -44,7 +44,6 @@
 	class Agent;
 	class PhysicalThing;
     class MovingCreature;
-//	class PerceptionPool;
 
 	/**
 	 * Realises steering for NPCs
@@ -136,12 +135,7 @@
 		 * @param minTimeToCollision minimum time to next collision
 		 */
 		bool needAvoidance(const float minTimeToCollision);
-		
-        /** Sets the animation of the actors mesh to a new keyframe.
-		 * @param name of the animation to set the mesh of the actor to.
-		 */
-		//void setAnimation(const CeGuiString& name);
-	
+			
 		/* TODO:
 		calcFollowPath
 		calcStayOnPath
@@ -153,13 +147,6 @@
 		Vector3 calcCohesion(AVGroup&);
 		*/
 				
-//		PerceptionPool* getPerceptionPool();
-
-		/** tests if a dialog is active with the creature
-		 * @returns true when dialog is active, otherwise false
-		 */
-		bool isDialogActive();
-
 		/** calculates euklidian distance between two vectors
 		 * @param vec1 first vector
 		 * @param vec2 second vector
@@ -256,75 +243,18 @@
 		 */
 		float setMaxSpeed (float ms);
 
-
 		/**
 		 * adjust the steering force passed to applySteeringForce.
          * allows a specific vehicle class to redefine this adjustment.
          * default is to disallow backward-facing steering at low speed.
 		 */
 		virtual OpenSteer::Vec3 adjustRawSteeringForce (const OpenSteer::Vec3& force);
-                                            // const float elapsedTime);
 
-		/**
-		 * apply a given steering force to our momentum,
-		 * adjusting our orientation to maintain velocity-alignment.
-		 */
-	//	void applySteeringForce(const OpenSteer::Vec3& force, const float elapsedTime);
-	//	void applySteeringForce(const Ogre::Vector3& force, const float elapsedTime);
-		
-		
-
-		/**
-		 * the default version: keep FORWARD parallel to velocity, change
-         * UP as little as possible.
-		 */
-  /*      virtual void regenerateLocalSpace (const OpenSteer::Vec3& newVelocity,
-                                           const float elapsedTime);
-		*/
-		
-		// get instantaneous curvature (since last update)
-/*		float curvature (void) {return _curvature;}
-
-		// get/reset smoothedCurvature, smoothedAcceleration and smoothedPosition
-		float smoothedCurvature (void) {return _smoothedCurvature;}
-		
-		float resetSmoothedCurvature (float value = 0)
-		{
-			_lastForward = OpenSteer::Vec3::zero;
-			_lastPosition = OpenSteer::Vec3::zero;
-			return _smoothedCurvature = _curvature = value;
-		}
-		
-		OpenSteer::Vec3 smoothedAcceleration (void) {return _smoothedAcceleration;}
-		
-		OpenSteer::Vec3 resetSmoothedAcceleration (const OpenSteer::Vec3& value = OpenSteer::Vec3::zero)
-		{
-			return _smoothedAcceleration = value;
-		}
-		
-		OpenSteer::Vec3 smoothedPosition (void) {return _smoothedPosition;}
-		
-		OpenSteer::Vec3 resetSmoothedPosition (const OpenSteer::Vec3& value = OpenSteer::Vec3::zero)
-		{
-			return _smoothedPosition = value;
-		}
-
-		// set a random "2D" heading: set local Up to global Y, then effectively
-		// rotate about it by a random angle (pick random forward, derive side).
-		void randomizeHeadingOnXZPlane (void)
-		{
-			setUp (OpenSteer::Vec3::up);
-			setForward (RandomUnitVectorOnXZPlane ());
-			setSide (localRotateForwardToSide (forward()));
-		}
-		*/
-
 		/** retrieve the controlled Actor
 		 * @returns Actor that is controlled by the SteeringVehicle
 		 */
         const Actor* getActor(void) const;
 
-
         // derived from debugvisualisable
         virtual DebugVisualisableFlag getFlag() const;
         virtual void updatePrimitive();
@@ -343,11 +273,6 @@
 		 */
 		const OpenSteer::ObstacleGroup& getObstacles() const;
 
-	//    float _mass;       // mass (defaults to unity so acceleration=force)
-    //   float _radius;     // size of bounding sphere, for obstacle avoidance, etc.
-    //    float _speed;      // speed along Forward direction.  Because local space
-                           // is velocity-aligned, velocity = Forward * Speed
-		
 		/** the maximum steering force this vehicle can apply.
          * steering force is clipped to this magnitude.
 		 */
@@ -357,24 +282,9 @@
 		 */
         float _maxSpeed;
 
-     /*   float _curvature;
-		float _smoothedCurvature;
-
-		OpenSteer::Vec3 _lastForward;
-        OpenSteer::Vec3 _lastPosition;
-        OpenSteer::Vec3 _smoothedPosition;
-        OpenSteer::Vec3 _smoothedAcceleration;
-	*/	
-		//! mass of the steering vehicle retrieved from Newton body (is this really necessary ?)
-		//Ogre::Real mMass;
-		//! radius of for the bounding sphere (use newton to get this from)
-		//Ogre::Real mRadius;
 		//! speed of the vehicle
 		Ogre::Real mSpeed;	
 
-		//! height of the vehicle ? (use newton to get this)
-        //float mHeight;
-
 		//! current force 
 		Ogre::Vector3 mCurrentForce;
 		//! current velocity
@@ -391,10 +301,6 @@
 
         MovingCreature* mMovingCreature;
 
-        // measure path curvature (1/turning-radius), maintain smoothed version
-      //  void measurePathCurvature (const float elapsedTime);
-
-
         // derived from debugvisualisable
         virtual void doCreatePrimitive();
 

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-07-02 17:48:24 UTC (rev 3558)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-07-02 19:31:44 UTC (rev 3559)
@@ -22,7 +22,6 @@
 #include "ScriptWrapper.h"
 #include "SteeringVehicle.h"
 #include "SteeringMachine.h"
-//#include "PerceptionPool.h"
 
 using namespace Ogre;
 using namespace OpenSteer;
@@ -30,54 +29,41 @@
 namespace rl {
 
 Agent::Agent(Creature* character)
-	: mType(AgentManager::AGENT_NONE), mBehaviour(NULL), mVehicle(NULL), mDialogBot(NULL), 
+	: mType(AgentManager::AGENT_NONE),
+      mBehaviour(NULL),
+      mVehicle(NULL),
 	  mCreature(character)
-//	  mPerceptionPool(new PerceptionPool())
 {
 	initialize();
 	ScriptWrapper::getSingleton().owned(character);
 }
 
 Agent::Agent(Creature* character, SteeringVehicle* vehicle)
-	: mType(AgentManager::AGENT_NONE), mBehaviour(NULL), mVehicle(vehicle), 
-	  mDialogBot(NULL), mCreature(character)
-//	  mPerceptionPool(new PerceptionPool())
+	: mType(AgentManager::AGENT_NONE),
+      mBehaviour(NULL),
+      mVehicle(vehicle), 
+	  mCreature(character)
 {
 	initialize();
 }
 
-Agent::Agent(DialogCharacter* character)
-	: mType(AgentManager::AGENT_STD_NPC), mBehaviour(NULL), mVehicle(NULL),
-	  mDialogBot(character),  mCreature(NULL)
-//	  mPerceptionPool(new PerceptionPool())
-{
-    mCreature = character->getNonPlayerCharacter();
-	initialize();
-	ScriptWrapper::getSingleton().owned(character);
-}
-
 Agent::~Agent(void)
 {
-    //if(mType == AgentManager::AGENT_STD_NPC)
-    //    mCreature->getActor()->getPhysicalThing()->setPhysicsController( NULL );
-
     delete mVehicle;
     delete mBehaviour;
 	if (mCreature != NULL)
 		ScriptWrapper::getSingleton().disowned(mCreature);
-	if (mDialogBot != NULL)
-		ScriptWrapper::getSingleton().disowned(mDialogBot);
-//	delete mPerceptionPool;
 }
 
 void Agent::initialize()
 {
-//  an agent needs a creature it refers to
+    //  an agent needs a creature it refers to
 	if(mCreature == NULL)
 	{
 		Throw(NullPointerException, "Agent has no creature");
 	}
-//  if there is no vehicle, create a standard vehicle
+
+    //  if there is no vehicle, create a standard vehicle
 	if(mVehicle == NULL)
 	{
 		mType = AgentManager::AGENT_STD_NPC;
@@ -89,17 +75,6 @@
 	mBehaviour = new SteeringMachine(NULL, mVehicle);
     LOG_MESSAGE(Logger::AI, 
         "created SteeringMachine for Agent");
-//  a perceptron should be the controller, and the perceptron calculates
-//  the steering force with the help of different steering behaviours
-/*
-// physic handled by movingcreature
-	if(mType == AgentManager::AGENT_STD_NPC)
-	{
-		mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
-        LOG_MESSAGE(Logger::AI, 
-			"added Agent to PhysicsManager as PhysicsController");
-	}
-*/
 }
 
 void Agent::addSteeringBehaviour(SteeringBehaviour* behaviour)
@@ -118,35 +93,13 @@
         "Cleared all SteeringBehaviours for Agent");
 }
 
-
 void Agent::update(const float elapsedTime)
 {
 	mBehaviour->update(elapsedTime);
-//  currentTime not needed yet, only elapsedTime
+    //  currentTime not needed yet, only elapsedTime
     mVehicle->update(0.0f, elapsedTime);
 }
 
-
-/*
-// physics handled in movingcreature
-void Agent::OnApplyForceAndTorque(PhysicalThing* thing)
-{
-	OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-	Real elapsedTime = world->getTimeStep();
-	update(elapsedTime);
-}
-*/
-
-bool Agent::isDialogActive()
-{
-	if(mDialogBot == NULL)
-	{
-		// Throw(NullPointerException, "No Dialogbot found");
-        return false;
-	}
-	return mDialogBot->isActive();
-}
-
 Creature* Agent::getControlledCreature() const
 {
     return mCreature;

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-07-02 17:48:24 UTC (rev 3558)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-07-02 19:31:44 UTC (rev 3559)
@@ -67,13 +67,6 @@
     return agent;
 }
 
-Agent* AgentManager::createAgent(DialogCharacter* character)
-{
-	Agent* agent = new Agent(character);
-	addAgent(agent);
-	return agent;
-}
-
 void AgentManager::destroyAgent(Agent* agent)
 {
     AgentList::iterator it = std::find(mAgents.begin(), mAgents.end(), agent);
@@ -96,12 +89,6 @@
 {
 	return mAllNeighbors;
 }
-/*
-void AgentManager::OnApplyForceAndTorque(PhysicalThing* thing)
-{
-    //	steerToAvoidNeighbors (10.0, const AVGroup& others);
-}
-*/
 
 void AgentManager::run( Ogre::Real elapsedTime ) 
 {

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-02 17:48:24 UTC (rev 3558)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-02 19:31:44 UTC (rev 3559)
@@ -31,20 +31,16 @@
 SteeringVehicle::SteeringVehicle(Agent* parent, Creature* character)
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
-      //mMass(),
-      //mRadius(),
       mSpeed(1.0f),
 	  mCurrentForce(Vector3::ZERO), 
 	  mCurrentVelocity(Vector3::ZERO),
 	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
-      //mYaw(115),
 	  mParent(parent),
 	  mCreature(character),
       mMovingCreature(NULL),
       mDebugSteer(Vector3::ZERO),
       mDebugWander(Vector3::ZERO),
       mDebugAvoidObstacles(Vector3::ZERO)
-      //mHeight(0)
 {
 	initialize();
 
@@ -78,48 +74,23 @@
 	Vector3 pos = mCreature->getActor()->getPosition();
 	setPosition(Vec3(pos.x, pos.y, pos.z));
 	Vector3 src = mCreature->getActor()->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
-	//Quaternion orientation = mCreature->getActor()->getOrientation();
-	//mYaw = orientation.getYaw();
 
-//  regenerate local space (by default: align vehicle's forward axis with
-//  new velocity, but this behavior may be overridden by derived classes.)
+    // regenerate local space (by default: align vehicle's forward axis with
+    // new velocity, but this behavior may be overridden by derived classes.)
 	regenerateOrthonormalBasisUF ( Vec3(src.x, src.y, src.z) );
 }
 
 void SteeringVehicle::initialize(void)
 {
-//  reset LocalSpace state
+    // reset LocalSpace state
 	resetLocalSpace();
 	
-//	mCreature->getActor()->_getSceneNode()->setOrientation(Ogre::Quaternion::IDENTITY);
-	//Vector3 inertia;
-	//mCreature->getActor()->getPhysicalThing()->_getBody()->getMassMatrix(mMass, inertia);
-
-//	mSpeed = (float)mCreature->getWert(Creature::WERT_GS) / (float)Date::ONE_KAMPFRUNDE * 1000.0f;
-
-//  reset SteerLibraryMixin state
+    // reset SteerLibraryMixin state
 	SimpleVehicle_2::reset ();
 
-//	setRadius (0.5f);     // size of bounding sphere
-
 	setMaxForce (1.0f);   // steering force is clipped to this magnitude
 	setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
-
-//  reset bookkeeping to do running averages of these quanities
-//	resetSmoothedPosition ();
-//	resetSmoothedCurvature ();
-//	resetSmoothedAcceleration ();
 }
-/*
-PerceptionPool* SteeringVehicle::getPerceptionPool()
-{
-  return mParent->getPerceptionPool();
-}
-*/
-bool SteeringVehicle::isDialogActive()
-{
-	return mParent->isDialogActive();
-}
 
 void SteeringVehicle::addForce(const Ogre::Vector3& force)
 {
@@ -128,8 +99,8 @@
 
 void SteeringVehicle::update(const float currentTime, const float elapsedTime)
 {
-// from PlayerVehicle
-// since physics schould by handled by movingcreature
+    // from PlayerVehicle
+    // since physics schould by handled by movingcreature
 
 	OgreNewt::Body* body = mCreature->getActor()->getPhysicalThing()->_getBody();
 
@@ -153,11 +124,11 @@
     Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
     regenerateOrthonormalBasisUF (Vec3(newUnitForward.x,newUnitForward.y,newUnitForward.z));
 
-// end of inserting from playervehicle
+    // end of inserting from playervehicle
 
 
 
-// only process if mMovingCreature not NULL
+    // only process if mMovingCreature not NULL
     if( mMovingCreature == NULL )
     {
         mCurrentForce = Vector3::ZERO;
@@ -169,9 +140,9 @@
 
      mDebugSteer = mCurrentForce;
 
-// @todo remove this
-if( mCreature->getAu() <= 6 )
-    mCreature->modifyAu(20,true);
+    // @todo remove this
+    if( mCreature->getAu() <= 6 )
+        mCreature->modifyAu(20,true);
 
 
     AbstractMovement *mov_drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
@@ -191,8 +162,6 @@
         yaw = max_drehen;
     if( yaw < Radian(0) && yaw < -max_drehen )
         yaw = -max_drehen;
-    // old version was -Degree(mCurrentForce.x * 60 * elapsedTime);
-    // should this really depend from the timestep!?!
 
     Ogre::Vector3 direction(Ogre::Vector3::ZERO);
     Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
@@ -278,22 +247,6 @@
 	return true;
 }
 
-/*
-// already in moveingcreature
-void SteeringVehicle::setAnimation(const CeGuiString& name)
-{
-	MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
-	mesh->stopAllAnimations();
-    try
-    {
-	    mesh->startAnimation(name.c_str());
-	    mCreature->getActor()->getPhysicalThing()->fitToPose(name.c_str());
-    }
-    catch( ... ) { }
-}
-*/
-
-
 AVGroup SteeringVehicle::getNeighbors() const
 {
 	AVGroup group;
@@ -425,28 +378,7 @@
         return limitMaxDeviationAngle (force, cosine, forward());
     }
 }
-/*
-void SteeringVehicle::measurePathCurvature (const float elapsedTime)
-{
-    if (elapsedTime > 0)
-    {
-        const Vec3 dP = _lastPosition - position ();
-        const Vec3 dF = (_lastForward - forward ()) / dP.length ();
-        const Vec3 lateral = dF.perpendicularComponent (forward ());
-        const float sign = (lateral.dot (side ()) < 0) ? 1.0f : -1.0f;
-        _curvature = lateral.length() * sign;
-        blendIntoAccumulator (elapsedTime * 4.0f,
-                              _curvature,
-                              _smoothedCurvature);
-        _lastForward = forward ();
-        _lastPosition = position ();
-    }
-}
-*/
 
-
-
-
 // methods from debugvisualisable
 DebugVisualisableFlag SteeringVehicle::getFlag() const
 {

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-07-02 17:48:24 UTC (rev 3558)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-07-02 19:31:44 UTC (rev 3559)
@@ -47,8 +47,6 @@
 		
 		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
 		
-		bool isDialogActive();
-		
 		float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2);
 		
 		Ogre::Vector3 getPosition();
@@ -86,7 +84,6 @@
 		virtual ~Agent();
 		void addSteeringBehaviour(rl::SteeringBehaviour* behaviour);
 		void clearSteeringBehaviours();
-		bool isDialogActive();
 	};
 	class AiSubsystem 
 	{
@@ -117,7 +114,6 @@
 		
 		static AgentManager& getSingleton(void);
 		rl::Agent* createAgent(rl::AgentManager::AgentType type, rl::Creature* character);
-		rl::Agent* createAgent(rl::DialogCharacter* character);
 		
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};



From tanis at mail.berlios.de  Mon Jul  2 21:41:29 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 21:41:29 +0200
Subject: [Dsa-hl-svn] r3560 - in rl/trunk/engine: script/swig ui/include
	ui/src
Message-ID: <200707021941.l62JfTmh004967@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 21:41:06 +0200 (Mon, 02 Jul 2007)
New Revision: 3560

Modified:
   rl/trunk/engine/script/swig/RlUi.head.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/include/CharacterController.h
   rl/trunk/engine/ui/include/CombatCharacterController.h
   rl/trunk/engine/ui/include/CutsceneCharacterController.h
   rl/trunk/engine/ui/include/DialogCharacterController.h
   rl/trunk/engine/ui/include/FreeFlightCharacterController.h
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/include/MovementCharacterController.h
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/src/CharacterController.cpp
   rl/trunk/engine/ui/src/CombatCharacterController.cpp
   rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
Attention: inconsistent state for a few hours. Partial commit so that I can remotely rename files..
Do not update now.

Modified: rl/trunk/engine/script/swig/RlUi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.head.swig	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/script/swig/RlUi.head.swig	2007-07-02 19:41:06 UTC (rev 3560)
@@ -18,7 +18,7 @@
 //----------- Includes - UI -----------
 #include "FixRubyHeaders.h"
 
-#include "CharacterController.h"
+#include "ControlState.h"
 #include "CommandMapper.h"
 #include "CutsceneCharacterController.h"
 #include "GameLoggerWindow.h"

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 19:41:06 UTC (rev 3560)
@@ -16,17 +16,17 @@
 
 namespace rl {
 
-%apply SWIGTYPE *DYNAMIC { rl::CharacterController * };
+%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
 
-%feature("director") CharacterController;
-class CharacterController
+%feature("director") ControlState;
+class ControlState
 {
 private:
-    CharacterController(rl::Actor* camera, rl::Actor* character);
+    ControlState(rl::Actor* camera, rl::Actor* character);
 public:
 };
 
-class CutsceneCharacterController : public CharacterController
+class CutsceneCharacterController : public ControlState
 {
 private:
        CutsceneCharacterController(rl::Actor* camera);
@@ -137,8 +137,8 @@
 %{
 static swig_type_info *CharacterController_dynamic_cast(void **ptr)
 {
-    rl::CharacterController **ppCharacterController =
-        reinterpret_cast<rl::CharacterController**>(ptr);
+    rl::ControlState **ppCharacterController =
+        reinterpret_cast<rl::ControlState**>(ptr);
 
     rl::CutsceneCharacterController *pCutSceneCC =
         dynamic_cast<rl::CutsceneCharacterController*>(*ppCharacterController);

Modified: rl/trunk/engine/ui/include/CharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CharacterController.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/CharacterController.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -35,7 +35,7 @@
     /**
      * This class handles character control via user input.
      */
-    class _RlUiExport CharacterController : public OIS::KeyListener, public OIS::MouseListener
+    class _RlUiExport ControlState : public OIS::KeyListener, public OIS::MouseListener
     {
 	public:
 
@@ -43,9 +43,9 @@
          *  @throw NullPointerException if camera or character is NULL.
          *  @throw InvalidArgumentException if character is not placed in the scene.
          */
-        CharacterController(CommandMapper* commandMapper, Actor* camera, Person* character,
+        ControlState(CommandMapper* commandMapper, Actor* camera, Person* character,
             ControlStateType type);
-		virtual ~CharacterController()= 0;
+		virtual ~ControlState()= 0;
 
         virtual void pause() = 0;
         virtual void resume() = 0;

Modified: rl/trunk/engine/ui/include/CombatCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CombatCharacterController.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/CombatCharacterController.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -19,7 +19,7 @@
 
 #include "UiPrerequisites.h"
 
-#include "CharacterController.h"
+#include "ControlState.h"
 #include "Selector.h"
 
 #include <OgreRectangle.h>
@@ -31,7 +31,7 @@
     class CombatManager;
     class CombatWindow;
 
-	class _RlUiExport CombatCharacterController : public CharacterController
+	class _RlUiExport CombatCharacterController : public ControlState
 	{
 	public:
 		/**

Modified: rl/trunk/engine/ui/include/CutsceneCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -18,13 +18,13 @@
 #define __CutsceneCharacterController_H__
 
 #include "UiPrerequisites.h"
-#include "CharacterController.h"
+#include "ControlState.h"
 
 namespace rl {
 
 	class Actor;
 
-	class _RlUiExport CutsceneCharacterController : public CharacterController
+	class _RlUiExport CutsceneCharacterController : public ControlState
 	{
 	public:
 		/**

Modified: rl/trunk/engine/ui/include/DialogCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/DialogCharacterController.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/DialogCharacterController.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -18,7 +18,7 @@
 #define __DialogCharacterController_H__
 
 #include "UiPrerequisites.h"
-#include "CharacterController.h"
+#include "ControlState.h"
 
 #include <OgreCamera.h>
 
@@ -33,7 +33,7 @@
 	/** Diese Klasse 
 	  *  
 	  */
-	class _RlUiExport DialogCharacterController : public CharacterController
+	class _RlUiExport DialogCharacterController : public ControlState
 	{
 	public:
         enum DialogMode

Modified: rl/trunk/engine/ui/include/FreeFlightCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -18,7 +18,7 @@
 #define __FreeFlightCharacterController_H__
 
 #include "UiPrerequisites.h"
-#include "CharacterController.h"
+#include "ControlState.h"
 #include "PhysicsController.h"
 #include "PhysicsGenericContactCallback.h"
 #include <OgreNewt.h>
@@ -29,7 +29,7 @@
 	* This class provides a no-clip free fly controller.
 	*/
 	class _RlUiExport FreeFlightCharacterController : 
-        public CharacterController,
+        public ControlState,
         public PhysicsController,
         public PhysicsGenericContactCallback
 	{

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/InputManager.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -34,7 +34,7 @@
 
     class AbstractWindow;
     class GameObject;
-    class CharacterController;
+    class ControlState;
     class CommandMapper;
 
     class _RlUiExport InputManager
@@ -78,7 +78,7 @@
         /// Remove all control states.
         void clearControlStates();
 
-        CharacterController* getCharacterController() const;
+        ControlState* getCharacterController() const;
 
         int getModifierCode() const;
         const CEGUI::utf8& getKeyChar(int keycode, int modifiers) const;
@@ -108,8 +108,8 @@
         typedef std::map<int, CeGuiString> KeyCommandMap;
         KeyCommandMap mKeyRubyCommand;
 
-        typedef std::stack<CharacterController*> ControlStateStack;
-        typedef std::vector<CharacterController*> ControlStateVector;
+        typedef std::stack<ControlState*> ControlStateStack;
+        typedef std::vector<ControlState*> ControlStateVector;
         ControlStateStack mControlStates;
         /// Stored for delay deletion, since else a state can be deleted while
         /// still in its run() function.

Modified: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -22,7 +22,7 @@
 #include "MovingCreature.h"
 #include "PhysicsController.h"
 #include "PhysicsGenericContactCallback.h"
-#include "CharacterController.h"
+#include "ControlState.h"
 #include "DebugVisualisable.h"
 #include "Selector.h"
 
@@ -39,7 +39,7 @@
      * This class handles character control via user input.
      */
     class _RlUiExport MovementCharacterController
-	  : public CharacterController,
+	  : public ControlState,
 		public PhysicsController,
         public PhysicsGenericContactCallback,
         public DebugVisualisable

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2007-07-02 19:41:06 UTC (rev 3560)
@@ -22,7 +22,7 @@
 
 #include <OgreSingleton.h>
 
-#include "CharacterController.h"
+#include "ControlState.h"
 
 // Gar nicht sch?n, aber ansonsten gibt es unn?tige Abh?ngigkeiten,
 // wenn man die Header hier inkludiert.

Modified: rl/trunk/engine/ui/src/CharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterController.cpp	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/src/CharacterController.cpp	2007-07-02 19:41:06 UTC (rev 3560)
@@ -13,7 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
-#include "CharacterController.h"
+#include "ControlState.h"
 
 #include <OgreSceneManager.h>
 
@@ -36,7 +36,7 @@
 
 namespace rl {
 
-	CharacterController::CharacterController(CommandMapper* commandMapper,
+	ControlState::ControlState(CommandMapper* commandMapper,
         Actor* camera, Person* character, ControlStateType type)
 		: mCharacter(character),
         mCameraActor(camera),
@@ -100,12 +100,12 @@
             PhysicsManager::getSingleton().getMaterialID("character"))->setDefaultCollidable(0);
 	}
     
-    CharacterController::~CharacterController()
+    ControlState::~ControlState()
     {
     
     }
 
-	bool CharacterController::startAction(const CeGuiString& actionName, Creature* character)
+	bool ControlState::startAction(const CeGuiString& actionName, Creature* character)
 	{
 		if (actionName.length() == 0)
 		{
@@ -124,7 +124,7 @@
 		return true;
 	}
 
-    bool CharacterController::mousePressed(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
+    bool ControlState::mousePressed(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
     {
         if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
         {
@@ -138,7 +138,7 @@
         }
     }
 
-    bool CharacterController::mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
+    bool ControlState::mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
     {
         if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
         {
@@ -151,7 +151,7 @@
         }
     }
 
-    bool CharacterController::mouseMoved(const OIS::MouseEvent& evt)
+    bool ControlState::mouseMoved(const OIS::MouseEvent& evt)
     {
         if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
         {
@@ -165,7 +165,7 @@
         }
     }
 
-    bool CharacterController::keyPressed(const OIS::KeyEvent& evt)
+    bool ControlState::keyPressed(const OIS::KeyEvent& evt)
     {
         InputManager* im = InputManager::getSingletonPtr();
 
@@ -181,7 +181,7 @@
         }
     }
 
-    bool CharacterController::keyReleased(const OIS::KeyEvent& evt)
+    bool ControlState::keyReleased(const OIS::KeyEvent& evt)
     {
         InputManager* im = InputManager::getSingletonPtr();
 
@@ -207,12 +207,12 @@
         }
     }
 
-    bool CharacterController::isCeguiActive() const
+    bool ControlState::isCeguiActive() const
     {
         return WindowManager::getSingleton().getWindowInputMask() != 0;
     }
 
-    bool CharacterController::sendKeyToCeGui(const OIS::KeyEvent& evt) const
+    bool ControlState::sendKeyToCeGui(const OIS::KeyEvent& evt) const
     {
         InputManager* im = InputManager::getSingletonPtr();
 

Modified: rl/trunk/engine/ui/src/CombatCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-07-02 19:41:06 UTC (rev 3560)
@@ -37,7 +37,7 @@
 namespace rl {
     CombatCharacterController::CombatCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-        : CharacterController(cmdMapper, camera, character, CST_COMBAT),
+        : ControlState(cmdMapper, camera, character, CST_COMBAT),
           mCombatManager(CombatManager::getSingletonPtr()),
           mCombat(NULL),
           mCombatWindow(NULL),

Modified: rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-07-02 19:41:06 UTC (rev 3560)
@@ -27,7 +27,7 @@
 namespace rl {
 
 	CutsceneCharacterController::CutsceneCharacterController(CommandMapper* cmdMapper,
-        Actor* camera) : CharacterController(cmdMapper, camera, NULL, CST_CUTSCENE)
+        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE)
 	{
 	}
 

Modified: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-07-02 19:41:06 UTC (rev 3560)
@@ -49,7 +49,7 @@
 
     DialogCharacterController::DialogCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-        : CharacterController(cmdMapper, camera, character, CST_DIALOG),
+        : ControlState(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
         mCurrFadeTextTime(0),

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-07-02 19:41:06 UTC (rev 3560)
@@ -35,7 +35,7 @@
 
 	FreeFlightCharacterController::FreeFlightCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-		: CharacterController(cmdMapper, camera, character, CST_FREEFLIGHT),
+		: ControlState(cmdMapper, camera, character, CST_FREEFLIGHT),
 		mMovementSpeed(5.0f),
 		mSpeedRange(0.03f, 90.0f),
 		mSpeedIncrement(0.02f),
@@ -259,7 +259,7 @@
             }
             else 
             {
-                return CharacterController::keyReleased(evt);
+                return ControlState::keyReleased(evt);
             }
         }
 	}

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-07-02 19:41:06 UTC (rev 3560)
@@ -33,7 +33,7 @@
 #include "Actor.h"
 #include "ActorManager.h"
 #include "AbstractWindow.h"
-#include "CharacterController.h"
+#include "ControlState.h"
 #include "CombatCharacterController.h"
 #include "CommandMapper.h"
 #include "ConfigurationManager.h"
@@ -404,7 +404,7 @@
         Actor* camera = ActorManager::getSingleton().getActor("DefaultCamera");
         Person* character = UiSubsystem::getSingleton().getActiveCharacter();
 
-        CharacterController* controller = NULL;
+        ControlState* controller = NULL;
         switch (controlStateType)
         {
         case CST_CUTSCENE:
@@ -440,14 +440,14 @@
 
     void InputManager::popControlState()
     {
-        CharacterController* controller = mControlStates.top();
+        ControlState* controller = mControlStates.top();
         mControlStates.pop();
         controller->pause();
         mFinishedControlStates.push_back(controller);
 
         if (!mControlStates.empty())
         {
-            CharacterController* newController = mControlStates.top();
+            ControlState* newController = mControlStates.top();
             mKeyboard->setEventCallback(newController);
             mMouse->setEventCallback(newController);
             newController->resume();
@@ -467,7 +467,7 @@
         }
     }
 
-    CharacterController* InputManager::getCharacterController() const
+    ControlState* InputManager::getCharacterController() const
     {
         if (!mControlStates.empty())
         {

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 19:31:44 UTC (rev 3559)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 19:41:06 UTC (rev 3560)
@@ -67,7 +67,7 @@
 
     MovementCharacterController::MovementCharacterController(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
-        : CharacterController(cmdMapper, camera, character, CST_MOVEMENT),
+        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
         mMovingCreature(NULL),
         mCharacterState(),
         mDesiredDistance(2.00),
@@ -1148,7 +1148,7 @@
     //------------------------------------------------------------------------
     bool MovementCharacterController::keyPressed(const OIS::KeyEvent& evt)
     {
-        if (CharacterController::keyPressed(evt)) return true;
+        if (ControlState::keyPressed(evt)) return true;
 
         int movement = mCommandMapper->getMovement(evt.key);
 
@@ -1171,7 +1171,7 @@
         // CEGUI is handled by base class, so hand it down if necessary.
         if (sendKeyToCeGui(evt))
         {
-            return CharacterController::keyReleased(evt);
+            return ControlState::keyReleased(evt);
         }
 
         int movement = mCommandMapper->getMovement(evt.key);
@@ -1204,7 +1204,7 @@
             else
             {
                 // Nothing we handle here, see if base class can make something of this input.
-                return CharacterController::keyReleased(evt);
+                return ControlState::keyReleased(evt);
             }
         }
 
@@ -1224,7 +1224,7 @@
         }
         else
         {
-            return CharacterController::mouseReleased(evt, id);
+            return ControlState::mouseReleased(evt, id);
         }
     }
 



From tanis at mail.berlios.de  Mon Jul  2 21:44:42 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 21:44:42 +0200
Subject: [Dsa-hl-svn] r3561 - rl/trunk/engine/ui/include
Message-ID: <200707021944.l62JigbY005217@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 21:44:37 +0200 (Mon, 02 Jul 2007)
New Revision: 3561

Added:
   rl/trunk/engine/ui/include/ControllState.h
Removed:
   rl/trunk/engine/ui/include/CharacterController.h
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/include/CharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CharacterController.h	2007-07-02 19:41:06 UTC (rev 3560)
+++ rl/trunk/engine/ui/include/CharacterController.h	2007-07-02 19:44:37 UTC (rev 3561)
@@ -1,86 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-
-#ifndef __CharacterController_H__
-#define __CharacterController_H__
-
-#include "UiPrerequisites.h"
-#include "GameTask.h"
-
-#include <OgreNewt.h>
-
-#include <OISMouse.h>
-#include <OISKeyboard.h>
-
-namespace rl {
-
-    class Actor;
-	class CommandMapper;
-	class Creature;
-    class Person;
-
-    /**
-     * This class handles character control via user input.
-     */
-    class _RlUiExport ControlState : public OIS::KeyListener, public OIS::MouseListener
-    {
-	public:
-
-        /**
-         *  @throw NullPointerException if camera or character is NULL.
-         *  @throw InvalidArgumentException if character is not placed in the scene.
-         */
-        ControlState(CommandMapper* commandMapper, Actor* camera, Person* character,
-            ControlStateType type);
-		virtual ~ControlState()= 0;
-
-        virtual void pause() = 0;
-        virtual void resume() = 0;
-
-        virtual void run(Ogre::Real elapsedTime) = 0;
-
-        virtual bool mousePressed(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
-        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
-        virtual bool mouseMoved(const OIS::MouseEvent& evt);
-        virtual bool keyPressed(const OIS::KeyEvent& evt);
-        virtual bool keyReleased(const OIS::KeyEvent& evt);
-
-	protected:
-		static bool startAction(const CeGuiString& actionName, Creature* character = NULL);
-
-        /// Returns true, if there is at least one window open,
-        /// that requires keyboard and/or mouse input. 
-        bool isCeguiActive() const;
-
-        /// Returns true, if the key event should be injected into CEGUI
-        /// This is the case, if an open window requests key input and it is
-        /// an input or navigation key.
-        bool sendKeyToCeGui(const OIS::KeyEvent& evt) const;
-
-        Person* mCharacter;
-
-        Actor* mCameraActor;
-        Actor* mCharacterActor;
-
-        OgreNewt::Body* mCamBody;
-        OgreNewt::Body* mCharBody;
-
-		CommandMapper* mCommandMapper;
-
-        ControlStateType mType;
-    };
-}
-#endif

Copied: rl/trunk/engine/ui/include/ControllState.h (from rev 3560, rl/trunk/engine/ui/include/CharacterController.h)



From tanis at mail.berlios.de  Mon Jul  2 21:45:16 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 21:45:16 +0200
Subject: [Dsa-hl-svn] r3562 - rl/trunk/engine/ui/include
Message-ID: <200707021945.l62JjGwH005310@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 21:45:10 +0200 (Mon, 02 Jul 2007)
New Revision: 3562

Added:
   rl/trunk/engine/ui/include/ControlState.h
Removed:
   rl/trunk/engine/ui/include/ControllState.h
Log:
Renamed remotely (hmpf)

Copied: rl/trunk/engine/ui/include/ControlState.h (from rev 3561, rl/trunk/engine/ui/include/ControllState.h)

Deleted: rl/trunk/engine/ui/include/ControllState.h
===================================================================
--- rl/trunk/engine/ui/include/ControllState.h	2007-07-02 19:44:37 UTC (rev 3561)
+++ rl/trunk/engine/ui/include/ControllState.h	2007-07-02 19:45:10 UTC (rev 3562)
@@ -1,86 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-
-#ifndef __CharacterController_H__
-#define __CharacterController_H__
-
-#include "UiPrerequisites.h"
-#include "GameTask.h"
-
-#include <OgreNewt.h>
-
-#include <OISMouse.h>
-#include <OISKeyboard.h>
-
-namespace rl {
-
-    class Actor;
-	class CommandMapper;
-	class Creature;
-    class Person;
-
-    /**
-     * This class handles character control via user input.
-     */
-    class _RlUiExport ControlState : public OIS::KeyListener, public OIS::MouseListener
-    {
-	public:
-
-        /**
-         *  @throw NullPointerException if camera or character is NULL.
-         *  @throw InvalidArgumentException if character is not placed in the scene.
-         */
-        ControlState(CommandMapper* commandMapper, Actor* camera, Person* character,
-            ControlStateType type);
-		virtual ~ControlState()= 0;
-
-        virtual void pause() = 0;
-        virtual void resume() = 0;
-
-        virtual void run(Ogre::Real elapsedTime) = 0;
-
-        virtual bool mousePressed(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
-        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
-        virtual bool mouseMoved(const OIS::MouseEvent& evt);
-        virtual bool keyPressed(const OIS::KeyEvent& evt);
-        virtual bool keyReleased(const OIS::KeyEvent& evt);
-
-	protected:
-		static bool startAction(const CeGuiString& actionName, Creature* character = NULL);
-
-        /// Returns true, if there is at least one window open,
-        /// that requires keyboard and/or mouse input. 
-        bool isCeguiActive() const;
-
-        /// Returns true, if the key event should be injected into CEGUI
-        /// This is the case, if an open window requests key input and it is
-        /// an input or navigation key.
-        bool sendKeyToCeGui(const OIS::KeyEvent& evt) const;
-
-        Person* mCharacter;
-
-        Actor* mCameraActor;
-        Actor* mCharacterActor;
-
-        OgreNewt::Body* mCamBody;
-        OgreNewt::Body* mCharBody;
-
-		CommandMapper* mCommandMapper;
-
-        ControlStateType mType;
-    };
-}
-#endif



From tanis at mail.berlios.de  Mon Jul  2 21:47:22 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 21:47:22 +0200
Subject: [Dsa-hl-svn] r3563 - rl/trunk/engine/ui/src
Message-ID: <200707021947.l62JlMmJ005518@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 21:46:58 +0200 (Mon, 02 Jul 2007)
New Revision: 3563

Added:
   rl/trunk/engine/ui/src/ControlState.cpp
Removed:
   rl/trunk/engine/ui/src/CharacterController.cpp
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/src/CharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterController.cpp	2007-07-02 19:45:10 UTC (rev 3562)
+++ rl/trunk/engine/ui/src/CharacterController.cpp	2007-07-02 19:46:58 UTC (rev 3563)
@@ -1,246 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-#include "ControlState.h"
-
-#include <OgreSceneManager.h>
-
-#include "AbstractWindow.h"
-#include "Action.h"
-#include "ActionManager.h"
-#include "Actor.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "Exception.h"
-#include "InputManager.h"
-#include "Person.h"
-#include "PhysicalThing.h"
-#include "WindowManager.h"
-#include "World.h"
-
-using namespace Ogre;
-
-namespace rl {
-
-	ControlState::ControlState(CommandMapper* commandMapper,
-        Actor* camera, Person* character, ControlStateType type)
-		: mCharacter(character),
-        mCameraActor(camera),
-		mCharacterActor(NULL),
-		mCamBody(NULL),
-		mCharBody(NULL),
-        mCommandMapper(commandMapper),
-        mType(type)
-	{
-		if (mCameraActor == NULL)
-		{
-			Throw(NullPointerException, "Camera must not be NULL.");
-		}
-
-		if (mCharacter != NULL)
-		{
-            mCharacterActor = mCharacter->getActor();
-            
-			if (mCharacter != NULL && mCharacterActor->_getSceneNode() == NULL)
-			{
-				Throw(IllegalArgumentException,
-					"character has to be placed in the scene beforehand");
-			}
-            if (mCharacter != NULL && mCharacterActor->getPhysicalThing() == NULL)
-			{
-				Throw(IllegalArgumentException,
-					"character must have a physics proxy");
-			}
-
-			mCharBody = mCharacterActor->getPhysicalThing()->_getBody();
-		}
-
-		mCamBody = mCameraActor->getPhysicalThing()->_getBody();
-
-		if (!mCameraActor->_getSceneNode())
-		{
-			mCameraActor->placeIntoNode(CoreSubsystem::getSingleton().
-				getWorld()->getSceneManager()->getRootSceneNode());
-		}
-
-		// Reset camera position/orientation, as it is now controlled via scene nodes.
-		Camera* ogreCam = static_cast<CameraObject*>(
-            mCameraActor->getControlledObject())->getCamera();
-		ogreCam->setPosition(Vector3::ZERO);
-		ogreCam->setOrientation(Quaternion::IDENTITY);
-
-		mCameraActor->_getSceneNode()->setFixedYawAxis(true);
-
-        PhysicsManager::getSingleton().createMaterialID("character");
-
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
-            PhysicsManager::getSingleton().getMaterialID("default"))->setDefaultFriction(0,0);
-
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
-            PhysicsManager::getSingleton().getMaterialID("level"))->setDefaultFriction(0,0);
-
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("character"),
-            PhysicsManager::getSingleton().getMaterialID("character"))->setDefaultCollidable(0);
-	}
-    
-    ControlState::~ControlState()
-    {
-    
-    }
-
-	bool ControlState::startAction(const CeGuiString& actionName, Creature* character)
-	{
-		if (actionName.length() == 0)
-		{
-			return false;
-		}
-
-        Action* action = ActionManager::getSingleton().getInGameGlobalAction(actionName);
-        if (action != NULL)
-        {
-            action->doAction(NULL, NULL, NULL);
-        }
-        else if (character != NULL)
-		{
-			character->doAction(actionName, character, character);
-		}
-		return true;
-	}
-
-    bool ControlState::mousePressed(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
-    {
-        if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
-        {
-            CEGUI::System::getSingleton().injectMouseButtonDown(
-                static_cast<CEGUI::MouseButton>(id));
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    bool ControlState::mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id)
-    {
-        if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
-        {
-            CEGUI::System::getSingleton().injectMouseButtonUp(static_cast<CEGUI::MouseButton>(id));
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    bool ControlState::mouseMoved(const OIS::MouseEvent& evt)
-    {
-        if (WindowManager::getSingleton().getWindowInputMask() & AbstractWindow::WIT_MOUSE_INPUT)
-        {
-            CEGUI::Renderer* renderer = CEGUI::System::getSingleton().getRenderer();
-            CEGUI::System::getSingleton().injectMouseMove(evt.state.X.rel, evt.state.Y.rel);
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    bool ControlState::keyPressed(const OIS::KeyEvent& evt)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        if (sendKeyToCeGui(evt))
-        {
-            CEGUI::System& cegui = CEGUI::System::getSingleton();
-            cegui.injectKeyUp(evt.key);
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-
-    bool ControlState::keyReleased(const OIS::KeyEvent& evt)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        if (sendKeyToCeGui(evt))
-        {
-            CEGUI::System& cegui = CEGUI::System::getSingleton();
-            cegui.injectKeyDown(evt.key);
-            cegui.injectChar(im->getKeyChar(evt.key, im->getModifierCode()));
-            return true;
-        }
-        else
-        {
-            int code = CommandMapper::encodeKey(evt.key, im->getModifierCode());
-
-            // First see, if a control state action is defined
-		    CeGuiString action = mCommandMapper->getControlStateAction(code, mType);
-            if (action == "")
-            {
-                // No. So try global actions.
-                action = mCommandMapper->getGlobalAction(code);
-            }
-            return startAction(action, mCharacter);
-        }
-    }
-
-    bool ControlState::isCeguiActive() const
-    {
-        return WindowManager::getSingleton().getWindowInputMask() != 0;
-    }
-
-    bool ControlState::sendKeyToCeGui(const OIS::KeyEvent& evt) const
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // Wenn kein Fenster mit Tastatureingabe aktiv ist, kriegt CEGUI keine KeyEvents
-        if ((WindowManager::getSingleton().getWindowInputMask()
-            & AbstractWindow::WIT_KEYBOARD_INPUT) == 0)
-        {
-            return false;
-        }
-
-        // ---- Tastatureingabe gefordert ----
-
-        // Tasten, die Zeichen liefern sollen an CEGUI gesendet werden
-        if (im->getKeyChar(evt.key, im->getModifierCode()) != 0)
-        {
-            return true;
-        }
-
-        if (evt.key == OIS::KC_RETURN
-            || evt.key == OIS::KC_HOME || evt.key == OIS::KC_END
-            || evt.key == OIS::KC_LEFT || evt.key == OIS::KC_RIGHT
-            || evt.key == OIS::KC_BACK || evt.key == OIS::KC_DELETE
-            || evt.key == OIS::KC_UP   || evt.key == OIS::KC_DOWN
-            || evt.key == OIS::KC_RMENU)
-        {
-            return true;
-        }
-
-        return false;
-    }
-}

Copied: rl/trunk/engine/ui/src/ControlState.cpp (from rev 3562, rl/trunk/engine/ui/src/CharacterController.cpp)



From tanis at mail.berlios.de  Mon Jul  2 21:59:45 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 21:59:45 +0200
Subject: [Dsa-hl-svn] r3564 - in rl/trunk/engine: script/swig ui ui/include
	ui/src
Message-ID: <200707021959.l62JxjmJ006698@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 21:59:18 +0200 (Mon, 02 Jul 2007)
New Revision: 3564

Modified:
   rl/trunk/engine/script/swig/RlUi.head.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/CombatCharacterController.h
   rl/trunk/engine/ui/include/CutsceneCharacterController.h
   rl/trunk/engine/ui/include/DialogCharacterController.h
   rl/trunk/engine/ui/include/DialogWindow.h
   rl/trunk/engine/ui/include/FreeFlightCharacterController.h
   rl/trunk/engine/ui/include/MovementCharacterController.h
   rl/trunk/engine/ui/src/CombatCharacterController.cpp
   rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Attention: inconsistent state for a few hours. Partial commit so that I can remotely rename files..
Do not update now.

Modified: rl/trunk/engine/script/swig/RlUi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.head.swig	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/script/swig/RlUi.head.swig	2007-07-02 19:59:18 UTC (rev 3564)
@@ -20,7 +20,7 @@
 
 #include "ControlState.h"
 #include "CommandMapper.h"
-#include "CutsceneCharacterController.h"
+#include "CutsceneControlState.h"
 #include "GameLoggerWindow.h"
 #include "InputManager.h"
 #include "UiPrerequisites.h"

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 19:59:18 UTC (rev 3564)
@@ -26,13 +26,13 @@
 public:
 };
 
-class CutsceneCharacterController : public ControlState
+class CutsceneControlState : public ControlState
 {
 private:
-       CutsceneCharacterController(rl::Actor* camera);
+       CutsceneControlState(rl::Actor* camera);
 
 public:
-    virtual ~CutsceneCharacterController();
+    virtual ~CutsceneControlState();
 
     void setCameraPosition(const Ogre::Vector3& pos);
     void setCameraOrientation(const Ogre::Quaternion& orient);
@@ -140,8 +140,8 @@
     rl::ControlState **ppCharacterController =
         reinterpret_cast<rl::ControlState**>(ptr);
 
-    rl::CutsceneCharacterController *pCutSceneCC =
-        dynamic_cast<rl::CutsceneCharacterController*>(*ppCharacterController);
+    rl::CutsceneControlState *pCutSceneCC =
+        dynamic_cast<rl::CutsceneControlState*>(*ppCharacterController);
     if (pCutSceneCC != NULL) {
         *ptr=pCutSceneCC;
         return SWIGTYPE_p_rl__CutsceneCharacterController;

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-02 19:59:18 UTC (rev 3564)
@@ -342,15 +342,15 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\CharacterController.h"
+				RelativePath=".\include\CombatCharacterController.h"
 				>
 			</File>
 			<File
-				RelativePath=".\include\CombatCharacterController.h"
+				RelativePath=".\include\CommandMapper.h"
 				>
 			</File>
 			<File
-				RelativePath=".\include\CommandMapper.h"
+				RelativePath=".\include\ControlState.h"
 				>
 			</File>
 			<File
@@ -539,15 +539,15 @@
 			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
 			>
 			<File
-				RelativePath=".\src\CharacterController.cpp"
+				RelativePath=".\src\CombatCharacterController.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\src\CombatCharacterController.cpp"
+				RelativePath=".\src\CommandMapper.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\src\CommandMapper.cpp"
+				RelativePath=".\src\ControlState.cpp"
 				>
 			</File>
 			<File

Modified: rl/trunk/engine/ui/include/CombatCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CombatCharacterController.h	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/include/CombatCharacterController.h	2007-07-02 19:59:18 UTC (rev 3564)
@@ -31,14 +31,14 @@
     class CombatManager;
     class CombatWindow;
 
-	class _RlUiExport CombatCharacterController : public ControlState
+	class _RlUiExport CombatControlState : public ControlState
 	{
 	public:
 		/**
 		*  @throw NullPointerException if camera is NULL.
 		*/
-		CombatCharacterController(CommandMapper* cmdMapper, Actor* camera, Person* character);
-		virtual ~CombatCharacterController();
+		CombatControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
+		virtual ~CombatControlState();
 
         virtual void pause();
         virtual void resume();

Modified: rl/trunk/engine/ui/include/CutsceneCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-07-02 19:59:18 UTC (rev 3564)
@@ -24,14 +24,14 @@
 
 	class Actor;
 
-	class _RlUiExport CutsceneCharacterController : public ControlState
+	class _RlUiExport CutsceneControlState : public ControlState
 	{
 	public:
 		/**
 		*  @throw NullPointerException if camera is NULL.
 		*/
-		CutsceneCharacterController(CommandMapper* cmdMapper, Actor* camera);
-		virtual ~CutsceneCharacterController();
+		CutsceneControlState(CommandMapper* cmdMapper, Actor* camera);
+		virtual ~CutsceneControlState();
 
         virtual void pause();
         virtual void resume();

Modified: rl/trunk/engine/ui/include/DialogCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/DialogCharacterController.h	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/include/DialogCharacterController.h	2007-07-02 19:59:18 UTC (rev 3564)
@@ -33,7 +33,7 @@
 	/** Diese Klasse 
 	  *  
 	  */
-	class _RlUiExport DialogCharacterController : public ControlState
+	class _RlUiExport DialogControlState : public ControlState
 	{
 	public:
         enum DialogMode
@@ -47,9 +47,9 @@
 		*  @throw NullPointerException if camera or character is NULL.
 		*  @throw InvalidArgumentException if character is not placed in the scene.
 		*/
-		DialogCharacterController(CommandMapper* cmdMapper, Actor* camera, Person* character);
+		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
 		/// Dtor 
-		virtual ~DialogCharacterController();
+		virtual ~DialogControlState();
 
         virtual void pause();
         virtual void resume();

Modified: rl/trunk/engine/ui/include/DialogWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DialogWindow.h	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/include/DialogWindow.h	2007-07-02 19:59:18 UTC (rev 3564)
@@ -28,7 +28,7 @@
 
 	class DialogCharacter;
 	class DialogResponse;
-	class DialogCharacterController;
+	class DialogControlState;
 	class GameLoggerWindow;
 
 	class _RlUiExport DialogWindow : public AbstractWindow
@@ -37,7 +37,7 @@
 		DialogWindow(GameLoggerWindow* gamelogger);
 		~DialogWindow();
 
-        void initialize(DialogCharacterController* controller, DialogCharacter* character);
+        void initialize(DialogControlState* controller, DialogCharacter* character);
 
 		void getResponse(const CeGuiString& msg);
 		unsigned int count();
@@ -66,7 +66,7 @@
 		CEGUI::Listbox* mQuestion;
 		CEGUI::Window* mName;
 		GameLoggerWindow* mGameLogger;
-		DialogCharacterController* mController;
+		DialogControlState* mController;
 		DialogState mState;
 		CeGuiString mCurrentResponseText;
 				

Modified: rl/trunk/engine/ui/include/FreeFlightCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-07-02 19:59:18 UTC (rev 3564)
@@ -28,7 +28,7 @@
 	/**
 	* This class provides a no-clip free fly controller.
 	*/
-	class _RlUiExport FreeFlightCharacterController : 
+	class _RlUiExport FreeflightControlState : 
         public ControlState,
         public PhysicsController,
         public PhysicsGenericContactCallback
@@ -38,8 +38,8 @@
 		*  @throw NullPointerException if camera or character is NULL.
 		*  @throw InvalidArgumentException if character is not placed in the scene.
 		*/
-		FreeFlightCharacterController(CommandMapper* cmdMapper, Actor* camera, Person* character);
-		virtual ~FreeFlightCharacterController();
+		FreeflightControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
+		virtual ~FreeflightControlState();
 
         virtual void pause();
         virtual void resume();

Modified: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-07-02 19:59:18 UTC (rev 3564)
@@ -38,7 +38,7 @@
     /**
      * This class handles character control via user input.
      */
-    class _RlUiExport MovementCharacterController
+    class _RlUiExport MovementControlState
 	  : public ControlState,
 		public PhysicsController,
         public PhysicsGenericContactCallback,
@@ -50,8 +50,8 @@
          *  @throw NullPointerException if camera or character is NULL.
          *  @throw InvalidArgumentException if character is not placed in the scene.
          */
-        MovementCharacterController(CommandMapper* cmdMapper, Actor* camera, Person* character);
-        virtual ~MovementCharacterController();
+        MovementControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
+        virtual ~MovementControlState();
 
         virtual void pause();
         virtual void resume();

Modified: rl/trunk/engine/ui/src/CombatCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -14,7 +14,7 @@
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
 
-#include "CombatCharacterController.h"
+#include "CombatControlState.h"
 
 #include "Actor.h"
 #include "CameraObject.h"
@@ -35,7 +35,7 @@
 using namespace Ogre;
 
 namespace rl {
-    CombatCharacterController::CombatCharacterController(CommandMapper* cmdMapper,
+    CombatControlState::CombatControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_COMBAT),
           mCombatManager(CombatManager::getSingletonPtr()),
@@ -64,12 +64,12 @@
         sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(mHud);
     }
 
-	CombatCharacterController::~CombatCharacterController()
+	CombatControlState::~CombatControlState()
     {
         delete mEnemySelector.getFilter();
     }
 
-    void CombatCharacterController::resume()
+    void CombatControlState::resume()
     {
         mCameraActor->getPhysicalThing()->freeze();
         mCharacterActor->getPhysicalThing()->freeze();
@@ -114,7 +114,7 @@
         mCombatWindow->setVisible(true);
     }
 
-    void CombatCharacterController::pause()
+    void CombatControlState::pause()
     {
         mCombatWindow->setVisible(false);
 
@@ -126,7 +126,7 @@
         mCombat = NULL;
     }
 
-	void CombatCharacterController::run(Ogre::Real elapsedTime)
+	void CombatControlState::run(Ogre::Real elapsedTime)
     {
         // HUD aktualisieren.
         mHud->clear();
@@ -152,7 +152,7 @@
         mHud->end();
     }
 
-    Ogre::Rectangle CombatCharacterController::getScreenRectFromWorldAABB(
+    Ogre::Rectangle CombatControlState::getScreenRectFromWorldAABB(
         const AxisAlignedBox& aabb) const
     {
         // Initialise each to the value of the opposite side, so that min/max work smoothly.

Modified: rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -15,7 +15,7 @@
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
 
-#include "CutsceneCharacterController.h"
+#include "CutsceneControlState.h"
 #include "Exception.h"
 #include "Actor.h"
 #include "CameraObject.h"
@@ -26,21 +26,21 @@
 
 namespace rl {
 
-	CutsceneCharacterController::CutsceneCharacterController(CommandMapper* cmdMapper,
+	CutsceneControlState::CutsceneControlState(CommandMapper* cmdMapper,
         Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE)
 	{
 	}
 
-	CutsceneCharacterController::~CutsceneCharacterController()
+	CutsceneControlState::~CutsceneControlState()
 	{
 	}
 
-    void CutsceneCharacterController::pause()
+    void CutsceneControlState::pause()
     {
 		mCameraActor->getPhysicalThing()->unfreeze();
     }
 
-    void CutsceneCharacterController::resume()
+    void CutsceneControlState::resume()
     {
 		mCameraActor->getPhysicalThing()->freeze();
 		Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
@@ -48,21 +48,21 @@
 		mCameraActor->_getSceneNode()->setFixedYawAxis(true);
     }
 
-	void CutsceneCharacterController::run(Ogre::Real elapsedTime)
+	void CutsceneControlState::run(Ogre::Real elapsedTime)
 	{
 	}
 
-    void CutsceneCharacterController::setCameraPosition(const Ogre::Vector3& pos)
+    void CutsceneControlState::setCameraPosition(const Ogre::Vector3& pos)
     {
         mCameraActor->setPosition(pos);
     }
 
-    void CutsceneCharacterController::setCameraOrientation(const Ogre::Quaternion& orient)
+    void CutsceneControlState::setCameraOrientation(const Ogre::Quaternion& orient)
     {
         mCameraActor->setOrientation(orient);
     }
 
-    void CutsceneCharacterController::lookAt(const Ogre::Vector3& point)
+    void CutsceneControlState::lookAt(const Ogre::Vector3& point)
     {
         dynamic_cast<Ogre::Camera*>(mCameraActor->getControlledObject()->getMovableObject())
             ->lookAt(point);

Modified: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -15,7 +15,7 @@
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
 
-#include "DialogCharacterController.h"
+#include "DialogControlState.h"
 #include "Exception.h"
 
 #include "Actor.h"
@@ -47,7 +47,7 @@
 
 namespace rl {
 
-    DialogCharacterController::DialogCharacterController(CommandMapper* cmdMapper,
+    DialogControlState::DialogControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
@@ -68,12 +68,12 @@
 
     }
 
-    DialogCharacterController::~DialogCharacterController()
+    DialogControlState::~DialogControlState()
     {
         delete mSoundObject;
     }
 
-    void DialogCharacterController::pause()
+    void DialogControlState::pause()
     {
         if(mDialogPartner)
         {
@@ -93,7 +93,7 @@
         mSubtitleWindow->setVisible(false, false);
     }
 
-    void DialogCharacterController::resume()
+    void DialogControlState::resume()
     {
         mCharacterActor->setVisible(true);
 
@@ -118,7 +118,7 @@
 		mDialogWindow->start();
     }
 
-    void DialogCharacterController::run(Real elapsedTime)
+    void DialogControlState::run(Real elapsedTime)
     {
         if( elapsedTime <= 0.0 )
             return;
@@ -165,7 +165,7 @@
                 + StringConverter::toString(mCurrFadeTextTime));
     }
 
-    void DialogCharacterController::recalculateCamera( Actor* speaker, Actor* listener )
+    void DialogControlState::recalculateCamera( Actor* speaker, Actor* listener )
     {
         // Position camera at position between char and dialog partner
         Vector3 charEyes = speaker->getWorldPosition();
@@ -205,13 +205,13 @@
         mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
     }
 
-    float DialogCharacterController::getShowTextLength(const CeGuiString& text) const
+    float DialogControlState::getShowTextLength(const CeGuiString& text) const
     {
         return 0.019f * text.length() + // Zeit f?rs Text lesen
                0.25f;                   // Fade in
     }
 
-    void DialogCharacterController::response(
+    void DialogControlState::response(
         Actor* actor, const CeGuiString& text, const Ogre::String& soundFile)
     {
         if( actor == mDialogPartner )
@@ -281,7 +281,7 @@
         }
     }
 
-    bool DialogCharacterController::mouseReleased(const OIS::MouseEvent& evt,
+    bool DialogControlState::mouseReleased(const OIS::MouseEvent& evt,
         OIS::MouseButtonID id)
     {
 

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -25,7 +25,7 @@
 #include "DialogCharacter.h"
 #include "DialogResponse.h"
 #include "DialogOption.h"
-#include "DialogCharacterController.h"
+#include "DialogControlState.h"
 #include "GameLoggerWindow.h"
 #include "InputManager.h"
 #include "ListboxWrappedTextItem.h"
@@ -78,7 +78,7 @@
 	mCurrentResponse = NULL;
 }
 
-void DialogWindow::initialize(DialogCharacterController* controller, DialogCharacter* character)
+void DialogWindow::initialize(DialogControlState* controller, DialogCharacter* character)
 {
     mController = controller;
     mBot = character;

Modified: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -14,7 +14,7 @@
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
 
-#include "FreeFlightCharacterController.h"
+#include "FreeflightControlState.h"
 
 #include "CoreSubsystem.h"
 #include "ConfigurationManager.h"
@@ -33,7 +33,7 @@
 
 namespace rl {
 
-	FreeFlightCharacterController::FreeFlightCharacterController(CommandMapper* cmdMapper,
+	FreeflightControlState::FreeflightControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
 		: ControlState(cmdMapper, camera, character, CST_FREEFLIGHT),
 		mMovementSpeed(5.0f),
@@ -52,11 +52,11 @@
         mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
 	}
 
-	FreeFlightCharacterController::~FreeFlightCharacterController()
+	FreeflightControlState::~FreeflightControlState()
 	{
 	}
 
-    void FreeFlightCharacterController::pause()
+    void FreeflightControlState::pause()
     {
 		mCameraActor->getPhysicalThing()->unfreeze();
         if(mCameraUpConstraint != Vector3::ZERO)
@@ -77,7 +77,7 @@
             PhysicsManager::getSingleton().getMaterialID("character"));
     }
 
-    void FreeFlightCharacterController::resume()
+    void FreeflightControlState::resume()
     {
         mCameraActor->getPhysicalThing()->freeze();
         mCameraUpConstraint = mCameraActor->getPhysicalThing()->getUpConstraint();
@@ -100,7 +100,7 @@
             PhysicsManager::getSingleton().getMaterialID("character"))->setContactCallback(this);
     }
 
-	void FreeFlightCharacterController::run(Real elapsedTime)
+	void FreeflightControlState::run(Real elapsedTime)
 	{
         if (isCeguiActive()) return;
 
@@ -190,14 +190,14 @@
         mCameraActor->pitch(mPitch.valueDegrees());
     }
 
-	void FreeFlightCharacterController::toggleCameraCollision()
+	void FreeflightControlState::toggleCameraCollision()
 	{
 		// with or without collision?
         // be careful to enable collision if beeing in another collision
         mCollisionsEnabled = !mCollisionsEnabled;
 	}
 
-	void FreeFlightCharacterController::resetCamera()
+	void FreeflightControlState::resetCamera()
 	{
 		// Position camera at char position
         if( mCharacterActor != NULL )
@@ -220,7 +220,7 @@
         mPitch = Degree(0);
 	}
 
-    bool FreeFlightCharacterController::keyPressed(const OIS::KeyEvent& evt)
+    bool FreeflightControlState::keyPressed(const OIS::KeyEvent& evt)
 	{
         int movement = mCommandMapper->getMovement(evt.key);
 
@@ -233,7 +233,7 @@
 		return false;
 	}
 
-    bool FreeFlightCharacterController::keyReleased(const OIS::KeyEvent& evt)
+    bool FreeflightControlState::keyReleased(const OIS::KeyEvent& evt)
 	{
         int movement = mCommandMapper->getMovement(evt.key);
 
@@ -264,7 +264,7 @@
         }
 	}
 
-    int FreeFlightCharacterController::userProcess()
+    int FreeflightControlState::userProcess()
     {
         if (m_body0 == mCamBody || m_body1 == mCamBody)
         {
@@ -285,7 +285,7 @@
 
 
 
-    void FreeFlightCharacterController::OnApplyForceAndTorque(PhysicalThing* thing)
+    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
         OgreNewt::Body* body = thing->_getBody();

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -34,18 +34,18 @@
 #include "ActorManager.h"
 #include "AbstractWindow.h"
 #include "ControlState.h"
-#include "CombatCharacterController.h"
+#include "CombatControlState.h"
 #include "CommandMapper.h"
 #include "ConfigurationManager.h"
 #include "Console.h"
 #include "CoreSubsystem.h"
-#include "CutsceneCharacterController.h"
+#include "CutsceneControlState.h"
 #include "DebugWindow.h"
-#include "DialogCharacterController.h"
-#include "FreeFlightCharacterController.h"
+#include "DialogControlState.h"
+#include "FreeflightControlState.h"
 #include "GameLoop.h"
 #include "GameObject.h"
-#include "MovementCharacterController.h"
+#include "MovementControlState.h"
 #include "RubyInterpreter.h"
 #include "UiSubsystem.h"
 #include "WindowFactory.h"
@@ -408,19 +408,19 @@
         switch (controlStateType)
         {
         case CST_CUTSCENE:
-            controller = new CutsceneCharacterController(mCommandMapper, camera);
+            controller = new CutsceneControlState(mCommandMapper, camera);
             break;
         case CST_MOVEMENT:
-            controller = new MovementCharacterController(mCommandMapper, camera, character);
+            controller = new MovementControlState(mCommandMapper, camera, character);
             break;
         case CST_FREEFLIGHT:
-            controller = new FreeFlightCharacterController(mCommandMapper, camera, character);
+            controller = new FreeflightControlState(mCommandMapper, camera, character);
             break;
         case CST_DIALOG:
-            controller = new DialogCharacterController(mCommandMapper, camera, character);
+            controller = new DialogControlState(mCommandMapper, camera, character);
             break;
         case CST_COMBAT:
-            controller = new CombatCharacterController(mCommandMapper, camera, character);
+            controller = new CombatControlState(mCommandMapper, camera, character);
             break;
         default:
             Throw(IllegalStateException, "Unknown controller type.");

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -14,7 +14,7 @@
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
 
-#include "MovementCharacterController.h"
+#include "MovementControlState.h"
 
 #include <OgreSceneManager.h>
 #include <OgreAxisAlignedBox.h>
@@ -39,7 +39,7 @@
 #include "Logger.h"
 #include "MeshObject.h"
 #include "MeshAnimation.h"
-#include "MovementCharacterController.h"
+#include "MovementControlState.h"
 #include "Person.h"
 #include "PhysicsManager.h"
 #include "PhysicsMaterialRaycast.h"
@@ -56,16 +56,16 @@
 
 namespace rl {
 
-    String MovementCharacterController::msDebugWindowPageName = "MovementCharacterController";
+    String MovementControlState::msDebugWindowPageName = "MovementControlState";
 
-    MovementCharacterController::CharacterState::CharacterState()
+    MovementControlState::CharacterState::CharacterState()
         :
         mCurrentMovementState(MOVE_NONE),
         mLastMovementState(MOVE_NONE)
     {
     }
 
-    MovementCharacterController::MovementCharacterController(CommandMapper* cmdMapper,
+    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
         mMovingCreature(NULL),
@@ -126,7 +126,7 @@
     }
 
     //------------------------------------------------------------------------
-    MovementCharacterController::~MovementCharacterController()
+    MovementControlState::~MovementControlState()
     {
         delete mCombatSelector.getFilter();
         delete mRaycast;
@@ -144,7 +144,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::pause()
+    void MovementControlState::pause()
     {
         if( mMovingCreature != NULL )
         {
@@ -177,7 +177,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::resume()
+    void MovementControlState::resume()
     {
         if( mMovingCreature == NULL )
             mMovingCreature = new MovingCreature(mCharacter);
@@ -213,7 +213,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::run(Real elapsedTime)
+    void MovementControlState::run(Real elapsedTime)
     {
         if (isCeguiActive()) return;
 
@@ -279,7 +279,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::updateCharacter(Ogre::Real elapsedTime)
+    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
         if( mMovingCreature != NULL )
@@ -408,7 +408,7 @@
     }
 
     // ------------------------------------------------------------------------
-    void MovementCharacterController::updateCameraLookAt(Ogre::Real elapsedTime)
+    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
 
@@ -504,7 +504,7 @@
 
     // -------------------------------------------------------------
     // character collision moved to MovingCreature(Manager)
-    int MovementCharacterController::userProcess()
+    int MovementControlState::userProcess()
     {
         // only camera collision
         return 0;
@@ -520,7 +520,7 @@
 
     //------------------------------------------------------------------------
     // character callback moved to MovingCreature
-    void MovementCharacterController::OnApplyForceAndTorque(PhysicalThing* thing)
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
         Real timestep = world->getTimeStep();
@@ -557,7 +557,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::calculateCamera(const Ogre::Real& timestep)
+    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
     {
         Vector3 charPos = mCharacter->getActor()->getWorldPosition();
         Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
@@ -803,7 +803,7 @@
     }
 
     //------------------------------------------------------------------------
-    Ogre::Vector3 MovementCharacterController::calculateOptimalCameraPosition(bool SlowlyMoveBackward, const Real &timestep)
+    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool SlowlyMoveBackward, const Real &timestep)
     {
         Vector3 targetCamPos;
 
@@ -966,7 +966,7 @@
     }
 
     //------------------------------------------------------------------------
-    bool MovementCharacterController::isEnemyNear()
+    bool MovementControlState::isEnemyNear()
     {
         mCombatSelector.updateSelection();
 
@@ -984,7 +984,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::updateSelection()
+    void MovementControlState::updateSelection()
     {
         if (isCeguiActive()) return;
 
@@ -1018,7 +1018,7 @@
     }
 
 
-    void MovementCharacterController::setViewMode(ViewMode mode)
+    void MovementControlState::setViewMode(ViewMode mode)
     {
         mViewMode = mode;
 
@@ -1077,7 +1077,7 @@
     //------------------------------------------------------------------------
 /*
     // not used at the moment!
-    void MovementCharacterController::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
+    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
     {
         AxisAlignedBox aab;
         Vector3 size[2];
@@ -1112,13 +1112,13 @@
 */
 
     //------------------------------------------------------------------------
-    MovementCharacterController::ViewMode MovementCharacterController::getViewMode()
+    MovementControlState::ViewMode MovementControlState::getViewMode()
     {
         return mViewMode;
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::toggleViewMode()
+    void MovementControlState::toggleViewMode()
     {
         if (getViewMode() == VM_THIRD_PERSON)
             setViewMode(VM_FIRST_PERSON);
@@ -1129,7 +1129,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::resetCamera()
+    void MovementControlState::resetCamera()
     {
         Vector3 camPos;
         Quaternion camOri;
@@ -1146,7 +1146,7 @@
     }
 
     //------------------------------------------------------------------------
-    bool MovementCharacterController::keyPressed(const OIS::KeyEvent& evt)
+    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt)
     {
         if (ControlState::keyPressed(evt)) return true;
 
@@ -1166,7 +1166,7 @@
     }
 
     //------------------------------------------------------------------------
-    bool MovementCharacterController::keyReleased(const OIS::KeyEvent& evt)
+    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt)
     {
         // CEGUI is handled by base class, so hand it down if necessary.
         if (sendKeyToCeGui(evt))
@@ -1212,7 +1212,7 @@
     }
 
     //------------------------------------------------------------------------
-    bool MovementCharacterController::mouseReleased(const OIS::MouseEvent& evt,
+    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
         OIS::MouseButtonID id)
     {
         if (!isCeguiActive())
@@ -1229,13 +1229,13 @@
     }
 
     //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementCharacterController::getFlag() const
+    DebugVisualisableFlag MovementControlState::getFlag() const
     {
         return DVF_CONTROL;
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::updatePrimitive()
+    void MovementControlState::updatePrimitive()
     {
         if (mSceneNode->getParent() == NULL)
         {
@@ -1248,7 +1248,7 @@
     }
 
     //------------------------------------------------------------------------
-    void MovementCharacterController::doCreatePrimitive()
+    void MovementControlState::doCreatePrimitive()
     {
         mPrimitive = new LineSetPrimitive();
     }

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -28,19 +28,19 @@
 #include "ConfigurationManager.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
-#include "CombatCharacterController.h"
-#include "CutsceneCharacterController.h"
-#include "DialogCharacterController.h"
+#include "CombatControlState.h"
+#include "CutsceneControlState.h"
+#include "DialogControlState.h"
 #include "DsaManager.h"
 #include "Exception.h"
-#include "FreeFlightCharacterController.h"
+#include "FreeflightControlState.h"
 #include "GameObject.h"
 #include "GameLoggerWindow.h"
 #include "GameLoop.h"
 #include "InputManager.h"
 #include "ListenerMovable.h"
 #include "Logger.h"
-#include "MovementCharacterController.h"
+#include "MovementControlState.h"
 #include "Person.h"
 #include "ScriptWrapper.h"
 #include "SoundManager.h"

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-07-02 19:46:58 UTC (rev 3563)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-07-02 19:59:18 UTC (rev 3564)
@@ -27,7 +27,7 @@
 #include "CoreSubsystem.h"
 #include "DebugWindow.h"
 #include "DialogCharacter.h"
-#include "DialogCharacterController.h"
+#include "DialogControlState.h"
 #include "DialogWindow.h"
 #include "Exception.h"
 #include "GameLoggerWindow.h"



From tanis at mail.berlios.de  Mon Jul  2 22:01:53 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:01:53 +0200
Subject: [Dsa-hl-svn] r3565 - rl/trunk/engine/ui/include
Message-ID: <200707022001.l62K1rPe007068@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:01:44 +0200 (Mon, 02 Jul 2007)
New Revision: 3565

Added:
   rl/trunk/engine/ui/include/CombatControlState.h
Removed:
   rl/trunk/engine/ui/include/CombatCharacterController.h
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/include/CombatCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CombatCharacterController.h	2007-07-02 19:59:18 UTC (rev 3564)
+++ rl/trunk/engine/ui/include/CombatCharacterController.h	2007-07-02 20:01:44 UTC (rev 3565)
@@ -1,63 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-
-#ifndef __CombatCharacterController_H__
-#define __CombatCharacterController_H__
-
-#include "UiPrerequisites.h"
-
-#include "ControlState.h"
-#include "Selector.h"
-
-#include <OgreRectangle.h>
-
-namespace rl {
-
-	class CameraObject;
-    class Combat;
-    class CombatManager;
-    class CombatWindow;
-
-	class _RlUiExport CombatControlState : public ControlState
-	{
-	public:
-		/**
-		*  @throw NullPointerException if camera is NULL.
-		*/
-		CombatControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
-		virtual ~CombatControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-		void run(Ogre::Real elapsedTime);
-
-    private:
-        CombatManager* mCombatManager;
-        // Current combat that is controlled.
-        Combat* mCombat;
-        CombatWindow* mCombatWindow;
-        HalfSphereSelector mEnemySelector;
-
-        CameraObject* mCamera;
-
-        /// Little Helper-MO for visualisation for everything that is difficult with cegui.
-        Ogre::ManualObject* mHud;
-
-        Ogre::Rectangle getScreenRectFromWorldAABB(const Ogre::AxisAlignedBox& aabb) const;
-	};
-}
-#endif

Copied: rl/trunk/engine/ui/include/CombatControlState.h (from rev 3564, rl/trunk/engine/ui/include/CombatCharacterController.h)



From tanis at mail.berlios.de  Mon Jul  2 22:02:40 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:02:40 +0200
Subject: [Dsa-hl-svn] r3566 - rl/trunk/engine/ui/include
Message-ID: <200707022002.l62K2eSw007215@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:02:33 +0200 (Mon, 02 Jul 2007)
New Revision: 3566

Added:
   rl/trunk/engine/ui/include/CutsceneControlState.h
Removed:
   rl/trunk/engine/ui/include/CutsceneCharacterController.h
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/include/CutsceneCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-07-02 20:01:44 UTC (rev 3565)
+++ rl/trunk/engine/ui/include/CutsceneCharacterController.h	2007-07-02 20:02:33 UTC (rev 3566)
@@ -1,46 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-
-#ifndef __CutsceneCharacterController_H__
-#define __CutsceneCharacterController_H__
-
-#include "UiPrerequisites.h"
-#include "ControlState.h"
-
-namespace rl {
-
-	class Actor;
-
-	class _RlUiExport CutsceneControlState : public ControlState
-	{
-	public:
-		/**
-		*  @throw NullPointerException if camera is NULL.
-		*/
-		CutsceneControlState(CommandMapper* cmdMapper, Actor* camera);
-		virtual ~CutsceneControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-		virtual void run(Ogre::Real elapsedTime);
-
-        void setCameraPosition(const Ogre::Vector3& pos);
-        void setCameraOrientation(const Ogre::Quaternion& orient);
-        void lookAt(const Ogre::Vector3& point);
-	};
-}
-#endif

Copied: rl/trunk/engine/ui/include/CutsceneControlState.h (from rev 3565, rl/trunk/engine/ui/include/CutsceneCharacterController.h)



From tanis at mail.berlios.de  Mon Jul  2 22:03:19 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:03:19 +0200
Subject: [Dsa-hl-svn] r3567 - rl/trunk/engine/ui/include
Message-ID: <200707022003.l62K3JWT007340@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:03:15 +0200 (Mon, 02 Jul 2007)
New Revision: 3567

Added:
   rl/trunk/engine/ui/include/DialogControlState.h
Removed:
   rl/trunk/engine/ui/include/DialogCharacterController.h
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/include/DialogCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/DialogCharacterController.h	2007-07-02 20:02:33 UTC (rev 3566)
+++ rl/trunk/engine/ui/include/DialogCharacterController.h	2007-07-02 20:03:15 UTC (rev 3567)
@@ -1,105 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-
-#ifndef __DialogCharacterController_H__
-#define __DialogCharacterController_H__
-
-#include "UiPrerequisites.h"
-#include "ControlState.h"
-
-#include <OgreCamera.h>
-
-namespace rl {
-
-	class Actor;
-	class DialogWindow;
-	class MeshAnimation;
-	class SoundObject;
-	class SubtitleWindow;
-
-	/** Diese Klasse 
-	  *  
-	  */
-	class _RlUiExport DialogControlState : public ControlState
-	{
-	public:
-        enum DialogMode
-		{ 
-            // Frontperspektive auf Augenh?he, ausgehend von der Mitte zwischen den Redenden
-			DM_FRONT = 1,
-		};
-
-
-		/**
-		*  @throw NullPointerException if camera or character is NULL.
-		*  @throw InvalidArgumentException if character is not placed in the scene.
-		*/
-		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
-		/// Dtor 
-		virtual ~DialogControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-		/// @override
-		virtual void run(Ogre::Real elapsedTime);
-
-		/// Setzt den Dialogpartner (Diealogf?hrenden Spieler-Actor)
-		void setDialogPartner(Actor* partner);
-
-		/// Antwort eines der Dialogf?hrenden
-		void response(Actor* actor, const CeGuiString& text, const Ogre::String& soundFile = "");
-
-		void setDialogWindow(DialogWindow* dialog);
-		void setSubtitleWindow(SubtitleWindow* subtitles);
-	
-        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
-	private:
-		/// Die Zielkameraposition in lokalen Koordinaten
-		Ogre::Vector3 mTargetCameraPosition;
-		/// Die ben?tigte lokale Drehung der Kamera
-		Ogre::Vector3 mTargetCameraDirection;
-
-		/// Die aktuelle Zeit f?r die Textanzeige
-		Ogre::Real mCurrFadeTextTime;
-        /// Die Zeit bis der Text ausgeblendet wird
-        Ogre::Real mTotalFadeTextTime;
-
-        Ogre::Real mSubtitleSpeed;
-
-		/// Der Untertitel Text
-		CeGuiString mText;
-		/// Es wird gerade Text angezeigt
-		bool mTextShown;
-
-		/// Der Spieler der redet
-		Actor* mDialogPartner;
-		/// Der Besitzer des Dialoges (Der Bauer mit dem der Spieler redet)
-		Actor* mCurrentActor;
-        /// Die Art der Kamerapositinierung
-        DialogMode mDialogMode;
-
-		MeshAnimation* mTalkAnimation;
-
-		DialogWindow* mDialogWindow;
-		SubtitleWindow* mSubtitleWindow;
-		SoundObject* mSoundObject;
-	
-		float getShowTextLength(const CeGuiString& text) const;
-        void recalculateCamera( Actor* speaker, Actor* listener );
-	};
-}
-#endif

Copied: rl/trunk/engine/ui/include/DialogControlState.h (from rev 3566, rl/trunk/engine/ui/include/DialogCharacterController.h)



From tanis at mail.berlios.de  Mon Jul  2 22:03:59 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:03:59 +0200
Subject: [Dsa-hl-svn] r3568 - rl/trunk/engine/ui/include
Message-ID: <200707022003.l62K3xNV007496@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:03:49 +0200 (Mon, 02 Jul 2007)
New Revision: 3568

Added:
   rl/trunk/engine/ui/include/FreeflightControlState.h
Removed:
   rl/trunk/engine/ui/include/FreeFlightCharacterController.h
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/include/FreeFlightCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-07-02 20:03:15 UTC (rev 3567)
+++ rl/trunk/engine/ui/include/FreeFlightCharacterController.h	2007-07-02 20:03:49 UTC (rev 3568)
@@ -1,79 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-#ifndef __FreeFlightCharacterController_H__
-#define __FreeFlightCharacterController_H__
-
-#include "UiPrerequisites.h"
-#include "ControlState.h"
-#include "PhysicsController.h"
-#include "PhysicsGenericContactCallback.h"
-#include <OgreNewt.h>
-
-namespace rl {
-
-	/**
-	* This class provides a no-clip free fly controller.
-	*/
-	class _RlUiExport FreeflightControlState : 
-        public ControlState,
-        public PhysicsController,
-        public PhysicsGenericContactCallback
-	{
-	public:
-		/**
-		*  @throw NullPointerException if camera or character is NULL.
-		*  @throw InvalidArgumentException if character is not placed in the scene.
-		*/
-		FreeflightControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
-		virtual ~FreeflightControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-		virtual void run(Ogre::Real elapsedTime);
-
-        virtual bool keyPressed(const OIS::KeyEvent& evt);
-        virtual bool keyReleased(const OIS::KeyEvent& evt);
-
-	    void toggleCameraCollision();
-	    void resetCamera();
-
-        /// This is the OgreNewt contact process callback for the combination
-        /// Character <-> Level
-        int userProcess();
-
-        /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
-
-	private:		
-		int mCurrentMovementState;
-
-		Ogre::Real mMovementSpeed;
-		std::pair<Ogre::Real, Ogre::Real> mSpeedRange;
-		Ogre::Real mSpeedIncrement;
-		Ogre::Real mRotationSpeed;
-        Ogre::Vector3 mDesiredVelocity;
-        Ogre::Vector3 mCameraUpConstraint;
-        Ogre::Radian mYaw;
-        Ogre::Radian mPitch;
-        bool mCollisionsEnabled;
-        Ogre::Real mMouseSensitivity;
-        bool mInvertedMouse;
-        std::pair<Ogre::Degree, Ogre::Degree> mPitchRange;
-	};
-}
-#endif

Copied: rl/trunk/engine/ui/include/FreeflightControlState.h (from rev 3567, rl/trunk/engine/ui/include/FreeFlightCharacterController.h)



From tanis at mail.berlios.de  Mon Jul  2 22:04:54 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:04:54 +0200
Subject: [Dsa-hl-svn] r3569 - rl/trunk/engine/ui/include
Message-ID: <200707022004.l62K4s7o007674@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:04:48 +0200 (Mon, 02 Jul 2007)
New Revision: 3569

Added:
   rl/trunk/engine/ui/include/MovementControlState.h
Removed:
   rl/trunk/engine/ui/include/MovementCharacterController.h
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/include/MovementCharacterController.h
===================================================================
--- rl/trunk/engine/ui/include/MovementCharacterController.h	2007-07-02 20:03:49 UTC (rev 3568)
+++ rl/trunk/engine/ui/include/MovementCharacterController.h	2007-07-02 20:04:48 UTC (rev 3569)
@@ -1,168 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-
-#ifndef __MovementCharacterController_H__
-#define __MovementCharacterController_H__
-
-#include "UiPrerequisites.h"
-#include "GameTask.h"
-#include "MovingCreature.h"
-#include "PhysicsController.h"
-#include "PhysicsGenericContactCallback.h"
-#include "ControlState.h"
-#include "DebugVisualisable.h"
-#include "Selector.h"
-
-#include <deque>
-
-namespace rl {
-
-    class Actor;
-	class Creature;
-    class MeshObject;
-	class PhysicsMaterialRaycast;
-
-    /**
-     * This class handles character control via user input.
-     */
-    class _RlUiExport MovementControlState
-	  : public ControlState,
-		public PhysicsController,
-        public PhysicsGenericContactCallback,
-        public DebugVisualisable
-    {
-    public:
-        typedef enum {VM_THIRD_PERSON, VM_FIRST_PERSON, VM_FREE_CAMERA} ViewMode;
-        /**
-         *  @throw NullPointerException if camera or character is NULL.
-         *  @throw InvalidArgumentException if character is not placed in the scene.
-         */
-        MovementControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
-        virtual ~MovementControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-        void run(Ogre::Real elapsedTime);
-
-        /// This is the OgreNewt contact process callback for the combination
-        /// Character <-> Level
-        int userProcess();
-
-        /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
-
-        /// First oder Third person view.
-        void setViewMode(ViewMode mode);
-        ViewMode getViewMode();
-        void toggleViewMode();
-
-        /** Setzt die Camera in einen 30-Grad-Winkel dem Helden auf den Hinterkopf
-        *  schauend im aktuellen Abstand vom Helden, wie durch den Spieler bestimmt.
-        */
-        void resetCamera();
-
-        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
-        virtual bool keyPressed(const OIS::KeyEvent& evt);
-        virtual bool keyReleased(const OIS::KeyEvent& evt);
-
-        // Overrides from DebugVisualisable
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        virtual void doCreatePrimitive();
-        MovingCreature *mMovingCreature;
-
-    private:
-
-		/// private struct for holding state info of the controller
-		struct CharacterState
-		{
-            CharacterState();
-			int mCurrentMovementState;
-			int mLastMovementState;
-		};
-
-        static Ogre::String msDebugWindowPageName;
-
-		CharacterState mCharacterState;// does only refer to the movement caused by the keyboard
-
-        // camera control params
-        /// optimal distance to the character
-        Ogre::Real mDesiredDistance;
-        std::pair<Ogre::Real, Ogre::Real> mDistanceRange;
-        Ogre::Degree mCamYaw; // f?r VM_FREE_CAMERA
-        Ogre::Degree mCamVirtualYaw; // helps to simulate strafe+forward/backward movement
-        Ogre::Degree mPitch;
-        Ogre::Degree mRoll;
-        std::pair<Ogre::Degree, Ogre::Degree> mPitchRange;
-
-        Ogre::Vector3 mLookAtOffset;
-        Ogre::Radian mRotationSpeed;
-        Ogre::Real mMouseSensitivity;
-        bool mInvertedMouse; // like in old games
-
-        ViewMode mViewMode;
-
-        int mObstractedFrameCount;
-        Ogre::Real mObstractedTime;
-        int mCameraJammedFrameCount;
-        Ogre::Real mCameraJammedTime;
-
-        PhysicsMaterialRaycast* mRaycast;
-        HalfSphereSelector mSelector;
-        HalfSphereSelector mCombatSelector;
-
-
-        /// Camera Spring-Damping System (smooth movement) spring-factor
-        Ogre::Real mLinearSpringK;
-        /// Camera Spring-Damping System (smooth movement) damping-factor
-        Ogre::Real mLinearDampingK;
-
-        /// with this velocity the optimal Position of the cam moves away from the char
-        Ogre::Real mCamMoveAwayVelocity;
-        /// if there was no collision of the cam for this time, the cam can securely move backward
-        Ogre::Real mCamMoveAwayStartTime;
-        /// if the angle between the last camera pos and the character and the new one is smaller than this value, the camera can move away from the character
-        Ogre::Radian mCamMoveAwayRange;
-
-        void updateSelection();
-        bool isEnemyNear();
-
-
-        void updateCameraLookAt(Ogre::Real elapsedTime);
-
-        void updateCharacter(Ogre::Real elapsedTime);
-
-        //void interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor);
-
-
-        /** Does all camera-stuff, moves the camera to the right position 
-        * and does pathfinding (in a very simple way)
-        * @warning this does only work well, if the character's material is not used for other objects!
-        */
-		void calculateCamera(const Ogre::Real& timestep);
-
-        /** Calculates the position, 
-        * the camera should move to.
-        * @param SlowlyMoveBackward if set, the camera moves more slowly away from the character then toward it.
-        * @param timestep in order to reset the camera (no valid last position) the timestep can be 0.
-        */
-        Ogre::Vector3 calculateOptimalCameraPosition(bool SlowlyMoveBackward, const Ogre::Real &timestep);
-    };
-}
-#endif

Copied: rl/trunk/engine/ui/include/MovementControlState.h (from rev 3568, rl/trunk/engine/ui/include/MovementCharacterController.h)



From tanis at mail.berlios.de  Mon Jul  2 22:05:55 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:05:55 +0200
Subject: [Dsa-hl-svn] r3570 - rl/trunk/engine/ui/src
Message-ID: <200707022005.l62K5tfQ007845@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:05:49 +0200 (Mon, 02 Jul 2007)
New Revision: 3570

Added:
   rl/trunk/engine/ui/src/CombatControlState.cpp
Removed:
   rl/trunk/engine/ui/src/CombatCharacterController.cpp
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/src/CombatCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-07-02 20:04:48 UTC (rev 3569)
+++ rl/trunk/engine/ui/src/CombatCharacterController.cpp	2007-07-02 20:05:49 UTC (rev 3570)
@@ -1,177 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  http://www.perldoc.com/perl5.6/Artistic.html.
- */
-
-#include "CombatControlState.h"
-
-#include "Actor.h"
-#include "CameraObject.h"
-#include "Combat.h"
-#include "CombatManager.h"
-#include "CombatWindow.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "InputManager.h"
-#include "MeshObject.h"
-#include "Person.h"
-#include "PhysicalThing.h"
-#include "Selector.h"
-#include "WindowFactory.h"
-#include "World.h"
-
-#include <OgreManualObject.h>
-using namespace Ogre;
-
-namespace rl {
-    CombatControlState::CombatControlState(CommandMapper* cmdMapper,
-        Actor* camera, Person* character)
-        : ControlState(cmdMapper, camera, character, CST_COMBAT),
-          mCombatManager(CombatManager::getSingletonPtr()),
-          mCombat(NULL),
-          mCombatWindow(NULL),
-          mEnemySelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE),
-          mCamera(NULL)
-    {
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mEnemySelector.setFilter(filter);
-
-        mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
-        mCamera = static_cast<CameraObject*>(mCameraActor->getControlledObject());
-
-        // Initialise HUD-MO. Put it into 2D mode and make sure it is always rendered.
-        SceneManager* sceneMgr = CoreSubsystem::getSingleton().getWorld()->getSceneManager();
-        mHud = sceneMgr->createManualObject("__COMBAT_HUD__");
-        mHud->setUseIdentityProjection(true);
-        mHud->setUseIdentityView(true);
-        AxisAlignedBox infiniteAabb;
-        infiniteAabb.setInfinite();
-        mHud->setBoundingBox(infiniteAabb);
-        mHud->setRenderQueueGroup(RENDER_QUEUE_OVERLAY);
-        sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(mHud);
-    }
-
-	CombatControlState::~CombatControlState()
-    {
-        delete mEnemySelector.getFilter();
-    }
-
-    void CombatControlState::resume()
-    {
-        mCameraActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->freeze();
-
-        ///\todo Richtig machen, nur tempor?r Ani hier setzen.
-        static_cast<MeshObject*>(mCharacterActor->getControlledObject())
-            ->startAnimation("kampf_schwerter_idle");
-
-        // Set reference to character
-        mEnemySelector.setCheckVisibility(true, mCharacter);
-        mEnemySelector.track(mCharacter);
-        mEnemySelector.setRadius(10.0);
-
-        // Is there a combat running already?
-        if (mCombatManager->getCurrentCombat() != NULL)
-        {
-            // Yes. Set this one as active.
-            mCombat = mCombatManager->getCurrentCombat();
-        }
-        else
-        {
-            // No. Test, if we can start one.
-            mEnemySelector.updateSelection();
-            const Selector::GameObjectVector& enemies = mEnemySelector.getAllSelectedObjects();
-            if (!enemies.empty())
-            {
-                // There are enemies in vicinity, so start a new combat and set it up properly.
-                mCombat = mCombatManager->startCombat(mCharacter,
-                    static_cast<Creature*>(enemies[0]));
-                for (size_t i = 1; i < enemies.size(); ++i)
-                {
-                    mCombat->addOpponent(static_cast<Creature*>(enemies[i]));
-                }
-            }
-            else
-            {
-                // Oops. Nothing to fight. Pop self.
-                InputManager::getSingleton().popControlState();
-                return;
-            }
-        }
-        mCombatWindow->setVisible(true);
-    }
-
-    void CombatControlState::pause()
-    {
-        mCombatWindow->setVisible(false);
-
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCharacterActor->getPhysicalThing()->unfreeze();
-        static_cast<MeshObject*>(mCharacterActor->getControlledObject())->stopAllAnimations();
-
-        // reset current combat, in order to avoid a potential dangling pointer
-        mCombat = NULL;
-    }
-
-	void CombatControlState::run(Ogre::Real elapsedTime)
-    {
-        // HUD aktualisieren.
-        mHud->clear();
-        
-        mHud->begin("BaseWhiteNoLighting", RenderOperation::OT_LINE_STRIP);
-        const Combat::CreatureSet& opponents = mCombat->getAllOpponents();
-        for (Combat::CreatureSet::const_iterator it = opponents.begin(), end = opponents.end();
-            it != end; ++it)
-        {
-            Ogre::Rectangle rec = getScreenRectFromWorldAABB(
-                (*it)->getActor()->_getSceneNode()->_getWorldAABB());
-            mHud->position(rec.left,  rec.top,    0.0f);
-            mHud->position(rec.left,  rec.bottom, 0.0f);
-            mHud->position(rec.right, rec.top,    0.0f);
-            mHud->position(rec.right, rec.bottom, 0.0f);
-
-            mHud->index(0);
-            mHud->index(1);
-            mHud->index(3);
-            mHud->index(2);
-            mHud->index(0);
-        }
-        mHud->end();
-    }
-
-    Ogre::Rectangle CombatControlState::getScreenRectFromWorldAABB(
-        const AxisAlignedBox& aabb) const
-    {
-        // Initialise each to the value of the opposite side, so that min/max work smoothly.
-        Real left = 1.0f, bottom = 1.0f, right = -1.0f, top = -1.0f;
-
-        // Determine screen pos of all corners and widen the rect if needed
-        const Vector3* corners = aabb.getAllCorners();
-        for (size_t i = 0; i < 8; ++i)
-        {
-			Vector3 screenSpacePos = mCamera->getPointOnScreen(corners[i]);
-            if (screenSpacePos.z > 0) continue; // Behind camera
-
-            left   = std::min(left,   screenSpacePos.x);
-            right  = std::max(right,  screenSpacePos.x);
-            bottom = std::min(bottom, screenSpacePos.y);
-            top    = std::max(top,    screenSpacePos.y);
-        }
-
-        Ogre::Rectangle rval = {left,top, right, bottom};
-        return rval;
-    }
-}

Copied: rl/trunk/engine/ui/src/CombatControlState.cpp (from rev 3569, rl/trunk/engine/ui/src/CombatCharacterController.cpp)



From tanis at mail.berlios.de  Mon Jul  2 22:06:48 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:06:48 +0200
Subject: [Dsa-hl-svn] r3571 - rl/trunk/engine/ui/src
Message-ID: <200707022006.l62K6mSg008029@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:06:42 +0200 (Mon, 02 Jul 2007)
New Revision: 3571

Added:
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
Removed:
   rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/src/CutsceneCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-07-02 20:05:49 UTC (rev 3570)
+++ rl/trunk/engine/ui/src/CutsceneCharacterController.cpp	2007-07-02 20:06:42 UTC (rev 3571)
@@ -1,70 +0,0 @@
-/*
-* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-#include "CutsceneControlState.h"
-#include "Exception.h"
-#include "Actor.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "PhysicalThing.h"
-
-using namespace Ogre;
-
-namespace rl {
-
-	CutsceneControlState::CutsceneControlState(CommandMapper* cmdMapper,
-        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE)
-	{
-	}
-
-	CutsceneControlState::~CutsceneControlState()
-	{
-	}
-
-    void CutsceneControlState::pause()
-    {
-		mCameraActor->getPhysicalThing()->unfreeze();
-    }
-
-    void CutsceneControlState::resume()
-    {
-		mCameraActor->getPhysicalThing()->freeze();
-		Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
-		ogreCam->setFixedYawAxis(true);
-		mCameraActor->_getSceneNode()->setFixedYawAxis(true);
-    }
-
-	void CutsceneControlState::run(Ogre::Real elapsedTime)
-	{
-	}
-
-    void CutsceneControlState::setCameraPosition(const Ogre::Vector3& pos)
-    {
-        mCameraActor->setPosition(pos);
-    }
-
-    void CutsceneControlState::setCameraOrientation(const Ogre::Quaternion& orient)
-    {
-        mCameraActor->setOrientation(orient);
-    }
-
-    void CutsceneControlState::lookAt(const Ogre::Vector3& point)
-    {
-        dynamic_cast<Ogre::Camera*>(mCameraActor->getControlledObject()->getMovableObject())
-            ->lookAt(point);
-    }
-}

Copied: rl/trunk/engine/ui/src/CutsceneControlState.cpp (from rev 3570, rl/trunk/engine/ui/src/CutsceneCharacterController.cpp)



From tanis at mail.berlios.de  Mon Jul  2 22:07:27 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:07:27 +0200
Subject: [Dsa-hl-svn] r3572 - rl/trunk/engine/ui/src
Message-ID: <200707022007.l62K7ROG008169@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:07:19 +0200 (Mon, 02 Jul 2007)
New Revision: 3572

Added:
   rl/trunk/engine/ui/src/DialogControlState.cpp
Removed:
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-07-02 20:06:42 UTC (rev 3571)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-07-02 20:07:19 UTC (rev 3572)
@@ -1,300 +0,0 @@
-/*
-* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-#include "DialogControlState.h"
-#include "Exception.h"
-
-#include "Actor.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "DialogCharacter.h"
-#include "DialogSubsystem.h"
-#include "DialogWindow.h"
-#include "InputManager.h"
-#include "MeshAnimation.h"
-#include "MeshObject.h"
-#include "Person.h"
-#include "PhysicalThing.h"
-#include "Sound.h"
-#include "SoundDriver.h"
-#include "SoundManager.h"
-#include "SoundObject.h"
-#include "SubtitleWindow.h"
-#include "WindowFactory.h"
-#include "WindowManager.h"
-#include "World.h"
-
-#include <OgreSceneManager.h>
-#include <OgreNewt_Body.h>
-
-using namespace Ogre;
-
-namespace rl {
-
-    DialogControlState::DialogControlState(CommandMapper* cmdMapper,
-        Actor* camera, Person* character)
-        : ControlState(cmdMapper, camera, character, CST_DIALOG),
-        mTargetCameraPosition(Vector3::ZERO),
-        mTargetCameraDirection(Vector3::UNIT_Z),
-        mCurrFadeTextTime(0),
-        mTotalFadeTextTime(0),
-        mText(),
-        mDialogMode(DM_FRONT),
-        mTextShown(false),
-        mDialogWindow(NULL),
-        mSubtitleWindow(NULL),
-        mSoundObject(NULL),
-        mTalkAnimation(NULL),
-        mSubtitleSpeed(1.0f)
-    {
-        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
-            "General", "Subtitle Speed");
-
-    }
-
-    DialogControlState::~DialogControlState()
-    {
-        delete mSoundObject;
-    }
-
-    void DialogControlState::pause()
-    {
-        if(mDialogPartner)
-        {
-            MeshObject* mesh = dynamic_cast<MeshObject*>(mDialogPartner->getControlledObject());
-            if (mesh != NULL)
-            {
-                mesh->stopAllAnimations();
-                if (mesh->hasAnimation("idle"))
-                {
-                    mTalkAnimation = mesh->startAnimation("idle");
-                }
-            }
-        }
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCharacterActor->getPhysicalThing()->unfreeze();
-        mDialogWindow->setVisible(false, false);
-        mSubtitleWindow->setVisible(false, false);
-    }
-
-    void DialogControlState::resume()
-    {
-        mCharacterActor->setVisible(true);
-
-        mCameraActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->freeze();
-        Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
-        ogreCam->setFixedYawAxis(true);
-        ogreCam->setPosition(Vector3::ZERO);
-        ogreCam->setOrientation(Quaternion::IDENTITY);
-        mCameraActor->_getSceneNode()->setFixedYawAxis(true);
-
-        DialogCharacter* bot = DialogSubsystem::getSingleton().getCurrentDialogCharacter();
-        bot->setDialogCharacter(mCharacter);
-		mDialogPartner = bot->getDialogPartner()->getActor();
-
-        recalculateCamera( mDialogPartner, mCharacterActor );
-
-        mSubtitleWindow = WindowFactory::getSingleton().getSubtitleWindow();
-
-        mDialogWindow = WindowFactory::getSingleton().getDialogWindow();
-        mDialogWindow->initialize(this, bot);
-		mDialogWindow->start();
-    }
-
-    void DialogControlState::run(Real elapsedTime)
-    {
-        if( elapsedTime <= 0.0 )
-            return;
-
-        // Aktuellen Abstand zur gew?nschten Position berechnen
-        Vector3 posDistance = (mTargetCameraPosition - mCameraActor->_getSceneNode()->getPosition());
-        // Ist eine Anpassung n?tig?
-        if( posDistance != Vector3::ZERO )
-        {
-            // Die Kameraanpassgeschwindigkeit
-            Real speed = 1/elapsedTime;
-            mCameraActor->setPosition(mTargetCameraPosition);
-        }
-
-        mCameraActor->setOrientation( Quaternion::IDENTITY );
-        mCameraActor->_getSceneNode()->setDirection( mTargetCameraDirection );
-        mCameraActor->_getSceneNode()->_update( true, false );
-
-        // Textanzeigedauer
-        if (mCurrFadeTextTime >= 0)
-        {
-            mCurrFadeTextTime -= elapsedTime;
-        }
-
-        if (mTextShown && mCurrFadeTextTime <= 0)
-        {
-            mCurrFadeTextTime = 0;
-            mTotalFadeTextTime = 0;
-            mTextShown = false;
-               if (mSoundObject)
-            {
-                mSoundObject->stop();
-            }
-            mSubtitleWindow->setVisible(false, false);
-            mDialogWindow->textFinished();
-        }
-
-        LOG_DEBUG(Logger::UI,
-                StringConverter::toString(mSubtitleWindow->getWindow()->getEffectiveAlpha())
-                + ": "
-                + mSubtitleWindow->getText()
-                + CeGuiString(mSubtitleWindow->getWindow()->isVisible() ? "vis" : "unvis")
-                + ", Time: "
-                + StringConverter::toString(mCurrFadeTextTime));
-    }
-
-    void DialogControlState::recalculateCamera( Actor* speaker, Actor* listener )
-    {
-        // Position camera at position between char and dialog partner
-        Vector3 charEyes = speaker->getWorldPosition();
-        // Modify by MeshBounds
-        if( speaker->getControlledObject()->isMeshObject() )
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(speaker->getControlledObject());
-            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            charEyes += speaker->getWorldOrientation()*offset;
-        }
-
-        Vector3 partEyes = listener->getWorldPosition();
-        // Modify by MeshBounds
-        if( listener->getControlledObject()->isMeshObject() )
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(listener->getControlledObject());
-            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            partEyes += listener->getWorldOrientation()*offset;
-        }
-
-        Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
-
-        // Weltkoordinaten in lokale umwandeln
-        mTargetCameraPosition =
-            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
-            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
-
-
-        mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
-    }
-
-    float DialogControlState::getShowTextLength(const CeGuiString& text) const
-    {
-        return 0.019f * text.length() + // Zeit f?rs Text lesen
-               0.25f;                   // Fade in
-    }
-
-    void DialogControlState::response(
-        Actor* actor, const CeGuiString& text, const Ogre::String& soundFile)
-    {
-        if( actor == mDialogPartner )
-            recalculateCamera( mCharacterActor, mDialogPartner );
-        else
-            recalculateCamera( mDialogPartner, mCharacterActor );
-
-        // Ungef?hre Lesedauer bestimmen
-        float fadeTime = getShowTextLength(text);
-        if (soundFile.length() == 0)
-        {
-            float speed = mSubtitleSpeed;
-
-            if( mSubtitleSpeed == 0.0 )
-                speed = 1.0;
-
-            mCurrFadeTextTime = fadeTime*speed;
-            mTotalFadeTextTime = fadeTime*speed;
-        }
-        else
-        {
-            if( mSoundObject != NULL )
-                mSoundObject->getMovableObject()->getParentSceneNode()->detachObject(
-                    mSoundObject->getMovableObject() );
-
-            delete mSoundObject;
-            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()->
-                    createSound(soundFile, ST_SAMPLE), soundFile);
-
-            // An Sprecher h?ngen
-            actor->_getSceneNode()->attachObject( mSoundObject->getMovableObject() );
-            actor->_getSceneNode()->_update( true, false );
-            mSoundObject->_setActor( actor );
-            mSoundObject->set3d(true);
-            mSoundObject->play();
-            mSoundObject->_update();
-
-
-            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject->getLength());
-            mTotalFadeTextTime = mCurrFadeTextTime;
-        }
-
-        MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
-        if (mesh != NULL)
-        {
-            if (mesh->hasAnimation("reden"))
-            {
-                mesh->stopAllAnimations();
-                mTalkAnimation = mesh->startAnimation("reden");
-            }
-        }
-
-        LOG_DEBUG(Logger::UI,
-            "Response: "
-                + actor->getName()
-                + " File: '"
-                + soundFile
-                + "', Text: '" + text + "', Time: "
-                + StringConverter::toString(mCurrFadeTextTime));
-
-
-        mTextShown = true;
-
-        if (mSubtitleWindow != NULL && !text.empty())
-        {
-            mSubtitleWindow->show(text);
-        }
-    }
-
-    bool DialogControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id)
-    {
-
-        if (mTextShown && (mCurrFadeTextTime + 0.25) < mTotalFadeTextTime)
-        {
-            mCurrFadeTextTime = -1;
-
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-
-    }
-}

Copied: rl/trunk/engine/ui/src/DialogControlState.cpp (from rev 3571, rl/trunk/engine/ui/src/DialogCharacterController.cpp)



From tanis at mail.berlios.de  Mon Jul  2 22:08:08 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:08:08 +0200
Subject: [Dsa-hl-svn] r3573 - rl/trunk/engine/ui/src
Message-ID: <200707022008.l62K88P2008308@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:08:00 +0200 (Mon, 02 Jul 2007)
New Revision: 3573

Added:
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
Removed:
   rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-07-02 20:07:19 UTC (rev 3572)
+++ rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp	2007-07-02 20:08:00 UTC (rev 3573)
@@ -1,318 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-#include "FreeflightControlState.h"
-
-#include "CoreSubsystem.h"
-#include "ConfigurationManager.h"
-#include "Exception.h"
-#include "Actor.h"
-#include "PhysicalThing.h"
-#include "World.h"
-#include "CameraObject.h"
-#include "InputManager.h"
-#include "CommandMapper.h"
-#include "MeshObject.h"
-
-#include <OgreSceneManager.h>
-
-using namespace Ogre;
-
-namespace rl {
-
-	FreeflightControlState::FreeflightControlState(CommandMapper* cmdMapper,
-        Actor* camera, Person* character)
-		: ControlState(cmdMapper, camera, character, CST_FREEFLIGHT),
-		mMovementSpeed(5.0f),
-		mSpeedRange(0.03f, 90.0f),
-		mSpeedIncrement(0.02f),
-		mRotationSpeed(4.0f),
-		mCurrentMovementState(0),
-        mDesiredVelocity(Vector3::ZERO),
-        mCollisionsEnabled(false),
-        mPitchRange(Degree(-89), Degree(89)),
-        mCameraUpConstraint(Vector3::ZERO),
-        mYaw(Degree(0)),
-        mPitch(Degree(0))
-	{
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
-	}
-
-	FreeflightControlState::~FreeflightControlState()
-	{
-	}
-
-    void FreeflightControlState::pause()
-    {
-		mCameraActor->getPhysicalThing()->unfreeze();
-        if(mCameraUpConstraint != Vector3::ZERO)
-            mCameraActor->getPhysicalThing()->setUpConstraint(mCameraUpConstraint);
-		mCharacterActor->getPhysicalThing()->unfreeze();
-        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-
-        // Char<->Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        // Char<->Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-    }
-
-    void FreeflightControlState::resume()
-    {
-        mCameraActor->getPhysicalThing()->freeze();
-        mCameraUpConstraint = mCameraActor->getPhysicalThing()->getUpConstraint();
-		mCharacterActor->getPhysicalThing()->freeze();
-
-        resetCamera();
-
-        // The actor should be controlled manually,
-        // so let the PM prepare it accordingly
-        mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        // We also handle char<->level, char<->default collision from now on (camera=char!)
-        PhysicsManager::getSingleton().getMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"))->setContactCallback(this);
-        PhysicsManager::getSingleton().getMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"))->setContactCallback(this);
-        PhysicsManager::getSingleton().getMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"))->setContactCallback(this);
-    }
-
-	void FreeflightControlState::run(Real elapsedTime)
-	{
-        if (isCeguiActive()) return;
-
-		InputManager* im = InputManager::getSingletonPtr();
-
-		// Fetch current movement state
-		mDesiredVelocity = Vector3::ZERO;
-
-		int movement = mCurrentMovementState;
-
-		// Determine character's control state based on user input
-		if (movement & MOVE_FORWARD)
-        {
-			mDesiredVelocity.z = -mMovementSpeed;
-        }
-
-		if (movement & MOVE_BACKWARD)
-        {
-            mDesiredVelocity.z = mMovementSpeed;
-        }
-
-		if (movement & MOVE_RIGHT)
-        {
-			mDesiredVelocity.x = mMovementSpeed;
-        }
-
-		if (movement & MOVE_LEFT)
-        {
-			mDesiredVelocity.x = -mMovementSpeed;
-        }
-
-		if (movement & MOVE_RUN)
-        {
-			mDesiredVelocity *= 10.0;
-        }
-
-        if (movement & MOVE_JUMP)
-        {
-            // put character here
-            if( mCharacterActor != NULL )
-            {
-                mCharacterActor->setPosition(
-                    mCameraActor->getPosition()
-                    + mCameraActor->getWorldOrientation() * Vector3::NEGATIVE_UNIT_Z * 2 
-                    - 1.5 * Vector3::UNIT_Y);
-            }
-        }
-
-		mMovementSpeed += im->getMouseRelativeZ() * mSpeedIncrement;
-		if (mMovementSpeed < mSpeedRange.first)
-		{
-			mMovementSpeed = mSpeedRange.first;
-		}
-		if (mMovementSpeed > mSpeedRange.second)
-		{
-			mMovementSpeed = mSpeedRange.second;
-		}
-
-
-        if (movement & TURN_LEFT)
-            mYaw += elapsedTime * Degree(120.0f);
-        if (movement & TURN_RIGHT)
-            mYaw -= elapsedTime * Degree(120.0f);
-
-        // mouse
-        if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
-        {
-            mYaw -= mMouseSensitivity * Degree(im->getMouseRelativeX() / 10);
-        }
-        while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
-        while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
-
-
-        if (mInvertedMouse)
-            mPitch += mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
-        else
-            mPitch -= mMouseSensitivity * Degree(im->getMouseRelativeY() / 4);
-
-        while (mPitch.valueDegrees() > 360.0f) mPitch -= Degree(360.0f);
-        while (mPitch.valueDegrees() < -360.0f) mPitch += Degree(360.0f);
-        if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-        if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
-
-        mCameraActor->setOrientation(Quaternion::IDENTITY);
-        mCameraActor->getPhysicalThing()->clearUpConstraint();
-        mCameraActor->yaw(mYaw.valueDegrees());
-        mCameraActor->pitch(mPitch.valueDegrees());
-    }
-
-	void FreeflightControlState::toggleCameraCollision()
-	{
-		// with or without collision?
-        // be careful to enable collision if beeing in another collision
-        mCollisionsEnabled = !mCollisionsEnabled;
-	}
-
-	void FreeflightControlState::resetCamera()
-	{
-		// Position camera at char position
-        if( mCharacterActor != NULL )
-        {
-            mCameraActor->setOrientation(Quaternion::IDENTITY);
-            Vector3 newPos = mCharacterActor->getWorldPosition();
-            if( mCharacterActor->getControlledObject()->isMeshObject() )
-            {
-                MeshObject* mo = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-                newPos.y += mo->getDefaultSize().getMaximum().y;
-            }
-		    mCameraActor->_getSceneNode()->setPosition( newPos );
-        }
-        else
-        {
-		    mCameraActor->setOrientation( Quaternion::IDENTITY );
-            mCameraActor->setPosition( Vector3::ZERO );
-        }
-        mYaw = Degree(0);
-        mPitch = Degree(0);
-	}
-
-    bool FreeflightControlState::keyPressed(const OIS::KeyEvent& evt)
-	{
-        int movement = mCommandMapper->getMovement(evt.key);
-
-		if (movement != MOVE_NONE)
-		{
-			mCurrentMovementState |= movement;
-			return true;
-		}
-
-		return false;
-	}
-
-    bool FreeflightControlState::keyReleased(const OIS::KeyEvent& evt)
-	{
-        int movement = mCommandMapper->getMovement(evt.key);
-
-		if (movement != MOVE_NONE)
-		{
-			mCurrentMovementState &= ~movement;
-			return true;
-		}
-        else
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int keycode = CommandMapper::encodeKey(evt.key, im->getModifierCode());
-            CeGuiString command = mCommandMapper->getControlStateAction(keycode, CST_FREEFLIGHT);
-            if (command == "back_to_character_movement")
-            {
-                InputManager::getSingleton().popControlState();
-                return true;
-            }
-            if (command == "toggle_camera_collision")
-            {
-                toggleCameraCollision();
-                return true;
-            }
-            else 
-            {
-                return ControlState::keyReleased(evt);
-            }
-        }
-	}
-
-    int FreeflightControlState::userProcess()
-    {
-        if (m_body0 == mCamBody || m_body1 == mCamBody)
-        {
-            // this is camera collision
-
-            if( !mCollisionsEnabled )
-                return 0;
-
-            setContactSoftness(1.0f);  // "weiche" Collision
-            setContactElasticity(0.0f);
-
-            return 1;
-        }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
-    }
-
-
-
-    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        OgreNewt::Body* body = thing->_getBody();
-
-        // Get the current world timestep
-        Real timestep = world->getTimeStep();
-
-        if (body == mCamBody)
-        {
-            // apply camera force
-            Vector3 position;
-            Quaternion orientation;
-            body->getPositionOrientation(position, orientation);
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            body->getMassMatrix(mass, inertia);
-
-
-            // Get the velocity vector
-            Vector3 currentVel = body->getVelocity();
-            Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
-            Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
-
-            body->setForce(force);
-        }
-    }
-
-}

Copied: rl/trunk/engine/ui/src/FreeflightControlState.cpp (from rev 3572, rl/trunk/engine/ui/src/FreeFlightCharacterController.cpp)



From tanis at mail.berlios.de  Mon Jul  2 22:09:27 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:09:27 +0200
Subject: [Dsa-hl-svn] r3574 - rl/trunk/engine/ui/src
Message-ID: <200707022009.l62K9Rsf008457@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:09:19 +0200 (Mon, 02 Jul 2007)
New Revision: 3574

Added:
   rl/trunk/engine/ui/src/MovementControlState.cpp
Removed:
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 20:08:00 UTC (rev 3573)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 20:09:19 UTC (rev 3574)
@@ -1,1255 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-#include "MovementControlState.h"
-
-#include <OgreSceneManager.h>
-#include <OgreAxisAlignedBox.h>
-#include <OgreStringConverter.h>
-#include <OgreMath.h>
-#include <OgreEntity.h>
-#include <OgreCamera.h>
-#include <OgreSceneNode.h>
-#include <OgreSceneQuery.h>
-#include <utility>
-
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "DebugWindow.h"
-#include "Exception.h"
-#include "InputManager.h"
-#include "Logger.h"
-#include "MeshObject.h"
-#include "MeshAnimation.h"
-#include "MovementControlState.h"
-#include "Person.h"
-#include "PhysicsManager.h"
-#include "PhysicsMaterialRaycast.h"
-#include "PhysicalThing.h"
-#include "World.h"
-#include "LineSetPrimitive.h"
-#include "WindowFactory.h"
-#include "AnimationManager.h"
-#include "UiSubsystem.h"
-
-#include <numeric>
-
-using namespace Ogre;
-
-namespace rl {
-
-    String MovementControlState::msDebugWindowPageName = "MovementControlState";
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Person* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mMovingCreature(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 1.0f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(
-            mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb = charMesh->getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
-        {
-            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        if( mMovingCreature != NULL )
-        {
-            delete mMovingCreature;
-            mMovingCreature = NULL;
-        }
-
-        // actors aren't controlled anymore
-        //mCharacterActor->getPhysicalThing()->setPhysicsController(NULL);
-        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-        // cam<->Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        // cam<->Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL && go->isHighlighted())
-        {
-            go->setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if( mMovingCreature == NULL )
-            mMovingCreature = new MovingCreature(mCharacter);
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().createMaterialID("camera"));
-        mCameraActor->getPhysicalThing()->setPhysicsController(this);
-
-        // We also handle cam<->level, cam<->default cam<->char collision from now on
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"))->setContactCallback(this);
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"))->setContactCallback(this);
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"))->setContactCallback(this);
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        if (isCeguiActive()) return;
-
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (mInvertedMouse)
-            mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-        else
-            mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-        if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-        if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor->getWorldPosition();
-        Quaternion charOri = mCharacterActor->getWorldOrientation();
-        //mCharBody->getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear())
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mMovingCreature != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen->calculateBaseVelocity(baseVelocity) )
-            {
-                Degree baseVel(baseVelocity*360);
-                if (movement & TURN_LEFT)
-                    rotation = elapsedTime * baseVel;
-                if (movement & TURN_RIGHT)
-                    rotation = -elapsedTime * baseVel;
-
-                // mouse
-                if( !isCeguiActive() && mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                {
-                    if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
-                    {
-                        rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
-                    }
-                }
-
-
-                // virtual yaw
-                Degree newVirtualYaw(0);
-                if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                    ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                {
-                    newVirtualYaw = Degree(45);
-                }
-                if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                    ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                {
-                    newVirtualYaw = Degree(-45);
-                }
-                if( mCamVirtualYaw != newVirtualYaw )
-                {
-                    rotation += mCamVirtualYaw - newVirtualYaw;
-                    mCamVirtualYaw = newVirtualYaw;
-                }
-            }
-
-
-
-            if( movement & MOVE_SNEAK )
-            {
-                Vector3 direction(Vector3::ZERO);
-                if (movement & MOVE_FORWARD)
-                    direction.z = -1;
-                else if( movement & MOVE_BACKWARD)
-                    direction.z = 1;
-                mMovingCreature->setMovement(
-                    MovingCreature::MT_SCHLEICHEN,
-                    direction,
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if( movement & MOVE_JUMP && 
-                mMovingCreature->getMovementFromId(MovingCreature::MT_HOCHSPRUNG)->isPossible() )
-            {
-                MovingCreature::MovementType type = MovingCreature::MT_HOCHSPRUNG;
-                Vector3 direction = Vector3::UNIT_Y;
-                if( movement & MOVE_FORWARD )
-                {
-                    type = MovingCreature::MT_WEITSPRUNG;
-                    direction += Vector3::NEGATIVE_UNIT_Z;
-                }
-                mMovingCreature->setMovement(
-                    type,
-                    direction,
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if( movement & MOVE_FORWARD )
-            {
-                MovingCreature::MovementType type = MovingCreature::MT_GEHEN;
-                if( movement & MOVE_RUN_LOCK )
-                {
-                    if( movement & MOVE_RUN )
-                        type = MovingCreature::MT_RENNEN;
-                    else
-                        type = MovingCreature::MT_LAUFEN;
-                }
-                else
-                {
-                    if( movement & MOVE_RUN )
-                        type = MovingCreature::MT_GEHEN;
-                    else
-                        type = MovingCreature::MT_JOGGEN;
-                }
-                mMovingCreature->setMovement(
-                    type,
-                    Vector3(0,0,-1), 
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if (movement & MOVE_BACKWARD )
-            {
-                MovingCreature::MovementType type = MovingCreature::MT_RUECKWAERTS_GEHEN;
-                if( !(movement & MOVE_RUN) )
-                    type = MovingCreature::MT_RUECKWAERTS_JOGGEN;
-                mMovingCreature->setMovement(
-                    type,
-                    Vector3(0,0,1), 
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
-            {
-                Vector3 direction = Vector3::UNIT_X;
-                if( movement & MOVE_LEFT )
-                    direction = Vector3::NEGATIVE_UNIT_X;
-                mMovingCreature->setMovement(
-                    MovingCreature::MT_SEITWAERTS_GEHEN,
-                    direction, 
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else
-            {
-                mMovingCreature->setMovement(
-                    MovingCreature::MT_STEHEN, 
-                    Vector3(0,0,0),
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
-        if (mDesiredDistance < mDistanceRange.first)
-        {
-            mDesiredDistance = mDistanceRange.first;
-        }
-        if (mDesiredDistance > mDistanceRange.second)
-        {
-            mDesiredDistance = mDistanceRange.second;
-        }
-
-        if( !isCeguiActive() && mViewMode == VM_FREE_CAMERA )
-        {
-            mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
-
-            while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
-            while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
-        }
-
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode->lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-            // Kamera-Gr?e beziehen
-            CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-            AxisAlignedBox aabb = ogreCam->getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
-
-            cameraNode->lookAt(
-                charPos
-                + charOri * virtualCamOri *  mLookAtOffset
-                + charOri * virtualCamOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA )
-        {
-            cameraNode->lookAt(
-                charPos + charOri * virtualCamOri * mLookAtOffset,
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody->getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody->getCollision(), camOri, camPos,
-                    mCharBody->getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor->setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor->setVisible(true);
-            }
-        }
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to MovingCreature(Manager)
-    int MovementControlState::userProcess()
-    {
-        // only camera collision
-        return 0;
-    
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        setContactSoftness(1.0f);
-        setContactElasticity(0.0f);
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to MovingCreature
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to MovingCreature?
-        SceneNode* node = mCharacterActor->_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node->getPosition();
-        Quaternion egal;
-        mCamBody->getPositionOrientation(bodpos,egal);
-        static Real maxHeight(0);
-        if( playpos.y > maxHeight )
-            maxHeight = playpos.y;
-        ss
-            << "scene node : " << playpos << std::endl
-            << "player max Height : " << maxHeight << std::endl
-            << "camera posder : " << static_cast<Camera*>(
-                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-                << "camera pos : " << static_cast<Camera*>(
-                    mCameraActor->_getMovableObject())->getPosition() << std::endl
-            << "camera actor orientation : " << mCameraActor->getWorldOrientation() << std::endl
-            << "camera actor : " << mCameraActor->getWorldPosition() << std::endl
-            << "camera body pos : " << bodpos << std::endl
-            << "camera distance : " << mDesiredDistance << std::endl
-            << "is airborne: " << (mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE ? "true" : "false") << std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
-    {
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-/*
-        // Ringbuffer mit Positionen der Kamera
-        static std::vector<Ogre::Vector3> camPositionsBuffer(20);
-        static size_t camPositionsBufferIdx = -1;
-        camPositionsBufferIdx = (camPositionsBufferIdx + 1) % camPositionsBuffer.size();
-        camPositionsBuffer[camPositionsBufferIdx] = camPos;
-
-        // Ringbuffer mit optimalen Positionen der Kamera
-        static std::vector<Ogre::Vector3> camOptPositionsBuffer(20);
-        static size_t camOptPositionsBufferIdx = -1;
-        camOptPositionsBufferIdx = (camOptPositionsBufferIdx + 1) % camOptPositionsBuffer.size();
-*/
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-//        camOptPositionsBuffer[camOptPositionsBufferIdx] = optimalCamPos;
-
-
-        // Ringbuffer mit Positionen des Characters
-        static std::vector<Ogre::Vector3> charPositionsBuffer(20);
-        static size_t charPositionsBufferIdx = -1;
-        charPositionsBufferIdx = (charPositionsBufferIdx + 1) % charPositionsBuffer.size();
-        charPositionsBuffer[charPositionsBufferIdx] = charPos;
-
-
-        static Real characterOccludedTime = 0;
-        static unsigned int characterOccludedFrameCount = 0;
-
-
-
-        // Kamera-Gr?e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-            mCameraActor->getControlledObject());
-        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr?e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr?e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
-            {
-                characterOccludedTime += timestep;
-                characterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( characterOccludedTime > 0.500f && characterOccludedFrameCount > 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                characterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Ann?erung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos + camRadius * normToOptCamPos, // Gr?e der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n?er an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt k?nen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Gr?e der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            static bool isPathfinding (false);
-            static unsigned int lastReachableBufPos;
-            // gibt an, ob schon gebufferte Daten fr den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
-                // und durch "Geraden" miteinander verbunden werden k?nen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = charPositionsBuffer.size();
-
-                if( !isPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta < buffSize )
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta >= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
-                        isPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    lastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = lastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta > 0 ) // delta = 0 braucht nicht berprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    lastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
-                }
-                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                isPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody->getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody->getMassMatrix(mass, inertia);
-
-            //mCamBody->setPositionOrientation(newCamPos, camOri);
-            mCamBody->setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody->setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool SlowlyMoveBackward, const Real &timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr?e beziehen
-            CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-            AxisAlignedBox aabb = ogreCam->getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody->getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i < 6; i++ )
-            {
-                RaycastInfo info = mRaycast->execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody && info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() < diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() < radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            static Real lastDistance(0.0f);
-            static Real TimeOfLastCollision(0.0f);
-            if( CollisionFound )
-                TimeOfLastCollision = 0.0f;
-            else
-                TimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-
-            if( SlowlyMoveBackward &&
-                desiredDistance > lastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( TimeOfLastCollision > mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = lastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = lastDistance;
-
-                if( newDistance > desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                lastDistance = newDistance;
-            }
-            else
-                lastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i < end; ++i)
-        {
-            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
-            if (creature && creature->getAlignment() == Creature::ALIGNMENT_ENEMY)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if (isCeguiActive()) return;
-
-        InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL && oldGo != newGo)
-        {
-            oldGo->setHighlighted(false);
-        }
-
-        if (newGo != NULL && newGo != oldGo)
-        {
-            newGo->setHighlighted(true);
-        }
-
-        // Optionen anzeigen
-        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
-        {
-            newGo->doDefaultAction(mCharacter, NULL);
-        }
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-            aabb = charMesh->getPoseSize("Idle");
-        }
-        catch(...)
-        {
-            aabb = charMesh->getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
-            resetCamera();
-        }
-        else // mode == VM_FREE_CAMERA
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr?e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        aab = mesh->getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh->getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr?e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor->setVisible(false);
-        else
-            mCharacterActor->setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, "Camera resetted.");
-        ///@todo remove this
-        mCharacter->modifyAu(100);
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt)
-    {
-        if (ControlState::keyPressed(evt)) return true;
-
-        int movement = mCommandMapper->getMovement(evt.key);
-
-        if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
-        {
-            mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-            movement &= ~MOVE_RUN_LOCK;
-        }
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState |= movement;
-            return true;
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt)
-    {
-        // CEGUI is handled by base class, so hand it down if necessary.
-        if (sendKeyToCeGui(evt))
-        {
-            return ControlState::keyReleased(evt);
-        }
-
-        int movement = mCommandMapper->getMovement(evt.key);
-
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
-            return true;
-        }
-        else
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int keycode = CommandMapper::encodeKey(evt.key, im->getModifierCode());
-            CeGuiString command = mCommandMapper->getControlStateAction(keycode, CST_MOVEMENT);
-            if (command == "freeflight_mode")
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                return true;
-            }
-            else if (command == "reset_camera")
-            {
-                resetCamera();
-                return true;
-            }
-            else if (command == "toggle_view_mode")
-            {
-                toggleViewMode();
-                return true;
-            }
-            else
-            {
-                // Nothing we handle here, see if base class can make something of this input.
-                return ControlState::keyReleased(evt);
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id)
-    {
-        if (!isCeguiActive())
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        else
-        {
-            return ControlState::mouseReleased(evt, id);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode->getParent() == NULL)
-        {
-            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        lineSet->clear();
-        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-}

Copied: rl/trunk/engine/ui/src/MovementControlState.cpp (from rev 3573, rl/trunk/engine/ui/src/MovementCharacterController.cpp)



From tanis at mail.berlios.de  Mon Jul  2 22:17:19 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:17:19 +0200
Subject: [Dsa-hl-svn] r3575 - rl/trunk/engine/ui
Message-ID: <200707022017.l62KHJGZ009445@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:17:13 +0200 (Mon, 02 Jul 2007)
New Revision: 3575

Modified:
   rl/trunk/engine/ui/RlUI2005.vcproj
Log:


Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-02 20:09:19 UTC (rev 3574)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-02 20:17:13 UTC (rev 3575)
@@ -342,7 +342,7 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\CombatCharacterController.h"
+				RelativePath=".\include\CombatControlState.h"
 				>
 			</File>
 			<File
@@ -354,15 +354,15 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\CutsceneCharacterController.h"
+				RelativePath=".\include\CutsceneControlState.h"
 				>
 			</File>
 			<File
-				RelativePath=".\include\DialogCharacterController.h"
+				RelativePath=".\include\DialogControlState.h"
 				>
 			</File>
 			<File
-				RelativePath=".\include\FreeFlightCharacterController.h"
+				RelativePath=".\include\FreeflightControlState.h"
 				>
 			</File>
 			<File
@@ -374,7 +374,7 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\MovementCharacterController.h"
+				RelativePath=".\include\MovementControlState.h"
 				>
 			</File>
 			<File
@@ -539,7 +539,7 @@
 			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
 			>
 			<File
-				RelativePath=".\src\CombatCharacterController.cpp"
+				RelativePath=".\src\CombatControlState.cpp"
 				>
 			</File>
 			<File
@@ -551,15 +551,15 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\CutsceneCharacterController.cpp"
+				RelativePath=".\src\CutsceneControlState.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\src\DialogCharacterController.cpp"
+				RelativePath=".\src\DialogControlState.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\src\FreeFlightCharacterController.cpp"
+				RelativePath=".\src\FreeflightControlState.cpp"
 				>
 			</File>
 			<File
@@ -571,7 +571,7 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\MovementCharacterController.cpp"
+				RelativePath=".\src\MovementControlState.cpp"
 				>
 			</File>
 			<File



From tanis at mail.berlios.de  Mon Jul  2 22:21:31 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:21:31 +0200
Subject: [Dsa-hl-svn] r3576 - rl/trunk/engine/rules/include
Message-ID: <200707022021.l62KLV9f009833@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:21:15 +0200 (Mon, 02 Jul 2007)
New Revision: 3576

Added:
   rl/trunk/engine/rules/include/CreatureController.h
Removed:
   rl/trunk/engine/rules/include/MovingCreature.h
Log:
Renamed remotely

Copied: rl/trunk/engine/rules/include/CreatureController.h (from rev 3575, rl/trunk/engine/rules/include/MovingCreature.h)

Deleted: rl/trunk/engine/rules/include/MovingCreature.h
===================================================================
--- rl/trunk/engine/rules/include/MovingCreature.h	2007-07-02 20:17:13 UTC (rev 3575)
+++ rl/trunk/engine/rules/include/MovingCreature.h	2007-07-02 20:21:15 UTC (rev 3576)
@@ -1,274 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-
-#ifndef __MovingCreature_H__
-#define __MovingCreature_H__
-
-#include "RulesPrerequisites.h"
-#include "PhysicsController.h"
-#include "PhysicsGenericContactCallback.h"
-#include "Creature.h"
-#include "Actor.h"
-#include <map>
-
-
-
-namespace rl
-{
-    class AbstractMovement;
-    class MovingCreatureManager;
-    class MeshAnimation;
-
-    /** 
-     * This class provides an interface to control the movement of a creature.
-     * It handles all nessessary things like animations and calculates the movement speed.
-     */
-    class _RlRulesExport MovingCreature :
-        public PhysicsController,
-        public PhysicsGenericContactCallback
-    {
-    public:
-        /** Constructor.
-		 * @param creature the creature of the bot/char
-		 * @param actor the actor of the bot/char
-		 */
-        MovingCreature(Creature *character);
-        ~MovingCreature();
-
-        /**
-         * This function is not intented to be called directly
-         * @retval true, if this MovingCreature still needs to be called every frame
-         */
-        bool run(Ogre::Real elapsedTime);
-
-        /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
-
-        /// Newton contact callback called by the movingCreatureManager
-        int userProcess();
-
-        Creature *getCreature() {return mCreature;}
-
-        /** 
-         * the different movements a creature can perform, 
-         * there must be an adequate movement-class
-         * (derived from AbstractMovement)
-         */
-        typedef enum
-        {
-            // these movements can be used
-            MT_NONE,
-            MT_STEHEN,
-            MT_GEHEN,
-            MT_JOGGEN,
-            MT_LAUFEN,
-            MT_RENNEN,
-            MT_RUECKWAERTS_GEHEN,
-            MT_RUECKWAERTS_JOGGEN,
-            MT_SEITWAERTS_GEHEN,
-            MT_SCHLEICHEN,
-            MT_HOCHSPRUNG,
-            MT_WEITSPRUNG,
-            // these movements are only for internal purposes and should not be used directly
-            // instead use one of the movements above
-            MT_DREHEN
-        } MovementType;
-
-        /// The generalization of the place (in the air, on the floor, in the water...)
-        typedef enum { 
-            AL_AIRBORNE, // the creature is floating/falling in the air
-            AL_FLOOR // the creature is standing/lying/moving/... on the floor
-        } AbstractLocation;
-
-        /**
-         * sets wether the creature is airborne or not
-         * this is done by this class itself every frame, so using this method does probably not
-         * have the desired effect
-         */
-        void setAbstractLocation(AbstractLocation type) {mAbstractLocation = type;}
-
-        AbstractLocation getAbstractLocation() const {return mAbstractLocation;}
-
-
-        /**
-         * the most important function: sets a new movement or changes the direction or rotation of a movement
-         * if this movement isn't possible, the fallback-movement is called.
-         * The movement doesn't change until another movement is set, so it is not necessary to call this function 
-         * every frame. Only the rotation is resettet to zero every new frame!
-         * @param type the id of the movement
-         * @param direction if the direction isn't possible (see AbstractMovement::isDirectionPossible), only a "part" of the direction is applied
-         * @param rotation like above
-         * @retval false signifies that the change to this movement was not possible (possibly because the present movement forbade it)
-         */
-        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
-
-
-        MovementType getMovementId() const;
-        Ogre::Vector3 getDirection() const {return mDirection;}
-
-        /// This function does probably not return the expected value, because the rotation is resetted every frame!
-        Ogre::Vector3 getRotation() const {return mRotation;}
-
-        /// This function can return NULL
-        AbstractMovement *getMovement() {return mMovement;}
-
-        /// This function can return NULL
-        AbstractMovement *getMovementFromId(MovementType id);
-
-        // some methods used by movements
-        int getCurrentGS() const;
-        Ogre::Vector3 getVelocity() const; // in local axes
-        Ogre::Vector3 getOmega() const;
-        MeshAnimation *setAnimation(const Ogre::String &name, 
-                          Ogre::Real speed = 1, 
-                          unsigned int timesToPlay = 0, 
-                          const Ogre::String &collisionName = "", // the name of the animation the collision is based on
-                          Ogre::Real weight = 1 // the weight of the animation, the weight of the last animation is set to 1-weight
-                          );
-
-
-        /// this method will return the yaw, the creature tries to turn to, if a rotation-movement is activated. if not, it will return the current yaw
-        Ogre::Radian getYaw();
-        Ogre::Real getLastMovementChange() const { return mLastMovementChange; }
-        MovementType getLastMovementType() const { return mLastMovementType; }
-        Ogre::Real getAnimationTimePlayed() const; // this is a relative value between 0 and 1
-
-
-    protected:
-        Creature *mCreature;
-        AbstractLocation mAbstractLocation;
-        
-        AbstractMovement *mMovement;
-        MovementType mLastMovementType;
-        Ogre::Real mLastMovementChange;
-        Ogre::Vector3 mDirection;
-        Ogre::Vector3 mRotation;
-
-        typedef std::map<MovementType, AbstractMovement*> MovementMap;
-        MovementMap mMovementMap;
-
-        // in order to copy the contactcallback members correctly;
-        friend class MovingCreatureManager;
-
-    private:
-        // only used in setAnimation
-        Ogre::String mLastAnimationName;
-        Ogre::String mLastCollisionName;
-        Ogre::Real mLastAnimationSpeed;
-        Ogre::String mStillWeightedAnimationName;
-
-        // only used in userProcess
-        Ogre::Real mLastFloorContact;
-
-    };
-
-    /// this is the base class of all movements
-    class AbstractMovement : 
-        public OgreNewt::ContactCallback
-    {
-    public:
-        AbstractMovement(MovingCreature *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
-
-        /// returns the id of this movement
-        virtual MovingCreature::MovementType getId() const = 0;
-
-        /// returns the id of the movement that is used, if this movement isn't possible (any more)
-        virtual MovingCreature::MovementType getFallBackMovement() const = 0;
-
-        /**
-         * this method calculates the basis velocity (without any changes due to Talentproben etc)
-         * @param velocity this parameter returns the calculated "velocity" ( m/s, rpm, or width/height of a jump)
-         * @retval false indicates, that this movement isn't possible, so the calculated values can be incorrect
-         */
-        virtual bool calculateBaseVelocity(Ogre::Real &velocity) = 0;
-
-        /**
-         * this method specifies, if the movement is possible
-         */
-        virtual bool isPossible() const = 0;
-
-        /**
-         * this method is called, when this movement is currently used to enable 
-         * an individual procession of collisions contacts for each movement
-         */
-        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
-
-        /**
-         * this method is called by OnApplyTorqueAndForceCallback of the MovingCreature
-         * the PhysicalThing can be acquired via the Creature
-         */
-        virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep) = 0;
-
-        /**
-         * this method indicates if it is possible to change to the specified movement at this moment
-         */
-        virtual bool canChangeToMovement(MovingCreature::MovementType id) {return true;}
-
-        /**
-         * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
-         */
-        virtual void requestChangeToMovement(MovingCreature::MovementType id) {}
-
-        /**
-         * here all the stuff not (directly) relating the physics should be done
-         * this function is called every frame if this movement is activated and the
-         * Creature is in an active moving state. It is important to handle all 
-         * "Talentproben" etc here and not in the physics function!
-         * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
-         * @retval true indicates that the creature should remain active (in order to activate it use MovingCreatureManager::setActive)
-         */
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
-
-        /**
-         * this function is called if this movement is activated.
-         * it can be used to determine if a new "Talentprobe" is needed
-         * if you ovveride it, please make sure to call the base class method
-         */
-        virtual void activate() {mActive = true;}
-
-        /**
-         * this function is called every time this movement is deactivated.
-         * if you ovveride it, please make sure to call the base class method
-         */
-        virtual void deactivate() {mActive = false;}
-
-        /**
-         * this method is used to get to know if a movement can be used with a certain direction
-         * @retval true if this movement can be used with the direction, false otherwise
-         * @param direction (in local axes); if this function returns false, this variable contains another valid direction (constructed from the given direction)
-         */
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const = 0;
-
-        /**
-         * this method is used to get to know if the given rotation can be used with this movement
-         * @retval true if the creature can perform this rotation with this movement
-         * @param rotation (in local axes and rpm); if the function returns false, this variable contains another valid rotation (constructed from the given rotation)
-         */
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const = 0;
-
-
-        /// this can return true even though movingcreature doesn't call this movement, but another that is using this movement
-        bool isActive() const {return mActive;}
-
-        /// this method is used to return the yaw value of rotation movemenrts etc
-        virtual Ogre::Real getMovementDefinedValue() {return 0;}
-    protected:
-        MovingCreature *mMovingCreature;
-        bool mActive;
-    };
-}
-#endif



From tanis at mail.berlios.de  Mon Jul  2 22:22:19 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:22:19 +0200
Subject: [Dsa-hl-svn] r3577 - rl/trunk/engine/rules/include
Message-ID: <200707022022.l62KMJ1I009925@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:22:12 +0200 (Mon, 02 Jul 2007)
New Revision: 3577

Added:
   rl/trunk/engine/rules/include/CreatureControllerManager.h
Removed:
   rl/trunk/engine/rules/include/MovingCreatureManager.h
Log:
Renamed remotely

Copied: rl/trunk/engine/rules/include/CreatureControllerManager.h (from rev 3576, rl/trunk/engine/rules/include/MovingCreatureManager.h)

Deleted: rl/trunk/engine/rules/include/MovingCreatureManager.h
===================================================================
--- rl/trunk/engine/rules/include/MovingCreatureManager.h	2007-07-02 20:21:15 UTC (rev 3576)
+++ rl/trunk/engine/rules/include/MovingCreatureManager.h	2007-07-02 20:22:12 UTC (rev 3577)
@@ -1,83 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-
-#ifndef __MovingCreatureManager_H__
-#define __MovingCreatureManager_H__
-
-#include "RulesPrerequisites.h"
-#include "GameTask.h"
-#include "PhysicsGenericContactCallback.h"
-#include <vector>
-#include <map>
-
-
-
-namespace rl
-{
-    class MovingCreature;
-
-    class _RlRulesExport MovingCreatureManager : 
-        public GameTask,
-        public Ogre::Singleton<MovingCreatureManager>,
-        public PhysicsGenericContactCallback
-    {
-    public:
-        MovingCreatureManager();
-        ~MovingCreatureManager();
-
-        /**
-         * adds a new movingCreature, this function is not intended to be used directly; 
-         * each MovingCreature is automatically added. a creature is always added in a
-         * idle state
-         */
-        void add(MovingCreature *movingCreature);
-
-        /**
-         * removes a movingCreature, this function is not intended to be used directly, 
-         * destroy the movingCreature instead.
-         */
-        void remove(MovingCreature *movingCreature);
-
-        void run(Ogre::Real elapsedTime);
-
-        /**
-         * Sets a movingCreature in an active state, this means that it is updated every
-         * frame. This must be the case, if the creature is moving. If a creature is in an
-         * idle state, it is only updated less often
-         */
-        void setActive(MovingCreature* movingCreature);
-
-        const Ogre::String & getName() const {return mName;}
-
-        // Newton Contact Callback
-        int userProcess();
-    protected:
-        typedef std::vector<MovingCreature*> MovingCreatureVector;
-        MovingCreatureVector mActiveCreatures;
-        MovingCreatureVector mIdleCreatures;
-        MovingCreatureVector mAddToActiveCreatures;
-        Ogre::Real mUpdateIdleTime;
-        Ogre::Real mTimeSinceLastIdleUpdate;
-        Ogre::String mName;
-
-        typedef std::map<OgreNewt::Body*,MovingCreature*> MovingCreatureBodyMap;
-        MovingCreatureBodyMap mMovingCreatureFromBody;
-    };
-}
-
-
-#endif



From tanis at mail.berlios.de  Mon Jul  2 22:23:43 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:23:43 +0200
Subject: [Dsa-hl-svn] r3578 - rl/trunk/engine/rules/src
Message-ID: <200707022023.l62KNhJB010058@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:23:38 +0200 (Mon, 02 Jul 2007)
New Revision: 3578

Added:
   rl/trunk/engine/rules/src/CreatureController.cpp
Removed:
   rl/trunk/engine/rules/src/MovingCreature.cpp
Log:
Renamed remotely

Copied: rl/trunk/engine/rules/src/CreatureController.cpp (from rev 3577, rl/trunk/engine/rules/src/MovingCreature.cpp)

Deleted: rl/trunk/engine/rules/src/MovingCreature.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreature.cpp	2007-07-02 20:22:12 UTC (rev 3577)
+++ rl/trunk/engine/rules/src/MovingCreature.cpp	2007-07-02 20:23:38 UTC (rev 3578)
@@ -1,1505 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-
-#include "Actor.h"
-#include "Creature.h"
-#include "DsaManager.h"
-#include "MeshAnimation.h"
-#include "MeshObject.h"
-#include "MovingCreature.h"
-#include "MovingCreatureManager.h"
-#include "PhysicsManager.h"
-#include "PhysicalThing.h"
-
-
-
-
-using namespace Ogre;
-using namespace std;
-
-namespace rl
-{
-
-    class Stehen : public AbstractMovement
-    {
-    public:
-        Stehen(MovingCreature *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO), mRotationMovement(NULL) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_STEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            getRotationMovement()->activate();
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-            getRotationMovement()->deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = 0.0f; 
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 0 &&
-                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_DEAD | Effect::STATUS_UNCONSCIOUS | Effect::STATUS_SLEEPING));
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
-        {
-            getRotationMovement()->calculateForceAndTorque(force, torque, timestep);
-
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-            Vector3 vel = mMovingCreature->getVelocity();
-            Real delay = 0.05;//(2 * PhysicsManager::getSingleton().getMaxTimestep());
-            if(vel.squaredLength() > mVelocity.squaredLength())
-                delay *= 1.5;
-            force = mass * (mVelocity - vel) / delay;
-            force.y = 0;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            direction.normalise();
-            Real velocity;
-            calculateBaseVelocity(velocity);
-            mVelocity = direction * velocity;
-            applyAuChanges(elapsedTime);
-            setAnimation(elapsedTime);
-            if( getRotationMovement()->isPossible() )
-                return getRotationMovement()->run(elapsedTime, direction, rotation);
-            return false;
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real omegaY = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega().y;
-            if( omegaY > Degree(20).valueRadians() )
-                mMovingCreature->setAnimation("drehen_links");
-            else
-            {
-                if( omegaY < Degree(-20).valueRadians() )
-                    mMovingCreature->setAnimation("drehen_rechts");
-                else
-                    mMovingCreature->setAnimation("Idle");                            
-            }
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            return getRotationMovement()->isRotationPossible(rotation);
-        }
-    protected:
-        Ogre::Vector3 mVelocity;
-        mutable AbstractMovement *mRotationMovement;
-        virtual AbstractMovement* getRotationMovement() const
-        {
-            if( mRotationMovement == NULL)
-            {                
-                mRotationMovement = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
-            }
-            if( mRotationMovement == NULL )
-            {
-                Throw(NullPointerException, "Konnte Movement mit der Id MT_STEHEN_DREHEN nicht finden.");
-            }
-            return mRotationMovement;
-        }
-    };
-
-    class Drehen : public AbstractMovement
-    {
-    public:
-        Drehen(MovingCreature *creature) : AbstractMovement(creature), mYaw(0)
-        {
-            mRotLinearSpringK = 600.0f;
-            Real relationCoefficient = 1.0f;
-            mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
-        }
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_DREHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = 0.3f;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR;// &&
-                mMovingCreature->getCreature()->getAu() > 1 &&
-                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
-        }
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mYaw = mMovingCreature->getCreature()->getActor()->getWorldOrientation().getYaw();
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-            Quaternion orientation;
-            Vector3 position;
-            body->getPositionOrientation(position, orientation);
-            // Calculate angular velocity
-            // We first need the yaw rotation from actual yaw to desired yaw
-            Vector3 src = orientation*Vector3::UNIT_Z;
-            src.y = 0;
-            Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
-            dst.y = 0;
-            Radian yaw = src.getRotationTo(dst, Vector3::UNIT_Y).getYaw();
-
-            // using a spring system to apply the rotation
-            Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
-            Vector3 omega = body->getOmega();
-            omega.x = omega.z = 0;
-            Vector3 springAcc = mRotLinearSpringK*diff - mRotLinearDampingK * omega;
-
-            /// @ todo change this
-            torque = springAcc * inertia; // this would be correct
-            //torque = springAcc * mass * 40;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mYaw += Radian(rotation.y);
-            while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
-            while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
-            
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            Quaternion orientation;
-            Vector3 position;
-            body->getPositionOrientation(position, orientation);
-
-            return orientation.getYaw() != mYaw;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction = Vector3::ZERO;
-            return oldDirection == Vector3::ZERO;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            Vector3 oldRotation(rotation);
-            rotation.x = rotation.z = 0;
-            return oldRotation.x == 0 && oldRotation.z == 0;
-        }
-    protected:
-        Ogre::Radian mYaw;
-        Ogre::Real mRotLinearDampingK, mRotLinearSpringK;
-        virtual Real getMovementDefinedValue() {return mYaw.valueRadians();}
-    };
-
-
-    class Gehen : public Stehen
-    {
-    public:
-        Gehen(MovingCreature *creature) : Stehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 3.6f * 0.7f; 
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR && 
-                mMovingCreature->getCreature()->getAu() > 1 &&
-                !(mMovingCreature->getCreature()->getStatus() & Effect::STATUS_IMMOBILE);
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            Stehen::run(elapsedTime, direction, rotation);
-            return true;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = direction.y = 0;
-            if( direction.z > 0 )
-                direction.z = 0;
-            return oldDirection.x == 0 && oldDirection.y == 0 && oldDirection.z > 0;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->getCreature()->regenerateAu(2, 0.5, elapsedTime);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real step = 1.49; // the width of a step
-            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
-            //Real length = charMesh->getAnimation("Run")->getLength();
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-            
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case MovingCreature::MT_NONE:
-                break;
-            case MovingCreature::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case MovingCreature::MT_JOGGEN:
-            case MovingCreature::MT_LAUFEN:
-            case MovingCreature::MT_RENNEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 1.0f )
-                    weight = mMovingCreature->getLastMovementChange() / 1.0f;
-                break;
-            default:
-                break;
-            }
-
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Walk", -mMovingCreature->getVelocity().z / (step / length), 0, "Walk", weight );
-            if( meshAnim != NULL )
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-    };
-
-    class Joggen : public Gehen
-    {
-    public:
-        Joggen(MovingCreature *creature) : Gehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_JOGGEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_GEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 2.8f; 
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            return Gehen::isPossible() &&
-                mMovingCreature->getCreature()->getAu() > 6;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime) {} // empty
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real step = 2.835; // the width of a step
-            // if the persons runs, the feet don't touch always the ground, so this value must be bigger
-            // trynerror:
-            step += 0.5;
-            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
-            //Real length = charMesh->getAnimation("Run")->getLength();
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case MovingCreature::MT_NONE:
-                break;
-            case MovingCreature::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case MovingCreature::MT_GEHEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 0.5f )
-                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length), 0, "Run", weight );
-            if( meshAnim != NULL )
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-    };
-
-    class Laufen : public Gehen
-    {
-    public:
-        Laufen(MovingCreature *creature) : Gehen(creature), mTimePerAu(1), mLastProbe(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_LAUFEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_JOGGEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 2.0f; 
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > 6;
-            else
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > 8;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            doTalentProbeIfNecessary();
-            return Gehen::run(elapsedTime, direction, rotation);
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->getCreature()->damageAu(elapsedTime/mTimePerAu);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real step = 2.835; // the width of a step
-            // if the persons runs, the feet don't touch always the ground, so this value must be bigger
-            // trynerror:
-            step += 0.5;
-            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
-            //Real length = charMesh->getAnimation("Run")->getLength();
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case MovingCreature::MT_NONE:
-                break;
-            case MovingCreature::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case MovingCreature::MT_GEHEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 0.5f )
-                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length), 0, "Run", weight );
-            if( meshAnim != NULL )
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            doTalentProbeIfNecessary();
-        }
-        virtual void doTalentProbeIfNecessary()
-        {
-            Date now = DsaManager::getSingleton().getCurrentDate();
-            if( mLastProbe + Date::ONE_SPIELRUNDE >= now || mLastProbe == 0 )
-            {
-                mTimePerAu = 180;
-                try
-                {
-                    mLastProbe = now;
-                    int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
-                    if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 5;
-                    }
-                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mTimePerAu += mMovingCreature->getCreature()->getTalent("Athletik") * 10;
-                    }
-                    else
-                    {
-                        mTimePerAu += taw * 5;
-                    }
-                }
-                catch(OutOfRangeException)
-                {
-                    mTimePerAu = 180;
-                }
-            }
-        }
-    protected:
-        Real mTimePerAu;
-        Date mLastProbe;
-    };
-
-
-    class Rennen : public Gehen
-    {
-    public:
-        Rennen(MovingCreature *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RENNEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_LAUFEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS(); 
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.3 &&
-                    mMovingCreature->getCreature()->getAu() > 6;
-            else
-                return Gehen::isPossible() &&
-                    mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax() * 0.5 &&
-                    mMovingCreature->getCreature()->getAu() > 8;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            doTalentProbeIfNecessary();
-            bool ret = Gehen::run(elapsedTime, direction, rotation);
-            mVelocity += mVelocityImprovement;
-            return ret;
-        }
-        virtual void applyAuChanges(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->getCreature()->damageAu(elapsedTime/1.5);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            Real step = 2.835; // the width of a step
-            // if the persons runs, the feet don't touch always the ground, so this value must be bigger
-            // trynerror:
-            step += 1.5;
-            //MeshObject* charMesh = dynamic_cast<MeshObject*>(mMovingCreature->getCreature()->getActor()->getControlledObject());
-            //Real length = charMesh->getAnimation("Run")->getLength();
-            Real length = 5./3.;
-            Real weight = 1;
-            Real relTimeOffset = 0;
-
-
-            switch( mMovingCreature->getLastMovementType() )
-            {
-            case MovingCreature::MT_NONE:
-                break;
-            case MovingCreature::MT_STEHEN:
-                relTimeOffset = 0.25;
-                break;
-            case MovingCreature::MT_GEHEN:
-                relTimeOffset = mMovingCreature->getAnimationTimePlayed();
-                if( mMovingCreature->getLastMovementChange() < 0.5f )
-                    weight = mMovingCreature->getLastMovementChange() / 0.5f;
-                break;
-            default:
-                break;
-            }
-
-            // apply relTimeOffset only once
-            if( mMovingCreature->getLastMovementChange() > elapsedTime )
-                relTimeOffset = 0;
-
-            MeshAnimation *meshAnim = mMovingCreature->setAnimation("Run", -mMovingCreature->getVelocity().z / (step / length), 0, "Run", weight );
-            if( meshAnim != NULL )
-                meshAnim->doAddTime(relTimeOffset*meshAnim->getLength());
-        }
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            doTalentProbeIfNecessary();
-        }
-        virtual void doTalentProbeIfNecessary()
-        {
-            Date now = DsaManager::getSingleton().getCurrentDate();
-            if( mLastProbe + mMovingCreature->getCreature()->getAuMax() * Date::ONE_SECOND >= now || mLastProbe == 0)
-            {
-                mVelocityImprovement = 0;
-                try
-                {
-                    mLastProbe = now;
-                    int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik",0);
-                    if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.2;
-                    }
-                    else if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mVelocityImprovement += mMovingCreature->getCreature()->getTalent("Athletik") * 0.3;
-                    }
-                    else
-                    {
-                        mVelocityImprovement += taw * 0.1;
-                    }
-                }
-                catch(OutOfRangeException)
-                {
-                    mVelocityImprovement = 0;
-                }
-            }
-        }
-    protected:
-        Real mVelocityImprovement;
-        Date mLastProbe;
-    };
-
-    class RueckwaertsGehen : public Gehen
-    {
-    public:
-        RueckwaertsGehen(MovingCreature *creature) : Gehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 4.0; 
-            return isPossible();
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->setAnimation("gehen_rueckwaerts");
-        }
-    };
-
-    class RueckwaertsJoggen : public Joggen
-    {
-    public:
-        RueckwaertsJoggen(MovingCreature *creature) : Joggen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_JOGGEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 3.2; 
-            return isPossible();
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            mMovingCreature->setAnimation("Run");
-        }
-    };
-
-
-    class SeitwaertsGehen : public Gehen
-    {
-    public:
-        SeitwaertsGehen(MovingCreature *creature) : Gehen(creature), mLeft(true) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SEITWAERTS_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 4.0; 
-            return isPossible();
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.z = direction.y = 0;
-            return oldDirection.z == 0 && oldDirection.y == 0;
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            mLeft = direction.x < 0;
-            return Gehen::run(elapsedTime, direction, rotation);
-        }
-        virtual void setAnimation(Ogre::Real elapsedTime)
-        {
-            if( mLeft )
-                mMovingCreature->setAnimation("seitwaerts_links");
-            else
-                mMovingCreature->setAnimation("seitwaerts_rechts");
-        }
-    protected:
-        bool mLeft;
-    };
-
-    class Schleichen : public Gehen
-    {
-    public:
-        Schleichen(MovingCreature *creature) : Gehen(creature), mState(UP), mTimer(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SCHLEICHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = mMovingCreature->getCurrentGS() / 6.0; 
-            return isPossible();
-        }
-        virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer > 0.5f )
-                    mState = DOWN;
-            }
-            if( mState == UP )
-            {
-                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer > 0.5f )
-                    mState = UP;
-            }
-            if( mState == DOWN )
-            {
-                setAnimation(elapsedTime);
-                direction.normalise();
-                Real velocity;
-                calculateBaseVelocity(velocity);
-                mVelocity = direction * velocity;
-                if( direction == Vector3::ZERO )
-                    mMovingCreature->setAnimation("hocke_idle");
-                else
-                    mMovingCreature->setAnimation("hocke_gehen");
-                applyAuChanges(elapsedTime);
-                if( getRotationMovement()->isPossible() )
-                    getRotationMovement()->run(elapsedTime, direction, rotation);
-            }
-            else
-                mVelocity = Vector3::ZERO;
-            return true;
-        }
-        void applyAuChanges(Ogre::Real elapsedTime) {}
-        virtual void setAnimation(Ogre::Real elapsedTime) {} // is not used
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mState = UPTODOWN;
-            mMovingCreature->setAnimation("idle_zu_hocke",1,1,"Idle");
-            mTimer = 0;
-        }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
-        {
-            return mState == UP;
-        }
-        virtual void requestChangeToMovement(MovingCreature::MovementType id)
-        {
-            if( mState == DOWN )
-            {
-                mState = DOWNTOUP;
-                mMovingCreature->setAnimation("hocke_zu_stehen",1,1,"Idle");
-                mTimer = 0;
-            }
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Real mTimer;
-    };
-
-
-    class Hochsprung : public AbstractMovement
-    {
-    public:
-        Hochsprung(MovingCreature *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_HOCHSPRUNG;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mState = DOWNTOUP;
-            mMovingCreature->setAnimation("idle_absprung",1,1,"Idle");
-            mTimer = 0;
-            calculateBaseVelocity(mHeight);
-
-            try
-            {
-                int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
-                if( taw > 0 )
-                {
-                    if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 12.5;
-                    }
-                    else if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mHeight += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
-                    }
-                    else
-                    {
-                        mHeight += taw / 25.0;
-                    }
-                }
-            }
-            catch(OutOfRangeException err)
-            {
-            }
-            mMovingCreature->getCreature()->damageAu(2./3);
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") + 
-                        mMovingCreature->getCreature()->getEigenschaft("KK")) / 4.0 / 5.0;
-
-            // steht nicht in den Regeln aber finde ich sinnvoll
-            // velocityBase *= (1 - getrageneLast/KK);
-            // steht in den Regeln: pro Ersch?pfung ein KK abziehen
-            //if( mErschoepfung > getEigenschaft("KO") )
-            //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 4.0 / 5.0;
-            // steht nicht in den Regeln, aber finde ich sinnvoll
-            //if( getAu() < getAuBasis() / 3.0 )
-            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 4.0 / 5.0;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return
-                    (mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR ||
-                    mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE) &&
-                    mMovingCreature->getCreature()->getAu() > 6 &&
-                    !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
-            else
-                return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 8 &&
-                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
-                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-            if( mJumpNow )
-            {
-                mJumpNow = false;
-
-                Real m = mass;
-                Real g = PhysicsManager::getSingleton().getGravity().length();
-                Real t = timestep;
-                Real h = mHeight;
-                Real jumpForce = 0.5f*g*m * (Math::Sqrt(1 + 8*h/(g * t * t)) - 1);
-                force = Vector3(0,
-                    jumpForce,
-                    0);
-                mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
-            }
-
-            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            if( mState == DOWN )
-            {
-                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
-            }
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.5f )
-                {
-                    mState = DOWN;
-                }
-            }
-            if( mState == UP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer < 0.5f )
-                {
-                    mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
-                }
-                else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
-                {
-                    mState = UPTODOWN;
-                    mMovingCreature->setAnimation("idle_sprung_landung", 1, 1, "Idle");
-                    mTimer = 0;
-                }
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.25f )
-                {
-                    mState = UP;
-                    mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
-                    //mMovingCreature->setAnimation("idle_sprung"); // we also don't need this animation!
-                    mJumpNow = true;
-                    mTimer = 0;
-                }
-            }
-            return false;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.z = direction.x = 0;
-            if(direction.y < 0)
-                direction.y = 0;
-            return oldDirection.x == 0 && oldDirection.z == 0 && oldDirection.y > 0;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
-        {
-            return mState == DOWN;
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Ogre::Real mHeight;
-        bool mJumpNow;
-        Ogre::Real mTimer;
-    };
-
-
-    class Weitsprung : public AbstractMovement
-    {
-    public:
-        Weitsprung(MovingCreature *creature) : 
-          AbstractMovement(creature), mState(DOWN), mWidth(0),
-              mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
-              mApplyForceTimer(0), mLastForce(Vector3::ZERO),
-              mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(17))) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_WEITSPRUNG;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
-        virtual void activate()
-        {
-            AbstractMovement::activate();
-            mState = DOWNTOUP;
-            mMovingCreature->setAnimation("rennen_absprung",1,1,"Run");
-            mTimer = 0;
-            calculateBaseVelocity(mWidth);
-
-            try
-            {
-                // the person will only achieve this width if it is running
-                // retrieve run movement
-                AbstractMovement *run = mMovingCreature->getMovementFromId(MovingCreature::MT_RENNEN);
-                if( run != NULL )
-                {
-                    Real vel(0);
-                    run->calculateBaseVelocity(vel);
-                    Real factor = -mMovingCreature->getVelocity().z / vel;
-                    factor = std::max(Real(0),factor);
-                    // without moving before, the width will be 1/3
-                    mWidth = mWidth/3. + mWidth * 2./3. * factor; 
-                }
-
-
-                int taw = mMovingCreature->getCreature()->doTalentprobe("Athletik", 0);
-                if( taw > 0 )
-                {
-                    if( taw == RESULT_SPEKT_AUTOERFOLG )
-                    {
-                        mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 25.0;
-                    }
-                    else if( taw == RESULT_AUTOERFOLG )
-                    {
-                        mWidth += mMovingCreature->getCreature()->getTalent("Athletik") / 50.0;
-                    }
-                    else
-                    {
-                        mWidth += taw / 50.0;
-                    }
-                }
-            }
-            catch(OutOfRangeException err)
-            {
-            }
-            mMovingCreature->getCreature()->damageAu(2./3);
-        }
-        virtual void deactivate()
-        {
-            AbstractMovement::deactivate();
-        }
-        virtual bool calculateBaseVelocity(Real &velocity)
-        {
-            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") + 
-                        mMovingCreature->getCreature()->getEigenschaft("KK")) / 5.0;
-
-            // steht nicht in den Regeln aber finde ich sinnvoll
-            // velocityBase *= (1 - getrageneLast/KK);
-            // steht in den Regeln: pro Ersch?pfung ein KK abziehen
-            //if( mErschoepfung > getEigenschaft("KO") )
-            //    velocity -= (mErschoepfung - getEigenschaft("KO")) / 5.0;
-            // steht nicht in den Regeln, aber finde ich sinnvoll
-            //if( getAu() < getAuBasis() / 3.0 )
-            //    velocity -= (getAu() / getAuBasis() * 3.0) * getEigenschaft("GE") / 5.0;
-            return isPossible();
-        }
-        virtual bool isPossible() const
-        {
-            if( mMovingCreature->getMovement() == this )
-                return
-                    (mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR ||
-                    mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE) &&
-                    mMovingCreature->getCreature()->getAu() > 6 &&
-                    !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
-            else
-                return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
-                mMovingCreature->getCreature()->getAu() > 8 &&
-                mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
-                !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
-        }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
-        {
-            Real mass;
-            Vector3 inertia;
-            OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
-            body->getMassMatrix(mass, inertia);
-
-
-            if( mJumpNow && timestep != 0 )
-            {
-                mApplyForceTimer += timestep;
-
-                if( mApplyForceTimer == timestep // first time
-                    && mApplyForceTimer < mApplyForceTime )// this is handled below
-                {
-                    Real t1 = mApplyForceTime;
-                    Real sx = mWidth;
-                    Real g = -PhysicsManager::getSingleton().getGravity().y;
-                    Real v0 = mVelocityBeforeJump;
-                    Real ax = 0;
-                    Real ay = 0;
-
-                    if( t1 != 0 || 2 * sx >= v0 * t1 )
-                    {
-                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
-                        Real v1y = mTanJumpAngle * v1x;
-                        ax =  (v1x - v0) / t1;
-                        ay = v1y/t1 + g;
-                    }
-                    
-                    mLastForce.x = 0;
-                    mLastForce.y = ay * mass;
-                    mLastForce.z = -ax * mass;
-                }
-
-                if( mApplyForceTimer < mApplyForceTime )
-                {
-                    force = mLastForce;
-                }
-                else
-                {
-                    mJumpNow = false;
-                    // adoption of the formula to our real jump time
-                    Real t1 = mApplyForceTimer;
-                    Real sx = mWidth;
-                    Real g = -PhysicsManager::getSingleton().getGravity().y;
-                    Real v0 = mVelocityBeforeJump;
-                    Real ax = 0;
-                    Real ay = 0;
-
-                    if( t1 != 0 || 2 * sx >= v0 * t1 )
-                    {
-                        Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
-                        Real v1y = mTanJumpAngle * v1x;
-
-std::ostringstream oss;
-oss << "v0: " << v0 << "    v1x: " << v1x << "    timediff: " << mApplyForceTimer - mApplyForceTime;
-LOG_MESSAGE(Logger::RULES, oss.str());
-
-                        Vector3 v_now = mMovingCreature->getVelocity();
-                        ax =  (v1x - -v_now.z) / timestep;
-                        ay = (v1y- v_now.y)/timestep + g;
-                    }
-                    
-                    force.x = 0;
-                    force.y = ay * mass;
-                    force.z = -ax * mass;
-                }
-            }
-
-            Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-            torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
-        }
-        virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
-        {
-            if( mState == DOWN )
-            {
-                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
-            }
-            if( mState == UPTODOWN )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.2f )
-                {
-                    mState = DOWN;
-                }
-            }
-            if( mState == UP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer < 0.5f )
-                {
-                    mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
-                }
-                else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
-                {
-                    mState = UPTODOWN;
-                    mMovingCreature->setAnimation("rennen_sprung_landung", 1, 1, "Run");
-                    mTimer = 0;
-                }
-            }
-            if( mState == DOWNTOUP )
-            {
-                mTimer += elapsedTime;
-                if( mTimer >= 0.3f )
-                {
-                    mState = UP;
-                    mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
-                    //mMovingCreature->setAnimation("rennen_sprung");
-                    mJumpNow = true;
-                    mApplyForceTimer = 0;
-                    mVelocityBeforeJump = -mMovingCreature->getVelocity().z;
-                    mTimer = 0;
-                }
-            }
-            return false;
-        }
-        virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
-        {
-            Vector3 oldDirection(direction);
-            direction.x = 0;
-            if(direction.y <= 0 || direction.z >= 0)
-                direction.y = direction.z = 0;
-            return oldDirection.x == 0 && oldDirection.z < 0 && oldDirection.y > 0;
-        }
-        virtual bool isRotationPossible(Ogre::Vector3 &rotation) const
-        {
-            rotation = Vector3::ZERO;
-            return false;
-        }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
-        {
-            return mState == DOWN;
-        }
-    protected:
-        enum {UP, DOWN, UPTODOWN, DOWNTOUP} mState;
-        Ogre::Real mWidth;
-        bool mJumpNow;
-        Ogre::Real mTimer;
-        Ogre::Real mApplyForceTime;
-        Ogre::Real mApplyForceTimer;
-        Ogre::Vector3 mLastForce;
-        Ogre::Real mVelocityBeforeJump;
-        Ogre::Real mTanJumpAngle;
-    };
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    MovingCreature::MovingCreature(Creature *creature) :
-        mCreature(creature),
-        mAbstractLocation(AL_AIRBORNE),
-        mMovement(NULL),
-        mLastMovementType(MT_NONE),
-        mLastMovementChange(0),
-        mDirection(Vector3::ZERO),
-        mRotation(Vector3::ZERO),
-        mLastAnimationName(""),
-        mLastCollisionName(""),
-        mLastAnimationSpeed(1),
-        mStillWeightedAnimationName(""),
-        mLastFloorContact(0)
-    {
-        MovingCreatureManager::getSingleton().add(this);
-        
-        const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID("character");
-        mCreature->getActor()->getPhysicalThing()->setMaterialID(material);
-
-        mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
-
-
-        std::pair<MovementType, AbstractMovement*> movementPair;
-        movementPair.first = MT_NONE;
-        movementPair.second = NULL;
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_DREHEN;
-        movementPair.second = new Drehen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_STEHEN;
-        movementPair.second = new Stehen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_GEHEN;
-        movementPair.second = new Gehen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_JOGGEN;
-        movementPair.second = new Joggen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_LAUFEN;
-        movementPair.second = new Laufen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_RENNEN;
-        movementPair.second = new Rennen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_RUECKWAERTS_GEHEN;
-        movementPair.second = new RueckwaertsGehen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_RUECKWAERTS_JOGGEN;
-        movementPair.second = new RueckwaertsJoggen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_SEITWAERTS_GEHEN;
-        movementPair.second = new SeitwaertsGehen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_SCHLEICHEN;
-        movementPair.second = new Schleichen (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_HOCHSPRUNG;
-        movementPair.second = new Hochsprung (this);
-        mMovementMap.insert(movementPair);
-        movementPair.first = MT_WEITSPRUNG;
-        movementPair.second = new Weitsprung (this);
-        mMovementMap.insert(movementPair);
-    }
-
-    MovingCreature::~MovingCreature()
-    {
-        MovementMap::iterator iter;
-        for(iter = mMovementMap.begin(); iter != mMovementMap.end(); iter++)
-            delete iter->second;
-        mMovementMap.erase(mMovementMap.begin(), mMovementMap.end());
-
-        mCreature->getActor()->getPhysicalThing()->setPhysicsController(NULL);
-
-        MovingCreatureManager::getSingleton().remove(this);
-    }
-
-    MovingCreature::MovementType MovingCreature::getMovementId() const
-    {
-        if (mMovement == NULL) 
-            return MT_NONE; 
-        else 
-            return mMovement->getId();
-    }
-
-    int MovingCreature::getCurrentGS() const
-    {
-        int act_gs = mCreature->getWert(Creature::WERT_GS);
-        ///@todo wy does this not work
-        //act_gs -= mCreature->getWert(Creature::WERT_BE);
-        return max(act_gs,1);
-    }
-
-    MeshAnimation *MovingCreature::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName, Real weight)
-    {
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
-        PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
-        MeshAnimation *meshAnim(NULL);
-        
-        if( mLastAnimationName != name)
-        {
-            const Ogre::String *pCollisionName = &collisionName;
-            if( collisionName == "" )
-                pCollisionName = &name;
-
-            if( *pCollisionName != mLastCollisionName )
-            {
-                pt->fitToPose(*pCollisionName);
-                mLastCollisionName = *pCollisionName;
-            }
-
-
-            if ( mStillWeightedAnimationName != "" )
-            {
-                mesh->stopAnimation(mStillWeightedAnimationName);
-                mStillWeightedAnimationName = "";
-            }
-
-
-            if( mesh->hasAnimation(mLastAnimationName) )
-            {
-                if ( weight == 1 )
-                    mesh->stopAnimation(mLastAnimationName);
-                else
-                {
-                    MeshAnimation *lastAnimation = mesh->getAnimation(mLastAnimationName);
-                    if( lastAnimation != NULL )
-                    {
-                        mStillWeightedAnimationName = mLastAnimationName;
-                        lastAnimation->setWeight(1-weight);
-                    }
-                }
-            }
-
-            meshAnim = mesh->startAnimation(name, speed, timesToPlay);
-            if( meshAnim )
-            {
-                meshAnim->setWeight(weight);
-                mLastAnimationName = name;
-                mLastAnimationSpeed = speed;
-            }
-        }
-        else
-        {
-            meshAnim = mesh->getAnimation(name);
-            if( mLastAnimationSpeed != speed )
-            {
-                meshAnim->setSpeed(speed);
-                mLastAnimationSpeed = speed;
-                meshAnim->setWeight(weight);
-            }
-            if( mStillWeightedAnimationName != "" )
-            {
-                MeshAnimation *lastAnimation = mesh->getAnimation(mStillWeightedAnimationName);
-                if( lastAnimation !=  NULL )
-                {
-                    lastAnimation->setWeight(1-weight);
-                    if( weight == 1 )
-                    {
-                        mesh->stopAnimation(mStillWeightedAnimationName);
-                        mStillWeightedAnimationName = "";
-                    }
-                }
-                else
-                {
-                    mStillWeightedAnimationName = "";
-                }
-            }
-        }
-
-        return meshAnim;
-    }
-
-    Ogre::Real MovingCreature::getAnimationTimePlayed() const
-    {
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
-        MeshAnimation *meshAnim = mesh->getAnimation(mLastAnimationName);
-        if( meshAnim != NULL )
-            return meshAnim->getTimePlayed()/meshAnim->getLength();
-        return 0;
-    }
-
-    Ogre::Vector3 MovingCreature::getVelocity() const
-    {
-        return 
-            mCreature->getActor()->getPhysicalThing()->getOrientation().Inverse() *
-            mCreature->getActor()->getPhysicalThing()->_getBody()->getVelocity();
-    }
-
-    Ogre::Vector3 MovingCreature::getOmega() const
-    {
-        return mCreature->getActor()->getPhysicalThing()->_getBody()->getOmega();
-    }
-
-    bool MovingCreature::run(Real elapsedTime)
-    {
-        if(mMovement != NULL)
-        {
-            mLastMovementChange += elapsedTime;
-            if( !mMovement->isPossible() )
-            {
-                setMovement(mMovement->getFallBackMovement(), mDirection, mRotation);
-                if( mMovement == NULL )
-                    return false;
-            }
-
-            Vector3 rotation(mRotation);
-            mRotation = Vector3::ZERO;
-            return mMovement->run(elapsedTime, mDirection, rotation);
-        }
-        return false;
-    }
-
-    void MovingCreature::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        Vector3 force, torque;
-        OgreNewt::Body *body = thing->_getBody();
-        force = Vector3::ZERO;
-        torque = Vector3::ZERO;
-        OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
-        Real mass;
-        Vector3 inertia;
-        body->getMassMatrix(mass, inertia);
-
-        if(mMovement != NULL)
-        {
-            mMovement->calculateForceAndTorque(force, torque, timestep);
-            force = thing->getOrientation() * force;
-        }
-        else
-        {
-            // don't move
-            force = - mass * body->getVelocity() / 1 * timestep;
-            force.y = 0;
-        }
-        force += mass * PhysicsManager::getSingleton().getGravity();
-        body->setForce(force);
-        body->setTorque(torque);
-    }
-
-    int MovingCreature::userProcess()
-    {
-        // own collision handling (floor, in order to get information for mAbstractLocation)
-        Vector3 point;
-        Vector3 normal;
-        getContactPositionAndNormal(point, normal);
-
-        // determine if this contact is with the floor.
-        // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
-        Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
-
-        Vector3 charPos;
-        Quaternion charOri;
-        mCreature->getActor()->getPhysicalThing()->_getBody()->getPositionOrientation(charPos, charOri);
-        bool isFloorCollision(false);
-
-        //AxisAlignedBox CharAab = mCharBody->getCollision()->getAABB();
-        //Real charHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
-        Real stepHeight = point.y - charPos.y;
-
-        if( stepHeight < 0.5f )
-            isFloorCollision = true;
-
-        if ( isFloorCollision )
-        {
-            setAbstractLocation(AL_FLOOR);
-            if(stepHeight > 0.1f)
-                setContactNormalAcceleration(10);
-            setContactElasticity(0.0f);
-            mLastFloorContact = 0.0f;
-        }
-        else
-        {
-            mLastFloorContact += PhysicsManager::getSingleton()._getNewtonWorld()->getTimeStep();
-            if(mLastFloorContact >= 2.2f || getAbstractLocation() == AL_AIRBORNE)
-                setAbstractLocation(AL_AIRBORNE);
-        }
-
-
-        if(mMovement != NULL)
-        {
-            // i hope this will copy the protected members of the contact callback
-            OgreNewt::ContactCallback *movement = mMovement;
-            *movement = (OgreNewt::ContactCallback)(*this);
-            return movement->userProcess();
-        }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
-    }
-
-    AbstractMovement *MovingCreature::getMovementFromId(MovingCreature::MovementType id)
-    {
-        MovementMap::iterator iter = mMovementMap.find(id);
-        if(iter == mMovementMap.end())
-        {
-            Throw(IllegalArgumentException, "Der angegebene Bewegungstyp wurde nicht gefunden.");
-        }
-        return iter->second;
-    }
-
-
-    bool MovingCreature::setMovement(MovementType type, Vector3 direction, Vector3 rotation)
-    {
-        if( mMovement != NULL )
-        {
-            if( mMovement->getId() == type )
-            {
-                MovingCreatureManager::getSingleton().setActive(this);
-                mDirection = direction;
-                mRotation = rotation;
-                return true;
-            }
-        }
-
-        if( mMovement != NULL )
-        {
-            if( !mMovement->canChangeToMovement(type) )
-            {
-                mMovement->requestChangeToMovement(type);
-                return false;
-            }
-        }
-
-        AbstractMovement *movement = getMovementFromId(type);
-
-
-        while(movement != NULL)
-        {
-            if(movement->isPossible())
-            {
-                MovingCreatureManager::getSingleton().setActive(this); // runs the old movement if idle!
-                if(mMovement == NULL)
-                {
-                    mLastMovementType = MT_NONE;
-                }
-                else
-                {
-                    mLastMovementType = mMovement->getId();
-                    mMovement->deactivate();
-                }
-                mMovement = movement;
-                mMovement->activate();
-                mDirection = direction;
-                mRotation = rotation;
-                mLastMovementChange = 0;
-                return true;
-            }
-
-            movement = getMovementFromId(movement->getFallBackMovement());
-        }
-
-        return false;
-    }
-
-
-
-    Ogre::Radian MovingCreature::getYaw()
-    {
-        Radian yaw = mCreature->getActor()->getWorldOrientation().getYaw();
-
-        AbstractMovement *drehen = getMovementFromId(MT_DREHEN);
-        
-        if( drehen == NULL )
-            return yaw;
-
-        if( !drehen->isActive() )
-            return yaw;
-
-        return Radian(drehen->getMovementDefinedValue());
-    }
-}



From tanis at mail.berlios.de  Mon Jul  2 22:24:15 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 22:24:15 +0200
Subject: [Dsa-hl-svn] r3579 - rl/trunk/engine/rules/src
Message-ID: <200707022024.l62KOFjs010084@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 22:24:10 +0200 (Mon, 02 Jul 2007)
New Revision: 3579

Added:
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
Removed:
   rl/trunk/engine/rules/src/MovingCreatureManager.cpp
Log:
Renamed remotely

Copied: rl/trunk/engine/rules/src/CreatureControllerManager.cpp (from rev 3578, rl/trunk/engine/rules/src/MovingCreatureManager.cpp)

Deleted: rl/trunk/engine/rules/src/MovingCreatureManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/MovingCreatureManager.cpp	2007-07-02 20:23:38 UTC (rev 3578)
+++ rl/trunk/engine/rules/src/MovingCreatureManager.cpp	2007-07-02 20:24:10 UTC (rev 3579)
@@ -1,228 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-
-#include "Actor.h"
-#include "Creature.h"
-#include "GameTask.h"
-#include "GameLoop.h"
-#include "Exception.h"
-#include "MovingCreatureManager.h"
-#include "MovingCreature.h"
-
-
-using namespace Ogre;
-using namespace std;
-
-
-template<> rl::MovingCreatureManager* Singleton<rl::MovingCreatureManager>::ms_Singleton = 0;
-
-
-namespace rl
-{
-    MovingCreatureManager::MovingCreatureManager() :
-            mUpdateIdleTime(1.0f),
-            mTimeSinceLastIdleUpdate(0.0f),
-            mName("MovingCreatureManager")
-    {
-        GameLoop::getSingleton().addTask(this, GameLoop::TG_LOGIC);
-
-        PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
-        // the material of moving creatures
-        const OgreNewt::MaterialID *char_mat = physicsManager->createMaterialID("character");
-
-        const OgreNewt::MaterialID *def_mat = physicsManager->createMaterialID("default");
-        const OgreNewt::MaterialID *level_mat = physicsManager->createMaterialID("level");
-
-        physicsManager->createMaterialPair(char_mat, def_mat)->setContactCallback(this);
-        physicsManager->createMaterialPair(char_mat, level_mat)->setContactCallback(this);
-    }
-
-    MovingCreatureManager::~MovingCreatureManager()
-    {
-        PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
-        const OgreNewt::MaterialID *char_mat = physicsManager->getMaterialID("character");
-
-        const OgreNewt::MaterialID *def_mat = physicsManager->getMaterialID("default");
-        const OgreNewt::MaterialID *level_mat = physicsManager->getMaterialID("level");
-
-        physicsManager->resetMaterialPair(char_mat, def_mat);
-        physicsManager->resetMaterialPair(char_mat, level_mat);
-
-
-        GameLoop::getSingleton().removeTask(this);
-    }
-
-    void MovingCreatureManager::add(MovingCreature *movingCreature)
-    {
-        if(movingCreature == NULL)
-        {
-            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
-        }
-
-        MovingCreatureVector::const_iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                Throw(IllegalArgumentException, "MovingCreature wird schon vom MovingCreatureManager verwaltet.");
-            }
-        }
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                Throw(IllegalArgumentException, "MovingCreature wird schon vom MovingCreatureManager verwaltet.");
-            }
-        }
-
-        mMovingCreatureFromBody.insert(make_pair(
-            movingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody(),
-            movingCreature));
-        mIdleCreatures.push_back(movingCreature);
-    }
-
-
-    void MovingCreatureManager::remove(MovingCreature *movingCreature)
-    {
-        if(movingCreature == NULL)
-        {
-            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
-        }
-
-        MovingCreatureBodyMap::iterator body_iter = mMovingCreatureFromBody.find(
-            movingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody());
-
-        if( body_iter == mMovingCreatureFromBody.end() )
-        {
-            Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
-        }
-
-        mMovingCreatureFromBody.erase(body_iter);
-
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mIdleCreatures.erase(iter);
-                return;
-            }
-        }
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mActiveCreatures.erase(iter);
-                return;
-            }
-        }
-        for(iter = mAddToActiveCreatures.begin(); iter != mAddToActiveCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mAddToActiveCreatures.erase(iter);
-                return;
-            }
-        }
-
-
-        Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
-    }
-
-    void MovingCreatureManager::run(Real elapsedTime)
-    {
-        mTimeSinceLastIdleUpdate += elapsedTime;
-
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter ++)
-        {
-            (*iter)->run(elapsedTime);
-        }
-
-        if( mTimeSinceLastIdleUpdate >= mUpdateIdleTime )
-        {
-            for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-            {
-                (*iter)->run(mTimeSinceLastIdleUpdate);
-            }
-            mTimeSinceLastIdleUpdate = 0.0f;
-        }
-    }
-
-
-    void MovingCreatureManager::setActive(MovingCreature* movingCreature)
-    {
-        if(movingCreature == NULL)
-        {
-            Throw(NullPointerException, "Argument movingCreature darf nicht NULL sein.");
-        }
-
-        // we cannot simply add the item to the other list, since it needs to be updated first!!
-        // i hope there are no errors, if this update is not at the proposed time in the game loop
-        // since it is not executed with the other runs!!!
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-        {
-            if( *iter == movingCreature )
-            {
-                movingCreature->run(mTimeSinceLastIdleUpdate);
-
-                mActiveCreatures.push_back(movingCreature);
-                mIdleCreatures.erase(iter);
-                return;
-            }
-        }
-
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
-        {
-            if( *iter == movingCreature )
-            {
-                LOG_DEBUG(Logger::RULES, "Die angegebene MovingCreature ist schon aktiv.");
-                return;
-            }
-        }
-
-
-        Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
-    }
-
-
-    int MovingCreatureManager::userProcess()
-    {
-        MovingCreatureBodyMap::iterator iter;
-        iter = mMovingCreatureFromBody.find(m_body0);
-
-        if( iter == mMovingCreatureFromBody.end() )
-        {
-            iter = mMovingCreatureFromBody.find(m_body1);
-
-            if( iter == mMovingCreatureFromBody.end() )
-            {
-                LOG_ERROR(Logger::RULES, "Der Kollisionsk?rper konnte keiner Creature zugeordner werden.");
-                return 1;
-            }
-        }
-
-        // i hope this will copy the protected members of the contact callback
-        OgreNewt::ContactCallback *movingCreature = iter->second;
-        *movingCreature = (OgreNewt::ContactCallback)(*this);
-        return movingCreature->userProcess();
-    }
-}



From tanis at mail.berlios.de  Mon Jul  2 23:22:20 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 2 Jul 2007 23:22:20 +0200
Subject: [Dsa-hl-svn] r3580 - in rl/trunk/engine: ai/include ai/src rules
	rules/include rules/src script/swig ui/include ui/src
Message-ID: <200707022122.l62LMKon013510@sheep.berlios.de>

Author: tanis
Date: 2007-07-02 23:21:48 +0200 (Mon, 02 Jul 2007)
New Revision: 3580

Modified:
   rl/trunk/engine/ai/include/CreatureWalkPathJob.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/include/RulesSubsystem.h
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Finished renaming-aria. SVN Update should be save again.

Modified: rl/trunk/engine/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -23,7 +23,7 @@
 #include "LandmarkPath.h"
 
 #include "Job.h"
-#include "MovingCreature.h"
+#include "CreatureController.h"
 
 namespace rl
 {
@@ -35,7 +35,7 @@
         * @param movingCreature the job has to know a moving creature
         * @param startLandmark first landmark, the moving creature has to go to
         */
-        CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark);
+        CreatureWalkPathJob(const Ogre::String& name, CreatureController* movingCreature, Landmark* startLandmark);
         //destructor
         virtual ~CreatureWalkPathJob();
 
@@ -50,13 +50,13 @@
         virtual bool execute(Ogre::Real time);
 
         // @retval the moving creature controlled by this object
-        MovingCreature* getMovingCreature();
+        CreatureController* getMovingCreature();
     private:
         void updateCreature(Ogre::Real time);
 
         LandmarkPath mLandmarkPath;
         Ogre::String mName;
-        MovingCreature* mMovingCreature;
+        CreatureController* mMovingCreature;
 
         Landmark* mCurrentLandmark;
         Landmark* mNextLandmark;

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -43,7 +43,7 @@
 	class Actor;
 	class Agent;
 	class PhysicalThing;
-    class MovingCreature;
+    class CreatureController;
 
 	/**
 	 * Realises steering for NPCs
@@ -299,7 +299,7 @@
         //! Creature object steered by this vehicle (and controlled by Agent).
         Creature* mCreature;
 
-        MovingCreature* mMovingCreature;
+        CreatureController* mMovingCreature;
 
         // derived from debugvisualisable
         virtual void doCreatePrimitive();

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -18,7 +18,7 @@
 
 namespace rl
 {
-    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark) 
+    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, CreatureController* movingCreature, Landmark* startLandmark) 
         : Job(true, true), mLandmarkPath("LandmarkPath" + name), mNextLandmarkRequested(false)
     {
         //the moving creature moves from the current position to the landmark
@@ -64,7 +64,7 @@
         mLandmarkPath.addPoint(lm);
     }
 
-    MovingCreature* CreatureWalkPathJob::getMovingCreature()
+    CreatureController* CreatureWalkPathJob::getMovingCreature()
     {
         return mMovingCreature;
     }
@@ -80,7 +80,7 @@
         direction.y = 0;
         if( direction.squaredLength() < 0.04 )
         {
-            mMovingCreature->setMovement(MovingCreature::MT_STEHEN, Ogre::Vector3::ZERO, Ogre::Vector3::ZERO);
+            mMovingCreature->setMovement(CreatureController::MT_STEHEN, Ogre::Vector3::ZERO, Ogre::Vector3::ZERO);
             mNextLandmarkRequested = true;
             updatedDirection = false;
             return;
@@ -100,6 +100,6 @@
             timeSinceLastRotation = 0;
         }
 
-        mMovingCreature->setMovement(MovingCreature::MT_GEHEN, Ogre::Vector3::NEGATIVE_UNIT_Z, usedRotation);
+        mMovingCreature->setMovement(CreatureController::MT_GEHEN, Ogre::Vector3::NEGATIVE_UNIT_Z, usedRotation);
     }
 }

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -20,7 +20,7 @@
 #include "Actor.h"
 #include "Creature.h"
 #include "MeshObject.h"
-#include "MovingCreature.h"
+#include "CreatureController.h"
 #include "PhysicalThing.h"
 
 using namespace Ogre;
@@ -56,7 +56,7 @@
 {
     if( mMovingCreature == NULL )
     {
-        mMovingCreature = new MovingCreature(mCreature);
+        mMovingCreature = new CreatureController(mCreature);
     }
 }
 
@@ -145,7 +145,7 @@
         mCreature->modifyAu(20,true);
 
 
-    AbstractMovement *mov_drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+    AbstractMovement *mov_drehen = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
     Real vel_drehen(0);
     Radian max_drehen = Degree(0);
     if( mov_drehen->calculateBaseVelocity(vel_drehen) )
@@ -165,11 +165,11 @@
 
     Ogre::Vector3 direction(Ogre::Vector3::ZERO);
     Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
-    MovingCreature::MovementType movement = MovingCreature::MT_STEHEN;
+    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
     if( result != Ogre::Vector3::ZERO )
     {
         direction.z = -1;
-        movement = MovingCreature::MT_GEHEN;
+        movement = CreatureController::MT_GEHEN;
     }
 
 

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-02 21:21:48 UTC (rev 3580)
@@ -301,6 +301,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\CreatureController.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\src\CreatureControllerManager.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\Date.cpp"
 				>
 			</File>
@@ -349,14 +357,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\MovingCreature.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\MovingCreatureManager.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\ObjectStateChangeEvent.cpp"
 				>
 			</File>
@@ -495,6 +495,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\CreatureController.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\CreatureControllerManager.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Date.h"
 				>
 			</File>
@@ -551,14 +559,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\MovingCreature.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\MovingCreatureManager.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\ObjectStateChangeEvent.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -30,14 +30,14 @@
 namespace rl
 {
     class AbstractMovement;
-    class MovingCreatureManager;
+    class CreatureControllerManager;
     class MeshAnimation;
 
     /** 
      * This class provides an interface to control the movement of a creature.
      * It handles all nessessary things like animations and calculates the movement speed.
      */
-    class _RlRulesExport MovingCreature :
+    class _RlRulesExport CreatureController :
         public PhysicsController,
         public PhysicsGenericContactCallback
     {
@@ -46,12 +46,12 @@
 		 * @param creature the creature of the bot/char
 		 * @param actor the actor of the bot/char
 		 */
-        MovingCreature(Creature *character);
-        ~MovingCreature();
+        CreatureController(Creature *character);
+        ~CreatureController();
 
         /**
          * This function is not intented to be called directly
-         * @retval true, if this MovingCreature still needs to be called every frame
+         * @retval true, if this CreatureController still needs to be called every frame
          */
         bool run(Ogre::Real elapsedTime);
 
@@ -162,7 +162,7 @@
         MovementMap mMovementMap;
 
         // in order to copy the contactcallback members correctly;
-        friend class MovingCreatureManager;
+        friend class CreatureControllerManager;
 
     private:
         // only used in setAnimation
@@ -181,13 +181,13 @@
         public OgreNewt::ContactCallback
     {
     public:
-        AbstractMovement(MovingCreature *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
+        AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
 
         /// returns the id of this movement
-        virtual MovingCreature::MovementType getId() const = 0;
+        virtual CreatureController::MovementType getId() const = 0;
 
         /// returns the id of the movement that is used, if this movement isn't possible (any more)
-        virtual MovingCreature::MovementType getFallBackMovement() const = 0;
+        virtual CreatureController::MovementType getFallBackMovement() const = 0;
 
         /**
          * this method calculates the basis velocity (without any changes due to Talentproben etc)
@@ -208,7 +208,7 @@
         virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
 
         /**
-         * this method is called by OnApplyTorqueAndForceCallback of the MovingCreature
+         * this method is called by OnApplyTorqueAndForceCallback of the CreatureController
          * the PhysicalThing can be acquired via the Creature
          */
         virtual void calculateForceAndTorque(Ogre::Vector3 &force, Ogre::Vector3 &torque, Ogre::Real timestep) = 0;
@@ -216,12 +216,12 @@
         /**
          * this method indicates if it is possible to change to the specified movement at this moment
          */
-        virtual bool canChangeToMovement(MovingCreature::MovementType id) {return true;}
+        virtual bool canChangeToMovement(CreatureController::MovementType id) {return true;}
 
         /**
          * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
          */
-        virtual void requestChangeToMovement(MovingCreature::MovementType id) {}
+        virtual void requestChangeToMovement(CreatureController::MovementType id) {}
 
         /**
          * here all the stuff not (directly) relating the physics should be done
@@ -229,7 +229,7 @@
          * Creature is in an active moving state. It is important to handle all 
          * "Talentproben" etc here and not in the physics function!
          * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
-         * @retval true indicates that the creature should remain active (in order to activate it use MovingCreatureManager::setActive)
+         * @retval true indicates that the creature should remain active (in order to activate it use CreatureControllerManager::setActive)
          */
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
 
@@ -267,7 +267,7 @@
         /// this method is used to return the yaw value of rotation movemenrts etc
         virtual Ogre::Real getMovementDefinedValue() {return 0;}
     protected:
-        MovingCreature *mMovingCreature;
+        CreatureController *mMovingCreature;
         bool mActive;
     };
 }

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -28,29 +28,29 @@
 
 namespace rl
 {
-    class MovingCreature;
+    class CreatureController;
 
-    class _RlRulesExport MovingCreatureManager : 
+    class _RlRulesExport CreatureControllerManager : 
         public GameTask,
-        public Ogre::Singleton<MovingCreatureManager>,
+        public Ogre::Singleton<CreatureControllerManager>,
         public PhysicsGenericContactCallback
     {
     public:
-        MovingCreatureManager();
-        ~MovingCreatureManager();
+        CreatureControllerManager();
+        ~CreatureControllerManager();
 
         /**
          * adds a new movingCreature, this function is not intended to be used directly; 
-         * each MovingCreature is automatically added. a creature is always added in a
+         * each CreatureController is automatically added. a creature is always added in a
          * idle state
          */
-        void add(MovingCreature *movingCreature);
+        void add(CreatureController *movingCreature);
 
         /**
          * removes a movingCreature, this function is not intended to be used directly, 
          * destroy the movingCreature instead.
          */
-        void remove(MovingCreature *movingCreature);
+        void remove(CreatureController *movingCreature);
 
         void run(Ogre::Real elapsedTime);
 
@@ -59,14 +59,14 @@
          * frame. This must be the case, if the creature is moving. If a creature is in an
          * idle state, it is only updated less often
          */
-        void setActive(MovingCreature* movingCreature);
+        void setActive(CreatureController* movingCreature);
 
         const Ogre::String & getName() const {return mName;}
 
         // Newton Contact Callback
         int userProcess();
     protected:
-        typedef std::vector<MovingCreature*> MovingCreatureVector;
+        typedef std::vector<CreatureController*> MovingCreatureVector;
         MovingCreatureVector mActiveCreatures;
         MovingCreatureVector mIdleCreatures;
         MovingCreatureVector mAddToActiveCreatures;
@@ -74,7 +74,7 @@
         Ogre::Real mTimeSinceLastIdleUpdate;
         Ogre::String mName;
 
-        typedef std::map<OgreNewt::Body*,MovingCreature*> MovingCreatureBodyMap;
+        typedef std::map<OgreNewt::Body*,CreatureController*> MovingCreatureBodyMap;
         MovingCreatureBodyMap mMovingCreatureFromBody;
     };
 }

Modified: rl/trunk/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/trunk/engine/rules/include/RulesSubsystem.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/include/RulesSubsystem.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -27,7 +27,7 @@
     class ActionManager;
     class CombatManager;
     class DsaManager;
-    class MovingCreatureManager;
+    class CreatureControllerManager;
     class TimerManager;
     class XdimlLoader;
 
@@ -45,7 +45,7 @@
         ActionManager* mActionManager;
         CombatManager* mCombatManager;
         DsaManager* mDsaManager;
-        MovingCreatureManager *mMovingCreatureManager;
+        CreatureControllerManager *mMovingCreatureManager;
         TimerManager* mTimerManager;
         XdimlLoader* mXdimlLoader;
     };

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -20,8 +20,8 @@
 #include "DsaManager.h"
 #include "MeshAnimation.h"
 #include "MeshObject.h"
-#include "MovingCreature.h"
-#include "MovingCreatureManager.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
 #include "PhysicsManager.h"
 #include "PhysicalThing.h"
 
@@ -37,9 +37,9 @@
     class Stehen : public AbstractMovement
     {
     public:
-        Stehen(MovingCreature *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO), mRotationMovement(NULL) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_STEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
+        Stehen(CreatureController *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO), mRotationMovement(NULL) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
         virtual void activate()
         {
             AbstractMovement::activate();
@@ -58,7 +58,7 @@
         virtual bool isPossible() const
         {
             return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_DEAD | Effect::STATUS_UNCONSCIOUS | Effect::STATUS_SLEEPING));
         }
@@ -124,7 +124,7 @@
         {
             if( mRotationMovement == NULL)
             {                
-                mRotationMovement = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+                mRotationMovement = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
             }
             if( mRotationMovement == NULL )
             {
@@ -137,14 +137,14 @@
     class Drehen : public AbstractMovement
     {
     public:
-        Drehen(MovingCreature *creature) : AbstractMovement(creature), mYaw(0)
+        Drehen(CreatureController *creature) : AbstractMovement(creature), mYaw(0)
         {
             mRotLinearSpringK = 600.0f;
             Real relationCoefficient = 1.0f;
             mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
         }
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_DREHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_DREHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = 0.3f;
@@ -153,7 +153,7 @@
         virtual bool isPossible() const
         {
             return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR;// &&
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR;// &&
                 mMovingCreature->getCreature()->getAu() > 1 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
         }
@@ -229,9 +229,9 @@
     class Gehen : public Stehen
     {
     public:
-        Gehen(MovingCreature *creature) : Stehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        Gehen(CreatureController *creature) : Stehen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS() / 3.6f * 0.7f; 
@@ -240,7 +240,7 @@
         virtual bool isPossible() const
         {
             return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR && 
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR && 
                 mMovingCreature->getCreature()->getAu() > 1 &&
                 !(mMovingCreature->getCreature()->getStatus() & Effect::STATUS_IMMOBILE);
         }
@@ -272,14 +272,14 @@
             
             switch( mMovingCreature->getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_JOGGEN:
-            case MovingCreature::MT_LAUFEN:
-            case MovingCreature::MT_RENNEN:
+            case CreatureController::MT_JOGGEN:
+            case CreatureController::MT_LAUFEN:
+            case CreatureController::MT_RENNEN:
                 relTimeOffset = mMovingCreature->getAnimationTimePlayed();
                 if( mMovingCreature->getLastMovementChange() < 1.0f )
                     weight = mMovingCreature->getLastMovementChange() / 1.0f;
@@ -302,9 +302,9 @@
     class Joggen : public Gehen
     {
     public:
-        Joggen(MovingCreature *creature) : Gehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_JOGGEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_GEHEN;}
+        Joggen(CreatureController *creature) : Gehen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS() / 2.8f; 
@@ -331,12 +331,12 @@
 
             switch( mMovingCreature->getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_GEHEN:
+            case CreatureController::MT_GEHEN:
                 relTimeOffset = mMovingCreature->getAnimationTimePlayed();
                 if( mMovingCreature->getLastMovementChange() < 0.5f )
                     weight = mMovingCreature->getLastMovementChange() / 0.5f;
@@ -358,9 +358,9 @@
     class Laufen : public Gehen
     {
     public:
-        Laufen(MovingCreature *creature) : Gehen(creature), mTimePerAu(1), mLastProbe(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_LAUFEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_JOGGEN;}
+        Laufen(CreatureController *creature) : Gehen(creature), mTimePerAu(1), mLastProbe(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_LAUFEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS() / 2.0f; 
@@ -399,12 +399,12 @@
 
             switch( mMovingCreature->getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_GEHEN:
+            case CreatureController::MT_GEHEN:
                 relTimeOffset = mMovingCreature->getAnimationTimePlayed();
                 if( mMovingCreature->getLastMovementChange() < 0.5f )
                     weight = mMovingCreature->getLastMovementChange() / 0.5f;
@@ -464,9 +464,9 @@
     class Rennen : public Gehen
     {
     public:
-        Rennen(MovingCreature *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RENNEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_LAUFEN;}
+        Rennen(CreatureController *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RENNEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_LAUFEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS(); 
@@ -509,12 +509,12 @@
 
             switch( mMovingCreature->getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_GEHEN:
+            case CreatureController::MT_GEHEN:
                 relTimeOffset = mMovingCreature->getAnimationTimePlayed();
                 if( mMovingCreature->getLastMovementChange() < 0.5f )
                     weight = mMovingCreature->getLastMovementChange() / 0.5f;
@@ -573,9 +573,9 @@
     class RueckwaertsGehen : public Gehen
     {
     public:
-        RueckwaertsGehen(MovingCreature *creature) : Gehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        RueckwaertsGehen(CreatureController *creature) : Gehen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS() / 4.0; 
@@ -590,9 +590,9 @@
     class RueckwaertsJoggen : public Joggen
     {
     public:
-        RueckwaertsJoggen(MovingCreature *creature) : Joggen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_JOGGEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
+        RueckwaertsJoggen(CreatureController *creature) : Joggen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS() / 3.2; 
@@ -608,9 +608,9 @@
     class SeitwaertsGehen : public Gehen
     {
     public:
-        SeitwaertsGehen(MovingCreature *creature) : Gehen(creature), mLeft(true) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SEITWAERTS_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        SeitwaertsGehen(CreatureController *creature) : Gehen(creature), mLeft(true) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SEITWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS() / 4.0; 
@@ -641,9 +641,9 @@
     class Schleichen : public Gehen
     {
     public:
-        Schleichen(MovingCreature *creature) : Gehen(creature), mState(UP), mTimer(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SCHLEICHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        Schleichen(CreatureController *creature) : Gehen(creature), mState(UP), mTimer(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SCHLEICHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
             velocity = mMovingCreature->getCurrentGS() / 6.0; 
@@ -659,7 +659,7 @@
             }
             if( mState == UP )
             {
-                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+                mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
             }
             if( mState == DOWNTOUP )
             {
@@ -695,11 +695,11 @@
             mMovingCreature->setAnimation("idle_zu_hocke",1,1,"Idle");
             mTimer = 0;
         }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        virtual bool canChangeToMovement(CreatureController::MovementType id)
         {
             return mState == UP;
         }
-        virtual void requestChangeToMovement(MovingCreature::MovementType id)
+        virtual void requestChangeToMovement(CreatureController::MovementType id)
         {
             if( mState == DOWN )
             {
@@ -717,9 +717,9 @@
     class Hochsprung : public AbstractMovement
     {
     public:
-        Hochsprung(MovingCreature *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_HOCHSPRUNG;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        Hochsprung(CreatureController *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_HOCHSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual void activate()
         {
             AbstractMovement::activate();
@@ -775,13 +775,13 @@
         {
             if( mMovingCreature->getMovement() == this )
                 return
-                    (mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR ||
-                    mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE) &&
+                    (mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR ||
+                    mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE) &&
                     mMovingCreature->getCreature()->getAu() > 6 &&
                     !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
             else
                 return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 8 &&
                 mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
@@ -805,7 +805,7 @@
                 force = Vector3(0,
                     jumpForce,
                     0);
-                mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
             }
 
             Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
@@ -815,7 +815,7 @@
         {
             if( mState == DOWN )
             {
-                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+                mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
             }
             if( mState == UPTODOWN )
             {
@@ -830,9 +830,9 @@
                 mTimer += elapsedTime;
                 if( mTimer < 0.5f )
                 {
-                    mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                    mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
                 }
-                else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
+                else if( mMovingCreature->getAbstractLocation() != CreatureController::AL_AIRBORNE )
                 {
                     mState = UPTODOWN;
                     mMovingCreature->setAnimation("idle_sprung_landung", 1, 1, "Idle");
@@ -845,7 +845,7 @@
                 if( mTimer >= 0.25f )
                 {
                     mState = UP;
-                    mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
+                    mMovingCreature->setAbstractLocation(CreatureController::AL_AIRBORNE);
                     //mMovingCreature->setAnimation("idle_sprung"); // we also don't need this animation!
                     mJumpNow = true;
                     mTimer = 0;
@@ -866,7 +866,7 @@
             rotation = Vector3::ZERO;
             return false;
         }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        virtual bool canChangeToMovement(CreatureController::MovementType id)
         {
             return mState == DOWN;
         }
@@ -881,13 +881,13 @@
     class Weitsprung : public AbstractMovement
     {
     public:
-        Weitsprung(MovingCreature *creature) : 
+        Weitsprung(CreatureController *creature) : 
           AbstractMovement(creature), mState(DOWN), mWidth(0),
               mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
               mApplyForceTimer(0), mLastForce(Vector3::ZERO),
               mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(17))) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_WEITSPRUNG;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_WEITSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual void activate()
         {
             AbstractMovement::activate();
@@ -900,7 +900,7 @@
             {
                 // the person will only achieve this width if it is running
                 // retrieve run movement
-                AbstractMovement *run = mMovingCreature->getMovementFromId(MovingCreature::MT_RENNEN);
+                AbstractMovement *run = mMovingCreature->getMovementFromId(CreatureController::MT_RENNEN);
                 if( run != NULL )
                 {
                     Real vel(0);
@@ -957,13 +957,13 @@
         {
             if( mMovingCreature->getMovement() == this )
                 return
-                    (mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR ||
-                    mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE) &&
+                    (mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR ||
+                    mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE) &&
                     mMovingCreature->getCreature()->getAu() > 6 &&
                     !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
             else
                 return 
-                mMovingCreature->getAbstractLocation() == MovingCreature::AL_FLOOR &&
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 8 &&
                 mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
@@ -1045,7 +1045,7 @@
         {
             if( mState == DOWN )
             {
-                mMovingCreature->setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+                mMovingCreature->setMovement(CreatureController::MT_STEHEN, direction, rotation);
             }
             if( mState == UPTODOWN )
             {
@@ -1060,9 +1060,9 @@
                 mTimer += elapsedTime;
                 if( mTimer < 0.5f )
                 {
-                    mMovingCreature->setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                    mMovingCreature->setAbstractLocation( CreatureController::AL_AIRBORNE );
                 }
-                else if( mMovingCreature->getAbstractLocation() != MovingCreature::AL_AIRBORNE )
+                else if( mMovingCreature->getAbstractLocation() != CreatureController::AL_AIRBORNE )
                 {
                     mState = UPTODOWN;
                     mMovingCreature->setAnimation("rennen_sprung_landung", 1, 1, "Run");
@@ -1075,7 +1075,7 @@
                 if( mTimer >= 0.3f )
                 {
                     mState = UP;
-                    mMovingCreature->setAbstractLocation(MovingCreature::AL_AIRBORNE);
+                    mMovingCreature->setAbstractLocation(CreatureController::AL_AIRBORNE);
                     //mMovingCreature->setAnimation("rennen_sprung");
                     mJumpNow = true;
                     mApplyForceTimer = 0;
@@ -1098,7 +1098,7 @@
             rotation = Vector3::ZERO;
             return false;
         }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        virtual bool canChangeToMovement(CreatureController::MovementType id)
         {
             return mState == DOWN;
         }
@@ -1131,7 +1131,7 @@
 
 
 
-    MovingCreature::MovingCreature(Creature *creature) :
+    CreatureController::CreatureController(Creature *creature) :
         mCreature(creature),
         mAbstractLocation(AL_AIRBORNE),
         mMovement(NULL),
@@ -1145,7 +1145,7 @@
         mStillWeightedAnimationName(""),
         mLastFloorContact(0)
     {
-        MovingCreatureManager::getSingleton().add(this);
+        CreatureControllerManager::getSingleton().add(this);
         
         const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID("character");
         mCreature->getActor()->getPhysicalThing()->setMaterialID(material);
@@ -1195,7 +1195,7 @@
         mMovementMap.insert(movementPair);
     }
 
-    MovingCreature::~MovingCreature()
+    CreatureController::~CreatureController()
     {
         MovementMap::iterator iter;
         for(iter = mMovementMap.begin(); iter != mMovementMap.end(); iter++)
@@ -1204,10 +1204,10 @@
 
         mCreature->getActor()->getPhysicalThing()->setPhysicsController(NULL);
 
-        MovingCreatureManager::getSingleton().remove(this);
+        CreatureControllerManager::getSingleton().remove(this);
     }
 
-    MovingCreature::MovementType MovingCreature::getMovementId() const
+    CreatureController::MovementType CreatureController::getMovementId() const
     {
         if (mMovement == NULL) 
             return MT_NONE; 
@@ -1215,7 +1215,7 @@
             return mMovement->getId();
     }
 
-    int MovingCreature::getCurrentGS() const
+    int CreatureController::getCurrentGS() const
     {
         int act_gs = mCreature->getWert(Creature::WERT_GS);
         ///@todo wy does this not work
@@ -1223,7 +1223,7 @@
         return max(act_gs,1);
     }
 
-    MeshAnimation *MovingCreature::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName, Real weight)
+    MeshAnimation *CreatureController::setAnimation(const Ogre::String &name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &collisionName, Real weight)
     {
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
         PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
@@ -1303,7 +1303,7 @@
         return meshAnim;
     }
 
-    Ogre::Real MovingCreature::getAnimationTimePlayed() const
+    Ogre::Real CreatureController::getAnimationTimePlayed() const
     {
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
         MeshAnimation *meshAnim = mesh->getAnimation(mLastAnimationName);
@@ -1312,19 +1312,19 @@
         return 0;
     }
 
-    Ogre::Vector3 MovingCreature::getVelocity() const
+    Ogre::Vector3 CreatureController::getVelocity() const
     {
         return 
             mCreature->getActor()->getPhysicalThing()->getOrientation().Inverse() *
             mCreature->getActor()->getPhysicalThing()->_getBody()->getVelocity();
     }
 
-    Ogre::Vector3 MovingCreature::getOmega() const
+    Ogre::Vector3 CreatureController::getOmega() const
     {
         return mCreature->getActor()->getPhysicalThing()->_getBody()->getOmega();
     }
 
-    bool MovingCreature::run(Real elapsedTime)
+    bool CreatureController::run(Real elapsedTime)
     {
         if(mMovement != NULL)
         {
@@ -1343,7 +1343,7 @@
         return false;
     }
 
-    void MovingCreature::OnApplyForceAndTorque(PhysicalThing* thing)
+    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing)
     {
         Vector3 force, torque;
         OgreNewt::Body *body = thing->_getBody();
@@ -1371,7 +1371,7 @@
         body->setTorque(torque);
     }
 
-    int MovingCreature::userProcess()
+    int CreatureController::userProcess()
     {
         // own collision handling (floor, in order to get information for mAbstractLocation)
         Vector3 point;
@@ -1422,7 +1422,7 @@
         return 1;
     }
 
-    AbstractMovement *MovingCreature::getMovementFromId(MovingCreature::MovementType id)
+    AbstractMovement *CreatureController::getMovementFromId(CreatureController::MovementType id)
     {
         MovementMap::iterator iter = mMovementMap.find(id);
         if(iter == mMovementMap.end())
@@ -1433,13 +1433,13 @@
     }
 
 
-    bool MovingCreature::setMovement(MovementType type, Vector3 direction, Vector3 rotation)
+    bool CreatureController::setMovement(MovementType type, Vector3 direction, Vector3 rotation)
     {
         if( mMovement != NULL )
         {
             if( mMovement->getId() == type )
             {
-                MovingCreatureManager::getSingleton().setActive(this);
+                CreatureControllerManager::getSingleton().setActive(this);
                 mDirection = direction;
                 mRotation = rotation;
                 return true;
@@ -1462,7 +1462,7 @@
         {
             if(movement->isPossible())
             {
-                MovingCreatureManager::getSingleton().setActive(this); // runs the old movement if idle!
+                CreatureControllerManager::getSingleton().setActive(this); // runs the old movement if idle!
                 if(mMovement == NULL)
                 {
                     mLastMovementType = MT_NONE;
@@ -1488,7 +1488,7 @@
 
 
 
-    Ogre::Radian MovingCreature::getYaw()
+    Ogre::Radian CreatureController::getYaw()
     {
         Radian yaw = mCreature->getActor()->getWorldOrientation().getYaw();
 

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -20,23 +20,23 @@
 #include "GameTask.h"
 #include "GameLoop.h"
 #include "Exception.h"
-#include "MovingCreatureManager.h"
-#include "MovingCreature.h"
+#include "CreatureControllerManager.h"
+#include "CreatureController.h"
 
 
 using namespace Ogre;
 using namespace std;
 
 
-template<> rl::MovingCreatureManager* Singleton<rl::MovingCreatureManager>::ms_Singleton = 0;
+template<> rl::CreatureControllerManager* Singleton<rl::CreatureControllerManager>::ms_Singleton = 0;
 
 
 namespace rl
 {
-    MovingCreatureManager::MovingCreatureManager() :
+    CreatureControllerManager::CreatureControllerManager() :
             mUpdateIdleTime(1.0f),
             mTimeSinceLastIdleUpdate(0.0f),
-            mName("MovingCreatureManager")
+            mName("CreatureControllerManager")
     {
         GameLoop::getSingleton().addTask(this, GameLoop::TG_LOGIC);
 
@@ -51,7 +51,7 @@
         physicsManager->createMaterialPair(char_mat, level_mat)->setContactCallback(this);
     }
 
-    MovingCreatureManager::~MovingCreatureManager()
+    CreatureControllerManager::~CreatureControllerManager()
     {
         PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
         const OgreNewt::MaterialID *char_mat = physicsManager->getMaterialID("character");
@@ -66,7 +66,7 @@
         GameLoop::getSingleton().removeTask(this);
     }
 
-    void MovingCreatureManager::add(MovingCreature *movingCreature)
+    void CreatureControllerManager::add(CreatureController *movingCreature)
     {
         if(movingCreature == NULL)
         {
@@ -78,14 +78,14 @@
         {
             if( (*iter) == movingCreature )
             {
-                Throw(IllegalArgumentException, "MovingCreature wird schon vom MovingCreatureManager verwaltet.");
+                Throw(IllegalArgumentException, "CreatureController wird schon vom CreatureControllerManager verwaltet.");
             }
         }
         for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
         {
             if( (*iter) == movingCreature )
             {
-                Throw(IllegalArgumentException, "MovingCreature wird schon vom MovingCreatureManager verwaltet.");
+                Throw(IllegalArgumentException, "CreatureController wird schon vom CreatureControllerManager verwaltet.");
             }
         }
 
@@ -96,7 +96,7 @@
     }
 
 
-    void MovingCreatureManager::remove(MovingCreature *movingCreature)
+    void CreatureControllerManager::remove(CreatureController *movingCreature)
     {
         if(movingCreature == NULL)
         {
@@ -108,7 +108,7 @@
 
         if( body_iter == mMovingCreatureFromBody.end() )
         {
-            Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
+            Throw(IllegalArgumentException, "CreatureController wird nicht vom CreatureControllerManager verwaltet.");
         }
 
         mMovingCreatureFromBody.erase(body_iter);
@@ -141,10 +141,10 @@
         }
 
 
-        Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
+        Throw(IllegalArgumentException, "CreatureController wird nicht vom CreatureControllerManager verwaltet.");
     }
 
-    void MovingCreatureManager::run(Real elapsedTime)
+    void CreatureControllerManager::run(Real elapsedTime)
     {
         mTimeSinceLastIdleUpdate += elapsedTime;
 
@@ -166,7 +166,7 @@
     }
 
 
-    void MovingCreatureManager::setActive(MovingCreature* movingCreature)
+    void CreatureControllerManager::setActive(CreatureController* movingCreature)
     {
         if(movingCreature == NULL)
         {
@@ -194,17 +194,17 @@
         {
             if( *iter == movingCreature )
             {
-                LOG_DEBUG(Logger::RULES, "Die angegebene MovingCreature ist schon aktiv.");
+                LOG_DEBUG(Logger::RULES, "Die angegebene CreatureController ist schon aktiv.");
                 return;
             }
         }
 
 
-        Throw(IllegalArgumentException, "MovingCreature wird nicht vom MovingCreatureManager verwaltet.");
+        Throw(IllegalArgumentException, "CreatureController wird nicht vom CreatureControllerManager verwaltet.");
     }
 
 
-    int MovingCreatureManager::userProcess()
+    int CreatureControllerManager::userProcess()
     {
         MovingCreatureBodyMap::iterator iter;
         iter = mMovingCreatureFromBody.find(m_body0);

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -22,7 +22,7 @@
 #include "DsaDataLoader.h"
 #include "EffectFactory.h"
 #include "Logger.h"
-#include "MovingCreatureManager.h"
+#include "CreatureControllerManager.h"
 #include "TimerManager.h"
 #include "GameObjectManager.h"
 #include "QuestBook.h"
@@ -51,8 +51,8 @@
 		LOG_MESSAGE(Logger::RULES, "CombatManager erzeugt");
         mDsaManager = new DsaManager();
 		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
-        mMovingCreatureManager = new MovingCreatureManager();
-		LOG_MESSAGE(Logger::RULES, "MovingCreatureManager erzeugt");
+        mMovingCreatureManager = new CreatureControllerManager();
+		LOG_MESSAGE(Logger::RULES, "CreatureControllerManager erzeugt");
         mTimerManager = new TimerManager(); 
 		LOG_MESSAGE(Logger::RULES, "TimerManager erzeugt");
 		resetQuestBook();

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -261,7 +261,7 @@
 	class CreatureWalkPathJob : public Job
     {
     public:
-        CreatureWalkPathJob(const Ogre::String& name, MovingCreature* movingCreature, Landmark* startLandmark);
+        CreatureWalkPathJob(const Ogre::String& name, CreatureController* movingCreature, Landmark* startLandmark);
 
         void addLandmark(const Ogre::String& name, const Ogre::Vector3& position);
         void addLandmark(Landmark* lm);

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -52,5 +52,5 @@
 #include "TimerListener.h"
 #include "Tripel.h"
 #include "Weapon.h"
-#include "MovingCreature.h"
+#include "CreatureController.h"
 %}

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -751,10 +751,10 @@
         rl::TimerEventSource* getSource() const;
     };
     
-    class MovingCreature
+    class CreatureController
     {
     public:
-        MovingCreature(Creature *character); 
+        CreatureController(Creature *character); 
         
         typedef enum
         {

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -135,18 +135,18 @@
 } //namespace rl
 
 %{
-static swig_type_info *CharacterController_dynamic_cast(void **ptr)
+static swig_type_info *ControlState_dynamic_cast(void **ptr)
 {
-    rl::ControlState **ppCharacterController =
+    rl::ControlState **ppControlState =
         reinterpret_cast<rl::ControlState**>(ptr);
 
-    rl::CutsceneControlState *pCutSceneCC =
-        dynamic_cast<rl::CutsceneControlState*>(*ppCharacterController);
-    if (pCutSceneCC != NULL) {
-        *ptr=pCutSceneCC;
-        return SWIGTYPE_p_rl__CutsceneCharacterController;
+    rl::CutsceneControlState *pCutSceneCS =
+        dynamic_cast<rl::CutsceneControlState*>(*ppControlState);
+    if (pCutSceneCS != NULL) {
+        *ptr=pCutSceneCS;
+        return SWIGTYPE_p_rl__CutsceneControlState;
     }
     return 0;
 }
 %}
-DYNAMIC_CAST(SWIGTYPE_p_rl__CharacterController, CharacterController_dynamic_cast);
+DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -19,7 +19,7 @@
 
 #include "UiPrerequisites.h"
 #include "GameTask.h"
-#include "MovingCreature.h"
+#include "CreatureController.h"
 #include "PhysicsController.h"
 #include "PhysicsGenericContactCallback.h"
 #include "ControlState.h"
@@ -85,7 +85,7 @@
 
     protected:
         virtual void doCreatePrimitive();
-        MovingCreature *mMovingCreature;
+        CreatureController *mMovingCreature;
 
     private:
 

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -180,7 +180,7 @@
     void MovementControlState::resume()
     {
         if( mMovingCreature == NULL )
-            mMovingCreature = new MovingCreature(mCharacter);
+            mMovingCreature = new CreatureController(mCharacter);
 
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacter);
@@ -287,7 +287,7 @@
             int movement = mCharacterState.mCurrentMovementState;
             Degree rotation(0);
 
-            AbstractMovement *drehen = mMovingCreature->getMovementFromId(MovingCreature::MT_DREHEN);
+            AbstractMovement *drehen = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
             Real baseVelocity = 0;
             if( drehen->calculateBaseVelocity(baseVelocity) )
             {
@@ -336,18 +336,18 @@
                 else if( movement & MOVE_BACKWARD)
                     direction.z = 1;
                 mMovingCreature->setMovement(
-                    MovingCreature::MT_SCHLEICHEN,
+                    CreatureController::MT_SCHLEICHEN,
                     direction,
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else if( movement & MOVE_JUMP && 
-                mMovingCreature->getMovementFromId(MovingCreature::MT_HOCHSPRUNG)->isPossible() )
+                mMovingCreature->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
             {
-                MovingCreature::MovementType type = MovingCreature::MT_HOCHSPRUNG;
+                CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
                 Vector3 direction = Vector3::UNIT_Y;
                 if( movement & MOVE_FORWARD )
                 {
-                    type = MovingCreature::MT_WEITSPRUNG;
+                    type = CreatureController::MT_WEITSPRUNG;
                     direction += Vector3::NEGATIVE_UNIT_Z;
                 }
                 mMovingCreature->setMovement(
@@ -357,20 +357,20 @@
             }
             else if( movement & MOVE_FORWARD )
             {
-                MovingCreature::MovementType type = MovingCreature::MT_GEHEN;
+                CreatureController::MovementType type = CreatureController::MT_GEHEN;
                 if( movement & MOVE_RUN_LOCK )
                 {
                     if( movement & MOVE_RUN )
-                        type = MovingCreature::MT_RENNEN;
+                        type = CreatureController::MT_RENNEN;
                     else
-                        type = MovingCreature::MT_LAUFEN;
+                        type = CreatureController::MT_LAUFEN;
                 }
                 else
                 {
                     if( movement & MOVE_RUN )
-                        type = MovingCreature::MT_GEHEN;
+                        type = CreatureController::MT_GEHEN;
                     else
-                        type = MovingCreature::MT_JOGGEN;
+                        type = CreatureController::MT_JOGGEN;
                 }
                 mMovingCreature->setMovement(
                     type,
@@ -379,9 +379,9 @@
             }
             else if (movement & MOVE_BACKWARD )
             {
-                MovingCreature::MovementType type = MovingCreature::MT_RUECKWAERTS_GEHEN;
+                CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
                 if( !(movement & MOVE_RUN) )
-                    type = MovingCreature::MT_RUECKWAERTS_JOGGEN;
+                    type = CreatureController::MT_RUECKWAERTS_JOGGEN;
                 mMovingCreature->setMovement(
                     type,
                     Vector3(0,0,1), 
@@ -393,14 +393,14 @@
                 if( movement & MOVE_LEFT )
                     direction = Vector3::NEGATIVE_UNIT_X;
                 mMovingCreature->setMovement(
-                    MovingCreature::MT_SEITWAERTS_GEHEN,
+                    CreatureController::MT_SEITWAERTS_GEHEN,
                     direction, 
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else
             {
                 mMovingCreature->setMovement(
-                    MovingCreature::MT_STEHEN, 
+                    CreatureController::MT_STEHEN, 
                     Vector3(0,0,0),
                     Vector3(0, rotation.valueRadians(), 0) );
             }
@@ -503,7 +503,7 @@
     }
 
     // -------------------------------------------------------------
-    // character collision moved to MovingCreature(Manager)
+    // character collision moved to CreatureController(Manager)
     int MovementControlState::userProcess()
     {
         // only camera collision
@@ -519,7 +519,7 @@
     }
 
     //------------------------------------------------------------------------
-    // character callback moved to MovingCreature
+    // character callback moved to CreatureController
     void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
@@ -530,7 +530,7 @@
 
 
 
-        ///@todo move to MovingCreature?
+        ///@todo move to CreatureController?
         SceneNode* node = mCharacterActor->_getSceneNode();
         std::ostringstream ss;
         Vector3 bodpos, playpos = node->getPosition();
@@ -550,7 +550,7 @@
             << "camera actor : " << mCameraActor->getWorldPosition() << std::endl
             << "camera body pos : " << bodpos << std::endl
             << "camera distance : " << mDesiredDistance << std::endl
-            << "is airborne: " << (mMovingCreature->getAbstractLocation() == MovingCreature::AL_AIRBORNE ? "true" : "false") << std::endl;
+            << "is airborne: " << (mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());



From timm at mail.berlios.de  Tue Jul  3 12:35:15 2007
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 3 Jul 2007 12:35:15 +0200
Subject: [Dsa-hl-svn] r3581 - in modules: combattest/scripts/maps
	regressiontest/scripts regressiontest/scripts/maps
Message-ID: <200707031035.l63AZFoa011743@sheep.berlios.de>

Author: timm
Date: 2007-07-03 12:35:05 +0200 (Tue, 03 Jul 2007)
New Revision: 3581

Modified:
   modules/combattest/scripts/maps/combattest.rb
   modules/regressiontest/scripts/LightzoneTest.rb
   modules/regressiontest/scripts/MapLoadingTest.rb
   modules/regressiontest/scripts/WalkJobTest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
displaced MovingCreature -> CreatureController

Modified: modules/combattest/scripts/maps/combattest.rb
===================================================================
--- modules/combattest/scripts/maps/combattest.rb	2007-07-02 21:21:48 UTC (rev 3580)
+++ modules/combattest/scripts/maps/combattest.rb	2007-07-03 10:35:05 UTC (rev 3581)
@@ -34,9 +34,9 @@
 wolf2.modifyAu(1000)
 #wolf2.setWert("ModAU", 10)
 
-movingCreature = MovingCreature.new(wolf2)
+creatureController = CreatureController.new(wolf2)
 
-job = CreatureWalkPathJob.new("TestWalkJob", movingCreature, Landmark.new("point", [5.0, 0.0, -10.0]))
+job = CreatureWalkPathJob.new("TestWalkJob", creatureController, Landmark.new("point", [5.0, 0.0, -10.0]))
 job.addLandmark("1",[5.0,0.0,-20.0])
 job.addLandmark("2",[5.0,0.0,-15.0])
 $JS.addJob(job);

Modified: modules/regressiontest/scripts/LightzoneTest.rb
===================================================================
--- modules/regressiontest/scripts/LightzoneTest.rb	2007-07-02 21:21:48 UTC (rev 3580)
+++ modules/regressiontest/scripts/LightzoneTest.rb	2007-07-03 10:35:05 UTC (rev 3581)
@@ -12,6 +12,7 @@
 	  
 	  MapLoader.new("regressiontest").loadMap("regressiontest_lights.rlmap.xml")
 
+	  $SCRIPT.log("LightzoneTest initialisiert")
   end
 end
 

Modified: modules/regressiontest/scripts/MapLoadingTest.rb
===================================================================
--- modules/regressiontest/scripts/MapLoadingTest.rb	2007-07-02 21:21:48 UTC (rev 3580)
+++ modules/regressiontest/scripts/MapLoadingTest.rb	2007-07-03 10:35:05 UTC (rev 3581)
@@ -37,5 +37,7 @@
         p custom2
         p custom2
         p custom2.getActor()
+		
+		$SCRIPT.log("MapLoadingTest initialisiert")
     end
 end

Modified: modules/regressiontest/scripts/WalkJobTest.rb
===================================================================
--- modules/regressiontest/scripts/WalkJobTest.rb	2007-07-02 21:21:48 UTC (rev 3580)
+++ modules/regressiontest/scripts/WalkJobTest.rb	2007-07-03 10:35:05 UTC (rev 3581)
@@ -7,11 +7,13 @@
 	walkingCreature.setPosition(getCenter())
 	walkingCreature.modifyAu(1000)
 
-    movingCreature = MovingCreature.new(walkingCreature)
+    creatureController = CreatureController.new(walkingCreature)
 
-    job = CreatureWalkPathJob.new("WalkJobTest", movingCreature, Landmark.new("point", [5.0, 0.0, -10.0]))
+    job = CreatureWalkPathJob.new("WalkJobTest", creatureController, Landmark.new("point", [5.0, 0.0, -10.0]))
     job.addLandmark("1",[5.0,0.0,-20.0])
     job.addLandmark("2",[5.0,0.0,-15.0])
 	$JS.addJob(job);
+	
+	$SCRIPT.log("WalkJobTest initialisiert")
   end
 end
\ No newline at end of file

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-07-02 21:21:48 UTC (rev 3580)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-07-03 10:35:05 UTC (rev 3581)
@@ -50,7 +50,7 @@
    MapLoadingTest.new([-5, 0, -10]).run()
 MergeableMeshTest.new([10, 0, 0]).run()
      SelectorTest.new([5, 0, 0]).run()
-	  WalkJobTest.new([0.0,0.0,-3.0]).run()
+	  WalkJobTest.new([0.0,0.0,0.0]).run()
 
 $SCRIPT.log("tests initialisiert.");
 



From blakharaz at mail.berlios.de  Tue Jul  3 15:49:36 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 3 Jul 2007 15:49:36 +0200
Subject: [Dsa-hl-svn] r3582 - in rl/trunk/engine: core/include rules/include
	rules/src ui/include ui/src
Message-ID: <200707031349.l63Dnaai032469@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-03 15:49:30 +0200 (Tue, 03 Jul 2007)
New Revision: 3582

Modified:
   rl/trunk/engine/core/include/CameraObject.h
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/Makefile.am
Log:
Fix Linux build

Modified: rl/trunk/engine/core/include/CameraObject.h
===================================================================
--- rl/trunk/engine/core/include/CameraObject.h	2007-07-03 10:35:05 UTC (rev 3581)
+++ rl/trunk/engine/core/include/CameraObject.h	2007-07-03 13:49:30 UTC (rev 3582)
@@ -70,7 +70,7 @@
 		 * @param y y coordinate on screen
 		 * @return the ray direction
 		 */
-		Ogre::Vector3 CameraObject::getDirectionFromScreenPosition(
+		Ogre::Vector3 getDirectionFromScreenPosition(
 			const Ogre::Real& x, const Ogre::Real& y) const;
 
 		Ogre::Ray getCameraToViewportRay(

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-07-03 10:35:05 UTC (rev 3581)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-07-03 13:49:30 UTC (rev 3582)
@@ -6,6 +6,8 @@
 	CombatManager.h \
 	Container.h \
 	Creature.h \
+	CreatureController.h \
+	CreatureControllerManager.h \
 	Date.h \
 	DsaDataLoader.h \
 	DsaManager.h \
@@ -21,8 +23,6 @@
 	Inventory.h \
 	JournalEntry.h \
 	Kampftechnik.h \
-	MovingCreatureManager.h \
-	MovingCreature.h \
 	ObjectStateChangeEvent.h \
 	ObjectStateChangeEventSource.h \
 	ObjectStateChangeListener.h \

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-07-03 10:35:05 UTC (rev 3581)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-07-03 13:49:30 UTC (rev 3582)
@@ -10,6 +10,8 @@
 	CombatManager.cpp \
 	Container.cpp \
 	Creature.cpp \
+	CreatureController.cpp \
+	CreatureControllerManager.cpp \
 	Date.cpp \
 	DsaDataLoader.cpp \
 	DsaManager.cpp \
@@ -24,8 +26,6 @@
 	Inventory.cpp \
 	JournalEntry.cpp \
 	Kampftechnik.cpp \
-	MovingCreatureManager.cpp \
-	MovingCreature.cpp \
 	ObjectStateChangeEvent.cpp \
 	ObjectStateChangeEventSource.cpp \
 	ObjectStateChangeListener.cpp \

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-07-03 10:35:05 UTC (rev 3581)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-07-03 13:49:30 UTC (rev 3582)
@@ -3,24 +3,23 @@
     ActionChoiceWindow.h \
     AbstractWindow.h \
     CeGuiHelper.h \
-    CharacterController.h \
     CharacterSheetWindow.h \
     CharacterStateWindow.h \
     CloseConfirmationWindow.h \
-    CombatCharacterController.h \
+    CombatControlState.h \
 	CombatWindow.h \
     CommandMapper.h \
     ConfigComponent.h \
     Console.h \
     ContainerContentWindow.h \
-    CutsceneCharacterController.h \
+    ControlState.h \
+    CutsceneControlState.h \
     DebugWindow.h \
     DialogWindow.h \
-    DialogCharacterController.h \
-    FreeFlightCharacterController.h \
+    DialogControlState.h \
+    FreeflightControlState.h \
     GameLoggerWindow.h \
     GameObjectInfoWindow.h \
-    GameObjectPropsWindow.h \
     SaveLoadWindow.h \
     GameSettings.h \
     InfoPopup.h \
@@ -34,10 +33,11 @@
     MainMenuWindow.h \
     MainMenuEngineWindow.h \
     MessageWindow.h \
-    MovementCharacterController.h \
+    MovementControlState.h \
     ObjectDescriptionWindow.h \
     PlaylistWindow.h \
     ProgressWindow.h \
+    PropertiesWindow.h \
     RenderSystemConfigComponent.h \
     SaveLoadWindow.h \
     SoundDriverConfigComponent.h \

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-07-03 10:35:05 UTC (rev 3581)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-07-03 13:49:30 UTC (rev 3582)
@@ -11,24 +11,23 @@
     AboutWindow.cpp \
     ActionChoiceWindow.cpp \
     AbstractWindow.cpp \
-    CharacterController.cpp \
     CharacterSheetWindow.cpp \
     CharacterStateWindow.cpp \
     CloseConfirmationWindow.cpp \
-    CombatCharacterController.cpp \
+    CombatControlState.cpp \
 	CombatWindow.cpp \
     CommandMapper.cpp \
     ConfigComponent.cpp \
     ContainerContentWindow.cpp \
+    ControlState.cpp \
     Console.cpp \
-    CutsceneCharacterController.cpp \
+    CutsceneControlState.cpp \
     DebugWindow.cpp \
-    DialogCharacterController.cpp \
+    DialogControlState.cpp \
     DialogWindow.cpp \
-    FreeFlightCharacterController.cpp \
+    FreeflightControlState.cpp \
     GameLoggerWindow.cpp \
     GameObjectInfoWindow.cpp \
-    GameObjectPropsWindow.cpp \
     GameSettings.cpp \
     InfoPopup.cpp \
     InGameMenuWindow.cpp \
@@ -41,10 +40,11 @@
     MainMenuWindow.cpp \
     MainMenuEngineWindow.cpp \
     MessageWindow.cpp \
-    MovementCharacterController.cpp \
+    MovementControlState.cpp \
     ObjectDescriptionWindow.cpp \
     PlaylistWindow.cpp \
     ProgressWindow.cpp \
+    PropertiesWindow.cpp \
     RenderSystemConfigComponent.cpp \
     SaveLoadWindow.cpp \
     SoundConfig.cpp \



From blakharaz at mail.berlios.de  Tue Jul  3 15:51:47 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 3 Jul 2007 15:51:47 +0200
Subject: [Dsa-hl-svn] r3583 - rl/trunk/m4
Message-ID: <200707031351.l63DplCN032712@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-03 15:51:46 +0200 (Tue, 03 Jul 2007)
New Revision: 3583

Modified:
   rl/trunk/m4/boost.m4
Log:
Also look for libboost_XYT-mt.so (fixes build problems with boost 1.40 on my system)

Modified: rl/trunk/m4/boost.m4
===================================================================
--- rl/trunk/m4/boost.m4	2007-07-03 13:49:30 UTC (rev 3582)
+++ rl/trunk/m4/boost.m4	2007-07-03 13:51:46 UTC (rev 3583)
@@ -240,8 +240,8 @@
 			AC_DEFINE(HAVE_BOOST_FILESYSTEM,,[define if the Boost::Filesystem library is available])
 			BN=boost_filesystem
             if test "x$ax_boost_user_filesystem_lib" = "x"; then
-    			for ax_lib in $BN $BN-$CC $BN-$CC-mt $BN-$CC-mt-s $BN-$CC-s \
-                              lib$BN lib$BN-$CC lib$BN-$CC-mt lib$BN-$CC-mt-s lib$BN-$CC-s \
+    			for ax_lib in $BN $BN-mt $BN-$CC $BN-$CC-mt $BN-$CC-mt-s $BN-$CC-s \
+                              lib$BN lib$BN-mt lib$BN-$CC lib$BN-$CC-mt lib$BN-$CC-mt-s lib$BN-$CC-s \
                               $BN-mgw $BN-mgw $BN-mgw-mt $BN-mgw-mt-s $BN-mgw-s ; do
 				    AC_CHECK_LIB($ax_lib, main,
                                  [BOOST_FILESYSTEM_LIB="-l$ax_lib" AC_SUBST(BOOST_FILESYSTEM_LIB) link_filesystem="yes" break],



From blakharaz at mail.berlios.de  Tue Jul  3 21:57:18 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 3 Jul 2007 21:57:18 +0200
Subject: [Dsa-hl-svn] r3584 - in rl/trunk/engine/ui: include src
Message-ID: <200707031957.l63JvIse007891@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-03 21:57:10 +0200 (Tue, 03 Jul 2007)
New Revision: 3584

Modified:
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
- Fix bad pointer when moving an object from outside the inventory to outside the inventory
- Fix bad pointer when exiting while inventory is open and mouse is outside the inventory window


Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-07-03 13:51:46 UTC (rev 3583)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-07-03 19:57:10 UTC (rev 3584)
@@ -26,10 +26,12 @@
     class Inventory;
 	class Item;
 	class ItemDragContainer;
+	class RaySelector;
 
 	class _RlUiExport InventoryWindow : public AbstractWindow
 	{
 	public:
+		///@todo where to put this, it is used in ContainerContentWindow too
 		static const Ogre::String ICON_UNKNOWN_ITEM;
 		static const Ogre::String SLOTNAME;
 
@@ -43,6 +45,7 @@
         std::map<CeGuiString, CEGUI::Window*> mSlotWindows;
 		CEGUI::Window* mWorldBackground;
 		DndContainerMap mDragContainers;
+		RaySelector* mMouseSelector;
 
 		void createSlotWindows(Inventory* inventory);
         void initInventoryWindow(Inventory* inventory);

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-03 13:51:46 UTC (rev 3583)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-03 19:57:10 UTC (rev 3584)
@@ -48,11 +48,14 @@
 
         createSlotWindows(inventory);
         initInventoryWindow(inventory);
+
+		mMouseSelector = new RaySelector(QUERYFLAG_ITEM, true);
     }
 
     InventoryWindow::~InventoryWindow()
     {
 		mWorldBackground->removeAllEvents();
+		delete mMouseSelector;
     }
 
     void InventoryWindow::createSlotWindows(Inventory* inventory)
@@ -297,16 +300,15 @@
 		CEGUI::Point mousePos = mevt.position;
 		mousePos.d_x /= getRoot()->getPixelSize().d_width;
 		mousePos.d_y /= getRoot()->getPixelSize().d_height;
-		static RaySelector sel(QUERYFLAG_ITEM, true);
 		Ogre::Ray camToWorld = camera->getCameraToViewportRay(
 			mousePos.d_x, mousePos.d_y); 
 		Ogre::Vector3 rayStart = camera->getCamera()->getWorldPosition();
 		Ogre::Vector3 rayDir = camera->getDirectionFromScreenPosition(
 			mousePos.d_x, mousePos.d_y); 
-		sel.setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
 
-		sel.updateSelection();
-		Selector::GameObjectVector objs = sel.getAllSelectedObjects();
+		mMouseSelector->setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
+		mMouseSelector->updateSelection();
+		Selector::GameObjectVector objs = mMouseSelector->getAllSelectedObjects();
 		
 		///@todo select, ...
 		if (!objs.empty())
@@ -423,10 +425,10 @@
 
 	bool InventoryWindow::destroyDragContainer(rl::ItemDragContainer* cont)
 	{
+		cont->removeAllEvents();
 		mWorldBackground->removeChildWindow(cont);
+		mDragContainers.erase(cont->getName());
 		CEGUI::WindowManager::getSingleton().destroyWindow(cont->getContentWindow());
-		mDragContainers.erase(cont->getName());
-		delete cont;
 
 		return true;
 	}



From blakharaz at mail.berlios.de  Wed Jul  4 00:22:02 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 4 Jul 2007 00:22:02 +0200
Subject: [Dsa-hl-svn] r3585 - modules/common/gui/windows rl/trunk/engine/ui
	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
Message-ID: <200707032222.l63MM2wp020064@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-04 00:21:46 +0200 (Wed, 04 Jul 2007)
New Revision: 3585

Added:
   modules/common/gui/windows/itemdescriptiondragcontainer.xml
   modules/common/gui/windows/itemicondragcontainer.xml
   rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h
   rl/trunk/engine/ui/include/ItemIconDragContainer.h
   rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
   rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
Modified:
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/include/ItemDragContainer.h
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
   rl/trunk/engine/ui/src/Makefile.am
Log:
Present item description in a nice window when selecting gameobjects in world

Added: modules/common/gui/windows/itemdescriptiondragcontainer.xml
===================================================================
--- modules/common/gui/windows/itemdescriptiondragcontainer.xml	2007-07-03 19:57:10 UTC (rev 3584)
+++ modules/common/gui/windows/itemdescriptiondragcontainer.xml	2007-07-03 22:21:46 UTC (rev 3585)
@@ -0,0 +1,28 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+    <Window Type="DefaultWindow" Name="ItemDescriptionDragContainer">
+		<Property Name="UnifiedSize" Value="{{0,250},{0,120}}" />
+        <Window Type="RastullahLook/StaticImage" Name="ItemDescriptionDragContainer/Icon">
+            <Property Name="VerticalAlignment" Value="Bottom" />
+            <Property Name="HorizontalAlignment" Value="Left" />
+            <Property Name="UnifiedPosition" Value="{{0,2},{0,2}}" />
+            <Property Name="UnifiedSize" Value="{{0,90},{0,90}}" />
+			<Property Name="FrameEnabled" Value="False"/>
+        </Window>
+        <Window Type="RastullahLook/StaticText" Name="ItemDescriptionDragContainer/Name">
+            <Property Name="VerticalAlignment" Value="Top" />
+            <Property Name="HorizontalAlignment" Value="Center" />
+            <Property Name="UnifiedPosition" Value="{{0.0,100},{0,5}}" />
+            <Property Name="UnifiedSize" Value="{{0.95,-100},{0,24}}" />
+            <Property Name="Font" Value="Vera Serif-10" />
+            <Property Name="FrameEnabled" Value="false" />
+        </Window>
+        <Window Type="RastullahLook/MultiLineEditbox" Name="ItemDescriptionDragContainer/Description">
+            <Property Name="ReadOnly" Value="true"/>
+            <Property Name="Disabled" Value="true"/>
+            <Property Name="UnifiedPosition" Value="{{0.0,100},{0,30}}" />
+            <Property Name="UnifiedSize" Value="{{0.95,-100},{0.95,-30}}" />
+            <Property Name="Font" Value="Vera Serif-8" />
+            <Property Name="FrameEnabled" Value="false" />
+        </Window>
+    </Window>
+</GUILayout> 

Added: modules/common/gui/windows/itemicondragcontainer.xml
===================================================================
--- modules/common/gui/windows/itemicondragcontainer.xml	2007-07-03 19:57:10 UTC (rev 3584)
+++ modules/common/gui/windows/itemicondragcontainer.xml	2007-07-03 22:21:46 UTC (rev 3585)
@@ -0,0 +1,11 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+    <Window Type="DefaultWindow" Name="ItemIconDragContainer">
+        <Window Type="RastullahLook/StaticImage" Name="ItemIconDragContainer/Icon">
+            <Property Name="VerticalAlignment" Value="Bottom" />
+            <Property Name="HorizontalAlignment" Value="Left" />
+            <Property Name="UnifiedPosition" Value="{{0,0},{0,0}}" />
+            <Property Name="UnifiedSize" Value="{{1,0},{1,0}}" />
+			<Property Name="FrameEnabled" Value="False"/>
+        </Window>
+    </Window>
+</GUILayout> 

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-03 22:21:46 UTC (rev 3585)
@@ -469,10 +469,18 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\ItemDescriptionDragContainer.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\ItemDragContainer.h"
 					>
 				</File>
 				<File
+					RelativePath=".\include\ItemIconDragContainer.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\JournalWindow.h"
 					>
 				</File>
@@ -662,10 +670,18 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\ItemDescriptionDragContainer.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\ItemDragContainer.cpp"
 					>
 				</File>
 				<File
+					RelativePath=".\src\ItemIconDragContainer.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\JournalWindow.cpp"
 					>
 				</File>

Modified: rl/trunk/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AbstractWindow.h	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2007-07-03 22:21:46 UTC (rev 3585)
@@ -57,7 +57,10 @@
 
 		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
 		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
-		
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
+
 		/// gets the CEGUI root
 		static CEGUI::Window* getRoot();
 
@@ -109,8 +112,6 @@
 		void bindDestroyWindowToXButton();
 		void bindHideWindowToXButton();
 
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
-
 		const CeGuiString& getUserDataType(CEGUI::Window* window) const;
 		void setUserDataType(CEGUI::Window* window, const CeGuiString& typeDescription) const;
 

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-07-03 22:21:46 UTC (rev 3585)
@@ -19,10 +19,13 @@
 
 #include "UiPrerequisites.h"
 
+#include <OgreRectangle.h>
+
 #include "AbstractWindow.h"
 
 namespace rl {
 
+	class CameraObject;
     class Inventory;
 	class Item;
 	class ItemDragContainer;
@@ -31,8 +34,6 @@
 	class _RlUiExport InventoryWindow : public AbstractWindow
 	{
 	public:
-		///@todo where to put this, it is used in ContainerContentWindow too
-		static const Ogre::String ICON_UNKNOWN_ITEM;
 		static const Ogre::String SLOTNAME;
 
 		InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory);
@@ -50,7 +51,7 @@
 		void createSlotWindows(Inventory* inventory);
         void initInventoryWindow(Inventory* inventory);
 
-		ItemDragContainer* createItemDragContainer(Item* item, const CeGuiString& containerName = "");
+		ItemDragContainer* createItemDragContainer(Item* item, bool showdescription, const CeGuiString& containerName = "");
 		bool handleItemDroppedOnSlot(const CEGUI::EventArgs& evt);
 		bool handleItemDroppedOnWorld(const CEGUI::EventArgs& evt);
 		bool handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
@@ -58,6 +59,10 @@
 		bool handleMouseMovedInWorld(const CEGUI::EventArgs& evt);
 		bool handleKeys(const CEGUI::EventArgs& evt, bool down);
 		bool destroyDragContainer(ItemDragContainer* cont);
+
+		Ogre::Rectangle getCeGuiRectFromWorldAABB(
+			CameraObject* camera,
+			const Ogre::AxisAlignedBox& aabb) const;
     };
 }
 

Added: rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h	2007-07-03 22:21:46 UTC (rev 3585)
@@ -0,0 +1,33 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __ItemDescriptionDragContainer_H__
+#define __ItemDescriptionDragContainer_H__
+
+#include "UiPrerequisites.h"
+
+#include "ItemDragContainer.h"
+
+namespace rl 
+{
+	class ItemDescriptionDragContainer : public ItemDragContainer
+	{
+	public:
+		ItemDescriptionDragContainer(Item* item, const CeGuiString& name);
+	};
+
+} // namespace rl
+
+#endif //__ItemDescriptionDragContainer_H__

Modified: rl/trunk/engine/ui/include/ItemDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDragContainer.h	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/include/ItemDragContainer.h	2007-07-03 22:21:46 UTC (rev 3585)
@@ -30,8 +30,10 @@
 	class ItemDragContainer : public CEGUI::DragContainer
 	{
 	public:
-		ItemDragContainer(Item* item, const CeGuiString& name);
+		static const Ogre::String ICON_UNKNOWN_ITEM;
 		
+		~ItemDragContainer();
+		
 		void setItemParent(Container* container);
 		void setItemParent(Inventory* inventory, const CeGuiString& slotname);
 		Container* getItemParentContainer() const;
@@ -39,9 +41,11 @@
 		Inventory* getItemParentInventory() const;
 		Item* getItem() const;
 		CEGUI::Window* getContentWindow() const;
-		void setContentWindow(CEGUI::Window* window);
-
+	
 	protected:
+		CEGUI::Window* mContentWindow;
+		
+		ItemDragContainer(Item* item, const CeGuiString& name);
 		virtual bool testClassName_impl(const CEGUI::String& class_name) const;
 
 	private:
@@ -49,7 +53,6 @@
 		Container* mParentContainer;
 		CeGuiString mParentSlot;
 		Inventory* mInventory;
-		CEGUI::Window* mContentWindow;
 	};
 
 } // namespace rl

Added: rl/trunk/engine/ui/include/ItemIconDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemIconDragContainer.h	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/include/ItemIconDragContainer.h	2007-07-03 22:21:46 UTC (rev 3585)
@@ -0,0 +1,35 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __ItemIconDragContainer_H__
+#define __ItemIconDragContainer_H__
+
+#include "UiPrerequisites.h"
+
+#include "ItemDragContainer.h"
+
+namespace rl 
+{
+	class Item;
+
+	class ItemIconDragContainer : public ItemDragContainer
+	{
+	public:
+		ItemIconDragContainer(Item* item, const CeGuiString& name);
+	};
+
+} // namespace rl
+
+#endif //__ItemIconDragContainer_H__

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-07-03 22:21:46 UTC (rev 3585)
@@ -27,6 +27,8 @@
     InputManager.h \
     InventoryWindow.h \
     ItemDragContainer.h \
+    ItemDescriptionDragContainer.h \
+    ItemIconDragContainer.h \
     JournalWindow.h \
     ListboxWrappedTextItem.h \
     LogWindow.h \

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-07-03 22:21:46 UTC (rev 3585)
@@ -23,8 +23,7 @@
 
 #include "Container.h"
 #include "Inventory.h"
-#include "InventoryWindow.h"
-#include "ItemDragContainer.h"
+#include "ItemIconDragContainer.h"
 #include "WindowFactory.h"
 
 using namespace CEGUI;
@@ -133,32 +132,26 @@
 
 		if (icon == "")
 		{
-			icon = InventoryWindow::ICON_UNKNOWN_ITEM;
+			icon = ItemDragContainer::ICON_UNKNOWN_ITEM;
 		}
 
-        LOG_MESSAGE("IW", icon);
-        Window* itemWindow = 
-	        CEGUI::WindowManager::getSingletonPtr()->createWindow(
-		    "RastullahLook/StaticImage", 
-			mWindow->getName() + "/" + icon 
-			+ "/" + CEGUI::PropertyHelper::intToString(sItemCount++));
-        itemWindow->setProperty("Image", icon);
-        itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-        itemWindow->setSize(
-            UVector2(cegui_absdim(item->getSize().first*30),
-                     cegui_absdim(item->getSize().second*30)));
+   //     LOG_MESSAGE("IW", icon);
+   //     Window* itemWindow = 
+	  //      CEGUI::WindowManager::getSingletonPtr()->createWindow(
+		 //   "RastullahLook/StaticImage", 
+			//mWindow->getName() + "/" + icon 
+			//+ "/" + CEGUI::PropertyHelper::intToString(sItemCount++));
+   //     itemWindow->setProperty("Image", icon);
+   //     itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+   //     itemWindow->setSize(UVector2(cegui_reldim(1), cegui_reldim(1)));
+		CeGuiString dragContainerName = 
+			mWindow->getName() +  "/item/" 
+			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
 
-		ItemDragContainer* itemhandler = new ItemDragContainer(item, 
-			"DragContainer_"+itemWindow->getName());
+		ItemDragContainer* itemhandler = new ItemIconDragContainer(item, 
+			dragContainerName);
 		itemhandler->setItemParent(mContainer);
 		itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-		itemhandler->setSize(
-			UVector2(cegui_absdim(item->getSize().first*30),
-					 cegui_absdim(item->getSize().second*30))); 
-		itemhandler->setUserData(item);
-		itemhandler->setTooltipText(item->getName());
-		itemhandler->addChildWindow(itemWindow);
-		
 
 		return itemhandler;
 	}

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-03 22:21:46 UTC (rev 3585)
@@ -26,16 +26,17 @@
 #include "Creature.h"
 #include "Inventory.h"
 #include "Item.h"
-#include "ItemDragContainer.h"
+#include "ItemDescriptionDragContainer.h"
+#include "ItemIconDragContainer.h"
 #include "Selector.h"
 #include "WindowFactory.h"
 
 using namespace CEGUI;
+using namespace Ogre;
 using namespace std;
 
 namespace rl {
 
-	const Ogre::String InventoryWindow::ICON_UNKNOWN_ITEM = "set:ModelThumbnails image:item_unknown";
 	const Ogre::String InventoryWindow::SLOTNAME = "slotname";
 
     InventoryWindow::InventoryWindow(const Ogre::String& inventoryWindow, Inventory* inventory)
@@ -120,7 +121,7 @@
             if (item != NULL)
             {
                 LOG_MESSAGE(Logger::UI, slotName + " - " + item->getDescription());
-				Window* itemWindow = createItemDragContainer(item, slotName);
+				Window* itemWindow = createItemDragContainer(item, false, slotName);
 				if (itemWindow != NULL)
 				{
 					slotWindow->addChildWindow(itemWindow);
@@ -139,32 +140,34 @@
 			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
     }
 
-	ItemDragContainer* InventoryWindow::createItemDragContainer(Item* item, const CeGuiString& slotName)
+	ItemDragContainer* InventoryWindow::createItemDragContainer(
+		Item* item, bool showdescription, const CeGuiString& slotName)
 	{
-        CeGuiString icon = item->getImageName();
-
-		if (icon == "")
-		{
-			icon = ICON_UNKNOWN_ITEM;
-		}
-
-		CeGuiString itemWindowName = mWindow->getName() + "/" + slotName + "/" + icon + item->getId();
-		CeGuiString dragContainerName = itemWindowName+"_DragContainer";
+		CeGuiString dragContainerName = 
+			mWindow->getName() +  "/item/" 
+			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
 		ItemDragContainer* itemhandler = NULL;
 
 		DndContainerMap::iterator it = mDragContainers.find(dragContainerName);
 		if (it != mDragContainers.end())
 		{
-			itemhandler = it->second;
+			//itemhandler = it->second;
 			return NULL; ///@todo just a test
 		}
 		else
 		{
-	        Window* itemWindow = CEGUI::WindowManager::getSingletonPtr()->createWindow(
-				"RastullahLook/StaticImage", 
-				itemWindowName);
-			itemWindow->setProperty("Image", icon);
+			if (showdescription)
+				itemhandler = new ItemDescriptionDragContainer(item, dragContainerName);
+			else
+				itemhandler = new ItemIconDragContainer(item, dragContainerName);
 
+			if (slotName != "")
+			{
+				itemhandler->setItemParent(mInventory, slotName);
+			}
+
+			Window* itemWindow = itemhandler->getContentWindow();
+
 			itemWindow->subscribeEvent(
 				Window::EventMouseClick,
 				boost::bind(&InventoryWindow::handleItemMouseClick, this, _1, item));
@@ -172,22 +175,9 @@
 			itemWindow->subscribeEvent(
 				Window::EventMouseDoubleClick,
 				boost::bind(&InventoryWindow::handleItemDoubleClick, this, _1, item));
-			
-			itemhandler = new ItemDragContainer(item, dragContainerName);
-			if (slotName != "")
-			{
-				itemhandler->setItemParent(mInventory, slotName);
-			}
 
 			itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-			itemhandler->setSize(
-				UVector2(cegui_absdim(item->getSize().first*30),
-						 cegui_absdim(item->getSize().second*30))); 
-			itemhandler->setTooltipText(item->getName());
-			itemhandler->setContentWindow(itemWindow);
 
-			itemhandler->setTooltipText(item->getName());
-
 			mDragContainers[dragContainerName] = itemhandler;
 		}
 
@@ -322,14 +312,19 @@
 					"Selected " + (*it)->getDescription());
 
 				ItemDragContainer* cont = 
-					createItemDragContainer(static_cast<Item*>(*it));
+					createItemDragContainer(static_cast<Item*>(*it), true);
 				if (cont)
 				{
 					mWorldBackground->addChildWindow(cont);
 					cont->setVisible(true);
 					
-					Ogre::Vector3 pos = camera->getPointOnCeGuiScreen((*it)->getPosition());
-					cont->setPosition(UVector2(UDim(pos.x, 0), UDim(pos.y, 0)));
+					Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
+							(*it)->getActor()->_getSceneNode()->_getWorldAABB());
+					UVector2 posCont = UVector2(
+							UDim((aabb.left+aabb.right)/2.0, 0), 
+							UDim((aabb.top+aabb.bottom)/2.0, 0));
+					posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
+					cont->setPosition(posCont);
 
 					cont->subscribeEvent(
 						Window::EventMouseLeaves,
@@ -392,14 +387,17 @@
 					it = v.begin(); it != v.end(); ++it)
 				{
 					ItemDragContainer* cont = 
-						createItemDragContainer(static_cast<Item*>(*it));
+						createItemDragContainer(static_cast<Item*>(*it), true);
 
 					if (cont)
 					{
 						mWorldBackground->addChildWindow(cont);
 						
-						Ogre::Vector3 pos = camera->getPointOnCeGuiScreen((*it)->getPosition());
-						UVector2 posCont = UVector2(UDim(pos.x, 0), UDim(pos.y, 0));
+						Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
+							(*it)->getActor()->_getSceneNode()->_getWorldAABB());
+						UVector2 posCont = UVector2(
+							UDim((aabb.left+aabb.right)/2.0, 0), 
+							UDim((aabb.top+aabb.bottom)/2.0, 0));
 						posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
 						cont->setPosition(posCont);
 
@@ -432,4 +430,28 @@
 
 		return true;
 	}
+
+	Ogre::Rectangle InventoryWindow::getCeGuiRectFromWorldAABB(
+		CameraObject* camera,
+        const AxisAlignedBox& aabb) const
+    {
+        // Initialise each to the value of the opposite side, so that min/max work smoothly.
+        Real left = 1.0f, bottom = 1.0f, right = -1.0f, top = -1.0f;
+
+        // Determine screen pos of all corners and widen the rect if needed
+		const Ogre::Vector3* corners = aabb.getAllCorners();
+        for (size_t i = 0; i < 8; ++i)
+        {
+			Ogre::Vector3 screenSpacePos = camera->getPointOnCeGuiScreen(corners[i]);
+            if (screenSpacePos.z > 0) continue; // Behind camera
+
+            left   = std::min(left,   screenSpacePos.x);
+            right  = std::max(right,  screenSpacePos.x);
+            bottom = std::min(bottom, screenSpacePos.y);
+            top    = std::max(top,    screenSpacePos.y);
+        }
+
+        Ogre::Rectangle rval = {left,top, right, bottom};
+        return rval;
+    }
 }

Added: rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2007-07-03 22:21:46 UTC (rev 3585)
@@ -0,0 +1,48 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "ItemDescriptionDragContainer.h"
+
+#include "AbstractWindow.h"
+#include "Item.h"
+
+namespace rl {
+	ItemDescriptionDragContainer::ItemDescriptionDragContainer(Item* item, const CeGuiString& name)
+		: ItemDragContainer(item, name)
+	{
+		CeGuiString icon = item->getImageName();
+
+		if (icon == "")
+		{
+			icon = ICON_UNKNOWN_ITEM;
+		}
+
+		CeGuiString prefix = name;
+		mContentWindow = AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", prefix);
+
+		mContentWindow->getChild(
+			mContentWindow->getName()+"/Icon")
+			->setProperty("Image", icon);
+		mContentWindow->getChild(
+			mContentWindow->getName()+"/Name")
+			->setText(item->getName());
+		mContentWindow->getChild(
+			mContentWindow->getName()+"/Description")
+			->setText(item->getDescription());
+
+		setSize(mContentWindow->getSize());
+		addChildWindow(mContentWindow);
+	}
+}

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-07-03 22:21:46 UTC (rev 3585)
@@ -15,15 +15,30 @@
  */
 #include "ItemDragContainer.h"
 
+#include <CEGUIWindowManager.h>
+
+#include "AbstractWindow.h"
+#include "Item.h"
+
 namespace rl {
+	const Ogre::String ItemDragContainer::ICON_UNKNOWN_ITEM = "set:ModelThumbnails image:item_unknown";
 
 	ItemDragContainer::ItemDragContainer(Item* item, const CeGuiString& name)
 		: CEGUI::DragContainer("DragContainer", name),
 		mItem(item),
 		mParentContainer(NULL),
-		mParentSlot("")
+		mParentSlot(""),
+		mContentWindow(NULL)
 	{
 	}
+
+	ItemDragContainer::~ItemDragContainer()
+	{
+		removeAllEvents();
+		mContentWindow->removeAllEvents();
+		removeChildWindow(mContentWindow);
+		CEGUI::WindowManager::getSingleton().destroyWindow(mContentWindow);
+	}
 		
 	void ItemDragContainer::setItemParent(Container* container)
 	{
@@ -69,15 +84,4 @@
 	{
 		return mContentWindow;
 	}
-
-	void ItemDragContainer::setContentWindow(CEGUI::Window* window)
-	{
-		if (window)
-		{
-			window->setPosition(CEGUI::UVector2(cegui_reldim(0), cegui_reldim(0)));
-			window->setSize(CEGUI::UVector2(cegui_reldim(1), cegui_reldim(1)));
-			addChildWindow(window);
-		}
-		mContentWindow = window;
-	}
 }

Added: rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-07-03 22:21:46 UTC (rev 3585)
@@ -0,0 +1,47 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "ItemIconDragContainer.h"
+
+#include "AbstractWindow.h"
+#include "Item.h"
+
+namespace rl {
+	ItemIconDragContainer::ItemIconDragContainer(Item* item, const CeGuiString& name)
+		: ItemDragContainer(item, name)
+	{
+		CeGuiString icon = item->getImageName();
+
+		if (icon == "")
+		{
+			icon = ICON_UNKNOWN_ITEM;
+		}
+
+		CeGuiString prefix = name;
+		mContentWindow = AbstractWindow::loadWindow("itemicondragcontainer.xml", prefix);
+		mContentWindow->getChild(mContentWindow->getName()+"/Icon")
+			->setProperty("Image", icon);
+
+		setSize(CEGUI::UVector2(
+			cegui_absdim(item->getSize().first*30),
+			cegui_absdim(item->getSize().second*30))); 
+		mContentWindow->setSize(CEGUI::UVector2(
+			cegui_absdim(item->getSize().first*30),
+			cegui_absdim(item->getSize().second*30))); 
+		setTooltipText(item->getName());
+
+		addChildWindow(mContentWindow);
+	}
+}

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-07-03 19:57:10 UTC (rev 3584)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-07-03 22:21:46 UTC (rev 3585)
@@ -34,6 +34,8 @@
     InputManager.cpp \
     InventoryWindow.cpp \
     ItemDragContainer.cpp \
+    ItemDescriptionDragContainer.cpp \
+    ItemIconDragContainer.cpp \
     JournalWindow.cpp \
     ListboxWrappedTextItem.cpp \
     LogWindow.cpp \



From pnyx at mail.berlios.de  Wed Jul  4 15:21:35 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 15:21:35 +0200
Subject: [Dsa-hl-svn] r3586 - in modules/common: materials materials/model
	materials/programs models
Message-ID: <200707041321.l64DLZpM023622@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 15:18:07 +0200 (Wed, 04 Jul 2007)
New Revision: 3586

Added:
   modules/common/materials/model/rl_mensch_female.png
   modules/common/materials/programs/ATorso_Vertex_Shader.material
   modules/common/materials/programs/Basic_Pixel_Shader.source
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_Shader.program
   modules/common/materials/programs/Basic_Vertex_Shader.source
   modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
   modules/common/materials/programs/Torso_Pixel_Shader.source
   modules/common/materials/programs/Torso_Vertex_Shader.program
   modules/common/materials/programs/Torso_Vertex_Shader.source
Modified:
   modules/common/materials/men_human_female_armor_garethplatte.mesh.material
   modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
   modules/common/materials/men_human_female_feet_boots01.mesh.material
   modules/common/materials/men_human_female_hair_long01_normal.mesh.material
   modules/common/materials/men_human_female_hand_nude.mesh.material
   modules/common/materials/men_human_female_head02.mesh.material
   modules/common/materials/men_human_female_leg_pants01_long.mesh.material
   modules/common/materials/men_human_female_torso.mesh.material
   modules/common/materials/model/men_human_female_hair_long_01.png
   modules/common/materials/model/men_human_female_head02.png
   modules/common/materials/model/obj_kroetenhaut.png
   modules/common/materials/model/obj_pants01.png
   modules/common/models/men_human_female.skeleton
   modules/common/models/men_human_female_armor_kroetenhaut.mesh
   modules/common/models/men_human_female_feet_boots_01.mesh
   modules/common/models/men_human_female_hair_long_01_normal.mesh
   modules/common/models/men_human_female_leg_pants_01_long.mesh
   modules/common/models/men_human_female_torso.mesh
Log:
-Adden Vertex shaders with Hemisphere lightingmodel for Character models.
-Skintexture just temporary

Modified: modules/common/materials/men_human_female_armor_garethplatte.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,17 +1,5 @@
 
-material men_human_female_armor_garethplatte
+material men_human_female_armor_garethplatte : Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture obj_plattediffuse.png
-			}
-		}
-
-	}
-
+set_texture_alias diffuse obj_plattediffuse.png
 }

Modified: modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,17 +1,5 @@
 
-material men_human_female_armor_kroetenhaut
+material men_human_female_armor_kroetenhaut : Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture obj_kroetenhaut.png
-			}
-		}
-
-	}
-
+set_texture_alias diffuse obj_kroetenhaut.png
 }

Modified: modules/common/materials/men_human_female_feet_boots01.mesh.material
===================================================================
--- modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,18 +1,6 @@
 
-material men_human_female_feet_boots_01
+material men_human_female_feet_boots_01 : Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture obj_boots01.png
-				tex_coord_set 1
-			}
-		}
-
-	}
-
+set_texture_alias diffuse obj_boots01.png
+			//	tex_coord_set 1
 }

Modified: modules/common/materials/men_human_female_hair_long01_normal.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,17 +1,5 @@
 
-material men_human_female_hair_long_01_normal
+material men_human_female_hair_long_01_normal : Basic_Vertex_Shader_Alpha
 {
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture men_human_female_hair_long_01.png
-			}
-		}
-
-	}
-
+set_texture_alias diffuse men_human_female_hair_long_01.png
 }

Modified: modules/common/materials/men_human_female_hand_nude.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hand_nude.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_hand_nude.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,17 +1,6 @@
 
-material men_human_female_hand_nude
+material men_human_female_hand_nude : Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
+set_texture_alias diffuse rl_mensch_female.png
 
-			texture_unit
-			{
-				texture men_human_female_hand.png
-			}
-		}
-
-	}
-
 }

Modified: modules/common/materials/men_human_female_head02.mesh.material
===================================================================
--- modules/common/materials/men_human_female_head02.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_head02.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,17 +1,6 @@
 
-material men_human_female_head_02
+material men_human_female_head_02 : Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
+set_texture_alias diffuse men_human_female_head02.png
 
-			texture_unit
-			{
-				texture men_human_female_head02.png
-			}
-		}
-
-	}
-
 }

Modified: modules/common/materials/men_human_female_leg_pants01_long.mesh.material
===================================================================
--- modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,17 +1,6 @@
 
-material men_human_female_legs_pants_01_long
+material men_human_female_legs_pants_01_long : Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
+set_texture_alias diffuse obj_pants01.png
 
-			texture_unit
-			{
-				texture obj_pants01.png
-			}
-		}
-
-	}
-
 }

Modified: modules/common/materials/men_human_female_torso.mesh.material
===================================================================
--- modules/common/materials/men_human_female_torso.mesh.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/men_human_female_torso.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -1,18 +1,5 @@
-
-material men_human_female_torso
+material men_human_female_torso : Torso_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture obj_shortsleeve02_diffuse.png
-				tex_coord_set 1
-			}
-		}
-
-	}
-
+	set_texture_alias skin rl_mensch_female.png
+	set_texture_alias cloth obj_shortsleeve02_diffuse.png
 }

Modified: modules/common/materials/model/men_human_female_hair_long_01.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/model/men_human_female_head02.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/model/obj_kroetenhaut.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/model/obj_pants01.png
===================================================================
(Binary files differ)

Added: modules/common/materials/model/rl_mensch_female.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/rl_mensch_female.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/programs/ATorso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/ATorso_Vertex_Shader.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/ATorso_Vertex_Shader.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,44 @@
+material Torso_Vertex_Shader
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Torso_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Torso_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0				
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias skin
+				//texture nat_felsen_01.dds 2d
+			}
+			
+			texture_unit
+			{
+				texture_alias cloth
+				//texture nat_felsen_01.dds 2d
+			}
+		}
+	}
+}

Added: modules/common/materials/programs/Basic_Pixel_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Pixel_Shader.source	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Basic_Pixel_Shader.source	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,19 @@
+sampler2D baseMap;
+
+struct PS_INPUT 
+{
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+float4 ps_main( PS_INPUT Input ) : COLOR0
+{
+   return tex2D( baseMap, Input.Texcoord )* Input.Color;
+   
+}
+
+
+

Added: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,43 @@
+//Effect: Textured
+material Basic_Vertex_Shader
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
+				
+				param_named_auto Light1_color light_diffuse_colour 0
+				//param_named Light1_color float4 1.0 1.0 1.0 1.0
+				param_named_auto Light1_position light_position_object_space 0
+				//param_named Light1_position float4 1.0 1.0 1.0 1.0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+	}
+}

Added: modules/common/materials/programs/Basic_Vertex_Shader.program
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.program	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Basic_Vertex_Shader.program	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,14 @@
+//DirectX 9.0 HLSL Vertex Shader vs_2_0
+vertex_program Basic_Vertex_Shader hlsl
+{
+	source Basic_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Basic_Pixel_Shader hlsl
+{
+	source Basic_Pixel_Shader.source
+	target ps_2_0
+	entry_point ps_main
+}
\ No newline at end of file

Added: modules/common/materials/programs/Basic_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.source	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Basic_Vertex_Shader.source	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,67 @@
+float4x4 matViewProjection;
+float4 skycolor;
+float4 groundcolor;
+float4 Light1_attenuation;
+float4 Light1_position;
+float4 Light1_color;
+float4 Light1_spec_power;
+float4 vViewPosition;
+
+struct VS_INPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1 : TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float3 Normal   : NORMAL;
+   
+};
+
+struct VS_OUTPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+VS_OUTPUT vs_main( VS_INPUT Input )
+{
+   VS_OUTPUT Output;
+   Output.Color = lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   Output.Position = mul( matViewProjection, Input.Position );
+   
+   
+   
+   // Light1
+   
+   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
+   float Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   float3 EyeVect = normalize(Input.Position - vViewPosition);
+   float3 HalfVect = normalize(LightDir - EyeVect);
+   
+   float SpecAttn = Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   float DistAttn = clamp(1/ (Light1_attenuation.y +
+                              Light1_attenuation.z * Dist +
+                              Light1_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light1_color * DistAttn * AngleAttn) + SpecAttn;
+   
+   Output.Texcoord = Input.Texcoord;
+   Output.Texcoord1 = Input.Texcoord1;
+   Output.Texcoord2 = Input.Texcoord2;
+   
+   return( Output );
+   
+}
+
+
+

Added: modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,95 @@
+//Effect: Textured
+material Basic_Vertex_Shader_Alpha
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		depth_write off
+      		//alpha_rejection greater 50
+      		
+      		cull_hardware anticlockwise 
+      		cull_software anticlockwise 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
+				
+				param_named_auto Light1_color light_diffuse_colour 0
+				//param_named Light1_color float4 1.0 1.0 1.0 1.0
+				param_named_auto Light1_position light_position_object_space 0
+				//param_named Light1_position float4 1.0 1.0 1.0 1.0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+		
+		pass
+		{
+			scene_blend alpha_blend 
+      		// Tiefenpuffer aus
+      		depth_write off
+      		//alpha_rejection greater 50
+      		
+      		cull_hardware clockwise 
+      		cull_software clockwise 
+      		
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
+				
+				param_named_auto Light1_color light_diffuse_colour 0
+				//param_named Light1_color float4 1.0 1.0 1.0 1.0
+				param_named_auto Light1_position light_position_object_space 0
+				//param_named Light1_position float4 1.0 1.0 1.0 1.0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+		
+		
+	}	
+}
\ No newline at end of file

Added: modules/common/materials/programs/Torso_Pixel_Shader.source
===================================================================
--- modules/common/materials/programs/Torso_Pixel_Shader.source	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Torso_Pixel_Shader.source	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,22 @@
+sampler2D baseMap;
+sampler2D clothMap;
+
+struct PS_INPUT 
+{
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+float4 ps_main( PS_INPUT Input ) : COLOR0
+{
+
+   float4 skin = tex2D( baseMap, Input.Texcoord );	
+   float4 cloth = tex2D( clothMap, Input.Texcoord1 );
+   return float4(lerp(skin.rgb,cloth.rgb, cloth.a )* Input.Color.rgb,skin.a+cloth.a);
+}
+
+
+

Added: modules/common/materials/programs/Torso_Vertex_Shader.program
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.program	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Torso_Vertex_Shader.program	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,14 @@
+//DirectX 9.0 HLSL Vertex Shader vs_2_0
+vertex_program Torso_Vertex_Shader hlsl
+{
+	source Torso_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Torso_Pixel_Shader hlsl
+{
+	source Torso_Pixel_Shader.source
+	target ps_2_0
+	entry_point ps_main
+}
\ No newline at end of file

Added: modules/common/materials/programs/Torso_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.source	2007-07-03 22:21:46 UTC (rev 3585)
+++ modules/common/materials/programs/Torso_Vertex_Shader.source	2007-07-04 13:18:07 UTC (rev 3586)
@@ -0,0 +1,67 @@
+float4x4 matViewProjection;
+float4 skycolor;
+float4 groundcolor;
+float4 Light1_attenuation;
+float4 Light1_position;
+float4 Light1_color;
+float4 Light1_spec_power;
+float4 vViewPosition;
+
+struct VS_INPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1 : TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float3 Normal   : NORMAL;
+   
+};
+
+struct VS_OUTPUT 
+{
+   float4 Position : POSITION0;
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+VS_OUTPUT vs_main( VS_INPUT Input )
+{
+   VS_OUTPUT Output;
+   Output.Color = lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
+   Output.Position = mul( matViewProjection, Input.Position );
+   
+   
+   
+   // Light1
+   
+   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
+   float Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   float3 EyeVect = normalize(Input.Position - vViewPosition);
+   float3 HalfVect = normalize(LightDir - EyeVect);
+   
+   float SpecAttn = Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   float DistAttn = clamp(1/ (Light1_attenuation.y +
+                              Light1_attenuation.z * Dist +
+                              Light1_attenuation.w * Dist * Dist)
+                          ,0,1);
+   
+   Output.Color += (Light1_color * DistAttn * AngleAttn) + SpecAttn;
+   
+   Output.Texcoord = Input.Texcoord;
+   Output.Texcoord1 = Input.Texcoord1;
+   Output.Texcoord2 = Input.Texcoord2;
+   
+   return( Output );
+   
+}
+
+
+

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_armor_kroetenhaut.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_feet_boots_01.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_hair_long_01_normal.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_leg_pants_01_long.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Wed Jul  4 16:01:54 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 16:01:54 +0200
Subject: [Dsa-hl-svn] r3587 - in modules/common: materials
	materials/programs models
Message-ID: <200707041401.l64E1ss6026452@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 16:01:48 +0200 (Wed, 04 Jul 2007)
New Revision: 3587

Added:
   modules/common/materials/programs/Basic_Pixel_ShaderUV1.source
   modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
Modified:
   modules/common/materials/men_human_female_feet_boots01.mesh.material
   modules/common/models/men_human_female_leg_pants_01_long.mesh
Log:
Added shader for Texcoord 1
Fixed rigging problem

Modified: modules/common/materials/men_human_female_feet_boots01.mesh.material
===================================================================
--- modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-07-04 13:18:07 UTC (rev 3586)
+++ modules/common/materials/men_human_female_feet_boots01.mesh.material	2007-07-04 14:01:48 UTC (rev 3587)
@@ -1,5 +1,5 @@
 
-material men_human_female_feet_boots_01 : Basic_Vertex_Shader
+material men_human_female_feet_boots_01 : Basic_Vertex_ShaderUV1
 {
 set_texture_alias diffuse obj_boots01.png
 			//	tex_coord_set 1

Added: modules/common/materials/programs/Basic_Pixel_ShaderUV1.source
===================================================================
--- modules/common/materials/programs/Basic_Pixel_ShaderUV1.source	2007-07-04 13:18:07 UTC (rev 3586)
+++ modules/common/materials/programs/Basic_Pixel_ShaderUV1.source	2007-07-04 14:01:48 UTC (rev 3587)
@@ -0,0 +1,19 @@
+sampler2D baseMap;
+
+struct PS_INPUT 
+{
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+float4 ps_main( PS_INPUT Input ) : COLOR0
+{
+   return tex2D( baseMap, Input.Texcoord1 )* Input.Color;
+   
+}
+
+
+

Added: modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-07-04 13:18:07 UTC (rev 3586)
+++ modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-07-04 14:01:48 UTC (rev 3587)
@@ -0,0 +1,51 @@
+//Effect: Textured
+fragment_program Basic_Pixel_ShaderUV1 hlsl
+{
+	source Basic_Pixel_ShaderUV1.source
+	target ps_2_0
+	entry_point ps_main
+}
+
+
+material Basic_Vertex_ShaderUV1
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_ShaderUV1
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
+				
+				param_named_auto Light1_color light_diffuse_colour 0
+				//param_named Light1_color float4 1.0 1.0 1.0 1.0
+				param_named_auto Light1_position light_position_object_space 0
+				//param_named Light1_position float4 1.0 1.0 1.0 1.0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+	}
+}

Modified: modules/common/models/men_human_female_leg_pants_01_long.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Wed Jul  4 16:35:01 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 16:35:01 +0200
Subject: [Dsa-hl-svn] r3588 - modules/common/materials/programs
Message-ID: <200707041435.l64EZ16S029223@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 16:34:55 +0200 (Wed, 04 Jul 2007)
New Revision: 3588

Added:
   modules/common/materials/programs/Torso_Vertex_Shader.material
Removed:
   modules/common/materials/programs/ATorso_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_Shader.program
   modules/common/materials/programs/Torso_Vertex_Shader.program
   modules/common/materials/programs/Torso_Vertex_Shader.source
Modified:
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_Shader.source
   modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
Log:
Deleted unneeded files
Added one lightsource to shader

Deleted: modules/common/materials/programs/ATorso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/ATorso_Vertex_Shader.material	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/ATorso_Vertex_Shader.material	2007-07-04 14:34:55 UTC (rev 3588)
@@ -1,44 +0,0 @@
-material Torso_Vertex_Shader
-{
-	technique
-	{
-		//Rendering Pass: Pass 0 (pass index: #0 )
-		pass
-		{
-			alpha_rejection greater 128
-			//DirectX 9.0 HLSL Pixel Shader ps_2_0
-			fragment_program_ref Torso_Pixel_Shader
-			{
-			}
-			//DirectX 9.0 HLSL Vertex Shader vs_2_0
-			vertex_program_ref Torso_Vertex_Shader
-			{
-				// param_named_auto
-
-				param_named_auto Light1_attenuation light_attenuation 0				
-				param_named_auto Light1_color light_diffuse_colour 0
-				param_named_auto Light1_position light_position_object_space 0
-				param_named Light1_spec_power float 0.3
-				
-				param_named_auto matViewProjection worldviewproj_matrix
-				param_named_auto vViewPosition camera_position_object_space
-				
-				
-				param_named skycolor float4 0.5 0.5 0.5 1.0
-				param_named groundcolor float4 0.10 0.10 0.10 1.0
-			}
-
-			texture_unit
-			{
-				texture_alias skin
-				//texture nat_felsen_01.dds 2d
-			}
-			
-			texture_unit
-			{
-				texture_alias cloth
-				//texture nat_felsen_01.dds 2d
-			}
-		}
-	}
-}

Modified: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-04 14:34:55 UTC (rev 3588)
@@ -1,4 +1,20 @@
 //Effect: Textured
+
+//DirectX 9.0 HLSL Vertex Shader vs_2_0
+vertex_program Basic_Vertex_Shader hlsl
+{
+	source Basic_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Basic_Pixel_Shader hlsl
+{
+	source Basic_Pixel_Shader.source
+	target ps_2_0
+	entry_point ps_main
+}
+
 material Basic_Vertex_Shader
 {
 	technique
@@ -17,14 +33,16 @@
 				// param_named_auto
 
 				param_named_auto Light1_attenuation light_attenuation 0
-				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
-				
 				param_named_auto Light1_color light_diffuse_colour 0
-				//param_named Light1_color float4 1.0 1.0 1.0 1.0
 				param_named_auto Light1_position light_position_object_space 0
-				//param_named Light1_position float4 1.0 1.0 1.0 1.0
 				param_named Light1_spec_power float 0.3
 				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				

Deleted: modules/common/materials/programs/Basic_Vertex_Shader.program
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.program	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/Basic_Vertex_Shader.program	2007-07-04 14:34:55 UTC (rev 3588)
@@ -1,14 +0,0 @@
-//DirectX 9.0 HLSL Vertex Shader vs_2_0
-vertex_program Basic_Vertex_Shader hlsl
-{
-	source Basic_Vertex_Shader.source
-	target vs_2_0
-	entry_point vs_main
-}
-//DirectX 9.0 HLSL Pixel Shader ps_2_0
-fragment_program Basic_Pixel_Shader hlsl
-{
-	source Basic_Pixel_Shader.source
-	target ps_2_0
-	entry_point ps_main
-}
\ No newline at end of file

Modified: modules/common/materials/programs/Basic_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.source	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/Basic_Vertex_Shader.source	2007-07-04 14:34:55 UTC (rev 3588)
@@ -5,6 +5,11 @@
 float4 Light1_position;
 float4 Light1_color;
 float4 Light1_spec_power;
+
+float4 Light2_attenuation;
+float4 Light2_position;
+float4 Light2_color;
+float4 Light2_spec_power;
 float4 vViewPosition;
 
 struct VS_INPUT 
@@ -55,6 +60,26 @@
    
    Output.Color += (Light1_color * DistAttn * AngleAttn) + SpecAttn;
    
+   
+   // Light2
+   
+   LightDir = Light2_position - Input.Position * Light2_position.w;
+   Dist = length(LightDir);
+   LightDir = LightDir / Dist;
+   
+   AngleAttn = saturate( dot(Input.Normal ,LightDir));
+   
+   HalfVect = normalize(LightDir - EyeVect);
+   
+   SpecAttn = Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   
+   DistAttn = clamp(1/ (Light2_attenuation.y +
+                        Light2_attenuation.z * Dist +
+                        Light2_attenuation.w * Dist * Dist)
+                        ,0,1);
+   
+   Output.Color += (Light2_color * DistAttn * AngleAttn) + SpecAttn;
+   
    Output.Texcoord = Input.Texcoord;
    Output.Texcoord1 = Input.Texcoord1;
    Output.Texcoord2 = Input.Texcoord2;

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-04 14:34:55 UTC (rev 3588)
@@ -24,14 +24,16 @@
 				// param_named_auto
 
 				param_named_auto Light1_attenuation light_attenuation 0
-				//param_named Light1_attenuation float4 0.4 0.002 0.00001 1.0
-				
 				param_named_auto Light1_color light_diffuse_colour 0
-				//param_named Light1_color float4 1.0 1.0 1.0 1.0
 				param_named_auto Light1_position light_position_object_space 0
-				//param_named Light1_position float4 1.0 1.0 1.0 1.0
 				param_named Light1_spec_power float 0.3
 				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				
 				param_named_auto matViewProjection worldviewproj_matrix
 				param_named_auto vViewPosition camera_position_object_space
 				

Added: modules/common/materials/programs/Torso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.material	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/Torso_Vertex_Shader.material	2007-07-04 14:34:55 UTC (rev 3588)
@@ -0,0 +1,58 @@
+
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Torso_Pixel_Shader hlsl
+{
+	source Torso_Pixel_Shader.source
+	target ps_2_0
+	entry_point ps_main
+}
+
+material Torso_Vertex_Shader
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Torso_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0				
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias skin
+				//texture nat_felsen_01.dds 2d
+			}
+			
+			texture_unit
+			{
+				texture_alias cloth
+				//texture nat_felsen_01.dds 2d
+			}
+		}
+	}
+}

Deleted: modules/common/materials/programs/Torso_Vertex_Shader.program
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.program	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/Torso_Vertex_Shader.program	2007-07-04 14:34:55 UTC (rev 3588)
@@ -1,14 +0,0 @@
-//DirectX 9.0 HLSL Vertex Shader vs_2_0
-vertex_program Torso_Vertex_Shader hlsl
-{
-	source Torso_Vertex_Shader.source
-	target vs_2_0
-	entry_point vs_main
-}
-//DirectX 9.0 HLSL Pixel Shader ps_2_0
-fragment_program Torso_Pixel_Shader hlsl
-{
-	source Torso_Pixel_Shader.source
-	target ps_2_0
-	entry_point ps_main
-}
\ No newline at end of file

Deleted: modules/common/materials/programs/Torso_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.source	2007-07-04 14:01:48 UTC (rev 3587)
+++ modules/common/materials/programs/Torso_Vertex_Shader.source	2007-07-04 14:34:55 UTC (rev 3588)
@@ -1,67 +0,0 @@
-float4x4 matViewProjection;
-float4 skycolor;
-float4 groundcolor;
-float4 Light1_attenuation;
-float4 Light1_position;
-float4 Light1_color;
-float4 Light1_spec_power;
-float4 vViewPosition;
-
-struct VS_INPUT 
-{
-   float4 Position : POSITION0;
-   float2 Texcoord : TEXCOORD0;
-   float2 Texcoord1 : TEXCOORD1;
-   float2 Texcoord2: TEXCOORD2;
-   float3 Normal   : NORMAL;
-   
-};
-
-struct VS_OUTPUT 
-{
-   float4 Position : POSITION0;
-   float2 Texcoord : TEXCOORD0;
-   float2 Texcoord1: TEXCOORD1;
-   float2 Texcoord2: TEXCOORD2;
-   float4 Color    : TEXCOORD3;
-   
-};
-
-VS_OUTPUT vs_main( VS_INPUT Input )
-{
-   VS_OUTPUT Output;
-   Output.Color = lerp(skycolor,groundcolor,(dot(Input.Normal, float3(0,-1,0))+1)/2 );
-   Output.Position = mul( matViewProjection, Input.Position );
-   
-   
-   
-   // Light1
-   
-   float3 LightDir = Light1_position - Input.Position * Light1_position.w;
-   float Dist = length(LightDir);
-   LightDir = LightDir / Dist;
-   
-   float AngleAttn = saturate( dot(Input.Normal ,LightDir));
-   
-   float3 EyeVect = normalize(Input.Position - vViewPosition);
-   float3 HalfVect = normalize(LightDir - EyeVect);
-   
-   float SpecAttn = Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
-   
-   float DistAttn = clamp(1/ (Light1_attenuation.y +
-                              Light1_attenuation.z * Dist +
-                              Light1_attenuation.w * Dist * Dist)
-                          ,0,1);
-   
-   Output.Color += (Light1_color * DistAttn * AngleAttn) + SpecAttn;
-   
-   Output.Texcoord = Input.Texcoord;
-   Output.Texcoord1 = Input.Texcoord1;
-   Output.Texcoord2 = Input.Texcoord2;
-   
-   return( Output );
-   
-}
-
-
-



From pnyx at mail.berlios.de  Wed Jul  4 18:44:06 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 18:44:06 +0200
Subject: [Dsa-hl-svn] r3589 - modules/common/materials/programs
Message-ID: <200707041644.l64Gi6QR029081@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 18:43:59 +0200 (Wed, 04 Jul 2007)
New Revision: 3589

Modified:
   modules/common/materials/programs/Basic_Vertex_Shader.source
Log:
Specular lighting must depend on light intensity

Modified: modules/common/materials/programs/Basic_Vertex_Shader.source
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.source	2007-07-04 14:34:55 UTC (rev 3588)
+++ modules/common/materials/programs/Basic_Vertex_Shader.source	2007-07-04 16:43:59 UTC (rev 3589)
@@ -51,7 +51,7 @@
    float3 EyeVect = normalize(Input.Position - vViewPosition);
    float3 HalfVect = normalize(LightDir - EyeVect);
    
-   float SpecAttn = Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   float SpecAttn = Light1_color * Light1_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
    
    float DistAttn = clamp(1/ (Light1_attenuation.y +
                               Light1_attenuation.z * Dist +
@@ -71,7 +71,7 @@
    
    HalfVect = normalize(LightDir - EyeVect);
    
-   SpecAttn = Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
+   SpecAttn = Light2_color *Light2_spec_power * pow(clamp(dot(Input.Normal,HalfVect),0,1),32);
    
    DistAttn = clamp(1/ (Light2_attenuation.y +
                         Light2_attenuation.z * Dist +



From pnyx at mail.berlios.de  Wed Jul  4 19:38:17 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 19:38:17 +0200
Subject: [Dsa-hl-svn] r3590 - modules/common/materials/model
Message-ID: <200707041738.l64HcH0g024247@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 19:34:45 +0200 (Wed, 04 Jul 2007)
New Revision: 3590

Modified:
   modules/common/materials/model/men_human_female_head02.png
   modules/common/materials/model/obj_plattediffuse.png
   modules/common/materials/model/rl_mensch_female.png
Log:
Adjusted Skin Color
Added FakeNormalmap to obj_plattediffuse.png

Modified: modules/common/materials/model/men_human_female_head02.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/model/obj_plattediffuse.png
===================================================================
(Binary files differ)

Modified: modules/common/materials/model/rl_mensch_female.png
===================================================================
(Binary files differ)



From blakharaz at mail.berlios.de  Wed Jul  4 20:21:42 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 4 Jul 2007 20:21:42 +0200
Subject: [Dsa-hl-svn] r3591 - in modules: common/models regressiontest/dsa
	regressiontest/scripts
Message-ID: <200707041821.l64ILgue026855@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-04 20:21:29 +0200 (Wed, 04 Jul 2007)
New Revision: 3591

Modified:
   modules/common/models/men_human_female_backpack_leather_01.mesh
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/mckhero.rb
Log:
use construction kit backpack instead of attached model

Modified: modules/common/models/men_human_female_backpack_leather_01.mesh
===================================================================
(Binary files differ)

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-07-04 17:34:45 UTC (rev 3590)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-07-04 18:21:29 UTC (rev 3591)
@@ -91,7 +91,7 @@
     <gameobjectclass classid="leather backpack" baseclass="Container">
         <property name="name" type="STRING" data="Rucksack"/>
         <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>
-        <property name="meshfile" type="STRING" data="ins_rucksack.mesh"/>
+        <property name="meshfile" type="STRING" data="men_human_female_backpack_leather_01.mesh"/>
         <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
         <property name="capacity" type="REAL" data="20.0"/>
         <property name="volume" type="INTPAIR" data="8,6"/>

Modified: modules/regressiontest/scripts/mckhero.rb
===================================================================
--- modules/regressiontest/scripts/mckhero.rb	2007-07-04 17:34:45 UTC (rev 3590)
+++ modules/regressiontest/scripts/mckhero.rb	2007-07-04 18:21:29 UTC (rev 3591)
@@ -36,8 +36,8 @@
 	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_ALL_ITEMS);
 	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
 	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, false);
-	#inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, false);
-	inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
+	inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, false);
+	#inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
     inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, false);
 
 	#addSounds()



From pnyx at mail.berlios.de  Wed Jul  4 20:24:36 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 20:24:36 +0200
Subject: [Dsa-hl-svn] r3592 - modules/common/models
Message-ID: <200707041824.l64IOaUZ027053@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 20:24:32 +0200 (Wed, 04 Jul 2007)
New Revision: 3592

Modified:
   modules/common/models/men_human_female_backpack_leather_01.mesh
Log:
leather backpack updated

Modified: modules/common/models/men_human_female_backpack_leather_01.mesh
===================================================================
(Binary files differ)



From blakharaz at mail.berlios.de  Wed Jul  4 20:25:36 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 4 Jul 2007 20:25:36 +0200
Subject: [Dsa-hl-svn] r3593 - in modules/common/materials: . model
Message-ID: <200707041825.l64IPaKI027221@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-04 20:24:58 +0200 (Wed, 04 Jul 2007)
New Revision: 3593

Added:
   modules/common/materials/men_human_female_backpack_leather_01.material
   modules/common/materials/model/men_human_female_backpack_leather_01_diffuse.png
Log:
..and now the missing texture :)

Added: modules/common/materials/men_human_female_backpack_leather_01.material
===================================================================
--- modules/common/materials/men_human_female_backpack_leather_01.material	2007-07-04 18:24:32 UTC (rev 3592)
+++ modules/common/materials/men_human_female_backpack_leather_01.material	2007-07-04 18:24:58 UTC (rev 3593)
@@ -0,0 +1,17 @@
+
+material men_human_female_backpack_leather_01
+{
+	technique
+	{
+		pass
+		{
+			texture_unit
+			{
+
+				texture men_human_female_backpack_leather_01_diffuse.png
+			}
+		}
+
+	}
+
+}

Added: modules/common/materials/model/men_human_female_backpack_leather_01_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/men_human_female_backpack_leather_01_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From pnyx at mail.berlios.de  Wed Jul  4 20:34:55 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 20:34:55 +0200
Subject: [Dsa-hl-svn] r3594 - modules/common/materials
Message-ID: <200707041834.l64IYtpv028023@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 20:34:53 +0200 (Wed, 04 Jul 2007)
New Revision: 3594

Modified:
   modules/common/materials/men_human_female_backpack_leather_01.material
Log:
backpack is using shader now

Modified: modules/common/materials/men_human_female_backpack_leather_01.material
===================================================================
--- modules/common/materials/men_human_female_backpack_leather_01.material	2007-07-04 18:24:58 UTC (rev 3593)
+++ modules/common/materials/men_human_female_backpack_leather_01.material	2007-07-04 18:34:53 UTC (rev 3594)
@@ -1,17 +1,5 @@
 
-material men_human_female_backpack_leather_01
+material men_human_female_backpack_leather_01: Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
-			texture_unit
-			{
-
-				texture men_human_female_backpack_leather_01_diffuse.png
-			}
-		}
-
-	}
-
+set_texture_alias diffuse men_human_female_backpack_leather_01_diffuse.png
 }



From pnyx at mail.berlios.de  Wed Jul  4 23:31:10 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Wed, 4 Jul 2007 23:31:10 +0200
Subject: [Dsa-hl-svn] r3595 - modules/common/models
Message-ID: <200707042131.l64LVAiV010447@sheep.berlios.de>

Author: pnyx
Date: 2007-07-04 23:31:08 +0200 (Wed, 04 Jul 2007)
New Revision: 3595

Modified:
   modules/common/models/men_human_female_backpack_leather_01.mesh
Log:
Fixed weights

Modified: modules/common/models/men_human_female_backpack_leather_01.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Thu Jul  5 14:08:37 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 5 Jul 2007 14:08:37 +0200
Subject: [Dsa-hl-svn] r3596 - in modules/common: materials/model models
Message-ID: <200707051208.l65C8brr010840@sheep.berlios.de>

Author: pnyx
Date: 2007-07-05 14:07:37 +0200 (Thu, 05 Jul 2007)
New Revision: 3596

Modified:
   modules/common/materials/model/obj_shortsleeve02_diffuse.png
   modules/common/models/men_human_female_head_02.mesh
   modules/common/models/men_human_female_torso.mesh
Log:
-fixed Seam and Weights in the neck area
-fixed Alpha issue in shortsleeve02

Modified: modules/common/materials/model/obj_shortsleeve02_diffuse.png
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_head_02.mesh
===================================================================
(Binary files differ)

Modified: modules/common/models/men_human_female_torso.mesh
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Thu Jul  5 15:21:09 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 5 Jul 2007 15:21:09 +0200
Subject: [Dsa-hl-svn] r3597 - modules/common/models
Message-ID: <200707051321.l65DL9i6016498@sheep.berlios.de>

Author: pnyx
Date: 2007-07-05 15:21:06 +0200 (Thu, 05 Jul 2007)
New Revision: 3597

Modified:
   modules/common/models/men_human_female.skeleton
Log:
fixed hand slot positions in idle animation

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)



From tanis at mail.berlios.de  Thu Jul 12 20:58:35 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Thu, 12 Jul 2007 20:58:35 +0200
Subject: [Dsa-hl-svn] r3598 - rl/trunk/engine/rules
Message-ID: <200707121858.l6CIwZSC003586@sheep.berlios.de>

Author: tanis
Date: 2007-07-12 20:58:30 +0200 (Thu, 12 Jul 2007)
New Revision: 3598

Removed:
   rl/trunk/engine/rules/basis.xdi
   rl/trunk/engine/rules/data/
Log:
Remove unused folder/file.

Deleted: rl/trunk/engine/rules/basis.xdi
===================================================================
--- rl/trunk/engine/rules/basis.xdi	2007-07-05 13:21:06 UTC (rev 3597)
+++ rl/trunk/engine/rules/basis.xdi	2007-07-12 18:58:30 UTC (rev 3598)
@@ -1,1550 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
-<XDIML lang="de" version="1.01">
-  <Inhalt>
-    <Personen>
-    </Personen>
-    <Rassen>
-    </Rassen>
-    <Kulturen>
-    </Kulturen>
-    <Professionen>
-    </Professionen>
-    <Talente>
-      <Talentgruppe ID="K?rperliche Talente">
-        <Talent ID="Akrobatik">
-          <Probe>MU/GE/KK</Probe>
-          <Art>Spezial</Art>
-          <eBE>BEx2</eBE>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="K?rperbeherrschung">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Balancieren</Spezialisierung>
-            <Spezialisierung>Bodenakrobatik</Spezialisierung>
-            <Spezialisierung>Schwingen</Spezialisierung>
-            <Spezialisierung>Spr?nge</Spezialisierung>
-            <Spezialisierung>Winden</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 20</Beschreibung>
-        </Talent>
-        <Talent ID="Athletik">
-          <Probe>GE/KO/KK</Probe>
-          <Art>Spezial</Art>
-          <eBE>BEx2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Hochsprung</Spezialisierung>
-            <Spezialisierung>Kraftakte</Spezialisierung>
-            <Spezialisierung>Langlauf</Spezialisierung>
-            <Spezialisierung>Sprint</Spezialisierung>
-            <Spezialisierung>Weitsprung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 20</Beschreibung>
-        </Talent>
-        <Talent ID="Fliegen">
-          <Probe>MU/IN/GE</Probe>
-          <Art>Spezial</Art>
-          <eBE>BE</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Hexenbesen</Spezialisierung>
-            <Spezialisierung>Fliegender Teppich</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 20</Beschreibung>
-        </Talent>
-        <Talent ID="Gaukeleien">
-          <Probe>MU/CH/FF</Probe>
-          <Art>Spezial</Art>
-          <eBE>BEx2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Bauchreden</Spezialisierung>
-            <Spezialisierung>Feuerkunst</Spezialisierung>
-            <Spezialisierung>Jonglieren</Spezialisierung>
-            <Spezialisierung>Possenrei?en</Spezialisierung>
-            <Spezialisierung>Taschenspielereien</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 20</Beschreibung>
-        </Talent>
-        <Talent ID="Klettern">
-          <Probe>MU/GE/KK</Probe>
-          <Art>Basis</Art>
-          <eBE>BEx2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Bergsteigen</Spezialisierung>
-            <Spezialisierung>Eisklettern</Spezialisierung>
-            <Spezialisierung>Freiklettern</Spezialisierung>
-            <Spezialisierung>Seilklettern</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 20</Beschreibung>
-        </Talent>
-        <Talent ID="K?rperbeherrschung">
-          <Probe>MU/IN/GE</Probe>
-          <Art>Basis</Art>
-          <eBE>BEx2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Fallen</Spezialisierung>
-            <Spezialisierung>Spr?nge</Spezialisierung>
-            <Spezialisierung>Standfestigkeit</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 21</Beschreibung>
-        </Talent>
-        <Talent ID="Reiten">
-          <Probe>CH/GE/KK</Probe>
-          <Art>Spezial</Art>
-          <eBE>BE-2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Pferd/Esel/Muli</Spezialisierung>
-            <Spezialisierung>Kamel</Spezialisierung>
-            <Spezialisierung>Strau?</Spezialisierung>
-            <Spezialisierung>Reitechse</Spezialisierung>
-            <Spezialisierung>Flugechse</Spezialisierung>
-            <Spezialisierung>Hippogriff</Spezialisierung>
-            <Spezialisierung>goblinisches Reit-Wildschwein</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 21</Beschreibung>
-        </Talent>
-        <Talent ID="Schleichen">
-          <Probe>MU/IN/GE</Probe>
-          <Art>Basis</Art>
-          <eBE>BE</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Eis und Schnee</Spezialisierung>
-            <Spezialisierung>Geb?ude</Spezialisierung>
-            <Spezialisierung>Ger?ll</Spezialisierung>
-            <Spezialisierung>Stra?en</Spezialisierung>
-            <Spezialisierung>Wald und Dschungel</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 21</Beschreibung>
-        </Talent>
-        <Talent ID="Schwimmen">
-          <Probe>GE/KO/KK</Probe>
-          <Art>Basis</Art>
-          <eBE>BEx2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Langstreckenschwimmen</Spezialisierung>
-            <Spezialisierung>Schnellschwimmen</Spezialisierung>
-            <Spezialisierung>Tauchen</Spezialisierung>
-            <Spezialisierung>Unterwasserkampf</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 21</Beschreibung>
-        </Talent>
-        <Talent ID="Selbstbeherrschung">
-          <Probe>MU/KO/KK</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Ersch?pfungen Ignorieren</Spezialisierung>
-            <Spezialisierung>Schmerz Unterdr?cken</Spezialisierung>
-            <Spezialisierung>St?rungen Ignorieren</Spezialisierung>
-            <Spezialisierung>Wunden Ignorieren</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 21</Beschreibung>
-        </Talent>
-        <Talent ID="Sich Verstecken">
-          <Probe>MU/IN/GE</Probe>
-          <Art>Basis</Art>
-          <eBE>BE-2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Geb?ude</Spezialisierung>
-            <Spezialisierung>Gebirge</Spezialisierung>
-            <Spezialisierung>Grasland</Spezialisierung>
-            <Spezialisierung>Eis und Schnee</Spezialisierung>
-            <Spezialisierung>Stadt</Spezialisierung>
-            <Spezialisierung>Wald und Dschungel</Spezialisierung>
-            <Spezialisierung>W?ste</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-        <Talent ID="Singen">
-          <Probe>IN/CH/CH</Probe>
-          <Art>Basis</Art>
-          <eBE>BE-3</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Balladenvortrag</Spezialisierung>
-            <Spezialisierung>Chorgesang</Spezialisierung>
-            <Spezialisierung>Mehrstimmigkeit</Spezialisierung>
-            <Spezialisierung>Operngesang</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-        <Talent ID="Sinnensch?rfe">
-          <Probe>KL/IN/IN</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>H?ren</Spezialisierung>
-            <Spezialisierung>Riechen und Schmecken</Spezialisierung>
-            <Spezialisierung>Sehen</Spezialisierung>
-            <Spezialisierung>Tasten</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-        <Talent ID="Skifahren">
-          <Probe>GE/GE/KO</Probe>
-          <Art>Spezial</Art>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-        <Talent ID="Stimmen Imitieren">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Spezial</Art>
-          <eBE>BE-4</eBE>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Sinnensch?rfe">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Haustiere</Spezialisierung>
-            <Spezialisierung>Jagdwild</Spezialisierung>
-            <Spezialisierung>Menschliche Stimmen</Spezialisierung>
-            <Spezialisierung>Raubtiere</Spezialisierung>
-            <Spezialisierung>V?gel</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-        <Talent ID="Tanzen">
-          <Probe>CH/GE/GE</Probe>
-          <Art>Basis</Art>
-          <eBE>BEx2</eBE>
-          <Spezialisierungen>
-            <Spezialisierung>Ausdruckst?nze</Spezialisierung>
-            <Spezialisierung>Formationst?nze</Spezialisierung>
-            <Spezialisierung>Meditationst?nze</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-        <Talent ID="Taschendiebstahl">
-          <Probe>MU/IN/FF</Probe>
-          <Art>Spezial</Art>
-          <eBE>BEx2</eBE>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Menschenkenntnis">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-        <Talent ID="Zechen">
-          <Probe>IN/KO/KK</Probe>
-          <Art>Basis</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 22</Beschreibung>
-        </Talent>
-      </Talentgruppe>
-      <Talentgruppe ID="Gesellschaftliche Talente">
-        <Talent ID="Bet?ren">
-          <Probe>IN/CH/CH</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Menschenkenntnis">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 23</Beschreibung>
-        </Talent>
-        <Talent ID="Etikette">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 23</Beschreibung>
-        </Talent>
-        <Talent ID="Galanterie">
-          <Probe>IN/CH/FF</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Festgestaltung</Spezialisierung>
-            <Spezialisierung>Garderobe und Schminke</Spezialisierung>
-            <Spezialisierung>Liebesk?nste</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 23</Beschreibung>
-        </Talent>
-        <Talent ID="Gassenwissen">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Beschatten</Spezialisierung>
-            <Spezialisierung>Hehlerei</Spezialisierung>
-            <Spezialisierung>Kontakte</Spezialisierung>
-            <Spezialisierung>Ortseinsch?tzung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 23</Beschreibung>
-        </Talent>
-        <Talent ID="Lehren">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Menschenkenntnis">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Kampftalente</Spezialisierung>
-            <Spezialisierung>K?rperliche Talente</Spezialisierung>
-            <Spezialisierung>Gesellschaftliche Talente</Spezialisierung>
-            <Spezialisierung>Natur-Talente</Spezialisierung>
-            <Spezialisierung>Wissenstalente</Spezialisierung>
-            <Spezialisierung>Handwerkstalente</Spezialisierung>
-            <Spezialisierung>Sprachen und Schriften</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 23</Beschreibung>
-        </Talent>
-        <Talent ID="Menschenkenntnis">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Basis</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 23/24</Beschreibung>
-        </Talent>
-        <Talent ID="Schauspielerei">
-          <Probe>MU/KL/CH</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Etikette">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Sich Verkleiden">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Singen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="?berreden">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="?berzeugen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Kom?die</Spezialisierung>
-            <Spezialisierung>Possen</Spezialisierung>
-            <Spezialisierung>Trag?die</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 24</Beschreibung>
-        </Talent>
-        <Talent ID="Schriftlicher Ausdruck">
-          <Probe>KL/IN/IN</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Schreiber</Spezialisierung>
-            <Spezialisierung>Schriftsteller</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 24</Beschreibung>
-        </Talent>
-        <Talent ID="Sich Verkleiden">
-          <Probe>MU/CH/GE</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>anderer Stand</Spezialisierung>
-            <Spezialisierung>anderes Geschlecht</Spezialisierung>
-            <Spezialisierung>andere Rolle</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 24</Beschreibung>
-        </Talent>
-        <Talent ID="?berreden">
-          <Probe>MU/IN/CH</Probe>
-          <Art>Basis</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Menschenkenntnis">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Aufwiegeln</Spezialisierung>
-            <Spezialisierung>Betteln</Spezialisierung>
-            <Spezialisierung>Einsch?chtern</Spezialisierung>
-            <Spezialisierung>Feilschen</Spezialisierung>
-            <Spezialisierung>L?gen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 24/25</Beschreibung>
-        </Talent>
-        <Talent ID="?berzeugen">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Menschenkenntnis">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Demagogie, Pl?doyer oder Predigt</Spezialisierung>
-            <Spezialisierung>Einzelgespr?ch und Verh?r</Spezialisierung>
-            <Spezialisierung>Diskussions-Rhetorik</Spezialisierung>
-            <Spezialisierung>schriftliche Rhetorik</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 25</Beschreibung>
-        </Talent>
-      </Talentgruppe>
-      <Talentgruppe ID="Natur-Talente">
-        <Talent ID="Fallenstellen">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Wildnisleben">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Gruben</Spezialisierung>
-            <Spezialisierung>Schlingen</Spezialisierung>
-            <Spezialisierung>Speere</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 25/26</Beschreibung>
-        </Talent>
-        <Talent ID="Fesseln / Entfesseln">
-          <Probe>FF/GE/KK</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Entfesseln</Spezialisierung>
-            <Spezialisierung>Fesseln</Spezialisierung>
-            <Spezialisierung>Knotenkunde</Spezialisierung>
-            <Spezialisierung>Taue Splei?en</Spezialisierung>
-            <Spezialisierung>Netze Kn?pfen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 26</Beschreibung>
-        </Talent>
-        <Talent ID="Fischen / Angeln">
-          <Probe>IN/FF/KK</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Fl?sse und B?che</Spezialisierung>
-            <Spezialisierung>Hochseeangeln</Spezialisierung>
-            <Spezialisierung>Seen, Sumpf oder Brackwasser</Spezialisierung>
-            <Spezialisierung>Strand und Riff</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 26</Beschreibung>
-        </Talent>
-        <Talent ID="F?hrtensuchen">
-          <Probe>KL/IN/KO</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Eis und Schnee</Spezialisierung>
-            <Spezialisierung>Gebirge</Spezialisierung>
-            <Spezialisierung>Grasland</Spezialisierung>
-            <Spezialisierung>Stadt</Spezialisierung>
-            <Spezialisierung>Sumpf</Spezialisierung>
-            <Spezialisierung>Unterirdisch</Spezialisierung>
-            <Spezialisierung>Wald und Dschungel</Spezialisierung>
-            <Spezialisierung>W?ste</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 25</Beschreibung>
-        </Talent>
-        <Talent ID="Orientierung">
-          <Probe>KL/IN/IN</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Dschungel</Spezialisierung>
-            <Spezialisierung>Eis und Schnee</Spezialisierung>
-            <Spezialisierung>Gebirge</Spezialisierung>
-            <Spezialisierung>Grasland</Spezialisierung>
-            <Spezialisierung>Meer</Spezialisierung>
-            <Spezialisierung>Stadt</Spezialisierung>
-            <Spezialisierung>Unterirdisch</Spezialisierung>
-            <Spezialisierung>Wald</Spezialisierung>
-            <Spezialisierung>W?ste</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 26</Beschreibung>
-        </Talent>
-        <Talent ID="Seefischerei">
-          <Probe>IN/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 26</Beschreibung>
-        </Talent>
-        <Talent ID="Wettervorhersage">
-          <Probe>KL/IN/IN</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 26</Beschreibung>
-        </Talent>
-        <Talent ID="Wildnisleben">
-          <Probe>IN/GE/KO</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Dschungel</Spezialisierung>
-            <Spezialisierung>Eis und Schnee</Spezialisierung>
-            <Spezialisierung>Gebirge</Spezialisierung>
-            <Spezialisierung>Meer</Spezialisierung>
-            <Spezialisierung>Steppe</Spezialisierung>
-            <Spezialisierung>Sumpf</Spezialisierung>
-            <Spezialisierung>Wald</Spezialisierung>
-            <Spezialisierung>W?ste</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 26</Beschreibung>
-        </Talent>
-      </Talentgruppe>
-      <Talentgruppe ID="Wissenstalente">
-        <Talent ID="Anatomie">
-          <Probe>MU/KL/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Totenangst">
-              <kein/>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="Baukunst">
-          <Probe>KL/KL/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">5</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Rechnen">
-              <Wert ID="minimal">5</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Hochbau</Spezialisierung>
-            <Spezialisierung>Tiefbau</Spezialisierung>
-            <Spezialisierung>Wehranlagen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="Brettspiel">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="Geographie">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="Geschichtswissen">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="Gesteinskunde">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Baugestein</Spezialisierung>
-            <Spezialisierung>Edelmetalle</Spezialisierung>
-            <Spezialisierung>Edelsteine</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="G?tter und Kulte">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Basis</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="Heraldik">
-          <Probe>KL/KL/FF</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 28</Beschreibung>
-        </Talent>
-        <Talent ID="H?ttenkunde">
-          <Probe>KL/IN/KO</Probe>
-          <Art>Beruf</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 29</Beschreibung>
-        </Talent>
-        <Talent ID="Kriegskunst">
-          <Probe>MU/KL/CH</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Logistik</Spezialisierung>
-            <Spezialisierung>Milit?rgeschichte</Spezialisierung>
-            <Spezialisierung>Monstren</Spezialisierung>
-            <Spezialisierung>Seegefechte</Spezialisierung>
-            <Spezialisierung>Strategie</Spezialisierung>
-            <Spezialisierung>Taktik</Spezialisierung>
-            <Spezialisierung>Drachenbek?mpfung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 29</Beschreibung>
-        </Talent>
-        <Talent ID="Kryptographie">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Rechnen">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Sprachenkunde">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 29</Beschreibung>
-        </Talent>
-        <Talent ID="Magiekunde">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Artefaktherstellung</Spezialisierung>
-            <Spezialisierung>D?monologie</Spezialisierung>
-            <Spezialisierung>Elementarismus</Spezialisierung>
-            <Spezialisierung>Magiehistorie</Spezialisierung>
-            <Spezialisierung>Magietheorie</Spezialisierung>
-            <Spezialisierung>Magische Analyse</Spezialisierung>
-            <Spezialisierung>Sph?rologie</Spezialisierung>
-            <Spezialisierung>Zauberpraxis</Spezialisierung>
-            <Spezialisierung>Zauberwerkstatt</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 29</Beschreibung>
-        </Talent>
-        <Talent ID="Mechanik">
-          <Probe>KL/KL/FF</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Rechnen">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Belagerungswaffen</Spezialisierung>
-            <Spezialisierung>Kr?ne, Hebewerke und Mahlwerke</Spezialisierung>
-            <Spezialisierung>Materialkunde</Spezialisierung>
-            <Spezialisierung>Pumpen und Wasserkraft</Spezialisierung>
-            <Spezialisierung>Windkraft</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 29</Beschreibung>
-        </Talent>
-        <Talent ID="Pflanzenkunde">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Dschungel</Spezialisierung>
-            <Spezialisierung>Gebirge</Spezialisierung>
-            <Spezialisierung>Grasland</Spezialisierung>
-            <Spezialisierung>Meer</Spezialisierung>
-            <Spezialisierung>Steppe</Spezialisierung>
-            <Spezialisierung>Sumpf</Spezialisierung>
-            <Spezialisierung>Tundra</Spezialisierung>
-            <Spezialisierung>Wlad</Spezialisierung>
-            <Spezialisierung>W?ste</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 29</Beschreibung>
-        </Talent>
-        <Talent ID="Philosophie">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 29/30</Beschreibung>
-        </Talent>
-        <Talent ID="Rechnen">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Arithemtik</Spezialisierung>
-            <Spezialisierung>Buchf?hrung</Spezialisierung>
-            <Spezialisierung>Geometrie</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 30</Beschreibung>
-        </Talent>
-        <Talent ID="Rechtskunde">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Gildenrecht</Spezialisierung>
-            <Spezialisierung>Kirchenrecht</Spezialisierung>
-            <Spezialisierung>Strafrecht</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 30</Beschreibung>
-        </Talent>
-        <Talent ID="Sagen / Legenden">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Basis</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 30</Beschreibung>
-        </Talent>
-        <Talent ID="Schiffbau">
-          <Probe>KL/KL/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Rechnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 30</Beschreibung>
-        </Talent>
-        <Talent ID="Sch?tzen">
-          <Probe>KL/IN/IN</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Antiquit?ten</Spezialisierung>
-            <Spezialisierung>Materialwert</Spezialisierung>
-            <Spezialisierung>Schmuck</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 30</Beschreibung>
-        </Talent>
-        <Talent ID="Sprachenkunde">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 30/31</Beschreibung>
-        </Talent>
-        <Talent ID="Staatskunst">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Diplomatie</Spezialisierung>
-            <Spezialisierung>Intrige</Spezialisierung>
-            <Spezialisierung>Verwaltung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 31</Beschreibung>
-        </Talent>
-        <Talent ID="Sternkunde">
-          <Probe>KL/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Rechnen">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Sinnensch?rfe">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Himmelskartographie</Spezialisierung>
-            <Spezialisierung>Horoskope</Spezialisierung>
-            <Spezialisierung>Navigation</Spezialisierung>
-            <Spezialisierung>Zeitbestimmung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 31</Beschreibung>
-        </Talent>
-        <Talent ID="Tierkunde">
-          <Probe>MU/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Drachen</Spezialisierung>
-            <Spezialisierung>Jagdwild</Spezialisierung>
-            <Spezialisierung>Meeresgetier</Spezialisierung>
-            <Spezialisierung>Monstren</Spezialisierung>
-            <Spezialisierung>Nutztiere</Spezialisierung>
-            <Spezialisierung>Raubtiere</Spezialisierung>
-            <Spezialisierung>Sch?dlinge</Spezialisierung>
-            <Spezialisierung>Vielbeiner</Spezialisierung>
-            <Spezialisierung>V?gel</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 31</Beschreibung>
-        </Talent>
-      </Talentgruppe>
-      <Talentgruppe ID="Handwerkliche Talente">
-        <Talent ID="Abrichten">
-          <Probe>MU/IN/CH</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Tierkunde">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Dompteur</Spezialisierung>
-            <Spezialisierung>Falkner</Spezialisierung>
-            <Spezialisierung>Hundef?hrer</Spezialisierung>
-            <Spezialisierung>Zureiter</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 33/34</Beschreibung>
-        </Talent>
-        <Talent ID="Ackerbau">
-          <Probe>IN/FF/KO</Probe>
-          <Art>Beruf</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34</Beschreibung>
-        </Talent>
-        <Talent ID="Alchimie">
-          <Probe>MU/KL/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Rechnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Brandmittel</Spezialisierung>
-            <Spezialisierung>Gifte</Spezialisierung>
-            <Spezialisierung>Laborpraxis</Spezialisierung>
-            <Spezialisierung>Zauber-Elixiere</Spezialisierung>
-            <Spezialisierung>Farben und Lacke</Spezialisierung>
-            <Spezialisierung>Gl?se</Spezialisierung>
-            <Spezialisierung>Porzellan</Spezialisierung>
-            <Spezialisierung>Legierungen</Spezialisierung>
-            <Spezialisierung>Goldmacherei</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34</Beschreibung>
-        </Talent>
-        <Talent ID="Bergbau">
-          <Probe>IN/KO/KK</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Gesteinskunde">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Bergwerke</Spezialisierung>
-            <Spezialisierung>Kanalisation</Spezialisierung>
-            <Spezialisierung>nat?rliche H?hlen</Spezialisierung>
-            <Spezialisierung>Sappeur</Spezialisierung>
-            <Spezialisierung>unterirdische St?dte</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34</Beschreibung>
-        </Talent>
-        <Talent ID="Bogenbau">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Holzbearbeitung">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Armbrust</Spezialisierung>
-            <Spezialisierung>Bogen</Spezialisierung>
-            <Spezialisierung>Bolzen und Pfeile</Spezialisierung>
-            <Spezialisierung>Torsionswaffen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34</Beschreibung>
-        </Talent>
-        <Talent ID="Boote Fahren">
-          <Probe>GE/KO/KK</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Einmaster Segeln</Spezialisierung>
-            <Spezialisierung>Fl??e Staken</Spezialisierung>
-            <Spezialisierung>Kanus und Kajaks Paddeln</Spezialisierung>
-            <Spezialisierung>Ruderboote Rudern</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34</Beschreibung>
-        </Talent>
-        <Talent ID="Brauer">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34</Beschreibung>
-        </Talent>
-        <Talent ID="Drucker">
-          <Probe>KL/FF/KO</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Mechanik">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Buchdruck</Spezialisierung>
-            <Spezialisierung>Druckereitechnologie</Spezialisierung>
-            <Spezialisierung>Pamphlete</Spezialisierung>
-            <Spezialisierung>Typographie</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34</Beschreibung>
-        </Talent>
-        <Talent ID="Eissegler Fahren">
-          <Probe>IN/GE/KK</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 34/35</Beschreibung>
-        </Talent>
-        <Talent ID="Fahrzeug Lenken">
-          <Probe>IN/CH/FF</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Lastkarren</Spezialisierung>
-            <Spezialisierung>Streitwagen</Spezialisierung>
-            <Spezialisierung>Zuggespanne</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Falschspiel">
-          <Probe>MU/CH/FF</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Menschenkenntnis">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>W?rfel</Spezialisierung>
-            <Spezialisierung>Karten</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Feinmechanik">
-          <Probe>KL/FF/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Gold- und Silberschmied</Spezialisierung>
-            <Spezialisierung>Gravieren</Spezialisierung>
-            <Spezialisierung>Schl?sser</Spezialisierung>
-            <Spezialisierung>Siegelst?cke</Spezialisierung>
-            <Spezialisierung>Trickwaffen und Fallen</Spezialisierung>
-            <Spezialisierung>Uhrwerke</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Feuersteinbearbeitung">
-          <Probe>KL/FF/FF</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Fleischer">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Fische</Spezialisierung>
-            <Spezialisierung>Gefl?gel</Spezialisierung>
-            <Spezialisierung>Reptilien</Spezialisierung>
-            <Spezialisierung>S?ugetiere</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Gerber / K?rschner">
-          <Probe>KL/FF/KO</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Gerber</Spezialisierung>
-            <Spezialisierung>K?rschner</Spezialisierung>
-            <Spezialisierung>Troph?en</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Glaskunst">
-          <Probe>FF/FF/KO</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Fensterscheiben</Spezialisierung>
-            <Spezialisierung>Glasbl?serei</Spezialisierung>
-            <Spezialisierung>Linsenschleifen</Spezialisierung>
-            <Spezialisierung>Spiegel</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Grobschmied">
-          <Probe>FF/KK/KO</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Drahtzieher</Spezialisierung>
-            <Spezialisierung>Hufschmied</Spezialisierung>
-            <Spezialisierung>Pl?ttner</Spezialisierung>
-            <Spezialisierung>Schwarzschmied</Spezialisierung>
-            <Spezialisierung>Spengler</Spezialisierung>
-            <Spezialisierung>Waffenschmied</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35</Beschreibung>
-        </Talent>
-        <Talent ID="Handel">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Rechnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 35/36</Beschreibung>
-        </Talent>
-        <Talent ID="Hauswirtschaft">
-          <Probe>IN/CH/FF</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Bewirtung und Feiern</Spezialisierung>
-            <Spezialisierung>Personal</Spezialisierung>
-            <Spezialisierung>Vorratshaltung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 36</Beschreibung>
-        </Talent>
-        <Talent ID="Heilkunde Gift">
-          <Probe>MU/KL/IN</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 36</Beschreibung>
-        </Talent>
-        <Talent ID="Heilkunde Krankheiten">
-          <Probe>MU/KL/CH</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 36</Beschreibung>
-        </Talent>
-        <Talent ID="Heilkunde Seele">
-          <Probe>IN/CH/CH</Probe>
-          <Art>Beruf</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 36/37</Beschreibung>
-        </Talent>
-        <Talent ID="Heilkunde Wunden">
-          <Probe>KL/CH/FF</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Br?che und Quetschungen</Spezialisierung>
-            <Spezialisierung>Schnitte</Spezialisierung>
-            <Spezialisierung>Verbrennungen</Spezialisierung>
-            <Spezialisierung>Zahnleiden</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 37</Beschreibung>
-        </Talent>
-        <Talent ID="Holzbearbeitung">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Beinschnitzerei</Spezialisierung>
-            <Spezialisierung>Holzkunde</Spezialisierung>
-            <Spezialisierung>Holzwaffen</Spezialisierung>
-            <Spezialisierung>K?fer und Wagner</Spezialisierung>
-            <Spezialisierung>M?belschreinerei und Tichlerei</Spezialisierung>
-            <Spezialisierung>Schnitzen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38</Beschreibung>
-        </Talent>
-        <Talent ID="Hundeschlitten Fahren">
-          <Probe>CH/FF/GE</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38</Beschreibung>
-        </Talent>
-        <Talent ID="Instrumentenbauer">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Feinmechanik">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Holzbearbeitung">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Musizieren">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Blasinstrumente</Spezialisierung>
-            <Spezialisierung>Saiteninstrumente</Spezialisierung>
-            <Spezialisierung>Tasteninstrumente</Spezialisierung>
-            <Spezialisierung>Trommeln</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38</Beschreibung>
-        </Talent>
-        <Talent ID="Kapellmeister">
-          <Probe>KL/IN/CH</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Lesen / Schreiben">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Musizieren">
-              <Wert ID="minimal">7</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Dirigieren</Spezialisierung>
-            <Spezialisierung>Komponieren</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38</Beschreibung>
-        </Talent>
-        <Talent ID="Kartographie">
-          <Probe>KL/KL/FF</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Geb?ude</Spezialisierung>
-            <Spezialisierung>H?hlen und Tunnel</Spezialisierung>
-            <Spezialisierung>K?sten und Meere</Spezialisierung>
-            <Spezialisierung>Landschaften</Spezialisierung>
-            <Spezialisierung>Stadt</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38</Beschreibung>
-        </Talent>
-        <Talent ID="Kochen">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Backen und Braten</Spezialisierung>
-            <Spezialisierung>Festmahle</Spezialisierung>
-            <Spezialisierung>Haltbarmachen</Spezialisierung>
-            <Spezialisierung>Marschversorgung</Spezialisierung>
-            <Spezialisierung>Tr?nke</Spezialisierung>
-            <Spezialisierung>Vorkoster</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38</Beschreibung>
-        </Talent>
-        <Talent ID="Kristallzucht">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Beruf</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38</Beschreibung>
-        </Talent>
-        <Talent ID="Lederarbeiten">
-          <Probe>KL/FF/FF</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Gurte und Riemen</Spezialisierung>
-            <Spezialisierung>Lederkleidung</Spezialisierung>
-            <Spezialisierung>Lederr?stung</Spezialisierung>
-            <Spezialisierung>S?ttel</Spezialisierung>
-            <Spezialisierung>Schuhwerk</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 38/39</Beschreibung>
-        </Talent>
-        <Talent ID="Malen / Zeichnen">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Architektur</Spezialisierung>
-            <Spezialisierung>Landschaften</Spezialisierung>
-            <Spezialisierung>Portr?t</Spezialisierung>
-            <Spezialisierung>technische Skizze</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Maurer">
-          <Probe>FF/GE/KK</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Steinbau</Spezialisierung>
-            <Spezialisierung>Steinguss</Spezialisierung>
-            <Spezialisierung>Ziegelbau</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Metallguss">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="H?ttenkunde">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Klangk?rper</Spezialisierung>
-            <Spezialisierung>Rohre</Spezialisierung>
-            <Spezialisierung>Reliefplatten und Statuen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Musizieren">
-          <Probe>IN/CH/FF</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Blechblasinstrumente</Spezialisierung>
-            <Spezialisierung>Fl?ten</Spezialisierung>
-            <Spezialisierung>Harfen</Spezialisierung>
-            <Spezialisierung>Lauten</Spezialisierung>
-            <Spezialisierung>Rhythmusinstrumente</Spezialisierung>
-            <Spezialisierung>Streichinstrumente</Spezialisierung>
-            <Spezialisierung>Tasteninstrumente</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Schl?sser Knacken">
-          <Probe>IN/FF/FF</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Fallen</Spezialisierung>
-            <Spezialisierung>Schl?sser</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Schnaps Brennen">
-          <Probe>KL/IN/FF</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>alchimistische Destillation</Spezialisierung>
-            <Spezialisierung>Beeren- und Obstbr?nde</Spezialisierung>
-            <Spezialisierung>Kornbr?nde</Spezialisierung>
-            <Spezialisierung>Kr?uterschn?pse</Spezialisierung>
-            <Spezialisierung>Lagerung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Schneidern">
-          <Probe>KL/FF/FF</Probe>
-          <Art>Basis</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Entwurf und Festgew?nder</Spezialisierung>
-            <Spezialisierung>Flcik und Gebrauchsschneiderei</Spezialisierung>
-            <Spezialisierung>Tuchr?stung</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Seefahrt">
-          <Probe>FF/GE/KK</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Ruderschiff</Spezialisierung>
-            <Spezialisierung>Segelschiff</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39</Beschreibung>
-        </Talent>
-        <Talent ID="Seiler">
-          <Probe>FF/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 39/40</Beschreibung>
-        </Talent>
-        <Talent ID="Steinmetz">
-          <Probe>FF/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Gesteinskunde">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Baugestein</Spezialisierung>
-            <Spezialisierung>Reliefs</Spezialisierung>
-            <Spezialisierung>Statuen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Steinschneider / Juwelier">
-          <Probe>IN/FF/FF</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Gesteinskunde">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Stellmacher">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Grobschmied">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Holzbearbeitung">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-            <Voraussetzung ID="Lederarbeiten">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Karren und Wagen</Spezialisierung>
-            <Spezialisierung>Schlitten</Spezialisierung>
-            <Spezialisierung>Streitwagen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Steuermann">
-          <Probe>IN/CH/KK</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Seefahrt">
-              <Wert ID="minimal">6</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Ruderschiff</Spezialisierung>
-            <Spezialisierung>Segelschiff</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Stoffe F?rben">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>alchimistische Farben</Spezialisierung>
-            <Spezialisierung>mineralische Farben</Spezialisierung>
-            <Spezialisierung>pflanzliche Farben</Spezialisierung>
-            <Spezialisierung>tierische Farben</Spezialisierung>
-            <Spezialisierung>Stoffdruck</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="T?towieren">
-          <Probe>IN/FF/FF</Probe>
-          <Art>Spezial</Art>
-          <Voraussetzungen ID="allgemein">
-            <Voraussetzung ID="Malen / Zeichnen">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Naturalistische Darstellungen</Spezialisierung>
-            <Spezialisierung>Ornamente</Spezialisierung>
-            <Spezialisierung>Zaubert?towierungen</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="T?pfern">
-          <Probe>KL/FF/FF</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Gef??e</Spezialisierung>
-            <Spezialisierung>Statuetten</Spezialisierung>
-            <Spezialisierung>Ziegelei</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Viehzucht">
-          <Probe>KL/IN/KK</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Rind</Spezialisierung>
-            <Spezialisierung>Schaf und Ziege</Spezialisierung>
-            <Spezialisierung>Schwein</Spezialisierung>
-            <Spezialisierung>Pferd</Spezialisierung>
-            <Spezialisierung>Hund</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Webkunst">
-          <Probe>FF/FF/KK</Probe>
-          <Art>Spezial</Art>
-          <Spezialisierungen>
-            <Spezialisierung>H?keln</Spezialisierung>
-            <Spezialisierung>Kl?ppeln</Spezialisierung>
-            <Spezialisierung>Stricken</Spezialisierung>
-            <Spezialisierung>Teppichkn?pfen</Spezialisierung>
-            <Spezialisierung>Weben</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Winzer">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Spezialisierungen>
-            <Spezialisierung>Wein</Spezialisierung>
-            <Spezialisierung>Fruchtweine</Spezialisierung>
-            <Spezialisierung>Schaumweine</Spezialisierung>
-            <Spezialisierung>Weinkenner</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-        <Talent ID="Zimmermann">
-          <Probe>KL/FF/KK</Probe>
-          <Art>Beruf</Art>
-          <Voraussetzungen ID="meisterlich">
-            <Voraussetzung ID="Holzbearbeitung">
-              <Wert ID="minimal">4</Wert>
-            </Voraussetzung>
-          </Voraussetzungen>
-          <Spezialisierungen>
-            <Spezialisierung>Dachdecker</Spezialisierung>
-            <Spezialisierung>Holzkonstruktionen</Spezialisierung>
-            <Spezialisierung>Schiffszimmermann</Spezialisierung>
-          </Spezialisierungen>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 40</Beschreibung>
-        </Talent>
-      </Talentgruppe>
-      <Talentgruppe ID="Sprachen &amp; Schriften">
-        <Talent ID="Lesen / Schreiben">
-          <Probe>KL/KL/FF</Probe>
-          <Art>Spezial</Art>
-          <Beschreibung>siehe Mit Flinken Fingern, S. 31-33</Beschreibung>
-        </Talent>
-      </Talentgruppe>
-    </Talente>
-    <Sprachen>
-    </Sprachen>
-    <Schriften>
-    </Schriften>
-    <Kampftechniken>
-      <Kampfart ID="Bewaffneter Nahkampf">
-        <Kampftechnik ID="Anderthalbh?nder">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 74</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Dolche">
-          <Art>Basis</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-1</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 75</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Fechtwaffen">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-1</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 75</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Hiebwaffen">
-          <Art>Basis</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-4</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 75</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Infanteriewaffen">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-3</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 76</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Kettenst?be">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-1</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 76</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Kettenwaffen">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-3</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 76</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Schwerter">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 77</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Speere">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-3</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 77</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="St?be">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 77</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="S?bel">
-          <Art>Basis</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 76/77</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Zweihand-Hiebwaffen">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-3</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 78</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Zweihandflegel">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-3</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 78</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Zweihandschwerter und -s?bel">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 78</Beschreibung>
-        </Kampftechnik>
-      </Kampfart>
-      <Kampfart ID="Bewaffneter Kampf">
-        <Kampftechnik ID="Lanzenreiten">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 58 und 76</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Peitsche">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-1</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 76</Beschreibung>
-        </Kampftechnik>
-      </Kampfart>
-      <Kampfart ID="Waffenloser Kampf">
-        <Kampftechnik ID="Raufen">
-          <Art>Basis</Art>
-          <SKT-Spalte>C</SKT-Spalte>
-          <eBE>BE</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 76</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Ringen">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 76</Beschreibung>
-        </Kampftechnik>
-      </Kampfart>
-      <Kampfart ID="Fernkampf">
-        <Kampftechnik ID="Armbrust">
-          <Art>Spezial</Art>
-          <SKT-Spalte>C</SKT-Spalte>
-          <eBE>BE-5</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 74</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Belagerungswaffen">
-          <Art>Beruf</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 74/75</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Blasrohr">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-5</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 75</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Bogen">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-3</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 75</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Diskus">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 75</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Schleuder">
-          <Art>Spezial</Art>
-          <SKT-Spalte>E</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 77</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Wurfbeile">
-          <Art>Spezial</Art>
-          <SKT-Spalte>D</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 77</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Wurfmesser">
-          <Art>Basis</Art>
-          <SKT-Spalte>C</SKT-Spalte>
-          <eBE>BE-3</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 77</Beschreibung>
-        </Kampftechnik>
-        <Kampftechnik ID="Wurfspeere">
-          <Art>Spezial</Art>
-          <SKT-Spalte>C</SKT-Spalte>
-          <eBE>BE-2</eBE>
-          <Beschreibung>siehe Mit Blitzenden Klingen, S. 77/78</Beschreibung>
-        </Kampftechnik>
-      </Kampfart>
-    </Kampftechniken>
-    <Charakteristika>
-    </Charakteristika>
-    <Sonderfertigkeiten>
-    </Sonderfertigkeiten>
-    <Zauberspr?che>
-    </Zauberspr?che>
-  </Inhalt>
-</XDIML>



From blakharaz at mail.berlios.de  Thu Jul 12 22:00:34 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 12 Jul 2007 22:00:34 +0200
Subject: [Dsa-hl-svn] r3599 - in rl/trunk/engine: dialog/include ui/include
	ui/src
Message-ID: <200707122000.l6CK0Y2Z006716@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-12 22:00:25 +0200 (Thu, 12 Jul 2007)
New Revision: 3599

Modified:
   rl/trunk/engine/dialog/include/DialogResponse.h
   rl/trunk/engine/ui/include/DialogControlState.h
   rl/trunk/engine/ui/include/DialogWindow.h
   rl/trunk/engine/ui/include/ListboxWrappedTextItem.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
- Removed all dialog control flow from DialogWindow
- DialogWindow is a view controlled by DialogControlState
- TODO: move all dialog option/response calculation functions to dialog subsystem


Modified: rl/trunk/engine/dialog/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/dialog/include/DialogResponse.h	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/dialog/include/DialogResponse.h	2007-07-12 20:00:25 UTC (rev 3599)
@@ -38,7 +38,7 @@
 	public:
 		typedef std::map<int, CeGuiString> Options;
 		typedef std::list<std::pair<CeGuiString, CeGuiString> > Responses;
-		typedef std::list<DialogOption*> DialogOptions;
+		typedef std::vector<DialogOption*> DialogOptions;
 
 		DialogResponse( const CeGuiString& input, 
 						const CeGuiString& response,
@@ -67,7 +67,7 @@
 		Options mSelectableOptions;
 		
 		Responses mResponses;
-		std::list<DialogOption*> mOptions;
+		DialogOptions mOptions;
 		AimlBot<CeGuiString>* mBot;
 
 		NaturalLanguageProcessor* mNlp;

Modified: rl/trunk/engine/ui/include/DialogControlState.h
===================================================================
--- rl/trunk/engine/ui/include/DialogControlState.h	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/include/DialogControlState.h	2007-07-12 20:00:25 UTC (rev 3599)
@@ -25,7 +25,10 @@
 namespace rl {
 
 	class Actor;
+	class DialogCharacter;
+	class DialogResponse;
 	class DialogWindow;
+	class GameLoggerWindow;
 	class MeshAnimation;
 	class SoundObject;
 	class SubtitleWindow;
@@ -63,10 +66,12 @@
 		/// Antwort eines der Dialogf?hrenden
 		void response(Actor* actor, const CeGuiString& text, const Ogre::String& soundFile = "");
 
-		void setDialogWindow(DialogWindow* dialog);
-		void setSubtitleWindow(SubtitleWindow* subtitles);
-	
         virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id);
+
+		bool handleDialogSelectOption();	
+		bool handleDialogClose();
+		bool requestDialogClose();
+
 	private:
 		/// Die Zielkameraposition in lokalen Koordinaten
 		Ogre::Vector3 mTargetCameraPosition;
@@ -100,6 +105,37 @@
 	
 		float getShowTextLength(const CeGuiString& text) const;
         void recalculateCamera( Actor* speaker, Actor* listener );
+
+		enum DialogState
+		{
+			CHOOSING_OPTION = 1,
+			TALKING_PARTNER_CHARACTER,
+			TALKING_PLAYER_CHARACTER,
+			CLOSING_DIALOG
+		};
+
+		DialogCharacter* mBot;
+		DialogResponse* mCurrentResponse;
+		GameLoggerWindow* mGameLogger;
+		DialogState mState;
+		CeGuiString mCurrentResponseText;
+				
+		void getOptions(const CeGuiString& question);
+
+		static const CeGuiString DIALOG_START;
+		static const CeGuiString DIALOG_EXIT;
+		static const CeGuiString DIALOG_END;
+
+		void getResponse(const CeGuiString& msg);
+		unsigned int count();
+		void setCallback(Ogre::String function);
+		int getSelectedOption();
+
+		void initialize(DialogCharacter* bot);
+		void textFinished();
+
+        void start();
+
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/include/DialogWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DialogWindow.h	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/include/DialogWindow.h	2007-07-12 20:00:25 UTC (rev 3599)
@@ -26,60 +26,31 @@
 
 namespace rl {
 
-	class DialogCharacter;
-	class DialogResponse;
 	class DialogControlState;
-	class GameLoggerWindow;
 
 	class _RlUiExport DialogWindow : public AbstractWindow
 	{
 	public:
-		DialogWindow(GameLoggerWindow* gamelogger);
-		~DialogWindow();
+		DialogWindow(DialogControlState* controller);
 
-        void initialize(DialogControlState* controller, DialogCharacter* character);
+		void setName(const CeGuiString& name);
+		void setImage(const CeGuiString& imageset, const CeGuiString& image);
+		void setAvailableOptions(const CeGuiStringVector& options);
+		void setChosenOption(const CeGuiString& option);
+		void setResponse(const CeGuiString& response);
+		void setDialogEnd();
+		int getSelectedOptionIndex() const;
 
-		void getResponse(const CeGuiString& msg);
-		unsigned int count();
-		void setCallback(Ogre::String function);
-		void setName(Ogre::String name);
-		void setImage(Ogre::String imageset, Ogre::String image);
-		int getSelectedOption();
-
-		void textFinished();
-
-        void start();
-
 	private:
-		enum DialogState
-		{
-			CHOOSING_OPTION = 1,
-			TALKING_PARTNER_CHARACTER,
-			TALKING_PLAYER_CHARACTER,
-			CLOSING_DIALOG
-		};
+		static const CEGUI::colour COLOR_PLAYER_CHARACTER;
+		static const CEGUI::colour COLOR_NON_PLAYER_CHARACTER;
 
-		DialogCharacter* mBot;
-		DialogResponse* mCurrentResponse;
 		CEGUI::Listbox* mDialogOptions;
 		CEGUI::Window* mImage;
 		CEGUI::Listbox* mQuestion;
 		CEGUI::Window* mName;
-		GameLoggerWindow* mGameLogger;
-		DialogControlState* mController;
-		DialogState mState;
-		CeGuiString mCurrentResponseText;
-				
-		bool handleSelectOption();	
-		bool handleClose();
-		bool requestClose();
-		void getOptions(const CeGuiString& question);
-
-		static const CEGUI::colour COLOR_PLAYER_CHARACTER;
-		static const CEGUI::colour COLOR_NON_PLAYER_CHARACTER;
-		static const CeGuiString DIALOG_START;
-		static const CeGuiString DIALOG_EXIT;
-		static const CeGuiString DIALOG_END;
+		CEGUI::ListboxTextItem* mPlayerText;
+		CEGUI::ListboxTextItem* mNscText;
 	};
 
 }

Modified: rl/trunk/engine/ui/include/ListboxWrappedTextItem.h
===================================================================
--- rl/trunk/engine/ui/include/ListboxWrappedTextItem.h	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/include/ListboxWrappedTextItem.h	2007-07-12 20:00:25 UTC (rev 3599)
@@ -28,7 +28,7 @@
 
 namespace CEGUI {
 
-class ListboxWrappedTextItem : public ListboxItem
+class ListboxWrappedTextItem : public ListboxTextItem
 {
 public:
 	/*************************************************************************

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2007-07-12 20:00:25 UTC (rev 3599)
@@ -42,7 +42,6 @@
     class Creature;
     class DebugWindow;
     class DialogCharacter;
-    class DialogWindow;
     class GameLoggerWindow;
     class GameObject;
     class PropertiesWindow;
@@ -56,7 +55,6 @@
     class ObjectDescriptionWindow;
     class Person;
     class SaveLoadWindow;
-    class SubtitleWindow;
     class WindowUpdater;
 
     class _RlUiExport WindowFactory : public Ogre::Singleton<WindowFactory>
@@ -104,8 +102,6 @@
         void toggleInGameGlobalMenu();
         void toggleInventoryWindow();
 
-        DialogWindow* getDialogWindow();
-        SubtitleWindow* getSubtitleWindow();
         CombatWindow* getCombatWindow();
 
         void checkForErrors();
@@ -125,8 +121,6 @@
 
         GameLoggerWindow* mGameLogger;
         CharacterStateWindow* mCharacterStateWindow;
-        DialogWindow* mDialogWindow;
-        SubtitleWindow* mSubtitleWindow;
         InGameMenuWindow* mInGameMenuWindow;
         CharacterSheetWindow* mCharacterSheet;
         JournalWindow* mJournalWindow;

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
@@ -1,300 +1,492 @@
-/*
-* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-
-#include "DialogControlState.h"
-#include "Exception.h"
-
-#include "Actor.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "DialogCharacter.h"
-#include "DialogSubsystem.h"
-#include "DialogWindow.h"
-#include "InputManager.h"
-#include "MeshAnimation.h"
-#include "MeshObject.h"
-#include "Person.h"
-#include "PhysicalThing.h"
-#include "Sound.h"
-#include "SoundDriver.h"
-#include "SoundManager.h"
-#include "SoundObject.h"
-#include "SubtitleWindow.h"
-#include "WindowFactory.h"
-#include "WindowManager.h"
-#include "World.h"
-
-#include <OgreSceneManager.h>
-#include <OgreNewt_Body.h>
-
-using namespace Ogre;
-
-namespace rl {
-
-    DialogControlState::DialogControlState(CommandMapper* cmdMapper,
-        Actor* camera, Person* character)
-        : ControlState(cmdMapper, camera, character, CST_DIALOG),
-        mTargetCameraPosition(Vector3::ZERO),
-        mTargetCameraDirection(Vector3::UNIT_Z),
-        mCurrFadeTextTime(0),
-        mTotalFadeTextTime(0),
-        mText(),
-        mDialogMode(DM_FRONT),
-        mTextShown(false),
-        mDialogWindow(NULL),
-        mSubtitleWindow(NULL),
-        mSoundObject(NULL),
-        mTalkAnimation(NULL),
-        mSubtitleSpeed(1.0f)
-    {
-        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
-            "General", "Subtitle Speed");
-
-    }
-
-    DialogControlState::~DialogControlState()
-    {
-        delete mSoundObject;
-    }
-
-    void DialogControlState::pause()
-    {
-        if(mDialogPartner)
-        {
-            MeshObject* mesh = dynamic_cast<MeshObject*>(mDialogPartner->getControlledObject());
-            if (mesh != NULL)
-            {
-                mesh->stopAllAnimations();
-                if (mesh->hasAnimation("idle"))
-                {
-                    mTalkAnimation = mesh->startAnimation("idle");
-                }
-            }
-        }
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCharacterActor->getPhysicalThing()->unfreeze();
-        mDialogWindow->setVisible(false, false);
-        mSubtitleWindow->setVisible(false, false);
-    }
-
-    void DialogControlState::resume()
-    {
-        mCharacterActor->setVisible(true);
-
-        mCameraActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->freeze();
-        Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
-        ogreCam->setFixedYawAxis(true);
-        ogreCam->setPosition(Vector3::ZERO);
-        ogreCam->setOrientation(Quaternion::IDENTITY);
-        mCameraActor->_getSceneNode()->setFixedYawAxis(true);
-
-        DialogCharacter* bot = DialogSubsystem::getSingleton().getCurrentDialogCharacter();
-        bot->setDialogCharacter(mCharacter);
-		mDialogPartner = bot->getDialogPartner()->getActor();
-
-        recalculateCamera( mDialogPartner, mCharacterActor );
-
-        mSubtitleWindow = WindowFactory::getSingleton().getSubtitleWindow();
-
-        mDialogWindow = WindowFactory::getSingleton().getDialogWindow();
-        mDialogWindow->initialize(this, bot);
-		mDialogWindow->start();
-    }
-
-    void DialogControlState::run(Real elapsedTime)
-    {
-        if( elapsedTime <= 0.0 )
-            return;
-
-        // Aktuellen Abstand zur gew?nschten Position berechnen
-        Vector3 posDistance = (mTargetCameraPosition - mCameraActor->_getSceneNode()->getPosition());
-        // Ist eine Anpassung n?tig?
-        if( posDistance != Vector3::ZERO )
-        {
-            // Die Kameraanpassgeschwindigkeit
-            Real speed = 1/elapsedTime;
-            mCameraActor->setPosition(mTargetCameraPosition);
-        }
-
-        mCameraActor->setOrientation( Quaternion::IDENTITY );
-        mCameraActor->_getSceneNode()->setDirection( mTargetCameraDirection );
-        mCameraActor->_getSceneNode()->_update( true, false );
-
-        // Textanzeigedauer
-        if (mCurrFadeTextTime >= 0)
-        {
-            mCurrFadeTextTime -= elapsedTime;
-        }
-
-        if (mTextShown && mCurrFadeTextTime <= 0)
-        {
-            mCurrFadeTextTime = 0;
-            mTotalFadeTextTime = 0;
-            mTextShown = false;
-               if (mSoundObject)
-            {
-                mSoundObject->stop();
-            }
-            mSubtitleWindow->setVisible(false, false);
-            mDialogWindow->textFinished();
-        }
-
-        LOG_DEBUG(Logger::UI,
-                StringConverter::toString(mSubtitleWindow->getWindow()->getEffectiveAlpha())
-                + ": "
-                + mSubtitleWindow->getText()
-                + CeGuiString(mSubtitleWindow->getWindow()->isVisible() ? "vis" : "unvis")
-                + ", Time: "
-                + StringConverter::toString(mCurrFadeTextTime));
-    }
-
-    void DialogControlState::recalculateCamera( Actor* speaker, Actor* listener )
-    {
-        // Position camera at position between char and dialog partner
-        Vector3 charEyes = speaker->getWorldPosition();
-        // Modify by MeshBounds
-        if( speaker->getControlledObject()->isMeshObject() )
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(speaker->getControlledObject());
-            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            charEyes += speaker->getWorldOrientation()*offset;
-        }
-
-        Vector3 partEyes = listener->getWorldPosition();
-        // Modify by MeshBounds
-        if( listener->getControlledObject()->isMeshObject() )
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(listener->getControlledObject());
-            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            partEyes += listener->getWorldOrientation()*offset;
-        }
-
-        Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
-
-        // Weltkoordinaten in lokale umwandeln
-        mTargetCameraPosition =
-            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
-            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
-
-
-        mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
-    }
-
-    float DialogControlState::getShowTextLength(const CeGuiString& text) const
-    {
-        return 0.019f * text.length() + // Zeit f?rs Text lesen
-               0.25f;                   // Fade in
-    }
-
-    void DialogControlState::response(
-        Actor* actor, const CeGuiString& text, const Ogre::String& soundFile)
-    {
-        if( actor == mDialogPartner )
-            recalculateCamera( mCharacterActor, mDialogPartner );
-        else
-            recalculateCamera( mDialogPartner, mCharacterActor );
-
-        // Ungef?hre Lesedauer bestimmen
-        float fadeTime = getShowTextLength(text);
-        if (soundFile.length() == 0)
-        {
-            float speed = mSubtitleSpeed;
-
-            if( mSubtitleSpeed == 0.0 )
-                speed = 1.0;
-
-            mCurrFadeTextTime = fadeTime*speed;
-            mTotalFadeTextTime = fadeTime*speed;
-        }
-        else
-        {
-            if( mSoundObject != NULL )
-                mSoundObject->getMovableObject()->getParentSceneNode()->detachObject(
-                    mSoundObject->getMovableObject() );
-
-            delete mSoundObject;
-            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()->
-                    createSound(soundFile, ST_SAMPLE), soundFile);
-
-            // An Sprecher h?ngen
-            actor->_getSceneNode()->attachObject( mSoundObject->getMovableObject() );
-            actor->_getSceneNode()->_update( true, false );
-            mSoundObject->_setActor( actor );
-            mSoundObject->set3d(true);
-            mSoundObject->play();
-            mSoundObject->_update();
-
-
-            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject->getLength());
-            mTotalFadeTextTime = mCurrFadeTextTime;
-        }
-
-        MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
-        if (mesh != NULL)
-        {
-            if (mesh->hasAnimation("reden"))
-            {
-                mesh->stopAllAnimations();
-                mTalkAnimation = mesh->startAnimation("reden");
-            }
-        }
-
-        LOG_DEBUG(Logger::UI,
-            "Response: "
-                + actor->getName()
-                + " File: '"
-                + soundFile
-                + "', Text: '" + text + "', Time: "
-                + StringConverter::toString(mCurrFadeTextTime));
-
-
-        mTextShown = true;
-
-        if (mSubtitleWindow != NULL && !text.empty())
-        {
-            mSubtitleWindow->show(text);
-        }
-    }
-
-    bool DialogControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id)
-    {
-
-        if (mTextShown && (mCurrFadeTextTime + 0.25) < mTotalFadeTextTime)
-        {
-            mCurrFadeTextTime = -1;
-
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-
-    }
-}
+??/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
\ No newline at end of file

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
@@ -34,291 +34,113 @@
 
 namespace rl {
 
-using namespace Ogre;
-using namespace CEGUI;
+	using namespace Ogre;
+	using namespace CEGUI;
 
-const CEGUI::colour DialogWindow::COLOR_PLAYER_CHARACTER(	 0xFFFF7F7F);
-const CEGUI::colour DialogWindow::COLOR_NON_PLAYER_CHARACTER(0xFFFFFF7F);
+	const CEGUI::colour DialogWindow::COLOR_PLAYER_CHARACTER(	 0xFFFF7F7F);
+	const CEGUI::colour DialogWindow::COLOR_NON_PLAYER_CHARACTER(0xFFFFFF7F);
 
-const CeGuiString DialogWindow::DIALOG_START = "1";
-const CeGuiString DialogWindow::DIALOG_END = "DIALOG BEENDET";
-const CeGuiString DialogWindow::DIALOG_EXIT = "EXIT";
+	DialogWindow::DialogWindow(DialogControlState* controller)
+	  : AbstractWindow("dialogwindow.xml", WIT_MOUSE_INPUT, false)
+	{
+		mImage = getWindow("DialogWindow/Image");
+		mName = getWindow("DialogWindow/Name");
+		mQuestion = getListbox("DialogWindow/Question");
+		mDialogOptions = getListbox("DialogWindow/OptionList");
 
-DialogWindow::DialogWindow(GameLoggerWindow* gamelogger)
-  : AbstractWindow("dialogwindow.xml", WIT_MOUSE_INPUT, false),
-	mBot(NULL), 
-	mCurrentResponse(NULL),
-    mCurrentResponseText(""),
-	mGameLogger(gamelogger),
-	mController(NULL),
-    mState( TALKING_PLAYER_CHARACTER )
-{
-	mImage = getWindow("DialogWindow/Image");
-	mName = getWindow("DialogWindow/Name");
-	mQuestion = getListbox("DialogWindow/Question");
-	mDialogOptions = getListbox("DialogWindow/OptionList");
+		mWindow->subscribeEvent(
+			FrameWindow::EventCloseClicked, // Verstecken, falls Close geklickt wird
+			boost::bind(&DialogControlState::requestDialogClose, controller)); //TODO: als Abbrechen werten 
 
-	mWindow->subscribeEvent(
-		FrameWindow::EventCloseClicked, // Verstecken, falls Close geklickt wird
-		boost::bind(&DialogWindow::requestClose, this)); //TODO: als Abbrechen werten 
+		mDialogOptions->subscribeEvent(
+			Listbox::EventSelectionChanged, 
+			boost::bind(&DialogControlState::handleDialogSelectOption, controller));
 
-	mDialogOptions->subscribeEvent(
-		Listbox::EventSelectionChanged, 
-		boost::bind(&DialogWindow::handleSelectOption, this));
-	mDialogOptions->moveToFront();
-	mDialogOptions->setClippedByParent(true);
-	mDialogOptions->setShowHorzScrollbar(false);
-	mDialogOptions->setShowVertScrollbar(false);
-	mDialogOptions->setMultiselectEnabled(false);
-}
+		mDialogOptions->moveToFront();
+		mDialogOptions->setClippedByParent(true);
+		mDialogOptions->setShowHorzScrollbar(false);
+		mDialogOptions->setShowVertScrollbar(false);
+		mDialogOptions->setMultiselectEnabled(false);
 
-DialogWindow::~DialogWindow()
-{
-	delete mCurrentResponse;
-	mCurrentResponse = NULL;
-}
+		// Add 2 ListboxItems, one for the nsc responses, 
+		// one for the player selections
+		mPlayerText = new ListboxWrappedTextItem("", 6);
+		mPlayerText->setTextColours(COLOR_PLAYER_CHARACTER);
+		mQuestion->addItem(mPlayerText);
 
-void DialogWindow::initialize(DialogControlState* controller, DialogCharacter* character)
-{
-    mController = controller;
-    mBot = character;
-	
-	// Add 2 ListboxItems, one for the nsc responses, 
-	// one for the player selections
-	ListboxWrappedTextItem* item = new ListboxWrappedTextItem("", 6);
-	item->setTextColours(COLOR_PLAYER_CHARACTER);
-	mQuestion->addItem(item);
-	item = new ListboxWrappedTextItem("", 0);
-	item->setTextColours(COLOR_NON_PLAYER_CHARACTER);
-	mQuestion->addItem(item);
-	item = NULL;
+		mNscText = new ListboxWrappedTextItem("", 0);
+		mNscText->setTextColours(COLOR_NON_PLAYER_CHARACTER);
+		mQuestion->addItem(mNscText);
+	}
 
-	
-	Ogre::String voiceFile = mBot->getVoiceFile().c_str();
-	if (voiceFile != "")
+	void DialogWindow::setImage(const CeGuiString& imageset, const CeGuiString& image)
 	{
-		if (voiceFile.find(".zip") != Ogre::String::npos)
-		{
-			ResourceGroupManager::getSingleton().addResourceLocation(
-				voiceFile, "Zip", voiceFile);
-		}
-		else
-		{
-			ResourceGroupManager::getSingleton().addResourceLocation(
-           		voiceFile, "FileSystem", voiceFile);
-		}
+		mImage->setProperty("Image", "set:" + imageset + " image:" + image);
 	}
-}
 
-void DialogWindow::start()
-{
-    if (mBot == NULL || mController == NULL)
-    {
-        Throw(IllegalStateException, "DialogWindow not properly initialized.");
-    }
-
-	mName->setText(mBot->getName());
-	getResponse(DIALOG_START);
-}
-
-void DialogWindow::getResponse(const CeGuiString& msg)
-{
-	delete mCurrentResponse;
-	mCurrentResponse = mBot->createResponse(msg);
-	
-    if(mBot->hasExitRequest())
-    {
-        mQuestion->getListboxItemFromIndex(0)->setText(DIALOG_END);
-		mQuestion->getListboxItemFromIndex(1)->setText("");
-		mState = CLOSING_DIALOG;
-        handleClose();
-        return;
-    }
-	if(mCurrentResponse == NULL)
+	void DialogWindow::setName(const CeGuiString& name)
 	{
-		mQuestion->getListboxItemFromIndex(0)->setText(DIALOG_END);
-		mQuestion->getListboxItemFromIndex(1)->setText("");
-		mState = CLOSING_DIALOG;
-	//	???bergangsl???sung, wenn gerade kein sprecher aktiv ist wird 
-	//	nicht nicht textFinished aufgerufen
-    //  hier m???sste wahrscheinlich requestClose auftauchen
-		handleClose();
-		return;
+		mName->setText(name);
 	}
 
-	DialogResponse::Responses responses = mCurrentResponse->getResponses();
-	CeGuiString responseSound = "null.ogg";
-	CeGuiString responseText;
-	if(!responses.empty())
+	void DialogWindow::setDialogEnd()
 	{
-		responseSound = responses.begin()->first;
-		responseText = responses.begin()->second;
-		responseText.c_str();
-		responseSound.c_str();	
+		setChosenOption("Ende");
+		setResponse("");
 	}
 
-	mController->response(
-			mBot->getDialogPartner()->getActor(), 
-			responseText, responseSound.c_str());
-
-	if(!responseText.empty())
+	void DialogWindow::setAvailableOptions(const CeGuiStringVector& options)
 	{
-		mQuestion->getListboxItemFromIndex(1)->
-			setText(mBot->getName() + ": " + responseText);
-		mQuestion->handleUpdatedItemData();
+		unsigned int i = 0;
+		for(CeGuiStringVector::const_iterator itr = options.begin(); 
+			itr != options.end(); ++itr)
+		{	
+			ListboxWrappedTextItem* item = NULL;
+			if(i < mDialogOptions->getItemCount())
+			{
+				item = static_cast<ListboxWrappedTextItem*>(
+					mDialogOptions->getListboxItemFromIndex(i));
+				item->setText(*itr);
+			}
+			else
+			{
+				item =	new ListboxWrappedTextItem(*itr, 6, true);
+				mDialogOptions->addItem(item);
+			}
 
-		mGameLogger->logDialogEvent(mBot->getName(), responseText);
-		LOG_MESSAGE(Logger::DIALOG, mBot->getName() + " says: " + responseText);
-	}
+			item->setTextFormatting(CEGUI::WordWrapLeftAligned);
+			mDialogOptions->handleUpdatedItemData();
 
-	setVisible(false);
-	mState = TALKING_PARTNER_CHARACTER;
-	mCurrentResponseText = msg;
-
-}
-
-void DialogWindow::textFinished()
-{
-	if (mState == TALKING_PARTNER_CHARACTER)
-	{
-		getOptions(mCurrentResponseText);
-		setVisible(true);
-		mState = CHOOSING_OPTION;
+			++i;
+		}
+		while(i < mDialogOptions->getItemCount())
+		{
+			mDialogOptions->removeItem(mDialogOptions->getListboxItemFromIndex(i));
+		}	
 	}
-	
-	if (mState == TALKING_PLAYER_CHARACTER)
-	{
-		getResponse(mCurrentResponseText);
-	}
-	
-    LOG_DEBUG(Logger::UI, 
-				StringConverter::toString(mState)
-				+ " bei textFinished" );
-}
 
-void DialogWindow::getOptions(const CeGuiString& question)
-{
-	if(mCurrentResponse == NULL)
+	int DialogWindow::getSelectedOptionIndex() const
 	{
-		Throw(rl::IllegalStateException, "mCurrentResponse must not be NULL.");
-		return;
-	}
-	
-	DialogResponse::DialogOptions options = mCurrentResponse->getDialogOptions();
-	
-	if(options.empty())
-	{
-		mQuestion->getListboxItemFromIndex(0)->setText(DIALOG_END);
-		mQuestion->getListboxItemFromIndex(1)->setText("");
-		handleClose();
-		return;
-	}
-	
-	//mDialogOptions->clearAllSelections();
-
-	unsigned int i = 0;
-	for(DialogResponse::DialogOptions::const_iterator itr = options.begin(); 
-		itr != options.end(); ++itr)
-	{	
-		CeGuiString currentResponse = (*itr)->getText();
-	    LOG_MESSAGE(Logger::UI, 
-			"Player says: " + currentResponse);
-		if(i < mDialogOptions->getItemCount())
+		CEGUI::ListboxItem* curr = mDialogOptions->getFirstSelectedItem();
+		if (curr)
 		{
-			ListboxWrappedTextItem* item = 
-				static_cast <ListboxWrappedTextItem*>(mDialogOptions->getListboxItemFromIndex(i));
-			item->setUserData(*itr);
-			item->setText(currentResponse);
-			item->setTextFormatting(CEGUI::WordWrapLeftAligned);
-			mDialogOptions->handleUpdatedItemData();
+			return mDialogOptions->getItemIndex(curr);
 		}
 		else
 		{
-			ListboxWrappedTextItem* item = 
-				new ListboxWrappedTextItem((*itr)->getText(), 6, true);
-			item->setUserData(*itr);
-			item->setTextFormatting(CEGUI::WordWrapLeftAligned);
-			mDialogOptions->addItem(item);
+			return -1;
 		}
-
-		++i;
 	}
-	while(i < mDialogOptions->getItemCount())
+
+	void DialogWindow::setChosenOption(const CeGuiString& option)
 	{
-		mDialogOptions->removeItem(mDialogOptions->getListboxItemFromIndex(i));
-	}	
-}
+		mPlayerText->setText("Held: " + option);
+	}
 
-unsigned int DialogWindow::count()
-{
-	return mDialogOptions->getItemCount();
-}
-
-void DialogWindow::setCallback(Ogre::String function)
-{
-	// TO DO: DialogWindow::setCallback(string function)
-}
-
-int DialogWindow::getSelectedOption()
-{
-	// TO DO: DialogWindow::getSelectedOption()
-	return 0;
-}
-
-bool DialogWindow::handleSelectOption()
-{
-	DebugWindow::getSingleton().setMessageText(StringConverter::toString(getSelectedOption()));
-	ListboxWrappedTextItem* item = 
-		static_cast<ListboxWrappedTextItem*>(mDialogOptions->getFirstSelectedItem());
-	if(item != NULL)
+	void DialogWindow::setResponse(const CeGuiString& response)
 	{
-		DialogOption* option = static_cast<DialogOption*>(item->getUserData());
-		option->processSelection();
-		mCurrentResponseText = option->getPattern();
-		CeGuiString selectedOption = option->getText();
-		if(mCurrentResponseText != "0" && mCurrentResponseText != "666")
-		{
-			if(!selectedOption.empty())
-			{
-				mState = TALKING_PLAYER_CHARACTER;
-				mGameLogger->logDialogEvent("Held", selectedOption);
-				LOG_MESSAGE(Logger::DIALOG,
-                    "Player says: " + selectedOption);
-				mQuestion->getListboxItemFromIndex(0)->setText("Held: " + selectedOption);	
-				mController->response(
-					mBot->getDialogCharacter()->getActor(), 
-					selectedOption, 
-					option->getId().c_str());			
-				setVisible(false);
-			}
-		}
+		mNscText->setText(mName->getText() + ": " + response);
+		mQuestion->handleUpdatedItemData();
 	}
-	
-	return true;
-}
 
-bool DialogWindow::handleClose()
-{
-	InputManager::getSingleton().popControlState();
-	hideWindow();
-	return true;
 }
-
-bool DialogWindow::requestClose()
-{
-//	handleClose is called automatically 
-	getResponse(DIALOG_EXIT);
-	return true;
-}
-
-void DialogWindow::setImage(Ogre::String imageset, Ogre::String image)
-{
-    mImage->setProperty("Image", "set:" + imageset + " image:" + image);
-}
-
-void DialogWindow::setName(Ogre::String name)
-{
-	mName->setProperty("Text", name);
-}
-
-}

Modified: rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
===================================================================
--- rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
@@ -42,7 +42,7 @@
     ListboxWrappedTextItem::ListboxWrappedTextItem(const String& text, int padding,
         bool draw_bullet, uint item_id,
         void* item_data, bool disabled, bool auto_delete) :
-    ListboxItem(text, item_id, item_data, disabled, auto_delete),
+    ListboxTextItem(text, item_id, item_data, disabled, auto_delete),
         d_textCols(DefaultTextColour, DefaultTextColour, DefaultTextColour, DefaultTextColour),
         d_padding(padding), d_draw_bullet(draw_bullet),
         d_font(0), d_textFormatting(WordWrapLeftAligned)

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-07-12 18:58:30 UTC (rev 3598)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-07-12 20:00:25 UTC (rev 3599)
@@ -68,8 +68,6 @@
     WindowFactory::WindowFactory()
         : mGameLogger(NULL),
         mCharacterStateWindow(NULL),
-        mDialogWindow(NULL),
-        mSubtitleWindow(NULL),
         mInGameMenuWindow(NULL),
         mCharacterSheet(NULL),
         mJournalWindow(NULL),
@@ -129,8 +127,6 @@
         delete mMainMenuWindow;
         delete mCloseConfirmationWindow;
         delete mGameSettings;
-        delete mDialogWindow;
-        delete mSubtitleWindow;
         delete mCombatWindow;
     }
 
@@ -409,24 +405,6 @@
         }
     }
 
-    DialogWindow* WindowFactory::getDialogWindow()
-    {
-        if (mDialogWindow == NULL)
-        {
-            mDialogWindow = new DialogWindow(mGameLogger);
-        }
-        return mDialogWindow;
-    }
-
-    SubtitleWindow* WindowFactory::getSubtitleWindow()
-    {
-        if (mSubtitleWindow == NULL)
-        {
-            mSubtitleWindow = new SubtitleWindow();
-        }
-        return mSubtitleWindow;
-    }
-
     CombatWindow* WindowFactory::getCombatWindow()
     {
         if (mCombatWindow == NULL)



From ablock at mail.berlios.de  Fri Jul 13 22:49:22 2007
From: ablock at mail.berlios.de (ablock at mail.berlios.de)
Date: Fri, 13 Jul 2007 22:49:22 +0200
Subject: [Dsa-hl-svn] r3600 - in rl/trunk: engine/ai engine/ai/include
	engine/ai/src engine/common engine/common/include
	engine/common/src engine/core engine/core/include
	engine/core/src engine/core/src/nulldriver engine/dialog
	engine/dialog/include engine/dialog/src
	engine/dialog/src/predicates engine/rules
	engine/rules/include engine/rules/src engine/script
	engine/script/include engine/script/src engine/ui
	engine/ui/include engine/ui/src plugins/fmod4driver
Message-ID: <200707132049.l6DKnMJl021076@sheep.berlios.de>

Author: ablock
Date: 2007-07-13 22:43:27 +0200 (Fri, 13 Jul 2007)
New Revision: 3600

Added:
   rl/trunk/engine/ai/include/stdinc.h
   rl/trunk/engine/ai/src/stdinc.cpp
   rl/trunk/engine/common/include/stdinc.h
   rl/trunk/engine/common/src/stdinc.cpp
   rl/trunk/engine/core/include/stdinc.h
   rl/trunk/engine/core/src/stdinc.cpp
   rl/trunk/engine/dialog/include/stdinc.h
   rl/trunk/engine/dialog/src/stdinc.cpp
   rl/trunk/engine/rules/include/stdinc.h
   rl/trunk/engine/rules/src/stdinc.cpp
   rl/trunk/engine/script/include/stdinc.h
   rl/trunk/engine/script/src/stdinc.cpp
   rl/trunk/engine/ui/include/stdinc.h
   rl/trunk/engine/ui/src/stdinc.cpp
Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/src/AStar.cpp
   rl/trunk/engine/ai/src/AStarCosts.cpp
   rl/trunk/engine/ai/src/AStarHeuristic.cpp
   rl/trunk/engine/ai/src/AStarNodePool.cpp
   rl/trunk/engine/ai/src/AStarWayPointNode.cpp
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
   rl/trunk/engine/ai/src/FuzzyState.cpp
   rl/trunk/engine/ai/src/FuzzyStateMachine.cpp
   rl/trunk/engine/ai/src/Landmark.cpp
   rl/trunk/engine/ai/src/LandmarkPath.cpp
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/ai/src/PlayerVehicle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/ai/src/WayPointGraphManager.cpp
   rl/trunk/engine/ai/src/WayPointNode.cpp
   rl/trunk/engine/common/RlCommon2005.vcproj
   rl/trunk/engine/common/src/ConfigFile.cpp
   rl/trunk/engine/common/src/EventObject.cpp
   rl/trunk/engine/common/src/EventSource.cpp
   rl/trunk/engine/common/src/GameTask.cpp
   rl/trunk/engine/common/src/Logger.cpp
   rl/trunk/engine/common/src/MathUtil.cpp
   rl/trunk/engine/common/src/OgreXercesInput.cpp
   rl/trunk/engine/common/src/Properties.cpp
   rl/trunk/engine/common/src/Property.cpp
   rl/trunk/engine/common/src/PropertyReader.cpp
   rl/trunk/engine/common/src/ScriptWrapper.cpp
   rl/trunk/engine/common/src/XmlErrorHandler.cpp
   rl/trunk/engine/common/src/XmlHelper.cpp
   rl/trunk/engine/common/src/XmlResource.cpp
   rl/trunk/engine/common/src/XmlResourceManager.cpp
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/core/src/ActorControlledObject.cpp
   rl/trunk/engine/core/src/ActorManager.cpp
   rl/trunk/engine/core/src/AnimationListener.cpp
   rl/trunk/engine/core/src/AnimationManager.cpp
   rl/trunk/engine/core/src/BaseAnimation.cpp
   rl/trunk/engine/core/src/BoxPrimitive.cpp
   rl/trunk/engine/core/src/CameraObject.cpp
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/ContentModule.cpp
   rl/trunk/engine/core/src/CoreEvents.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/DebugVisualisable.cpp
   rl/trunk/engine/core/src/DebugVisualsManager.cpp
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
   rl/trunk/engine/core/src/FadeAnimation.cpp
   rl/trunk/engine/core/src/GameAreaEvent.cpp
   rl/trunk/engine/core/src/GameAreaEventSource.cpp
   rl/trunk/engine/core/src/GameAreaListener.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/core/src/Job.cpp
   rl/trunk/engine/core/src/JobScheduler.cpp
   rl/trunk/engine/core/src/LightFadeJob.cpp
   rl/trunk/engine/core/src/LightObject.cpp
   rl/trunk/engine/core/src/LineSetPrimitive.cpp
   rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp
   rl/trunk/engine/core/src/ListenerMovable.cpp
   rl/trunk/engine/core/src/ListenerObject.cpp
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
   rl/trunk/engine/core/src/MeshAnimation.cpp
   rl/trunk/engine/core/src/MeshObject.cpp
   rl/trunk/engine/core/src/MovableText.cpp
   rl/trunk/engine/core/src/ParticleSystemObject.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsContactListener.cpp
   rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/trunk/engine/core/src/PlayAnimationJob.cpp
   rl/trunk/engine/core/src/PlaySoundJob.cpp
   rl/trunk/engine/core/src/PrimitiveObject.cpp
   rl/trunk/engine/core/src/RubyInterpreter.cpp
   rl/trunk/engine/core/src/SceneQuery.cpp
   rl/trunk/engine/core/src/Sound.cpp
   rl/trunk/engine/core/src/SoundDriver.cpp
   rl/trunk/engine/core/src/SoundEvents.cpp
   rl/trunk/engine/core/src/SoundFadeFunctor.cpp
   rl/trunk/engine/core/src/SoundFadeJob.cpp
   rl/trunk/engine/core/src/SoundManager.cpp
   rl/trunk/engine/core/src/SoundObject.cpp
   rl/trunk/engine/core/src/SoundResource.cpp
   rl/trunk/engine/core/src/TrackAnimation.cpp
   rl/trunk/engine/core/src/World.cpp
   rl/trunk/engine/core/src/Zone.cpp
   rl/trunk/engine/core/src/ZoneManager.cpp
   rl/trunk/engine/core/src/nulldriver/NullDriver.cpp
   rl/trunk/engine/core/src/nulldriver/NullListener.cpp
   rl/trunk/engine/core/src/nulldriver/NullSound.cpp
   rl/trunk/engine/dialog/RlDialog2005.vcproj
   rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
   rl/trunk/engine/dialog/src/AimlParserImplRl.cpp
   rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
   rl/trunk/engine/dialog/src/ContextInterpreter.cpp
   rl/trunk/engine/dialog/src/DialogCharacter.cpp
   rl/trunk/engine/dialog/src/DialogOption.cpp
   rl/trunk/engine/dialog/src/DialogResponse.cpp
   rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
   rl/trunk/engine/dialog/src/DialogSubsystem.cpp
   rl/trunk/engine/dialog/src/ScriptProcessor.cpp
   rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp
   rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp
   rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/src/Action.cpp
   rl/trunk/engine/rules/src/ActionManager.cpp
   rl/trunk/engine/rules/src/Armor.cpp
   rl/trunk/engine/rules/src/Combat.cpp
   rl/trunk/engine/rules/src/CombatManager.cpp
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/Date.cpp
   rl/trunk/engine/rules/src/DsaDataLoader.cpp
   rl/trunk/engine/rules/src/DsaManager.cpp
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectFactory.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/rules/src/Eigenschaft.cpp
   rl/trunk/engine/rules/src/EigenschaftenStateSet.cpp
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/rules/src/Item.cpp
   rl/trunk/engine/rules/src/JournalEntry.cpp
   rl/trunk/engine/rules/src/Kampftechnik.cpp
   rl/trunk/engine/rules/src/ObjectStateChangeEvent.cpp
   rl/trunk/engine/rules/src/ObjectStateChangeEventSource.cpp
   rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp
   rl/trunk/engine/rules/src/Person.cpp
   rl/trunk/engine/rules/src/Quest.cpp
   rl/trunk/engine/rules/src/QuestBook.cpp
   rl/trunk/engine/rules/src/QuestEvent.cpp
   rl/trunk/engine/rules/src/QuestListener.cpp
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/rules/src/SelectionHelper.cpp
   rl/trunk/engine/rules/src/Selector.cpp
   rl/trunk/engine/rules/src/Slot.cpp
   rl/trunk/engine/rules/src/SonderfertigkeitenStateSet.cpp
   rl/trunk/engine/rules/src/StateSet.cpp
   rl/trunk/engine/rules/src/Talent.cpp
   rl/trunk/engine/rules/src/TalentStateSet.cpp
   rl/trunk/engine/rules/src/Talentgruppe.cpp
   rl/trunk/engine/rules/src/TimerEvent.cpp
   rl/trunk/engine/rules/src/TimerEventSource.cpp
   rl/trunk/engine/rules/src/TimerListener.cpp
   rl/trunk/engine/rules/src/TimerManager.cpp
   rl/trunk/engine/rules/src/Weapon.cpp
   rl/trunk/engine/rules/src/ZauberStateSet.cpp
   rl/trunk/engine/script/RlScript2005.vcproj
   rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
   rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
   rl/trunk/engine/script/src/LightNodeProcessor.cpp
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
   rl/trunk/engine/script/src/ScriptObjectMarker.cpp
   rl/trunk/engine/script/src/ScriptSubsystem.cpp
   rl/trunk/engine/script/src/SoundNodeProcessor.cpp
   rl/trunk/engine/script/src/UnifiedFactory.cpp
   rl/trunk/engine/script/src/WaypointProcessor.cpp
   rl/trunk/engine/script/src/ZoneProcessor.cpp
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/src/AboutWindow.cpp
   rl/trunk/engine/ui/src/AbstractWindow.cpp
   rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
   rl/trunk/engine/ui/src/CharacterStateWindow.cpp
   rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp
   rl/trunk/engine/ui/src/CombatControlState.cpp
   rl/trunk/engine/ui/src/CombatWindow.cpp
   rl/trunk/engine/ui/src/CommandMapper.cpp
   rl/trunk/engine/ui/src/ConfigComponent.cpp
   rl/trunk/engine/ui/src/Console.cpp
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/ControlState.cpp
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/GameLoggerWindow.cpp
   rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
   rl/trunk/engine/ui/src/InGameMenuWindow.cpp
   rl/trunk/engine/ui/src/InfoPopup.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
   rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
   rl/trunk/engine/ui/src/JournalWindow.cpp
   rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
   rl/trunk/engine/ui/src/LogWindow.cpp
   rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp
   rl/trunk/engine/ui/src/MainMenuWindow.cpp
   rl/trunk/engine/ui/src/MessageWindow.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
   rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp
   rl/trunk/engine/ui/src/PlaylistWindow.cpp
   rl/trunk/engine/ui/src/ProgressWindow.cpp
   rl/trunk/engine/ui/src/PropertiesWindow.cpp
   rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp
   rl/trunk/engine/ui/src/SaveLoadWindow.cpp
   rl/trunk/engine/ui/src/SoundConfig.cpp
   rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp
   rl/trunk/engine/ui/src/SubtitleWindow.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
   rl/trunk/engine/ui/src/WindowFadeJob.cpp
   rl/trunk/engine/ui/src/WindowManager.cpp
   rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj
Log:
-Added precompiled header (stdinc.h and stdinc.cpp) to all sub projects.
-Needed to add -Zm130 in some projects to increase the maximum pch allocation limit

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -39,16 +39,18 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\"
-				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS;_DEBUG;WIN32;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS;_DEBUG;WIN32;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				SmallerTypeCheck="true"
 				RuntimeLibrary="3"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				ExpandAttributedSource="true"
 				AssemblerOutput="4"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
@@ -135,13 +137,15 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="true"
 				DebugInformationFormat="3"
@@ -219,13 +223,15 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\rules\include;..\dialog\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="true"
 				DebugInformationFormat="3"
@@ -345,6 +351,34 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\stdinc.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
 				RelativePath=".\src\SteeringVehicle.cpp"
 				>
 			</File>
@@ -435,6 +469,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\stdinc.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\SteeringMachine.h"
 				>
 			</File>

Added: rl/trunk/engine/ai/include/stdinc.h
===================================================================
--- rl/trunk/engine/ai/include/stdinc.h	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/include/stdinc.h	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,107 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+/*
+ * This file is used for precompiled header generation. You have to
+ * include it in all cpp files which have "Use Precompiled Header"
+ * set in their C/C++ properties. It shall never be included in other
+ * headers.
+ *
+ * The content of this file should be limited to the following include
+ * types:
+ *   - stdlib headers
+ *   - stl headers
+ *   - all types of external dependencies which will never be changed by us
+ *
+ * Every sub project should have it's own copy of this file and may have
+ * project specific modifications
+ */
+
+#ifndef __stdinc_h__
+#define __stdinc_h__
+
+#ifdef RL_USE_PCH
+
+#include <string>
+#include <vector>
+#include <list>
+#include <map>
+#include <set>
+
+#include <iostream>
+#include <sstream>
+
+#include <functional>
+#include <algorithm>
+#include <utility>
+
+#include <OgreCommon.h>
+#include <OgreConfigFile.h>
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreMath.h>
+#include <OgreVector3.h>
+#include <OgreSingleton.h>
+#include <OgreLog.h>
+#include <OgreLogManager.h>
+#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
+#include <OgreResource.h>
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
+#include <OgreUserDefinedObject.h>
+#include <OgreMovableObject.h>
+#include <OgreManualObject.h>
+#include <OgreNode.h>
+#include <OgreCamera.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <OgreLight.h>
+#include <OgreQuaternion.h>
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <OgreRenderable.h>
+#include <OgreParticleSystem.h>
+#include <OgreSceneQuery.h>
+#include <OgreSceneManager.h>
+#include <OgreSceneNode.h>
+#include <OgreAnimationState.h>
+#include <OgreRay.h>
+#include <OgreMeshManager.h>
+#include <OgreBillboardParticleRenderer.h>
+#include <OgreTextureManager.h>
+#include <OgreException.h>
+#include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
+
+#include <OgreNewt.h>
+#include <OgreNewt_ContactCallback.h>
+#include <OgreNewt_Collision.h>
+#include <OgreNewt_RayCast.h>
+
+#include <CEGUIString.h>
+#include <CEGUILogger.h>
+
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+#include <boost/any.hpp>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#  include <Windows.h>
+#endif
+
+#endif//RL_USE_PCH
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AStar.h"
 #include "AStarWayPointNode.h"
 #include "AStarHeuristic.h"
@@ -119,7 +121,7 @@
 }
 
 /*
-The A* algorithm, stripped of all the code, is fairly simple. 
+The A* algorithm, stripped of all the code, is fairly simple.
 There are two sets, OPEN and CLOSED. The OPEN set contains those nodes that are candidates for examining.
 Initially, the OPEN set contains just one element: the starting position.
 The CLOSED set contains those nodes that have already been examined.
@@ -129,7 +131,7 @@
 
 There is a main loop that repeatedly pulls out the best node n in OPEN
 (the node with the lowest f value) and examines it. If n is the goal, then we're done.
-Otherwise, node n is removed from OPEN and added to CLOSED. 
+Otherwise, node n is removed from OPEN and added to CLOSED.
 Then, its neighbors n' are examined. A neighbor that is in CLOSED has already
 been seen, so we don't need to look at it (*). A neighbor that is in OPEN is
 scheduled to be looked at, so we don't need to look at it now (*). Otherwise,
@@ -197,8 +199,8 @@
 
 			AStarSet::iterator ASit;
 			// now check if the node is already in Open
-			
-			if ( (ASit = searchSet(mOpen, ASubNode)) != mOpen.end() ) 
+
+			if ( (ASit = searchSet(mOpen, ASubNode)) != mOpen.end() )
 			{
 				AStarWayPointNode* ASfound = (*ASit);
 				// check if current g is better
@@ -212,9 +214,9 @@
 				}
 				// anyway the newly created node isn't needed
 				delete ASubNode;
-			
+
 			}  // now check if the node is already in Closed
-			else if ( (ASit = searchSet(mClosed, ASubNode)) != mClosed.end()) 
+			else if ( (ASit = searchSet(mClosed, ASubNode)) != mClosed.end())
 			{
 				AStarWayPointNode* ASfound = (*ASit);
 				// (check if current g is better, then reopen)
@@ -231,8 +233,8 @@
 				}
 				// anyway the newly created node isn't needed
 				delete ASubNode;
-			} 
-			else 
+			}
+			else
 			{
 				// neither in Open nor Closed, so add it to Open
 				mOpen.push_back( ASubNode );
@@ -248,10 +250,10 @@
 {
 	AStarSet::iterator it;
 
-    /* try binary search - but keep in mind this compares the F and not G&H values 
+    /* try binary search - but keep in mind this compares the F and not G&H values
      * so this is not going to work at the moment with the current sortMethod ...
      */
-    
+
     //AStarWayPointNode* help = NULL;
     //bool found = std::binary_search(Set.begin(), Set.end(), Node, AStarWayPointNode::SortMethod);
     //while (it != Set.end())
@@ -261,9 +263,9 @@
         // otherwise continue binary search
         //it = std::binary_search(it, Set.end(), Node, AStarWayPointNode::SortMethod);
     //}
-    
-    
-	for (it = Set.begin(); it != Set.end(); it++) 
+
+
+	for (it = Set.begin(); it != Set.end(); it++)
 	{
         if ( (*it)->EqualPosition(Node) )
 			return it;
@@ -288,7 +290,7 @@
 
     Ogre::Vector3 From;
     Ogre::Vector3 To;
-    for (it++ ; it != searchPath.end(); it++) 
+    for (it++ ; it != searchPath.end(); it++)
     {
         pit = it - 1;
         From = (*pit) + Ogre::Vector3(0,0.5,0);

Modified: rl/trunk/engine/ai/src/AStarCosts.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarCosts.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AStarCosts.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AStarCosts.h"
 #include "AStarWayPointNode.h"
 #include "WayPointNode.h"
@@ -29,7 +31,7 @@
 {
 }
 
-float AStarCosts::calcHeuristic(const WayPointGraph* WPGraph, 
+float AStarCosts::calcHeuristic(const WayPointGraph* WPGraph,
                                 const AStarWayPointNode* wp1,
                                 const AStarWayPointNode* wp2) const
 {

Modified: rl/trunk/engine/ai/src/AStarHeuristic.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AStarHeuristic.h"
 #include "AStarWayPointNode.h"
 #include "WayPointNode.h"

Modified: rl/trunk/engine/ai/src/AStarNodePool.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AStarNodePool.h"
 #include "AStarWayPointNode.h"
 
@@ -48,7 +50,7 @@
 	AStarNodeList::iterator it;
 	for (it = mUsed.begin(); it != mUsed.end(); it++)
 	{
-		if ( (*it) == Node ) 
+		if ( (*it) == Node )
 		{
 			mUsed.erase(it);
 			mFree.push_back(Node);
@@ -61,7 +63,7 @@
 	AStarNodeList::iterator it;
 	for (it = mUsed.begin(); it != mUsed.end(); it++)
 	{
-		if ( (*it) == Node ) 
+		if ( (*it) == Node )
 		{
 			mUsed.erase(it);
 			delete Node;
@@ -72,7 +74,7 @@
 AStarWayPointNode* AStarNodePool::createAStarWayPointNode(const WayPointNode* WP)
 {
 	AStarWayPointNode* Node;
-	
+
 	if ( mFree.empty())
 		Node = new AStarWayPointNode(WP);
 	else

Modified: rl/trunk/engine/ai/src/AStarWayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AStarWayPointNode.h"
 
 namespace rl {

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "Agent.h"
 
 #include "Actor.h"
@@ -41,7 +43,7 @@
 Agent::Agent(Creature* character, SteeringVehicle* vehicle)
 	: mType(AgentManager::AGENT_NONE),
       mBehaviour(NULL),
-      mVehicle(vehicle), 
+      mVehicle(vehicle),
 	  mCreature(character)
 {
 	initialize();
@@ -69,11 +71,11 @@
 		mType = AgentManager::AGENT_STD_NPC;
 		mVehicle = new SteeringVehicle(this, mCreature);
 	}
-    LOG_MESSAGE(Logger::AI, 
+    LOG_MESSAGE(Logger::AI,
         "created SteeringVehicle for Agent");
-    
+
 	mBehaviour = new SteeringMachine(NULL, mVehicle);
-    LOG_MESSAGE(Logger::AI, 
+    LOG_MESSAGE(Logger::AI,
         "created SteeringMachine for Agent");
 }
 
@@ -82,14 +84,14 @@
     behaviour->setParent(mBehaviour);
     behaviour->setController(mVehicle);
     mBehaviour->addState(behaviour);
-    LOG_MESSAGE(Logger::AI, 
+    LOG_MESSAGE(Logger::AI,
         "added SteeringBehaviour for Agent");
 }
 
 void Agent::clearSteeringBehaviours()
 {
     mBehaviour->clearStates();
-    LOG_MESSAGE(Logger::AI, 
+    LOG_MESSAGE(Logger::AI,
         "Cleared all SteeringBehaviours for Agent");
 }
 

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AgentManager.h"
 #include "Agent.h"
 #include "PlayerVehicle.h"
@@ -80,7 +82,7 @@
 void AgentManager::addAgent(Agent* agent)
 {
 	mAgents.push_back(agent);
-    LOG_MESSAGE(Logger::AI, 
+    LOG_MESSAGE(Logger::AI,
         "created AI Agent");
 	mAllNeighbors.push_back(agent->getVehicle());
 }
@@ -90,7 +92,7 @@
 	return mAllNeighbors;
 }
 
-void AgentManager::run( Ogre::Real elapsedTime ) 
+void AgentManager::run( Ogre::Real elapsedTime )
 {
     //	update agents
     for(AgentList::iterator itr = mAgents.begin(); itr != mAgents.end(); ++itr)

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AiSubsystem.h"
 
 #include "AiWorld.h"
@@ -138,7 +140,7 @@
 
 void AiSubsystem::removeAllLandmarkPaths()
 {
-	for (std::map<Ogre::String, LandmarkPath*>::iterator it = mLandmarkPaths.begin(); 
+	for (std::map<Ogre::String, LandmarkPath*>::iterator it = mLandmarkPaths.begin();
 		it != mLandmarkPaths.end(); it++)
 	{
 		delete (*it).second;
@@ -149,7 +151,7 @@
 
 void AiSubsystem::removeAllLandmarks()
 {
-	for (std::map<Ogre::String, Landmark*>::iterator it = mLandmarks.begin(); 
+	for (std::map<Ogre::String, Landmark*>::iterator it = mLandmarks.begin();
 		it != mLandmarks.end(); it++)
 	{
 		delete (*it).second;

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AiWorld.h"
 #include "PhysicsManager.h"
 #include "LineSetPrimitive.h"
@@ -56,7 +58,7 @@
 
 void AiWorld::addObstacle(Obstacle* obstacle)
 {
-	mObstacles.push_back(obstacle);	
+	mObstacles.push_back(obstacle);
 }
 
 const ObstacleGroup& AiWorld::getSteeringObstacles()
@@ -216,7 +218,7 @@
         pi.surfaceNormal = Vec3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);
 /*        pi.surfaceNormal.normalize();
         // jedenfalls gilt dafuer, dass der abstand zwischen surfacePoint+surfaceNormal und _pos minimal sein muss
-        if( ((pi.surfacePoint + pi.surfaceNormal) - _pos).length() > 
+        if( ((pi.surfacePoint + pi.surfaceNormal) - _pos).length() >
             ((pi.surfacePoint - pi.surfaceNormal) - _pos).length() )
             pi.surfaceNormal = -pi.surfaceNormal;
 */        pi.vehicleOutside = true; // egal?
@@ -239,7 +241,7 @@
 {
     if( mSceneNode->getParent() == NULL )
     {
-        SceneManager* mgr = 
+        SceneManager* mgr =
             CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager();
         mgr->getRootSceneNode()->addChild(mSceneNode);
     }

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Perl Artistic License.
 *
@@ -13,12 +13,14 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
+#include "stdinc.h" //precompiled header
 
+
 #include "CreatureWalkPathJob.h"
 
 namespace rl
 {
-    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, CreatureController* movingCreature, Landmark* startLandmark) 
+    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String& name, CreatureController* movingCreature, Landmark* startLandmark)
         : Job(true, true), mLandmarkPath("LandmarkPath" + name), mNextLandmarkRequested(false)
     {
         //the moving creature moves from the current position to the landmark
@@ -91,7 +93,7 @@
         Ogre::Quaternion rotation = creatureViewVector.getRotationTo(direction, Ogre::Vector3::UNIT_Y);
         Ogre::Radian yaw = rotation.getYaw();
         Ogre::Vector3 usedRotation(Ogre::Vector3::ZERO);
-        
+
         if(!updatedDirection || (direction.squaredLength() > 0.04 && timeSinceLastRotation > 1 &&
             direction.normalisedCopy().dotProduct(creatureViewVector.normalisedCopy()) < 0.9))
         {

Modified: rl/trunk/engine/ai/src/FuzzyState.cpp
===================================================================
--- rl/trunk/engine/ai/src/FuzzyState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/FuzzyState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,4 +1,7 @@
 
+#include "stdinc.h" //precompiled header
+
+
 #include "FuzzyState.h"
 /*
 FuzzyState::FuzzyState(void)

Modified: rl/trunk/engine/ai/src/FuzzyStateMachine.cpp
===================================================================
--- rl/trunk/engine/ai/src/FuzzyStateMachine.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/FuzzyStateMachine.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,4 +1,6 @@
 
+#include "stdinc.h" //precompiled header
+
 #include "FuzzyStateMachine.h"
 /*
 FuzzyStateMachine::FuzzyStateMachine(void)

Modified: rl/trunk/engine/ai/src/Landmark.cpp
===================================================================
--- rl/trunk/engine/ai/src/Landmark.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/Landmark.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "Landmark.h"
 
 namespace rl

Modified: rl/trunk/engine/ai/src/LandmarkPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/LandmarkPath.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "LandmarkPath.h"
 
 #include "AiSubsystem.h"

Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,14 +13,15 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
- 
- #include "PhysicalObstacle.h"
- #include "PhysicalThing.h"
- #include "Exception.h"
- #include <OpenSteer/Obstacle.h>
- #include <OgreNewt_Body.h>
- #include <OgreNewt_Collision.h>
- 
+#include "stdinc.h" //precompiled header
+
+#include "PhysicalObstacle.h"
+#include "PhysicalThing.h"
+#include "Exception.h"
+#include <OpenSteer/Obstacle.h>
+#include <OgreNewt_Body.h>
+#include <OgreNewt_Collision.h>
+
 using namespace Ogre;
 
 namespace rl {
@@ -30,33 +31,33 @@
     {
         _update();
     }
-     
+
     PhysicalObstacle::~PhysicalObstacle()
     {
     }
-     
+
     OpenSteer::Obstacle *PhysicalObstacle::getObstacle() const
     {
         return mObstacle;
     }
-     
+
     void PhysicalObstacle::setObstacle(OpenSteer::Obstacle *obstacle)
     {
         mObstacle = obstacle; // TODO Need update?
     }
-    
+
     PhysicalThing *PhysicalObstacle::getPhysicalThing() const
     {
         return mPhysicalThing;
     }
-    
+
     void PhysicalObstacle::setPhysicalThing(PhysicalThing *thing)
     {
         mPhysicalThing = thing;
         mObstacle = NULL;	// question: shouldn't we check before doing this ?
         _update();
     }
-    
+
     void PhysicalObstacle::_update()
     {
     	OgreNewt::Body *body = mPhysicalThing->_getBody();

Modified: rl/trunk/engine/ai/src/PlayerVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "PlayerVehicle.h"
 #include "Actor.h"
 #include "Creature.h"

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,9 +13,11 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "SteeringVehicle.h"
 #include "AiSubsystem.h"
-#include "AiWorld.h" 
+#include "AiWorld.h"
 #include "Agent.h"
 #include "Actor.h"
 #include "Creature.h"
@@ -32,7 +34,7 @@
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
       mSpeed(1.0f),
-	  mCurrentForce(Vector3::ZERO), 
+	  mCurrentForce(Vector3::ZERO),
 	  mCurrentVelocity(Vector3::ZERO),
 	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
 	  mParent(parent),
@@ -84,7 +86,7 @@
 {
     // reset LocalSpace state
 	resetLocalSpace();
-	
+
     // reset SteerLibraryMixin state
 	SimpleVehicle_2::reset ();
 
@@ -134,8 +136,8 @@
         mCurrentForce = Vector3::ZERO;
         return;
     }
-    
-// calculate the result of the force    
+
+// calculate the result of the force
     Vector3 result = mCurrentForce;// + mCurrentVelocity;
 
      mDebugSteer = mCurrentForce;
@@ -181,7 +183,7 @@
 Vector3 SteeringVehicle::calcWander(const float elapsedTime)
 {
 	Vec3 rVal(mForwardVector.x, mForwardVector.y, mForwardVector.z);
-	
+
     rVal += steerForWander(elapsedTime/12.0f).setYtoZero();
 
     Vector3 steering(rVal.x, rVal.y, rVal.z);
@@ -224,7 +226,7 @@
 	Vec3 rVal = steerToAvoidNeighbors(minTimeToCollision, getNeighbors()).setYtoZero();
 	return Vector3(rVal.x, rVal.y, rVal.z);
 }
-		
+
 Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
 {
 	return Vector3();
@@ -273,75 +275,75 @@
 	return Vector3(position().x, position().y, position().z);
 }
 
-float SteeringVehicle::mass (void) const 
+float SteeringVehicle::mass (void) const
 {
     return mCreature->getActor()->getPhysicalThing()->getMass();
 }
 
-float SteeringVehicle::setMass (float m) 
+float SteeringVehicle::setMass (float m)
 {
 	// don't set mass here TODO: throw exception
 
 	return 1;
-} 
+}
 
-float SteeringVehicle::speed (void) const 
+float SteeringVehicle::speed (void) const
 {
 	return mSpeed;
 }
 
-float SteeringVehicle::setSpeed (float s) 
+float SteeringVehicle::setSpeed (float s)
 {
 	return mSpeed = s;
 }
 
-float SteeringVehicle::radius (void) const 
+float SteeringVehicle::radius (void) const
 {
 	// this is only the radius in x axis, but i think, this is the value that should be used here
     Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
     return (aab.getMaximum().x - aab.getMinimum().x)/2;
 }
 
-float SteeringVehicle::setRadius (float m) 
+float SteeringVehicle::setRadius (float m)
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-float SteeringVehicle::height (void) const 
+float SteeringVehicle::height (void) const
 {
     Ogre::AxisAlignedBox aab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
     return aab.getMaximum().y - aab.getMinimum().y;
 }
 
-float SteeringVehicle::setHeight (float h) 
+float SteeringVehicle::setHeight (float h)
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-const Actor* SteeringVehicle::getActor(void) const  
-{ 
-	return mCreature->getActor(); 
+const Actor* SteeringVehicle::getActor(void) const
+{
+	return mCreature->getActor();
 }
 
-float SteeringVehicle::maxForce (void) const 
+float SteeringVehicle::maxForce (void) const
 {
 	return 10000.0f;
-} 
+}
 
-float SteeringVehicle::setMaxForce (float mf) 
+float SteeringVehicle::setMaxForce (float mf)
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxForce = mf;
 }
 
-float SteeringVehicle::maxSpeed (void) const 
+float SteeringVehicle::maxSpeed (void) const
 {
-	return 100000; 
+	return 100000;
 }
 
-float SteeringVehicle::setMaxSpeed (float ms) 
+float SteeringVehicle::setMaxSpeed (float ms)
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxSpeed = ms;
@@ -394,7 +396,7 @@
 
     LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
     lineSet->clear();
-    
+
     if(mDebugSteer != Vector3::ZERO)
     {
         lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "WayPointGraph.h"
 #include "WayPointNode.h"
 #include <algorithm>
@@ -56,7 +58,7 @@
 {
 	WayPointNodeList::iterator it;
 
-	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
 	{
 		// equal to some waypoint already added ...
 		if ( (*it)->getPosition() == position )
@@ -64,7 +66,7 @@
 	}
 
 	return rawAddWayPoint(position, type);
-	
+
 }
 
 WayPointNode* WayPointGraph::rawAddWayPoint(const Ogre::Vector3& position, const WayPointNode::WayPointNodeType type)
@@ -92,16 +94,16 @@
 void WayPointGraph::load (const Ogre::String& filename)
 {
 	// fetch modules directory
-	Ogre::String modulespath( 
+	Ogre::String modulespath(
 		ConfigurationManager::getSingleton().getModulesRootDirectory());
 	Ogre::String fullfilename(modulespath + "/" + filename);
-	
+
 	// check if the file exists
 	if (! boost::filesystem::exists(boost::filesystem::path(fullfilename)) )
 		Throw(FileNotFoundException, fullfilename);
 
 	std::ifstream input(fullfilename.c_str(), ios::binary);
-	
+
 	if (input.fail())
 		Throw(Error, filename+": couldn't open");
 	if (input.eof())
@@ -128,7 +130,7 @@
 	Ogre::Vector3 Position;
 	WayPointNode::WayPointNodeType type;
 	unsigned int count = 0;
-	while (!input.eof() && count < numberOfNodes) 
+	while (!input.eof() && count < numberOfNodes)
 	{
 		input.read((char *) &Position, sizeof(Position));
 		if (input.eof())
@@ -153,7 +155,7 @@
 
 	// read in the connections
 	count=0;
-	while (!input.eof() && count < numberOfNodes) 
+	while (!input.eof() && count < numberOfNodes)
 	{
 		input.read((char *) &nrOfConnections, sizeof(nrOfConnections));
 		if (input.eof())
@@ -168,7 +170,7 @@
 		count++;
 		input.getline(line, sizeof(line));
 	}
-	if (count != numberOfNodes) 
+	if (count != numberOfNodes)
 		Throw(Error, filename+": couldn't read expeced number of connections");
 
 	input.close();
@@ -180,9 +182,9 @@
 	unsigned int count;
 	WayPointNodeList::const_iterator it;
 	std::map<const WayPointNode*, unsigned int> IndexList;
-	
+
 	// fetch modules directory
-	Ogre::String modulespath( 
+	Ogre::String modulespath(
 		ConfigurationManager::getSingleton().getModulesRootDirectory());
 	Ogre::String fullfilename(modulespath + "/" + filename);
 
@@ -203,7 +205,7 @@
 	count = 0;
 	Ogre::Vector3 Position;
 	WayPointNode::WayPointNodeType type;
-	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
 	{
 		// write waypoint to file
 		Position = (*it)->getPosition();
@@ -219,16 +221,16 @@
 
 	// save the index-index pairs for the connections between the nodes
 	count = 0;
-	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
 	{
 		const WayPointNode::WayPointWeightNodeList subnodes = (*it)->getNeighbours();
 		WayPointNode::WayPointWeightNodeList::size_type subnodessize = subnodes.size();
 		WayPointNode::WayPointWeightNodeList::const_iterator nit;
 		std::map<const WayPointNode*, unsigned int>::iterator itIndex;
-		
+
 		output.write((char *) &(subnodessize), sizeof(subnodessize));
 		// iteratte through the neighbours
-		for (nit = subnodes.begin(); nit != subnodes.end(); nit++) 
+		for (nit = subnodes.begin(); nit != subnodes.end(); nit++)
 		{
 			itIndex = IndexList.find( (*nit).second );
 			output.write((char *) &((*itIndex).second), sizeof((*itIndex).second));
@@ -257,13 +259,13 @@
 	nearestVec = position - (*it)->getPosition();
 	nearestDistance = nearestVec.length();
 	nearestWayPoint = (*it);
-	
+
 	// search the full list for points that are nearer
-	for (it = mNodeList.begin(); it != mNodeList.end(); it++) 
+	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
 	{
 		// calculate distance
 		nearestVec = position - (*it)->getPosition();
-		
+
 		// test if distance is smaller than the smallest seen until now
 		if ( nearestDistance > nearestVec.length() )
 		{
@@ -328,7 +330,7 @@
 		const WayPointNode::WayPointWeightNodeList subnodes = (*it)->getNeighbours();
 		WayPointNode::WayPointWeightNodeList::const_iterator nit;
 
-		for (nit = subnodes.begin(); nit != subnodes.end(); nit++) 
+		for (nit = subnodes.begin(); nit != subnodes.end(); nit++)
 		{
 			/*bool found = false;
 			while ( (edgeListIt = edgeList.find( (*nit).second )) != edgeList.end() )

Modified: rl/trunk/engine/ai/src/WayPointGraphManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/WayPointGraphManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "WayPointNode.h"
 #include "WayPointGraph.h"
 #include "WayPointGraphManager.h"

Modified: rl/trunk/engine/ai/src/WayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointNode.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/WayPointNode.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "WayPointNode.h"
 
 using namespace std;
@@ -30,16 +32,16 @@
 	mNeighbours.clear();
 }
 
-void WayPointNode::addNeighbour(const WayPointNode* neighbour) 
+void WayPointNode::addNeighbour(const WayPointNode* neighbour)
 {
 	WayPointWeightNodeList::iterator it;
 
 	// test if neighbour not already added
 	for (it = mNeighbours.begin(); it != mNeighbours.end(); it++) {
 		// already added
-		if ( (*it).second == neighbour ) 
+		if ( (*it).second == neighbour )
 			return;
-		
+
 	}
 
 	// calculate cost to neighbour

Added: rl/trunk/engine/ai/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/ai/src/stdinc.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ai/src/stdinc.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,17 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+#include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/common/RlCommon2005.vcproj
===================================================================
--- rl/trunk/engine/common/RlCommon2005.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/RlCommon2005.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -40,15 +40,17 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\boost\include"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_USRDLL;RLCOMMON_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_USRDLL;RLCOMMON_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				SmallerTypeCheck="true"
 				RuntimeLibrary="3"
 				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
 				ObjectFile=".\obj\$(ConfigurationName)/"
 				GenerateXMLDocumentationFiles="false"
@@ -131,10 +133,12 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				AdditionalIncludeDirectories=".\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\boost\include"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLCOMMON_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLCOMMON_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
 				ObjectFile=".\obj\$(ConfigurationName)/"
 				GenerateXMLDocumentationFiles="false"
@@ -215,10 +219,12 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				AdditionalIncludeDirectories=".\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\boost\include"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLCOMMON_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLCOMMON_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
 				ObjectFile=".\obj\$(ConfigurationName)/"
 				GenerateXMLDocumentationFiles="false"
@@ -291,6 +297,14 @@
 			<File
 				RelativePath=".\src\EventObject.cpp"
 				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
 			</File>
 			<File
 				RelativePath=".\src\EventSource.cpp"
@@ -329,6 +343,34 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\stdinc.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
 				RelativePath=".\src\XmlErrorHandler.cpp"
 				>
 			</File>
@@ -429,6 +471,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\stdinc.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Tripel.h"
 				>
 			</File>

Added: rl/trunk/engine/common/include/stdinc.h
===================================================================
--- rl/trunk/engine/common/include/stdinc.h	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/include/stdinc.h	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,103 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+/*
+ * This file is used for precompiled header generation. You have to
+ * include it in all cpp files which have "Use Precompiled Header"
+ * set in their C/C++ properties. It shall never be included in other
+ * headers.
+ *
+ * The content of this file should be limited to the following include
+ * types:
+ *   - stdlib headers
+ *   - stl headers
+ *   - all types of external dependencies which will never be changed by us
+ *
+ * Every sub project should have it's own copy of this file and may have
+ * project specific modifications
+ */
+
+#ifndef __stdinc_h__
+#define __stdinc_h__
+
+#ifdef RL_USE_PCH
+
+#include <string>
+#include <vector>
+#include <list>
+#include <map>
+#include <set>
+
+#include <iostream>
+#include <sstream>
+
+#include <functional>
+#include <algorithm>
+#include <utility>
+
+#include <OgreCommon.h>
+#include <OgreConfigFile.h>
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreMath.h>
+#include <OgreVector3.h>
+#include <OgreSingleton.h>
+#include <OgreLog.h>
+#include <OgreLogManager.h>
+#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
+#include <OgreResource.h>
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
+#include <OgreUserDefinedObject.h>
+#include <OgreMovableObject.h>
+#include <OgreManualObject.h>
+#include <OgreNode.h>
+#include <OgreCamera.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <OgreLight.h>
+#include <OgreQuaternion.h>
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <OgreRenderable.h>
+#include <OgreParticleSystem.h>
+#include <OgreSceneQuery.h>
+#include <OgreSceneManager.h>
+#include <OgreSceneNode.h>
+#include <OgreAnimationState.h>
+#include <OgreRay.h>
+#include <OgreMeshManager.h>
+#include <OgreBillboardParticleRenderer.h>
+#include <OgreTextureManager.h>
+#include <OgreException.h>
+#include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
+
+#include <CEGUIString.h>
+#include <CEGUILogger.h>
+
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+#include <boost/any.hpp>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#  include <Windows.h>
+#endif
+
+#endif //RL_USE_PCH
+#endif
+

Modified: rl/trunk/engine/common/src/ConfigFile.cpp
===================================================================
--- rl/trunk/engine/common/src/ConfigFile.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/ConfigFile.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "ConfigFile.h"
 #include "Exception.h"
 

Modified: rl/trunk/engine/common/src/EventObject.cpp
===================================================================
--- rl/trunk/engine/common/src/EventObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/EventObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "EventObject.h"
 
 namespace rl {

Modified: rl/trunk/engine/common/src/EventSource.cpp
===================================================================
--- rl/trunk/engine/common/src/EventSource.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/EventSource.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+
+#include "stdinc.h" //precompiled header
 
 #include "EventSource.h"
 

Modified: rl/trunk/engine/common/src/GameTask.cpp
===================================================================
--- rl/trunk/engine/common/src/GameTask.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/GameTask.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "GameTask.h"
 
 namespace rl {

Modified: rl/trunk/engine/common/src/Logger.cpp
===================================================================
--- rl/trunk/engine/common/src/Logger.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/Logger.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "Logger.h"
 
 #include <OgreLogManager.h>

Modified: rl/trunk/engine/common/src/MathUtil.cpp
===================================================================
--- rl/trunk/engine/common/src/MathUtil.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/MathUtil.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "MathUtil.h"
 
 #include <OgreMath.h>

Modified: rl/trunk/engine/common/src/OgreXercesInput.cpp
===================================================================
--- rl/trunk/engine/common/src/OgreXercesInput.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/OgreXercesInput.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "OgreXercesInput.h"
 #include "XmlErrorHandler.h"
 

Modified: rl/trunk/engine/common/src/Properties.cpp
===================================================================
--- rl/trunk/engine/common/src/Properties.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/Properties.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.perldoc.com/perl5.6/Artistic.html
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "Properties.h"
 
 #include "Exception.h"

Modified: rl/trunk/engine/common/src/Property.cpp
===================================================================
--- rl/trunk/engine/common/src/Property.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/Property.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.perldoc.com/perl5.6/Artistic.html
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "Property.h"
 
 #include "Exception.h"

Modified: rl/trunk/engine/common/src/PropertyReader.cpp
===================================================================
--- rl/trunk/engine/common/src/PropertyReader.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/PropertyReader.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,9 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+
+#include "stdinc.h" //precompiled header
+
 #include <xercesc/dom/DOM.hpp>
 #include <xercesc/parsers/XercesDOMParser.hpp>
 #include <xercesc/util/XMLString.hpp>

Modified: rl/trunk/engine/common/src/ScriptWrapper.cpp
===================================================================
--- rl/trunk/engine/common/src/ScriptWrapper.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/ScriptWrapper.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "ScriptWrapper.h"
 
 using namespace Ogre;

Modified: rl/trunk/engine/common/src/XmlErrorHandler.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlErrorHandler.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/XmlErrorHandler.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,9 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+
+#include "stdinc.h" //precompiled header
+
 #include <sstream>
 #include <xercesc/sax/SAXParseException.hpp>
 #include "XmlErrorHandler.h"

Modified: rl/trunk/engine/common/src/XmlHelper.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlHelper.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/XmlHelper.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include <xercesc/dom/DOM.hpp>
 
 #include "XmlHelper.h"

Modified: rl/trunk/engine/common/src/XmlResource.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlResource.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/XmlResource.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "XmlResource.h"
 #include "XmlResourceManager.h"
 #include "XmlHelper.h"

Modified: rl/trunk/engine/common/src/XmlResourceManager.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlResourceManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/XmlResourceManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+#include "stdinc.h" //precompiled header
+
 #include "XmlResourceManager.h"
 
 using namespace Ogre;

Added: rl/trunk/engine/common/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/common/src/stdinc.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/common/src/stdinc.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,17 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+#include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -46,9 +46,10 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include"
-				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				SmallerTypeCheck="true"
@@ -56,7 +57,9 @@
 				BufferSecurityCheck="false"
 				EnableFunctionLevelLinking="false"
 				RuntimeTypeInfo="true"
-				PrecompiledHeaderFile=".\obj\Debug/Rastullah.pch"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
+				PrecompiledHeaderFile="$(IntDir)\$(TargetName).pch"
 				ExpandAttributedSource="false"
 				AssemblerOutput="0"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
@@ -156,18 +159,20 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include"
-				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\obj\Release/Rastullah.pch"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
+				PrecompiledHeaderFile="$(IntDir)\$(TargetName).pch"
 				ExpandAttributedSource="false"
 				AssemblerOutput="0"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
@@ -261,18 +266,20 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;.\include\nulldriver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include"
-				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\obj\Release/Rastullah.pch"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
+				PrecompiledHeaderFile="$(IntDir)\$(TargetName).pch"
 				ExpandAttributedSource="false"
 				AssemblerOutput="0"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
@@ -581,6 +588,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\stdinc.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\TrackAnimation.h"
 				>
 			</File>
@@ -834,6 +845,34 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\stdinc.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
 				RelativePath=".\src\TrackAnimation.cpp"
 				>
 			</File>

Added: rl/trunk/engine/core/include/stdinc.h
===================================================================
--- rl/trunk/engine/core/include/stdinc.h	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/include/stdinc.h	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,108 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+/*
+ * This file is used for precompiled header generation. You have to
+ * include it in all cpp files which have "Use Precompiled Header"
+ * set in their C/C++ properties. It shall never be included in other
+ * headers.
+ *
+ * The content of this file should be limited to the following include
+ * types:
+ *   - stdlib headers
+ *   - stl headers
+ *   - all types of external dependencies which will never be changed by us
+ *
+ * Every sub project should have it's own copy of this file and may have
+ * project specific modifications
+ */
+
+#ifndef __stdinc_h__
+#define __stdinc_h__
+
+#ifdef RL_USE_PCH
+
+#include <string>
+#include <vector>
+#include <list>
+#include <map>
+#include <set>
+
+#include <iostream>
+#include <sstream>
+
+#include <functional>
+#include <algorithm>
+#include <utility>
+
+#include <OgreCommon.h>
+#include <OgreConfigFile.h>
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreMath.h>
+#include <OgreVector3.h>
+#include <OgreSingleton.h>
+#include <OgreLog.h>
+#include <OgreLogManager.h>
+#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
+#include <OgreResource.h>
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
+#include <OgreUserDefinedObject.h>
+#include <OgreMovableObject.h>
+#include <OgreManualObject.h>
+#include <OgreNode.h>
+#include <OgreCamera.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <OgreLight.h>
+#include <OgreQuaternion.h>
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <OgreRenderable.h>
+#include <OgreParticleSystem.h>
+#include <OgreSceneQuery.h>
+#include <OgreSceneManager.h>
+#include <OgreSceneNode.h>
+#include <OgreAnimationState.h>
+#include <OgreRay.h>
+#include <OgreMeshManager.h>
+#include <OgreBillboardParticleRenderer.h>
+#include <OgreEnvironment.h>
+#include <OgreTextureManager.h>
+#include <OgreException.h>
+#include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
+
+#include <OgreNewt.h>
+#include <OgreNewt_ContactCallback.h>
+#include <OgreNewt_Collision.h>
+#include <OgreNewt_RayCast.h>
+
+#include <CEGUIString.h>
+#include <CEGUILogger.h>
+
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+#include <boost/any.hpp>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#  include <Windows.h>
+#endif
+
+#endif//RL_USE_PCH
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/Actor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "Actor.h"
 
@@ -76,7 +77,7 @@
         }
         else
         {
-            mParent->detach( this );  
+            mParent->detach( this );
         }
 
         if (mActorControlledObject != NULL)
@@ -110,7 +111,7 @@
         return mPhysicalThing;
     }
 
-    void Actor::setPhysicalThing( PhysicalThing* pt ) 
+    void Actor::setPhysicalThing( PhysicalThing* pt )
     {
         mPhysicalThing = pt;
     }
@@ -139,13 +140,13 @@
         return mActorControlledObject;
     }
 
-    void Actor::setControlledObject( ActorControlledObject* act ) 
+    void Actor::setControlledObject( ActorControlledObject* act )
     {
         if( act->getActor() != NULL )
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
             "Aktor "+mName+": Das anzuf?gende Objekt ist bereits an einem Aktor befestigt.");
         if( this->getControlledObject() != NULL )
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
             "Aktor "+mName+": Es ist bereits ein Objekt an diesem Aktor befestigt.");
 
         mActorControlledObject = act;
@@ -186,7 +187,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
         _update();
@@ -200,7 +201,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
         _update();
@@ -219,7 +220,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
         _update();
@@ -233,7 +234,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
         _update();
@@ -247,7 +248,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
         _update();
@@ -261,7 +262,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
         _update();
@@ -275,7 +276,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
         _update();
@@ -293,7 +294,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
     }
@@ -310,7 +311,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
     }
@@ -327,7 +328,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
     }
@@ -344,7 +345,7 @@
         }
         else
         {
-            Throw(IllegalStateException, 
+            Throw(IllegalStateException,
                 "Aktor "+mName+": Der Aktor ist nicht in der Szene befestigt.");
         }
     }
@@ -374,7 +375,7 @@
     }
 
     void Actor::placeIntoScene(
-        Real px, Real py, Real pz, 
+        Real px, Real py, Real pz,
         Real ow, Real ox, Real oy, Real oz ,
         const Ogre::String& physicsBone)
     {
@@ -384,16 +385,16 @@
     void Actor::placeIntoScene( const Vector3& position, const Quaternion& orientation ,
         const Ogre::String& physicsBone)
     {
-        SceneManager* mgr = 
+        SceneManager* mgr =
             CoreSubsystem::getSingletonPtr()->getWorld()->getSceneManager();
         placeIntoNode( mgr->getRootSceneNode(), position, orientation, physicsBone );
-    }        
+    }
 
-    void Actor::placeIntoNode( 
+    void Actor::placeIntoNode(
         Ogre::SceneNode* parent, const Vector3& position, const Quaternion& orientation,
         const Ogre::String& physicsBone )
     {
-        doPlaceIntoScene(parent,position,orientation, physicsBone);		
+        doPlaceIntoScene(parent,position,orientation, physicsBone);
     }
 
 
@@ -409,8 +410,8 @@
 				mPhysicalThing);
 		}
 
-        if( mActorControlledObject 
-			&& mSceneNode 
+        if( mActorControlledObject
+			&& mSceneNode
 			&& mActorControlledObject->getMovableObject())
         {
             mSceneNode->detachObject(
@@ -438,15 +439,15 @@
 
             // Wir brauchen den Node nicht mehr
             if( !childsInNode )
-            {                
+            {
                 CoreSubsystem::getSingleton().getWorld()->
                     getSceneManager()->destroySceneNode( mSceneNode->getName() );
                 mSceneNode = NULL;
-            }            
+            }
         }
     }
 
-    void Actor::attachToSlot( 
+    void Actor::attachToSlot(
         Actor* actor,
         const Ogre::String& slot,
         const Ogre::String& childSlot,
@@ -460,60 +461,60 @@
         mChildren.insert(actor);
     }
 
-    void Actor::attachToSlotAxisRot( 
+    void Actor::attachToSlotAxisRot(
         Actor* actor,
         const Ogre::String& slot,
-        const Ogre::String& childSlot,            
+        const Ogre::String& childSlot,
         const Ogre::Vector3& offsetPosition,
         const Ogre::Vector3& offsetAxis,
         const Ogre::Radian& offsetRotation )
     {
-        attachToSlot( actor, slot, childSlot, 
+        attachToSlot( actor, slot, childSlot,
             offsetPosition, Quaternion(offsetRotation,offsetAxis) );
     }
 
-    void Actor::attach( 
+    void Actor::attach(
         Actor* actor,
         const Ogre::String& childSlot,
         const Ogre::Vector3& offsetPosition,
         const Ogre::Quaternion& offsetOrientation
         )
     {
-        attachToSlot( actor, DEFAULT_SLOT_NAME, childSlot, 
+        attachToSlot( actor, DEFAULT_SLOT_NAME, childSlot,
             offsetPosition, offsetOrientation );
     }
 
-    void Actor::attachAxisRot( 
+    void Actor::attachAxisRot(
         Actor* actor,
-        const Ogre::String& childSlot,            
+        const Ogre::String& childSlot,
         const Ogre::Vector3& offsetPosition,
         const Ogre::Vector3& offsetAxis,
         const Ogre::Radian& offsetRotation)
     {
-        attachToSlot( actor, DEFAULT_SLOT_NAME, childSlot, 
+        attachToSlot( actor, DEFAULT_SLOT_NAME, childSlot,
             offsetPosition, Quaternion(offsetRotation,offsetAxis) );
     }
 
     void Actor::doAttach(
         Actor* actor,
-        const Ogre::String& slot, 
-        const Ogre::String& childSlot, 
+        const Ogre::String& slot,
+        const Ogre::String& childSlot,
         const Ogre::Vector3& offsetPosition,
-        const Ogre::Quaternion& offsetOrientation ) 
+        const Ogre::Quaternion& offsetOrientation )
     {
         Ogre::Vector3 offsetPositionMod = offsetPosition;
         Ogre::Quaternion offsetOrientationMod = offsetOrientation;
 
         if( actor == NULL )
-            Throw(NullPointerException, 
+            Throw(NullPointerException,
             "Aktor "+mName+": Der anzuf?gende Aktor darf nicht NULL sein." );
         if( actor->mParent != NULL )
-            Throw(NullPointerException, 
+            Throw(NullPointerException,
             "Aktor "+mName+": Der Aktor ist bereits an einen anderen Aktor angef?gt." );
 
         // Verschiebung durch den Child-Slot berechnen
         // Kontrolliert der Aktor ein Objekt && Ist dieses ein Mesh
-        if( actor->getControlledObject() != NULL && 
+        if( actor->getControlledObject() != NULL &&
             actor->getControlledObject()->isMeshObject() )
         {
             Entity* ent = dynamic_cast<MeshObject*>(actor->getControlledObject())->getEntity();
@@ -526,13 +527,13 @@
 				if (!useDefaultBone)
 				{
 					LOG_ERROR(
-						Logger::CORE, 
+						Logger::CORE,
 						"Aktor "+mName+": Das kontrollierte MeshObject des ChildAktor hat kein Skeleton." );
 				}
 			}
 			else
 			{
-				// Wenn der Slot existiert, dann 
+				// Wenn der Slot existiert, dann
 				try
 				{
 					Bone* bone = ent->getSkeleton()->getBone( childSlot );
@@ -544,11 +545,11 @@
 					offsetOrientationMod = offsetOrientation *  quat;
 					offsetPositionMod = ( offsetOrientationMod * (-vec) ) + offsetPosition;
 				}
-				catch (Ogre::Exception) 
+				catch (Ogre::Exception)
 				{
 					if (!useDefaultBone)
 					{
-						LOG_ERROR(Logger::CORE, 
+						LOG_ERROR(Logger::CORE,
 							"Aktor "+mName+": Der geforderte Slot '"+childSlot+"' am ChildAktor existiert nicht." );
 					}
 				}
@@ -557,12 +558,12 @@
 
         // Das wirkliche Anf?gen
         // Ist es ein nicht Standard-Slot && Kontrolliert der Aktor ein Objekt && Ist dieses ein Mesh
-        if( slot.compare(DEFAULT_SLOT_NAME) != 0 && 
-            getControlledObject() != NULL && 
+        if( slot.compare(DEFAULT_SLOT_NAME) != 0 &&
+            getControlledObject() != NULL &&
             getControlledObject()->isMeshObject() )
         {
             if( actor->getControlledObject() == NULL )
-                Throw(IllegalArgumentException, 
+                Throw(IllegalArgumentException,
                 "Aktor "+mName+": Der zu befestigende Aktor darf bei SLOTs nicht leer sein." );
 
             MovableObject* movObj = actor->getControlledObject()->getMovableObject();
@@ -570,7 +571,7 @@
 
             // Braucht ein Skelett
             if( !ent->hasSkeleton() )
-                Throw(IllegalArgumentException, 
+                Throw(IllegalArgumentException,
                 "Aktor "+mName+": Das kontrollierte MeshObject hat kein Skeleton." );
 
             // Der Slot muss existieren
@@ -579,7 +580,7 @@
                 ent->getSkeleton()->getBone( slot );
             }
             catch (Ogre::Exception) {
-                Throw(IllegalArgumentException, 
+                Throw(IllegalArgumentException,
                     "Aktor "+mName+": Der geforderte Slot '"+slot+"' existiert nicht." );
             }
 
@@ -596,7 +597,7 @@
             // Der Aktor wurde nicht an einem Bone befestigt
             actor->mBone = NULL;
         }
-    }         
+    }
 
     void Actor::detachFromParent()
     {
@@ -646,7 +647,7 @@
 
     MovableObject* Actor::_getMovableObject() const
     {
-        return mActorControlledObject ? 
+        return mActorControlledObject ?
             mActorControlledObject->getMovableObject() : 0;
     }
 
@@ -668,20 +669,20 @@
                 Actor* child = *iter;
                 child->_update();
             }
-        }        
+        }
     }
 
     void Actor::doPlaceIntoScene(SceneNode* parent, const Vector3& position,
         const Quaternion& orientation, const Ogre::String& physicsBone)
     {
         if( parent == NULL )
-            Throw(NullPointerException, 
+            Throw(NullPointerException,
             "Aktor "+mName+": Kann nicht an einen leeren parentNode angeh?ngt werden.");
         if( mBone )
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
             "Aktor "+mName+": Der Aktor ist bereits an einen Bone angeh?ngt.");
         if( mSceneNode && mSceneNode->isInSceneGraph() )
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
             "Aktor "+mName+": Der Aktor ist bereits in die Szene angeh?ngt.");
 
         // SceneNode erzeugen, falls nicht schon einer vorhanden
@@ -714,7 +715,7 @@
 
                 // Braucht ein Skelett
                 if( !ent->hasSkeleton() )
-                    Throw(IllegalArgumentException, 
+                    Throw(IllegalArgumentException,
                     "Aktor "+mName+": Das kontrollierte MeshObject hat kein Skeleton." );
 
                 // Der Slot muss existieren
@@ -723,7 +724,7 @@
                     ent->getSkeleton()->getBone( physicsBone );
                 }
                 catch (Ogre::Exception) {
-                    Throw(IllegalArgumentException, 
+                    Throw(IllegalArgumentException,
                         "Aktor "+mName+": Der geforderte PhysicsBone '"+physicsBone+"' existiert nicht." );
                 }
 
@@ -731,7 +732,7 @@
             }
             // Dann an einem SceneNode befestigen
             else
-            {      
+            {
                 mPhysicalThing->_attachToSceneNode(mSceneNode);
             }
         }
@@ -812,7 +813,7 @@
             doDetach( actor );
             actor->mParent = NULL;
             mChildren.erase( iter++ );
-        } 
+        }
     }
 
     void Actor::setVisible( bool vis, bool cascade )
@@ -834,7 +835,7 @@
 
     void Actor::nodeUpdated (const Node *node)
     {
-        _update();   
+        _update();
     }
 
     void Actor::nodeDestroyed (const Node *node)

Modified: rl/trunk/engine/core/src/ActorControlledObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorControlledObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ActorControlledObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ActorControlledObject.h"
 
@@ -32,11 +33,11 @@
         :   mMovableObject(mo)
     {
     }
-    
+
     ActorControlledObject::~ActorControlledObject()
     {
     }
-    
+
     void ActorControlledObject::_setActor(Actor* actor)
     {
         if (mMovableObject != NULL)
@@ -44,7 +45,7 @@
             mMovableObject->setUserObject(actor);
         }
     }
-    
+
     Actor* ActorControlledObject::getActor() const
     {
         if (mMovableObject != NULL)
@@ -53,12 +54,12 @@
         }
         return NULL;
     }
-    
+
     MovableObject* ActorControlledObject::getMovableObject() const
     {
         return mMovableObject;
     }
-    
+
     void ActorControlledObject::_attachSceneNode(Ogre::SceneNode* node)
     {
         if (mMovableObject != NULL)
@@ -66,13 +67,13 @@
             node->attachObject(mMovableObject);
         }
     }
-    
+
     void ActorControlledObject::_detachSceneNode(Ogre::SceneNode* node)
     {
         if (mMovableObject != NULL)
         {
-            node->detachObject(mMovableObject);    
-        }        
+            node->detachObject(mMovableObject);
+        }
     }
 
     bool ActorControlledObject::isAttached() const

Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ActorManager.h"
 
@@ -68,10 +69,10 @@
         return mActorRenderingDistance;
     }
 
-    void ActorManager::setDefaultActorRenderingDistance( Ogre::Real dist ) 
+    void ActorManager::setDefaultActorRenderingDistance( Ogre::Real dist )
     {
         for (ActorPtrMap::iterator it = mActors.begin();
-            it != mActors.end();) 
+            it != mActors.end();)
         {
             Actor* actor = it->second;
 
@@ -79,7 +80,7 @@
             if( actor->getRenderingDistance() == mActorRenderingDistance )
             {
                 actor->setRenderingDistance( dist );
-            } 
+            }
 
             ++it;
         }
@@ -141,12 +142,12 @@
 
     void ActorManager::destroyAllActors()
     {
-        for (ActorPtrMap::iterator it = mActors.begin(); it != mActors.end();) 
+        for (ActorPtrMap::iterator it = mActors.begin(); it != mActors.end();)
         {
             Actor* actor = it->second;
-            mActors.erase(it++);  
+            mActors.erase(it++);
             doDestroyActor(actor);
-        }		
+        }
     }
 
     Actor* ActorManager::createLightActor(const String& name, rl::LightObject::LightTypes type )
@@ -160,7 +161,7 @@
             LightObject* lo = new LightObject(uniquename, type);
 
             actor = new Actor(uniquename, lo);
-            mActors.insert(ActorPtrPair(uniquename,actor)); 
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {
@@ -189,7 +190,7 @@
                 createSound(soundfile, ST_SAMPLE);
             SoundObject* so = new SoundObject(sm, soundfile);
             actor = new Actor(uniquename, so);
-            mActors.insert(ActorPtrPair(uniquename,actor));  
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {
@@ -219,7 +220,7 @@
             SoundObject* so = new SoundObject(sm, soundfile);
 
             actor = new Actor(uniquename, so);
-            mActors.insert(ActorPtrPair(uniquename,actor)); 
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {
@@ -249,7 +250,7 @@
             ListenerObject* lo = new ListenerObject(lm);
 
             actor = new Actor(uniquename, lo);
-            mActors.insert(ActorPtrPair(uniquename,actor)); 
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {
@@ -274,7 +275,7 @@
         const String&  uniquename = nextUniqueName(name);
 
         Actor* actor = new Actor(uniquename);
-        mActors.insert(ActorPtrPair(uniquename,actor)); 
+        mActors.insert(ActorPtrPair(uniquename,actor));
 
         return actor;
     }
@@ -287,14 +288,14 @@
         {
             CameraObject* co = new CameraObject(uniquename);
             PhysicalThing* pt = PhysicsManager::getSingleton()
-                .createPhysicalThing(GT_SPHERE, co, 
+                .createPhysicalThing(GT_SPHERE, co,
                 100.0f, true);
             PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
 			pt->_getBody()->setMaterialGroupID(
                 PhysicsManager::getSingleton().getMaterialID("character"));
             actor = new Actor(uniquename, co, pt);
 
-            mActors.insert(ActorPtrPair(uniquename,actor)); 
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {
@@ -316,7 +317,7 @@
         return actor;
     }
 
-    Actor* ActorManager::createMeshActor(const String& name, const Ogre::String& basemeshname, 
+    Actor* ActorManager::createMeshActor(const String& name, const Ogre::String& basemeshname,
 		const MeshPartMap& meshparts, GeometryType geomType, Ogre::Real mass)
 	{
 		if (meshparts.empty())
@@ -329,7 +330,7 @@
 
         try
         {
-			
+
 			MergeableMeshObject* mmo = new MergeableMeshObject(uniquename, basemeshname);
 
 			for (MeshPartMap::const_iterator partIt = meshparts.begin(); partIt != meshparts.end(); ++partIt)
@@ -340,12 +341,12 @@
 				}
 				mmo->addSubmesh(partIt->first, partIt->second);
 			}
-		
+
 			PhysicalThing* pt = PhysicsManager::getSingleton()
 				.createPhysicalThing(geomType, mmo, mass);
 
 			actor = new Actor(uniquename, mmo, pt);
-			mActors.insert(ActorPtrPair(uniquename,actor)); 
+			mActors.insert(ActorPtrPair(uniquename,actor));
 		}
         catch (Ogre::Exception& e)
         {
@@ -385,7 +386,7 @@
                 .createPhysicalThing(geomType, mo, mass);
 
             actor = new Actor(uniquename, mo, pt);
-            mActors.insert(ActorPtrPair(uniquename,actor)); 
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {
@@ -423,7 +424,7 @@
                 .createPhysicalThing(GT_BOX, bp, mass);
 
             actor = new Actor(uniquename, bp, pt);
-            mActors.insert(ActorPtrPair(uniquename,actor)); 
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {
@@ -450,7 +451,7 @@
             ParticleSystemObject* po = new ParticleSystemObject(uniquename, partname);
 
             actor = new Actor(uniquename, po, 0);
-            mActors.insert(ActorPtrPair(uniquename,actor)); 
+            mActors.insert(ActorPtrPair(uniquename,actor));
         }
         catch (Ogre::Exception& e)
         {

Modified: rl/trunk/engine/core/src/AnimationListener.cpp
===================================================================
--- rl/trunk/engine/core/src/AnimationListener.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/AnimationListener.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "AnimationListener.h"
 
@@ -21,7 +22,7 @@
 
 namespace rl {
 
-AnimationEvent::AnimationEvent( BaseAnimation* anim, const unsigned int reason ) : 
+AnimationEvent::AnimationEvent( BaseAnimation* anim, const unsigned int reason ) :
 	EventObject(anim,reason)
 {}
 
@@ -36,7 +37,7 @@
 
 }
 
-bool AnimationListener::eventRaised( AnimationEvent* anEvent ) 
+bool AnimationListener::eventRaised( AnimationEvent* anEvent )
 {
     switch( anEvent->getReason() )
     {
@@ -64,7 +65,7 @@
 }
 
 
-AnimationFrameEvent::AnimationFrameEvent( BaseAnimation* anim,  const unsigned int reason, const Ogre::Real& frameNumber ) : 
+AnimationFrameEvent::AnimationFrameEvent( BaseAnimation* anim,  const unsigned int reason, const Ogre::Real& frameNumber ) :
 EventObject(anim,reason)
 {
 	mFrameNumber = frameNumber;

Modified: rl/trunk/engine/core/src/AnimationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/AnimationManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/AnimationManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "AnimationManager.h"
 
@@ -27,16 +28,16 @@
 
 template<> rl::AnimationManager* Ogre::Singleton<rl::AnimationManager>::ms_Singleton = 0;
 
-namespace rl 
+namespace rl
 {
 
-AnimationManager::AnimationManager( ) : 
+AnimationManager::AnimationManager( ) :
     mStateAnimationMap(),
     mFadeAnimSet(),
     mGlobalAnimationSpeed( 1.0f )
 {
 }
-    
+
 AnimationManager::~AnimationManager( )
 {
     removeAllAnimations();
@@ -54,35 +55,35 @@
 
 void AnimationManager::setDefaultInterpolationMode( AnimationManager::InterpolationMode im )
 {
-    Ogre::Animation::setDefaultInterpolationMode( 
+    Ogre::Animation::setDefaultInterpolationMode(
         Ogre::Animation::InterpolationMode( im ) );
 }
 
-AnimationManager::InterpolationMode 
+AnimationManager::InterpolationMode
     AnimationManager::getDefaultInterpolationMode() const
 {
-    return AnimationManager::InterpolationMode( 
+    return AnimationManager::InterpolationMode(
         Ogre::Animation::getDefaultInterpolationMode() );
 }
 
 void AnimationManager::setDefaultRotationInterpolationMode(
     AnimationManager::RotationInterpolationMode rim )
 {
-    Ogre::Animation::setDefaultRotationInterpolationMode( 
+    Ogre::Animation::setDefaultRotationInterpolationMode(
         Ogre::Animation::RotationInterpolationMode( rim ) );
 }
 
-AnimationManager::RotationInterpolationMode 
+AnimationManager::RotationInterpolationMode
     AnimationManager::getDefaultRotationInterpolationMode() const
 {
-    return AnimationManager::RotationInterpolationMode( 
+    return AnimationManager::RotationInterpolationMode(
         Ogre::Animation::getDefaultRotationInterpolationMode() );
 }
 
-MeshAnimation* AnimationManager::addMeshAnimation(Ogre::AnimationState* animState, 
+MeshAnimation* AnimationManager::addMeshAnimation(Ogre::AnimationState* animState,
     MeshObject* mesh, Ogre::Real speed, unsigned int timesToPlay, bool paused )
 {
-    StateAnimMap::iterator iter = 
+    StateAnimMap::iterator iter =
         mStateAnimationMap.find(animState);
 
     MeshAnimation* anim = 0;
@@ -107,7 +108,7 @@
     return anim;
 }
 
-TrackAnimation* AnimationManager::createTrackAnimation(Actor* actor, 
+TrackAnimation* AnimationManager::createTrackAnimation(Actor* actor,
     const Ogre::String& name, Ogre::Real length )
 {
     if( actor == 0 )
@@ -115,7 +116,7 @@
 
     ///@todo Namen abfangen
     TrackAnimation* trackAnim = new TrackAnimation(name,actor,length);
-    mStateAnimationMap.insert(std::pair<Ogre::AnimationState*,BaseAnimation*>( 
+    mStateAnimationMap.insert(std::pair<Ogre::AnimationState*,BaseAnimation*>(
         trackAnim->getAnimationState(),trackAnim));
 
     return trackAnim;
@@ -123,7 +124,7 @@
 
 BaseAnimation* AnimationManager::getAnimation(Ogre::AnimationState* animState) const
 {
-    StateAnimMap::const_iterator iter = 
+    StateAnimMap::const_iterator iter =
         mStateAnimationMap.find(animState);
 
     if( iter == mStateAnimationMap.end() )
@@ -132,33 +133,33 @@
         return iter->second;
 }
 
-void AnimationManager::removeTrackAnimation( Actor* act, const Ogre::String& name ) 
+void AnimationManager::removeTrackAnimation( Actor* act, const Ogre::String& name )
 {
     StateAnimMap::iterator it;
-    for( it = mStateAnimationMap.begin(); it != mStateAnimationMap.end();) 
+    for( it = mStateAnimationMap.begin(); it != mStateAnimationMap.end();)
     {
         TrackAnimation* anim = dynamic_cast<TrackAnimation*>( it->second );
-        
-        if ( anim != 0 && 
-             anim->getActor() == act && 
-             anim->getName() == name ) 
+
+        if ( anim != 0 &&
+             anim->getActor() == act &&
+             anim->getName() == name )
         {
             AnimationManager::stopAnimation(anim);
             ScriptWrapper::getSingleton().deleted( anim );
             delete anim;
             mStateAnimationMap.erase(it++); // ++i geht nicht
-        } 
-        else 
+        }
+        else
         {
            ++it; // Oder i++
-        } 
+        }
     }
 }
 
 bool AnimationManager::isStillInUse( BaseAnimation* anim ) const
 {
     FadeAnimSet::const_iterator it;
-    for( it = mFadeAnimSet.begin(); it != mFadeAnimSet.end(); it++) 
+    for( it = mFadeAnimSet.begin(); it != mFadeAnimSet.end(); it++)
     {
         if( (*it)->containsAnimation(anim) )
             return true;
@@ -167,32 +168,32 @@
     return false;
 }
 
-void AnimationManager::removeAllTrackAnimations( Actor* act ) 
+void AnimationManager::removeAllTrackAnimations( Actor* act )
 {
     StateAnimMap::iterator it;
-    for( it = mStateAnimationMap.begin(); it != mStateAnimationMap.end();) 
+    for( it = mStateAnimationMap.begin(); it != mStateAnimationMap.end();)
     {
         TrackAnimation* anim = dynamic_cast<TrackAnimation*>( it->second );
-        
-        if ( anim != 0 && anim->getActor() == act ) 
+
+        if ( anim != 0 && anim->getActor() == act )
         {
             AnimationManager::stopAnimation(anim);
             ScriptWrapper::getSingleton().deleted( anim );
             delete anim;
             mStateAnimationMap.erase(it++); // ++i geht nicht
-        } 
-        else 
+        }
+        else
         {
            ++it; // Oder i++
-        } 
+        }
     }
 }
 
-void AnimationManager::removeAllAnimations() 
+void AnimationManager::removeAllAnimations()
 {
     {
     FadeAnimSet::iterator it;
-    for( it = mFadeAnimSet.begin(); it != mFadeAnimSet.end();) 
+    for( it = mFadeAnimSet.begin(); it != mFadeAnimSet.end();)
     {
         FadeAnimation* anim = *it;
         AnimationManager::stopAnimation(anim);
@@ -204,7 +205,7 @@
     }
     {
     StateAnimMap::iterator it;
-    for( it = mStateAnimationMap.begin(); it != mStateAnimationMap.end();) 
+    for( it = mStateAnimationMap.begin(); it != mStateAnimationMap.end();)
     {
         BaseAnimation* anim = it->second;
         AnimationManager::stopAnimation(anim);
@@ -218,7 +219,7 @@
 
 void AnimationManager::removeAnimation(Ogre::AnimationState* animState)
 {
-    StateAnimMap::iterator iter = 
+    StateAnimMap::iterator iter =
         mStateAnimationMap.find(animState);
 
     if( iter != mStateAnimationMap.end() )
@@ -230,7 +231,7 @@
             return;
 
         AnimationManager::stopAnimation(anim);
-        mStateAnimationMap.erase(iter);      
+        mStateAnimationMap.erase(iter);
         ScriptWrapper::getSingleton().deleted( anim );
         delete anim;
     }
@@ -243,7 +244,7 @@
     RlAssert( time > 0.0, "Time must be greater then zero");
 
     FadeAnimation* anim = new FadeAnimation();
-    
+
     anim->addAnimation(from,0.0,time,1.0,0.0);
     anim->addAnimation(  to,0.0,time,0.0,1.0);
     anim->setPaused(false);
@@ -253,7 +254,7 @@
     return anim;
 }
 
-FadeAnimation* AnimationManager::fadeAnimation( MeshAnimation* fromLoop, 
+FadeAnimation* AnimationManager::fadeAnimation( MeshAnimation* fromLoop,
     MeshAnimation* blendAnim, MeshAnimation* toLoop, Ogre::Real loopDuration )
 {
     RlAssert( fromLoop != NULL, "StartAnimation must not be NULL!" );
@@ -262,7 +263,7 @@
     RlAssert( loopDuration > 0.0, "Time must be greater then zero");
 
     FadeAnimation* anim = new FadeAnimation();
-    
+
     if( loopDuration <= 0.0 )
         loopDuration = blendAnim->getLength();
 
@@ -282,11 +283,11 @@
     anim->resetTimesPlayed();
     anim->setTimesToPlay(1);
     anim->setSpeed(1.0);
-    anim->setPaused(true);    
+    anim->setPaused(true);
 }
 
 // @todo Check ob das das selbe MeshObject ist
-MeshAnimation* AnimationManager::replaceAnimation(MeshAnimation* oldAnim,  
+MeshAnimation* AnimationManager::replaceAnimation(MeshAnimation* oldAnim,
     Ogre::AnimationState* newAnimState, Ogre::Real speed, unsigned int timesToPlay )
 {
     removeAnimation( oldAnim );
@@ -318,18 +319,18 @@
 void AnimationManager::run(Ogre::Real timePassed)
 {
     // Zuerst faden (Weights modifizieren)
-    for (FadeAnimSet::iterator it = mFadeAnimSet.begin(); 
+    for (FadeAnimSet::iterator it = mFadeAnimSet.begin();
             it != mFadeAnimSet.end(); )
     {
         FadeAnimation* anim = *it;
         anim->addTime(timePassed*mGlobalAnimationSpeed);
 
-        if( anim->isDeleteOnFinish() && 
+        if( anim->isDeleteOnFinish() &&
             anim->getTimePlayed() > anim->getLength()  )
         {
            AnimationManager::stopAnimation(anim);
            ScriptWrapper::getSingleton().deleted( anim );
-           delete anim;           
+           delete anim;
            mFadeAnimSet.erase(it++);
         }
         else
@@ -337,7 +338,7 @@
     }
 
     // Dann normal animieren
-    for (StateAnimMap::iterator it = mStateAnimationMap.begin(); 
+    for (StateAnimMap::iterator it = mStateAnimationMap.begin();
             it != mStateAnimationMap.end(); it++)
     {
         it->second->addTime(timePassed*mGlobalAnimationSpeed);

Modified: rl/trunk/engine/core/src/BaseAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/BaseAnimation.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/BaseAnimation.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h"
 
 #include "Exception.h"
 #include "AnimationManager.h"

Modified: rl/trunk/engine/core/src/BoxPrimitive.cpp
===================================================================
--- rl/trunk/engine/core/src/BoxPrimitive.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/BoxPrimitive.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "BoxPrimitive.h"
 #include "World.h"

Modified: rl/trunk/engine/core/src/CameraObject.cpp
===================================================================
--- rl/trunk/engine/core/src/CameraObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/CameraObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "CameraObject.h"
 

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 /**
  * \file ConfigurationManager.h

Modified: rl/trunk/engine/core/src/ContentModule.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentModule.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ContentModule.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ContentModule.h"
 

Modified: rl/trunk/engine/core/src/CoreEvents.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreEvents.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/CoreEvents.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #ifndef __GameAreaEvent_H__
 #define __GameAreaEvent_H__
@@ -31,7 +32,7 @@
 		: CoreEvent(CoreEvent::DATA_LOADED),
 		mPercentLoaded(percent)
 	{
-		
+
 	}
 
 	float DataLoadedEvent::getPercentLoaded()

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "XmlResourceManager.h"
 

Modified: rl/trunk/engine/core/src/DebugVisualisable.cpp
===================================================================
--- rl/trunk/engine/core/src/DebugVisualisable.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/DebugVisualisable.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "DebugVisualisable.h"
 

Modified: rl/trunk/engine/core/src/DebugVisualsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/DebugVisualsManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/DebugVisualsManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "DebugVisualsManager.h"
 #include "DebugVisualisable.h"

Modified: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include <xercesc/framework/LocalFileInputSource.hpp>
 #include <xercesc/parsers/XercesDOMParser.hpp>
 #include <xercesc/dom/DOMDocument.hpp>

Modified: rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 // Xerces geht vor allen Ogre includes...
 #include "XmlResourceManager.h"
@@ -75,7 +76,7 @@
         // Alte Szene l?schen
         clearScene();
 
-		setCastShadows( true ); 
+		setCastShadows( true );
 
         // Leerer String, keine Map laden
         if (levelName.length() != 0)
@@ -127,10 +128,10 @@
 
 		if( enabled )
 		{
-			Ogre::String tmp = 
+			Ogre::String tmp =
 				ConfigurationManager::getSingleton().getStringSetting(
 					"Video", "Cast Shadows" );
-			
+
 			if (tmp == "yes")
 				castShadows = true;
 			else if (tmp == "no")
@@ -140,7 +141,7 @@
 		/// @todo Settings for multiple Shadow-Types?
 		if( castShadows )
 		{
-			int textureSize = 
+			int textureSize =
 				ConfigurationManager::getSingleton().getIntSetting(
 					"Video", "Shadow Texture Size" );
 			textureSize = std::max( 64, std::min( 4096, textureSize ) );

Modified: rl/trunk/engine/core/src/FadeAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/FadeAnimation.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/FadeAnimation.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "FadeAnimation.h"
 
@@ -23,21 +24,21 @@
 #include "ScriptWrapper.h"
 #include "AnimationManager.h"
 
-namespace rl 
+namespace rl
 {
 
 
-AnimationFadeOptions::AnimationFadeOptions( MeshAnimation* anim, Ogre::Real timeStart, 
+AnimationFadeOptions::AnimationFadeOptions( MeshAnimation* anim, Ogre::Real timeStart,
             Ogre::Real timeEnd, Ogre::Real weightStart, Ogre::Real weightEnd )
 {
     mAnimation = anim;
-    mTimeStart = timeStart; 
+    mTimeStart = timeStart;
     mTimeEnd = timeEnd;
     mWeightStart = weightStart;
     mWeightEnd = weightEnd;
 }
 
-FadeAnimation::FadeAnimation() : 
+FadeAnimation::FadeAnimation() :
     BaseAnimation(0.0, 1.0, 1, true ),
 	mDeleteOnFinish( true ),
     mDeleteAnimationsOnFinish( false ),
@@ -46,14 +47,14 @@
 {
 }
 
-FadeAnimation::~FadeAnimation() 
+FadeAnimation::~FadeAnimation()
 {
     for (FadeOptionsSet::iterator it = mFadeOptions.begin();
-            it != mFadeOptions.end(); ) 
+            it != mFadeOptions.end(); )
     {
         AnimationFadeOptions* afo = *it;
 
-        if( mDeleteAnimationsOnFinish && 
+        if( mDeleteAnimationsOnFinish &&
             afo->getAnimation()->getWeight() == 0.0 )
             AnimationManager::getSingleton().removeAnimation( afo->getAnimation() );
 
@@ -65,7 +66,7 @@
     mFadeOptions.clear();
 }
 
-void FadeAnimation::addAnimation( MeshAnimation* anim, Ogre::Real timeStart, 
+void FadeAnimation::addAnimation( MeshAnimation* anim, Ogre::Real timeStart,
     Ogre::Real timeEnd, Ogre::Real weightStart, Ogre::Real weightEnd )
 {
     anim->doAddTime(0.0);
@@ -82,16 +83,16 @@
 void FadeAnimation::removeAnimation( MeshAnimation* anim )
 {
     for (FadeOptionsSet::iterator it = mFadeOptions.begin();
-            it != mFadeOptions.end(); ) 
+            it != mFadeOptions.end(); )
     {
-        if( (*it)->getAnimation() == anim ) 
+        if( (*it)->getAnimation() == anim )
         {
             AnimationFadeOptions* afo = *it;
             ScriptWrapper::getSingleton().deleted( afo );
             mFadeOptions.erase(it++);
             delete afo;
-        } 
-        else 
+        }
+        else
            ++it;
     }
 }
@@ -109,9 +110,9 @@
 bool FadeAnimation::containsAnimation( BaseAnimation* anim ) const
 {
     for (FadeOptionsSet::const_iterator it = mFadeOptions.begin();
-            it != mFadeOptions.end(); it++ ) 
+            it != mFadeOptions.end(); it++ )
     {
-        if( (*it)->getAnimation() == anim ) 
+        if( (*it)->getAnimation() == anim )
             return true;
     }
 
@@ -120,13 +121,13 @@
 
 /// FIXME - was macht R?ckw?rts?
 void FadeAnimation::doAddTime( Ogre::Real timePassed )
-{        
+{
     for( FadeOptionsSet::iterator it = mFadeOptions.begin();
-            it != mFadeOptions.end(); it++ ) 
+            it != mFadeOptions.end(); it++ )
     {
         AnimationFadeOptions* afo = *it;
         Ogre::Real localElapsed = mTimePlayed + timePassed - afo ->getTimeStart();
-        
+
         // Nach der Anfangszeit
         if( localElapsed >= 0.0 )
         {
@@ -137,13 +138,13 @@
             {
                 Ogre::Real fadeFactor = (localElapsed/localLength);
                 Ogre::Real finalWeight = afo->getWeightEnd()*(1-fadeFactor) +
-                    afo->getWeightStart() * (fadeFactor); 
+                    afo->getWeightStart() * (fadeFactor);
 
-                afo->getAnimation()->setWeight(finalWeight);                
+                afo->getAnimation()->setWeight(finalWeight);
             }
             else if( !mFadeSoft && localElapsed >= localLength )
             {
-                afo->getAnimation()->setWeight(afo->getWeightEnd());  
+                afo->getAnimation()->setWeight(afo->getWeightEnd());
             }
             else if( !mFadeSoft && localElapsed < localLength )
             {

Modified: rl/trunk/engine/core/src/GameAreaEvent.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaEvent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/GameAreaEvent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "GameAreaEvent.h"
 
@@ -20,7 +21,7 @@
 
 namespace rl {
 
-GameAreaEvent::GameAreaEvent( GameAreaEventSource* src, const unsigned int reason ) 
+GameAreaEvent::GameAreaEvent( GameAreaEventSource* src, const unsigned int reason )
     : EventObject(src,reason),
     mActor(NULL)
 {

Modified: rl/trunk/engine/core/src/GameAreaEventSource.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "GameAreaEventSource.h"
 #include "ScriptWrapper.h"
@@ -28,16 +29,16 @@
         mAreaEventCaster(),
         mActor(act)
     {
-       
+
     }
 
-    GameAreaEventSource::~GameAreaEventSource() 
+    GameAreaEventSource::~GameAreaEventSource()
     {
         mInsideAreaList.clear();
         removeAllAreaListeners(  );
     }
 
-    
+
     void GameAreaEventSource::performQuery( Ogre::Real timePassed )
     {
 		// Ohne Listener ist der Query unwichtig...
@@ -45,21 +46,21 @@
 			return;
 
         // Position bertragen
-        mAreaType->setQueryPosition( mActor->getWorldPosition() );       
+        mAreaType->setQueryPosition( mActor->getWorldPosition() );
         ActorMap currInside = mAreaType->performQuery();
         // Der Actor um den herum die Quelle ist, wird vermutlich auch gefunden :)
         // Also rausl???chen
         currInside.erase( mActor->getName() );
 
         ActorMap enteredMap, leftMap;
-        // EinfuegeIteratoren erstellen        
+        // EinfuegeIteratoren erstellen
         std::insert_iterator<ActorMap> enteredInsert(enteredMap, enteredMap.begin());
         std::insert_iterator<ActorMap> leftInsert(leftMap, leftMap.begin());
 
         // Alle feststellen die rausgefallen sind
         std::set_difference( mInsideAreaList.begin(), mInsideAreaList.end(),
                         currInside.begin(), currInside.end(), leftInsert );
-        
+
         // Alle feststellen die neu hinzugekommen sind
         std::set_difference( currInside.begin(), currInside.end(),
             mInsideAreaList.begin(), mInsideAreaList.end(), enteredInsert );
@@ -71,7 +72,7 @@
 		doDispatchEvents( enteredMap, leftMap );
     }
 
-    void GameAreaEventSource::doDispatchEvents( 
+    void GameAreaEventSource::doDispatchEvents(
         const ActorMap& enteringActors, const ActorMap& leavingActors )
     {
         ActorMap::const_iterator it;
@@ -79,7 +80,7 @@
 
         GameAreaEvent* event = new GameAreaEvent( this, GameAreaEvent::AREA_LEFT );
         // Erst werden alle Listener fr jedes verlassende Object einmal benachrichtigt
-        for( it = leavingActors.begin(); it != leavingActors.end();++it) 
+        for( it = leavingActors.begin(); it != leavingActors.end();++it)
         {
             actor = it->second;
             event->setProvokingActor( actor );
@@ -88,7 +89,7 @@
 
         event->setReason( GameAreaEvent::AREA_ENTERED );
         // Dann werden alle Listener fr jedes betretende Object einmal benachrichtigt
-        for( it = enteringActors.begin(); it != enteringActors.end();++it) 
+        for( it = enteringActors.begin(); it != enteringActors.end();++it)
         {
             actor = it->second;
             event->setProvokingActor( actor );
@@ -100,7 +101,7 @@
     void GameAreaEventSource::addAreaListener( GameAreaListener*  list )
     {
         if( !mAreaEventCaster.containsListener(list) )
-        {        
+        {
             mAreaEventCaster.addEventListener( list );
             // Owned ;)
             ScriptWrapper::getSingleton().owned( list );
@@ -110,7 +111,7 @@
     void GameAreaEventSource::removeAreaListener( GameAreaListener* list )
     {
         if( mAreaEventCaster.containsListener(list) )
-        {        
+        {
             mAreaEventCaster.removeEventListener( list );
             // Nicht mehr gebraucht
             ScriptWrapper::getSingleton().disowned( list );
@@ -119,13 +120,13 @@
 
     void GameAreaEventSource::removeAllAreaListeners(  )
     {
-        EventCaster<GameAreaEvent>::EventSet arSet 
+        EventCaster<GameAreaEvent>::EventSet arSet
             = mAreaEventCaster.getEventSet();
-        EventCaster<GameAreaEvent>::EventSet::iterator iter 
+        EventCaster<GameAreaEvent>::EventSet::iterator iter
             = arSet.begin();
-        for (iter; iter != arSet.end(); ) 
+        for (iter; iter != arSet.end(); )
         {
-            EventListener<GameAreaEvent>* ev = *iter; 
+            EventListener<GameAreaEvent>* ev = *iter;
             GameAreaListener* gal = dynamic_cast<GameAreaListener*>( ev );
             ScriptWrapper::getSingleton().disowned( gal );
             iter++;

Modified: rl/trunk/engine/core/src/GameAreaListener.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaListener.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/GameAreaListener.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "GameAreaListener.h"
 

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "GameAreaTypes.h"
 
@@ -55,19 +56,19 @@
     {
         SceneQueryResult rs = mSphereQuery->execute();
         SceneQueryResultMovableList movList = rs.movables;
-        
+
         ActorMap retMap;
-        
+
         // Durch die Ergebnis Liste iterieren
         SceneQueryResultMovableList::iterator it;
-        for (it = movList.begin(); it != movList.end(); ++it) 
+        for (it = movList.begin(); it != movList.end(); ++it)
         {
-            MovableObject* mov = *it;  
+            MovableObject* mov = *it;
             if( mov->getUserObject() != NULL )
             {
                 // Zur Zeit sind die einzigen an Movables gekn?pfte Objekte Actoren
                 Actor* act = dynamic_cast<Actor*>( mov->getUserObject() );
-                retMap.insert(ActorPair(act->getName(),act)); 
+                retMap.insert(ActorPair(act->getName(),act));
             }
         }
 
@@ -79,7 +80,7 @@
         return mSphereQuery->getQueryMask();
     }
 
-    void GameSphereAreaType::setQueryMask( unsigned long mask ) 
+    void GameSphereAreaType::setQueryMask( unsigned long mask )
     {
         mSphereQuery->setQueryMask( mask );
     }

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "GameEventManager.h"
 #include "GameAreaTypes.h"
@@ -28,13 +29,13 @@
         mAreaEventSources(),
 		mQueuedDeletionSources()
     {
-        
+
     }
 
     GameEventManager::~GameEventManager( )
     {
         GameAreaEventSourceList::iterator it;
-        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();++it) 
+        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();++it)
         {
             GameAreaEventSource* gam = *it;
 			ScriptWrapper::getSingleton().deleted( gam );
@@ -57,20 +58,20 @@
         mAreaEventSources.insert( gam );
 		ScriptWrapper::getSingleton().owned( gam );
         // Und Listener anh?ngen
-        gam->addAreaListener( list );        
+        gam->addAreaListener( list );
     }
 
     void GameEventManager::removeAreaListener( GameAreaListener* list )
     {
         GameAreaEventSourceList::iterator it;
-        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();) 
+        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();)
         {
             GameAreaEventSource* gam = *it;
             gam->removeAreaListener( list );
 
             // Sind alle Listener weggeworfen?
             if( !gam->hasListeners() )
-            {          
+            {
 				// Sp?ter l?schen
 				mQueuedDeletionSources.insert( gam );
             }
@@ -83,17 +84,17 @@
     void GameEventManager::removeAllAreas( Actor* actor )
     {
         GameAreaEventSourceList::iterator it;
-        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();) 
+        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();)
         {
             GameAreaEventSource* gam = *it;
 
             // Ist das der Actor?
             if( gam->getActor() == actor )
-            {     
+            {
 				// Sp?ter l?schen
                 mQueuedDeletionSources.insert( gam );
             }
-            
+
             // Iterieren
             ++it;
         }
@@ -114,7 +115,7 @@
 			// Das Objekt l?schen
 			delete gam;
 		}
-		
+
 	}
 
     void GameEventManager::run( Ogre::Real elapsedTime )
@@ -122,7 +123,7 @@
         removeQueuedDeletionSources();
 
         GameAreaEventSourceList::iterator it;
-        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();++it) 
+        for( it = mAreaEventSources.begin(); it != mAreaEventSources.end();++it)
         {
             GameAreaEventSource* gam = *it;
             gam->performQuery( elapsedTime );

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "GameLoop.h"
 
 #include <OgreRoot.h>
@@ -30,7 +32,7 @@
 
 template<> rl::GameLoop* Singleton<rl::GameLoop>::ms_Singleton = 0;
 
-namespace rl 
+namespace rl
 {
     GameLoop::GameLoop()
         : mTaskLists(),
@@ -149,7 +151,7 @@
     }
 
     void GameLoop::updateTaskList()
-    {        
+    {
         // Remove removed tasks.
         for (GameTaskList::iterator it = mRemovedTasks.begin(); it != mRemovedTasks.end(); ++it)
         {

Modified: rl/trunk/engine/core/src/Job.cpp
===================================================================
--- rl/trunk/engine/core/src/Job.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/Job.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "Job.h"
 #include "Exception.h"

Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "JobScheduler.h"
 #include "Job.h"
@@ -65,7 +66,7 @@
 
             if (entry.start <= clock && clock < entry.end)
             {
-                // Is the token threshold reached? 
+                // Is the token threshold reached?
                 if (entry.tokens >= mTokenThreshold)
                 {
                     // Yes, pay run fee and execute.

Modified: rl/trunk/engine/core/src/LightFadeJob.cpp
===================================================================
--- rl/trunk/engine/core/src/LightFadeJob.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/LightFadeJob.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,13 +13,14 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "LightFadeJob.h"
 
 
 namespace rl
 {
-    LightFadeJob::LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse, 
+    LightFadeJob::LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse,
         const Ogre::ColourValue& targetSpecular, Ogre::Real duration)
         : Job(true, true),
         mLightObject(lightObject),
@@ -71,7 +72,7 @@
         /// @todo check if light source is invisible?
     }
 
-    bool LightFadeJob::interpolateColour(const Ogre::ColourValue& startColour, 
+    bool LightFadeJob::interpolateColour(const Ogre::ColourValue& startColour,
         const Ogre::ColourValue& endColour, Ogre::ColourValue& currentColour)
     {
         // Postcondition: mTime <= mDuration

Modified: rl/trunk/engine/core/src/LightObject.cpp
===================================================================
--- rl/trunk/engine/core/src/LightObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/LightObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "LightObject.h"
 #include "Actor.h"
@@ -39,7 +40,7 @@
     {
         return "LightObject";
     }
-    
+
     void LightObject::setAttenuation( Real range, Real constant, Real linear,
         Real quadric)
     {

Modified: rl/trunk/engine/core/src/LineSetPrimitive.cpp
===================================================================
--- rl/trunk/engine/core/src/LineSetPrimitive.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/LineSetPrimitive.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "LineSetPrimitive.h"
 #include "World.h"

Modified: rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp
===================================================================
--- rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/LinearSoundFadeFunctor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "LinearSoundFadeFunctor.h"
 
@@ -34,6 +35,6 @@
         } else {
             return factor * (mUp ? 1.0 : -1.0);
         }
-    }  
-    
+    }
+
 }

Modified: rl/trunk/engine/core/src/ListenerMovable.cpp
===================================================================
--- rl/trunk/engine/core/src/ListenerMovable.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ListenerMovable.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,13 +13,15 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "ListenerMovable.h"
 
 using namespace Ogre;
 
 
 namespace rl {
- 
+
 String ListenerMovable::msMovableType = "ListenerMovable";
 AxisAlignedBox ListenerMovable::msAABox = AxisAlignedBox(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5);
 
@@ -38,7 +40,7 @@
     setVelocity(Vector3(0.0, 0.0, 0.0));
     setOrientation(Quaternion(0.0, 0.0, 1.0));
 }
- 
+
 /**
  * @author JoSch
  * @date 03-12-2005
@@ -81,7 +83,7 @@
  * @author JoSch
  * @date 03-11-2005
  */
-const AxisAlignedBox& ListenerMovable::getBoundingBox() const 
+const AxisAlignedBox& ListenerMovable::getBoundingBox() const
 {
     return msAABox;
 }

Modified: rl/trunk/engine/core/src/ListenerObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ListenerObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ListenerObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ListenerObject.h"
 #include "Actor.h"
@@ -23,12 +24,12 @@
 using namespace Ogre;
 
 namespace rl {
-   
+
 /**
  * @param listener. Der Listener, Besitz wird ?bernommen.
  * @author JoSch
  * @date 03-16-2005
- */   
+ */
 ListenerObject::ListenerObject(ListenerMovable *listener) : ActorControlledObject()
 {
     mMovableObject = dynamic_cast<MovableObject*>(listener);
@@ -37,7 +38,7 @@
 /**
  * @author JoSch
  * @date 03-16-2005
- */   
+ */
 ListenerObject::~ListenerObject()
 {
     if (mMovableObject)
@@ -50,7 +51,7 @@
  * @return Immer false, weil kein Meshobjekt.
  * @author JoSch
  * @date 03-16-2005
- */   
+ */
 bool ListenerObject::isMeshObject()
 {
 	return false;
@@ -59,7 +60,7 @@
 /**
  * @author JoSch
  * @date 03-16-2005
- */   
+ */
 void ListenerObject::_update()
 {
     ActorControlledObject::_update();
@@ -89,7 +90,7 @@
  * @param Der bewegbare Listener
  * @author JoSch
  * @date 03-16-2005
- */   
+ */
 ListenerMovable* ListenerObject::getListener() const
 {
     return static_cast<ListenerMovable*>(mMovableObject);
@@ -99,7 +100,7 @@
  * @return Immer "ListenerObject"
  * @author JoSch
  * @date 03-16-2005
- */   
+ */
 String ListenerObject::getObjectType() const
 {
     return "ListenerObject";

Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "MergeableMeshObject.h"
 
 #include <MeshMergeTool.h>
@@ -59,7 +61,7 @@
 		if (mCombinedMeshName != newMeshName)
 		{
 			MeshPtr newMesh = MeshManager::getSingleton().getByName(newMeshName);
-			
+
 			if (newMesh.isNull())
 			{
 				MeshMergeTool mm;
@@ -69,7 +71,7 @@
 					MeshPtr meshToAdd = MeshManager::getSingleton().load(curMeshfile, "regressiontest"); ///@todo this is just for testing
 					mm.addMesh(meshToAdd);
 				}
-				
+
 				newMesh = mm.bake(newMeshName);
 			}
 
@@ -102,7 +104,7 @@
 		else
 		{
 			LOG_ERROR(
-				Logger::CORE, 
+				Logger::CORE,
 				"Could not remove part '"
 				 + partToRemove + "' from mergeable mesh '"
 				 + getMeshName() + "'. Part not found.");
@@ -117,7 +119,7 @@
 		Entity* oldEnt = getEntity();
 		Entity* newEnt = CoreSubsystem::getSingletonPtr()->getWorld()
 			->getSceneManager()->createEntity(oldEnt->getName()+"_", newMesh->getName());
-		
+
 		Node* parentNode = oldEnt->getParentNode();
 		if (parentNode != NULL)
 		{

Modified: rl/trunk/engine/core/src/MeshAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/MeshAnimation.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/MeshAnimation.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "MeshAnimation.h"
 
 #include <OgreAnimation.h>
@@ -34,11 +36,11 @@
 MeshAnimation::MeshAnimation( Ogre::AnimationState* animState, MeshObject* mesh,
                      Ogre::Real speed, unsigned int timesToPlay, bool paused ) :
     BaseAnimation( animState->getLength(), speed, timesToPlay, paused ),
-    mMeshObject( mesh )     
+    mMeshObject( mesh )
 {
 	setAnimationState(animState);
-    
-    mAnimation = 
+
+    mAnimation =
         static_cast<Entity*>(mMeshObject->getMovableObject())->getSkeleton()
         ->getAnimation(animState->getAnimationName());
 }
@@ -55,10 +57,10 @@
 		Throw( NullPointerException,"Ogre::AnimationState darf nicht null sein" );
 
 	mAnimState = animState;
-	
+
 	if( mTimesToPlay != 1 )
 		mAnimState->setLoop( true );
-	
+
 	// Wenn die Zeit negativ ist, beginnen wir am Ende
 	if( mSpeed < 0 )
 		mAnimState->setTimePosition( mAnimState->getLength() );
@@ -66,7 +68,7 @@
 	mAnimState->setEnabled( true );
 }
 
-void MeshAnimation::setSpeed( Ogre::Real speed ) 
+void MeshAnimation::setSpeed( Ogre::Real speed )
 {
 	// Eventuell auf Anfang/Ende setzen
 	if( speed < 0 && mAnimState->getTimePosition() == 0 )

Modified: rl/trunk/engine/core/src/MeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MeshObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/MeshObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "MeshObject.h"
 
 #include <OgreAnimationState.h>
@@ -62,7 +64,7 @@
             stopAllAnimations();
             CoreSubsystem::getSingletonPtr()->getWorld()
                 ->getSceneManager()->destroyEntity( getEntity() );
-        }		
+        }
     }
 
     Entity* MeshObject::getEntity() const
@@ -74,7 +76,7 @@
     {
         return mSize;
     }
-    
+
     AxisAlignedBox MeshObject::getPoseSize(const String& animationName)
 	{
 		PoseMap::iterator it = mPoseSizes.find(animationName);
@@ -117,7 +119,7 @@
 		{
 			animState = getEntity()->getAnimationState(animName);
 		}
-		catch(Ogre::Exception&) 
+		catch(Ogre::Exception&)
 		{
             Throw(IllegalArgumentException,
                 animName + " is not a valid AnimationState of " + mMeshName + ".");
@@ -141,7 +143,7 @@
         {
             animState = getEntity()->getAnimationState(animName);
         }
-        catch(Ogre::Exception&) 
+        catch(Ogre::Exception&)
         {
 			LOG_ERROR(Logger::CORE,
                 animName + " is not a valid AnimationState of " + mMeshName + ".");
@@ -166,14 +168,14 @@
 		{
 			animState = getEntity()->getAnimationState(animName);
 		}
-		catch(Ogre::Exception&) 
-		{ 
+		catch(Ogre::Exception&)
+		{
             Throw(IllegalArgumentException,
                 animName + " is not a valid AnimationState of " + mMeshName + ".");
 		}
 		AnimationManager::getSingleton().removeAnimation(animState);
 	}
-    
+
     void MeshObject::stopAllAnimations( )
     {
         if (getEntity() == NULL) // Entity schon abgebaut?
@@ -185,11 +187,11 @@
         {
             AnimationStateIterator iter = animStates->getAnimationStateIterator();
 
-            while (iter.hasMoreElements()) 
+            while (iter.hasMoreElements())
             {
-                AnimationState* state = iter.getNext(); 
+                AnimationState* state = iter.getNext();
                 stopAnimation( state->getAnimationName() );
-            } 
+            }
         }
     }
 
@@ -301,7 +303,7 @@
 
 		unsigned char* data = static_cast<unsigned char*>(
 			vb->lock(Ogre::HardwareBuffer::HBL_READ_ONLY));
-		
+
 		for (size_t i = 0; i < vd->vertexCount; ++i)
 		{
 			float* v;
@@ -314,7 +316,7 @@
 
 		return aabb;
     }
-    
+
     void MeshObject::setCastShadows (bool enabled)
     {
         getEntity()->setCastShadows(enabled);
@@ -341,7 +343,7 @@
             // TODO - optimieren, nur wenn der Typ ver???ndert wird
             //if(StringUtil::endsWith(subent->getMaterialName(),nameExtension)
             // == highlight )
-            //  continue;  
+            //  continue;
 
             if (ent->isHardwareAnimationEnabled())
             {
@@ -353,7 +355,7 @@
 
             // Highlight setzen
             if( highlight )
-            {           	 
+            {
                 MaterialPtr material = MaterialManager::getSingleton().getByName( oldMaterial->getName()+nameExtension );
 
                 if( material.isNull() )
@@ -362,7 +364,7 @@
 
                     material->setAmbient(1.0, 1.0, 1.0);
                     material->setDiffuse(1.0, 1.0, 1.0, 1.0);
-                    material->setSelfIllumination(0.4, 0.4, 0.4); 
+                    material->setSelfIllumination(0.4, 0.4, 0.4);
                 }
 
                 subent->setMaterialName(material->getName());
@@ -372,7 +374,7 @@
             {
                 String matName = oldMaterial->getName();
                 matName = matName.erase(matName.length() - nameExtension.length(), nameExtension.length() );
-                subent->setMaterialName( matName );				
+                subent->setMaterialName( matName );
             }
         }
     }

Modified: rl/trunk/engine/core/src/MovableText.cpp
===================================================================
--- rl/trunk/engine/core/src/MovableText.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/MovableText.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -5,6 +5,8 @@
 //-----------------------------------------------------------
 // Modified by Daniel Wickert, 2006
 
+#include "stdinc.h"
+
 #include "MovableText.h"
 #include "Exception.h"
 

Modified: rl/trunk/engine/core/src/ParticleSystemObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ParticleSystemObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ParticleSystemObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ParticleSystemObject.h"
 
@@ -31,7 +32,7 @@
 	{
 		ParticleSystem* part = CoreSubsystem::getSingletonPtr()->getWorld()
 				->getSceneManager()->createParticleSystem(name,partSys);
-        
+
 		mMovableObject = part;
 	}
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "PhysicalThing.h"
 
@@ -195,7 +196,7 @@
     void PhysicalThing::addForce(const Ogre::Vector3& force)
     {
         mBody->unFreeze();
-        mPendingForce += force;        
+        mPendingForce += force;
     }
 
     Ogre::Real PhysicalThing::getMass() const
@@ -227,8 +228,8 @@
         Node* node = entity->getParentNode();
         RlAssert(node,
             "Actor has to be placed in the scene in order to update its collision hull.");
-        
 
+
         Vector3 position;
         Quaternion orientation;
         mBody->getPositionOrientation(position, orientation);
@@ -322,7 +323,7 @@
     void PhysicalThing::fitToPose(const Ogre::String& animName)
     {
 		CollisionPtr coll;
-        
+
         if (mPhysicalObject->isMeshObject())
         {
             MeshObject* meshObject = dynamic_cast<MeshObject*>(mPhysicalObject);
@@ -384,7 +385,7 @@
 
     void PhysicalThing::createPhysicsProxy(SceneNode* node)
 	{
-		if (!mBody) 
+		if (!mBody)
 		{
             Vector3 inertia;
             OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia);
@@ -411,7 +412,7 @@
 
         // there is a difference between a meshobject and a 'normal' object
         // because a meshobject has got a mesh entity and therefore a it is
-        // likely that there will be more than one object with those collision 
+        // likely that there will be more than one object with those collision
         // primitives, so they need to get cached.
 
         if (mPhysicalObject->isMeshObject())
@@ -448,7 +449,7 @@
             mPoseCollisions.clear();
 
             Vector3 inertia;
-            
+
             // update the collision
 		    mBody->setCollision(createCollision(mPhysicalObject, inertia));
 		    if (mMass > 0.0 && mGeometryType != GT_MESH)

Modified: rl/trunk/engine/core/src/PhysicsContactListener.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsContactListener.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PhysicsContactListener.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "PhysicsContactListener.h"
 #include "PhysicalThing.h"
@@ -27,7 +28,7 @@
 {
 }
 
-void PhysicsContactListener::contactOccured(PhysicalThing* thing1, PhysicalThing* thing2) 
+void PhysicsContactListener::contactOccured(PhysicalThing* thing1, PhysicalThing* thing2)
 {
 	contactOccured(thing1->getActor(), thing2->getActor());
 }

Modified: rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include <OgreNewt_Prerequisites.h>
 

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "PhysicsManager.h"
 
@@ -61,7 +62,7 @@
 	}
 
 
-	const Ogre::AxisAlignedBox LQTBodies::getAABB(OgreNewt::Body* body) 
+	const Ogre::AxisAlignedBox LQTBodies::getAABB(OgreNewt::Body* body)
 	{
 		return body->getCollision()->getAABB();
 	}
@@ -120,7 +121,7 @@
         {
             // default material has been provided by OgreNewt, therefore it
             // it must not be deleted here
-            if ((*it).first != "default") 
+            if ((*it).first != "default")
                 delete (*it).second;
         }
         mMaterials.clear();
@@ -133,7 +134,7 @@
     void PhysicsManager::run(Real elapsedTime)
     {
         // do nothing, if not enabled
-        if (!mEnabled) 
+        if (!mEnabled)
 			return;
 
         // does not need to be executed each frame!
@@ -241,15 +242,15 @@
                 continue;
 
             OgreNewt::CollisionPtr collision = collisions[i];
-            
+
 		    OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
-            
 
+
             body->attachToNode(node);
             body->setPositionOrientation(node->getWorldPosition(),
                 node->getWorldOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
-			
+
 			mLevelBodiesQuadTree.add(body);
             //mLevelBodies.push_back(body);
         }
@@ -395,7 +396,7 @@
     }
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
-        Ogre::Entity* entity, const GeometryType& geomType, 
+        Ogre::Entity* entity, const GeometryType& geomType,
 		const Ogre::String animName, Ogre::Vector3* offset,
         Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
     {
@@ -406,7 +407,7 @@
 
         // result value
         CollisionPtr rval;
-		
+
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[collisionName]);
         // log some performance warning if collisionname is equal, but geomtype different ?
@@ -422,8 +423,8 @@
             } else {
                 // found it
                 rval = usedcol.colPtr;
-                
 
+
                 if( inertia )
                 {
                     // we must set inertia here, the calling function doesn't know we are not creating a new collision
@@ -473,7 +474,7 @@
                 }
             }
         }
-        
+
         if (rval.isNull())
         {
             // if there is none, then create a new collision object
@@ -494,7 +495,7 @@
     {
         // result value
         CollisionPtr rval;
-		
+
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[name]);
         // log some performance warning if collisionname is equal, but geomtype different ?
@@ -512,7 +513,7 @@
                 rval = usedcol.colPtr;
             }
         }
-        
+
         if (rval.isNull())
         {
             // if there is none, then create a new collision object
@@ -577,7 +578,7 @@
             size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
             size.z < PhysicsManager::NEWTON_GRID_WIDTH )
             return false;
-        return true;            
+        return true;
     }
 
     void PhysicsCollisionFactory::correctSize(Ogre::Vector3& size)
@@ -604,13 +605,13 @@
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
         const Ogre::Real Mass,
-        Ogre::Vector3* inertia) 
+        Ogre::Vector3* inertia)
     {
         // size of the mesh
         Vector3 size( aabb.getSize() );
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
-		
+
         // result value
         CollisionPtr rval;
 
@@ -618,17 +619,17 @@
         if (checkSize(size) == false )
         {
             correctSize(size);
-            LOG_MESSAGE(Logger::CORE, 
+            LOG_MESSAGE(Logger::CORE,
                 " AABB is too small, using 'box' instead of primitiv '" +
                 PhysicsManager::convertGeometryTypeToString(geomType));
             forceBox = true;
         }
 
         // check if the geometry type is supported for aabb
-        if (geomType == GT_CONVEXHULL || 
+        if (geomType == GT_CONVEXHULL ||
             geomType == GT_MESH)
         {
-            LOG_MESSAGE(Logger::CORE, 
+            LOG_MESSAGE(Logger::CORE,
                 " the geometry type '"+
                 PhysicsManager::convertGeometryTypeToString(geomType)+
                 "' is not supported for aabb, fail back to box");
@@ -670,7 +671,7 @@
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
         const Ogre::Real Mass,
-        Ogre::Vector3* inertia) 
+        Ogre::Vector3* inertia)
     {
         // bounding box of the mesh
         const Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
@@ -678,7 +679,7 @@
         Vector3 size( aabb.getSize() );
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
-		
+
         // result value
         CollisionPtr rval;
 
@@ -725,7 +726,7 @@
 	    	Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
             // orientation of the collision primitiv
 		    Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-				
+
             // set offset/orientation when they are null
 			if (! offset)
 				offset = &object_offset;
@@ -838,7 +839,7 @@
 		Ogre::Vector3 object_offset(0,radius,0);
         // orientation of the collision primitiv
 		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-        
+
 		// set offset/orientation when they are null
 		if (! offset)
 			offset = &object_offset;
@@ -871,7 +872,7 @@
 		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
 
 		// set offset/orientation when they are null
-		if (! offset) 
+		if (! offset)
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
@@ -903,7 +904,7 @@
 		// set offset/orientation when they are null
 		if (! offset)
     		offset = &object_offset;
-		if (! orientation) 
+		if (! orientation)
 			orientation = &object_orientation;
         if (inertia) {
             double sradius = radius*radius;

Modified: rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "PhysicsMaterialRaycast.h"
 
@@ -35,10 +36,10 @@
         mInfo.mBody = 0;
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
-        
+
         mGetNearest = false;
         go(world, start, end);
-        
+
         return mInfo;
     }
 
@@ -52,10 +53,10 @@
         mInfo.mBody = 0;
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
-        
+
         mGetNearest = false;
         go(world, start, end);
-        
+
         return mInfo;
     }
 

Modified: rl/trunk/engine/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/trunk/engine/core/src/PlayAnimationJob.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PlayAnimationJob.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "PlayAnimationJob.h"
 #include "MeshObject.h"

Modified: rl/trunk/engine/core/src/PlaySoundJob.cpp
===================================================================
--- rl/trunk/engine/core/src/PlaySoundJob.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PlaySoundJob.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "PlaySoundJob.h"
 #include "Sound.h"

Modified: rl/trunk/engine/core/src/PrimitiveObject.cpp
===================================================================
--- rl/trunk/engine/core/src/PrimitiveObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/PrimitiveObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "PrimitiveObject.h"
 #include "World.h"
@@ -29,7 +30,7 @@
         World* world = CoreSubsystem::getSingleton().getWorld();
         String manualObjectName = name == StringUtil::BLANK ? world->getUniqueName() : name;
         mMovableObject = world->getSceneManager()->createManualObject(manualObjectName);
-        
+
         if (mMaterialName == StringUtil::BLANK)
         {
             mMaterialName = "DefaultDebugPrimitiveMaterial";

Modified: rl/trunk/engine/core/src/RubyInterpreter.cpp
===================================================================
--- rl/trunk/engine/core/src/RubyInterpreter.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/RubyInterpreter.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 
 #include "RubyInterpreter.h"
@@ -33,7 +34,7 @@
 
 RubyInterpreter::RubyInterpreter()
 {
-    
+
 }
 
 RubyInterpreter::~RubyInterpreter()
@@ -65,12 +66,12 @@
         addSearchPath(mod->getDirectory() + "/scripts");
         addSearchPath(mod->getDirectory() + "/scripts/maps");
     }
-    
+
     ruby_init_loadpath();
     //Skriptname
     ruby_script("Rastullah");
     // Fuer Ruby .dll oder .so dazu laden
-    
+
     loadProtected(&RubyInterpreter::loadDlls, 0, "Ruby error while loading dlls");
 }
 
@@ -114,7 +115,7 @@
 
 void RubyInterpreter::logRubyErrors(const std::string& intro, int errorcode)
 {
-    if(errorcode != 0) 
+    if(errorcode != 0)
     {
         VALUE info = rb_inspect(ruby_errinfo);
         rb_backtrace();
@@ -157,8 +158,8 @@
     return CeGuiString(
         (CEGUI::utf8*)STR2CSTR(
             rb_funcall(
-                rval, 
-                rb_intern("to_s"), 
+                rval,
+                rb_intern("to_s"),
                 0)));
 }
 

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "SceneQuery.h"
 
@@ -269,7 +270,7 @@
         mResult.clear();
 
 		Ray ray(getRayStart(), (getRayEnd() - getRayStart()).normalisedCopy());
-		
+
 		Ogre::RaySceneQuery* query = CoreSubsystem::getSingleton().getWorld()->getSceneManager()
 			->createRayQuery(ray, getQueryMask());
 
@@ -288,7 +289,7 @@
 		}
 		return true;
 	}
-	
+
 	bool OgreRaySceneQuery::queryResult(
 		Ogre::SceneQuery::WorldFragment* fragment, Ogre::Real distance)
 	{

Modified: rl/trunk/engine/core/src/Sound.cpp
===================================================================
--- rl/trunk/engine/core/src/Sound.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/Sound.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,10 +13,12 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "Sound.h"
 #include "SoundDriver.h"
 
-using namespace Ogre; 
+using namespace Ogre;
 
 namespace rl
 {
@@ -53,7 +55,7 @@
  */
 bool Sound::isLooping() const
 {
-    return mIsLooping; 
+    return mIsLooping;
 }
 
 /**
@@ -73,7 +75,7 @@
  */
 bool Sound::is3d() const
 {
-    return mIs3d; 
+    return mIs3d;
 }
 
 /**
@@ -100,7 +102,7 @@
  * @author JoSch
  * @date 03-11-2005
  */
-const AxisAlignedBox& Sound::getBoundingBox() const 
+const AxisAlignedBox& Sound::getBoundingBox() const
 {
     return msAABox;
 }

Modified: rl/trunk/engine/core/src/SoundDriver.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundDriver.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SoundDriver.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "SoundDriver.h"
 #include "ConfigFile.h"
 

Modified: rl/trunk/engine/core/src/SoundEvents.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundEvents.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SoundEvents.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "SoundEvents.h"
 

Modified: rl/trunk/engine/core/src/SoundFadeFunctor.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundFadeFunctor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SoundFadeFunctor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "SoundFadeFunctor.h"
 

Modified: rl/trunk/engine/core/src/SoundFadeJob.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundFadeJob.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SoundFadeJob.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "SoundFadeJob.h"
 #include "SoundFadeFunctor.h"
@@ -50,7 +51,7 @@
             return true;
         }
         mSoundObject->setVolume(volume);
-        
+
         return false;
     }
 

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "SoundManager.h"
 
 #include <set>
@@ -360,7 +362,7 @@
     }
     return NULL;
 }
-    
+
 /**
  * @author JoSch
  * @date 20-04-2007

Modified: rl/trunk/engine/core/src/SoundObject.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SoundObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "SoundObject.h"
 #include "Actor.h"
@@ -28,12 +29,12 @@
 using namespace Ogre;
 
 namespace rl {
-   
+
 /**
  * @param sound. Der Sound, Besitz wird bernommen.
  * @author JoSch
  * @date 03-11-2005
- */   
+ */
 SoundObject::SoundObject(Sound *sound, const Ogre::String &name)
     : ActorControlledObject(sound)
 {
@@ -45,7 +46,7 @@
 /**
  * @author JoSch
  * @date 03-11-2005
- */   
+ */
 SoundObject::~SoundObject()
 {
     if (mMovableObject != NULL)
@@ -59,7 +60,7 @@
  * @return Immer false, weil kein Meshobjekt.
  * @author JoSch
  * @date 03-11-2005
- */   
+ */
 bool SoundObject::isMeshObject() const
 {
 	return false;
@@ -68,13 +69,13 @@
 /**
  * @author JoSch
  * @date 03-11-2005
- */   
+ */
 void SoundObject::_update()
 {
     ActorControlledObject::_update();
     Actor *actor = getActor();
 
-    if (mMovableObject == NULL || actor == NULL) 
+    if (mMovableObject == NULL || actor == NULL)
     {
         return;
     }
@@ -87,7 +88,7 @@
     if (isAttached())
     {
         getSound()->setPosition(actor->getWorldPosition());
-        getSound()->setDirection(actor->getWorldOrientation()); 
+        getSound()->setDirection(actor->getWorldOrientation());
 
        LOG_DEBUG(Logger::CORE, "Pos SoundObject: "
         + StringConverter::toString(actor->getWorldPosition().x) + " "
@@ -160,7 +161,7 @@
  * @param Der bewegbare Sound
  * @author JoSch
  * @date 03-11-2005
- */   
+ */
 Sound* SoundObject::getSound() const
 {
     return static_cast<Sound*>(mMovableObject);
@@ -170,7 +171,7 @@
  * @return Immer "SoundObject"
  * @author JoSch
  * @date 03-11-2005
- */   
+ */
 String SoundObject::getObjectType() const
 {
     return "SoundObject";

Modified: rl/trunk/engine/core/src/SoundResource.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundResource.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/SoundResource.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "SoundResource.h"
 

Modified: rl/trunk/engine/core/src/TrackAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/TrackAnimation.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/TrackAnimation.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "TrackAnimation.h"
 
@@ -24,7 +25,7 @@
 
 namespace rl {
 
-TrackAnimation::TrackAnimation( const Ogre::String& name, Actor *act, Ogre::Real length ) :	
+TrackAnimation::TrackAnimation( const Ogre::String& name, Actor *act, Ogre::Real length ) :
 	BaseAnimation(length,1.0,0,true),
 	mActor(act)
 {
@@ -36,7 +37,7 @@
 		mAnimation = mgr->createAnimation(name, length );
 	}
 	catch( Ogre::Exception& ) { Throw(RuntimeException, "Eine Animation mit dem Namen '"+name+"' war schon vorhanden." ); }
-	
+
 	act->_getSceneNode()->setInitialState();
 	mAnimationTrack = mAnimation->createNodeTrack(0, act->_getSceneNode() );
 	setAnimationState( mgr->createAnimationState(name) );
@@ -58,10 +59,10 @@
 		Throw( NullPointerException,"Ogre::AnimationState darf nicht null sein" );
 
 	mAnimState = animState;
-	
+
 	if( mTimesToPlay != 1 )
 		mAnimState->setLoop( true );
-	
+
 	// Wenn die Zeit negativ ist, beginnen wir am Ende
 	if( mSpeed < 0 )
 		mAnimState->setTimePosition( mAnimState->getLength() );
@@ -110,7 +111,7 @@
 	Ogre::TransformKeyFrame* frame = getKeyFrameAtTimePos( timePos );
 
 	if( frame != NULL )
-		frame->setRotation( Ogre::Quaternion(  Ogre::Radian( Ogre::Degree(angleUnits)), 
+		frame->setRotation( Ogre::Quaternion(  Ogre::Radian( Ogre::Degree(angleUnits)),
 				Ogre::Vector3(xRotAxis,yRotAxis,zRotAxis) ) );
 }
 
@@ -124,25 +125,25 @@
 
 void TrackAnimation::setInterpolationMode( AnimationManager::InterpolationMode im )
 {
-	mAnimation->setInterpolationMode( 
+	mAnimation->setInterpolationMode(
 		Ogre::Animation::InterpolationMode( im ) );
 }
 
 AnimationManager::InterpolationMode TrackAnimation::getInterpolationMode() const
 {
-	return AnimationManager::InterpolationMode( 
+	return AnimationManager::InterpolationMode(
 		mAnimation->getInterpolationMode() );
 }
 
 void TrackAnimation::setRotationInterpolationMode( AnimationManager::RotationInterpolationMode im )
 {
-	mAnimation->setRotationInterpolationMode( 
+	mAnimation->setRotationInterpolationMode(
 		Ogre::Animation::RotationInterpolationMode( im ) );
 }
 
 AnimationManager::RotationInterpolationMode TrackAnimation::getRotationInterpolationMode() const
 {
-	return AnimationManager::RotationInterpolationMode( 
+	return AnimationManager::RotationInterpolationMode(
 		mAnimation->getRotationInterpolationMode() );
 }
 

Modified: rl/trunk/engine/core/src/World.cpp
===================================================================
--- rl/trunk/engine/core/src/World.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/World.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "World.h"
 
 #include <OgreRoot.h>
@@ -44,7 +46,7 @@
 	{
 		mSceneMgr = SceneMgr;
 	}
-    
+
     //Enables / disables a 'sky plane' i.e.
     void World::setSkyPlane(bool enable, const Plane &plane,
         const String &materialName, Real scale, Real tiling,
@@ -69,11 +71,11 @@
     //Enables / disables a 'sky dome' i.e.
     void World::setSkyDome(bool enable, const String &materialName,
         Real curvature, Real tiling, Real distance, bool drawFirst)
-    {   
+    {
         mSceneMgr->setSkyDome(enable, materialName, curvature,
             tiling, distance, drawFirst, Quaternion::ZERO);
     }
- 	    
+
     //Sets the fogging mode applied to the scene.
     void World::setFog(FogMode mode, const ColourValue &colour,
         Real expDensity, Real linearStart, Real linearEnd)
@@ -81,25 +83,25 @@
         mSceneMgr->setFog(Ogre::FogMode(mode), colour,
             expDensity, linearStart, linearEnd );
     }
- 	    
+
     //Returns the fog mode for the scene.
     rl::World::FogMode World::getFogMode(void) const
     {
         return rl::World::FogMode(mSceneMgr->getFogMode( ));
     }
- 	    
+
     //Returns the fog colour for the scene.
     const ColourValue& World::getFogColour(void) const
     {
         return mSceneMgr->getFogColour();
     }
- 	    
+
     //Returns the fog start distance for the scene.
     Real World::getFogStart(void) const
     {
         return mSceneMgr->getFogStart();
     }
- 	    
+
     //Returns the fog end distance for the scene.
     Real World::getFogEnd(void) const
     {
@@ -110,14 +112,14 @@
 	{
         return Vector3::ZERO;
 	}
-	
+
 	void World::setCastShadows(bool enabled)
 	{
 		Throw(OperationNotSupportedException,
 			"SceneManager does not support shadows");
 	}
 
-    void World::setShowBoundingBoxes( bool dis ) 
+    void World::setShowBoundingBoxes( bool dis )
     {
         mSceneMgr->showBoundingBoxes( dis );
     }

Modified: rl/trunk/engine/core/src/Zone.cpp
===================================================================
--- rl/trunk/engine/core/src/Zone.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/Zone.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "Zone.h"
 
 #include "ActorManager.h"
@@ -21,7 +23,7 @@
 #include "Trigger.h"
 #include "ZoneManager.h"
 
-namespace rl 
+namespace rl
 {
 
 	Zone::Zone(Actor* actor)
@@ -53,7 +55,7 @@
 	}
 
     void Zone::areaEntered(GameAreaEvent *anEvent)
-	{		
+	{
 		ZoneManager::getSingleton().areaEntered(this);
 
 		std::list<Trigger*> toDelete;
@@ -90,7 +92,7 @@
 		std::list<Actor*> rval(mLights);
 		return rval;
 	}
-	
+
 	std::list<Ogre::String> Zone::getSounds() const
 	{
 		std::list<Ogre::String> rval(mSounds);
@@ -100,12 +102,12 @@
 
 	void Zone::deleteTriggers(const std::list<Trigger*>& toDelete)
 	{
-		for (std::list<Trigger*>::const_iterator it = toDelete.begin(); 
+		for (std::list<Trigger*>::const_iterator it = toDelete.begin();
 			it != toDelete.end(); ++it)
 		{
 			const Trigger* cur = *it;
 
-			std::list<Trigger*>::iterator trigIt = 
+			std::list<Trigger*>::iterator trigIt =
 				std::find(mTriggers.begin(), mTriggers.end(), cur);
 			mTriggers.erase(trigIt);
 		}

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ZoneManager.h"
 
@@ -23,14 +24,14 @@
 
 template<> rl::ZoneManager* Ogre::Singleton<rl::ZoneManager>::ms_Singleton = 0;
 
-namespace rl 
+namespace rl
 {
 	ZoneManager::ZoneManager()
 		: Ogre::Singleton<ZoneManager>()
 	{
 		// the default zone is active when no other Zone is active
 		mDefaultZone = new Zone(NULL);
-		mActiveZones.push_front(mDefaultZone); 
+		mActiveZones.push_front(mDefaultZone);
 	}
 
 	ZoneManager::~ZoneManager()
@@ -122,7 +123,7 @@
 			}
 		}
 	}
-	
+
 	void ZoneManager::switchSounds()
 	{
 		Zone* currentZone = mActiveZones.front();

Modified: rl/trunk/engine/core/src/nulldriver/NullDriver.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullDriver.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/nulldriver/NullDriver.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h"
+
 #include "NullDriver.h"
 #include "NullSound.h"
 #include "NullListener.h"

Modified: rl/trunk/engine/core/src/nulldriver/NullListener.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullListener.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/nulldriver/NullListener.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h"
 
 #include "NullListener.h"
 

Modified: rl/trunk/engine/core/src/nulldriver/NullSound.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullSound.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/nulldriver/NullSound.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h"
+
 #include "NullSound.h"
 #include "NullDriver.h"
 

Added: rl/trunk/engine/core/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/core/src/stdinc.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/core/src/stdinc.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,17 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+#include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/dialog/RlDialog2005.vcproj
===================================================================
--- rl/trunk/engine/dialog/RlDialog2005.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/RlDialog2005.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -39,16 +39,18 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\boost\include;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies;..\..\dependencies\ogrenewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
-				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLDIALOG_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLDIALOG_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				SmallerTypeCheck="true"
 				RuntimeLibrary="3"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				ExpandAttributedSource="true"
 				AssemblerOutput="4"
 				AssemblerListingLocation=".\obj\$(ConfigurationName)/"
@@ -134,13 +136,15 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\boost\include;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies;..\..\dependencies\ogrenewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLDIALOG_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLDIALOG_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="true"
 				DebugInformationFormat="3"
@@ -218,13 +222,15 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\boost\include;..\..\dependencies\aiml\MadaBot\include;..\..\dependencies\aiml\dependencies;..\..\dependencies\ogrenewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLDIALOG_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLDIALOG_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="true"
 				DebugInformationFormat="3"
@@ -327,6 +333,34 @@
 				RelativePath=".\src\ScriptProcessor.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\src\stdinc.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
 			<Filter
 				Name="predicates"
 				>
@@ -493,6 +527,10 @@
 				RelativePath=".\include\ScriptProcessor.h"
 				>
 			</File>
+			<File
+				RelativePath=".\include\stdinc.h"
+				>
+			</File>
 			<Filter
 				Name="predicates"
 				>

Added: rl/trunk/engine/dialog/include/stdinc.h
===================================================================
--- rl/trunk/engine/dialog/include/stdinc.h	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/include/stdinc.h	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,109 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+/*
+ * This file is used for precompiled header generation. You have to
+ * include it in all cpp files which have "Use Precompiled Header"
+ * set in their C/C++ properties. It shall never be included in other
+ * headers.
+ *
+ * The content of this file should be limited to the following include
+ * types:
+ *   - stdlib headers
+ *   - stl headers
+ *   - all types of external dependencies which will never be changed by us
+ *
+ * Every sub project should have it's own copy of this file and may have
+ * project specific modifications
+ */
+
+#ifndef __stdinc_h__
+#define __stdinc_h__
+
+#ifdef RL_USE_PCH
+
+#include <string>
+#include <vector>
+#include <list>
+#include <map>
+#include <set>
+
+#include <iostream>
+#include <sstream>
+
+#include <functional>
+#include <algorithm>
+#include <utility>
+
+#include <OgreCommon.h>
+#include <OgreConfigFile.h>
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreMath.h>
+#include <OgreVector3.h>
+#include <OgreSingleton.h>
+#include <OgreLog.h>
+#include <OgreLogManager.h>
+#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
+#include <OgreResource.h>
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
+#include <OgreUserDefinedObject.h>
+#include <OgreMovableObject.h>
+#include <OgreManualObject.h>
+#include <OgreNode.h>
+#include <OgreCamera.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <OgreLight.h>
+#include <OgreQuaternion.h>
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <OgreRenderable.h>
+#include <OgreParticleSystem.h>
+#include <OgreSceneQuery.h>
+#include <OgreSceneManager.h>
+#include <OgreSceneNode.h>
+#include <OgreAnimationState.h>
+#include <OgreRay.h>
+#include <OgreMeshManager.h>
+#include <OgreBillboardParticleRenderer.h>
+#include <OgreTextureManager.h>
+#include <OgreException.h>
+#include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
+
+#include <OgreNewt.h>
+#include <OgreNewt_ContactCallback.h>
+#include <OgreNewt_Collision.h>
+#include <OgreNewt_RayCast.h>
+
+#include <CEGUIString.h>
+#include <CEGUILogger.h>
+#include <elements/CEGUIFrameWindow.h>
+
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+#include <boost/any.hpp>
+#include <boost/bind.hpp>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#  include <Windows.h>
+#endif
+
+#endif//RL_USE_PCH
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp
===================================================================
--- rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/AimlNodeImplRl.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include <xercesc/dom/DOM.hpp>
 #include <xercesc/util/XMLString.hpp>
 #include <xercesc/util/XMLChar.hpp>
@@ -52,7 +54,7 @@
 	{
 		for(unsigned int i = 0; i < attributes->getLength(); ++i)
 		{
-			CeGuiString attributeName  = 
+			CeGuiString attributeName  =
 				XmlHelper::transcodeToString(attributes->item(i)->getNodeName());
 			CeGuiString attributeValue =
 				XmlHelper::transcodeToString(attributes->item(i)->getNodeValue());

Modified: rl/trunk/engine/dialog/src/AimlParserImplRl.cpp
===================================================================
--- rl/trunk/engine/dialog/src/AimlParserImplRl.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/AimlParserImplRl.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,3 +1,6 @@
+
+#include "stdinc.h"
+
 #include <xercesc/dom/DOM.hpp>
 #include <xercesc/parsers/XercesDOMParser.hpp>
 #include <xercesc/sax/HandlerBase.hpp>
@@ -31,7 +34,7 @@
 	XmlPtr res = getXmlResource(fileName);
 
     bool result = res->parseBy(&parser);
-    
+
     if(result)
     {
         XERCES_CPP_NAMESPACE::DOMDocument* doc = parser.getDocument();

Modified: rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/ContextConditionProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ContextConditionProcessor.h"
 #include "Creature.h"
 #include "Exception.h"

Modified: rl/trunk/engine/dialog/src/ContextInterpreter.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/ContextInterpreter.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ContextInterpreter.h"
 #include "ContextConditionProcessor.h"
 #include "ScriptProcessor.h"
@@ -124,7 +126,7 @@
 
 DialogResponse* ContextInterpreter::interpret(const Response<CeGuiString>::GossipData& pData, AimlBot<CeGuiString>* pProcessHelper)
 {
-	mOptions.clear();	
+	mOptions.clear();
 	mResponses.clear();
 	mBot = pProcessHelper;
 	CeGuiString type;

Modified: rl/trunk/engine/dialog/src/DialogCharacter.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogCharacter.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/DialogCharacter.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "DialogCharacter.h"
 #include "DialogSubsystem.h"
 #include "ContextInterpreter.h"
@@ -34,8 +36,8 @@
 namespace rl
 {
 	DialogCharacter::DialogCharacter()
-		: mActive(false), 
-		  mBot(NULL), 
+		: mActive(false),
+		  mBot(NULL),
 		  mNonPlayerCharacter(NULL),
 		  mPlayerCharacter(NULL)
 	{

Modified: rl/trunk/engine/dialog/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogOption.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/DialogOption.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "DialogOption.h"
 #include "DialogResponse.h"
 #include "DialogSubsystem.h"

Modified: rl/trunk/engine/dialog/src/DialogResponse.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogResponse.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/DialogResponse.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include <xercesc/parsers/XercesDOMParser.hpp>
 #include <xercesc/framework/MemBufInputSource.hpp>
 #include <xercesc/dom/DOM.hpp>
@@ -28,23 +30,23 @@
 
 namespace rl
 {
-	DialogResponse::DialogResponse( const CeGuiString& input, 
+	DialogResponse::DialogResponse( const CeGuiString& input,
 									const CeGuiString& response,
 									const Options& currentOptions,
 									const Options& selectableOptions,
 									NaturalLanguageProcessor* nlp)
-		:	mInput(input), 
-			mResponse(response), 
+		:	mInput(input),
+			mResponse(response),
 			mCurrentOptions(currentOptions),
-			mSelectableOptions(selectableOptions), 
+			mSelectableOptions(selectableOptions),
 			mNlp(nlp)
 	{
 	}
 
-	DialogResponse::DialogResponse( const Responses &responses, 
+	DialogResponse::DialogResponse( const Responses &responses,
 									const DialogOptions &options,
 									AimlBot<CeGuiString>* bot)
-		: mResponses(responses), 
+		: mResponses(responses),
 		  mOptions(options),
 		  mBot(bot)
 	{

Modified: rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/DialogScriptProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "DialogScriptProcessor.h"
 #include "CoreSubsystem.h"
 #include "RubyInterpreter.h"

Modified: rl/trunk/engine/dialog/src/DialogSubsystem.cpp
===================================================================
--- rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/DialogSubsystem.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include <xercesc/util/PlatformUtils.hpp>
 
 #include "XmlHelper.h"
@@ -47,8 +49,8 @@
 	LOG_MESSAGE(Logger::DIALOG, "Init Ende");
 }
 
-DialogSubsystem::~DialogSubsystem() 
-{  
+DialogSubsystem::~DialogSubsystem()
+{
 	delete mCore;
 	delete mContextInterpreter;
 
@@ -65,17 +67,17 @@
 #if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
     setlocale(LC_ALL, "C");
 #endif
-    
+
 	mCore->setParser(new AimlParserImplRl());
 	mCore->getBotInterpreter().addProcessor(new DialogScriptProcessor());
 	mCore->getAimlInterpreter().addProcessor(new ScriptProcessor());
 //  Initialize Xerces if this wasn't done already
-	try 
+	try
 	{
         XMLPlatformUtils::Initialize();
 		XmlHelper::initializeTranscoder();
     }
-    catch (const XMLException& exc) 
+    catch (const XMLException& exc)
 	{
 		char* excmsg = XMLString::transcode(exc.getMessage());
 		std::string excs="Exception while initializing Xerces: ";
@@ -100,7 +102,7 @@
 {
 	mCurrentBot = NULL;
 	AimlBot<CeGuiString>* bot = mCore->loadBot(botName.c_str(), fileName.c_str());
-//  while processing the bot definition, a DialogCharacter should have been created 
+//  while processing the bot definition, a DialogCharacter should have been created
 //  through a ruby script and stored in mCurrentBot
     if (mCurrentBot == NULL)
     {

Modified: rl/trunk/engine/dialog/src/ScriptProcessor.cpp
===================================================================
--- rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/ScriptProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ScriptProcessor.h"
 #include "CoreSubsystem.h"
 #include "RubyInterpreter.h"

Modified: rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/CreaturePredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "CreaturePredicates.h"
 #include "Creature.h"
 

Modified: rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "EigenschaftsProbePredicates.h"
 #include "Creature.h"
 

Modified: rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "EigenschaftsWertPredicates.h"
 #include "Creature.h"
 

Modified: rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/GrundWertPredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,13 +13,15 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "GrundWertPredicates.h"
 #include "Creature.h"
 
 namespace rl {
 
 GrundWertPredicates::GrundWertPredicates(Creature* pCharacter)
-	: CreaturePredicates(pCharacter) 
+	: CreaturePredicates(pCharacter)
 {
 }
 

Modified: rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/QuestKnownPredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "QuestKnownPredicates.h"
 
 #include "Exception.h"

Modified: rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/QuestPartsPredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "QuestPartsPredicates.h"
 
 #include <CEGUIPropertyHelper.h>
@@ -75,7 +77,7 @@
 	else if (value.substr(0, INCREASE.length()) == INCREASE)
 	{
 		int parts = PropertyHelper::stringToInt(value.substr(INCREASE.length()));
-		quest->increasePartsDone(parts);		
+		quest->increasePartsDone(parts);
 	}
 	else if (value == DECREASE)
 	{

Modified: rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/QuestStatePredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "QuestStatePredicates.h"
 
 #include "Exception.h"

Modified: rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/ScriptPredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "DialogCharacter.h"
 #include "ScriptPredicates.h"
 

Modified: rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/TalentProbePredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "TalentProbePredicates.h"
 #include "Creature.h"
 

Modified: rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp
===================================================================
--- rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/predicates/TalentWertPredicates.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "TalentWertPredicates.h"
 #include "Creature.h"
 

Added: rl/trunk/engine/dialog/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/dialog/src/stdinc.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/dialog/src/stdinc.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,17 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+#include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -40,16 +40,18 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
-				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				SmallerTypeCheck="true"
 				RuntimeLibrary="3"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				AssemblerListingLocation=".\obj\Debug/"
 				ObjectFile=".\obj\Debug/"
 				WarningLevel="3"
@@ -131,11 +133,13 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				AssemblerListingLocation=".\obj\Release/"
 				ObjectFile=".\obj\Release/"
 				WarningLevel="3"
@@ -215,11 +219,13 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				AssemblerListingLocation=".\obj\Release/"
 				ObjectFile=".\obj\Release/"
 				WarningLevel="3"
@@ -409,6 +415,34 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\stdinc.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
 				RelativePath=".\src\Talent.cpp"
 				>
 			</File>
@@ -615,6 +649,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\stdinc.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Talent.h"
 				>
 			</File>

Added: rl/trunk/engine/rules/include/stdinc.h
===================================================================
--- rl/trunk/engine/rules/include/stdinc.h	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/include/stdinc.h	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,107 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+/*
+ * This file is used for precompiled header generation. You have to
+ * include it in all cpp files which have "Use Precompiled Header"
+ * set in their C/C++ properties. It shall never be included in other
+ * headers.
+ *
+ * The content of this file should be limited to the following include
+ * types:
+ *   - stdlib headers
+ *   - stl headers
+ *   - all types of external dependencies which will never be changed by us
+ *
+ * Every sub project should have it's own copy of this file and may have
+ * project specific modifications
+ */
+
+#ifndef __stdinc_h__
+#define __stdinc_h__
+
+#ifdef RL_USE_PCH
+
+#include <string>
+#include <vector>
+#include <list>
+#include <map>
+#include <set>
+
+#include <iostream>
+#include <sstream>
+
+#include <functional>
+#include <algorithm>
+#include <utility>
+
+#include <OgreCommon.h>
+#include <OgreConfigFile.h>
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreMath.h>
+#include <OgreVector3.h>
+#include <OgreSingleton.h>
+#include <OgreLog.h>
+#include <OgreLogManager.h>
+#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
+#include <OgreResource.h>
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
+#include <OgreUserDefinedObject.h>
+#include <OgreMovableObject.h>
+#include <OgreManualObject.h>
+#include <OgreNode.h>
+#include <OgreCamera.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <OgreLight.h>
+#include <OgreQuaternion.h>
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <OgreRenderable.h>
+#include <OgreParticleSystem.h>
+#include <OgreSceneQuery.h>
+#include <OgreSceneManager.h>
+#include <OgreSceneNode.h>
+#include <OgreAnimationState.h>
+#include <OgreRay.h>
+#include <OgreMeshManager.h>
+#include <OgreBillboardParticleRenderer.h>
+#include <OgreTextureManager.h>
+#include <OgreException.h>
+#include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
+
+#include <OgreNewt.h>
+#include <OgreNewt_ContactCallback.h>
+#include <OgreNewt_Collision.h>
+#include <OgreNewt_RayCast.h>
+
+#include <CEGUIString.h>
+#include <CEGUILogger.h>
+
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+#include <boost/any.hpp>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#  include <Windows.h>
+#endif
+
+#endif//RL_USE_PCH
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/rules/src/Action.cpp
===================================================================
--- rl/trunk/engine/rules/src/Action.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Action.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,13 +13,14 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Action.h"
 #include "Exception.h"
 
 namespace rl
 {
-    Action::Action(const CeGuiString name, const CeGuiString description) 
+    Action::Action(const CeGuiString name, const CeGuiString description)
 		: mName(name),
           mDescription(description),
 		  mGroup(NULL)
@@ -56,64 +57,64 @@
         // Im Zweifel klappts halt. :)
         return true;
     }
-    
+
     void Action::doAction(GameObject* object,
                           Creature* actor,
                           GameObject* target)
     {
         // Muss ueberschrieben werden, sonst passiert nix.
     }
-	
+
 	void Action::setGroup(ActionGroup* group)
 	{
 		mGroup = group;
 	}
-	
+
 	ActionGroup* Action::getGroup() const
 	{
 		return mGroup;
 	}
-	
+
 	ActionGroup::ActionGroup(CeGuiString name, ActionGroup* parent)
 	{
 		mParent = parent;
 		mName = name;
-		
+
 		if (parent != NULL)
 			parent->addChild(this);
 	}
-	
+
 	ActionGroup::~ActionGroup()
 	{
 		if (mParent != NULL)
 			mParent->removeChild(this);
-		
+
 		for (ChildrenList::iterator it = mChildren.begin(); it != mChildren.end(); it++)
 			(*it)->removeParent();
 	}
-	
+
 	const CeGuiString ActionGroup::getName() const
 	{
 		return mName;
 	}
-	
+
 	const ActionGroup* const ActionGroup::getParent() const
 	{
 		return mParent;
 	}
-	
+
 	void ActionGroup::addChild(ActionGroup* child)
 	{
 		mChildren.insert(child);
 	}
-	
+
 	void ActionGroup::removeChild(ActionGroup* child)
 	{
 		ChildrenList::iterator it = mChildren.find(child);
 		if (it != mChildren.end())
 			mChildren.erase(it);
 	}
-	
+
 	void ActionGroup::removeParent()
 	{
 		mParent = NULL;

Modified: rl/trunk/engine/rules/src/ActionManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/ActionManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/ActionManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ActionManager.h"
 #include "Action.h"
@@ -62,7 +63,7 @@
 		if (mActions.find(action->getName()) != mActions.end())
 		{
 			Throw(
-				IllegalArgumentException, 
+				IllegalArgumentException,
 				("Action "+action->getName()+" bereits registriert").c_str());
 		}
 
@@ -106,10 +107,10 @@
 
 	Action* ActionManager::getInGameGlobalAction(const CeGuiString actionName) const
 	{
-		ActionVector::const_iterator iter = 
+		ActionVector::const_iterator iter =
 			findActionConst(
-				mInGameGlobalActions.begin(), 
-				mInGameGlobalActions.end(), 
+				mInGameGlobalActions.begin(),
+				mInGameGlobalActions.end(),
 				actionName);
 		if (iter == mInGameGlobalActions.end())
 			return NULL;

Modified: rl/trunk/engine/rules/src/Armor.cpp
===================================================================
--- rl/trunk/engine/rules/src/Armor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Armor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "Armor.h"
 
 #include "Creature.h"

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Combat.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Combat.h"
 

Modified: rl/trunk/engine/rules/src/CombatManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CombatManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/CombatManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,7 +13,9 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
+
 #include "CombatManager.h"
 
 #include "Combat.h"

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Container.h"
 
@@ -103,7 +104,7 @@
 
         UintPair pos = position;
 		if (!canPlaceAt(item, pos.first, pos.second))
-		{		
+		{
 			pos = findPositionWithEnoughSpace(item->getSize());
 		}
 
@@ -148,7 +149,7 @@
 		bool free = true;
 
         // Es wird versucht, das Item au?erhalb des Containers zu platzieren
-        if (xPos + xSize > mVolume.first 
+        if (xPos + xSize > mVolume.first
             || yPos + ySize > mVolume.second)
         {
             return false;
@@ -160,19 +161,19 @@
             {
                 LOG_DEBUG2(Logger::RULES,
 					Ogre::String("Checking Point in Backpack: Point x:")
-					+ Ogre::StringConverter::toString(x) 
+					+ Ogre::StringConverter::toString(x)
 					+ ", Point y:"
 					+ Ogre::StringConverter::toString(y),
                     "Container::canPlaceAt()");
 
                 if (getItemAt(x, y) != item)
-                {				
+                {
                     // Siehe nach, ob ein anderes Item im Weg ist
 					return false;
 				}
 			}
 		}
-		
+
 		return true;
 	}
 
@@ -188,7 +189,7 @@
 
 	UintPair Container::getItemPosition(Item* item) const
     {
-		std::map<Item*, UintPair >::const_iterator it = 
+		std::map<Item*, UintPair >::const_iterator it =
 			mItemPositions.find(item);
         if (it == mItemPositions.end())
         {
@@ -216,7 +217,7 @@
     bool Container::checkSpace(unsigned int xStart, unsigned int yStart, pair<unsigned int,unsigned int> space) const
     {
 		// Falls K?stchen nicht mehr im Rucksack, ist auch kein Platz mehr :)
-        if ((xStart+space.first) > mVolume.first 
+        if ((xStart+space.first) > mVolume.first
             || (yStart+space.second) > mVolume.second)
         {
 			return false;
@@ -228,7 +229,7 @@
             {
                 if (!isFree(xStart+x, yStart+y))
                 {
-                    return false;				
+                    return false;
                 }
 			}
 		}
@@ -242,14 +243,14 @@
 
     Item* Container::getItemAt(unsigned int x, unsigned int y) const
     {
-        for (map<Item*, UintPair >::const_iterator iter = mItemPositions.begin(); 
+        for (map<Item*, UintPair >::const_iterator iter = mItemPositions.begin();
             iter != mItemPositions.end(); iter++)
         {
             Item* item = (*iter).first;
             UintPair pos = (*iter).second;
 
-            if (pos.first <= x 
-                && pos.second <= y 
+            if (pos.first <= x
+                && pos.second <= y
                 && x < pos.first + item->getSize().first
                 && y < pos.second + item->getSize().second)
             {
@@ -296,7 +297,7 @@
 				Item* cur = dynamic_cast<Item*>(
 					GameObjectManager::getSingleton().createGameObjectFromProperty(curObjProp));
 
-				addItem(cur, curObjPos);				
+				addItem(cur, curObjPos);
 			}
         }
         else
@@ -332,7 +333,7 @@
 			contentMap[Container::PROPERTY_CONTENT_OBJECTS] = objects;
 			contentMap[Container::PROPERTY_CONTENT_POSITIONS] = positions;
 
-			return Property(contentMap);			
+			return Property(contentMap);
         }
         else
         {

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "Creature.h"
 
 #include "Actor.h"
@@ -39,7 +41,7 @@
     const Ogre::String Creature::CLASS_NAME = "Creature";
 
     const Ogre::String Creature::PROPERTY_BEHAVIOURS = "behaviours";
-    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype"; 
+    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = "inventorywindowtype";
     const Ogre::String Creature::PROPERTY_CURRENT_LE = "current_le";
     const Ogre::String Creature::PROPERTY_CURRENT_AE = "current_ae";
     const Ogre::String Creature::PROPERTY_CURRENT_AU = "current_au";
@@ -69,14 +71,14 @@
     const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
     const Creature::Wert Creature::WERT_BE = "BE";
     const Creature::Wert Creature::WERT_INI = "INI";
-    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle"; 
+    const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle";
     const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
-    
-    
 
 
+
+
     Creature::Creature(unsigned int id)
-        : GameObject(id), 
+        : GameObject(id),
 		mCurrentLe(0),
         mCurrentAu(0),
         mCurrentAe(0),
@@ -259,7 +261,7 @@
     {
         return mCurrentLe;
     }
-    
+
     int Creature::getLeMax()
     {
 		return getLeBasis() + getWert(WERT_MOD_LE);
@@ -277,7 +279,7 @@
     {
         return mCurrentAe;
     }
-    
+
     int Creature::getAeMax()
     {
 		return isMagic()?getAeBasis() + getWert(WERT_MOD_AE):0;
@@ -299,7 +301,7 @@
     {
         return mCurrentAu;
     }
-    
+
     int Creature::getAuMax()
     {
 		return getAuBasis() + getWert(WERT_MOD_AU);
@@ -309,17 +311,17 @@
     {
         mAp.total += modifier;
     }
-    
+
     int Creature::getAp()
     {
         return mAp.total;
     }
-    
+
     void Creature::modifyUsedAp(int modifier)
     {
         mAp.used += modifier;
     }
-    
+
     int Creature::getUsedAp()
     {
         return mAp.used;
@@ -362,7 +364,7 @@
         if (it == mTalente.end())
         {
             Talent::AusweichTalente ausweichTalente;
-            ausweichTalente = 
+            ausweichTalente =
                 DsaManager::getSingleton().getTalent(talentName)->getAusweichTalente();
             Talent::AusweichTalente::const_iterator ausweichIt = ausweichTalente.begin();
             if (ausweichIt == ausweichTalente.end())
@@ -372,7 +374,7 @@
             int rval = getTalent(ausweichIt->first) - ausweichIt->second;
             for (ausweichIt++; ausweichIt != ausweichTalente.end(); ausweichIt++)
             {
-                int tempAusweichTaw = getTalent(ausweichIt->first) 
+                int tempAusweichTaw = getTalent(ausweichIt->first)
                     - ausweichIt->second;
                 if (tempAusweichTaw > rval) rval = tempAusweichTaw;
             }
@@ -436,11 +438,11 @@
 		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
 		if (it != mKampftechniken.end())
 		{
-			Throw(IllegalArgumentException, 
+			Throw(IllegalArgumentException,
 				"Kampftechnik schon in mKampftechniken enthalten.");
 		}
 		//ueberpruefe ob es die Kampftechnik ueberhaupt gibt
-		DsaManager::getSingleton().getKampftechnik(kampftechnikName); 
+		DsaManager::getSingleton().getKampftechnik(kampftechnikName);
 		mKampftechniken[kampftechnikName] = value;
 		fireObjectStateChangeEvent();
 	}
@@ -598,7 +600,7 @@
 		int modifier, CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
     {
         Talent* talent = DsaManager::getSingleton().getTalent(talentName);
-		if (((talent->getArt() == TALENT_ART_SPEZIAL) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_SPEZIAL)) || 
+		if (((talent->getArt() == TALENT_ART_SPEZIAL) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_SPEZIAL)) ||
 			((talent->getArt() == TALENT_ART_BERUF) && (getTalent(talentName) < TALENT_MIN_TAW_FOR_BERUF)))
 		{
           /// @todo Find proper return value. Prompt an error message?
@@ -611,28 +613,28 @@
         Tripel<int> probe(DsaManager::getSingleton().roll3D20());
 
 		// Glueckliche
-		if ( (probe.first == 1) && (probe.second == 1) && (probe.third == 1) ) 
+		if ( (probe.first == 1) && (probe.second == 1) && (probe.third == 1) )
 		{
 			// BasisBoxS. 72 Der Wert wird sofort um 1 angehoben
-			modifyTalent(talentName, +1); 
+			modifyTalent(talentName, +1);
 			return RESULT_SPEKT_AUTOERFOLG;
 		}
-		if ( ((probe.first == 1) && (probe.second == 1)) || 
+		if ( ((probe.first == 1) && (probe.second == 1)) ||
 			 ((probe.first == 1) && (probe.third == 1)) ||
-			 ((probe.second == 1) && (probe.third == 1))) 
+			 ((probe.second == 1) && (probe.third == 1)))
 		{
 			addSe(talentName);
 			return RESULT_AUTOERFOLG;
 		}
 		// Patzer
-		if ((probe.first == 20) && (probe.second == 20) && (probe.third == 20)) 
+		if ((probe.first == 20) && (probe.second == 20) && (probe.third == 20))
 		{
 			addSe(talentName);
-			return RESULT_SPEKT_AUTOMISSERFOLG; 
+			return RESULT_SPEKT_AUTOMISSERFOLG;
 		}
-		if ( ((probe.first == 20) && (probe.second == 20)) || 
+		if ( ((probe.first == 20) && (probe.second == 20)) ||
 			 ((probe.first == 20) && (probe.third == 20)) ||
-			 ((probe.second == 20) && (probe.third == 20))) 
+			 ((probe.second == 20) && (probe.third == 20)))
 		{
 			addSe(talentName);
 			return RESULT_AUTOMISSERFOLG;
@@ -667,7 +669,7 @@
         return rval;
     }
 
-    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier, 
+    int Creature::doAlternativeTalentprobe(const CeGuiString talentName, int modifier,
 		CeGuiString eigenschaft1Name, CeGuiString eigenschaft2Name, CeGuiString eigenschaft3Name)
     {
 		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, eigenschaft1Name,
@@ -678,7 +680,7 @@
     {
         Talent* talent = DsaManager::getSingleton().getTalent(talentName);
         EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, spezialisierung, modifier, 
+		return doAlternativeTalentprobe(talentName, spezialisierung, modifier,
 			et.first, et. second, et.third);
 	}
 
@@ -686,7 +688,7 @@
     {
         Talent* talent = DsaManager::getSingleton().getTalent(talentName);
         EigenschaftTripel et(talent->getEigenschaften());
-		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first, 
+		return doAlternativeTalentprobe(talentName, Effect::MODTAG_NONE, modifier, et.first,
 			et. second, et.third);
 	}
 
@@ -705,13 +707,13 @@
         }
         else
         {
-			rval = getEigenschaft(eigenschaftName) - 
+			rval = getEigenschaft(eigenschaftName) -
                 (probe + modifier + mEffectManager->getMod(eigenschaftName, Effect::MODTYPE_PROBENMOD, tag) + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD, tag));
         }
         return rval;
     }
 
-	
+
 	Inventory* Creature::getInventory() const
 	{
 		return mInventory;
@@ -721,7 +723,7 @@
     {
         return mInventoryWindowType;
     }
-	
+
 	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
 	{
 		KampftechnikMap::const_iterator it = mKampftechniken.find(kampftechnikName);
@@ -743,12 +745,12 @@
 		}
 		else
 		{
-			rval = getAttackeBasis() + (*it).second.first - (probe + modifier 
+			rval = getAttackeBasis() + (*it).second.first - (probe + modifier
                 + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
 		}
-		if (rval < 0) 
+		if (rval < 0)
 			return RESULT_MISSERFOLG;
-		else 
+		else
 			return RESULT_ERFOLG;
 	}
 
@@ -774,12 +776,12 @@
 		else
 		{
 			/// @todo Gute Parade
-			rval = getParadeBasis() + (*it).second.second - (probe + modifier 
+			rval = getParadeBasis() + (*it).second.second - (probe + modifier
                 + mEffectManager->getMod(ALL_EIGENSCHAFTEN, Effect::MODTYPE_PROBENMOD) + eBe);
 		}
-		if (rval < 0) 
+		if (rval < 0)
 			return RESULT_MISSERFOLG;
-		else 
+		else
 			return RESULT_ERFOLG;
 	}
 
@@ -788,7 +790,7 @@
 		int rval = getInitiativeBasis();
 		rval += mEffectManager->getMod(WERT_INI, Effect::MODTYPE_SUM);
 		rval -= mEffectManager->getMod(WERT_BE, Effect::MODTYPE_SUM);
-		if (getMaxInitiave) 
+		if (getMaxInitiave)
         {
             rval += 6;
         }
@@ -804,16 +806,16 @@
 	{
         /**@todo Was tun bei negativen TP? Exception? Fehlermeldung? Stillschweigend
              auf 0 setzen?*/
-        if (tp < 0) 
+        if (tp < 0)
         {
             tp = 0;
         }
         ///@todo auf Verletzlichkeiten und Immunitaeten achten
-        if ((damageType & LEDAMAGE_FIRE) == LEDAMAGE_FIRE) 
+        if ((damageType & LEDAMAGE_FIRE) == LEDAMAGE_FIRE)
             CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Fire!\"");
-        if ((damageType & LEDAMAGE_WATER) == LEDAMAGE_WATER) 
+        if ((damageType & LEDAMAGE_WATER) == LEDAMAGE_WATER)
             CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Water!\"");
-        if ((damageType & LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC) 
+        if ((damageType & LEDAMAGE_DEMONIC) == LEDAMAGE_DEMONIC)
             CoreSubsystem::getSingleton().getRubyInterpreter()->execute("p \"Demons!\"");
         if ((damageType & LEDAMAGE_TP_A) == LEDAMAGE_TP_A)
         {
@@ -858,7 +860,7 @@
         //Addiere eventuelle Modifikatoren hinzu
         regeneratedLe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_LE);
         //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG <= doEigenschaftsprobe("KO", 
+        if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
             0, Effect::MODTAG_REGENERATION_LE))
         {
             regeneratedLe++;
@@ -874,7 +876,7 @@
         //Addiere eventuelle Modifikatoren hinzu
         regeneratedAe += mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AE);
         //Bei gelungener KO Probe addiere 1
-        if (RESULT_ERFOLG <= doEigenschaftsprobe("IN", 
+        if (RESULT_ERFOLG <= doEigenschaftsprobe("IN",
             0, Effect::MODTAG_REGENERATION_AE))
         {
             regeneratedAe++;
@@ -888,7 +890,7 @@
         // das Ganze nur jede Spielrunde machen
         static float lastSpielrunde = 0;
         static int regeneratedAu = DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6() 
+                + DsaManager::getSingleton().rollD6()
                 + DsaManager::getSingleton().rollD6();
         lastSpielrunde += time;
 
@@ -908,17 +910,17 @@
             ///@todo Gibt es etwas das die Regeneration permanent modifiziert?
             //Grundregeneration von 3W6
             regeneratedAu = DsaManager::getSingleton().rollD6()
-                + DsaManager::getSingleton().rollD6() 
+                + DsaManager::getSingleton().rollD6()
                 + DsaManager::getSingleton().rollD6();
             //Addiere eventuelle Modifikatoren hinzu
             //regeneratedAu += getWert(WERT_MOD_REGENERATION_LE);
             //Bei gelungener KO Probe addiere 1
-            if (RESULT_ERFOLG <= doEigenschaftsprobe("KO", 
+            if (RESULT_ERFOLG <= doEigenschaftsprobe("KO",
                 0, mEffectManager->getMod(WERT_REGENERATION, Effect::MODTYPE_SUM, Effect::MODTAG_REGENERATION_AU)))
             {
                 modifyAu(6*factor);
             }
-            
+
             if( lastSpielrunde >= Date::ONE_SPIELRUNDE ) // mehrere Runden auf einmal
             {
                 //modifiziere die aktuellen AU

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,8 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
+#include "stdinc.h" //precompiled header
 
-
 #include "Actor.h"
 #include "Creature.h"
 #include "DsaManager.h"
@@ -52,17 +52,17 @@
         }
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = 0.0f; 
+            velocity = 0.0f;
             return isPossible();
         }
         virtual bool isPossible() const
         {
-            return 
+            return
                 mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_DEAD | Effect::STATUS_UNCONSCIOUS | Effect::STATUS_SLEEPING));
         }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
         {
             getRotationMovement()->calculateForceAndTorque(force, torque, timestep);
 
@@ -100,7 +100,7 @@
                 if( omegaY < Degree(-20).valueRadians() )
                     mMovingCreature->setAnimation("drehen_rechts");
                 else
-                    mMovingCreature->setAnimation("Idle");                            
+                    mMovingCreature->setAnimation("Idle");
             }
         }
         virtual void applyAuChanges(Ogre::Real elapsedTime)
@@ -123,7 +123,7 @@
         virtual AbstractMovement* getRotationMovement() const
         {
             if( mRotationMovement == NULL)
-            {                
+            {
                 mRotationMovement = mMovingCreature->getMovementFromId(CreatureController::MT_DREHEN);
             }
             if( mRotationMovement == NULL )
@@ -152,7 +152,7 @@
         }
         virtual bool isPossible() const
         {
-            return 
+            return
                 mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR;// &&
                 mMovingCreature->getCreature()->getAu() > 1 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
@@ -166,7 +166,7 @@
         {
             AbstractMovement::deactivate();
         }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
         {
             Real mass;
             Vector3 inertia;
@@ -199,7 +199,7 @@
             mYaw += Radian(rotation.y);
             while (mYaw.valueDegrees() > 360.0f) mYaw -= Degree(360.0f);
             while (mYaw.valueDegrees() < -360.0f) mYaw += Degree(360.0f);
-            
+
             OgreNewt::Body *body = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody();
             Quaternion orientation;
             Vector3 position;
@@ -234,13 +234,13 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 3.6f * 0.7f; 
+            velocity = mMovingCreature->getCurrentGS() / 3.6f * 0.7f;
             return isPossible();
         }
         virtual bool isPossible() const
         {
-            return 
-                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR && 
+            return
+                mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 1 &&
                 !(mMovingCreature->getCreature()->getStatus() & Effect::STATUS_IMMOBILE);
         }
@@ -269,7 +269,7 @@
             Real length = 5./3.;
             Real weight = 1;
             Real relTimeOffset = 0;
-            
+
             switch( mMovingCreature->getLastMovementType() )
             {
             case CreatureController::MT_NONE:
@@ -307,7 +307,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 2.8f; 
+            velocity = mMovingCreature->getCurrentGS() / 2.8f;
             return isPossible();
         }
         virtual bool isPossible() const
@@ -363,7 +363,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 2.0f; 
+            velocity = mMovingCreature->getCurrentGS() / 2.0f;
             return isPossible();
         }
         virtual bool isPossible() const
@@ -469,7 +469,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_LAUFEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS(); 
+            velocity = mMovingCreature->getCurrentGS();
             return isPossible();
         }
         virtual bool isPossible() const
@@ -578,7 +578,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 4.0; 
+            velocity = mMovingCreature->getCurrentGS() / 4.0;
             return isPossible();
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
@@ -595,7 +595,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 3.2; 
+            velocity = mMovingCreature->getCurrentGS() / 3.2;
             return isPossible();
         }
         virtual void setAnimation(Ogre::Real elapsedTime)
@@ -613,7 +613,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 4.0; 
+            velocity = mMovingCreature->getCurrentGS() / 4.0;
             return isPossible();
         }
         virtual bool isDirectionPossible(Ogre::Vector3 &direction) const
@@ -646,7 +646,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 6.0; 
+            velocity = mMovingCreature->getCurrentGS() / 6.0;
             return isPossible();
         }
         virtual bool run(Ogre::Real elapsedTime, Ogre::Vector3 direction, Ogre::Vector3 rotation)
@@ -758,7 +758,7 @@
         }
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") + 
+            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") +
                         mMovingCreature->getCreature()->getEigenschaft("KK")) / 4.0 / 5.0;
 
             // steht nicht in den Regeln aber finde ich sinnvoll
@@ -780,13 +780,13 @@
                     mMovingCreature->getCreature()->getAu() > 6 &&
                     !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
             else
-                return 
+                return
                 mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 8 &&
                 mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
         }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
         {
             Real mass;
             Vector3 inertia;
@@ -881,7 +881,7 @@
     class Weitsprung : public AbstractMovement
     {
     public:
-        Weitsprung(CreatureController *creature) : 
+        Weitsprung(CreatureController *creature) :
           AbstractMovement(creature), mState(DOWN), mWidth(0),
               mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
               mApplyForceTimer(0), mLastForce(Vector3::ZERO),
@@ -908,7 +908,7 @@
                     Real factor = -mMovingCreature->getVelocity().z / vel;
                     factor = std::max(Real(0),factor);
                     // without moving before, the width will be 1/3
-                    mWidth = mWidth/3. + mWidth * 2./3. * factor; 
+                    mWidth = mWidth/3. + mWidth * 2./3. * factor;
                 }
 
 
@@ -940,7 +940,7 @@
         }
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") + 
+            velocity = (mMovingCreature->getCreature()->getEigenschaft("GE") +
                         mMovingCreature->getCreature()->getEigenschaft("KK")) / 5.0;
 
             // steht nicht in den Regeln aber finde ich sinnvoll
@@ -962,13 +962,13 @@
                     mMovingCreature->getCreature()->getAu() > 6 &&
                     !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
             else
-                return 
+                return
                 mMovingCreature->getAbstractLocation() == CreatureController::AL_FLOOR &&
                 mMovingCreature->getCreature()->getAu() > 8 &&
                 mMovingCreature->getCreature()->getAu() > mMovingCreature->getCreature()->getAuMax()/3.0 &&
                 !(mMovingCreature->getCreature()->getStatus() & (Effect::STATUS_IMMOBILE));
         }
-        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep) 
+        virtual void calculateForceAndTorque(Vector3 &force, Vector3 &torque, Real timestep)
         {
             Real mass;
             Vector3 inertia;
@@ -997,7 +997,7 @@
                         ax =  (v1x - v0) / t1;
                         ay = v1y/t1 + g;
                     }
-                    
+
                     mLastForce.x = 0;
                     mLastForce.y = ay * mass;
                     mLastForce.z = -ax * mass;
@@ -1031,7 +1031,7 @@
                         ax =  (v1x - -v_now.z) / timestep;
                         ay = (v1y- v_now.y)/timestep + g;
                     }
-                    
+
                     force.x = 0;
                     force.y = ay * mass;
                     force.z = -ax * mass;
@@ -1146,7 +1146,7 @@
         mLastFloorContact(0)
     {
         CreatureControllerManager::getSingleton().add(this);
-        
+
         const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID("character");
         mCreature->getActor()->getPhysicalThing()->setMaterialID(material);
 
@@ -1209,9 +1209,9 @@
 
     CreatureController::MovementType CreatureController::getMovementId() const
     {
-        if (mMovement == NULL) 
-            return MT_NONE; 
-        else 
+        if (mMovement == NULL)
+            return MT_NONE;
+        else
             return mMovement->getId();
     }
 
@@ -1228,7 +1228,7 @@
         MeshObject* mesh = dynamic_cast<MeshObject*>(mCreature->getActor()->getControlledObject());
         PhysicalThing* pt = mCreature->getActor()->getPhysicalThing();
         MeshAnimation *meshAnim(NULL);
-        
+
         if( mLastAnimationName != name)
         {
             const Ogre::String *pCollisionName = &collisionName;
@@ -1314,7 +1314,7 @@
 
     Ogre::Vector3 CreatureController::getVelocity() const
     {
-        return 
+        return
             mCreature->getActor()->getPhysicalThing()->getOrientation().Inverse() *
             mCreature->getActor()->getPhysicalThing()->_getBody()->getVelocity();
     }
@@ -1493,7 +1493,7 @@
         Radian yaw = mCreature->getActor()->getWorldOrientation().getYaw();
 
         AbstractMovement *drehen = getMovementFromId(MT_DREHEN);
-        
+
         if( drehen == NULL )
             return yaw;
 

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,8 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
+#include "stdinc.h" //precompiled header
 
-
 #include "Actor.h"
 #include "Creature.h"
 #include "GameTask.h"

Modified: rl/trunk/engine/rules/src/Date.cpp
===================================================================
--- rl/trunk/engine/rules/src/Date.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Date.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Date.h"
 

Modified: rl/trunk/engine/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include <xercesc/dom/DOM.hpp>
 #include <xercesc/parsers/XercesDOMParser.hpp>
@@ -60,7 +61,7 @@
 
         parser->setValidationScheme(XercesDOMParser::Val_Auto);    // optional.
         parser->setDoNamespaces(true);    // optional
-		
+
         OgreInputSource source(stream);
         parser->parse(source);
 
@@ -71,7 +72,7 @@
 		initializeTalente(XmlHelper::getChildNamed(dataDocumentContent, "Talente"));
 		initializeKampftechniken(XmlHelper::getChildNamed(dataDocumentContent, "Kampftechniken"));
 		initializePersonen(XmlHelper::getChildNamed(dataDocumentContent, "Personen"));
-		
+
 		doc->release();
 
 		XMLPlatformUtils::Terminate();
@@ -208,12 +209,12 @@
 		DOMNodeList* personenXml = rootPersons->getElementsByTagName(AutoXMLCh("Person").data());
 		for (unsigned int idx = 0; idx < personenXml->getLength(); idx++)
 		{
-			Person* p = 
+			Person* p =
 				processPerson(
 					static_cast<DOMElement*>(personenXml->item(idx)));
 			DsaManager::getSingleton()._addPerson(p);
 		}
-		
+
 	}
 
 	Person* XdimlLoader::processPerson(DOMElement* personXml)
@@ -222,19 +223,19 @@
 		AutoXMLCh ID = "ID";
 		AutoXMLCh ABGELEITETER_WERT = "AbgeleiteterWert";
 		AutoXMLCh EIGENSCHAFT = "Eigenschaft";
-		
-		CeGuiString name = 
+
+		CeGuiString name =
 			XmlHelper::getValueAsString(XmlHelper::getChildNamed(personXml, "Name"));
-		CeGuiString desc = 
+		CeGuiString desc =
 			XmlHelper::getValueAsString(XmlHelper::getChildNamed(personXml, "Beschreibung"));
-        
+
         //@warning replace this by correct loading process
 		Person* rval = new Person(10000);
         rval->setName(name);
         rval->setDescription(desc);
 
 		// Eigenschaften laden
-		DOMNodeList* eigensch = 
+		DOMNodeList* eigensch =
 			XmlHelper::getChildNamed(personXml, "Eigenschaften")->
 				getElementsByTagName(EIGENSCHAFT.data());
 		// Die Eigenschaftsnamen mssen durch ihre Abkrzung ersetzt werden.
@@ -242,29 +243,29 @@
 		{
 			DOMElement* eigenschXml = static_cast<DOMElement*>(eigensch->item(idx));
 			CeGuiString eigName = XmlHelper::transcodeToString(eigenschXml->getAttribute(ID.data()));
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_MUT)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_MUT)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_MUT)->getNameAbbreviation();
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KLUGHEIT)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KLUGHEIT)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_KLUGHEIT)->getNameAbbreviation();
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_INTUITION)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_INTUITION)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_INTUITION)->getNameAbbreviation();
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_CHARISMA)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_CHARISMA)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_CHARISMA)->getNameAbbreviation();
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_FINGERFERTIGKEIT)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_FINGERFERTIGKEIT)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_FINGERFERTIGKEIT)->getNameAbbreviation();
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_GEWANDTHEIT)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_GEWANDTHEIT)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_GEWANDTHEIT)->getNameAbbreviation();
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KONSTITUTION)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KONSTITUTION)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_KONSTITUTION)->getNameAbbreviation();
-			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KOERPERKRAFT)->getName()) 
+			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KOERPERKRAFT)->getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_KOERPERKRAFT)->getNameAbbreviation();
 			int wert = XmlHelper::getValueAsInteger(XmlHelper::getChildNamed(eigenschXml, "Wert"));
 
 			rval->setEigenschaft(eigName, wert);
-		}		
+		}
 
 		// Abgeleitete Werte laden
-		DOMNodeList* werte = 
+		DOMNodeList* werte =
 			XmlHelper::getChildNamed(personXml, "AbgeleiteteWerte")->
 				getElementsByTagName(ABGELEITETER_WERT.data());
 		for (unsigned int idx = 0; idx < werte->getLength(); idx++)
@@ -272,7 +273,7 @@
 			DOMElement* wertXml = static_cast<DOMElement*>(werte->item(idx));
 			int basis = XmlHelper::getValueAsInteger(XmlHelper::getChildNamed(wertXml, "Basiswert"));
 			int wert = XmlHelper::getValueAsInteger(XmlHelper::getChildNamed(wertXml, "Wert"));
-			
+
 			AutoChar wertId = wertXml->getAttribute(ID.data());
 			if (strcmp(wertId.data(), "Lebensenergie") == 0)
 				rval->setWert(rl::Creature::WERT_MOD_LE, wert - basis);
@@ -297,22 +298,22 @@
 		// Talente laden
 		// Talente, die direkt unter <Person> angeordnet sind,
         // ergeben bereits die zusammengefassten Werte
-		DOMNodeList* talente =			
+		DOMNodeList* talente =
 			XmlHelper::getChildNamed(personXml, "Talente")->
 				getElementsByTagName(TALENT.data());
 		for (unsigned int idx = 0; idx < talente->getLength(); idx++)
 		{
 			DOMElement* talentXml = static_cast<DOMElement*>(talente->item(idx));
-			
+
 			CeGuiString talentName = XmlHelper::transcodeToString(
                 talentXml->getAttribute(ID.data()));
 
-			Talent* tal = 
+			Talent* tal =
 				DsaManager::getSingleton().getTalent(talentName);
 
 			rval->addTalent(talentName);
 			rval->setTalent(
-				talentName, 
+				talentName,
 				XmlHelper::getValueAsInteger(XmlHelper::getChildNamed(talentXml, "Wert")));
 		}
 		return rval;

Modified: rl/trunk/engine/rules/src/DsaManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/DsaManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "DsaManager.h"
 
@@ -48,12 +49,12 @@
     {
         //Zufallsgenerator initialisieren
         srand(static_cast<unsigned int>(time(NULL)));
-          		  
+
 		initializeEigenschaften();
 		initializeSkt();
 
         initializeTalente();
-        initializeKampftechniken();		
+        initializeKampftechniken();
     }
 
     DsaManager::~DsaManager()

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,13 +13,14 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Effect.h"
 #include "DsaManager.h"
 
 namespace rl
 {
-   
+
 	Effect::Effect(int stufe)
 	{
 		mStufe = stufe;
@@ -96,7 +97,7 @@
       // should be overlaoaded in the specific derivated effects.
       return STATUS_NONE;
     }
-    
+
     int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
     {
       return 0;

Modified: rl/trunk/engine/rules/src/EffectFactory.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectFactory.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/EffectFactory.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,9 +13,11 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "EffectFactory.h"
 
-template <> 
+template <>
 rl::EffectFactoryManager* Ogre::Singleton<rl::EffectFactoryManager>::ms_Singleton = 0;
 
 namespace rl

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "EffectManager.h"
 #include "DsaManager.h"
@@ -46,7 +47,7 @@
 			std::cout << "Effect check: " << checkIt->first << " now: " << now << std::endl;
             for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
             {
-                int nextCheck; 
+                int nextCheck;
                 nextCheck = (*effIt)->check();
                 switch (nextCheck)
                 {
@@ -74,7 +75,7 @@
         // Insert Sum and effect into the checklist
         mChecklist[timeForCheck].insert(effect);
     }
-    
+
     void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
     {
         // Preconditions: date > now, effect != NULL
@@ -110,7 +111,7 @@
 		mEffects.insert(effect);
 		effect->enable();
 	}
-    
+
     void EffectManager::removeEffect(Effect* effect)
     {
       mEffects.erase(effect);
@@ -132,7 +133,7 @@
     }
 
 
-    
+
     Effect::Status EffectManager::getStatus()
     {
       checkEffects();
@@ -143,7 +144,7 @@
       }
       return status;
     }
-    
+
     int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
     {
       checkEffects();

Modified: rl/trunk/engine/rules/src/Eigenschaft.cpp
===================================================================
--- rl/trunk/engine/rules/src/Eigenschaft.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Eigenschaft.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Eigenschaft.h"
 

Modified: rl/trunk/engine/rules/src/EigenschaftenStateSet.cpp
===================================================================
--- rl/trunk/engine/rules/src/EigenschaftenStateSet.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/EigenschaftenStateSet.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "EigenschaftenStateSet.h"
 
@@ -39,12 +40,12 @@
 	{
 		mStartValue = newStartValue;
 	}
-	
+
 	int EigenschaftenStateSet::getPermanentModifier()
 	{
 		return mPermanentModifier;
 	}
-	
+
 	void EigenschaftenStateSet::setPermanentModifier( int newPermanentModifier )
 	{
 		mPermanentModifier = newPermanentModifier;

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "GameObject.h"
 
 #include "Action.h"
@@ -37,16 +39,16 @@
 
     const Ogre::String GameObject::CLASS_NAME = "GameObject";
 
-    const Ogre::String GameObject::PROPERTY_CLASS_ID = "classid"; 
-    const Ogre::String GameObject::PROPERTY_BASE_CLASS = "baseclass"; 
-    const Ogre::String GameObject::PROPERTY_POSITION = "position"; 
-    const Ogre::String GameObject::PROPERTY_ORIENTATION = "orientation"; 
-    const Ogre::String GameObject::PROPERTY_NAME = "name"; 
-    const Ogre::String GameObject::PROPERTY_DESCRIPTION = "description"; 
-    const Ogre::String GameObject::PROPERTY_MESHFILE = "meshfile"; 
-	const Ogre::String GameObject::PROPERTY_MESHPARTS = "meshparts"; 
-    const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = "geometrytype"; 
-    const Ogre::String GameObject::PROPERTY_MASS = "mass"; 
+    const Ogre::String GameObject::PROPERTY_CLASS_ID = "classid";
+    const Ogre::String GameObject::PROPERTY_BASE_CLASS = "baseclass";
+    const Ogre::String GameObject::PROPERTY_POSITION = "position";
+    const Ogre::String GameObject::PROPERTY_ORIENTATION = "orientation";
+    const Ogre::String GameObject::PROPERTY_NAME = "name";
+    const Ogre::String GameObject::PROPERTY_DESCRIPTION = "description";
+    const Ogre::String GameObject::PROPERTY_MESHFILE = "meshfile";
+	const Ogre::String GameObject::PROPERTY_MESHPARTS = "meshparts";
+    const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = "geometrytype";
+    const Ogre::String GameObject::PROPERTY_MASS = "mass";
     const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
     const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
 
@@ -105,12 +107,12 @@
     {
         return mClassId;
     }
-    
+
     void GameObject::setClassId(Ogre::String classId)
     {
         mClassId = classId;
     }
-        
+
     const CeGuiString GameObject::getName() const
     {
         return mName;
@@ -153,7 +155,7 @@
             Throw(NullPointerException, "Parameter action ist NULL.");
         }
 
-        mActions.push_back(make_pair(action, option));    
+        mActions.push_back(make_pair(action, option));
         LOG_MESSAGE(Logger::RULES,
             "Bei GameObject #"+Ogre::StringConverter::toString(mId)+
             " ("+getName()+") wurde Aktion "+action->getName().c_str()+" hinzugef?gt.");
@@ -173,7 +175,7 @@
             mActions.erase(it);
         }
     }
-    
+
     const ActionVector GameObject::getValidActions(Creature* actor) const
     {
         ActionVector actions;
@@ -185,7 +187,7 @@
             //if ((*it).second > ACT_NEEDS_TALENT)
             if (actor != NULL && !(*it).first->canDo(const_cast<GameObject*>(this), actor)) // Aktion nicht m?glich
                 continue;
-                
+
             actions.push_back((*it).first);
         }
         return actions;
@@ -195,13 +197,13 @@
                               Creature* actor,
                               GameObject* target)
     {
-        ActionOptionVector::const_iterator it = 
+        ActionOptionVector::const_iterator it =
             findAction(mActions.begin(), mActions.end(), actionName);
 
         if (it == mActions.end())
         {
             LOG_ERROR(
-                Logger::RULES, 
+                Logger::RULES,
                 "'" + actionName + "' ist eine dem Objekt unbekannte Aktion.");
         }
         else
@@ -221,7 +223,7 @@
     {
         action->doAction(this, actor, target);
     }
-    
+
     void GameObject::doDefaultAction(Creature* actor, GameObject* target)
     {
         Action* action = getDefaultAction(actor);
@@ -232,7 +234,7 @@
         else
         {
             LOG_ERROR(
-                Logger::RULES, 
+                Logger::RULES,
                 "GameObject " + getName() + " has no valid default action set.");
         }
     }
@@ -245,10 +247,10 @@
         return true;
     }
 
-    GameObject::ActionOptionVector::iterator 
+    GameObject::ActionOptionVector::iterator
         GameObject::findAction(
-            GameObject::ActionOptionVector::iterator begin, 
-            GameObject::ActionOptionVector::iterator end, 
+            GameObject::ActionOptionVector::iterator begin,
+            GameObject::ActionOptionVector::iterator end,
             const CeGuiString actionName)
     {
         for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
@@ -261,10 +263,10 @@
         return end;
     }
 
-    GameObject::ActionOptionVector::iterator 
+    GameObject::ActionOptionVector::iterator
         GameObject::findAction(
-            GameObject::ActionOptionVector::iterator begin, 
-            GameObject::ActionOptionVector::iterator end, 
+            GameObject::ActionOptionVector::iterator begin,
+            GameObject::ActionOptionVector::iterator end,
             const Action* action)
     {
         for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
@@ -273,7 +275,7 @@
 
         return end;
     }
-    
+
     void GameObject::setActor(Actor* actor)
     {
         if (mActor != actor)
@@ -294,11 +296,11 @@
                 }
                 actor->setGameObject(this);
             }
-            
+
             mActor = actor;
         }
     }
-    
+
     Actor* GameObject::getActor()
     {
         return mActor;
@@ -308,7 +310,7 @@
     {
         return mHighlightingEnabled;
     }
-    
+
     void GameObject::setHighlightingEnabled( bool highlightenabled )
     {
         // Leuchtet zur Zeit, sollte aber nicht leuchten
@@ -404,13 +406,13 @@
 	{
 		mEffectManager->addEffect(effect);
 	}
-    
+
     void GameObject::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
     {
       addEffect(effect);
       mEffectManager->addTimeCheck(time, effect);
     }
-    
+
     void GameObject::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
     {
       addEffect(effect);
@@ -427,7 +429,7 @@
 	{
 		mEffectManager->removeEffect(effect);
 	}
-    
+
     const Property GameObject::getProperty(const Ogre::String& key) const
     {
         Property prop;
@@ -479,7 +481,7 @@
 
     void GameObject::setProperty(const Ogre::String& key, const Property& value)
     {
-        try 
+        try
         {
             if (key == PROPERTY_POSITION)
             {
@@ -504,7 +506,7 @@
             else if (key == PROPERTY_MESHPARTS)
             {
 				PropertyMap map = value.toMap();
-				for (PropertyMap::const_iterator 
+				for (PropertyMap::const_iterator
 					it = map.begin(); it != map.end(); ++it)
 				{
 					mMeshParts[(*it).first.c_str()] = (*it).second.toString().c_str();
@@ -512,7 +514,7 @@
             }
             else if (key == PROPERTY_GEOMETRY_TYPE)
             {
-                setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));            
+                setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));
             }
             else if (key == PROPERTY_MASS)
             {
@@ -552,7 +554,7 @@
             else
             {
                 LOG_WARNING(
-                    Logger::RULES, 
+                    Logger::RULES,
                     key + " is not a property of this GameObject ("+mName+")");
             }
         }
@@ -589,7 +591,7 @@
 			if (mMeshfile.empty() && mMeshParts.empty())
 			{
 				LOG_ERROR(
-					Logger::RULES, 
+					Logger::RULES,
 					"Neither mesh file nor mesh parts are set on gameobject '" + getName()
 					+ "' (id: " + getId() + "). Can't create actor!");
 			}
@@ -614,7 +616,7 @@
 			if (actor == NULL)
 			{
 				LOG_ERROR(
-					Logger::RULES, 
+					Logger::RULES,
 					"Error creating actor '"
 					+ actorName	+ "'.");
 			}
@@ -663,7 +665,7 @@
             }
             else {
                 LOG_ERROR(
-                    Logger::RULES, 
+                    Logger::RULES,
                     "Error placing gameobject '"
                     + Ogre::StringConverter::toString(mId)
                     + "' into scene "
@@ -714,8 +716,8 @@
         else
         {
             LOG_ERROR(
-                Logger::RULES, 
-                "GameObject '" + getName() 
+                Logger::RULES,
+                "GameObject '" + getName()
                 + "' could not change state from "
                 + Ogre::StringConverter::toString(mState) + " to "
                 + Ogre::StringConverter::toString(targetstate));

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "GameObjectManager.h"
 
 #include <CEGUIPropertyHelper.h>
@@ -31,7 +33,7 @@
 #include "RubyInterpreter.h"
 #include "Weapon.h"
 
-template<> rl::GameObjectManager* 
+template<> rl::GameObjectManager*
     Ogre::Singleton<rl::GameObjectManager>::ms_Singleton = NULL;
 
 namespace rl
@@ -78,7 +80,7 @@
 
     GameObject* GameObjectManager::getGameObject(unsigned int id) const
     {
-        std::map<unsigned int, GameObject*>::const_iterator it 
+        std::map<unsigned int, GameObject*>::const_iterator it
                 = mGameObjects.find(id);
 
         if (it != mGameObjects.end())
@@ -88,12 +90,12 @@
 
         return NULL;
     }
-     
+
     std::list<const GameObject*> GameObjectManager::getAllGameObjects() const
     {
-        std::list<const GameObject*> gos;      
+        std::list<const GameObject*> gos;
         std::map<unsigned int, GameObject*>::const_iterator it;
-        
+
         //
         //    Run through all GOs and put them into the list
         //
@@ -101,7 +103,7 @@
         {
             gos.push_back(it->second);
         }
-        
+
         return gos;
     }
 
@@ -138,9 +140,9 @@
 
         GameObject* go = mGameObjectFactory
             ->createGameObject(
-                classname, 
+                classname,
                 goId);
-        
+
         go->setClassId(classId);
         go->setProperties(ps);
         mGameObjects[goId] = go;
@@ -152,14 +154,14 @@
 		CeGuiString serializedString = goProp.toString();
 
 		CeGuiString::size_type posDivider = serializedString.find("|");
-		
+
 		if (posDivider != CeGuiString::npos)
 		{
 			Ogre::String classId(serializedString.substr(0, posDivider).c_str());
 			unsigned int goid = CEGUI::PropertyHelper::stringToUint(serializedString.substr(posDivider));
 			return createGameObject(classId, goid);
 		}
-		
+
 		return NULL;
 	}
 
@@ -175,7 +177,7 @@
         {
             Throw(rl::Exception, "No properties found for classId "+classId);
         }
-        return (*it).second; 
+        return (*it).second;
     }
 
     void GameObjectManager::setGameObjectFactory(GameObjectFactory* gof)

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,8 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
-
 #include "Item.h"
 #include "Armor.h"
 #include "Weapon.h"
@@ -68,10 +68,10 @@
 	{
 	}
 
-	Inventory::~Inventory() 
+	Inventory::~Inventory()
 	{
 	}
-	
+
 	void Inventory::markDirty()
 	{
 		mValuesUpToDate = false;
@@ -98,27 +98,27 @@
 		return allItems;
 	}
 
-	int Inventory::getOverallWeight() 
+	int Inventory::getOverallWeight()
 	{
 		if (!mValuesUpToDate)
 			updateStats();
 		return mCurrentWeight;
 	}
 
-	pair<int,int> Inventory::getOverallBe() 
+	pair<int,int> Inventory::getOverallBe()
 	{
 		if (!mValuesUpToDate)
 			updateStats();
 		return make_pair<int,int>(mCurrentBe, mCurrentBeByWeight);
 	}
 
-	int Inventory::getOverallRs() 
+	int Inventory::getOverallRs()
 	{
 		if (!mValuesUpToDate)
 			updateStats();
 		return mCurrentRs;
 	}
-	
+
 	void Inventory::updateStats()
 	{
 		calculateWeight(getAllItems());
@@ -187,7 +187,7 @@
         {
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
         }
-        
+
         slotIter->second->setItem(item);
         item->setOwner(getOwner());
     }
@@ -199,7 +199,7 @@
         {
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+slotName.c_str()+"' doesn't exist.");
         }
-        
+
 		return slotIter->second->isAllowed(item);
     }
 
@@ -253,7 +253,7 @@
 				Slot* curSlot = (*it).second;
 				if (curSlot->getItem())
 				{
-					contentProp[(*it).first] = 
+					contentProp[(*it).first] =
 						GameObjectManager::getSingleton().toProperty(curSlot->getItem());
 				}
 			}
@@ -262,7 +262,7 @@
 		}
 		return prop;
 	}
-    
+
 	void Inventory::setProperty(const Ogre::String& key, const Property& value)
 	{
 		if (key == Inventory::PROPERTY_CONTENT)

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Item.h"
 
@@ -42,7 +43,7 @@
     Item::~Item(void)
     {
     }
-	
+
 	void Item::setItemType(ItemType itemType)
 	{
 		mItemType = itemType;

Modified: rl/trunk/engine/rules/src/JournalEntry.cpp
===================================================================
--- rl/trunk/engine/rules/src/JournalEntry.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/JournalEntry.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "JournalEntry.h"
 #include "QuestBook.h"

Modified: rl/trunk/engine/rules/src/Kampftechnik.cpp
===================================================================
--- rl/trunk/engine/rules/src/Kampftechnik.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Kampftechnik.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Kampftechnik.h"
 #include "DsaManager.h"

Modified: rl/trunk/engine/rules/src/ObjectStateChangeEvent.cpp
===================================================================
--- rl/trunk/engine/rules/src/ObjectStateChangeEvent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/ObjectStateChangeEvent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ObjectStateChangeEvent.h"
 
@@ -20,7 +21,7 @@
 
 namespace rl {
 
-ObjectStateChangeEvent::ObjectStateChangeEvent( ObjectStateChangeEventSource* src ) 
+ObjectStateChangeEvent::ObjectStateChangeEvent( ObjectStateChangeEventSource* src )
     : EventObject(src,0),
     mObject(NULL)
 {

Modified: rl/trunk/engine/rules/src/ObjectStateChangeEventSource.cpp
===================================================================
--- rl/trunk/engine/rules/src/ObjectStateChangeEventSource.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/ObjectStateChangeEventSource.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ObjectStateChangeEventSource.h"
 #include "ObjectStateChangeEvent.h"
@@ -25,21 +26,21 @@
     ObjectStateChangeEventSource::ObjectStateChangeEventSource( GameObject* obj ) :
 		mObjectStateChangeEventCaster(),
         mObject(obj)
-    {       
+    {
     }
 
 	ObjectStateChangeEventSource::ObjectStateChangeEventSource() :
 	mObjectStateChangeEventCaster(),
 		mObject(NULL)
-	{       
+	{
 	}
 
-    ObjectStateChangeEventSource::~ObjectStateChangeEventSource() 
+    ObjectStateChangeEventSource::~ObjectStateChangeEventSource()
     {
         removeObjectStateChangeListener();
     }
 
-    
+
 	void ObjectStateChangeEventSource::fireObjectStateChangeEvent()
 	{
 		ObjectStateChangeEvent* evt = new ObjectStateChangeEvent(this);
@@ -51,7 +52,7 @@
     void ObjectStateChangeEventSource::addObjectStateChangeListener( ObjectStateChangeListener*  list )
     {
         if( !mObjectStateChangeEventCaster.containsListener( list ) )
-        {        
+        {
             mObjectStateChangeEventCaster.addEventListener( list );
             ScriptWrapper::getSingleton().owned( list );
         }
@@ -60,7 +61,7 @@
     void ObjectStateChangeEventSource::removeObjectStateChangeListener( ObjectStateChangeListener* list )
     {
         if( mObjectStateChangeEventCaster.containsListener( list ) )
-        { 
+        {
             mObjectStateChangeEventCaster.removeEventListener( list );
             ScriptWrapper::getSingleton().owned( list );
         }
@@ -68,13 +69,13 @@
 
     void ObjectStateChangeEventSource::removeObjectStateChangeListener(  )
     {
-        EventCaster<ObjectStateChangeEvent>::EventSet arSet 
+        EventCaster<ObjectStateChangeEvent>::EventSet arSet
             = mObjectStateChangeEventCaster.getEventSet();
-        EventCaster<ObjectStateChangeEvent>::EventSet::iterator iter 
+        EventCaster<ObjectStateChangeEvent>::EventSet::iterator iter
             = arSet.begin();
-        for (iter; iter != arSet.end(); ) 
+        for (iter; iter != arSet.end(); )
         {
-            EventListener<ObjectStateChangeEvent>* ev = *iter; 
+            EventListener<ObjectStateChangeEvent>* ev = *iter;
             ObjectStateChangeListener* gal = dynamic_cast<ObjectStateChangeListener*>( ev );
             ScriptWrapper::getSingleton().disowned( gal );
             iter++;

Modified: rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp
===================================================================
--- rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/ObjectStateChangeListener.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ObjectStateChangeListener.h"
 
@@ -21,7 +22,7 @@
 namespace rl {
 
     ObjectStateChangeListener::~ObjectStateChangeListener()
-    {        
+    {
 	}
 
 	bool ObjectStateChangeListener::eventRaised(ObjectStateChangeEvent* evt)

Modified: rl/trunk/engine/rules/src/Person.cpp
===================================================================
--- rl/trunk/engine/rules/src/Person.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Person.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Person.h"
 
@@ -26,5 +27,5 @@
         mQueryFlags |= QUERYFLAG_PERSON;
 		setWert(WERT_SOZIALSTATUS, 0);
     }
-	
+
 }

Modified: rl/trunk/engine/rules/src/Quest.cpp
===================================================================
--- rl/trunk/engine/rules/src/Quest.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Quest.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include <vector>
 #include <map>
 
@@ -28,15 +30,15 @@
 
 namespace rl {
 
-const CeGuiString	Quest::STATE_NAMES[5] = 
-		{	"OPEN",		
-            "ASSIGNED",	
-            "FAILED", 
-            "SUCCEEDED", 
+const CeGuiString	Quest::STATE_NAMES[5] =
+		{	"OPEN",
+            "ASSIGNED",
+            "FAILED",
+            "SUCCEEDED",
             "COMPLETED"};
 
-const CeGuiString	Quest::KNOWN_NAMES[2] = 
-		{	"UNKNOWN",	
+const CeGuiString	Quest::KNOWN_NAMES[2] =
+		{	"UNKNOWN",
             "KNOWN"};
 
 const Ogre::String Quest::PROP_NAME = "str_name";
@@ -60,7 +62,7 @@
 
 Quest::~Quest()
 {
-    for( QuestVector::iterator it = mSubquests.begin(); 
+    for( QuestVector::iterator it = mSubquests.begin();
         it != mSubquests.end(); it++ )
            ScriptWrapper::getSingleton().disowned( (*it) );
     mSubquests.clear();
@@ -99,11 +101,11 @@
 		return mPartsDone;
 
 	int done = 0;
-	for(QuestVector::const_iterator it = mSubquests.begin(); 
+	for(QuestVector::const_iterator it = mSubquests.begin();
 		it != mSubquests.end(); it++)
 	{
 		Quest* cur = (*it);
-		if (cur->getState() == Quest::COMPLETED 
+		if (cur->getState() == Quest::COMPLETED
 			|| cur->getState() == Quest::SUCCEEDED)
 			done++;
 	}
@@ -244,15 +246,15 @@
 
 Quest::State Quest::getStateFromName(const CeGuiString stateName)
 {
-	if (stateName == Quest::STATE_NAMES[Quest::OPEN]) 
+	if (stateName == Quest::STATE_NAMES[Quest::OPEN])
 		return Quest::OPEN;
-	else if (stateName == Quest::STATE_NAMES[Quest::FAILED]) 
+	else if (stateName == Quest::STATE_NAMES[Quest::FAILED])
 		return Quest::FAILED;
-	else if (stateName == Quest::STATE_NAMES[Quest::COMPLETED]) 
+	else if (stateName == Quest::STATE_NAMES[Quest::COMPLETED])
 		return Quest::COMPLETED;
-	else if (stateName == Quest::STATE_NAMES[Quest::SUCCEEDED]) 
+	else if (stateName == Quest::STATE_NAMES[Quest::SUCCEEDED])
 		return Quest::SUCCEEDED;
-	else if (stateName == Quest::STATE_NAMES[Quest::ASSIGNED]) 
+	else if (stateName == Quest::STATE_NAMES[Quest::ASSIGNED])
 		return Quest::ASSIGNED;
 
 	const char* msg = (stateName + " is no valid quest state.").c_str();
@@ -267,7 +269,7 @@
 		return true;
 
 	Throw(
-		IllegalArgumentException, 
+		IllegalArgumentException,
 		(knownName + " is no valid quest known state.").c_str());
 }
 
@@ -332,7 +334,7 @@
 PropertySet* Quest::getAllProperties() const
 {
     PropertySet* ps = PropertySet::getAllProperties();
-    
+
     ps->setProperty(PROP_NAME, Property(mName));
     ps->setProperty(PROP_DESCRIPTION, Property(mDescription));
     ps->setProperty(PROP_KNOWN, Property(mKnown));

Modified: rl/trunk/engine/rules/src/QuestBook.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestBook.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/QuestBook.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "QuestBook.h"
 #include "Quest.h"
@@ -36,7 +37,7 @@
 QuestBook::~QuestBook()
 {
 	delete mRootQuest;
-    for( vector<JournalEntry*>::iterator it = mJournalEntries.begin(); 
+    for( vector<JournalEntry*>::iterator it = mJournalEntries.begin();
         it != mJournalEntries.end(); it++ )
         delete (*it);
     mJournalEntries.clear();
@@ -91,7 +92,7 @@
         Throw(AssertionFailedError, "listener registration inconsistent");
     }
 	else if (!mJournalEventCaster.containsListener(listener))
-    {    
+    {
 		mJournalEventCaster.addEventListener(listener);
 		mQuestEventCaster.addEventListener(listener);
         ScriptWrapper::getSingleton().owned( listener );
@@ -105,7 +106,7 @@
     {
         Throw(AssertionFailedError, "listener registration inconsistent");
     }
-	else if (mJournalEventCaster.containsListener( listener )) 
+	else if (mJournalEventCaster.containsListener( listener ))
     {
 	    mJournalEventCaster.removeEventListener(listener);
 	    mQuestEventCaster.removeEventListener(listener);

Modified: rl/trunk/engine/rules/src/QuestEvent.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestEvent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/QuestEvent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "QuestEvent.h"
 

Modified: rl/trunk/engine/rules/src/QuestListener.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestListener.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/QuestListener.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "QuestListener.h"
 

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "RulesSubsystem.h"
 #include "ActionManager.h"
@@ -45,15 +46,15 @@
         srand(static_cast<unsigned int>(time(NULL)));
 
         //Singletons erzeugen
-        mActionManager = new ActionManager(); 
+        mActionManager = new ActionManager();
 		LOG_MESSAGE(Logger::RULES, "ActionManager erzeugt");
-        mCombatManager = new CombatManager(); 
+        mCombatManager = new CombatManager();
 		LOG_MESSAGE(Logger::RULES, "CombatManager erzeugt");
         mDsaManager = new DsaManager();
 		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
         mMovingCreatureManager = new CreatureControllerManager();
 		LOG_MESSAGE(Logger::RULES, "CreatureControllerManager erzeugt");
-        mTimerManager = new TimerManager(); 
+        mTimerManager = new TimerManager();
 		LOG_MESSAGE(Logger::RULES, "TimerManager erzeugt");
 		resetQuestBook();
 		LOG_MESSAGE(Logger::RULES, "Questverwaltung erzeugt");
@@ -61,12 +62,12 @@
 		//Daten laden
 		mXdimlLoader = new XdimlLoader();
 		LOG_MESSAGE(Logger::RULES, "Basisdaten geladen");
-		
+
         new EffectFactoryManager();
         new GameObjectManager();
-		LOG_MESSAGE(Logger::RULES, "Erzeugen abgeschlossen");		
+		LOG_MESSAGE(Logger::RULES, "Erzeugen abgeschlossen");
     }
-	
+
 	RulesSubsystem::~RulesSubsystem()
     {
         delete mQuestBook;

Modified: rl/trunk/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/trunk/engine/rules/src/SelectionHelper.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/SelectionHelper.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "SelectionHelper.h"
 
 #include "Actor.h"
@@ -63,7 +65,7 @@
             targetPos += actor2->getWorldOrientation() *
                 physical->getDefaultSize().getCenter();
         }
-        
+
         // Setup and execute raycast. Set result to be ordered by distance
         BasicRaycast raycast = BasicRaycast(PhysicsManager::getSingleton()._getNewtonWorld(),
             startPos, targetPos, true);

Modified: rl/trunk/engine/rules/src/Selector.cpp
===================================================================
--- rl/trunk/engine/rules/src/Selector.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Selector.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
+
 #include "Selector.h"
 #include "SelectionHelper.h"
 
@@ -59,7 +61,7 @@
         return false;
     }
 
-    Selector::Selector(unsigned long mask) 
+    Selector::Selector(unsigned long mask)
 		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
     {
     }

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "Slot.h"
 
 #include "Actor.h"
@@ -110,17 +112,17 @@
 				else
 				{
 					if (isAllowed(item))
-					{			
+					{
 						item->setState(GOS_IN_POSSESSION);
 						mmo->replaceSubmesh(
-							mSubmesh, 
+							mSubmesh,
 							item->getMeshfile().c_str());
 						mItem = item;
 					}
 				}
 			}
 
-            if (mOwner->getActor() 
+            if (mOwner->getActor()
                 && mOwner->getActor()->getPhysicalThing())
             {
                 mOwner->getActor()->getPhysicalThing()->updatePhysicsProxy();

Modified: rl/trunk/engine/rules/src/SonderfertigkeitenStateSet.cpp
===================================================================
--- rl/trunk/engine/rules/src/SonderfertigkeitenStateSet.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/SonderfertigkeitenStateSet.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "SonderfertigkeitenStateSet.h"
 #include "Exception.h"

Modified: rl/trunk/engine/rules/src/StateSet.cpp
===================================================================
--- rl/trunk/engine/rules/src/StateSet.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/StateSet.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "StateSet.h"
 
@@ -66,7 +67,7 @@
 	{
 		mModifier += modifier;
 	}
-	
+
 	int StateSet::getProbenModifier() const
 	{
 		return mProbenModifier;
@@ -81,7 +82,7 @@
 	{
 		mProbenModifier += modifier;
 	}
-	
+
 	int StateSet::getMultiplier() const
 	{
 		return mMultiplier;

Modified: rl/trunk/engine/rules/src/Talent.cpp
===================================================================
--- rl/trunk/engine/rules/src/Talent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Talent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Talent.h"
 #include "DsaManager.h"
@@ -65,7 +66,7 @@
 			return 0;
 		if (mEbe == EBE_BEx2)
 			return be*2;
-		
+
 		return std::max(be + mEbe, 0);
 	}
 

Modified: rl/trunk/engine/rules/src/TalentStateSet.cpp
===================================================================
--- rl/trunk/engine/rules/src/TalentStateSet.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/TalentStateSet.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "TalentStateSet.h"
 

Modified: rl/trunk/engine/rules/src/Talentgruppe.cpp
===================================================================
--- rl/trunk/engine/rules/src/Talentgruppe.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Talentgruppe.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,3 +1,6 @@
+
+#include "stdinc.h"
+
 #include "Talentgruppe.h"
 
 namespace rl

Modified: rl/trunk/engine/rules/src/TimerEvent.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerEvent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/TimerEvent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "TimerEvent.h"
 
@@ -20,7 +21,7 @@
 
 namespace rl {
 
-TimerEvent::TimerEvent( TimerEventSource* src ) 
+TimerEvent::TimerEvent( TimerEventSource* src )
     : EventObject(src,0)
 {
 

Modified: rl/trunk/engine/rules/src/TimerEventSource.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "TimerEventSource.h"
 
@@ -38,7 +39,7 @@
 		mDsaTime(0L),
 		mDsaTimeLastCall(0L),
 		mDsaTimeRepeatInterval(0L)
-	{ 
+	{
 		TimerManager::getSingleton().registerTimerEventSource(this);
 	}
 
@@ -51,22 +52,22 @@
 		mDsaTime(time),
 		mDsaTimeRepeatInterval(repeat),
 		mDsaTimeLastCall(0L)
-	{       
+	{
 		TimerManager::getSingleton().registerTimerEventSource(this);
 	}
 
-    TimerEventSource::~TimerEventSource() 
+    TimerEventSource::~TimerEventSource()
     {
 		TimerManager::getSingleton().unregisterTimerEventSource(this);
 
 		// Alle TimerListener
-		EventCaster<TimerEvent>::EventSet evSet 
+		EventCaster<TimerEvent>::EventSet evSet
 			= mTimerEventCaster.getEventSet();
-		EventCaster<TimerEvent>::EventSet::iterator citer 
+		EventCaster<TimerEvent>::EventSet::iterator citer
 			= evSet.begin();
-		for (citer; citer != evSet.end(); ) 
+		for (citer; citer != evSet.end(); )
 		{
-			EventListener<TimerEvent>* ev = *citer; 
+			EventListener<TimerEvent>* ev = *citer;
 			TimerListener* al = dynamic_cast<TimerListener*>( ev );
 			ScriptWrapper::getSingleton().disowned( al );
 			citer++;
@@ -74,7 +75,7 @@
         mTimerEventCaster.removeEventListeners();
     }
 
-    
+
 	void TimerEventSource::fireTimerEvent()
 	{
 		TimerEvent* evt = new TimerEvent(this);

Modified: rl/trunk/engine/rules/src/TimerListener.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerListener.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/TimerListener.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "TimerListener.h"
 
@@ -22,7 +23,7 @@
 namespace rl {
 
     TimerListener::~TimerListener()
-    {        
+    {
 	}
 
 	bool TimerListener::eventRaised(TimerEvent* evt)

Modified: rl/trunk/engine/rules/src/TimerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/TimerManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "TimerManager.h"
 
@@ -39,7 +40,7 @@
 
 	TimerManager::~TimerManager()
 	{
-		for (std::set<TimerEventSource*>::iterator timerIter = mTimers.begin(); 
+		for (std::set<TimerEventSource*>::iterator timerIter = mTimers.begin();
 			timerIter != mTimers.end();timerIter++)
 		{
 			TimerEventSource* currTimer = *timerIter;
@@ -54,7 +55,7 @@
 		RL_LONGLONG nowDsa = DsaManager::getSingleton().getTimestamp();
 		RL_LONGLONG now = GameLoop::getSingleton().getClock();
 
-		for (std::set<TimerEventSource*>::iterator timerIter = mTimers.begin(); 
+		for (std::set<TimerEventSource*>::iterator timerIter = mTimers.begin();
 			timerIter != mTimers.end();)
 		{
 			TimerEventSource* currTimer = *timerIter;
@@ -71,7 +72,7 @@
 	}
 
 	void TimerManager::registerTimerEventSource(TimerEventSource* source)
-	{	
+	{
 		if (mTimers.find(source) != mTimers.end())
 		{
             Throw(IllegalArgumentException, "TimerEventSource already registered.");

Modified: rl/trunk/engine/rules/src/Weapon.cpp
===================================================================
--- rl/trunk/engine/rules/src/Weapon.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/Weapon.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "DsaManager.h"
 #include "Weapon.h"
@@ -156,7 +157,7 @@
         {
             mKampftechnik = value.toString();
         }
-        else 
+        else
         {
             Item::setProperty(key, value);
         }

Modified: rl/trunk/engine/rules/src/ZauberStateSet.cpp
===================================================================
--- rl/trunk/engine/rules/src/ZauberStateSet.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/ZauberStateSet.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ZauberStateSet.h"
 

Added: rl/trunk/engine/rules/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/rules/src/stdinc.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/rules/src/stdinc.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,17 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+#include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -39,16 +39,18 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				SmallerTypeCheck="true"
 				RuntimeLibrary="3"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="false"
 				DebugInformationFormat="4"
@@ -128,11 +130,13 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="false"
 				DebugInformationFormat="3"
@@ -210,11 +214,13 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES"
+				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="false"
 				DebugInformationFormat="3"
@@ -285,6 +291,34 @@
 				RelativePath=".\src\ScriptSubsystem.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\src\stdinc.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
 			<Filter
 				Name="map loading"
 				>
@@ -348,6 +382,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\stdinc.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\TriggerFactory.h"
 				>
 			</File>
@@ -373,27 +411,21 @@
 						Name="Debug|Win32"
 						>
 						<Tool
-							Name="VCCLCompilerTool"
-							ObjectFile="$(IntDir)\$(InputName)1.obj"
-							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+							Name="VCCustomBuildTool"
 						/>
 					</FileConfiguration>
 					<FileConfiguration
 						Name="Release|Win32"
 						>
 						<Tool
-							Name="VCCLCompilerTool"
-							ObjectFile="$(IntDir)\$(InputName)1.obj"
-							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+							Name="VCCustomBuildTool"
 						/>
 					</FileConfiguration>
 					<FileConfiguration
 						Name="Release with Symbols|Win32"
 						>
 						<Tool
-							Name="VCCLCompilerTool"
-							ObjectFile="$(IntDir)\$(InputName)1.obj"
-							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+							Name="VCCustomBuildTool"
 						/>
 					</FileConfiguration>
 				</File>
@@ -428,27 +460,21 @@
 						Name="Debug|Win32"
 						>
 						<Tool
-							Name="VCCLCompilerTool"
-							ObjectFile="$(IntDir)\$(InputName)1.obj"
-							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+							Name="VCCustomBuildTool"
 						/>
 					</FileConfiguration>
 					<FileConfiguration
 						Name="Release|Win32"
 						>
 						<Tool
-							Name="VCCLCompilerTool"
-							ObjectFile="$(IntDir)\$(InputName)1.obj"
-							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+							Name="VCCustomBuildTool"
 						/>
 					</FileConfiguration>
 					<FileConfiguration
 						Name="Release with Symbols|Win32"
 						>
 						<Tool
-							Name="VCCLCompilerTool"
-							ObjectFile="$(IntDir)\$(InputName)1.obj"
-							XMLDocumentationFileName="$(IntDir)\$(InputName)1.xdc"
+							Name="VCCustomBuildTool"
 						/>
 					</FileConfiguration>
 				</File>
@@ -497,6 +523,30 @@
 			<File
 				RelativePath=".\swig\RlExports_wrap.cxx"
 				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
 			</File>
 			<File
 				RelativePath=".\swig\RlExports_wrap.h"

Added: rl/trunk/engine/script/include/stdinc.h
===================================================================
--- rl/trunk/engine/script/include/stdinc.h	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/include/stdinc.h	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,107 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+/*
+ * This file is used for precompiled header generation. You have to
+ * include it in all cpp files which have "Use Precompiled Header"
+ * set in their C/C++ properties. It shall never be included in other
+ * headers.
+ *
+ * The content of this file should be limited to the following include
+ * types:
+ *   - stdlib headers
+ *   - stl headers
+ *   - all types of external dependencies which will never be changed by us
+ *
+ * Every sub project should have it's own copy of this file and may have
+ * project specific modifications
+ */
+
+#ifndef __stdinc_h__
+#define __stdinc_h__
+
+#ifdef RL_USE_PCH
+
+#include <string>
+#include <vector>
+#include <list>
+#include <map>
+#include <set>
+
+#include <iostream>
+#include <sstream>
+
+#include <functional>
+#include <algorithm>
+#include <utility>
+
+#include <OgreCommon.h>
+#include <OgreConfigFile.h>
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreMath.h>
+#include <OgreVector3.h>
+#include <OgreSingleton.h>
+#include <OgreLog.h>
+#include <OgreLogManager.h>
+#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
+#include <OgreResource.h>
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
+#include <OgreUserDefinedObject.h>
+#include <OgreMovableObject.h>
+#include <OgreManualObject.h>
+#include <OgreNode.h>
+#include <OgreCamera.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <OgreLight.h>
+#include <OgreQuaternion.h>
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <OgreRenderable.h>
+#include <OgreParticleSystem.h>
+#include <OgreSceneQuery.h>
+#include <OgreSceneManager.h>
+#include <OgreSceneNode.h>
+#include <OgreAnimationState.h>
+#include <OgreRay.h>
+#include <OgreMeshManager.h>
+#include <OgreBillboardParticleRenderer.h>
+#include <OgreTextureManager.h>
+#include <OgreException.h>
+#include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
+
+#include <OgreNewt.h>
+#include <OgreNewt_ContactCallback.h>
+#include <OgreNewt_Collision.h>
+#include <OgreNewt_RayCast.h>
+
+#include <CEGUIString.h>
+#include <CEGUILogger.h>
+
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+#include <boost/any.hpp>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#  include <Windows.h>
+#endif
+
+#endif//RL_USE_PCH
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "AbstractMapNodeProcessor.h"
 
 #include <OgreColourValue.h>
@@ -30,7 +32,7 @@
       mXmlPropertyReader()
     {
     }
-    
+
     AbstractMapNodeProcessor::~AbstractMapNodeProcessor()
     {
         delete mXmlPropertyReader;
@@ -83,7 +85,7 @@
 
         return rval;
     }
-    
+
     ColourValue AbstractMapNodeProcessor::processColour(DOMElement* colElem) const
     {
         ColourValue rval(1, 1, 1, 1);
@@ -117,7 +119,7 @@
         rval << baseName << "_" << ++ival;
         return rval.str();
     }
-    
+
     void AbstractMapNodeProcessor::setRootSceneNode(Ogre::SceneNode* node)
     {
         mRootSceneNode = node;
@@ -127,7 +129,7 @@
     {
         return mRootSceneNode;
     }
-    
+
     XmlPropertyReader* AbstractMapNodeProcessor::getXmlPropertyReader() const
     {
         return mXmlPropertyReader;

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "EntityNodeProcessor.h"
 
 #include <OgreEntity.h>
@@ -42,11 +44,11 @@
         {
             return false;
         }
-    
+
         Ogre::String entName = XmlHelper::getAttributeValueAsStdString(nodeElem, "name");
 
-        LOG_DEBUG(Logger::RULES, 
-            "Processing entity node " 
+        LOG_DEBUG(Logger::RULES,
+            "Processing entity node "
                 + entName);
 
         if (!XmlHelper::hasAttribute(nodeElem, "meshfile"))
@@ -54,7 +56,7 @@
             LOG_ERROR(Logger::RULES, "Entity node defines no meshfile attribute");
             return false;
         }
-        
+
         Ogre::String meshFile = XmlHelper::getAttributeValueAsStdString(nodeElem, "meshfile");
         if (entName == "")
         {
@@ -73,7 +75,7 @@
         {
             position = processVector3(posElem);
         }
-        else 
+        else
         {
             LOG_WARNING(Logger::RULES, "No position given for entity, used (0,0,0)");
         }
@@ -83,7 +85,7 @@
         {
             orientation = processQuaternion(oriElem);
         }
-        else 
+        else
         {
             LOG_WARNING(Logger::RULES, "No orientation given for entity, used Identity");
         }
@@ -137,14 +139,14 @@
 				processAnimation(newEnt, static_cast<DOMElement*>(cur));
 			}
 		}
-        
+
         return true;
     }
 
     void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, DOMElement* physicsProxyElem)
 	{
         std::vector<OgreNewt::CollisionPtr> collisions;
-        
+
         Ogre::String physicsProxyType;
         if (physicsProxyElem == NULL || !XmlHelper::hasAttribute(physicsProxyElem, "type"))
         {

Modified: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "EnvironmentProcessor.h"
 
@@ -47,7 +48,7 @@
 			return;
 		}
 
-		if (!XmlHelper::hasAttribute(skyElem, "material") 
+		if (!XmlHelper::hasAttribute(skyElem, "material")
 			|| !XmlHelper::hasAttribute(skyElem, "type"))
 		{
 			LOG_ERROR(Logger::RULES, "<sky> element must have at least attributes 'type' and 'material'.");
@@ -62,12 +63,12 @@
 			{
 				drawFirst = XmlHelper::getAttributeValueAsBool(skyElem, "drawfirst");
 			}
-			
+
 			Ogre::Real distance = 5000;
 			if (XmlHelper::hasAttribute(skyElem, "distance"))
 			{
 				distance = XmlHelper::getAttributeValueAsReal(skyElem, "distance");
-			}				
+			}
 
 			if (type == "dome")
 			{
@@ -107,7 +108,7 @@
 		if (!XmlHelper::hasAttribute(fogElem, "material"))
 		{
 			LOG_ERROR(
-				Logger::RULES, 
+				Logger::RULES,
 				"<fog> element must have at least the attribute 'type'.");
 			return;
 		}

Modified: rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "GameObjectNodeProcessor.h"
 
 #include <xercesc/dom/DOM.hpp>
@@ -33,13 +35,13 @@
         {
             return false;
         }
-    
-        LOG_DEBUG(Logger::RULES, 
-            "Processing game object node " 
+
+        LOG_DEBUG(Logger::RULES,
+            "Processing game object node "
                 + XmlHelper::getAttributeValueAsStdString(nodeElem, "name"));
-        
+
         Ogre::String classname = XmlHelper::getAttributeValueAsStdString(nodeElem, "class");
-        
+
         unsigned int goid = GameObject::NO_OBJECT_ID;
 
         if (XmlHelper::hasAttribute(nodeElem, "id"))
@@ -67,7 +69,7 @@
         for (XMLSize_t idx = 0; idx < goElChildNodes->getLength(); idx++)
         {
             DOMNode* cur = goElChildNodes->item(idx);
-            if (cur->getNodeType() == DOMNode::ENTITY_NODE 
+            if (cur->getNodeType() == DOMNode::ENTITY_NODE
                 && XmlHelper::hasNodeName(cur, "property"))
             {
                 PropertyEntry propEntry = getXmlPropertyReader()->processProperty(static_cast<DOMElement*>(cur));

Modified: rl/trunk/engine/script/src/LightNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/LightNodeProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/LightNodeProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "LightNodeProcessor.h"
 
 #include "XmlHelper.h"
@@ -32,15 +34,15 @@
             return false;
         }
 
-        LOG_DEBUG(Logger::RULES, 
-            "Processing light node " 
+        LOG_DEBUG(Logger::RULES,
+            "Processing light node "
                 + XmlHelper::getAttributeValueAsStdString(nodeElem, "name"));
-                
+
         Ogre::String name = XmlHelper::getAttributeValueAsStdString(nodeElem, "name");
         Ogre::String stype = XmlHelper::getAttributeValueAsStdString(nodeElem, "type");
         bool visible = XmlHelper::getAttributeValueAsBool(nodeElem, "visible");
         bool shadowCaster = XmlHelper::getAttributeValueAsBool(nodeElem, "castShadows");
-        
+
         LightObject::LightTypes type = LightObject::LT_DIRECTIONAL;
         if (stype == "point")
         {
@@ -75,13 +77,13 @@
 
         light->setCastShadows(shadowCaster);
         light->setVisible(visible);
-        
+
         DOMElement* diffElem = XmlHelper::getChildNamed(nodeElem, "colourDiffuse");
         if (diffElem != NULL)
         {
             light->setDiffuseColour(processColour(diffElem));
         }
-        
+
         DOMElement* specElem = XmlHelper::getChildNamed(nodeElem, "colourSpecular");
         if (specElem != NULL)
         {
@@ -93,7 +95,7 @@
         {
             if (XmlHelper::hasAttribute(attElem, "range")
                 && XmlHelper::hasAttribute(attElem, "constant")
-                && XmlHelper::hasAttribute(attElem, "linear") 
+                && XmlHelper::hasAttribute(attElem, "linear")
                 && XmlHelper::hasAttribute(attElem, "quadratic"))
             {
                 Ogre::Real range = XmlHelper::getAttributeValueAsReal(attElem, "range");

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include <xercesc/dom/DOM.hpp>
 #include <xercesc/parsers/XercesDOMParser.hpp>
 #include <xercesc/util/PlatformUtils.hpp>
@@ -45,7 +47,7 @@
 namespace rl {
 
     using XERCES_CPP_NAMESPACE::DOMDocument; //XXX: for VS 2003/2005
-    
+
     MapLoader::MapLoader(const Ogre::String& resourceGroup)
         : mRootSceneNode(NULL),
           mResourceGroup(resourceGroup),
@@ -62,7 +64,7 @@
 
     MapLoader::~MapLoader()
     {
-        for (list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin(); 
+        for (list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin();
             it != mNodeProcessors.end(); ++it)
         {
             delete *it;
@@ -81,7 +83,7 @@
 
         parser->setValidationScheme(XercesDOMParser::Val_Auto);    // optional.
         parser->setDoNamespaces(true);    // optional
-		
+
         XmlPtr res = XmlResourceManager::getSingleton().getByName(mapresource);
         if (res.isNull())
         {
@@ -93,35 +95,35 @@
             }
             res = XmlResourceManager::getSingleton().create(mapresource, group);
         }
-                
+
         if (!res.isNull())
         {
             res->parseBy(parser);
-    
+
             setRootSceneNode(CoreSubsystem::getSingleton().getWorld()
                     ->getSceneManager()->getRootSceneNode()->createChildSceneNode(mapresource));
 
             DOMDocument* doc = parser->getDocument();
             DOMElement* dataDocumentContent = doc->getDocumentElement();
-            
+
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
 			///@todo: Window fade jobs don't work if Core is paused, think about solution for: CoreSubsystem::getSingleton().setPaused(true);
-            
+
             LOG_MESSAGE(Logger::RULES, "Processing nodes");
-            
+
             processSceneNodes(XmlHelper::getChildNamed(dataDocumentContent, "nodes"), loadGameObjects);
-            
+
 			ZoneProcessor zp;
 			zp.processNode(XmlHelper::getChildNamed(dataDocumentContent, "zones"), loadGameObjects);
-			
+
 			EnvironmentProcessor ep;
 			ep.processNode(XmlHelper::getChildNamed(dataDocumentContent, "environment"), loadGameObjects);
-            
+
 			WaypointProcessor wp;
 			wp.processNode(XmlHelper::getChildNamed(dataDocumentContent, "waypoints"), loadGameObjects);
-            
+
             LOG_MESSAGE(Logger::RULES, "Map loaded");
-    
+
             doc->release();
 
 			CoreSubsystem::getSingleton().getWorld()->initializeDefaultCamera();
@@ -131,7 +133,7 @@
         {
             LOG_ERROR(Logger::RULES, "Map resource '" + mapresource + "' not found");
         }
-       
+
 		XMLPlatformUtils::Terminate();
     }
 
@@ -146,8 +148,8 @@
         Ogre::Real numChildren = nodesElem->getChildNodes()->getLength();
         int count = 0;
 
-        for (DOMNode* cur = nodesElem->getFirstChild(); 
-            cur != NULL; 
+        for (DOMNode* cur = nodesElem->getFirstChild();
+            cur != NULL;
             cur = cur->getNextSibling())
         {
             if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
@@ -159,7 +161,7 @@
                 {
                     ++it;
                 }
-                
+
                 if (it == mNodeProcessors.end())
                 {
                     LOG_WARNING(Logger::RULES,
@@ -170,7 +172,7 @@
 			count += 1;
             if (count % 250 == 0)
             {
-                setLoadingPercentage(count/numChildren, 
+                setLoadingPercentage(count/numChildren,
                     Ogre::StringConverter::toString(count/numChildren*100.0f, 0) + "%");
             }
         }
@@ -181,7 +183,7 @@
     void MapLoader::setRootSceneNode(SceneNode* node)
     {
         mRootSceneNode = node;
-        for (list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin(); 
+        for (list<AbstractMapNodeProcessor*>::const_iterator it = mNodeProcessors.begin();
             it != mNodeProcessors.end(); ++it)
         {
             (*it)->setRootSceneNode(node);
@@ -210,5 +212,5 @@
             mPercentageWindow = NULL;
         }
     }
-    
+
 } // namespace rl

Modified: rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "ParticleSystemNodeProcessor.h"
 
 #include "XmlHelper.h"
@@ -41,7 +43,7 @@
 
 		Ogre::String name = XmlHelper::getAttributeValueAsStdString(nodeElem, "name");
 
-		LOG_DEBUG(Logger::SCRIPT, 
+		LOG_DEBUG(Logger::SCRIPT,
             "Processing particle system node " + name);
 
 		Ogre::String material = XmlHelper::getAttributeValueAsStdString(nodeElem, "material");

Modified: rl/trunk/engine/script/src/ScriptObjectMarker.cpp
===================================================================
--- rl/trunk/engine/script/src/ScriptObjectMarker.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/ScriptObjectMarker.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ScriptObjectMarker.h"
 
@@ -63,11 +64,11 @@
         unsigned int refCount = 1;
 
         // Es gab schon einen RefCount, dann diesen hochz?hlen
-        if( iter != m_RubyRefCountMap.end() )         
+        if( iter != m_RubyRefCountMap.end() )
             refCount = iter->second + 1;
 
         // In Liste einf?gen
-        m_RubyRefCountMap.insert( ValueCountPair( val, refCount ) ); 
+        m_RubyRefCountMap.insert( ValueCountPair( val, refCount ) );
 
         // refCount wurde 1, beim GC anmelden
         if( refCount == 1 )
@@ -80,16 +81,16 @@
     void ScriptObjectMarker::disowned( void* ptr )
     {
         VALUE val = RL_RubyInstanceFor(ptr);
-        
+
         // Hat kein Skript Equivalent, muss nicht verwaltet werden
         if( val == Qnil )
             return;
 
         ValueCountMap::iterator iter = m_RubyRefCountMap.find( val );
         // Gibt es ?berhaupt noch einen RefCount?
-        if( iter == m_RubyRefCountMap.end() )   
+        if( iter == m_RubyRefCountMap.end() )
             return;
-        
+
         // Alter RefCount
         unsigned int refCount = iter->second;
 
@@ -99,7 +100,7 @@
             // Herunterz?hlen
             refCount = refCount--;
             // Neu einspeichern
-            m_RubyRefCountMap.insert( ValueCountPair(val, refCount ) ); 
+            m_RubyRefCountMap.insert( ValueCountPair(val, refCount ) );
         }
         // Null geworden
         if( refCount <= 1 )
@@ -135,7 +136,7 @@
 			test->basic.klass = rb_cNilClass;
 			// Nicht l?schen, ist der ptr
 			test->data = NULL;
-			
+
         }
         catch (IllegalArgumentException& ) {}
     }

Modified: rl/trunk/engine/script/src/ScriptSubsystem.cpp
===================================================================
--- rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ScriptSubsystem.h"
 #include "ScriptObjectMarker.h"
@@ -27,7 +28,7 @@
     ScriptSubsystem::ScriptSubsystem()
 		: mScriptObjectMarker(NULL), mTriggerFactory(NULL)
     {
-        mScriptObjectMarker = new ScriptObjectMarker();	
+        mScriptObjectMarker = new ScriptObjectMarker();
     }
 
     ScriptSubsystem::~ScriptSubsystem()

Modified: rl/trunk/engine/script/src/SoundNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "SoundNodeProcessor.h"
 
 #include "XmlHelper.h"
@@ -29,8 +31,8 @@
             return false;
         }
 
-        LOG_DEBUG(Logger::RULES, 
-            "Processing sound node " 
+        LOG_DEBUG(Logger::RULES,
+            "Processing sound node "
                 + XmlHelper::getAttributeValueAsStdString(nodeElem, "name"));
 
 

Modified: rl/trunk/engine/script/src/UnifiedFactory.cpp
===================================================================
--- rl/trunk/engine/script/src/UnifiedFactory.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/UnifiedFactory.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,3 +1,6 @@
+
+#include "stdinc.h"
+
 #include "..\include\UnifiedFactory.h"
 
 UnifiedFactory::UnifiedFactory(void)

Modified: rl/trunk/engine/script/src/WaypointProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/WaypointProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/WaypointProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "WaypointProcessor.h"
 
@@ -57,11 +58,11 @@
 				Ogre::String name;
 
 				LandmarkPath* path = AiSubsystem::getSingleton().createLandmarkPath(name);
-				
-				for (DOMNode* curPathChild = nodeElem->getFirstChild(); 
+
+				for (DOMNode* curPathChild = nodeElem->getFirstChild();
 					curPathChild != NULL; curPathChild = curPathChild->getNextSibling())
 				{
-					if (curPathChild->getNodeType() == DOMNode::ELEMENT_NODE 
+					if (curPathChild->getNodeType() == DOMNode::ELEMENT_NODE
 						&& XmlHelper::hasNodeName(curPathChild, "landmark"))
 					{
 						DOMElement* curLmElem = static_cast<DOMElement*>(curPathChild);

Modified: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "ZoneProcessor.h"
 
@@ -57,7 +58,7 @@
 						///@todo: zone = ZoneManager::getSingleton().createZone(...);
 					}
 					else if (type == "sphere")
-					{						
+					{
 						Vector3 center = Vector3::ZERO;
 						DOMElement* centerElem = XmlHelper::getChildNamed(curZoneElem, "center");
 						if (centerElem != NULL)
@@ -97,7 +98,7 @@
 								}
 								else if (XmlHelper::hasNodeName(curElem, "trigger"))
 								{
-									Ogre::String classname = 
+									Ogre::String classname =
 										XmlHelper::getAttributeValueAsStdString(curElem, "classname");
 
 									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()

Added: rl/trunk/engine/script/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/script/src/stdinc.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/script/src/stdinc.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,17 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+#include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -46,9 +46,10 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
-				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				SmallerTypeCheck="true"
@@ -56,7 +57,9 @@
 				BufferSecurityCheck="false"
 				EnableFunctionLevelLinking="false"
 				RuntimeTypeInfo="true"
-				PrecompiledHeaderFile=".\obj\Debug/Rastullah.pch"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
+				PrecompiledHeaderFile="$(IntDir)\$(TargetName).pch"
 				ExpandAttributedSource="true"
 				AssemblerOutput="4"
 				AssemblerListingLocation=".\obj\Debug/"
@@ -155,18 +158,20 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
-				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\obj\Release/Rastullah.pch"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
+				PrecompiledHeaderFile="$(IntDir)\$(TargetName).pch"
 				AssemblerListingLocation=".\obj\Release/"
 				ObjectFile=".\obj\Release/"
 				ProgramDataBaseFileName=".\obj\Release/"
@@ -257,18 +262,20 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
+				AdditionalOptions="-Zm130"
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
 				AdditionalIncludeDirectories=".\include;;..\common\include;..\dialog\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
-				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="false"
 				RuntimeTypeInfo="true"
-				UsePrecompiledHeader="0"
-				PrecompiledHeaderFile=".\obj\Release/Rastullah.pch"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderThrough="stdinc.h"
+				PrecompiledHeaderFile="$(IntDir)\$(TargetName).pch"
 				AssemblerListingLocation=".\obj\Release/"
 				ObjectFile=".\obj\Release/"
 				ProgramDataBaseFileName=".\obj\Release/"
@@ -378,6 +385,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\stdinc.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\UiPrerequisites.h"
 				>
 			</File>
@@ -583,6 +594,34 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\stdinc.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release with Symbols|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
 				RelativePath=".\src\UiSubsystem.cpp"
 				>
 			</File>

Added: rl/trunk/engine/ui/include/stdinc.h
===================================================================
--- rl/trunk/engine/ui/include/stdinc.h	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/include/stdinc.h	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,108 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+/*
+ * This file is used for precompiled header generation. You have to
+ * include it in all cpp files which have "Use Precompiled Header"
+ * set in their C/C++ properties. It shall never be included in other
+ * headers.
+ *
+ * The content of this file should be limited to the following include
+ * types:
+ *   - stdlib headers
+ *   - stl headers
+ *   - all types of external dependencies which will never be changed by us
+ *
+ * Every sub project should have it's own copy of this file and may have
+ * project specific modifications
+ */
+
+#ifndef __stdinc_h__
+#define __stdinc_h__
+
+#ifdef RL_USE_PCH
+
+#include <string>
+#include <vector>
+#include <list>
+#include <map>
+#include <set>
+
+#include <iostream>
+#include <sstream>
+
+#include <functional>
+#include <algorithm>
+#include <utility>
+
+#include <OgreCommon.h>
+#include <OgreConfigFile.h>
+#include <OgreString.h>
+#include <OgreStringConverter.h>
+#include <OgreMath.h>
+#include <OgreVector3.h>
+#include <OgreSingleton.h>
+#include <OgreLog.h>
+#include <OgreLogManager.h>
+#include <OgreDataStream.h>
+#include <OgreSharedPtr.h>
+#include <OgreResource.h>
+#include <OgreResourceGroupManager.h>
+#include <OgreResourceManager.h>
+#include <OgreUserDefinedObject.h>
+#include <OgreMovableObject.h>
+#include <OgreManualObject.h>
+#include <OgreNode.h>
+#include <OgreCamera.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <OgreLight.h>
+#include <OgreQuaternion.h>
+#include <OgreEntity.h>
+#include <OgreMesh.h>
+#include <OgreRenderable.h>
+#include <OgreParticleSystem.h>
+#include <OgreSceneQuery.h>
+#include <OgreSceneManager.h>
+#include <OgreSceneNode.h>
+#include <OgreAnimationState.h>
+#include <OgreRay.h>
+#include <OgreMeshManager.h>
+#include <OgreBillboardParticleRenderer.h>
+#include <OgreTextureManager.h>
+#include <OgreException.h>
+#include <OgreWindowEventUtilities.h>
+#include <OgreRenderWindow.h>
+
+#include <OgreNewt.h>
+#include <OgreNewt_ContactCallback.h>
+#include <OgreNewt_Collision.h>
+#include <OgreNewt_RayCast.h>
+
+#include <CEGUIString.h>
+#include <CEGUILogger.h>
+
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+#include <boost/any.hpp>
+#include <boost/bind.hpp>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#  include <Windows.h>
+#endif
+
+#endif//RL_USE_PCH
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/ui/src/AboutWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AboutWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/AboutWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "AboutWindow.h"
 #include "CoreSubsystem.h"
 #include "ContentModule.h"

Modified: rl/trunk/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include <boost/bind.hpp>
 #include <CEGUIWindowManager.h>
 #include <elements/CEGUIFrameWindow.h>
@@ -42,14 +44,14 @@
 		mWindowInputType(inputType),
 		mCloseOnEscape(closeOnEscape)
 	{
-        LOG_MESSAGE(Logger::UI, 
+        LOG_MESSAGE(Logger::UI,
 		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
    		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
 		if (mWindow == NULL)
 		{
 			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
 		}
-		
+
 		getRoot()->addChildWindow(mWindow);
 
         if (modal)
@@ -67,7 +69,7 @@
 		mNormalAlpha = mWindow->getAlpha();
 		mName = mWindow->getName();
 		WindowManager::getSingleton().registerWindow(this);
-		mWindow->subscribeEvent(Window::EventActivated, 
+		mWindow->subscribeEvent(Window::EventActivated,
 			boost::bind(
 				&rl::WindowManager::handleMovedToFront,
 				rl::WindowManager::getSingletonPtr(),
@@ -90,17 +92,17 @@
 	}
 
 
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)    
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)
 	{
 		CeGuiString namePrefix;
 		if (prefix == "")
 			prefix.assign(StringConverter::toString(sNumAbstractWindows));
 		sNumAbstractWindows++;
 
-		CEGUI::Window* window = NULL;		
-		try 
+		CEGUI::Window* window = NULL;
+		try
 		{
-			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, 
+			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile,
 				prefix);
 		}
 		catch(...)
@@ -164,23 +166,23 @@
 
 	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
 	{
-		CEGUI::Window* wnd = 
+		CEGUI::Window* wnd =
 			CEGUI::WindowManager::getSingleton().getWindow(
 				mNamePrefix + (utf8*)name);
-		
+
 		if (wnd == NULL)
 			Throw(
-				rl::NullPointerException, 
-				"Window " 
-				+ Ogre::String(name) 
+				rl::NullPointerException,
+				"Window "
+				+ Ogre::String(name)
 				+ " is NULL");
 
 		if (requiredClass != NULL && !wnd->testClassName(requiredClass))
 			Throw(
-				rl::NullPointerException, 
+				rl::NullPointerException,
 				"Window "
-				+ Ogre::String(name) 
-				+ " has not the required class " 
+				+ Ogre::String(name)
+				+ " has not the required class "
 				+ Ogre::String(requiredClass));
 
 		return wnd;
@@ -230,7 +232,7 @@
 	{
 		return static_cast<Combobox*>(getWindow(name, "Combobox"));
 	}
-	
+
 	ComboDropList* AbstractWindow::getComboDropList(const char* name)
 	{
 		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));

Modified: rl/trunk/engine/ui/src/ActionChoiceWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ActionChoiceWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ActionChoiceWindow.h"
 #include <boost/bind.hpp>
 #include <CEGUIWindowManager.h>
@@ -49,7 +51,7 @@
 				this,
 				_1));
 	}
-	
+
 	ActionChoiceWindow::~ActionChoiceWindow()
 	{
 		/*for (unsigned int i = 0; i<mButtons.size(); i++)
@@ -71,20 +73,20 @@
 
 		return false;
 	}
-	
+
 	int ActionChoiceWindow::showActionsOfObject(GameObject* object)
 	{
-		LOG_DEBUG2(Logger::UI, 
+		LOG_DEBUG2(Logger::UI,
 			"Start", "ActionChoiceWindow::showActionsOfObject");
 		mObject = object;
-		
+
 		for (unsigned int i = 0; i<mButtons.size(); i++)
 		{
 			mWindow->removeChildWindow(mButtons[i]);
 			CEGUI::WindowManager::getSingleton().destroyWindow(mButtons[i]);
 		}
 		mButtons.clear();
-		LOG_DEBUG2(Logger::UI, 
+		LOG_DEBUG2(Logger::UI,
 			"Buttons gel???scht", "ActionChoiceWindow::showActionsOfObject");
 
 		CEGUI::UVector2 center(cegui_reldim(0.5), cegui_reldim(0.5));
@@ -93,35 +95,35 @@
 		ActionVector actions = object->getValidActions(mActor);
 		if (actions.size() != 0)
 		{
-			LOG_DEBUG2(Logger::UI, 
+			LOG_DEBUG2(Logger::UI,
 				"Aktionen ermittelt", "ActionChoiceWindow::showActionsOfObject");
 
 			ActionNode* actionTree = ActionNode::createActionTree(actions);
-			LOG_DEBUG2(Logger::UI, 
+			LOG_DEBUG2(Logger::UI,
 				"Baum erzeugt", "ActionChoiceWindow::showActionsOfObject");
 			createButtons(actionTree, center, RADIUS, 0, 360);
 
 			mButtonCancel = createButton("cancelbutton", center);
 			bindDestroyWindowToClick(mButtonCancel);
 			mWindow->addChildWindow(mButtonCancel);
-			
-			LOG_DEBUG2(Logger::UI, 
+
+			LOG_DEBUG2(Logger::UI,
 				"Buttons erzeugt", "ActionChoiceWindow::showActionsOfObject");
 			setButtonActions(actionTree, actionTree);
-			LOG_DEBUG2(Logger::UI, 
+			LOG_DEBUG2(Logger::UI,
 				"Ende", "ActionChoiceWindow::showActionsOfObject");
 		}
 		return actions.size();
 	}
-	
+
 	void ActionChoiceWindow::setButtonActions(ActionNode* actions, ActionNode* treeRoot)
 	{
 		PushButton* button = actions->getButton();
-			
+
 		if (actions->isLeaf())
 		{
 			Action* action = actions->getAction();
-			
+
 			if (actions->getGroup() != NULL)
 				button->setVisible(false);
 			else
@@ -143,24 +145,24 @@
 		else
 		{
 			ActionGroup* gr = actions->getGroup();
-			
+
 			if (gr != NULL && gr->getParent() != NULL)
 			{
-				button->setVisible(false);					
+				button->setVisible(false);
 			}
 			else if (button != NULL)
 				button->setVisible(true);
-			
+
 			if (button != NULL)
 			{
-				const NodeSet nodesToHide = 
+				const NodeSet nodesToHide =
 					ActionNode::getAllNodesNotBelow(treeRoot, actions);
-				LOG_DEBUG2(Logger::UI, 
+				LOG_DEBUG2(Logger::UI,
 					StringConverter::toString(nodesToHide.size())+" nodes to hide",
 					"ActionChoiceWindow::setButtonActions");
-					
+
 				for (NodeSet::const_iterator iter = nodesToHide.begin(); iter != nodesToHide.end(); iter++)
-				{			
+				{
 					button->subscribeEvent(
 						Window::EventMouseEnters,
 						boost::bind(
@@ -175,7 +177,7 @@
 			for (NodeSet::const_iterator iter = children.begin(); iter != children.end(); iter++)
 			{
 				if (button != NULL)
-				{					
+				{
 					button->subscribeEvent(
 						Window::EventMouseEnters,
 						boost::bind(
@@ -184,23 +186,23 @@
 							(*iter)->getButton(),
 							true));
 				}
-				
+
 				setButtonActions(*iter, treeRoot);
 			}
-		}		
+		}
 	}
-	
+
 	bool ActionChoiceWindow::activateAction(Action* action)
 	{
-		LOG_DEBUG2(Logger::UI, 
+		LOG_DEBUG2(Logger::UI,
 			"Start", "ActionChoiceWindow::activateAction");
-		LOG_DEBUG2(Logger::UI, 
+		LOG_DEBUG2(Logger::UI,
 			action->getName().c_str(), "ActionChoiceWindow::activateAction");
-			
+
 		//TODO: Ask for target
-        action->doAction(mObject, mActor, NULL); 
-		
-		LOG_DEBUG2(Logger::UI, 
+        action->doAction(mObject, mActor, NULL);
+
+		LOG_DEBUG2(Logger::UI,
 			"Ende", "ActionChoiceWindow::activateAction");
 
 		destroyWindow();
@@ -208,7 +210,7 @@
 	}
 
 	void ActionChoiceWindow::createButtons(
-		ActionNode* actions, const CEGUI::UVector2& center, 
+		ActionNode* actions, const CEGUI::UVector2& center,
 		float radius, float angle, float angleWidth)
 	{
 		PushButton* button = NULL;
@@ -223,11 +225,11 @@
 			{
 				button = createButton(actions->getGroup()->getName(), center);
 			}
-			
+
             const NodeSet children = actions->getChildren();
 			float angleStep = angleWidth / (float)children.size();
 			float ang = children.size()>1 ? angle - angleWidth : angle - 180;
-			for (NodeSet::const_iterator iter = children.begin(); 
+			for (NodeSet::const_iterator iter = children.begin();
 				iter != children.end(); iter++)
 			{
 				CEGUI::UVector2 centerChild = getPositionOnCircle(center, radius, ang);
@@ -238,7 +240,7 @@
 
 		actions->setButton(button);
 		if (button != NULL)
-			mWindow->addChildWindow(button);		
+			mWindow->addChildWindow(button);
 	}
 
 	PushButton* ActionChoiceWindow::createButton(const CeGuiString& name, const CEGUI::UVector2& pos)
@@ -246,43 +248,43 @@
 		Window* button = AbstractWindow::loadWindow("buttons/"+name+".xml");
 		if (button == NULL)
 		{
-			button = 
+			button =
 				AbstractWindow::loadWindow(
 					"buttons/defaultbutton.xml");
 		}
 
 		CEGUI::UVector2 size = button->getSize();
 		button->setPosition(pos - size * UVector2(cegui_reldim(0.5), cegui_reldim(0.5)));
-		LOG_DEBUG2(Logger::UI, 
+		LOG_DEBUG2(Logger::UI,
 			(button->getText()+" "+
-            StringConverter::toString(button->getPixelRect().d_left) + ", " + 
-            StringConverter::toString(button->getPixelRect().d_top)).c_str(), 
+            StringConverter::toString(button->getPixelRect().d_left) + ", " +
+            StringConverter::toString(button->getPixelRect().d_top)).c_str(),
 			"createButton");
-		
+
 		return static_cast<PushButton*>(button);
 	}
-	
+
 	bool ActionChoiceWindow::setButtonVisible(PushButton* button, bool visible)
 	{
 		Ogre::String showHide;
-		
+
 		if (visible)
 			showHide = "Show ";
 		else
 			showHide = "Hide ";
-		
+
 		if (button == NULL)
 		{
-			LOG_DEBUG2(Logger::UI, 
+			LOG_DEBUG2(Logger::UI,
 				showHide + "NULL", "ActionChoiceWindow::setButtonVisible");
 			return true;
 		}
-		
+
 		LOG_DEBUG(Logger::UI, showHide + button->getName());
 		//CEGUI::Point p = button->getRelativePosition();
-		//LOG_DEBUG(Logger::UI, 
+		//LOG_DEBUG(Logger::UI,
 		//	"("+StringConverter::toString(p.d_x)+", "+StringConverter::toString(p.d_y)+")");
-			
+
 		if (visible)
 			button->show();
 		else
@@ -299,24 +301,24 @@
 	CEGUI::UVector2 ActionChoiceWindow::getPositionOnCircle(
 		const CEGUI::UVector2& center, float radius, float angle)
 	{
-		//LOG_DEBUG(Logger::UI, 
+		//LOG_DEBUG(Logger::UI,
 		//	"center="+StringConverter::toString(center.d_x)+","+StringConverter::toString(center.d_y)+
 		//	" radius="+StringConverter::toString(radius)+
 		//	" angle="+StringConverter::toString(angle)
 		//	);
 		static const float PI = 3.1415926;
-		
+
 		float relX = radius * sin(PI * angle/180);
 		float relY = radius * cos(PI * angle/180);
 
-		LOG_DEBUG(Logger::UI, 
+		LOG_DEBUG(Logger::UI,
 			"diff="+StringConverter::toString(relX)+","+StringConverter::toString(relY));
-			
 
+
 		return center + CEGUI::UVector2(cegui_reldim(relX), cegui_reldim(relY));
 	}
-	
-	ActionChoiceWindow::ActionNode* 
+
+	ActionChoiceWindow::ActionNode*
         ActionChoiceWindow::ActionNode::createActionTree(const ActionVector& actions, ActionGroup* rootGroup)
 	{
 		ActionNode* root = new ActionNode(false);
@@ -324,7 +326,7 @@
 
 		set<ActionGroup*> groups;
 		ActionVector rest;
-        
+
 		for (ActionVector::const_iterator iter = actions.begin(); iter != actions.end(); iter++)
 		{
 			Action* action = *iter;
@@ -348,7 +350,7 @@
 			ActionVector actionsThisGroup;
 			ActionGroup* thisGroup = *groupIter;
 
-			for (ActionVector::const_iterator actionIter = actions.begin(); 
+			for (ActionVector::const_iterator actionIter = actions.begin();
 				 actionIter != actions.end(); actionIter++)
 			{
 				Action* action = *actionIter;
@@ -373,37 +375,37 @@
 		return root;
 	}
 
-	void ActionChoiceWindow::ActionNode::addChild(ActionChoiceWindow::ActionNode* child) 
-	{ 
-		child->setParent(this); 
-		mChildren.insert(child); 
+	void ActionChoiceWindow::ActionNode::addChild(ActionChoiceWindow::ActionNode* child)
+	{
+		child->setParent(this);
+		mChildren.insert(child);
 	}
-	
-    const ActionChoiceWindow::NodeSet& ActionChoiceWindow::ActionNode::getChildren() 
-	{ 
-		return mChildren; 
+
+    const ActionChoiceWindow::NodeSet& ActionChoiceWindow::ActionNode::getChildren()
+	{
+		return mChildren;
 	}
-	
+
     void ActionChoiceWindow::ActionNode::getAllNodes(ActionNode* treeRoot, NodeSet& nodes)
 	{
 		nodes.insert(treeRoot);
 		const NodeSet children = treeRoot->getChildren();
-		
+
 		for (NodeSet::const_iterator iter = children.begin(); iter != children.end(); iter++)
 			getAllNodes(*iter, nodes);
 	}
-	
+
 	ActionChoiceWindow::NodeSet ActionChoiceWindow::ActionNode::getAllNodesNotBelow(
 		ActionNode* treeRoot, ActionChoiceWindow::ActionNode* targetNode)
 	{
 		NodeSet allNodes;
 		getAllNodes(treeRoot, allNodes);
-		
+
 		NodeSet nodes;
 		for (NodeSet::iterator iter = allNodes.begin(); iter != allNodes.end(); iter++)
 		{
 			bool leaveOut = false;
-			
+
 			if ((*iter)->getParent() == treeRoot ||
 				*iter == targetNode ||
 				(*iter)->getButton() == NULL)
@@ -411,7 +413,7 @@
 				leaveOut = true;
 				continue;
 			}
-				
+
 			ActionNode* node = *iter;
 			while(node->getParent() != NULL)
 			{
@@ -426,8 +428,8 @@
 			if (!leaveOut)
 				nodes.insert(*iter);
 		}
-		
+
 		return nodes;
 	}
-	
+
 }

Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "CharacterSheetWindow.h"
 
 #include <boost/bind.hpp>
@@ -41,7 +43,7 @@
 	mTalentTable->addColumn((utf8*)"eBE", 2, cegui_reldim(0.1));
 	mTalentTable->addColumn((utf8*)"TW", 3, cegui_reldim(0.1));
 	mTalentTable->setUserSortControlEnabled(false);
-	
+
 	mLE = getWindow("CharacterSheet/CharacterSheet/LE");
 	mAE = getWindow("CharacterSheet/CharacterSheet/AE");
 	mAP = getWindow("CharacterSheet/CharacterSheet/AP");
@@ -50,9 +52,9 @@
 	mProfession = getWindow("CharacterSheet/CharacterSheet/Profession");
 
 	bindDestroyWindowToXButton();
-	
+
 	/*for (int i=0; i<EIGENSCHAFT_COUNT; i++)
-		mEigenschaft[i] = 
+		mEigenschaft[i] =
 			getWindow(("CharacterSheet/CharacterSheet/Eigenschaften/"+
 				DsaManager::getSingleton().getEigenschaft(i)->getNameAbbreviation()).c_str());*/
 	mEigenschaft[0]= getWindow("CharacterSheet/CharacterSheet/Eigenschaften/MU");
@@ -102,7 +104,7 @@
 	mLE->setText("LeP: "+
 		StringConverter::toString(mCharacter->getLe())+"/"+
 		StringConverter::toString(mCharacter->getLeMax()));
-	
+
 	/*for (unsigned int eig = 0; eig < EIGENSCHAFT_COUNT; eig++)
 	{
 		CeGuiString name = DsaManager::getSingleton().getEigenschaft(eig)->getName();
@@ -126,7 +128,7 @@
 		+": "+ StringConverter::toString(mCharacter->getEigenschaft(E_KONSTITUTION)));
 	mEigenschaft[7]->setText(DsaManager::getSingleton().getEigenschaft(E_KOERPERKRAFT)->getName()
 		+": "+ StringConverter::toString(mCharacter->getEigenschaft(E_KOERPERKRAFT)));
-	
+
 	for (unsigned int row = 0; row < mTalentTable->getRowCount(); row++)
 	{
 		int tw = mCharacter->getTalent(

Modified: rl/trunk/engine/ui/src/CharacterStateWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include <boost/bind.hpp>
 #include "UiPrerequisites.h"
 
@@ -103,7 +105,7 @@
 void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
 {
 	AbstractWindow::setVisible(visible, destroyAfterHide);
-	if (visible) 
+	if (visible)
 	{
 		update();
 	}

Modified: rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/CloseConfirmationWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include <boost/bind.hpp>
 

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.perldoc.com/perl5.6/Artistic.html.
  */
+#include "stdinc.h" //precompiled header
 
 #include "CombatControlState.h"
 
@@ -130,7 +131,7 @@
     {
         // HUD aktualisieren.
         mHud->clear();
-        
+
         mHud->begin("BaseWhiteNoLighting", RenderOperation::OT_LINE_STRIP);
         const Combat::CreatureSet& opponents = mCombat->getAllOpponents();
         for (Combat::CreatureSet::const_iterator it = opponents.begin(), end = opponents.end();

Modified: rl/trunk/engine/ui/src/CombatWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/CombatWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "CombatWindow.h"
 #include "CoreSubsystem.h"

Modified: rl/trunk/engine/ui/src/CommandMapper.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandMapper.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/CommandMapper.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "Action.h"
 #include "ActionManager.h"

Modified: rl/trunk/engine/ui/src/ConfigComponent.cpp
===================================================================
--- rl/trunk/engine/ui/src/ConfigComponent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ConfigComponent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include <CEGUIWindowManager.h>
 #include <iostream>

Modified: rl/trunk/engine/ui/src/Console.cpp
===================================================================
--- rl/trunk/engine/ui/src/Console.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/Console.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "Console.h"
 
 #include <boost/bind.hpp>
@@ -28,21 +30,21 @@
 using CEGUI::KeyEventArgs; using CEGUI::Key; using CEGUI::colour;
 using CEGUI::ListboxWrappedTextItem; using CEGUI::TextFormatting;
 
-namespace rl 
+namespace rl
 {
-	Console::Console() : 
+	Console::Console() :
 		AbstractWindow("console.xml", WIT_KEYBOARD_INPUT)
 	{
 		using namespace CEGUI;
-		
+
 		mDisplay = getListbox("Console/Display");
 		mCommandLine = getEditbox("Console/Inputbox");
 
 		mWindow->subscribeEvent(
-			FrameWindow::EventKeyDown, 
+			FrameWindow::EventKeyDown,
 			boost::bind(&Console::handleKeyDown, this, _1));
 		mCommandLine->subscribeEvent(
-			Editbox::EventKeyDown, 
+			Editbox::EventKeyDown,
 			boost::bind(&Console::handleKeyDown, this, _1));
 		mDisplay->moveToFront();
 
@@ -58,7 +60,7 @@
 		{
 			mCommandLine->activate();
 		}
-		
+
 		AbstractWindow::setVisible(visible, destroy);
 	}
 
@@ -80,7 +82,7 @@
 			CeGuiString command = mCommandLine->getText();
 			CeGuiString printCommand = ">" + command;
 			appendTextRow(printCommand, 0xFF7FFF7F);
-				
+
 			mPrompt = CoreSubsystem::getSingleton().getRubyInterpreter()->execute(command.c_str());
 
 			mHistory.push_back(command);
@@ -88,14 +90,14 @@
 			mCommandLine->setText((utf8*)"");
 			return true;
 		}
-		
-		return false;		
+
+		return false;
 	}
 
 	void Console::write(const CeGuiString& output)
-	{        
+	{
 		CeGuiString temp;
-        if( output.substr(output.length() - 2).compare("\n") == 0 ) 
+        if( output.substr(output.length() - 2).compare("\n") == 0 )
             temp = output.substr( 0, output.length() - 1 );
 		else
 			temp = output;
@@ -149,7 +151,7 @@
 		//mDisplay->addItem(item);
 		//mDisplay->ensureItemIsVisible(item); // scroll to bottom;*/
 	}
-	
+
 	void Console::setRubyInterpreter(RubyInterpreter* RubyInterpreter)
 	{
 		mRubyInterpreter = RubyInterpreter;
@@ -160,7 +162,7 @@
 	{
 		if (mHistory.size() == 0)
 			return;
-		
+
 		if (mHistoryMarker + skip < 0)
 			mHistoryMarker = 0;
 		else if (mHistoryMarker + skip > mHistory.size())

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ContainerContentWindow.h"
 
 #include <boost/bind.hpp>
@@ -32,7 +34,7 @@
 
 	int ContainerContentWindow::sItemCount = 0;
 
-	ContainerContentWindow::ContainerContentWindow(Container* container) 
+	ContainerContentWindow::ContainerContentWindow(Container* container)
 		: AbstractWindow("containercontentwindow.xml", WIT_MOUSE_INPUT),
 		mContainer(container)
 	{
@@ -102,7 +104,7 @@
 						cegui_absdim(pos.second*30)));
 				dragcont->setItemParent(mContainer);
 
-				///@todo Swap with old content (if there is some)				
+				///@todo Swap with old content (if there is some)
 			}
 			else if (dragcont->getItemParentSlot() != "")
 			{
@@ -118,9 +120,9 @@
 						cegui_absdim(pos.second*30)));
 				dragcont->setItemParent(mContainer);
 
-				///@todo Swap with old content (if there is some)				
+				///@todo Swap with old content (if there is some)
 			}
-			
+
 			return true;
 		}
 		return false;
@@ -136,19 +138,19 @@
 		}
 
    //     LOG_MESSAGE("IW", icon);
-   //     Window* itemWindow = 
+   //     Window* itemWindow =
 	  //      CEGUI::WindowManager::getSingletonPtr()->createWindow(
-		 //   "RastullahLook/StaticImage", 
-			//mWindow->getName() + "/" + icon 
+		 //   "RastullahLook/StaticImage",
+			//mWindow->getName() + "/" + icon
 			//+ "/" + CEGUI::PropertyHelper::intToString(sItemCount++));
    //     itemWindow->setProperty("Image", icon);
    //     itemWindow->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
    //     itemWindow->setSize(UVector2(cegui_reldim(1), cegui_reldim(1)));
-		CeGuiString dragContainerName = 
-			mWindow->getName() +  "/item/" 
+		CeGuiString dragContainerName =
+			mWindow->getName() +  "/item/"
 			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
 
-		ItemDragContainer* itemhandler = new ItemIconDragContainer(item, 
+		ItemDragContainer* itemhandler = new ItemIconDragContainer(item,
 			dragContainerName);
 		itemhandler->setItemParent(mContainer);
 		itemhandler->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));

Modified: rl/trunk/engine/ui/src/ControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/ControlState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ControlState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Perl Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
+#include "stdinc.h" //precompiled header
+
 #include "ControlState.h"
 
 #include <OgreSceneManager.h>
@@ -54,7 +56,7 @@
 		if (mCharacter != NULL)
 		{
             mCharacterActor = mCharacter->getActor();
-            
+
 			if (mCharacter != NULL && mCharacterActor->_getSceneNode() == NULL)
 			{
 				Throw(IllegalArgumentException,
@@ -99,10 +101,10 @@
             PhysicsManager::getSingleton().getMaterialID("character"),
             PhysicsManager::getSingleton().getMaterialID("character"))->setDefaultCollidable(0);
 	}
-    
+
     ControlState::~ControlState()
     {
-    
+
     }
 
 	bool ControlState::startAction(const CeGuiString& actionName, Creature* character)

Modified: rl/trunk/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneControlState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/CutsceneControlState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,7 +1,7 @@
 /*
 * This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Perl Artistic License.
 *
@@ -14,6 +14,7 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
+#include "stdinc.h" //precompiled header
 
 #include "CutsceneControlState.h"
 #include "Exception.h"

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "UiPrerequisites.h"
 
 #include "UiSubsystem.h"

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,3 +1,306 @@
+<<<<<<< .mine
+/*
+* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "DialogControlState.h"
+#include "Exception.h"
+
+#include "Actor.h"
+#include "CameraObject.h"
+#include "CommandMapper.h"
+#include "ConfigurationManager.h"
+#include "CoreSubsystem.h"
+#include "DialogCharacter.h"
+#include "DialogSubsystem.h"
+#include "DialogWindow.h"
+#include "InputManager.h"
+#include "MeshAnimation.h"
+#include "MeshObject.h"
+#include "Person.h"
+#include "PhysicalThing.h"
+#include "Sound.h"
+#include "SoundDriver.h"
+#include "SoundManager.h"
+#include "SoundObject.h"
+#include "SubtitleWindow.h"
+#include "WindowFactory.h"
+#include "WindowManager.h"
+#include "World.h"
+
+#include <OgreSceneManager.h>
+#include <OgreNewt_Body.h>
+
+using namespace Ogre;
+
+namespace rl {
+
+    DialogControlState::DialogControlState(CommandMapper* cmdMapper,
+        Actor* camera, Person* character)
+        : ControlState(cmdMapper, camera, character, CST_DIALOG),
+        mTargetCameraPosition(Vector3::ZERO),
+        mTargetCameraDirection(Vector3::UNIT_Z),
+        mCurrFadeTextTime(0),
+        mTotalFadeTextTime(0),
+        mText(),
+        mDialogMode(DM_FRONT),
+        mTextShown(false),
+        mDialogWindow(NULL),
+        mSubtitleWindow(NULL),
+        mSoundObject(NULL),
+        mTalkAnimation(NULL),
+        mSubtitleSpeed(1.0f)
+    {
+        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
+            "General", "Subtitle Speed");
+
+    }
+
+    DialogControlState::~DialogControlState()
+    {
+        delete mSoundObject;
+    }
+
+    void DialogControlState::pause()
+    {
+        if(mDialogPartner)
+        {
+            MeshObject* mesh = dynamic_cast<MeshObject*>(mDialogPartner->getControlledObject());
+            if (mesh != NULL)
+            {
+                mesh->stopAllAnimations();
+                if (mesh->hasAnimation("idle"))
+                {
+                    mTalkAnimation = mesh->startAnimation("idle");
+                }
+            }
+        }
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCharacterActor->getPhysicalThing()->unfreeze();
+        mDialogWindow->setVisible(false, false);
+        mSubtitleWindow->setVisible(false, false);
+    }
+
+    void DialogControlState::resume()
+    {
+        mCharacterActor->setVisible(true);
+
+        mCameraActor->getPhysicalThing()->freeze();
+        mCharacterActor->getPhysicalThing()->freeze();
+        Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
+        ogreCam->setFixedYawAxis(true);
+        ogreCam->setPosition(Vector3::ZERO);
+        ogreCam->setOrientation(Quaternion::IDENTITY);
+        mCameraActor->_getSceneNode()->setFixedYawAxis(true);
+
+        DialogCharacter* bot = DialogSubsystem::getSingleton().getCurrentDialogCharacter();
+        bot->setDialogCharacter(mCharacter);
+		mDialogPartner = bot->getDialogPartner()->getActor();
+
+        recalculateCamera( mDialogPartner, mCharacterActor );
+
+        mSubtitleWindow = WindowFactory::getSingleton().getSubtitleWindow();
+
+        mDialogWindow = WindowFactory::getSingleton().getDialogWindow();
+        mDialogWindow->initialize(this, bot);
+		mDialogWindow->start();
+    }
+
+    void DialogControlState::run(Real elapsedTime)
+    {
+        if( elapsedTime <= 0.0 )
+            return;
+
+        // Aktuellen Abstand zur gew?nschten Position berechnen
+        Vector3 posDistance = (mTargetCameraPosition - mCameraActor->_getSceneNode()->getPosition());
+        // Ist eine Anpassung n?tig?
+        if( posDistance != Vector3::ZERO )
+        {
+            // Die Kameraanpassgeschwindigkeit
+            Real speed = 1/elapsedTime;
+            mCameraActor->setPosition(mTargetCameraPosition);
+        }
+
+        mCameraActor->setOrientation( Quaternion::IDENTITY );
+        mCameraActor->_getSceneNode()->setDirection( mTargetCameraDirection );
+        mCameraActor->_getSceneNode()->_update( true, false );
+
+        // Textanzeigedauer
+        if (mCurrFadeTextTime >= 0)
+        {
+            mCurrFadeTextTime -= elapsedTime;
+        }
+
+        if (mTextShown && mCurrFadeTextTime <= 0)
+        {
+            mCurrFadeTextTime = 0;
+            mTotalFadeTextTime = 0;
+            mTextShown = false;
+               if (mSoundObject)
+            {
+                mSoundObject->stop();
+            }
+            mSubtitleWindow->setVisible(false, false);
+            mDialogWindow->textFinished();
+        }
+
+        LOG_DEBUG(Logger::UI,
+                StringConverter::toString(mSubtitleWindow->getWindow()->getEffectiveAlpha())
+                + ": "
+                + mSubtitleWindow->getText()
+                + CeGuiString(mSubtitleWindow->getWindow()->isVisible() ? "vis" : "unvis")
+                + ", Time: "
+                + StringConverter::toString(mCurrFadeTextTime));
+    }
+
+    void DialogControlState::recalculateCamera( Actor* speaker, Actor* listener )
+    {
+        // Position camera at position between char and dialog partner
+        Vector3 charEyes = speaker->getWorldPosition();
+        // Modify by MeshBounds
+        if( speaker->getControlledObject()->isMeshObject() )
+        {
+            MeshObject* mo = dynamic_cast<MeshObject*>(speaker->getControlledObject());
+            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y*0.933,
+                aab.getCenter().z );
+            charEyes += speaker->getWorldOrientation()*offset;
+        }
+
+        Vector3 partEyes = listener->getWorldPosition();
+        // Modify by MeshBounds
+        if( listener->getControlledObject()->isMeshObject() )
+        {
+            MeshObject* mo = dynamic_cast<MeshObject*>(listener->getControlledObject());
+            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y*0.933,
+                aab.getCenter().z );
+            partEyes += listener->getWorldOrientation()*offset;
+        }
+
+        Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
+
+        // Weltkoordinaten in lokale umwandeln
+        mTargetCameraPosition =
+            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
+            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
+
+
+        mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
+    }
+
+    float DialogControlState::getShowTextLength(const CeGuiString& text) const
+    {
+        return 0.019f * text.length() + // Zeit f?rs Text lesen
+               0.25f;                   // Fade in
+    }
+
+    void DialogControlState::response(
+        Actor* actor, const CeGuiString& text, const Ogre::String& soundFile)
+    {
+        if( actor == mDialogPartner )
+            recalculateCamera( mCharacterActor, mDialogPartner );
+        else
+            recalculateCamera( mDialogPartner, mCharacterActor );
+
+        // Ungef?hre Lesedauer bestimmen
+        float fadeTime = getShowTextLength(text);
+        if (soundFile.length() == 0)
+        {
+            float speed = mSubtitleSpeed;
+
+            if( mSubtitleSpeed == 0.0 )
+                speed = 1.0;
+
+            mCurrFadeTextTime = fadeTime*speed;
+            mTotalFadeTextTime = fadeTime*speed;
+        }
+        else
+        {
+            if( mSoundObject != NULL )
+                mSoundObject->getMovableObject()->getParentSceneNode()->detachObject(
+                    mSoundObject->getMovableObject() );
+
+            delete mSoundObject;
+            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()->
+                    createSound(soundFile, ST_SAMPLE), soundFile);
+
+            // An Sprecher h?ngen
+            actor->_getSceneNode()->attachObject( mSoundObject->getMovableObject() );
+            actor->_getSceneNode()->_update( true, false );
+            mSoundObject->_setActor( actor );
+            mSoundObject->set3d(true);
+            mSoundObject->play();
+            mSoundObject->_update();
+
+
+            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject->getLength());
+            mTotalFadeTextTime = mCurrFadeTextTime;
+        }
+
+        MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
+        if (mesh != NULL)
+        {
+            if (mesh->hasAnimation("reden"))
+            {
+                mesh->stopAllAnimations();
+                mTalkAnimation = mesh->startAnimation("reden");
+            }
+        }
+
+        LOG_DEBUG(Logger::UI,
+            "Response: "
+                + actor->getName()
+                + " File: '"
+                + soundFile
+                + "', Text: '" + text + "', Time: "
+                + StringConverter::toString(mCurrFadeTextTime));
+
+
+        mTextShown = true;
+
+        if (mSubtitleWindow != NULL && !text.empty())
+        {
+            mSubtitleWindow->show(text);
+        }
+    }
+
+    bool DialogControlState::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id)
+    {
+
+        if (mTextShown && (mCurrFadeTextTime + 0.25) < mTotalFadeTextTime)
+        {
+            mCurrFadeTextTime = -1;
+
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+
+    }
+}
+=======
 ??/
 
 
@@ -489,4 +792,4 @@
 
 
 
-
\ No newline at end of file
+

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h"
+
 #include "DialogWindow.h"
 
 #include <boost/bind.hpp>

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Perl Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
+#include "stdinc.h" //precompiled header
 
 #include "FreeflightControlState.h"
 
@@ -144,7 +145,7 @@
             {
                 mCharacterActor->setPosition(
                     mCameraActor->getPosition()
-                    + mCameraActor->getWorldOrientation() * Vector3::NEGATIVE_UNIT_Z * 2 
+                    + mCameraActor->getWorldOrientation() * Vector3::NEGATIVE_UNIT_Z * 2
                     - 1.5 * Vector3::UNIT_Y);
             }
         }
@@ -257,7 +258,7 @@
                 toggleCameraCollision();
                 return true;
             }
-            else 
+            else
             {
                 return ControlState::keyReleased(evt);
             }

Modified: rl/trunk/engine/ui/src/GameLoggerWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/GameLoggerWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "UiPrerequisites.h"
 
 #include "Creature.h"
@@ -26,7 +28,7 @@
 CEGUI::colour GameLoggerWindow::COLOR_FIGHT(     0xFFFFFF7F);
 CEGUI::colour GameLoggerWindow::COLOR_MISC(      0xFFFFFFFF);
 
-GameLoggerWindow::GameLoggerWindow() : 
+GameLoggerWindow::GameLoggerWindow() :
 	AbstractWindow("gameloggerwindow.xml", WIT_NONE)
 {
 	mLog = getListbox ("GameLogger/Log");

Modified: rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/GameObjectInfoWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 /**
  * \file GameObjectInfoWindow.cpp
@@ -34,7 +35,7 @@
 
     //------------------------------------------------------- Constructor
 
-	GameObjectInfoWindow::GameObjectInfoWindow(GameObject* go, Creature* character) 
+	GameObjectInfoWindow::GameObjectInfoWindow(GameObject* go, Creature* character)
 	 :  AbstractWindow("gameobjectinfowindow.xml", WIT_MOUSE_INPUT),
 		mGameObject(go),
 		mCharacter(character),
@@ -54,8 +55,8 @@
 
     //------------------------------------------------------- Destructor
 
-	GameObjectInfoWindow::~GameObjectInfoWindow() 
-	{        
+	GameObjectInfoWindow::~GameObjectInfoWindow()
+	{
 	}
 
     //------------------------------------------------------- initialize
@@ -69,13 +70,13 @@
 		{
 			mIcon->setProperty("Image", item->getImageName());
 		}
-		
-		
+
+
 		///@todo: Add Action Buttons
 		const ActionVector actions = mGameObject->getValidActions(mCharacter);
 		for (ActionVector::const_iterator it = actions.begin(); it != actions.end(); it++)
 		{
-            if ((*it)->getName() != GameObject::DEFAULT_VIEW_OBJECT_ACTION 
+            if ((*it)->getName() != GameObject::DEFAULT_VIEW_OBJECT_ACTION
                 && (*it)->getName() != GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG)
             {
                 addActionButton(*it);
@@ -93,7 +94,7 @@
 		btn->setTooltipText(action->getDescription());
 		mActionButtonsArea->addChildWindow(btn);
 		mNumActionButtons++;
-		btn->subscribeEvent(Window::EventMouseClick, 
+		btn->subscribeEvent(Window::EventMouseClick,
 			boost::bind(&GameObjectInfoWindow::handleActivateAction, this, action));
 	}
 

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "GameSettings.h"
 
 #include <boost/bind.hpp>

Modified: rl/trunk/engine/ui/src/InGameMenuWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/InGameMenuWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "InGameMenuWindow.h"
 
 #include <boost/bind.hpp>
@@ -44,8 +46,8 @@
 
 void InGameMenuWindow::createMenu(MenuBase* menu)
 {
-	CEGUI::WindowManager* windowMan = CEGUI::WindowManager::getSingletonPtr(); 
-				
+	CEGUI::WindowManager* windowMan = CEGUI::WindowManager::getSingletonPtr();
+
 	const ActionVector actions = ActionManager::getSingleton().getInGameGlobalActions();
 	map<CeGuiString, PopupMenu*> menuGroups;
 
@@ -62,13 +64,13 @@
 				menuGrp = (*grpIter).second;
 			}
 			else
-			{				
+			{
 				MenuItem* grpItem = static_cast<MenuItem*>(windowMan->createWindow("RastullahLook/MenuItem", getNamePrefix()+"IngameMenu/"+group->getName()));
 				grpItem->setText(group->getName());
 				menu->addChildWindow(grpItem);
 
 				menuGrp = static_cast<PopupMenu*>(windowMan->createWindow("RastullahLook/PopupMenu", getNamePrefix()+"IngameMenu/Menu"+group->getName()));
-				grpItem->addChildWindow(menuGrp);				
+				grpItem->addChildWindow(menuGrp);
 
 				menuGroups[group->getName()] = menuGrp;
 			}
@@ -85,10 +87,10 @@
 void InGameMenuWindow::setAction(MenuItem* item, Action* action)
 {
 	item->subscribeEvent(
-		MenuItem::EventClicked, 
+		MenuItem::EventClicked,
 		boost::bind(
-			&InGameMenuWindow::handleAction, 
-			this, 
+			&InGameMenuWindow::handleAction,
+			this,
 			action));
 }
 
@@ -97,13 +99,13 @@
 	action->doAction(NULL, NULL, NULL);
 
 	setVisible(false);
-	
+
 	return true;
 }
 
 void InGameMenuWindow::update()
 {
-	createMenu(getMenu("InGameMenu/Menubar"));	
+	createMenu(getMenu("InGameMenu/Menubar"));
 }
 
 }

Modified: rl/trunk/engine/ui/src/InfoPopup.cpp
===================================================================
--- rl/trunk/engine/ui/src/InfoPopup.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/InfoPopup.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "InfoPopup.h"
 #include "WindowManager.h"
@@ -90,7 +91,7 @@
 	{
 		showQuestBookChange();
 	}
-	
+
 	void InfoPopup::questPartsDoneChanged(QuestEvent* anEvent)
 	{
 		showQuestBookChange();

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "InputManager.h"
 
 #include <xercesc/parsers/XercesDOMParser.hpp>
@@ -145,7 +147,7 @@
             delete *it;
         }
         mFinishedControlStates.clear();
-   
+
         if (!mControlStates.empty())
         {
             mControlStates.top()->run(elapsedTime);

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "InventoryWindow.h"
 
 #include <boost/bind.hpp>
@@ -71,7 +73,7 @@
             CeGuiString curWndName = curWnd->getName();
             if (curWndName.find("InventoryWindow/Slots/") != CeGuiString::npos)
             {
-                CeGuiString slotname = 
+                CeGuiString slotname =
                     curWndName.substr(
                         curWndName.find("InventoryWindow/Slots/") + 22);
                 slotsInWindowDefinition[slotname] = curWnd;
@@ -86,12 +88,12 @@
         for (Inventory::SlotMap::const_iterator it = slots.begin(); it != slots.end(); it++)
         {
             CeGuiString slotName = (*it).first;
-            std::map<CeGuiString, Window*>::iterator 
+            std::map<CeGuiString, Window*>::iterator
                 slotInWindowFile = slotsInWindowDefinition.find(slotName);
 
             if (slotInWindowFile != slotsInWindowDefinition.end())
             {
-                mSlotWindows[slotName] = (*slotInWindowFile).second; 
+                mSlotWindows[slotName] = (*slotInWindowFile).second;
 				mSlotWindows[slotName]->setUserString(SLOTNAME, slotName);
                 slotsInWindowDefinition.erase(slotInWindowFile);
                 LOG_DEBUG(Logger::UI, "Found slot "+slotName);
@@ -115,7 +117,7 @@
             Item* item = inventory->getItem(slotName);
 			Window* slotWindow = (*it).second;
 			slotWindow->setDragDropTarget(true);
-			slotWindow->subscribeEvent(Window::EventDragDropItemDropped, 
+			slotWindow->subscribeEvent(Window::EventDragDropItemDropped,
 				boost::bind(&InventoryWindow::handleItemDroppedOnSlot, this, _1));
 
             if (item != NULL)
@@ -130,21 +132,21 @@
         }
 
 		mWorldBackground->setDragDropTarget(true);
-		mWorldBackground->subscribeEvent(Window::EventDragDropItemDropped, 
+		mWorldBackground->subscribeEvent(Window::EventDragDropItemDropped,
 			boost::bind(&InventoryWindow::handleItemDroppedOnWorld, this, _1));
-		mWorldBackground->subscribeEvent(Window::EventMouseMove, 
+		mWorldBackground->subscribeEvent(Window::EventMouseMove,
 			boost::bind(&InventoryWindow::handleMouseMovedInWorld, this, _1));
-		mWorldBackground->subscribeEvent(Window::EventKeyDown, 
+		mWorldBackground->subscribeEvent(Window::EventKeyDown,
 			boost::bind(&InventoryWindow::handleKeys, this, _1, true));
-		mWorldBackground->subscribeEvent(Window::EventKeyUp, 
+		mWorldBackground->subscribeEvent(Window::EventKeyUp,
 			boost::bind(&InventoryWindow::handleKeys, this, _1, false));
     }
 
 	ItemDragContainer* InventoryWindow::createItemDragContainer(
 		Item* item, bool showdescription, const CeGuiString& slotName)
 	{
-		CeGuiString dragContainerName = 
-			mWindow->getName() +  "/item/" 
+		CeGuiString dragContainerName =
+			mWindow->getName() +  "/item/"
 			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
 		ItemDragContainer* itemhandler = NULL;
 
@@ -218,7 +220,7 @@
 				mSlotWindows[targetSlot]->addChildWindow(dragcont);
 				dragcont->setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
 				dragcont->setItemParent(mInventory, targetSlot);
-				
+
 				return true;
 			}
 			else
@@ -238,7 +240,7 @@
 			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
-			Ogre::Vector3 targetPosWindow( 
+			Ogre::Vector3 targetPosWindow(
 				dragcont->getPixelRect().d_left / getRoot()->getPixelSize().d_width,
 				dragcont->getPixelRect().d_top / getRoot()->getPixelSize().d_height,
 				-1);
@@ -263,8 +265,8 @@
 				destroyDragContainer(dragcont);
 			}
 
-			Ogre::Vector3 targetPosWorldSpace = 
-				mInventory->getOwner()->getPosition() 
+			Ogre::Vector3 targetPosWorldSpace =
+				mInventory->getOwner()->getPosition()
 				+ mInventory->getOwner()->getOrientation()
 				* targetPosWindow; ///@todo check why coordinates are negative
 			item->placeIntoScene();
@@ -273,7 +275,7 @@
 			LOG_DEBUG(Logger::UI,
 				"Dropped item "+item->getName()
 				+" to position "+Ogre::StringConverter::toString(targetPosWorldSpace));
-			
+
 			return true;
 
 		}
@@ -291,37 +293,37 @@
 		mousePos.d_x /= getRoot()->getPixelSize().d_width;
 		mousePos.d_y /= getRoot()->getPixelSize().d_height;
 		Ogre::Ray camToWorld = camera->getCameraToViewportRay(
-			mousePos.d_x, mousePos.d_y); 
+			mousePos.d_x, mousePos.d_y);
 		Ogre::Vector3 rayStart = camera->getCamera()->getWorldPosition();
 		Ogre::Vector3 rayDir = camera->getDirectionFromScreenPosition(
-			mousePos.d_x, mousePos.d_y); 
+			mousePos.d_x, mousePos.d_y);
 
 		mMouseSelector->setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
 		mMouseSelector->updateSelection();
 		Selector::GameObjectVector objs = mMouseSelector->getAllSelectedObjects();
-		
+
 		///@todo select, ...
 		if (!objs.empty())
 		{
-			LOG_MESSAGE(Logger::UI, 
+			LOG_MESSAGE(Logger::UI,
 				"Selected "+Ogre::StringConverter::toString(objs.size())+" items.");
 			for (Selector::GameObjectVector::const_iterator it = objs.begin();
 				it != objs.end(); ++it)
 			{
-				LOG_MESSAGE(Logger::UI, 
+				LOG_MESSAGE(Logger::UI,
 					"Selected " + (*it)->getDescription());
 
-				ItemDragContainer* cont = 
+				ItemDragContainer* cont =
 					createItemDragContainer(static_cast<Item*>(*it), true);
 				if (cont)
 				{
 					mWorldBackground->addChildWindow(cont);
 					cont->setVisible(true);
-					
+
 					Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
 							(*it)->getActor()->_getSceneNode()->_getWorldAABB());
 					UVector2 posCont = UVector2(
-							UDim((aabb.left+aabb.right)/2.0, 0), 
+							UDim((aabb.left+aabb.right)/2.0, 0),
 							UDim((aabb.top+aabb.bottom)/2.0, 0));
 					posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
 					cont->setPosition(posCont);
@@ -380,23 +382,23 @@
 				sel.setPosition(cameraActor->getWorldPosition());
 				sel.setOrientation(cameraActor->getWorldOrientation());
 				sel.setRadius(2.0);
-				
+
 				sel.updateSelection();
 				Selector::GameObjectVector v = sel.getAllSelectedObjects();
-				for (Selector::GameObjectVector::iterator 
+				for (Selector::GameObjectVector::iterator
 					it = v.begin(); it != v.end(); ++it)
 				{
-					ItemDragContainer* cont = 
+					ItemDragContainer* cont =
 						createItemDragContainer(static_cast<Item*>(*it), true);
 
 					if (cont)
 					{
 						mWorldBackground->addChildWindow(cont);
-						
+
 						Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
 							(*it)->getActor()->_getSceneNode()->_getWorldAABB());
 						UVector2 posCont = UVector2(
-							UDim((aabb.left+aabb.right)/2.0, 0), 
+							UDim((aabb.left+aabb.right)/2.0, 0),
 							UDim((aabb.top+aabb.bottom)/2.0, 0));
 						posCont -= cont->getSize() / UVector2(UDim(2, 2), UDim(2, 2));
 						cont->setPosition(posCont);

Modified: rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ItemDescriptionDragContainer.h"
 
 #include "AbstractWindow.h"

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ItemDragContainer.h"
 
 #include <CEGUIWindowManager.h>
@@ -39,21 +41,21 @@
 		removeChildWindow(mContentWindow);
 		CEGUI::WindowManager::getSingleton().destroyWindow(mContentWindow);
 	}
-		
+
 	void ItemDragContainer::setItemParent(Container* container)
 	{
 		mParentContainer = container;
 		mParentSlot = "";
 		mInventory = NULL;
 	}
-	
+
 	void ItemDragContainer::setItemParent(Inventory* inventory, const CeGuiString& slotname)
 	{
 		mParentSlot = slotname;
 		mParentContainer = NULL;
 		mInventory = inventory;
 	}
-	
+
 	Container* ItemDragContainer::getItemParentContainer() const
 	{
 		return mParentContainer;

Modified: rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "ItemIconDragContainer.h"
 
 #include "AbstractWindow.h"
@@ -36,10 +38,10 @@
 
 		setSize(CEGUI::UVector2(
 			cegui_absdim(item->getSize().first*30),
-			cegui_absdim(item->getSize().second*30))); 
+			cegui_absdim(item->getSize().second*30)));
 		mContentWindow->setSize(CEGUI::UVector2(
 			cegui_absdim(item->getSize().first*30),
-			cegui_absdim(item->getSize().second*30))); 
+			cegui_absdim(item->getSize().second*30)));
 		setTooltipText(item->getName());
 
 		addChildWindow(mContentWindow);

Modified: rl/trunk/engine/ui/src/JournalWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/JournalWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/JournalWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "JournalWindow.h"
 
 #include <boost/bind.hpp>

Modified: rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp
===================================================================
--- rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ListboxWrappedTextItem.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -2,12 +2,12 @@
 	filename: 	ListboxWrappedTextItem.cpp
 	created:	01/8/2006
 	author:		Paul D Turner & The CEGUI Development Team, Philipp Walser
-	
+
 	purpose:	Implementation of List box text items with WordWrapping
 *************************************************************************/
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Perl Artistic License.
 *
@@ -20,6 +20,8 @@
 *  along with this program; if not you can get it here
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
+#include "stdinc.h" //precompiled header
+
 #include "ListboxWrappedTextItem.h"
 #include "CEGUIFontManager.h"
 #include "CEGUIFont.h"
@@ -121,7 +123,7 @@
             formatRect.setSize(size);
             uint lines = font->getFormattedLineCount(d_itemText, formatRect, d_textFormatting);
             size.d_height *= lines;
-            size.d_height += d_padding;		
+            size.d_height += d_padding;
         }
 
         return size;
@@ -153,11 +155,11 @@
             finalPos.d_y -= PixelAligned((font->getLineSpacing() - font->getBaseline()) * 0.5f);
             Rect draw_area = Rect(finalPos.d_x, finalPos.d_y,
                 clipper.d_right, finalPos.d_y);
-            font->drawText(ds_bullet, draw_area, finalPos.d_z, clipper, d_textFormatting, 
+            font->drawText(ds_bullet, draw_area, finalPos.d_z, clipper, d_textFormatting,
                 getModulateAlphaColourRect(d_textCols, alpha));
             draw_area.d_left += left_offset;
-            font->drawText(d_itemText, draw_area, finalPos.d_z, clipper, d_textFormatting, 
-                getModulateAlphaColourRect(d_textCols, alpha));  
+            font->drawText(d_itemText, draw_area, finalPos.d_z, clipper, d_textFormatting,
+                getModulateAlphaColourRect(d_textCols, alpha));
         }
 
     }
@@ -193,7 +195,7 @@
 
 
     /*************************************************************************
-    Set the colours used for text rendering.	
+    Set the colours used for text rendering.
     *************************************************************************/
     void ListboxWrappedTextItem::setTextColours(colour top_left_colour,
         colour top_right_colour,

Modified: rl/trunk/engine/ui/src/LogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/LogWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/LogWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "LogWindow.h"
 
@@ -37,21 +38,21 @@
 
 		centerWindow();
 	}
-	
+
 	LogWindow::~LogWindow()
 	{
 	}
-	
+
 	bool LogWindow::update()
 	{
 		mErrorLog->setText(Logger::getSingleton().getErrorLog());
 		mErrorLog->setCaratIndex(1999999999);
 		mErrorLog->ensureCaratIsVisible();
 		//TODO: ogre.log und rastullah.log
-		
+
 		return true;
 	}
-	
+
 	void LogWindow::setVisible(bool visible, bool destroyAfterHide)
 	{
 		AbstractWindow::setVisible(visible, destroyAfterHide);
@@ -61,6 +62,6 @@
 			update();
 		}
 	}
-	
-	
+
+
 } // namespace rl

Modified: rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/MainMenuEngineWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include <boost/bind.hpp>
 
 #include "UiPrerequisites.h"

Modified: rl/trunk/engine/ui/src/MainMenuWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MainMenuWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/MainMenuWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "MainMenuWindow.h"
 
 #include <boost/bind.hpp>

Modified: rl/trunk/engine/ui/src/MessageWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MessageWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/MessageWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "MessageWindow.h"
 
 using namespace CEGUI;

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -14,6 +14,8 @@
 *  http://www.perldoc.com/perl5.6/Artistic.html.
 */
 
+#include "stdinc.h"
+
 #include "MovementControlState.h"
 
 #include <OgreSceneManager.h>

Modified: rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ObjectDescriptionWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ObjectDescriptionWindow.h"
 
@@ -25,11 +26,11 @@
 	{
 		mDescription = getMultiLineEditbox("ObjectDescriptionWindow/Text");
 	}
-	
+
 	ObjectDescriptionWindow::~ObjectDescriptionWindow()
 	{
 	}
-	
+
 	void ObjectDescriptionWindow::show(GameObject* object)
 	{
 		if (mObject != object)
@@ -48,5 +49,5 @@
 			mObject = object;
 		}
 	}
-	
+
 } // namespace rl

Modified: rl/trunk/engine/ui/src/PlaylistWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/PlaylistWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/PlaylistWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include <boost/bind.hpp>
 
 #include "UiPrerequisites.h"
@@ -35,16 +37,16 @@
 	mPlaylistTable->addColumn((utf8*)"Name", 0, cegui_reldim(0.5));
 	mPlaylistTable->addColumn((utf8*)"Dauer", 1, cegui_reldim(0.3));
 	mPlaylistTable->setUserSortControlEnabled(false);
-	
+
     /* getWindow("PlaylistWindow")->subscribeEvent(
-            Window::EventMouseClick, 
+            Window::EventMouseClick,
             boost::bind(&MainMenuWindow::handleChooseModules, this)); */
 
     getWindow("PlaylistSheet/ButtonSheet/Play")->subscribeEvent(
-            Window::EventMouseClick, 
+            Window::EventMouseClick,
             boost::bind(&PlaylistWindow::handlePlay, this));
     getWindow("PlaylistSheet/ButtonSheet/Quit")->subscribeEvent(
-            Window::EventMouseClick, 
+            Window::EventMouseClick,
             boost::bind(&PlaylistWindow::handleQuit, this));
     bindDestroyWindowToClick(getWindow("PlaylistSheet"));
 	bindDestroyWindowToXButton();

Modified: rl/trunk/engine/ui/src/ProgressWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ProgressWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/ProgressWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "ProgressWindow.h"
 

Modified: rl/trunk/engine/ui/src/PropertiesWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/PropertiesWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/PropertiesWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 /**
  * \file PropertiesWindow.cpp
@@ -50,19 +51,19 @@
         mMainTable->addColumn( (utf8*)"Key", 0, cegui_reldim(0.3));
         mMainTable->addColumn( (utf8*)"Type", 1, cegui_reldim(0.3));
         mMainTable->addColumn( (utf8*)"Value", 2, cegui_reldim(0.4));
-        
+
         centerWindow();
 
         bindDestroyWindowToXButton();
         bindDestroyWindowToClick(getWindow("PropertiesWindow/CloseButton"));
-	    
+
 		initialize(mObject);
 	}
 
     //------------------------------------------------------- Destructor
 
-	PropertiesWindow::~PropertiesWindow() 
-	{        
+	PropertiesWindow::~PropertiesWindow()
+	{
 	}
 
     //------------------------------------------------------- initialize
@@ -70,7 +71,7 @@
 	void PropertiesWindow::initialize( PropertyHolder* object )
 	{
         // Fill header text fields with name and description
-        fillHeader(object);    
+        fillHeader(object);
 
         // Get the property set of the object
         PropertySet* props = object->getAllProperties();
@@ -82,7 +83,7 @@
             propIter != props->end(); propIter++ )
         {
             Ogre::String key = propIter->first;
-            
+
             if( key == "description" || key == "name" )
                 continue;
 
@@ -181,7 +182,7 @@
 
     //------------------------------------------------------- addPropertyInt
 
-    void PropertiesWindow::addPropertyInt(const Property& prop, 
+    void PropertiesWindow::addPropertyInt(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
@@ -196,8 +197,8 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("Int  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
-                2, 
+            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())),
+                2,
                 rowCount);
         }
         // Table has the two columns Type, Value
@@ -205,15 +206,15 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Int  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())), 
-                1, 
+            table->setItem(new ListboxTextItem(PropertyHelper::intToString(prop.toInt())),
+                1,
                 rowCount);
         }
     }
 
     //------------------------------------------------------- addPropertyIntPair
 
-    void PropertiesWindow::addPropertyIntPair(const Property& prop, 
+    void PropertiesWindow::addPropertyIntPair(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
@@ -231,10 +232,10 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("IntPair  "), 1, rowCount);
-            table->setItem(new ListboxTextItem( "( " + 
+            table->setItem(new ListboxTextItem( "( " +
                 PropertyHelper::intToString(intPair.first) + ", " +
-                PropertyHelper::intToString(intPair.second) + " )"), 
-                2, 
+                PropertyHelper::intToString(intPair.second) + " )"),
+                2,
                 rowCount);
         }
         // Table has the two columns Type, Value
@@ -242,17 +243,17 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("IntPair  "), 0, rowCount);
-            table->setItem(new ListboxTextItem("( " + 
+            table->setItem(new ListboxTextItem("( " +
                 PropertyHelper::intToString(intPair.first) + ", " +
-                PropertyHelper::intToString(intPair.second) + " )"), 
-                1, 
+                PropertyHelper::intToString(intPair.second) + " )"),
+                1,
                 rowCount);
         }
     }
 
     //------------------------------------------------------- addPropertyIntTriple
 
-    void PropertiesWindow::addPropertyIntTriple(const Property& prop, 
+    void PropertiesWindow::addPropertyIntTriple(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
@@ -274,7 +275,7 @@
                 PropertyHelper::intToString(intTriple.first) + ", " +
                 PropertyHelper::intToString(intTriple.second) + ", " +
                 PropertyHelper::intToString(intTriple.third) + " )"),
-                2, 
+                2,
                 rowCount);
         }
         // Table has the two columns Type, Value
@@ -285,15 +286,15 @@
             table->setItem(new ListboxTextItem("( " +
                 PropertyHelper::intToString(intTriple.first) + ", " +
                 PropertyHelper::intToString(intTriple.second) + ", " +
-                PropertyHelper::intToString(intTriple.third) + " )"), 
-                1, 
+                PropertyHelper::intToString(intTriple.third) + " )"),
+                1,
                 rowCount);
-        } 
+        }
     }
 
     //------------------------------------------------------- addPropertyString
 
-    void PropertiesWindow::addPropertyString(const Property& prop, 
+    void PropertiesWindow::addPropertyString(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
@@ -308,8 +309,8 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("String    "), 1, rowCount);
-            table->setItem(new ListboxTextItem(prop.toString()), 
-                2, 
+            table->setItem(new ListboxTextItem(prop.toString()),
+                2,
                 rowCount);
         }
         // Table has the two columns Type, Value
@@ -317,15 +318,15 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("String    "), 0, rowCount);
-            table->setItem(new ListboxTextItem(prop.toString()), 
-                1, 
+            table->setItem(new ListboxTextItem(prop.toString()),
+                1,
                 rowCount);
         }
     }
 
     //------------------------------------------------------- addPropertyBool
 
-    void PropertiesWindow::addPropertyBool(const Property& prop, 
+    void PropertiesWindow::addPropertyBool(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
@@ -340,8 +341,8 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("Bool  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
-                2, 
+            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())),
+                2,
                 rowCount);
         }
         // Table has the two columns Type, Value
@@ -349,15 +350,15 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Bool  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())), 
-                1, 
+            table->setItem(new ListboxTextItem(PropertyHelper::boolToString(prop.toBool())),
+                1,
                 rowCount);
         }
     }
 
     //------------------------------------------------------- addPropertyReal
 
-    void PropertiesWindow::addPropertyReal(const Property& prop, 
+    void PropertiesWindow::addPropertyReal(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
        // Check column count
@@ -375,8 +376,8 @@
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem(key + "  "), 0, rowCount);
             table->setItem(new ListboxTextItem("Real  "), 1, rowCount);
-            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
-                2, 
+            table->setItem(new ListboxTextItem(CEGUI::String(buf)),
+                2,
                 rowCount);
         }
         // Table has the two columns Type, Value
@@ -384,15 +385,15 @@
         {
             table->addRow(rowCount);
             table->setItem(new ListboxTextItem("Real  "), 0, rowCount);
-            table->setItem(new ListboxTextItem(CEGUI::String(buf)), 
-                1, 
+            table->setItem(new ListboxTextItem(CEGUI::String(buf)),
+                1,
                 rowCount);
         }
     }
 
     //------------------------------------------------------- addPropertyVector3
 
-    void PropertiesWindow::addPropertyVector3(const Property& prop, 
+    void PropertiesWindow::addPropertyVector3(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
@@ -419,8 +420,8 @@
             table->setItem(new ListboxTextItem("Vector3  "), 1, rowCount);
             table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
                 CEGUI::String(buf2) + ", " +
-                CEGUI::String(buf3) + " )"), 
-                2 , 
+                CEGUI::String(buf3) + " )"),
+                2 ,
                 rowCount);
         }
         // Table has the two columns Type, Value
@@ -430,15 +431,15 @@
             table->setItem(new ListboxTextItem("Vector3  "), 0, rowCount);
             table->setItem(new ListboxTextItem("( " + CEGUI::String(buf1) + ", " +
                 CEGUI::String(buf2) + ", " +
-                CEGUI::String(buf3) + " )"), 
-                1 , 
+                CEGUI::String(buf3) + " )"),
+                1 ,
                 rowCount);
-        } 
+        }
     }
 
     //------------------------------------------------------- addPropertyQuaternion
 
-    void PropertiesWindow::addPropertyQuaternion(const Property& prop, 
+    void PropertiesWindow::addPropertyQuaternion(const Property& prop,
         CEGUI::MultiColumnList* table, const Ogre::String& key)
     {
         // Check column count
@@ -472,15 +473,15 @@
             table->setItem(new ListboxTextItem("Axis:   ( " +
                 CEGUI::String(buf_v1) + ", " +
                 CEGUI::String(buf_v2) + ", " +
-                CEGUI::String(buf_v3) + " )"), 
-                2, 
+                CEGUI::String(buf_v3) + " )"),
+                2,
                 rowCount);
 
             // Add second for the second IntTriple value
             table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Degree: " + 
-                CEGUI::String(buf_angle)), 
-                2, 
+            table->setItem(new ListboxTextItem("Degree: " +
+                CEGUI::String(buf_angle)),
+                2,
                 rowCount + 1);
         }
         // Table has the two columns Type, Value
@@ -491,17 +492,17 @@
             table->setItem(new ListboxTextItem("Axis:   ( " +
                 CEGUI::String(buf_v1) + ", " +
                 CEGUI::String(buf_v2) + ", " +
-                CEGUI::String(buf_v3) + " )"), 
-                2, 
+                CEGUI::String(buf_v3) + " )"),
+                2,
                 rowCount);
 
             // Add second for the second IntTriple value
             table->addRow(rowCount + 1);
-            table->setItem(new ListboxTextItem("Degree " + 
-                CEGUI::String(buf_angle)), 
-                2, 
+            table->setItem(new ListboxTextItem("Degree " +
+                CEGUI::String(buf_angle)),
+                2,
                 rowCount + 1);
-        } 
+        }
 
     }
 
@@ -513,16 +514,16 @@
         // Type and Value and set tab text to key
         int tabCount = mTabPane->getTabCount();
         CEGUI::MultiColumnList* newTable = static_cast<CEGUI::MultiColumnList*>
-            (CEGUI::WindowManager::getSingleton().createWindow("RastullahLook/MultiColumnList", 
+            (CEGUI::WindowManager::getSingleton().createWindow("RastullahLook/MultiColumnList",
             "PropertiesWindow/PropertiesTabControl/" + key));
 
         // Set table properties
         newTable->setText(key);
-        newTable->setPosition(CEGUI::UVector2( 
-            CEGUI::UDim(0,0), 
+        newTable->setPosition(CEGUI::UVector2(
+            CEGUI::UDim(0,0),
             CEGUI::UDim(0,0)));
         newTable->setSize(CEGUI::UVector2(
-            CEGUI::UDim(1,0), 
+            CEGUI::UDim(1,0),
             CEGUI::UDim(1,0)));
         newTable->setUserSortControlEnabled(false);
         newTable->setFont("Vera Serif-8");
@@ -535,7 +536,7 @@
 
         // Get access to the vector
         PropertyVector vProp = prop.toArray();
-        
+
         // Iterate through the vector entries and add them
         // to the table
         for(PropertyVector::const_iterator it = vProp.begin(); it != vProp.end(); it++)

Modified: rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp
===================================================================
--- rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/RenderSystemConfigComponent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "RenderSystemConfigComponent.h"
 

Modified: rl/trunk/engine/ui/src/SaveLoadWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/SaveLoadWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 /**
  * \file SaveLoadWindow.cpp
@@ -41,14 +42,14 @@
         // Get a access to the filename edit box
         mFilename = getEditbox("SaveLoadWindow/FileSheet/Filename");
         RlAssert(mFilename != NULL, "SaveLoadWindow/FileSheet/File is null");
-        
+
         // Get a access to the savegame table
         mSaveGameTable = getMultiColumnList("SaveLoadWindow/FileSheet/SaveGameTable");
         RlAssert(mSaveGameTable != NULL, "SaveLoadWindow/FileSheet/SaveGameTable is null");
 
         mSaveGameTable->addColumn( (utf8*)"Filename", 0, cegui_reldim(0.7));
         mSaveGameTable->addColumn( (utf8*)"Date", 1, cegui_reldim(0.3));
-        
+
         centerWindow();
 
         getPushButton("SaveLoadWindow/ButtonSheet/LoadButton")->subscribeEvent(
@@ -57,30 +58,30 @@
             &SaveLoadWindow::handleLoadEvent,
             this
         ));
-        
+
         getPushButton("SaveLoadWindow/ButtonSheet/SaveButton")->subscribeEvent(
         CEGUI::Window::EventMouseClick,
         boost::bind(
             &SaveLoadWindow::handleSaveEvent,
             this
         ));
-        
+
         getPushButton("SaveLoadWindow/ButtonSheet/DeleteButton")->subscribeEvent(
         CEGUI::Window::EventMouseClick,
         boost::bind(
             &SaveLoadWindow::handleDeleteEvent,
             this
         ));
-        
+
         bindDestroyWindowToXButton();
         bindDestroyWindowToClick(getWindow("SaveLoadWindow/ButtonSheet/CancelButton"));
-        
+
     }
 
     //------------------------------------------------------- Destructor
 
-    SaveLoadWindow::~SaveLoadWindow() 
-    {        
+    SaveLoadWindow::~SaveLoadWindow()
+    {
     }
 
     //------------------------------------------------------- initialize
@@ -90,39 +91,39 @@
         //mSaveGameTable->autoSizeColumnHeader(0);
         //mSaveGameTable->autoSizeColumnHeader(1);
     }
-    
+
     //------------------------------------------------------- LoadEvent
 
-    bool SaveLoadWindow::handleLoadEvent() 
+    bool SaveLoadWindow::handleLoadEvent()
     {
         LOG_MESSAGE(Logger::UI, "Load Button pressed");
-        return true;        
+        return true;
     }
-    
+
     //------------------------------------------------------- SaveEvent
 
-    bool SaveLoadWindow::handleSaveEvent() 
+    bool SaveLoadWindow::handleSaveEvent()
     {
         LOG_MESSAGE(Logger::UI, "Save Button pressed");
-        
+
         std::list<const GameObject*>::const_iterator it;
         std::list<const GameObject*> gos;
         gos = GameObjectManager::getSingleton().getAllGameObjects();
-        
+
         LOG_MESSAGE(Logger::UI, "Following GOs must be saved:");
         for( it=gos.begin(); it!=gos.end(); ++it )
         {
             //const CeGuiString test = (*it)->getName();
             LOG_MESSAGE(Logger::UI, "ClassId: " + (*it)->getClassId() +
-                " Name: " + (*it)->getName());    
+                " Name: " + (*it)->getName());
         }
-        
-        return true;        
+
+        return true;
     }
 
     //------------------------------------------------------- DeleteEvent
 
-    bool SaveLoadWindow::handleDeleteEvent() 
+    bool SaveLoadWindow::handleDeleteEvent()
     {
         LOG_MESSAGE(Logger::UI, "Delete Button pressed");
         return true;

Modified: rl/trunk/engine/ui/src/SoundConfig.cpp
===================================================================
--- rl/trunk/engine/ui/src/SoundConfig.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/SoundConfig.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,8 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
+
 #include "SoundConfig.h"
 
 #include <boost/bind.hpp>
@@ -47,12 +49,12 @@
 			boost::bind(&SoundConfig::handleClose, this));
 
 		getWindow("SoundConfig/OK")->subscribeEvent(
-			Window::EventMouseClick, 
+			Window::EventMouseClick,
 			boost::bind(&SoundConfig::handleOK, this));
-            
+
 		mVolumeSound = getSlider("SoundConfig/VolumeSound");
 		mVolumeSound->setMaxValue(1.0);
-		mVolumeSound->setCurrentValue(	
+		mVolumeSound->setCurrentValue(
 			SoundManager::getSingleton()
 			.getActiveDriver()
 			->getDefaultSoundVolume());
@@ -62,7 +64,7 @@
 
 		mVolumeMusic = getSlider("SoundConfig/VolumeMusic");
 		mVolumeMusic->setMaxValue(1.0);
-		mVolumeMusic->setCurrentValue(	
+		mVolumeMusic->setCurrentValue(
 			SoundManager::getSingleton()
 			.getActiveDriver()
 			->getDefaultMusicVolume());
@@ -72,7 +74,7 @@
 
 		mVolumeMaster = getSlider("SoundConfig/VolumeMaster");
 		mVolumeMaster->setMaxValue(1.0);
-		mVolumeMaster->setCurrentValue(	
+		mVolumeMaster->setCurrentValue(
 			SoundManager::getSingleton()
 			.getActiveDriver()
 			->getMasterVolume());
@@ -96,11 +98,11 @@
 
 	bool SoundConfig::handleOK()
 	{
-		ListboxTextItem *item = 
+		ListboxTextItem *item =
 			dynamic_cast<ListboxTextItem*>(mDriverBox->getSelectedItem());
 		if (item != 0)
 		{
-			SoundDriver *activeDriver = SoundManager::getSingleton().getActiveDriver();        
+			SoundDriver *activeDriver = SoundManager::getSingleton().getActiveDriver();
 			if (item->getText() != activeDriver->getName())
 			{
 				// Nicht der aktive Treiber, also ???ndern.
@@ -148,8 +150,8 @@
 
         mDriverBox->addItem(
             new ListboxTextItem(
-                wnd->getDriverName(), 
-                mDriverBox->getItemCount(), 
+                wnd->getDriverName(),
+                mDriverBox->getItemCount(),
                 wnd));
 	}
 

Modified: rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp
===================================================================
--- rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/SoundDriverConfigComponent.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "SoundDriverConfigComponent.h"
 

Modified: rl/trunk/engine/ui/src/SubtitleWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/SubtitleWindow.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/SubtitleWindow.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "SubtitleWindow.h"
 
@@ -25,16 +26,16 @@
 	{
 		mSubtitle = getMultiLineEditbox("SubtitleWindow/Text");
 	}
-	
+
 	SubtitleWindow::~SubtitleWindow()
 	{
 	}
-	
+
 	void SubtitleWindow::show(const CeGuiString& text)
 	{
 		mSubtitle->setText(text);
 		setVisible(true);
-        LOG_DEBUG(Logger::UI, 
+        LOG_DEBUG(Logger::UI,
 			"Subtitle: " + text);
 	}
 
@@ -42,5 +43,5 @@
 	{
 		return mSubtitle->getText();
 	}
-	
+
 } // namespace rl

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
 
 #include "UiSubsystem.h"
 

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "WindowFactory.h"
 
 #include "AboutWindow.h"
@@ -167,7 +169,7 @@
         PropertiesWindow* wnd = new PropertiesWindow(obj);
         wnd->setVisible(true);
     }
-    
+
     void WindowFactory::showSaveLoadWindow()
     {
         SaveLoadWindow* wnd = new SaveLoadWindow();

Modified: rl/trunk/engine/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,6 +13,7 @@
 *  along with this program; if not you can get it here
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
+#include "stdinc.h" //precompiled header
 
 #include "WindowFadeJob.h"
 

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,6 +13,8 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h" //precompiled header
+
 #include "WindowManager.h"
 #include <CEGUIWindowManager.h>
 
@@ -46,7 +48,7 @@
 		}
 		mWindowList.clear();
 	}
-	
+
 	void WindowManager::registerWindow(AbstractWindow* window)
 	{
 		mWindowList.push_back(window);
@@ -81,7 +83,7 @@
 		mWindowList.push_front(window);
 		return true;
 	}
-	
+
 	bool WindowManager::handleMovedToBack(AbstractWindow* window)
 	{
 		mWindowList.remove(window);

Added: rl/trunk/engine/ui/src/stdinc.cpp
===================================================================
--- rl/trunk/engine/ui/src/stdinc.cpp	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/engine/ui/src/stdinc.cpp	2007-07-13 20:43:27 UTC (rev 3600)
@@ -0,0 +1,17 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.perldoc.com/perl5.6/Artistic.html.
+ */
+
+#include "stdinc.h"
\ No newline at end of file

Modified: rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj
===================================================================
--- rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj	2007-07-12 20:00:25 UTC (rev 3599)
+++ rl/trunk/plugins/fmod4driver/RlFmod4Driver.vcproj	2007-07-13 20:43:27 UTC (rev 3600)
@@ -4,6 +4,7 @@
 	Version="8,00"
 	Name="RlFmod4Driver"
 	ProjectGUID="{A2DD1E40-4D80-44C5-B04E-1B1C4B07131C}"
+	RootNamespace="RlFmod4Driver"
 	>
 	<Platforms>
 		<Platform
@@ -300,6 +301,10 @@
 				RelativePath=".\include\Fmod4Sound.h"
 				>
 			</File>
+			<File
+				RelativePath="..\..\engine\core\include\stdinc.h"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Resource Files"



From chrber at mail.berlios.de  Fri Jul 13 23:26:08 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Fri, 13 Jul 2007 23:26:08 +0200
Subject: [Dsa-hl-svn] r3601 - rl/trunk/engine/ui/src
Message-ID: <200707132126.l6DLQ8AA022797@sheep.berlios.de>

Author: chrber
Date: 2007-07-13 23:26:04 +0200 (Fri, 13 Jul 2007)
New Revision: 3601

Modified:
   rl/trunk/engine/ui/src/DialogControlState.cpp
Log:
Fixed an unusable file


Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2007-07-13 20:43:27 UTC (rev 3600)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2007-07-13 21:26:04 UTC (rev 3601)
@@ -1,795 +1,492 @@
-<<<<<<< .mine
-/*
-* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  http://www.perldoc.com/perl5.6/Artistic.html.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "DialogControlState.h"
-#include "Exception.h"
-
-#include "Actor.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "DialogCharacter.h"
-#include "DialogSubsystem.h"
-#include "DialogWindow.h"
-#include "InputManager.h"
-#include "MeshAnimation.h"
-#include "MeshObject.h"
-#include "Person.h"
-#include "PhysicalThing.h"
-#include "Sound.h"
-#include "SoundDriver.h"
-#include "SoundManager.h"
-#include "SoundObject.h"
-#include "SubtitleWindow.h"
-#include "WindowFactory.h"
-#include "WindowManager.h"
-#include "World.h"
-
-#include <OgreSceneManager.h>
-#include <OgreNewt_Body.h>
-
-using namespace Ogre;
-
-namespace rl {
-
-    DialogControlState::DialogControlState(CommandMapper* cmdMapper,
-        Actor* camera, Person* character)
-        : ControlState(cmdMapper, camera, character, CST_DIALOG),
-        mTargetCameraPosition(Vector3::ZERO),
-        mTargetCameraDirection(Vector3::UNIT_Z),
-        mCurrFadeTextTime(0),
-        mTotalFadeTextTime(0),
-        mText(),
-        mDialogMode(DM_FRONT),
-        mTextShown(false),
-        mDialogWindow(NULL),
-        mSubtitleWindow(NULL),
-        mSoundObject(NULL),
-        mTalkAnimation(NULL),
-        mSubtitleSpeed(1.0f)
-    {
-        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
-            "General", "Subtitle Speed");
-
-    }
-
-    DialogControlState::~DialogControlState()
-    {
-        delete mSoundObject;
-    }
-
-    void DialogControlState::pause()
-    {
-        if(mDialogPartner)
-        {
-            MeshObject* mesh = dynamic_cast<MeshObject*>(mDialogPartner->getControlledObject());
-            if (mesh != NULL)
-            {
-                mesh->stopAllAnimations();
-                if (mesh->hasAnimation("idle"))
-                {
-                    mTalkAnimation = mesh->startAnimation("idle");
-                }
-            }
-        }
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCharacterActor->getPhysicalThing()->unfreeze();
-        mDialogWindow->setVisible(false, false);
-        mSubtitleWindow->setVisible(false, false);
-    }
-
-    void DialogControlState::resume()
-    {
-        mCharacterActor->setVisible(true);
-
-        mCameraActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->freeze();
-        Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
-        ogreCam->setFixedYawAxis(true);
-        ogreCam->setPosition(Vector3::ZERO);
-        ogreCam->setOrientation(Quaternion::IDENTITY);
-        mCameraActor->_getSceneNode()->setFixedYawAxis(true);
-
-        DialogCharacter* bot = DialogSubsystem::getSingleton().getCurrentDialogCharacter();
-        bot->setDialogCharacter(mCharacter);
-		mDialogPartner = bot->getDialogPartner()->getActor();
-
-        recalculateCamera( mDialogPartner, mCharacterActor );
-
-        mSubtitleWindow = WindowFactory::getSingleton().getSubtitleWindow();
-
-        mDialogWindow = WindowFactory::getSingleton().getDialogWindow();
-        mDialogWindow->initialize(this, bot);
-		mDialogWindow->start();
-    }
-
-    void DialogControlState::run(Real elapsedTime)
-    {
-        if( elapsedTime <= 0.0 )
-            return;
-
-        // Aktuellen Abstand zur gew?nschten Position berechnen
-        Vector3 posDistance = (mTargetCameraPosition - mCameraActor->_getSceneNode()->getPosition());
-        // Ist eine Anpassung n?tig?
-        if( posDistance != Vector3::ZERO )
-        {
-            // Die Kameraanpassgeschwindigkeit
-            Real speed = 1/elapsedTime;
-            mCameraActor->setPosition(mTargetCameraPosition);
-        }
-
-        mCameraActor->setOrientation( Quaternion::IDENTITY );
-        mCameraActor->_getSceneNode()->setDirection( mTargetCameraDirection );
-        mCameraActor->_getSceneNode()->_update( true, false );
-
-        // Textanzeigedauer
-        if (mCurrFadeTextTime >= 0)
-        {
-            mCurrFadeTextTime -= elapsedTime;
-        }
-
-        if (mTextShown && mCurrFadeTextTime <= 0)
-        {
-            mCurrFadeTextTime = 0;
-            mTotalFadeTextTime = 0;
-            mTextShown = false;
-               if (mSoundObject)
-            {
-                mSoundObject->stop();
-            }
-            mSubtitleWindow->setVisible(false, false);
-            mDialogWindow->textFinished();
-        }
-
-        LOG_DEBUG(Logger::UI,
-                StringConverter::toString(mSubtitleWindow->getWindow()->getEffectiveAlpha())
-                + ": "
-                + mSubtitleWindow->getText()
-                + CeGuiString(mSubtitleWindow->getWindow()->isVisible() ? "vis" : "unvis")
-                + ", Time: "
-                + StringConverter::toString(mCurrFadeTextTime));
-    }
-
-    void DialogControlState::recalculateCamera( Actor* speaker, Actor* listener )
-    {
-        // Position camera at position between char and dialog partner
-        Vector3 charEyes = speaker->getWorldPosition();
-        // Modify by MeshBounds
-        if( speaker->getControlledObject()->isMeshObject() )
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(speaker->getControlledObject());
-            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            charEyes += speaker->getWorldOrientation()*offset;
-        }
-
-        Vector3 partEyes = listener->getWorldPosition();
-        // Modify by MeshBounds
-        if( listener->getControlledObject()->isMeshObject() )
-        {
-            MeshObject* mo = dynamic_cast<MeshObject*>(listener->getControlledObject());
-            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y*0.933,
-                aab.getCenter().z );
-            partEyes += listener->getWorldOrientation()*offset;
-        }
-
-        Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
-
-        // Weltkoordinaten in lokale umwandeln
-        mTargetCameraPosition =
-            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
-            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
-
-
-        mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
-    }
-
-    float DialogControlState::getShowTextLength(const CeGuiString& text) const
-    {
-        return 0.019f * text.length() + // Zeit f?rs Text lesen
-               0.25f;                   // Fade in
-    }
-
-    void DialogControlState::response(
-        Actor* actor, const CeGuiString& text, const Ogre::String& soundFile)
-    {
-        if( actor == mDialogPartner )
-            recalculateCamera( mCharacterActor, mDialogPartner );
-        else
-            recalculateCamera( mDialogPartner, mCharacterActor );
-
-        // Ungef?hre Lesedauer bestimmen
-        float fadeTime = getShowTextLength(text);
-        if (soundFile.length() == 0)
-        {
-            float speed = mSubtitleSpeed;
-
-            if( mSubtitleSpeed == 0.0 )
-                speed = 1.0;
-
-            mCurrFadeTextTime = fadeTime*speed;
-            mTotalFadeTextTime = fadeTime*speed;
-        }
-        else
-        {
-            if( mSoundObject != NULL )
-                mSoundObject->getMovableObject()->getParentSceneNode()->detachObject(
-                    mSoundObject->getMovableObject() );
-
-            delete mSoundObject;
-            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()->
-                    createSound(soundFile, ST_SAMPLE), soundFile);
-
-            // An Sprecher h?ngen
-            actor->_getSceneNode()->attachObject( mSoundObject->getMovableObject() );
-            actor->_getSceneNode()->_update( true, false );
-            mSoundObject->_setActor( actor );
-            mSoundObject->set3d(true);
-            mSoundObject->play();
-            mSoundObject->_update();
-
-
-            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject->getLength());
-            mTotalFadeTextTime = mCurrFadeTextTime;
-        }
-
-        MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
-        if (mesh != NULL)
-        {
-            if (mesh->hasAnimation("reden"))
-            {
-                mesh->stopAllAnimations();
-                mTalkAnimation = mesh->startAnimation("reden");
-            }
-        }
-
-        LOG_DEBUG(Logger::UI,
-            "Response: "
-                + actor->getName()
-                + " File: '"
-                + soundFile
-                + "', Text: '" + text + "', Time: "
-                + StringConverter::toString(mCurrFadeTextTime));
-
-
-        mTextShown = true;
-
-        if (mSubtitleWindow != NULL && !text.empty())
-        {
-            mSubtitleWindow->show(text);
-        }
-    }
-
-    bool DialogControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id)
-    {
-
-        if (mTextShown && (mCurrFadeTextTime + 0.25) < mTotalFadeTextTime)
-        {
-            mCurrFadeTextTime = -1;
-
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-
-    }
-}
-=======
-??/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+/*
+* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Perl Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Perl Artistic License for more details.
+*
+*  You should have received a copy of the Perl Artistic License
+*  along with this program; if not you can get it here
+*  http://www.perldoc.com/perl5.6/Artistic.html.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "DialogControlState.h"
+#include "Exception.h"
+
+#include "Actor.h"
+#include "CameraObject.h"
+#include "CommandMapper.h"
+#include "ConfigurationManager.h"
+#include "CoreSubsystem.h"
+#include "DialogCharacter.h"
+#include "DialogOption.h"
+#include "DialogResponse.h"
+#include "DialogSubsystem.h"
+#include "DialogWindow.h"
+#include "GameLoggerWindow.h"
+#include "InputManager.h"
+#include "MeshAnimation.h"
+#include "MeshObject.h"
+#include "Person.h"
+#include "PhysicalThing.h"
+#include "Sound.h"
+#include "SoundDriver.h"
+#include "SoundManager.h"
+#include "SoundObject.h"
+#include "SubtitleWindow.h"
+#include "WindowFactory.h"
+#include "WindowManager.h"
+#include "World.h"
+
+#include <OgreSceneManager.h>
+#include <OgreNewt_Body.h>
+
+using namespace Ogre;
+
+namespace rl {
+
+	const CeGuiString DialogControlState::DIALOG_START = "1";
+	const CeGuiString DialogControlState::DIALOG_END = "DIALOG BEENDET";
+	const CeGuiString DialogControlState::DIALOG_EXIT = "EXIT";
+
+    DialogControlState::DialogControlState(CommandMapper* cmdMapper,
+        Actor* camera, Person* character)
+        : ControlState(cmdMapper, camera, character, CST_DIALOG),
+        mTargetCameraPosition(Vector3::ZERO),
+        mTargetCameraDirection(Vector3::UNIT_Z),
+        mCurrFadeTextTime(0),
+        mTotalFadeTextTime(0),
+        mText(),
+        mDialogMode(DM_FRONT),
+        mTextShown(false),
+        mDialogWindow(NULL),
+        mSubtitleWindow(NULL),
+        mSoundObject(NULL),
+        mTalkAnimation(NULL),
+        mSubtitleSpeed(1.0f),
+		mCurrentResponse(NULL),
+		mCurrentResponseText(""),
+		mBot(NULL),
+		mGameLogger(NULL)
+    {
+        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
+            "General", "Subtitle Speed");
+    }
+
+    DialogControlState::~DialogControlState()
+    {
+        delete mSoundObject;
+    }
+
+    void DialogControlState::pause()
+    {
+        if (mDialogPartner)
+        {
+            MeshObject* mesh = dynamic_cast<MeshObject*>(mDialogPartner->getControlledObject());
+            if (mesh != NULL)
+            {
+                mesh->stopAllAnimations();
+                if (mesh->hasAnimation("idle"))
+                {
+                    mTalkAnimation = mesh->startAnimation("idle");
+                }
+            }
+        }
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCharacterActor->getPhysicalThing()->unfreeze();
+        mDialogWindow->setVisible(false, false);
+        mSubtitleWindow->setVisible(false, false);
+    }
+
+    void DialogControlState::resume()
+    {
+        mCharacterActor->setVisible(true);
+
+        mCameraActor->getPhysicalThing()->freeze();
+        mCharacterActor->getPhysicalThing()->freeze();
+        Camera* ogreCam = static_cast<Camera*>(mCameraActor->_getMovableObject());
+        ogreCam->setFixedYawAxis(true);
+        ogreCam->setPosition(Vector3::ZERO);
+        ogreCam->setOrientation(Quaternion::IDENTITY);
+        mCameraActor->_getSceneNode()->setFixedYawAxis(true);
+
+        mDialogWindow = new DialogWindow(this);
+        mSubtitleWindow = new SubtitleWindow();
+
+		mGameLogger = WindowFactory::getSingleton().getGameLogger();
+
+		DialogCharacter* bot = DialogSubsystem::getSingleton().getCurrentDialogCharacter();
+		initialize(bot);
+    }
+
+	void DialogControlState::initialize(DialogCharacter* bot)
+	{
+		mBot = bot;
+        mBot->setDialogCharacter(mCharacter);
+		mDialogPartner = mBot->getDialogPartner()->getActor();
+
+        recalculateCamera( mDialogPartner, mCharacterActor );
+
+		Ogre::String voiceFile = mBot->getVoiceFile().c_str();
+		if (voiceFile != "")
+		{
+			if (voiceFile.find(".zip") != Ogre::String::npos)
+			{
+				ResourceGroupManager::getSingleton().addResourceLocation(
+					voiceFile, "Zip", voiceFile);
+			}
+			else
+			{
+				ResourceGroupManager::getSingleton().addResourceLocation(
+           			voiceFile, "FileSystem", voiceFile);
+			}
+		}
+
+		start();
+	}
+
+    void DialogControlState::run(Real elapsedTime)
+    {
+        if ( elapsedTime <= 0.0 )
+            return;
+
+        // Aktuellen Abstand zur gew??nschten Position berechnen
+        Vector3 posDistance = (mTargetCameraPosition - mCameraActor->_getSceneNode()->getPosition());
+        // Ist eine Anpassung n??tig?
+        if ( posDistance != Vector3::ZERO )
+        {
+            // Die Kameraanpassgeschwindigkeit
+            Real speed = 1/elapsedTime;
+            mCameraActor->setPosition(mTargetCameraPosition);
+        }
+
+        mCameraActor->setOrientation( Quaternion::IDENTITY );
+        mCameraActor->_getSceneNode()->setDirection( mTargetCameraDirection );
+        mCameraActor->_getSceneNode()->_update( true, false );
+
+        // Textanzeigedauer
+        if (mCurrFadeTextTime >= 0)
+        {
+            mCurrFadeTextTime -= elapsedTime;
+        }
+
+        if (mTextShown && mCurrFadeTextTime <= 0)
+        {
+            mCurrFadeTextTime = 0;
+            mTotalFadeTextTime = 0;
+            mTextShown = false;
+               if (mSoundObject)
+            {
+                mSoundObject->stop();
+            }
+            mSubtitleWindow->setVisible(false, false);
+            textFinished();
+        }
+
+        LOG_DEBUG(Logger::UI,
+                StringConverter::toString(mSubtitleWindow->getWindow()->getEffectiveAlpha())
+                + ": "
+                + mSubtitleWindow->getText()
+                + CeGuiString(mSubtitleWindow->getWindow()->isVisible() ? "vis" : "unvis")
+                + ", Time: "
+                + StringConverter::toString(mCurrFadeTextTime));
+    }
+
+    void DialogControlState::recalculateCamera( Actor* speaker, Actor* listener )
+    {
+        // Position camera at position between char and dialog partner
+        Vector3 charEyes = speaker->getWorldPosition();
+        // Modify by MeshBounds
+        if ( speaker->getControlledObject()->isMeshObject() )
+        {
+            MeshObject* mo = dynamic_cast<MeshObject*>(speaker->getControlledObject());
+            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y*0.933,
+                aab.getCenter().z );
+            charEyes += speaker->getWorldOrientation()*offset;
+        }
+
+        Vector3 partEyes = listener->getWorldPosition();
+        // Modify by MeshBounds
+        if ( listener->getControlledObject()->isMeshObject() )
+        {
+            MeshObject* mo = dynamic_cast<MeshObject*>(listener->getControlledObject());
+            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y*0.933,
+                aab.getCenter().z );
+            partEyes += listener->getWorldOrientation()*offset;
+        }
+
+        Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
+
+        // Weltkoordinaten in lokale umwandeln
+        mTargetCameraPosition =
+            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
+            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
+
+
+        mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
+    }
+
+    float DialogControlState::getShowTextLength(const CeGuiString& text) const
+    {
+        return 0.019f * text.length() + // Zeit f??rs Text lesen
+               0.25f;                   // Fade in
+    }
+
+    void DialogControlState::response(
+        Actor* actor, const CeGuiString& text, const Ogre::String& soundFile)
+    {
+        if ( actor == mDialogPartner )
+            recalculateCamera( mCharacterActor, mDialogPartner );
+        else
+            recalculateCamera( mDialogPartner, mCharacterActor );
+
+        // Ungef??hre Lesedauer bestimmen
+        float fadeTime = getShowTextLength(text);
+        if (soundFile.length() == 0)
+        {
+            float speed = mSubtitleSpeed;
+
+            if ( mSubtitleSpeed == 0.0 )
+                speed = 1.0;
+
+            mCurrFadeTextTime = fadeTime*speed;
+            mTotalFadeTextTime = fadeTime*speed;
+        }
+        else
+        {
+            if ( mSoundObject != NULL )
+                mSoundObject->getMovableObject()->getParentSceneNode()->detachObject(
+                    mSoundObject->getMovableObject() );
+
+            delete mSoundObject;
+            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()->
+                    createSound(soundFile, ST_SAMPLE), soundFile);
+
+            // An Sprecher h??ngen
+            actor->_getSceneNode()->attachObject( mSoundObject->getMovableObject() );
+            actor->_getSceneNode()->_update( true, false );
+            mSoundObject->_setActor( actor );
+            mSoundObject->set3d(true);
+            mSoundObject->play();
+            mSoundObject->_update();
+
+
+            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject->getLength());
+            mTotalFadeTextTime = mCurrFadeTextTime;
+        }
+
+        MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
+        if (mesh != NULL)
+        {
+            if (mesh->hasAnimation("reden"))
+            {
+                mesh->stopAllAnimations();
+                mTalkAnimation = mesh->startAnimation("reden");
+            }
+        }
+
+        LOG_DEBUG(Logger::UI,
+            "Response: "
+                + actor->getName()
+                + " File: '"
+                + soundFile
+                + "', Text: '" + text + "', Time: "
+                + StringConverter::toString(mCurrFadeTextTime));
+
+
+        mTextShown = true;
+
+        if (mSubtitleWindow != NULL && !text.empty())
+        {
+            mSubtitleWindow->show(text);
+        }
+    }
+
+    bool DialogControlState::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id)
+    {
+
+        if (mTextShown && (mCurrFadeTextTime + 0.25) < mTotalFadeTextTime)
+        {
+            mCurrFadeTextTime = -1;
+
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+	void DialogControlState::start()
+	{
+		if (!mBot || !mDialogWindow)
+		{
+			Throw(IllegalStateException, "DialogControlState not properly initialized.");
+		}
+
+		mDialogWindow->setName(mBot->getName());
+		getResponse(DIALOG_START);
+	}
+
+	void DialogControlState::getResponse(const CeGuiString& msg)
+	{
+		delete mCurrentResponse;
+		mCurrentResponse = mBot->createResponse(msg);
+
+		if (mBot->hasExitRequest())
+		{
+			mDialogWindow->setDialogEnd();
+			mState = CLOSING_DIALOG;
+			handleDialogClose();
+			return;
+		}
+		if (mCurrentResponse == NULL)
+		{
+			mDialogWindow->setDialogEnd();
+			mState = CLOSING_DIALOG;
+		//	??bergangsl??sung, wenn gerade kein sprecher aktiv ist wird
+		//	nicht nicht textFinished aufgerufen
+		//  hier m??sste wahrscheinlich requestClose auftauchen
+			handleDialogClose();
+			return;
+		}
+
+		DialogResponse::Responses responses = mCurrentResponse->getResponses();
+		CeGuiString responseSound = "null.ogg";
+		CeGuiString responseText;
+		if (!responses.empty())
+		{
+			responseSound = responses.begin()->first;
+			responseText = responses.begin()->second;
+			responseText.c_str();
+			responseSound.c_str();
+		}
+
+		response(mBot->getDialogPartner()->getActor(),
+				responseText, responseSound.c_str());
+
+		if (!responseText.empty())
+		{
+			mDialogWindow->setResponse(responseText);
+
+			mGameLogger->logDialogEvent(mBot->getName(), responseText);
+			LOG_MESSAGE(Logger::DIALOG, mBot->getName() + " says: " + responseText);
+		}
+
+		mDialogWindow->setVisible(false);
+		mState = TALKING_PARTNER_CHARACTER;
+		mCurrentResponseText = msg;
+	}
+
+	void DialogControlState::textFinished()
+	{
+		if (mState == TALKING_PARTNER_CHARACTER)
+		{
+			getOptions(mCurrentResponseText);
+			mDialogWindow->setVisible(true);
+			mState = CHOOSING_OPTION;
+		}
+
+		if (mState == TALKING_PLAYER_CHARACTER)
+		{
+			getResponse(mCurrentResponseText);
+		}
+
+		LOG_DEBUG(Logger::UI,
+					StringConverter::toString(mState)
+					+ " bei textFinished" );
+	}
+
+	void DialogControlState::getOptions(const CeGuiString& question)
+	{
+		if (mCurrentResponse == NULL)
+		{
+			Throw(rl::IllegalStateException, "mCurrentResponse must not be NULL.");
+			return;
+		}
+
+		DialogResponse::DialogOptions options = mCurrentResponse->getDialogOptions();
+
+		if (options.empty())
+		{
+			mDialogWindow->setDialogEnd();
+			handleDialogClose();
+			return;
+		}
+
+		//mDialogOptions->clearAllSelections();
+
+		CeGuiStringVector optionTexts;
+		for(DialogResponse::DialogOptions::const_iterator itr = options.begin();
+			itr != options.end(); ++itr)
+		{
+			CeGuiString currentOption = (*itr)->getText();
+			LOG_DEBUG(Logger::UI, "Player option: " + currentOption);
+
+			optionTexts.push_back(currentOption);
+			///@todo mark attribute/talent checks
+		}
+
+		mDialogWindow->setAvailableOptions(optionTexts);
+	}
+
+	bool DialogControlState::handleDialogSelectOption()
+	{
+		int idx = mDialogWindow->getSelectedOptionIndex();
+		if (idx != -1)
+		{
+			DialogOption* option = mCurrentResponse->getDialogOptions()[idx];
+			option->processSelection();
+			mCurrentResponseText = option->getPattern();
+			CeGuiString selectedOption = option->getText();
+			if (mCurrentResponseText != "0" && mCurrentResponseText != "666")
+			{
+				if (!selectedOption.empty())
+				{
+					mState = TALKING_PLAYER_CHARACTER;
+					mGameLogger->logDialogEvent("Held", selectedOption);
+					LOG_MESSAGE(Logger::DIALOG,
+						"Player says: " + selectedOption);
+					mDialogWindow->setChosenOption(selectedOption);
+					response(
+						mBot->getDialogCharacter()->getActor(),
+						selectedOption,
+						option->getId().c_str());
+					mDialogWindow->setVisible(false);
+				}
+			}
+		}
+
+		return true;
+	}
+
+	bool DialogControlState::handleDialogClose()
+	{
+		InputManager::getSingleton().popControlState();
+		mDialogWindow->setVisible(false, true);
+		mSubtitleWindow->setVisible(false, true);
+		return true;
+	}
+
+	bool DialogControlState::requestDialogClose()
+	{
+	//	handleClose is called automatically
+		getResponse(DIALOG_EXIT);
+		return true;
+	}
+
+
+}



From chrber at mail.berlios.de  Sat Jul 14 12:21:41 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Sat, 14 Jul 2007 12:21:41 +0200
Subject: [Dsa-hl-svn] r3602 - in rl/trunk: . Mac Mac/English.lproj
	Mac/English.lproj/main.nib Mac/Rastullah.xcodeproj
	engine/rules/include engine/rules/src engine/script/swig
	engine/ui/src
Message-ID: <200707141021.l6EALf9v013857@sheep.berlios.de>

Author: chrber
Date: 2007-07-14 12:20:14 +0200 (Sat, 14 Jul 2007)
New Revision: 3602

Added:
   rl/trunk/Mac/
   rl/trunk/Mac/English.lproj/
   rl/trunk/Mac/English.lproj/InfoPlist.strings
   rl/trunk/Mac/English.lproj/main.nib/
   rl/trunk/Mac/English.lproj/main.nib/classes.nib
   rl/trunk/Mac/English.lproj/main.nib/info.nib
   rl/trunk/Mac/English.lproj/main.nib/objects.xib
   rl/trunk/Mac/Info.plist
   rl/trunk/Mac/Rastullah.xcodeproj/
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/Mac/RlScript-Info.plist
Modified:
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/ui/src/AbstractWindow.cpp
Log:
Added XCode project for building on a Mac
Changed some code parts to allow building on a Mac


Added: rl/trunk/Mac/English.lproj/InfoPlist.strings
===================================================================
(Binary files differ)


Property changes on: rl/trunk/Mac/English.lproj/InfoPlist.strings
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/Mac/English.lproj/main.nib/classes.nib
===================================================================
--- rl/trunk/Mac/English.lproj/main.nib/classes.nib	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/Mac/English.lproj/main.nib/classes.nib	2007-07-14 10:20:14 UTC (rev 3602)
@@ -0,0 +1,4 @@
+{
+IBClasses = ();
+IBVersion = 1;
+}

Added: rl/trunk/Mac/English.lproj/main.nib/info.nib
===================================================================
--- rl/trunk/Mac/English.lproj/main.nib/info.nib	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/Mac/English.lproj/main.nib/info.nib	2007-07-14 10:20:14 UTC (rev 3602)
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>IBDocumentLocation</key>
+	<string>117 12 356 240 0 0 1920 1178 </string>
+	<key>IBEditorPositions</key>
+	<dict>
+		<key>29</key>
+		<string>110 302 204 44 0 0 1920 1178 </string>
+	</dict>
+	<key>IBFramework Version</key>
+	<string>431.0</string>
+	<key>IBOldestOS</key>
+	<integer>3</integer>
+	<key>IBOpenObjects</key>
+	<array>
+		<integer>29</integer>
+		<integer>166</integer>
+	</array>
+	<key>IBSystem Version</key>
+	<string>8A383</string>
+	<key>targetFramework</key>
+	<string>IBCarbonFramework</string>
+</dict>
+</plist>

Added: rl/trunk/Mac/English.lproj/main.nib/objects.xib
===================================================================
--- rl/trunk/Mac/English.lproj/main.nib/objects.xib	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/Mac/English.lproj/main.nib/objects.xib	2007-07-14 10:20:14 UTC (rev 3602)
@@ -0,0 +1,272 @@
+<?xml version="1.0" standalone="yes"?>
+<object class="NSIBObjectData">
+  <string name="targetFramework">IBCarbonFramework</string>
+  <object name="rootObject" class="NSCustomObject" id="1">
+    <string name="customClass">NSApplication</string>
+  </object>
+  <array count="38" name="allObjects">
+    <object class="IBCarbonMenu" id="29">
+      <string name="title">main</string>
+      <array count="4" name="items">
+        <object class="IBCarbonMenuItem" id="185">
+          <string name="title">Foo</string>
+          <object name="submenu" class="IBCarbonMenu" id="184">
+            <string name="title">Foo</string>
+            <array count="1" name="items">
+              <object class="IBCarbonMenuItem" id="187">
+                <string name="title">About Foo</string>
+                <int name="keyEquivalentModifier">0</int>
+                <ostype name="command">abou</ostype>
+              </object>
+            </array>
+            <string name="name">_NSAppleMenu</string>
+          </object>
+        </object>
+        <object class="IBCarbonMenuItem" id="127">
+          <string name="title">File</string>
+          <object name="submenu" class="IBCarbonMenu" id="131">
+            <string name="title">File</string>
+            <array count="10" name="items">
+              <object class="IBCarbonMenuItem" id="139">
+                <string name="title">New</string>
+                <string name="keyEquivalent">n</string>
+                <ostype name="command">new </ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="134">
+                <string name="title">Open?</string>
+                <string name="keyEquivalent">o</string>
+                <ostype name="command">open</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="133">
+                <boolean name="separator">TRUE</boolean>
+              </object>
+              <object class="IBCarbonMenuItem" id="130">
+                <string name="title">Close</string>
+                <string name="keyEquivalent">w</string>
+                <ostype name="command">clos</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="138">
+                <string name="title">Save</string>
+                <string name="keyEquivalent">s</string>
+                <ostype name="command">save</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="137">
+                <string name="title">Save As?</string>
+                <string name="keyEquivalent">S</string>
+                <ostype name="command">svas</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="132">
+                <string name="title">Revert</string>
+                <string name="keyEquivalent">r</string>
+                <ostype name="command">rvrt</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="128">
+                <boolean name="separator">TRUE</boolean>
+              </object>
+              <object class="IBCarbonMenuItem" id="135">
+                <string name="title">Page Setup?</string>
+                <string name="keyEquivalent">P</string>
+                <ostype name="command">page</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="136">
+                <string name="title">Print?</string>
+                <string name="keyEquivalent">p</string>
+                <ostype name="command">prnt</ostype>
+              </object>
+            </array>
+          </object>
+        </object>
+        <object class="IBCarbonMenuItem" id="152">
+          <string name="title">Edit</string>
+          <object name="submenu" class="IBCarbonMenu" id="147">
+            <string name="title">Edit</string>
+            <array count="10" name="items">
+              <object class="IBCarbonMenuItem" id="141">
+                <string name="title">Undo</string>
+                <string name="keyEquivalent">z</string>
+                <ostype name="command">undo</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="146">
+                <string name="title">Redo</string>
+                <string name="keyEquivalent">Z</string>
+                <ostype name="command">redo</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="142">
+                <boolean name="separator">TRUE</boolean>
+              </object>
+              <object class="IBCarbonMenuItem" id="143">
+                <string name="title">Cut</string>
+                <string name="keyEquivalent">x</string>
+                <ostype name="command">cut </ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="149">
+                <string name="title">Copy</string>
+                <string name="keyEquivalent">c</string>
+                <ostype name="command">copy</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="144">
+                <string name="title">Paste</string>
+                <string name="keyEquivalent">v</string>
+                <ostype name="command">past</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="151">
+                <string name="title">Delete</string>
+                <ostype name="command">clea</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="148">
+                <string name="title">Select All</string>
+                <string name="keyEquivalent">a</string>
+                <ostype name="command">sall</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="199">
+                <boolean name="separator">TRUE</boolean>
+              </object>
+              <object class="IBCarbonMenuItem" id="198">
+                <string name="title">Special Characters?</string>
+                <ostype name="command">chrp</ostype>
+              </object>
+            </array>
+          </object>
+        </object>
+        <object class="IBCarbonMenuItem" id="192">
+          <string name="title">Window</string>
+          <object name="submenu" class="IBCarbonMenu" id="195">
+            <string name="title">Window</string>
+            <array count="6" name="items">
+              <object class="IBCarbonMenuItem" id="190">
+                <boolean name="dynamic">TRUE</boolean>
+                <string name="title">Minimize</string>
+                <string name="keyEquivalent">m</string>
+                <ostype name="command">mini</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="191">
+                <boolean name="dynamic">TRUE</boolean>
+                <string name="title">Minimize All</string>
+                <string name="keyEquivalent">m</string>
+                <int name="keyEquivalentModifier">1572864</int>
+                <ostype name="command">mina</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="197">
+                <string name="title">Zoom</string>
+                <ostype name="command">zoom</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="194">
+                <boolean name="separator">TRUE</boolean>
+              </object>
+              <object class="IBCarbonMenuItem" id="196">
+                <boolean name="dynamic">TRUE</boolean>
+                <string name="title">Bring All to Front</string>
+                <ostype name="command">bfrt</ostype>
+              </object>
+              <object class="IBCarbonMenuItem" id="193">
+                <boolean name="dynamic">TRUE</boolean>
+                <string name="title">Arrange in Front</string>
+                <int name="keyEquivalentModifier">1572864</int>
+                <ostype name="command">frnt</ostype>
+              </object>
+            </array>
+            <string name="name">_NSWindowsMenu</string>
+          </object>
+        </object>
+      </array>
+      <string name="name">_NSMainMenu</string>
+    </object>
+    <reference idRef="127"/>
+    <reference idRef="128"/>
+    <reference idRef="130"/>
+    <reference idRef="131"/>
+    <reference idRef="132"/>
+    <reference idRef="133"/>
+    <reference idRef="134"/>
+    <reference idRef="135"/>
+    <reference idRef="136"/>
+    <reference idRef="137"/>
+    <reference idRef="138"/>
+    <reference idRef="139"/>
+    <reference idRef="141"/>
+    <reference idRef="142"/>
+    <reference idRef="143"/>
+    <reference idRef="144"/>
+    <reference idRef="146"/>
+    <reference idRef="147"/>
+    <reference idRef="148"/>
+    <reference idRef="149"/>
+    <reference idRef="151"/>
+    <reference idRef="152"/>
+    <object class="IBCarbonWindow" id="166">
+      <string name="windowRect">204 300 564 780 </string>
+      <string name="title">Window</string>
+      <object name="rootControl" class="IBCarbonRootControl" id="167">
+        <string name="bounds">0 0 360 480 </string>
+        <string name="viewFrame">0 0 480 360 </string>
+      </object>
+      <boolean name="receiveUpdates">FALSE</boolean>
+      <boolean name="liveResize">TRUE</boolean>
+      <boolean name="compositing">TRUE</boolean>
+      <boolean name="isConstrained">FALSE</boolean>
+    </object>
+    <reference idRef="167"/>
+    <reference idRef="184"/>
+    <reference idRef="185"/>
+    <reference idRef="187"/>
+    <reference idRef="190"/>
+    <reference idRef="191"/>
+    <reference idRef="192"/>
+    <reference idRef="193"/>
+    <reference idRef="194"/>
+    <reference idRef="195"/>
+    <reference idRef="196"/>
+    <reference idRef="197"/>
+    <reference idRef="198"/>
+    <reference idRef="199"/>
+  </array>
+  <array count="38" name="allParents">
+    <reference idRef="1"/>
+    <reference idRef="29"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="127"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="131"/>
+    <reference idRef="147"/>
+    <reference idRef="147"/>
+    <reference idRef="147"/>
+    <reference idRef="147"/>
+    <reference idRef="147"/>
+    <reference idRef="152"/>
+    <reference idRef="147"/>
+    <reference idRef="147"/>
+    <reference idRef="147"/>
+    <reference idRef="29"/>
+    <reference idRef="1"/>
+    <reference idRef="166"/>
+    <reference idRef="185"/>
+    <reference idRef="29"/>
+    <reference idRef="184"/>
+    <reference idRef="195"/>
+    <reference idRef="195"/>
+    <reference idRef="29"/>
+    <reference idRef="195"/>
+    <reference idRef="195"/>
+    <reference idRef="192"/>
+    <reference idRef="195"/>
+    <reference idRef="195"/>
+    <reference idRef="147"/>
+    <reference idRef="147"/>
+  </array>
+  <dictionary count="3" name="nameTable">
+    <string>Files Owner</string>
+    <reference idRef="1"/>
+    <string>MainWindow</string>
+    <reference idRef="166"/>
+    <string>MenuBar</string>
+    <reference idRef="29"/>
+  </dictionary>
+  <unsigned_int name="nextObjectID">200</unsigned_int>
+</object>

Added: rl/trunk/Mac/Info.plist
===================================================================
--- rl/trunk/Mac/Info.plist	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/Mac/Info.plist	2007-07-14 10:20:14 UTC (rev 3602)
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>com.yourcompany.Rastullah</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>APPL</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+	<key>CSResourcesFileMapped</key>
+	<true/>
+</dict>
+</plist>

Added: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2007-07-14 10:20:14 UTC (rev 3602)
@@ -0,0 +1,3312 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 42;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		4404DA6F0C48CEE2007B4657 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA6E0C48CEE2007B4657 /* stdinc.h */; };
+		4404DA7D0C48CFB3007B4657 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA7C0C48CFB3007B4657 /* stdinc.h */; };
+		4404DA7F0C48CFC7007B4657 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA7E0C48CFC7007B4657 /* stdinc.h */; };
+		4404DA810C48CFDE007B4657 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA800C48CFDE007B4657 /* stdinc.h */; };
+		4404DA830C48D005007B4657 /* stdinc.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4404DA820C48D005007B4657 /* stdinc.cpp */; };
+		4404DA860C48D037007B4657 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA850C48D037007B4657 /* stdinc.h */; };
+		440785DE0C09D231006E496D /* libmeshmagick.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
+		440785E40C09D2C1006E496D /* LightFadeJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 440785E20C09D2C1006E496D /* LightFadeJob.cpp */; };
+		440785E50C09D2C1006E496D /* MergeableMeshObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */; };
+		440785E70C09D2DF006E496D /* MergeableMeshObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 440785E60C09D2DF006E496D /* MergeableMeshObject.h */; };
+		440785EB0C09D377006E496D /* libmeshmagick.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
+		440785EF0C09D3A8006E496D /* libmeshmagick.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
+		440785F10C09D3D5006E496D /* libmeshmagick.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
+		440785F30C09D42B006E496D /* libmeshmagick.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
+		440787E10C09D688006E496D /* OgreCEGUIRenderer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */; };
+		440787E20C09D688006E496D /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		440787E30C09D688006E496D /* OpenSteer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */; };
+		440787E40C09D688006E496D /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		440787E50C09D688006E496D /* libRlDialog.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC2F0BD0E42A00C6D4A0 /* libRlDialog.dylib */; };
+		440787E60C09D688006E496D /* libRlAi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */; };
+		440787E70C09D688006E496D /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
+		440787E80C09D688006E496D /* libRlUi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */; };
+		440787E90C09D688006E496D /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		440787EA0C09D688006E496D /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		440787EB0C09D688006E496D /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		440787EC0C09D688006E496D /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		440787ED0C09D688006E496D /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		440787EE0C09D688006E496D /* libruby.1.8.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB08E0BD1158700C6D4A0 /* libruby.1.8.6.dylib */; };
+		440787EF0C09D697006E496D /* AbstractMapNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */; };
+		440787F00C09D697006E496D /* EntityNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DA0BF7B2B200C5A94F /* EntityNodeProcessor.cpp */; };
+		440787F10C09D697006E496D /* EnvironmentProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DB0BF7B2B200C5A94F /* EnvironmentProcessor.cpp */; };
+		440787F20C09D697006E496D /* GameObjectNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DC0BF7B2B200C5A94F /* GameObjectNodeProcessor.cpp */; };
+		440787F30C09D697006E496D /* LightNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DD0BF7B2B200C5A94F /* LightNodeProcessor.cpp */; };
+		440787F40C09D697006E496D /* MapLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DE0BF7B2B200C5A94F /* MapLoader.cpp */; };
+		440787F50C09D697006E496D /* ParticleSystemNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DF0BF7B2B200C5A94F /* ParticleSystemNodeProcessor.cpp */; };
+		440787F60C09D697006E496D /* RlExports.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EB6BC0BD1891400C6D4A0 /* RlExports.cpp */; };
+		440787F70C09D697006E496D /* ScriptObjectMarker.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */; };
+		440787F80C09D697006E496D /* ScriptSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */; };
+		440787F90C09D697006E496D /* SoundNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E00BF7B2B200C5A94F /* SoundNodeProcessor.cpp */; };
+		440787FA0C09D697006E496D /* WaypointProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E10BF7B2B200C5A94F /* WaypointProcessor.cpp */; };
+		440787FB0C09D697006E496D /* ZoneProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E20BF7B2B200C5A94F /* ZoneProcessor.cpp */; };
+		4407880D0C09D743006E496D /* libmeshmagick.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
+		4407880E0C09D74C006E496D /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		44125A300C083D0100C24C0A /* CreatureWalkPathJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */; };
+		44125A320C083D1100C24C0A /* CreatureWalkPathJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */; };
+		444826050BF7B37D00C5A94F /* SelectionHelper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444826030BF7B37D00C5A94F /* SelectionHelper.cpp */; };
+		444826060BF7B37D00C5A94F /* Selector.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444826040BF7B37D00C5A94F /* Selector.cpp */; };
+		444EAAAD0BD0E0C700C6D4A0 /* RastullahMain.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAAC0BD0E0C700C6D4A0 /* RastullahMain.cpp */; };
+		444EAABB0BD0E17000C6D4A0 /* ConfigFile.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAB60BD0E17000C6D4A0 /* ConfigFile.cpp */; };
+		444EAABC0BD0E17000C6D4A0 /* EventObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAB70BD0E17000C6D4A0 /* EventObject.cpp */; };
+		444EAABD0BD0E17000C6D4A0 /* EventSource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAB80BD0E17000C6D4A0 /* EventSource.cpp */; };
+		444EAABE0BD0E17000C6D4A0 /* GameTask.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAB90BD0E17000C6D4A0 /* GameTask.cpp */; };
+		444EAABF0BD0E17000C6D4A0 /* Logger.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAABA0BD0E17000C6D4A0 /* Logger.cpp */; };
+		444EAACA0BD0E18800C6D4A0 /* MathUtil.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC00BD0E18800C6D4A0 /* MathUtil.cpp */; };
+		444EAACB0BD0E18800C6D4A0 /* OgreXercesInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC10BD0E18800C6D4A0 /* OgreXercesInput.cpp */; };
+		444EAACC0BD0E18800C6D4A0 /* Properties.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC20BD0E18800C6D4A0 /* Properties.cpp */; };
+		444EAACD0BD0E18800C6D4A0 /* Property.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC30BD0E18800C6D4A0 /* Property.cpp */; };
+		444EAACE0BD0E18800C6D4A0 /* PropertyReader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC40BD0E18800C6D4A0 /* PropertyReader.cpp */; };
+		444EAACF0BD0E18800C6D4A0 /* ScriptWrapper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC50BD0E18800C6D4A0 /* ScriptWrapper.cpp */; };
+		444EAAD00BD0E18800C6D4A0 /* XmlErrorHandler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC60BD0E18800C6D4A0 /* XmlErrorHandler.cpp */; };
+		444EAAD10BD0E18800C6D4A0 /* XmlHelper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC70BD0E18800C6D4A0 /* XmlHelper.cpp */; };
+		444EAAD20BD0E18800C6D4A0 /* XmlResource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC80BD0E18800C6D4A0 /* XmlResource.cpp */; };
+		444EAAD30BD0E18800C6D4A0 /* XmlResourceManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAAC90BD0E18800C6D4A0 /* XmlResourceManager.cpp */; };
+		444EAAEB0BD0E1EF00C6D4A0 /* CommonPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAD40BD0E1EF00C6D4A0 /* CommonPrerequisites.h */; };
+		444EAAEC0BD0E1EF00C6D4A0 /* ConfigFile.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAD50BD0E1EF00C6D4A0 /* ConfigFile.h */; };
+		444EAAED0BD0E1EF00C6D4A0 /* EventCaster.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAD60BD0E1EF00C6D4A0 /* EventCaster.h */; };
+		444EAAEE0BD0E1EF00C6D4A0 /* EventListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAD70BD0E1EF00C6D4A0 /* EventListener.h */; };
+		444EAAEF0BD0E1EF00C6D4A0 /* EventObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAD80BD0E1EF00C6D4A0 /* EventObject.h */; };
+		444EAAF00BD0E1EF00C6D4A0 /* EventSource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAD90BD0E1EF00C6D4A0 /* EventSource.h */; };
+		444EAAF10BD0E1EF00C6D4A0 /* Exception.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAADA0BD0E1EF00C6D4A0 /* Exception.h */; };
+		444EAAF20BD0E1EF00C6D4A0 /* FixRubyHeaders.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAADB0BD0E1EF00C6D4A0 /* FixRubyHeaders.h */; };
+		444EAAF30BD0E1EF00C6D4A0 /* GameTask.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAADC0BD0E1EF00C6D4A0 /* GameTask.h */; };
+		444EAAF40BD0E1EF00C6D4A0 /* Logger.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAADD0BD0E1EF00C6D4A0 /* Logger.h */; };
+		444EAAF50BD0E1EF00C6D4A0 /* MathUtil.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAADE0BD0E1EF00C6D4A0 /* MathUtil.h */; };
+		444EAAF60BD0E1EF00C6D4A0 /* OgreXercesInput.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAADF0BD0E1EF00C6D4A0 /* OgreXercesInput.h */; };
+		444EAAF70BD0E1EF00C6D4A0 /* Properties.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE00BD0E1EF00C6D4A0 /* Properties.h */; };
+		444EAAF80BD0E1EF00C6D4A0 /* Property.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE10BD0E1EF00C6D4A0 /* Property.h */; };
+		444EAAF90BD0E1EF00C6D4A0 /* PropertyReader.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE20BD0E1EF00C6D4A0 /* PropertyReader.h */; };
+		444EAAFA0BD0E1EF00C6D4A0 /* RastullahPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE30BD0E1EF00C6D4A0 /* RastullahPrerequisites.h */; };
+		444EAAFB0BD0E1EF00C6D4A0 /* ScriptWrapper.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE40BD0E1EF00C6D4A0 /* ScriptWrapper.h */; };
+		444EAAFC0BD0E1EF00C6D4A0 /* Sleep.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE50BD0E1EF00C6D4A0 /* Sleep.h */; };
+		444EAAFD0BD0E1EF00C6D4A0 /* Tripel.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE60BD0E1EF00C6D4A0 /* Tripel.h */; };
+		444EAAFE0BD0E1EF00C6D4A0 /* XmlErrorHandler.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE70BD0E1EF00C6D4A0 /* XmlErrorHandler.h */; };
+		444EAAFF0BD0E1EF00C6D4A0 /* XmlHelper.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE80BD0E1EF00C6D4A0 /* XmlHelper.h */; };
+		444EAB000BD0E1EF00C6D4A0 /* XmlResource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAE90BD0E1EF00C6D4A0 /* XmlResource.h */; };
+		444EAB010BD0E1EF00C6D4A0 /* XmlResourceManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAAEA0BD0E1EF00C6D4A0 /* XmlResourceManager.h */; };
+		444EAB620BD0E2F300C6D4A0 /* Actor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB210BD0E2B600C6D4A0 /* Actor.cpp */; };
+		444EAB630BD0E2F300C6D4A0 /* ActorControlledObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */; };
+		444EAB640BD0E2F300C6D4A0 /* ActorManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */; };
+		444EAB650BD0E2F300C6D4A0 /* AnimationListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB240BD0E2B600C6D4A0 /* AnimationListener.cpp */; };
+		444EAB660BD0E2F300C6D4A0 /* AnimationManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */; };
+		444EAB670BD0E2F300C6D4A0 /* BaseAnimation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */; };
+		444EAB680BD0E2F300C6D4A0 /* BoxPrimitive.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */; };
+		444EAB690BD0E2F300C6D4A0 /* CameraObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */; };
+		444EAB6A0BD0E2F300C6D4A0 /* ConfigurationManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */; };
+		444EAB6B0BD0E2F300C6D4A0 /* ContentModule.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */; };
+		444EAB6C0BD0E2F300C6D4A0 /* CoreEvents.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2B0BD0E2B600C6D4A0 /* CoreEvents.cpp */; };
+		444EAB6D0BD0E2F300C6D4A0 /* CoreSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */; };
+		444EAB6E0BD0E2F300C6D4A0 /* DebugVisualisable.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */; };
+		444EAB6F0BD0E2F300C6D4A0 /* DebugVisualsManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */; };
+		444EAB700BD0E2F300C6D4A0 /* DotSceneLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */; };
+		444EAB710BD0E2F300C6D4A0 /* DotSceneOctreeWorld.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */; };
+		444EAB720BD0E2F300C6D4A0 /* FadeAnimation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */; };
+		444EAB730BD0E2F300C6D4A0 /* GameAreaEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */; };
+		444EAB740BD0E2F300C6D4A0 /* GameAreaEventSource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */; };
+		444EAB750BD0E2F300C6D4A0 /* GameAreaListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */; };
+		444EAB760BD0E2F300C6D4A0 /* GameAreaTypes.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */; };
+		444EAB770BD0E2F300C6D4A0 /* GameEventManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */; };
+		444EAB780BD0E2F300C6D4A0 /* GameLoop.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */; };
+		444EAB790BD0E2F300C6D4A0 /* Job.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB380BD0E2B600C6D4A0 /* Job.cpp */; };
+		444EAB7A0BD0E2F300C6D4A0 /* JobScheduler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */; };
+		444EAB7B0BD0E2F300C6D4A0 /* LightObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */; };
+		444EAB7D0BD0E2F300C6D4A0 /* LineSetPrimitive.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */; };
+		444EAB7E0BD0E2F300C6D4A0 /* ListenerMovable.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */; };
+		444EAB7F0BD0E2F300C6D4A0 /* ListenerObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */; };
+		444EAB800BD0E2F300C6D4A0 /* MeshAnimation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */; };
+		444EAB810BD0E2F300C6D4A0 /* MeshObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */; };
+		444EAB820BD0E2F300C6D4A0 /* MovableText.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */; };
+		444EAB840BD0E2F300C6D4A0 /* NullDriver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */; };
+		444EAB850BD0E2F300C6D4A0 /* NullListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */; };
+		444EAB860BD0E2F300C6D4A0 /* NullSound.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */; };
+		444EAB870BD0E2F300C6D4A0 /* ParticleSystemObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */; };
+		444EAB880BD0E2F300C6D4A0 /* PhysicalThing.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */; };
+		444EAB890BD0E2F300C6D4A0 /* PhysicsContactListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */; };
+		444EAB8A0BD0E2F300C6D4A0 /* PhysicsGenericContactCallback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */; };
+		444EAB8B0BD0E2F300C6D4A0 /* PhysicsManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */; };
+		444EAB8C0BD0E2F300C6D4A0 /* PhysicsMaterialRaycast.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */; };
+		444EAB8D0BD0E2F300C6D4A0 /* PlayAnimationJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */; };
+		444EAB8E0BD0E2F300C6D4A0 /* PlaySoundJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */; };
+		444EAB8F0BD0E2F300C6D4A0 /* PrimitiveObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */; };
+		444EAB900BD0E2F300C6D4A0 /* RubyInterpreter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */; };
+		444EAB910BD0E2F300C6D4A0 /* SceneQuery.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */; };
+		444EAB920BD0E2F300C6D4A0 /* Sound.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB550BD0E2B600C6D4A0 /* Sound.cpp */; };
+		444EAB930BD0E2F300C6D4A0 /* SoundDriver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */; };
+		444EAB940BD0E2F300C6D4A0 /* SoundEvents.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */; };
+		444EAB950BD0E2F300C6D4A0 /* SoundManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */; };
+		444EAB960BD0E2F300C6D4A0 /* SoundObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */; };
+		444EAB970BD0E2F300C6D4A0 /* SoundResource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */; };
+		444EAB980BD0E2F300C6D4A0 /* TrackAnimation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */; };
+		444EAB990BD0E2F300C6D4A0 /* World.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB5C0BD0E2B600C6D4A0 /* World.cpp */; };
+		444EABDE0BD0E33300C6D4A0 /* Actor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAB9D0BD0E33300C6D4A0 /* Actor.h */; };
+		444EABDF0BD0E33300C6D4A0 /* ActorControlledObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */; };
+		444EABE00BD0E33300C6D4A0 /* ActorManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */; };
+		444EABE10BD0E33300C6D4A0 /* AnimationListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA00BD0E33300C6D4A0 /* AnimationListener.h */; };
+		444EABE20BD0E33300C6D4A0 /* AnimationManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA10BD0E33300C6D4A0 /* AnimationManager.h */; };
+		444EABE30BD0E33300C6D4A0 /* BaseAnimation.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */; };
+		444EABE40BD0E33300C6D4A0 /* BoxPrimitive.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */; };
+		444EABE50BD0E33300C6D4A0 /* CameraObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA40BD0E33300C6D4A0 /* CameraObject.h */; };
+		444EABE60BD0E33300C6D4A0 /* ConfigurationManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */; };
+		444EABE70BD0E33300C6D4A0 /* ContentModule.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA60BD0E33300C6D4A0 /* ContentModule.h */; };
+		444EABE80BD0E33300C6D4A0 /* CoreEvents.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA70BD0E33300C6D4A0 /* CoreEvents.h */; };
+		444EABE90BD0E33300C6D4A0 /* CorePrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */; };
+		444EABEA0BD0E33300C6D4A0 /* CoreSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */; };
+		444EABEB0BD0E33300C6D4A0 /* DebugVisualisable.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */; };
+		444EABEC0BD0E33300C6D4A0 /* DebugVisualsManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */; };
+		444EABED0BD0E33300C6D4A0 /* DotSceneLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */; };
+		444EABEE0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */; };
+		444EABEF0BD0E33300C6D4A0 /* FadeAnimation.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */; };
+		444EABF00BD0E33300C6D4A0 /* GameAreaEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */; };
+		444EABF10BD0E33300C6D4A0 /* GameAreaEventSource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */; };
+		444EABF20BD0E33300C6D4A0 /* GameAreaListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */; };
+		444EABF30BD0E33300C6D4A0 /* GameAreaTypes.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */; };
+		444EABF40BD0E33300C6D4A0 /* GameEventManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB30BD0E33300C6D4A0 /* GameEventManager.h */; };
+		444EABF50BD0E33300C6D4A0 /* GameLoop.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB40BD0E33300C6D4A0 /* GameLoop.h */; };
+		444EABF60BD0E33300C6D4A0 /* Job.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB50BD0E33300C6D4A0 /* Job.h */; };
+		444EABF70BD0E33300C6D4A0 /* JobListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB60BD0E33300C6D4A0 /* JobListener.h */; };
+		444EABF80BD0E33300C6D4A0 /* JobScheduler.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB70BD0E33300C6D4A0 /* JobScheduler.h */; };
+		444EABF90BD0E33300C6D4A0 /* LightObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB80BD0E33300C6D4A0 /* LightObject.h */; };
+		444EABFB0BD0E33300C6D4A0 /* LineSetPrimitive.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */; };
+		444EABFC0BD0E33300C6D4A0 /* ListenerMovable.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */; };
+		444EABFD0BD0E33300C6D4A0 /* ListenerObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */; };
+		444EABFE0BD0E33300C6D4A0 /* MeshAnimation.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */; };
+		444EABFF0BD0E33300C6D4A0 /* MeshObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABBE0BD0E33300C6D4A0 /* MeshObject.h */; };
+		444EAC000BD0E33300C6D4A0 /* MovableText.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABBF0BD0E33300C6D4A0 /* MovableText.h */; };
+		444EAC010BD0E33300C6D4A0 /* NullDriver.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABC50BD0E33300C6D4A0 /* NullDriver.h */; };
+		444EAC020BD0E33300C6D4A0 /* NullListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABC60BD0E33300C6D4A0 /* NullListener.h */; };
+		444EAC030BD0E33300C6D4A0 /* NullSound.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABC70BD0E33300C6D4A0 /* NullSound.h */; };
+		444EAC040BD0E33300C6D4A0 /* ParticleSystemObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */; };
+		444EAC050BD0E33300C6D4A0 /* PhysicalObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */; };
+		444EAC060BD0E33300C6D4A0 /* PhysicalThing.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */; };
+		444EAC070BD0E33300C6D4A0 /* PhysicsContactListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */; };
+		444EAC080BD0E33300C6D4A0 /* PhysicsController.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */; };
+		444EAC090BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */; };
+		444EAC0A0BD0E33300C6D4A0 /* PhysicsManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */; };
+		444EAC0B0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */; };
+		444EAC0C0BD0E33300C6D4A0 /* PlayAnimationJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */; };
+		444EAC0D0BD0E33300C6D4A0 /* PlaySoundJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */; };
+		444EAC0E0BD0E33300C6D4A0 /* PrimitiveObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */; };
+		444EAC0F0BD0E33300C6D4A0 /* QuadTree.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD30BD0E33300C6D4A0 /* QuadTree.h */; };
+		444EAC100BD0E33300C6D4A0 /* RubyInterpreter.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */; };
+		444EAC110BD0E33300C6D4A0 /* SceneQuery.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD50BD0E33300C6D4A0 /* SceneQuery.h */; };
+		444EAC120BD0E33300C6D4A0 /* Sound.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD60BD0E33300C6D4A0 /* Sound.h */; };
+		444EAC130BD0E33300C6D4A0 /* SoundDriver.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD70BD0E33300C6D4A0 /* SoundDriver.h */; };
+		444EAC140BD0E33300C6D4A0 /* SoundEvents.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD80BD0E33300C6D4A0 /* SoundEvents.h */; };
+		444EAC150BD0E33300C6D4A0 /* SoundManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABD90BD0E33300C6D4A0 /* SoundManager.h */; };
+		444EAC160BD0E33300C6D4A0 /* SoundObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABDA0BD0E33300C6D4A0 /* SoundObject.h */; };
+		444EAC170BD0E33300C6D4A0 /* SoundResource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABDB0BD0E33300C6D4A0 /* SoundResource.h */; };
+		444EAC180BD0E33300C6D4A0 /* TrackAnimation.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */; };
+		444EAC190BD0E33300C6D4A0 /* World.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABDD0BD0E33300C6D4A0 /* World.h */; };
+		444EAC6B0BD0E52E00C6D4A0 /* Agent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC5A0BD0E52E00C6D4A0 /* Agent.cpp */; };
+		444EAC6C0BD0E52E00C6D4A0 /* AgentManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC5B0BD0E52E00C6D4A0 /* AgentManager.cpp */; };
+		444EAC6D0BD0E52E00C6D4A0 /* AiSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC5C0BD0E52E00C6D4A0 /* AiSubsystem.cpp */; };
+		444EAC6E0BD0E52E00C6D4A0 /* AiWorld.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC5D0BD0E52E00C6D4A0 /* AiWorld.cpp */; };
+		444EAC6F0BD0E52E00C6D4A0 /* AStar.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC5E0BD0E52E00C6D4A0 /* AStar.cpp */; };
+		444EAC700BD0E52E00C6D4A0 /* AStarCosts.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC5F0BD0E52E00C6D4A0 /* AStarCosts.cpp */; };
+		444EAC710BD0E52E00C6D4A0 /* AStarHeuristic.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC600BD0E52E00C6D4A0 /* AStarHeuristic.cpp */; };
+		444EAC720BD0E52E00C6D4A0 /* AStarNodePool.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC610BD0E52E00C6D4A0 /* AStarNodePool.cpp */; };
+		444EAC730BD0E52E00C6D4A0 /* AStarWayPointNode.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC620BD0E52E00C6D4A0 /* AStarWayPointNode.cpp */; };
+		444EAC740BD0E52E00C6D4A0 /* FuzzyState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC630BD0E52E00C6D4A0 /* FuzzyState.cpp */; };
+		444EAC750BD0E52E00C6D4A0 /* FuzzyStateMachine.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC640BD0E52E00C6D4A0 /* FuzzyStateMachine.cpp */; };
+		444EAC760BD0E52E00C6D4A0 /* PhysicalObstacle.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC650BD0E52E00C6D4A0 /* PhysicalObstacle.cpp */; };
+		444EAC770BD0E52E00C6D4A0 /* PlayerVehicle.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC660BD0E52E00C6D4A0 /* PlayerVehicle.cpp */; };
+		444EAC780BD0E52E00C6D4A0 /* SteeringVehicle.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC670BD0E52E00C6D4A0 /* SteeringVehicle.cpp */; };
+		444EAC790BD0E52E00C6D4A0 /* WayPointGraph.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC680BD0E52E00C6D4A0 /* WayPointGraph.cpp */; };
+		444EAC7A0BD0E52E00C6D4A0 /* WayPointGraphManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC690BD0E52E00C6D4A0 /* WayPointGraphManager.cpp */; };
+		444EAC7B0BD0E52E00C6D4A0 /* WayPointNode.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAC6A0BD0E52E00C6D4A0 /* WayPointNode.cpp */; };
+		444EAC8F0BD0E54100C6D4A0 /* Agent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC7C0BD0E54000C6D4A0 /* Agent.h */; };
+		444EAC900BD0E54100C6D4A0 /* AgentManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC7D0BD0E54000C6D4A0 /* AgentManager.h */; };
+		444EAC910BD0E54100C6D4A0 /* AiPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC7E0BD0E54000C6D4A0 /* AiPrerequisites.h */; };
+		444EAC920BD0E54100C6D4A0 /* AiSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC7F0BD0E54000C6D4A0 /* AiSubsystem.h */; };
+		444EAC930BD0E54100C6D4A0 /* AiWorld.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC800BD0E54000C6D4A0 /* AiWorld.h */; };
+		444EAC940BD0E54100C6D4A0 /* AStar.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC810BD0E54000C6D4A0 /* AStar.h */; };
+		444EAC950BD0E54100C6D4A0 /* AStarCosts.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC820BD0E54000C6D4A0 /* AStarCosts.h */; };
+		444EAC960BD0E54100C6D4A0 /* AStarHeuristic.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC830BD0E54000C6D4A0 /* AStarHeuristic.h */; };
+		444EAC970BD0E54100C6D4A0 /* AStarNodePool.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC840BD0E54000C6D4A0 /* AStarNodePool.h */; };
+		444EAC980BD0E54100C6D4A0 /* AStarWayPointNode.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC850BD0E54000C6D4A0 /* AStarWayPointNode.h */; };
+		444EAC990BD0E54100C6D4A0 /* FuzzyState.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC860BD0E54100C6D4A0 /* FuzzyState.h */; };
+		444EAC9A0BD0E54100C6D4A0 /* FuzzyStateMachine.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC870BD0E54100C6D4A0 /* FuzzyStateMachine.h */; };
+		444EAC9B0BD0E54100C6D4A0 /* PhysicalObstacle.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC880BD0E54100C6D4A0 /* PhysicalObstacle.h */; };
+		444EAC9C0BD0E54100C6D4A0 /* PlayerVehicle.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC890BD0E54100C6D4A0 /* PlayerVehicle.h */; };
+		444EAC9D0BD0E54100C6D4A0 /* SteeringMachine.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC8A0BD0E54100C6D4A0 /* SteeringMachine.h */; };
+		444EAC9E0BD0E54100C6D4A0 /* SteeringVehicle.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC8B0BD0E54100C6D4A0 /* SteeringVehicle.h */; };
+		444EAC9F0BD0E54100C6D4A0 /* WayPointGraph.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC8C0BD0E54100C6D4A0 /* WayPointGraph.h */; };
+		444EACA00BD0E54100C6D4A0 /* WayPointGraphManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC8D0BD0E54100C6D4A0 /* WayPointGraphManager.h */; };
+		444EACA10BD0E54100C6D4A0 /* WayPointNode.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAC8E0BD0E54100C6D4A0 /* WayPointNode.h */; };
+		444EACD00BD0E57100C6D4A0 /* AboutWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */; };
+		444EACD10BD0E57100C6D4A0 /* AbstractWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */; };
+		444EACD20BD0E57100C6D4A0 /* ActionChoiceWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */; };
+		444EACD40BD0E57100C6D4A0 /* CharacterSheetWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */; };
+		444EACD50BD0E57100C6D4A0 /* CharacterStateWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */; };
+		444EACD60BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */; };
+		444EACD80BD0E57100C6D4A0 /* CommandMapper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */; };
+		444EACDA0BD0E57100C6D4A0 /* ConfigComponent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */; };
+		444EACDB0BD0E57100C6D4A0 /* Console.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACAD0BD0E57100C6D4A0 /* Console.cpp */; };
+		444EACDC0BD0E57100C6D4A0 /* ContainerContentWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */; };
+		444EACDF0BD0E57100C6D4A0 /* DebugWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */; };
+		444EACE10BD0E57100C6D4A0 /* DialogWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */; };
+		444EACE30BD0E57100C6D4A0 /* GameLoggerWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */; };
+		444EACE40BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */; };
+		444EACE60BD0E57100C6D4A0 /* GameSettings.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */; };
+		444EACE70BD0E57100C6D4A0 /* InfoPopup.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */; };
+		444EACE80BD0E57100C6D4A0 /* InGameMenuWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */; };
+		444EACE90BD0E57100C6D4A0 /* InputManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */; };
+		444EACEA0BD0E57100C6D4A0 /* InventoryWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */; };
+		444EACEB0BD0E57100C6D4A0 /* ItemDragContainer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */; };
+		444EACEC0BD0E57100C6D4A0 /* JournalWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */; };
+		444EACED0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */; };
+		444EACEE0BD0E57100C6D4A0 /* LogWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */; };
+		444EACEF0BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */; };
+		444EACF00BD0E57100C6D4A0 /* MainMenuWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */; };
+		444EACF10BD0E57100C6D4A0 /* MessageWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */; };
+		444EACF30BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */; };
+		444EACF40BD0E57100C6D4A0 /* PlaylistWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */; };
+		444EACF50BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */; };
+		444EACF70BD0E57100C6D4A0 /* SoundConfig.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */; };
+		444EACF80BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */; };
+		444EACF90BD0E57100C6D4A0 /* SubtitleWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */; };
+		444EACFA0BD0E57100C6D4A0 /* UiSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */; };
+		444EACFB0BD0E57100C6D4A0 /* WindowFactory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */; };
+		444EACFC0BD0E57100C6D4A0 /* WindowFadeJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */; };
+		444EACFD0BD0E57100C6D4A0 /* WindowManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */; };
+		444EAD2E0BD0E58C00C6D4A0 /* AboutWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */; };
+		444EAD2F0BD0E58C00C6D4A0 /* AbstractWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */; };
+		444EAD300BD0E58C00C6D4A0 /* ActionChoiceWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */; };
+		444EAD310BD0E58C00C6D4A0 /* CeGuiHelper.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */; };
+		444EAD330BD0E58C00C6D4A0 /* CharacterSheetWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */; };
+		444EAD340BD0E58C00C6D4A0 /* CharacterStateWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */; };
+		444EAD350BD0E58C00C6D4A0 /* CloseConfirmationWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */; };
+		444EAD370BD0E58C00C6D4A0 /* CommandMapper.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */; };
+		444EAD390BD0E58C00C6D4A0 /* ConfigComponent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */; };
+		444EAD3A0BD0E58C00C6D4A0 /* Console.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD0A0BD0E58C00C6D4A0 /* Console.h */; };
+		444EAD3B0BD0E58C00C6D4A0 /* ContainerContentWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */; };
+		444EAD3E0BD0E58C00C6D4A0 /* DebugWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */; };
+		444EAD400BD0E58C00C6D4A0 /* DialogWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */; };
+		444EAD420BD0E58C00C6D4A0 /* GameLoggerWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */; };
+		444EAD430BD0E58C00C6D4A0 /* GameObjectInfoWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */; };
+		444EAD450BD0E58C00C6D4A0 /* GameSettings.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD150BD0E58C00C6D4A0 /* GameSettings.h */; };
+		444EAD460BD0E58C00C6D4A0 /* InfoPopup.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */; };
+		444EAD470BD0E58C00C6D4A0 /* InGameMenuWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */; };
+		444EAD480BD0E58C00C6D4A0 /* InputManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD180BD0E58C00C6D4A0 /* InputManager.h */; };
+		444EAD490BD0E58C00C6D4A0 /* InventoryWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */; };
+		444EAD4A0BD0E58C00C6D4A0 /* ItemDragContainer.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */; };
+		444EAD4B0BD0E58C00C6D4A0 /* JournalWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */; };
+		444EAD4C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */; };
+		444EAD4D0BD0E58C00C6D4A0 /* LogWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */; };
+		444EAD4E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */; };
+		444EAD4F0BD0E58C00C6D4A0 /* MainMenuWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */; };
+		444EAD500BD0E58C00C6D4A0 /* MessageWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */; };
+		444EAD520BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */; };
+		444EAD530BD0E58C00C6D4A0 /* PlaylistWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */; };
+		444EAD540BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */; };
+		444EAD560BD0E58C00C6D4A0 /* SoundConfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */; };
+		444EAD570BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */; };
+		444EAD580BD0E58C00C6D4A0 /* SubtitleWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */; };
+		444EAD590BD0E58C00C6D4A0 /* UiPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */; };
+		444EAD5A0BD0E58C00C6D4A0 /* UiSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */; };
+		444EAD5B0BD0E58C00C6D4A0 /* WindowFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */; };
+		444EAD5C0BD0E58C00C6D4A0 /* WindowFadeJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD2C0BD0E58C00C6D4A0 /* WindowFadeJob.h */; };
+		444EAD5D0BD0E58C00C6D4A0 /* WindowManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD2D0BD0E58C00C6D4A0 /* WindowManager.h */; };
+		444EAD680BD0E5D500C6D4A0 /* AimlNodeImplRl.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD5E0BD0E5D500C6D4A0 /* AimlNodeImplRl.cpp */; };
+		444EAD690BD0E5D500C6D4A0 /* AimlParserImplRl.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD5F0BD0E5D500C6D4A0 /* AimlParserImplRl.cpp */; };
+		444EAD6A0BD0E5D500C6D4A0 /* ContextConditionProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD600BD0E5D500C6D4A0 /* ContextConditionProcessor.cpp */; };
+		444EAD6B0BD0E5D500C6D4A0 /* ContextInterpreter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD610BD0E5D500C6D4A0 /* ContextInterpreter.cpp */; };
+		444EAD6C0BD0E5D500C6D4A0 /* DialogCharacter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD620BD0E5D500C6D4A0 /* DialogCharacter.cpp */; };
+		444EAD6D0BD0E5D500C6D4A0 /* DialogOption.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD630BD0E5D500C6D4A0 /* DialogOption.cpp */; };
+		444EAD6E0BD0E5D500C6D4A0 /* DialogResponse.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD640BD0E5D500C6D4A0 /* DialogResponse.cpp */; };
+		444EAD6F0BD0E5D500C6D4A0 /* DialogScriptProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD650BD0E5D500C6D4A0 /* DialogScriptProcessor.cpp */; };
+		444EAD700BD0E5D500C6D4A0 /* DialogSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD660BD0E5D500C6D4A0 /* DialogSubsystem.cpp */; };
+		444EAD710BD0E5D500C6D4A0 /* ScriptProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD670BD0E5D500C6D4A0 /* ScriptProcessor.cpp */; };
+		444EAD7C0BD0E5E900C6D4A0 /* CreaturePredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD720BD0E5E900C6D4A0 /* CreaturePredicates.cpp */; };
+		444EAD7D0BD0E5E900C6D4A0 /* EigenschaftsProbePredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD730BD0E5E900C6D4A0 /* EigenschaftsProbePredicates.cpp */; };
+		444EAD7E0BD0E5E900C6D4A0 /* EigenschaftsWertPredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD740BD0E5E900C6D4A0 /* EigenschaftsWertPredicates.cpp */; };
+		444EAD7F0BD0E5E900C6D4A0 /* GrundWertPredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD750BD0E5E900C6D4A0 /* GrundWertPredicates.cpp */; };
+		444EAD800BD0E5E900C6D4A0 /* QuestKnownPredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD760BD0E5E900C6D4A0 /* QuestKnownPredicates.cpp */; };
+		444EAD810BD0E5E900C6D4A0 /* QuestPartsPredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD770BD0E5E900C6D4A0 /* QuestPartsPredicates.cpp */; };
+		444EAD820BD0E5E900C6D4A0 /* QuestStatePredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD780BD0E5E900C6D4A0 /* QuestStatePredicates.cpp */; };
+		444EAD830BD0E5E900C6D4A0 /* ScriptPredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD790BD0E5E900C6D4A0 /* ScriptPredicates.cpp */; };
+		444EAD840BD0E5E900C6D4A0 /* TalentProbePredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD7A0BD0E5E900C6D4A0 /* TalentProbePredicates.cpp */; };
+		444EAD850BD0E5E900C6D4A0 /* TalentWertPredicates.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAD7B0BD0E5E900C6D4A0 /* TalentWertPredicates.cpp */; };
+		444EAD910BD0E60000C6D4A0 /* AimlNodeImplRl.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD860BD0E60000C6D4A0 /* AimlNodeImplRl.h */; };
+		444EAD920BD0E60000C6D4A0 /* AimlParserImplRl.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD870BD0E60000C6D4A0 /* AimlParserImplRl.h */; };
+		444EAD930BD0E60000C6D4A0 /* ContextConditionProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD880BD0E60000C6D4A0 /* ContextConditionProcessor.h */; };
+		444EAD940BD0E60000C6D4A0 /* ContextInterpreter.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD890BD0E60000C6D4A0 /* ContextInterpreter.h */; };
+		444EAD950BD0E60000C6D4A0 /* DialogCharacter.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD8A0BD0E60000C6D4A0 /* DialogCharacter.h */; };
+		444EAD960BD0E60000C6D4A0 /* DialogOption.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD8B0BD0E60000C6D4A0 /* DialogOption.h */; };
+		444EAD970BD0E60000C6D4A0 /* DialogPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD8C0BD0E60000C6D4A0 /* DialogPrerequisites.h */; };
+		444EAD980BD0E60000C6D4A0 /* DialogResponse.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD8D0BD0E60000C6D4A0 /* DialogResponse.h */; };
+		444EAD990BD0E60000C6D4A0 /* DialogScriptProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD8E0BD0E60000C6D4A0 /* DialogScriptProcessor.h */; };
+		444EAD9A0BD0E60000C6D4A0 /* DialogSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD8F0BD0E60000C6D4A0 /* DialogSubsystem.h */; };
+		444EAD9B0BD0E60000C6D4A0 /* ScriptProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD900BD0E60000C6D4A0 /* ScriptProcessor.h */; };
+		444EADA60BD0E61400C6D4A0 /* CreaturePredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD9C0BD0E61400C6D4A0 /* CreaturePredicates.h */; };
+		444EADA70BD0E61400C6D4A0 /* EigenschaftsProbePredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD9D0BD0E61400C6D4A0 /* EigenschaftsProbePredicates.h */; };
+		444EADA80BD0E61400C6D4A0 /* EigenschaftsWertPredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD9E0BD0E61400C6D4A0 /* EigenschaftsWertPredicates.h */; };
+		444EADA90BD0E61400C6D4A0 /* GrundWertPredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAD9F0BD0E61400C6D4A0 /* GrundWertPredicates.h */; };
+		444EADAA0BD0E61400C6D4A0 /* QuestKnownPredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EADA00BD0E61400C6D4A0 /* QuestKnownPredicates.h */; };
+		444EADAB0BD0E61400C6D4A0 /* QuestPartsPredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EADA10BD0E61400C6D4A0 /* QuestPartsPredicates.h */; };
+		444EADAC0BD0E61400C6D4A0 /* QuestStatePredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EADA20BD0E61400C6D4A0 /* QuestStatePredicates.h */; };
+		444EADAD0BD0E61400C6D4A0 /* ScriptPredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EADA30BD0E61400C6D4A0 /* ScriptPredicates.h */; };
+		444EADAE0BD0E61400C6D4A0 /* TalentProbePredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EADA40BD0E61400C6D4A0 /* TalentProbePredicates.h */; };
+		444EADAF0BD0E61400C6D4A0 /* TalentWertPredicates.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EADA50BD0E61400C6D4A0 /* TalentWertPredicates.h */; };
+		444EADDA0BD0E64100C6D4A0 /* Action.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB00BD0E64100C6D4A0 /* Action.cpp */; };
+		444EADDB0BD0E64100C6D4A0 /* ActionManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */; };
+		444EADDC0BD0E64100C6D4A0 /* Armor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB20BD0E64100C6D4A0 /* Armor.cpp */; };
+		444EADDD0BD0E64100C6D4A0 /* Combat.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB30BD0E64100C6D4A0 /* Combat.cpp */; };
+		444EADDE0BD0E64100C6D4A0 /* CombatManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB40BD0E64100C6D4A0 /* CombatManager.cpp */; };
+		444EADDF0BD0E64100C6D4A0 /* Container.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB50BD0E64100C6D4A0 /* Container.cpp */; };
+		444EADE00BD0E64100C6D4A0 /* Creature.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB60BD0E64100C6D4A0 /* Creature.cpp */; };
+		444EADE10BD0E64100C6D4A0 /* Date.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB70BD0E64100C6D4A0 /* Date.cpp */; };
+		444EADE20BD0E64100C6D4A0 /* DsaDataLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB80BD0E64100C6D4A0 /* DsaDataLoader.cpp */; };
+		444EADE30BD0E64100C6D4A0 /* DsaManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADB90BD0E64100C6D4A0 /* DsaManager.cpp */; };
+		444EADE40BD0E64100C6D4A0 /* Effect.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADBA0BD0E64100C6D4A0 /* Effect.cpp */; };
+		444EADE50BD0E64100C6D4A0 /* EffectManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADBB0BD0E64100C6D4A0 /* EffectManager.cpp */; };
+		444EADE60BD0E64100C6D4A0 /* Eigenschaft.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADBC0BD0E64100C6D4A0 /* Eigenschaft.cpp */; };
+		444EADE70BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADBD0BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp */; };
+		444EADE80BD0E64100C6D4A0 /* GameObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADBE0BD0E64100C6D4A0 /* GameObject.cpp */; };
+		444EADE90BD0E64100C6D4A0 /* GameObjectManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADBF0BD0E64100C6D4A0 /* GameObjectManager.cpp */; };
+		444EADEB0BD0E64100C6D4A0 /* Inventory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC10BD0E64100C6D4A0 /* Inventory.cpp */; };
+		444EADEC0BD0E64100C6D4A0 /* Item.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC20BD0E64100C6D4A0 /* Item.cpp */; };
+		444EADED0BD0E64100C6D4A0 /* JournalEntry.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC30BD0E64100C6D4A0 /* JournalEntry.cpp */; };
+		444EADEE0BD0E64100C6D4A0 /* Kampftechnik.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC40BD0E64100C6D4A0 /* Kampftechnik.cpp */; };
+		444EADEF0BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */; };
+		444EADF00BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */; };
+		444EADF10BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */; };
+		444EADF20BD0E64100C6D4A0 /* Person.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC80BD0E64100C6D4A0 /* Person.cpp */; };
+		444EADF30BD0E64100C6D4A0 /* Quest.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADC90BD0E64100C6D4A0 /* Quest.cpp */; };
+		444EADF40BD0E64100C6D4A0 /* QuestBook.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */; };
+		444EADF50BD0E64100C6D4A0 /* QuestEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */; };
+		444EADF60BD0E64100C6D4A0 /* QuestListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCC0BD0E64100C6D4A0 /* QuestListener.cpp */; };
+		444EADF70BD0E64100C6D4A0 /* RulesSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCD0BD0E64100C6D4A0 /* RulesSubsystem.cpp */; };
+		444EADF80BD0E64100C6D4A0 /* Slot.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCE0BD0E64100C6D4A0 /* Slot.cpp */; };
+		444EADF90BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADCF0BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp */; };
+		444EADFA0BD0E64100C6D4A0 /* StateSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD00BD0E64100C6D4A0 /* StateSet.cpp */; };
+		444EADFB0BD0E64100C6D4A0 /* Talent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD10BD0E64100C6D4A0 /* Talent.cpp */; };
+		444EADFC0BD0E64100C6D4A0 /* Talentgruppe.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD20BD0E64100C6D4A0 /* Talentgruppe.cpp */; };
+		444EADFD0BD0E64100C6D4A0 /* TalentStateSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD30BD0E64100C6D4A0 /* TalentStateSet.cpp */; };
+		444EADFE0BD0E64100C6D4A0 /* TimerEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD40BD0E64100C6D4A0 /* TimerEvent.cpp */; };
+		444EADFF0BD0E64100C6D4A0 /* TimerEventSource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD50BD0E64100C6D4A0 /* TimerEventSource.cpp */; };
+		444EAE000BD0E64100C6D4A0 /* TimerListener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD60BD0E64100C6D4A0 /* TimerListener.cpp */; };
+		444EAE010BD0E64100C6D4A0 /* TimerManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD70BD0E64100C6D4A0 /* TimerManager.cpp */; };
+		444EAE020BD0E64100C6D4A0 /* Weapon.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD80BD0E64100C6D4A0 /* Weapon.cpp */; };
+		444EAE030BD0E64100C6D4A0 /* ZauberStateSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EADD90BD0E64100C6D4A0 /* ZauberStateSet.cpp */; };
+		444EAE320BD0E65B00C6D4A0 /* Action.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE040BD0E65B00C6D4A0 /* Action.h */; };
+		444EAE330BD0E65B00C6D4A0 /* ActionManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE050BD0E65B00C6D4A0 /* ActionManager.h */; };
+		444EAE340BD0E65B00C6D4A0 /* Armor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE060BD0E65B00C6D4A0 /* Armor.h */; };
+		444EAE350BD0E65B00C6D4A0 /* Combat.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE070BD0E65B00C6D4A0 /* Combat.h */; };
+		444EAE360BD0E65B00C6D4A0 /* CombatManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE080BD0E65B00C6D4A0 /* CombatManager.h */; };
+		444EAE370BD0E65B00C6D4A0 /* Container.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE090BD0E65B00C6D4A0 /* Container.h */; };
+		444EAE380BD0E65B00C6D4A0 /* Creature.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE0A0BD0E65B00C6D4A0 /* Creature.h */; };
+		444EAE390BD0E65B00C6D4A0 /* Date.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE0B0BD0E65B00C6D4A0 /* Date.h */; };
+		444EAE3A0BD0E65B00C6D4A0 /* DsaDataLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE0C0BD0E65B00C6D4A0 /* DsaDataLoader.h */; };
+		444EAE3B0BD0E65B00C6D4A0 /* DsaManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE0D0BD0E65B00C6D4A0 /* DsaManager.h */; };
+		444EAE3C0BD0E65B00C6D4A0 /* Effect.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE0E0BD0E65B00C6D4A0 /* Effect.h */; };
+		444EAE3D0BD0E65B00C6D4A0 /* EffectManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE0F0BD0E65B00C6D4A0 /* EffectManager.h */; };
+		444EAE3E0BD0E65B00C6D4A0 /* Eigenschaft.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE100BD0E65B00C6D4A0 /* Eigenschaft.h */; };
+		444EAE3F0BD0E65B00C6D4A0 /* EigenschaftenStateSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE110BD0E65B00C6D4A0 /* EigenschaftenStateSet.h */; };
+		444EAE400BD0E65B00C6D4A0 /* GameObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE120BD0E65B00C6D4A0 /* GameObject.h */; };
+		444EAE410BD0E65B00C6D4A0 /* GameObjectManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE130BD0E65B00C6D4A0 /* GameObjectManager.h */; };
+		444EAE440BD0E65B00C6D4A0 /* GameObjectStateListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE160BD0E65B00C6D4A0 /* GameObjectStateListener.h */; };
+		444EAE450BD0E65B00C6D4A0 /* Inventory.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE170BD0E65B00C6D4A0 /* Inventory.h */; };
+		444EAE460BD0E65B00C6D4A0 /* Item.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE180BD0E65B00C6D4A0 /* Item.h */; };
+		444EAE470BD0E65B00C6D4A0 /* JournalEntry.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE190BD0E65B00C6D4A0 /* JournalEntry.h */; };
+		444EAE480BD0E65B00C6D4A0 /* Kampftechnik.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1A0BD0E65B00C6D4A0 /* Kampftechnik.h */; };
+		444EAE490BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */; };
+		444EAE4A0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */; };
+		444EAE4B0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */; };
+		444EAE4C0BD0E65B00C6D4A0 /* Person.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1E0BD0E65B00C6D4A0 /* Person.h */; };
+		444EAE4D0BD0E65B00C6D4A0 /* Quest.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE1F0BD0E65B00C6D4A0 /* Quest.h */; };
+		444EAE4E0BD0E65B00C6D4A0 /* QuestBook.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE200BD0E65B00C6D4A0 /* QuestBook.h */; };
+		444EAE4F0BD0E65B00C6D4A0 /* QuestEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */; };
+		444EAE500BD0E65B00C6D4A0 /* QuestListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE220BD0E65B00C6D4A0 /* QuestListener.h */; };
+		444EAE510BD0E65B00C6D4A0 /* RulesPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE230BD0E65B00C6D4A0 /* RulesPrerequisites.h */; };
+		444EAE520BD0E65B00C6D4A0 /* RulesSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE240BD0E65B00C6D4A0 /* RulesSubsystem.h */; };
+		444EAE530BD0E65B00C6D4A0 /* Slot.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE250BD0E65B00C6D4A0 /* Slot.h */; };
+		444EAE540BD0E65B00C6D4A0 /* SonderfertigkeitenStateSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE260BD0E65B00C6D4A0 /* SonderfertigkeitenStateSet.h */; };
+		444EAE550BD0E65B00C6D4A0 /* StateSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE270BD0E65B00C6D4A0 /* StateSet.h */; };
+		444EAE560BD0E65B00C6D4A0 /* Talent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE280BD0E65B00C6D4A0 /* Talent.h */; };
+		444EAE570BD0E65B00C6D4A0 /* Talentgruppe.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE290BD0E65B00C6D4A0 /* Talentgruppe.h */; };
+		444EAE580BD0E65B00C6D4A0 /* TalentInputIterator.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE2A0BD0E65B00C6D4A0 /* TalentInputIterator.h */; };
+		444EAE590BD0E65B00C6D4A0 /* TalentStateSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE2B0BD0E65B00C6D4A0 /* TalentStateSet.h */; };
+		444EAE5A0BD0E65B00C6D4A0 /* TimerEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE2C0BD0E65B00C6D4A0 /* TimerEvent.h */; };
+		444EAE5B0BD0E65B00C6D4A0 /* TimerEventSource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE2D0BD0E65B00C6D4A0 /* TimerEventSource.h */; };
+		444EAE5C0BD0E65B00C6D4A0 /* TimerListener.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE2E0BD0E65B00C6D4A0 /* TimerListener.h */; };
+		444EAE5D0BD0E65B00C6D4A0 /* TimerManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE2F0BD0E65B00C6D4A0 /* TimerManager.h */; };
+		444EAE5E0BD0E65B00C6D4A0 /* Weapon.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE300BD0E65B00C6D4A0 /* Weapon.h */; };
+		444EAE5F0BD0E65B00C6D4A0 /* ZauberStateSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE310BD0E65B00C6D4A0 /* ZauberStateSet.h */; };
+		444EAEBA0BD0F06700C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		444EAEBF0BD0F09900C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		444EAEC00BD0F09900C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		444EAEC80BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		444EAED00BD1041C00C6D4A0 /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		444EAEF30BD1150500C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		444EAEF40BD1150500C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		444EAEF50BD1150500C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		444EAEF60BD1150500C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		444EAEF70BD1150500C6D4A0 /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		444EB0890BD1153500C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		444EB08F0BD1158700C6D4A0 /* libruby.1.8.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB08E0BD1158700C6D4A0 /* libruby.1.8.6.dylib */; };
+		444EB0AB0BD115CB00C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		444EB0D40BD1198B00C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		444EB0D50BD1198B00C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		444EB0D60BD1198B00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		444EB0D70BD1198B00C6D4A0 /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		444EB0D80BD1198B00C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		444EB0DB0BD119BB00C6D4A0 /* OpenSteer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */; };
+		444EB1250BD119E300C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		444EB1290BD119FB00C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		444EB12D0BD11A0C00C6D4A0 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		444EB1C10BD136F200C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		444EB1C20BD136F200C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		444EB1C30BD136F200C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		444EB1C40BD136FA00C6D4A0 /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		444EB1C50BD1370600C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		444EB1CA0BD137FB00C6D4A0 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		444EB1CE0BD1595100C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		444EB1D60BD1598F00C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		444EB3400BD172BA00C6D4A0 /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		444EB3410BD172BA00C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		444EB3420BD172BA00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		444EB3430BD172FA00C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		444EB3440BD1730C00C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		444EB3450BD1730C00C6D4A0 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		444EB3470BD1733900C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		444EB3480BD1733900C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		444EB34A0BD173A900C6D4A0 /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
+		444EB34C0BD1744F00C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		444EB34D0BD1744F00C6D4A0 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		444EB34E0BD1746600C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		444EB34F0BD1746600C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		444EB3500BD1746600C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		444EB3510BD1746600C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		444EB3520BD1746600C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		444EB3530BD1746600C6D4A0 /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		444EB3570BD174A100C6D4A0 /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
+		444EB35A0BD174C600C6D4A0 /* libMadaBot.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3590BD174C600C6D4A0 /* libMadaBot.dylib */; };
+		444EB35E0BD1754900C6D4A0 /* libRlDialog.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC2F0BD0E42A00C6D4A0 /* libRlDialog.dylib */; };
+		444EB3610BD1756B00C6D4A0 /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
+		444EB3630BD1759500C6D4A0 /* libois.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3620BD1759500C6D4A0 /* libois.a */; };
+		444EB3730BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */; };
+		444EB79A0BD195E800C6D4A0 /* libRlAi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */; };
+		444EB79B0BD195E800C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		444EB79C0BD195E800C6D4A0 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		444EB79D0BD195E800C6D4A0 /* libRlDialog.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC2F0BD0E42A00C6D4A0 /* libRlDialog.dylib */; };
+		444EB79E0BD195E800C6D4A0 /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
+		444EB7A00BD195E800C6D4A0 /* libRlUi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */; };
+		444EB7A20BD1963A00C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		444EB7A30BD1963A00C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */; };
+		444EB7A40BD1963A00C6D4A0 /* libMadaBot.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3590BD174C600C6D4A0 /* libMadaBot.dylib */; };
+		444EB7A50BD1963A00C6D4A0 /* libois.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3620BD1759500C6D4A0 /* libois.a */; };
+		444EB7A60BD1963A00C6D4A0 /* libruby.1.8.6.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB08E0BD1158700C6D4A0 /* libruby.1.8.6.dylib */; };
+		444EB7A70BD1963A00C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
+		444EB7A80BD1963A00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		444EB7A90BD1963A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */; };
+		444EB7AA0BD1963A00C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		444EB7AB0BD1963A00C6D4A0 /* OpenSteer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */; };
+		444EB7AC0BD1963A00C6D4A0 /* PCRE.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAECF0BD1041C00C6D4A0 /* PCRE.framework */; };
+		446BF46C0C4531FA0013C214 /* LinearSoundFadeFunctor.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */; };
+		446BF46D0C4531FA0013C214 /* SoundFadeFunctor.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */; };
+		446BF46E0C4531FA0013C214 /* SoundFadeJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF46B0C4531FA0013C214 /* SoundFadeJob.h */; };
+		446BF4720C4532120013C214 /* LinearSoundFadeFunctor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */; };
+		446BF4730C4532120013C214 /* SoundFadeFunctor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */; };
+		446BF4740C4532120013C214 /* SoundFadeJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4710C4532120013C214 /* SoundFadeJob.cpp */; };
+		446BF4780C4532720013C214 /* CreatureController.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4750C4532720013C214 /* CreatureController.h */; };
+		446BF4790C4532720013C214 /* CreatureControllerManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4760C4532720013C214 /* CreatureControllerManager.h */; };
+		446BF47A0C4532720013C214 /* EffectFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4770C4532720013C214 /* EffectFactory.h */; };
+		446BF47E0C45329F0013C214 /* CreatureController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF47B0C45329F0013C214 /* CreatureController.cpp */; };
+		446BF47F0C45329F0013C214 /* CreatureControllerManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */; };
+		446BF4800C45329F0013C214 /* EffectFactory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF47D0C45329F0013C214 /* EffectFactory.cpp */; };
+		446BF48C0C45335A0013C214 /* ControlState.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4840C45335A0013C214 /* ControlState.h */; };
+		446BF48D0C45335A0013C214 /* CutsceneControlState.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4850C45335A0013C214 /* CutsceneControlState.h */; };
+		446BF48E0C45335A0013C214 /* DialogControlState.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4860C45335A0013C214 /* DialogControlState.h */; };
+		446BF48F0C45335A0013C214 /* FreeflightControlState.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4870C45335A0013C214 /* FreeflightControlState.h */; };
+		446BF4900C45335A0013C214 /* ItemDescriptionDragContainer.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */; };
+		446BF4910C45335A0013C214 /* ItemIconDragContainer.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4890C45335A0013C214 /* ItemIconDragContainer.h */; };
+		446BF4920C45335A0013C214 /* MovementControlState.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF48A0C45335A0013C214 /* MovementControlState.h */; };
+		446BF4930C45335A0013C214 /* PropertiesWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF48B0C45335A0013C214 /* PropertiesWindow.h */; };
+		446BF49D0C4533BD0013C214 /* CombatControlState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4940C4533BD0013C214 /* CombatControlState.cpp */; };
+		446BF49E0C4533BD0013C214 /* CombatWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4950C4533BD0013C214 /* CombatWindow.cpp */; };
+		446BF49F0C4533BD0013C214 /* ControlState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4960C4533BD0013C214 /* ControlState.cpp */; };
+		446BF4A00C4533BD0013C214 /* CutsceneControlState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */; };
+		446BF4A10C4533BD0013C214 /* DialogControlState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4980C4533BD0013C214 /* DialogControlState.cpp */; };
+		446BF4A20C4533BD0013C214 /* FreeflightControlState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */; };
+		446BF4A30C4533BD0013C214 /* ItemIconDragContainer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */; };
+		446BF4A40C4533BD0013C214 /* MovementControlState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF49B0C4533BD0013C214 /* MovementControlState.cpp */; };
+		446BF4A50C4533BD0013C214 /* PropertiesWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */; };
+		446BF4D20C453B9E0013C214 /* CombatControlState.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4D00C453B9E0013C214 /* CombatControlState.h */; };
+		446BF4D30C453B9E0013C214 /* CombatWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4D10C453B9E0013C214 /* CombatWindow.h */; };
+		446BF4D60C453C1D0013C214 /* ItemDescriptionDragContainer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */; };
+		44D8145C0BF7B52600534175 /* GameObjectConstants.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814590BF7B52600534175 /* GameObjectConstants.h */; };
+		44D8145D0BF7B52600534175 /* SelectionHelper.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8145A0BF7B52600534175 /* SelectionHelper.h */; };
+		44D8145E0BF7B52600534175 /* Selector.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8145B0BF7B52600534175 /* Selector.h */; };
+		44D814610BF7B58A00534175 /* ProgressWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8145F0BF7B58A00534175 /* ProgressWindow.h */; };
+		44D814620BF7B58A00534175 /* SaveLoadWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814600BF7B58A00534175 /* SaveLoadWindow.h */; };
+		44D814650BF7B5AD00534175 /* ProgressWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 44D814630BF7B5AD00534175 /* ProgressWindow.cpp */; };
+		44D814660BF7B5AD00534175 /* SaveLoadWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 44D814640BF7B5AD00534175 /* SaveLoadWindow.cpp */; };
+		44D814690BF7B5C700534175 /* Landmark.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 44D814670BF7B5C700534175 /* Landmark.cpp */; };
+		44D8146A0BF7B5C700534175 /* LandmarkPath.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 44D814680BF7B5C700534175 /* LandmarkPath.cpp */; };
+		44D8146D0BF7B5E800534175 /* Landmark.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8146B0BF7B5E800534175 /* Landmark.h */; };
+		44D8146E0BF7B5E800534175 /* LandmarkPath.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8146C0BF7B5E800534175 /* LandmarkPath.h */; };
+		44D814710BF7B61500534175 /* Zone.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 44D8146F0BF7B61500534175 /* Zone.cpp */; };
+		44D814720BF7B61500534175 /* ZoneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 44D814700BF7B61500534175 /* ZoneManager.cpp */; };
+		44D814780BF7B62F00534175 /* CoreDefines.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814730BF7B62F00534175 /* CoreDefines.h */; };
+		44D814790BF7B62F00534175 /* LightFadeJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814740BF7B62F00534175 /* LightFadeJob.h */; };
+		44D8147A0BF7B62F00534175 /* Trigger.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814750BF7B62F00534175 /* Trigger.h */; };
+		44D8147B0BF7B62F00534175 /* Zone.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814760BF7B62F00534175 /* Zone.h */; };
+		44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814770BF7B62F00534175 /* ZoneManager.h */; };
+		8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */; };
+		8D0C4E8E0486CD37000505A6 /* main.nib in Resources */ = {isa = PBXBuildFile; fileRef = 02345980000FD03B11CA0E72 /* main.nib */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXContainerItemProxy section */
+		440788010C09D6DD006E496D /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC3D0BD0E46000C6D4A0;
+			remoteInfo = RlUi;
+		};
+		440788080C09D706006E496D /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 440786100C09D602006E496D;
+			remoteInfo = RlScript2;
+		};
+		444EAC1E0BD0E3A800C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAAB10BD0E0FB00C6D4A0;
+			remoteInfo = RlCommon;
+		};
+		444EAC200BD0E3A800C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAB600BD0E2DA00C6D4A0;
+			remoteInfo = RlCore;
+		};
+		444EAC4A0BD0E49900C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC260BD0E3FF00C6D4A0;
+			remoteInfo = RlAi;
+		};
+		444EAC4C0BD0E49900C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC2E0BD0E42A00C6D4A0;
+			remoteInfo = RlDialog;
+		};
+		444EAC4E0BD0E49900C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC360BD0E44900C6D4A0;
+			remoteInfo = RlRules;
+		};
+		444EAC500BD0E49900C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC3D0BD0E46000C6D4A0;
+			remoteInfo = RlUi;
+		};
+		444EB1310BD11A3A00C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAAB10BD0E0FB00C6D4A0;
+			remoteInfo = RlCommon;
+		};
+		444EB1350BD11A5C00C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC360BD0E44900C6D4A0;
+			remoteInfo = RlRules;
+		};
+		444EB1DA0BD159B600C6D4A0 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC360BD0E44900C6D4A0;
+			remoteInfo = RlRules;
+		};
+		44F219FF0BD2142A00EF01CF /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC360BD0E44900C6D4A0;
+			remoteInfo = RlRules;
+		};
+		44F21A050BD2143D00EF01CF /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAB600BD0E2DA00C6D4A0;
+			remoteInfo = RlCore;
+		};
+/* End PBXContainerItemProxy section */
+
+/* Begin PBXFileReference section */
+		0867D6ABFE840B52C02AAC07 /* English */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = English; path = English.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		1870340FFE93FCAF11CA0CD7 /* English */ = {isa = PBXFileReference; lastKnownFileType = wrapper.nib; name = English; path = English.lproj/main.nib; sourceTree = "<group>"; };
+		4404DA6E0C48CEE2007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ai/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA7C0C48CFB3007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/common/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/core/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA800C48CFDE007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/dialog/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA820C48D005007B4657 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/rules/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
+		4404DA840C48D01E007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/script/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA850C48D037007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ui/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		440785DD0C09D231006E496D /* libmeshmagick.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libmeshmagick.dylib; path = /usr/local/lib/libmeshmagick.dylib; sourceTree = "<absolute>"; };
+		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
+		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
+		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MergeableMeshObject.h; path = ../engine/core/include/MergeableMeshObject.h; sourceTree = SOURCE_ROOT; };
+		440786110C09D602006E496D /* libRlScript.bundle */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = libRlScript.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
+		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "RlScript-Info.plist"; sourceTree = "<group>"; };
+		44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureWalkPathJob.cpp; path = ../engine/ai/src/CreatureWalkPathJob.cpp; sourceTree = SOURCE_ROOT; };
+		44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureWalkPathJob.h; path = ../engine/ai/include/CreatureWalkPathJob.h; sourceTree = SOURCE_ROOT; };
+		444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AbstractMapNodeProcessor.cpp; path = ../engine/script/src/AbstractMapNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825DA0BF7B2B200C5A94F /* EntityNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EntityNodeProcessor.cpp; path = ../engine/script/src/EntityNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825DB0BF7B2B200C5A94F /* EnvironmentProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EnvironmentProcessor.cpp; path = ../engine/script/src/EnvironmentProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825DC0BF7B2B200C5A94F /* GameObjectNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameObjectNodeProcessor.cpp; path = ../engine/script/src/GameObjectNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825DD0BF7B2B200C5A94F /* LightNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightNodeProcessor.cpp; path = ../engine/script/src/LightNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825DE0BF7B2B200C5A94F /* MapLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MapLoader.cpp; path = ../engine/script/src/MapLoader.cpp; sourceTree = SOURCE_ROOT; };
+		444825DF0BF7B2B200C5A94F /* ParticleSystemNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ParticleSystemNodeProcessor.cpp; path = ../engine/script/src/ParticleSystemNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825E00BF7B2B200C5A94F /* SoundNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundNodeProcessor.cpp; path = ../engine/script/src/SoundNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825E10BF7B2B200C5A94F /* WaypointProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WaypointProcessor.cpp; path = ../engine/script/src/WaypointProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825E20BF7B2B200C5A94F /* ZoneProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ZoneProcessor.cpp; path = ../engine/script/src/ZoneProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractMapNodeProcessor.h; path = ../engine/script/include/AbstractMapNodeProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825EE0BF7B32100C5A94F /* EntityNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EntityNodeProcessor.h; path = ../engine/script/include/EntityNodeProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825EF0BF7B32100C5A94F /* EnvironmentProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EnvironmentProcessor.h; path = ../engine/script/include/EnvironmentProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825F00BF7B32100C5A94F /* GameObjectNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectNodeProcessor.h; path = ../engine/script/include/GameObjectNodeProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825F10BF7B32100C5A94F /* LightNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightNodeProcessor.h; path = ../engine/script/include/LightNodeProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825F20BF7B32100C5A94F /* MapLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MapLoader.h; path = ../engine/script/include/MapLoader.h; sourceTree = SOURCE_ROOT; };
+		444825F30BF7B32100C5A94F /* ParticleSystemNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ParticleSystemNodeProcessor.h; path = ../engine/script/include/ParticleSystemNodeProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825F40BF7B32100C5A94F /* SoundNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundNodeProcessor.h; path = ../engine/script/include/SoundNodeProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825F50BF7B32100C5A94F /* TriggerFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TriggerFactory.h; path = ../engine/script/include/TriggerFactory.h; sourceTree = SOURCE_ROOT; };
+		444825F60BF7B32100C5A94F /* WaypointProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WaypointProcessor.h; path = ../engine/script/include/WaypointProcessor.h; sourceTree = SOURCE_ROOT; };
+		444825F70BF7B32100C5A94F /* ZoneProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneProcessor.h; path = ../engine/script/include/ZoneProcessor.h; sourceTree = SOURCE_ROOT; };
+		444826030BF7B37D00C5A94F /* SelectionHelper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SelectionHelper.cpp; path = ../engine/rules/src/SelectionHelper.cpp; sourceTree = SOURCE_ROOT; };
+		444826040BF7B37D00C5A94F /* Selector.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Selector.cpp; path = ../engine/rules/src/Selector.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAAC0BD0E0C700C6D4A0 /* RastullahMain.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RastullahMain.cpp; path = ../engine/startup/src/RastullahMain.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlCommon.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		444EAAB60BD0E17000C6D4A0 /* ConfigFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigFile.cpp; path = ../engine/common/src/ConfigFile.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAB70BD0E17000C6D4A0 /* EventObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EventObject.cpp; path = ../engine/common/src/EventObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAB80BD0E17000C6D4A0 /* EventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EventSource.cpp; path = ../engine/common/src/EventSource.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAB90BD0E17000C6D4A0 /* GameTask.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameTask.cpp; path = ../engine/common/src/GameTask.cpp; sourceTree = SOURCE_ROOT; };
+		444EAABA0BD0E17000C6D4A0 /* Logger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Logger.cpp; path = ../engine/common/src/Logger.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC00BD0E18800C6D4A0 /* MathUtil.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MathUtil.cpp; path = ../engine/common/src/MathUtil.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC10BD0E18800C6D4A0 /* OgreXercesInput.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreXercesInput.cpp; path = ../engine/common/src/OgreXercesInput.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC20BD0E18800C6D4A0 /* Properties.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Properties.cpp; path = ../engine/common/src/Properties.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC30BD0E18800C6D4A0 /* Property.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Property.cpp; path = ../engine/common/src/Property.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC40BD0E18800C6D4A0 /* PropertyReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PropertyReader.cpp; path = ../engine/common/src/PropertyReader.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC50BD0E18800C6D4A0 /* ScriptWrapper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptWrapper.cpp; path = ../engine/common/src/ScriptWrapper.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC60BD0E18800C6D4A0 /* XmlErrorHandler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlErrorHandler.cpp; path = ../engine/common/src/XmlErrorHandler.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC70BD0E18800C6D4A0 /* XmlHelper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlHelper.cpp; path = ../engine/common/src/XmlHelper.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC80BD0E18800C6D4A0 /* XmlResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlResource.cpp; path = ../engine/common/src/XmlResource.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAC90BD0E18800C6D4A0 /* XmlResourceManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlResourceManager.cpp; path = ../engine/common/src/XmlResourceManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAAD40BD0E1EF00C6D4A0 /* CommonPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CommonPrerequisites.h; path = ../engine/common/include/CommonPrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EAAD50BD0E1EF00C6D4A0 /* ConfigFile.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ConfigFile.h; path = ../engine/common/include/ConfigFile.h; sourceTree = SOURCE_ROOT; };
+		444EAAD60BD0E1EF00C6D4A0 /* EventCaster.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EventCaster.h; path = ../engine/common/include/EventCaster.h; sourceTree = SOURCE_ROOT; };
+		444EAAD70BD0E1EF00C6D4A0 /* EventListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EventListener.h; path = ../engine/common/include/EventListener.h; sourceTree = SOURCE_ROOT; };
+		444EAAD80BD0E1EF00C6D4A0 /* EventObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EventObject.h; path = ../engine/common/include/EventObject.h; sourceTree = SOURCE_ROOT; };
+		444EAAD90BD0E1EF00C6D4A0 /* EventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EventSource.h; path = ../engine/common/include/EventSource.h; sourceTree = SOURCE_ROOT; };
+		444EAADA0BD0E1EF00C6D4A0 /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Exception.h; path = ../engine/common/include/Exception.h; sourceTree = SOURCE_ROOT; };
+		444EAADB0BD0E1EF00C6D4A0 /* FixRubyHeaders.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FixRubyHeaders.h; path = ../engine/common/include/FixRubyHeaders.h; sourceTree = SOURCE_ROOT; };
+		444EAADC0BD0E1EF00C6D4A0 /* GameTask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameTask.h; path = ../engine/common/include/GameTask.h; sourceTree = SOURCE_ROOT; };
+		444EAADD0BD0E1EF00C6D4A0 /* Logger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Logger.h; path = ../engine/common/include/Logger.h; sourceTree = SOURCE_ROOT; };
+		444EAADE0BD0E1EF00C6D4A0 /* MathUtil.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MathUtil.h; path = ../engine/common/include/MathUtil.h; sourceTree = SOURCE_ROOT; };
+		444EAADF0BD0E1EF00C6D4A0 /* OgreXercesInput.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreXercesInput.h; path = ../engine/common/include/OgreXercesInput.h; sourceTree = SOURCE_ROOT; };
+		444EAAE00BD0E1EF00C6D4A0 /* Properties.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Properties.h; path = ../engine/common/include/Properties.h; sourceTree = SOURCE_ROOT; };
+		444EAAE10BD0E1EF00C6D4A0 /* Property.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Property.h; path = ../engine/common/include/Property.h; sourceTree = SOURCE_ROOT; };
+		444EAAE20BD0E1EF00C6D4A0 /* PropertyReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PropertyReader.h; path = ../engine/common/include/PropertyReader.h; sourceTree = SOURCE_ROOT; };
+		444EAAE30BD0E1EF00C6D4A0 /* RastullahPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RastullahPrerequisites.h; path = ../engine/common/include/RastullahPrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EAAE40BD0E1EF00C6D4A0 /* ScriptWrapper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptWrapper.h; path = ../engine/common/include/ScriptWrapper.h; sourceTree = SOURCE_ROOT; };
+		444EAAE50BD0E1EF00C6D4A0 /* Sleep.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Sleep.h; path = ../engine/common/include/Sleep.h; sourceTree = SOURCE_ROOT; };
+		444EAAE60BD0E1EF00C6D4A0 /* Tripel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Tripel.h; path = ../engine/common/include/Tripel.h; sourceTree = SOURCE_ROOT; };
+		444EAAE70BD0E1EF00C6D4A0 /* XmlErrorHandler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlErrorHandler.h; path = ../engine/common/include/XmlErrorHandler.h; sourceTree = SOURCE_ROOT; };
+		444EAAE80BD0E1EF00C6D4A0 /* XmlHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlHelper.h; path = ../engine/common/include/XmlHelper.h; sourceTree = SOURCE_ROOT; };
+		444EAAE90BD0E1EF00C6D4A0 /* XmlResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResource.h; path = ../engine/common/include/XmlResource.h; sourceTree = SOURCE_ROOT; };
+		444EAAEA0BD0E1EF00C6D4A0 /* XmlResourceManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = XmlResourceManager.h; path = ../engine/common/include/XmlResourceManager.h; sourceTree = SOURCE_ROOT; };
+		444EAB210BD0E2B600C6D4A0 /* Actor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Actor.cpp; path = ../engine/core/src/Actor.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorControlledObject.cpp; path = ../engine/core/src/ActorControlledObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActorManager.cpp; path = ../engine/core/src/ActorManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB240BD0E2B600C6D4A0 /* AnimationListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AnimationListener.cpp; path = ../engine/core/src/AnimationListener.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AnimationManager.cpp; path = ../engine/core/src/AnimationManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BaseAnimation.cpp; path = ../engine/core/src/BaseAnimation.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = BoxPrimitive.cpp; path = ../engine/core/src/BoxPrimitive.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CameraObject.cpp; path = ../engine/core/src/CameraObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigurationManager.cpp; path = ../engine/core/src/ConfigurationManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentModule.cpp; path = ../engine/core/src/ContentModule.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB2B0BD0E2B600C6D4A0 /* CoreEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CoreEvents.cpp; path = ../engine/core/src/CoreEvents.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CoreSubsystem.cpp; path = ../engine/core/src/CoreSubsystem.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualisable.cpp; path = ../engine/core/src/DebugVisualisable.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugVisualsManager.cpp; path = ../engine/core/src/DebugVisualsManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneLoader.cpp; path = ../engine/core/src/DotSceneLoader.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DotSceneOctreeWorld.cpp; path = ../engine/core/src/DotSceneOctreeWorld.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FadeAnimation.cpp; path = ../engine/core/src/FadeAnimation.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEvent.cpp; path = ../engine/core/src/GameAreaEvent.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaEventSource.cpp; path = ../engine/core/src/GameAreaEventSource.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaListener.cpp; path = ../engine/core/src/GameAreaListener.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameAreaTypes.cpp; path = ../engine/core/src/GameAreaTypes.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameEventManager.cpp; path = ../engine/core/src/GameEventManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameLoop.cpp; path = ../engine/core/src/GameLoop.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB380BD0E2B600C6D4A0 /* Job.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Job.cpp; path = ../engine/core/src/Job.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JobScheduler.cpp; path = ../engine/core/src/JobScheduler.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightObject.cpp; path = ../engine/core/src/LightObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LineSetPrimitive.cpp; path = ../engine/core/src/LineSetPrimitive.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerMovable.cpp; path = ../engine/core/src/ListenerMovable.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListenerObject.cpp; path = ../engine/core/src/ListenerObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshAnimation.cpp; path = ../engine/core/src/MeshAnimation.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MeshObject.cpp; path = ../engine/core/src/MeshObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MovableText.cpp; path = ../engine/core/src/MovableText.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB420BD0E2B600C6D4A0 /* nulldriver */ = {isa = PBXFileReference; lastKnownFileType = folder; name = nulldriver; path = ../engine/core/src/nulldriver; sourceTree = SOURCE_ROOT; };
+		444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullDriver.cpp; path = ../engine/core/src/nulldriver/NullDriver.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullListener.cpp; path = ../engine/core/src/nulldriver/NullListener.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSound.cpp; path = ../engine/core/src/nulldriver/NullSound.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ParticleSystemObject.cpp; path = ../engine/core/src/ParticleSystemObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicalThing.cpp; path = ../engine/core/src/PhysicalThing.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsContactListener.cpp; path = ../engine/core/src/PhysicsContactListener.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsGenericContactCallback.cpp; path = ../engine/core/src/PhysicsGenericContactCallback.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsManager.cpp; path = ../engine/core/src/PhysicsManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicsMaterialRaycast.cpp; path = ../engine/core/src/PhysicsMaterialRaycast.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlayAnimationJob.cpp; path = ../engine/core/src/PlayAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaySoundJob.cpp; path = ../engine/core/src/PlaySoundJob.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PrimitiveObject.cpp; path = ../engine/core/src/PrimitiveObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RubyInterpreter.cpp; path = ../engine/core/src/RubyInterpreter.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneQuery.cpp; path = ../engine/core/src/SceneQuery.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB550BD0E2B600C6D4A0 /* Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Sound.cpp; path = ../engine/core/src/Sound.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundDriver.cpp; path = ../engine/core/src/SoundDriver.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundEvents.cpp; path = ../engine/core/src/SoundEvents.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundManager.cpp; path = ../engine/core/src/SoundManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundObject.cpp; path = ../engine/core/src/SoundObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundResource.cpp; path = ../engine/core/src/SoundResource.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TrackAnimation.cpp; path = ../engine/core/src/TrackAnimation.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB5C0BD0E2B600C6D4A0 /* World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = World.cpp; path = ../engine/core/src/World.cpp; sourceTree = SOURCE_ROOT; };
+		444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlCore.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		444EAB9D0BD0E33300C6D4A0 /* Actor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Actor.h; path = ../engine/core/include/Actor.h; sourceTree = SOURCE_ROOT; };
+		444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorControlledObject.h; path = ../engine/core/include/ActorControlledObject.h; sourceTree = SOURCE_ROOT; };
+		444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActorManager.h; path = ../engine/core/include/ActorManager.h; sourceTree = SOURCE_ROOT; };
+		444EABA00BD0E33300C6D4A0 /* AnimationListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AnimationListener.h; path = ../engine/core/include/AnimationListener.h; sourceTree = SOURCE_ROOT; };
+		444EABA10BD0E33300C6D4A0 /* AnimationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AnimationManager.h; path = ../engine/core/include/AnimationManager.h; sourceTree = SOURCE_ROOT; };
+		444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BaseAnimation.h; path = ../engine/core/include/BaseAnimation.h; sourceTree = SOURCE_ROOT; };
+		444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = BoxPrimitive.h; path = ../engine/core/include/BoxPrimitive.h; sourceTree = SOURCE_ROOT; };
+		444EABA40BD0E33300C6D4A0 /* CameraObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CameraObject.h; path = ../engine/core/include/CameraObject.h; sourceTree = SOURCE_ROOT; };
+		444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ConfigurationManager.h; path = ../engine/core/include/ConfigurationManager.h; sourceTree = SOURCE_ROOT; };
+		444EABA60BD0E33300C6D4A0 /* ContentModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentModule.h; path = ../engine/core/include/ContentModule.h; sourceTree = SOURCE_ROOT; };
+		444EABA70BD0E33300C6D4A0 /* CoreEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreEvents.h; path = ../engine/core/include/CoreEvents.h; sourceTree = SOURCE_ROOT; };
+		444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CorePrerequisites.h; path = ../engine/core/include/CorePrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreSubsystem.h; path = ../engine/core/include/CoreSubsystem.h; sourceTree = SOURCE_ROOT; };
+		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualisable.h; path = ../engine/core/include/DebugVisualisable.h; sourceTree = SOURCE_ROOT; };
+		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugVisualsManager.h; path = ../engine/core/include/DebugVisualsManager.h; sourceTree = SOURCE_ROOT; };
+		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneLoader.h; path = ../engine/core/include/DotSceneLoader.h; sourceTree = SOURCE_ROOT; };
+		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DotSceneOctreeWorld.h; path = ../engine/core/include/DotSceneOctreeWorld.h; sourceTree = SOURCE_ROOT; };
+		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FadeAnimation.h; path = ../engine/core/include/FadeAnimation.h; sourceTree = SOURCE_ROOT; };
+		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEvent.h; path = ../engine/core/include/GameAreaEvent.h; sourceTree = SOURCE_ROOT; };
+		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaEventSource.h; path = ../engine/core/include/GameAreaEventSource.h; sourceTree = SOURCE_ROOT; };
+		444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaListener.h; path = ../engine/core/include/GameAreaListener.h; sourceTree = SOURCE_ROOT; };
+		444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameAreaTypes.h; path = ../engine/core/include/GameAreaTypes.h; sourceTree = SOURCE_ROOT; };
+		444EABB30BD0E33300C6D4A0 /* GameEventManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameEventManager.h; path = ../engine/core/include/GameEventManager.h; sourceTree = SOURCE_ROOT; };
+		444EABB40BD0E33300C6D4A0 /* GameLoop.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameLoop.h; path = ../engine/core/include/GameLoop.h; sourceTree = SOURCE_ROOT; };
+		444EABB50BD0E33300C6D4A0 /* Job.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Job.h; path = ../engine/core/include/Job.h; sourceTree = SOURCE_ROOT; };
+		444EABB60BD0E33300C6D4A0 /* JobListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobListener.h; path = ../engine/core/include/JobListener.h; sourceTree = SOURCE_ROOT; };
+		444EABB70BD0E33300C6D4A0 /* JobScheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JobScheduler.h; path = ../engine/core/include/JobScheduler.h; sourceTree = SOURCE_ROOT; };
+		444EABB80BD0E33300C6D4A0 /* LightObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightObject.h; path = ../engine/core/include/LightObject.h; sourceTree = SOURCE_ROOT; };
+		444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LineSetPrimitive.h; path = ../engine/core/include/LineSetPrimitive.h; sourceTree = SOURCE_ROOT; };
+		444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerMovable.h; path = ../engine/core/include/ListenerMovable.h; sourceTree = SOURCE_ROOT; };
+		444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListenerObject.h; path = ../engine/core/include/ListenerObject.h; sourceTree = SOURCE_ROOT; };
+		444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshAnimation.h; path = ../engine/core/include/MeshAnimation.h; sourceTree = SOURCE_ROOT; };
+		444EABBE0BD0E33300C6D4A0 /* MeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MeshObject.h; path = ../engine/core/include/MeshObject.h; sourceTree = SOURCE_ROOT; };
+		444EABBF0BD0E33300C6D4A0 /* MovableText.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MovableText.h; path = ../engine/core/include/MovableText.h; sourceTree = SOURCE_ROOT; };
+		444EABC50BD0E33300C6D4A0 /* NullDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullDriver.h; path = ../engine/core/include/nulldriver/NullDriver.h; sourceTree = SOURCE_ROOT; };
+		444EABC60BD0E33300C6D4A0 /* NullListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullListener.h; path = ../engine/core/include/nulldriver/NullListener.h; sourceTree = SOURCE_ROOT; };
+		444EABC70BD0E33300C6D4A0 /* NullSound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSound.h; path = ../engine/core/include/nulldriver/NullSound.h; sourceTree = SOURCE_ROOT; };
+		444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ParticleSystemObject.h; path = ../engine/core/include/ParticleSystemObject.h; sourceTree = SOURCE_ROOT; };
+		444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalObject.h; path = ../engine/core/include/PhysicalObject.h; sourceTree = SOURCE_ROOT; };
+		444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalThing.h; path = ../engine/core/include/PhysicalThing.h; sourceTree = SOURCE_ROOT; };
+		444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsContactListener.h; path = ../engine/core/include/PhysicsContactListener.h; sourceTree = SOURCE_ROOT; };
+		444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsController.h; path = ../engine/core/include/PhysicsController.h; sourceTree = SOURCE_ROOT; };
+		444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsGenericContactCallback.h; path = ../engine/core/include/PhysicsGenericContactCallback.h; sourceTree = SOURCE_ROOT; };
+		444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsManager.h; path = ../engine/core/include/PhysicsManager.h; sourceTree = SOURCE_ROOT; };
+		444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicsMaterialRaycast.h; path = ../engine/core/include/PhysicsMaterialRaycast.h; sourceTree = SOURCE_ROOT; };
+		444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlayAnimationJob.h; path = ../engine/core/include/PlayAnimationJob.h; sourceTree = SOURCE_ROOT; };
+		444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaySoundJob.h; path = ../engine/core/include/PlaySoundJob.h; sourceTree = SOURCE_ROOT; };
+		444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PrimitiveObject.h; path = ../engine/core/include/PrimitiveObject.h; sourceTree = SOURCE_ROOT; };
+		444EABD30BD0E33300C6D4A0 /* QuadTree.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuadTree.h; path = ../engine/core/include/QuadTree.h; sourceTree = SOURCE_ROOT; };
+		444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RubyInterpreter.h; path = ../engine/core/include/RubyInterpreter.h; sourceTree = SOURCE_ROOT; };
+		444EABD50BD0E33300C6D4A0 /* SceneQuery.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SceneQuery.h; path = ../engine/core/include/SceneQuery.h; sourceTree = SOURCE_ROOT; };
+		444EABD60BD0E33300C6D4A0 /* Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Sound.h; path = ../engine/core/include/Sound.h; sourceTree = SOURCE_ROOT; };
+		444EABD70BD0E33300C6D4A0 /* SoundDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundDriver.h; path = ../engine/core/include/SoundDriver.h; sourceTree = SOURCE_ROOT; };
+		444EABD80BD0E33300C6D4A0 /* SoundEvents.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundEvents.h; path = ../engine/core/include/SoundEvents.h; sourceTree = SOURCE_ROOT; };
+		444EABD90BD0E33300C6D4A0 /* SoundManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundManager.h; path = ../engine/core/include/SoundManager.h; sourceTree = SOURCE_ROOT; };
+		444EABDA0BD0E33300C6D4A0 /* SoundObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundObject.h; path = ../engine/core/include/SoundObject.h; sourceTree = SOURCE_ROOT; };
+		444EABDB0BD0E33300C6D4A0 /* SoundResource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundResource.h; path = ../engine/core/include/SoundResource.h; sourceTree = SOURCE_ROOT; };
+		444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TrackAnimation.h; path = ../engine/core/include/TrackAnimation.h; sourceTree = SOURCE_ROOT; };
+		444EABDD0BD0E33300C6D4A0 /* World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = World.h; path = ../engine/core/include/World.h; sourceTree = SOURCE_ROOT; };
+		444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlAi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		444EAC2F0BD0E42A00C6D4A0 /* libRlDialog.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlDialog.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlRules.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlUi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		444EAC5A0BD0E52E00C6D4A0 /* Agent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Agent.cpp; path = ../engine/ai/src/Agent.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC5B0BD0E52E00C6D4A0 /* AgentManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AgentManager.cpp; path = ../engine/ai/src/AgentManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC5C0BD0E52E00C6D4A0 /* AiSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AiSubsystem.cpp; path = ../engine/ai/src/AiSubsystem.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC5D0BD0E52E00C6D4A0 /* AiWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AiWorld.cpp; path = ../engine/ai/src/AiWorld.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC5E0BD0E52E00C6D4A0 /* AStar.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AStar.cpp; path = ../engine/ai/src/AStar.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC5F0BD0E52E00C6D4A0 /* AStarCosts.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AStarCosts.cpp; path = ../engine/ai/src/AStarCosts.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC600BD0E52E00C6D4A0 /* AStarHeuristic.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AStarHeuristic.cpp; path = ../engine/ai/src/AStarHeuristic.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC610BD0E52E00C6D4A0 /* AStarNodePool.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AStarNodePool.cpp; path = ../engine/ai/src/AStarNodePool.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC620BD0E52E00C6D4A0 /* AStarWayPointNode.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AStarWayPointNode.cpp; path = ../engine/ai/src/AStarWayPointNode.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC630BD0E52E00C6D4A0 /* FuzzyState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FuzzyState.cpp; path = ../engine/ai/src/FuzzyState.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC640BD0E52E00C6D4A0 /* FuzzyStateMachine.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FuzzyStateMachine.cpp; path = ../engine/ai/src/FuzzyStateMachine.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC650BD0E52E00C6D4A0 /* PhysicalObstacle.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PhysicalObstacle.cpp; path = ../engine/ai/src/PhysicalObstacle.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC660BD0E52E00C6D4A0 /* PlayerVehicle.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlayerVehicle.cpp; path = ../engine/ai/src/PlayerVehicle.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC670BD0E52E00C6D4A0 /* SteeringVehicle.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SteeringVehicle.cpp; path = ../engine/ai/src/SteeringVehicle.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC680BD0E52E00C6D4A0 /* WayPointGraph.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WayPointGraph.cpp; path = ../engine/ai/src/WayPointGraph.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC690BD0E52E00C6D4A0 /* WayPointGraphManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WayPointGraphManager.cpp; path = ../engine/ai/src/WayPointGraphManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC6A0BD0E52E00C6D4A0 /* WayPointNode.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WayPointNode.cpp; path = ../engine/ai/src/WayPointNode.cpp; sourceTree = SOURCE_ROOT; };
+		444EAC7C0BD0E54000C6D4A0 /* Agent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Agent.h; path = ../engine/ai/include/Agent.h; sourceTree = SOURCE_ROOT; };
+		444EAC7D0BD0E54000C6D4A0 /* AgentManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AgentManager.h; path = ../engine/ai/include/AgentManager.h; sourceTree = SOURCE_ROOT; };
+		444EAC7E0BD0E54000C6D4A0 /* AiPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AiPrerequisites.h; path = ../engine/ai/include/AiPrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EAC7F0BD0E54000C6D4A0 /* AiSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AiSubsystem.h; path = ../engine/ai/include/AiSubsystem.h; sourceTree = SOURCE_ROOT; };
+		444EAC800BD0E54000C6D4A0 /* AiWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AiWorld.h; path = ../engine/ai/include/AiWorld.h; sourceTree = SOURCE_ROOT; };
+		444EAC810BD0E54000C6D4A0 /* AStar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AStar.h; path = ../engine/ai/include/AStar.h; sourceTree = SOURCE_ROOT; };
+		444EAC820BD0E54000C6D4A0 /* AStarCosts.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AStarCosts.h; path = ../engine/ai/include/AStarCosts.h; sourceTree = SOURCE_ROOT; };
+		444EAC830BD0E54000C6D4A0 /* AStarHeuristic.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AStarHeuristic.h; path = ../engine/ai/include/AStarHeuristic.h; sourceTree = SOURCE_ROOT; };
+		444EAC840BD0E54000C6D4A0 /* AStarNodePool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AStarNodePool.h; path = ../engine/ai/include/AStarNodePool.h; sourceTree = SOURCE_ROOT; };
+		444EAC850BD0E54000C6D4A0 /* AStarWayPointNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AStarWayPointNode.h; path = ../engine/ai/include/AStarWayPointNode.h; sourceTree = SOURCE_ROOT; };
+		444EAC860BD0E54100C6D4A0 /* FuzzyState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FuzzyState.h; path = ../engine/ai/include/FuzzyState.h; sourceTree = SOURCE_ROOT; };
+		444EAC870BD0E54100C6D4A0 /* FuzzyStateMachine.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FuzzyStateMachine.h; path = ../engine/ai/include/FuzzyStateMachine.h; sourceTree = SOURCE_ROOT; };
+		444EAC880BD0E54100C6D4A0 /* PhysicalObstacle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PhysicalObstacle.h; path = ../engine/ai/include/PhysicalObstacle.h; sourceTree = SOURCE_ROOT; };
+		444EAC890BD0E54100C6D4A0 /* PlayerVehicle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlayerVehicle.h; path = ../engine/ai/include/PlayerVehicle.h; sourceTree = SOURCE_ROOT; };
+		444EAC8A0BD0E54100C6D4A0 /* SteeringMachine.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SteeringMachine.h; path = ../engine/ai/include/SteeringMachine.h; sourceTree = SOURCE_ROOT; };
+		444EAC8B0BD0E54100C6D4A0 /* SteeringVehicle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SteeringVehicle.h; path = ../engine/ai/include/SteeringVehicle.h; sourceTree = SOURCE_ROOT; };
+		444EAC8C0BD0E54100C6D4A0 /* WayPointGraph.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WayPointGraph.h; path = ../engine/ai/include/WayPointGraph.h; sourceTree = SOURCE_ROOT; };
+		444EAC8D0BD0E54100C6D4A0 /* WayPointGraphManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WayPointGraphManager.h; path = ../engine/ai/include/WayPointGraphManager.h; sourceTree = SOURCE_ROOT; };
+		444EAC8E0BD0E54100C6D4A0 /* WayPointNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WayPointNode.h; path = ../engine/ai/include/WayPointNode.h; sourceTree = SOURCE_ROOT; };
+		444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AboutWindow.cpp; path = ../engine/ui/src/AboutWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AbstractWindow.cpp; path = ../engine/ui/src/AbstractWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActionChoiceWindow.cpp; path = ../engine/ui/src/ActionChoiceWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CharacterSheetWindow.cpp; path = ../engine/ui/src/CharacterSheetWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CharacterStateWindow.cpp; path = ../engine/ui/src/CharacterStateWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CloseConfirmationWindow.cpp; path = ../engine/ui/src/CloseConfirmationWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CommandMapper.cpp; path = ../engine/ui/src/CommandMapper.cpp; sourceTree = SOURCE_ROOT; };
+		444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigComponent.cpp; path = ../engine/ui/src/ConfigComponent.cpp; sourceTree = SOURCE_ROOT; };
+		444EACAD0BD0E57100C6D4A0 /* Console.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Console.cpp; path = ../engine/ui/src/Console.cpp; sourceTree = SOURCE_ROOT; };
+		444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContainerContentWindow.cpp; path = ../engine/ui/src/ContainerContentWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugWindow.cpp; path = ../engine/ui/src/DebugWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogWindow.cpp; path = ../engine/ui/src/DialogWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameLoggerWindow.cpp; path = ../engine/ui/src/GameLoggerWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameObjectInfoWindow.cpp; path = ../engine/ui/src/GameObjectInfoWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameSettings.cpp; path = ../engine/ui/src/GameSettings.cpp; sourceTree = SOURCE_ROOT; };
+		444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InfoPopup.cpp; path = ../engine/ui/src/InfoPopup.cpp; sourceTree = SOURCE_ROOT; };
+		444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InGameMenuWindow.cpp; path = ../engine/ui/src/InGameMenuWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InputManager.cpp; path = ../engine/ui/src/InputManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InventoryWindow.cpp; path = ../engine/ui/src/InventoryWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ItemDragContainer.cpp; path = ../engine/ui/src/ItemDragContainer.cpp; sourceTree = SOURCE_ROOT; };
+		444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JournalWindow.cpp; path = ../engine/ui/src/JournalWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListboxWrappedTextItem.cpp; path = ../engine/ui/src/ListboxWrappedTextItem.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LogWindow.cpp; path = ../engine/ui/src/LogWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MainMenuEngineWindow.cpp; path = ../engine/ui/src/MainMenuEngineWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MainMenuWindow.cpp; path = ../engine/ui/src/MainMenuWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MessageWindow.cpp; path = ../engine/ui/src/MessageWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectDescriptionWindow.cpp; path = ../engine/ui/src/ObjectDescriptionWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaylistWindow.cpp; path = ../engine/ui/src/PlaylistWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RenderSystemConfigComponent.cpp; path = ../engine/ui/src/RenderSystemConfigComponent.cpp; sourceTree = SOURCE_ROOT; };
+		444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundConfig.cpp; path = ../engine/ui/src/SoundConfig.cpp; sourceTree = SOURCE_ROOT; };
+		444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundDriverConfigComponent.cpp; path = ../engine/ui/src/SoundDriverConfigComponent.cpp; sourceTree = SOURCE_ROOT; };
+		444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SubtitleWindow.cpp; path = ../engine/ui/src/SubtitleWindow.cpp; sourceTree = SOURCE_ROOT; };
+		444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = UiSubsystem.cpp; path = ../engine/ui/src/UiSubsystem.cpp; sourceTree = SOURCE_ROOT; };
+		444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WindowFactory.cpp; path = ../engine/ui/src/WindowFactory.cpp; sourceTree = SOURCE_ROOT; };
+		444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WindowFadeJob.cpp; path = ../engine/ui/src/WindowFadeJob.cpp; sourceTree = SOURCE_ROOT; };
+		444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WindowManager.cpp; path = ../engine/ui/src/WindowManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AboutWindow.h; path = ../engine/ui/include/AboutWindow.h; sourceTree = SOURCE_ROOT; };
+		444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractWindow.h; path = ../engine/ui/include/AbstractWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActionChoiceWindow.h; path = ../engine/ui/include/ActionChoiceWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CeGuiHelper.h; path = ../engine/ui/include/CeGuiHelper.h; sourceTree = SOURCE_ROOT; };
+		444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CharacterSheetWindow.h; path = ../engine/ui/include/CharacterSheetWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CharacterStateWindow.h; path = ../engine/ui/include/CharacterStateWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CloseConfirmationWindow.h; path = ../engine/ui/include/CloseConfirmationWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CommandMapper.h; path = ../engine/ui/include/CommandMapper.h; sourceTree = SOURCE_ROOT; };
+		444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ConfigComponent.h; path = ../engine/ui/include/ConfigComponent.h; sourceTree = SOURCE_ROOT; };
+		444EAD0A0BD0E58C00C6D4A0 /* Console.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Console.h; path = ../engine/ui/include/Console.h; sourceTree = SOURCE_ROOT; };
+		444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContainerContentWindow.h; path = ../engine/ui/include/ContainerContentWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugWindow.h; path = ../engine/ui/include/DebugWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogWindow.h; path = ../engine/ui/include/DialogWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameLoggerWindow.h; path = ../engine/ui/include/GameLoggerWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectInfoWindow.h; path = ../engine/ui/include/GameObjectInfoWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD150BD0E58C00C6D4A0 /* GameSettings.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameSettings.h; path = ../engine/ui/include/GameSettings.h; sourceTree = SOURCE_ROOT; };
+		444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InfoPopup.h; path = ../engine/ui/include/InfoPopup.h; sourceTree = SOURCE_ROOT; };
+		444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InGameMenuWindow.h; path = ../engine/ui/include/InGameMenuWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD180BD0E58C00C6D4A0 /* InputManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InputManager.h; path = ../engine/ui/include/InputManager.h; sourceTree = SOURCE_ROOT; };
+		444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InventoryWindow.h; path = ../engine/ui/include/InventoryWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ItemDragContainer.h; path = ../engine/ui/include/ItemDragContainer.h; sourceTree = SOURCE_ROOT; };
+		444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JournalWindow.h; path = ../engine/ui/include/JournalWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListboxWrappedTextItem.h; path = ../engine/ui/include/ListboxWrappedTextItem.h; sourceTree = SOURCE_ROOT; };
+		444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LogWindow.h; path = ../engine/ui/include/LogWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MainMenuEngineWindow.h; path = ../engine/ui/include/MainMenuEngineWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MainMenuWindow.h; path = ../engine/ui/include/MainMenuWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageWindow.h; path = ../engine/ui/include/MessageWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectDescriptionWindow.h; path = ../engine/ui/include/ObjectDescriptionWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaylistWindow.h; path = ../engine/ui/include/PlaylistWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RenderSystemConfigComponent.h; path = ../engine/ui/include/RenderSystemConfigComponent.h; sourceTree = SOURCE_ROOT; };
+		444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundConfig.h; path = ../engine/ui/include/SoundConfig.h; sourceTree = SOURCE_ROOT; };
+		444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundDriverConfigComponent.h; path = ../engine/ui/include/SoundDriverConfigComponent.h; sourceTree = SOURCE_ROOT; };
+		444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SubtitleWindow.h; path = ../engine/ui/include/SubtitleWindow.h; sourceTree = SOURCE_ROOT; };
+		444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = UiPrerequisites.h; path = ../engine/ui/include/UiPrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = UiSubsystem.h; path = ../engine/ui/include/UiSubsystem.h; sourceTree = SOURCE_ROOT; };
+		444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowFactory.h; path = ../engine/ui/include/WindowFactory.h; sourceTree = SOURCE_ROOT; };
+		444EAD2C0BD0E58C00C6D4A0 /* WindowFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowFadeJob.h; path = ../engine/ui/include/WindowFadeJob.h; sourceTree = SOURCE_ROOT; };
+		444EAD2D0BD0E58C00C6D4A0 /* WindowManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowManager.h; path = ../engine/ui/include/WindowManager.h; sourceTree = SOURCE_ROOT; };
+		444EAD5E0BD0E5D500C6D4A0 /* AimlNodeImplRl.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AimlNodeImplRl.cpp; path = ../engine/dialog/src/AimlNodeImplRl.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD5F0BD0E5D500C6D4A0 /* AimlParserImplRl.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AimlParserImplRl.cpp; path = ../engine/dialog/src/AimlParserImplRl.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD600BD0E5D500C6D4A0 /* ContextConditionProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContextConditionProcessor.cpp; path = ../engine/dialog/src/ContextConditionProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD610BD0E5D500C6D4A0 /* ContextInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContextInterpreter.cpp; path = ../engine/dialog/src/ContextInterpreter.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD620BD0E5D500C6D4A0 /* DialogCharacter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogCharacter.cpp; path = ../engine/dialog/src/DialogCharacter.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD630BD0E5D500C6D4A0 /* DialogOption.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogOption.cpp; path = ../engine/dialog/src/DialogOption.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD640BD0E5D500C6D4A0 /* DialogResponse.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogResponse.cpp; path = ../engine/dialog/src/DialogResponse.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD650BD0E5D500C6D4A0 /* DialogScriptProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogScriptProcessor.cpp; path = ../engine/dialog/src/DialogScriptProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD660BD0E5D500C6D4A0 /* DialogSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogSubsystem.cpp; path = ../engine/dialog/src/DialogSubsystem.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD670BD0E5D500C6D4A0 /* ScriptProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptProcessor.cpp; path = ../engine/dialog/src/ScriptProcessor.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD720BD0E5E900C6D4A0 /* CreaturePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreaturePredicates.cpp; path = ../engine/dialog/src/predicates/CreaturePredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD730BD0E5E900C6D4A0 /* EigenschaftsProbePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EigenschaftsProbePredicates.cpp; path = ../engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD740BD0E5E900C6D4A0 /* EigenschaftsWertPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EigenschaftsWertPredicates.cpp; path = ../engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD750BD0E5E900C6D4A0 /* GrundWertPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GrundWertPredicates.cpp; path = ../engine/dialog/src/predicates/GrundWertPredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD760BD0E5E900C6D4A0 /* QuestKnownPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestKnownPredicates.cpp; path = ../engine/dialog/src/predicates/QuestKnownPredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD770BD0E5E900C6D4A0 /* QuestPartsPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestPartsPredicates.cpp; path = ../engine/dialog/src/predicates/QuestPartsPredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD780BD0E5E900C6D4A0 /* QuestStatePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestStatePredicates.cpp; path = ../engine/dialog/src/predicates/QuestStatePredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD790BD0E5E900C6D4A0 /* ScriptPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptPredicates.cpp; path = ../engine/dialog/src/predicates/ScriptPredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD7A0BD0E5E900C6D4A0 /* TalentProbePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TalentProbePredicates.cpp; path = ../engine/dialog/src/predicates/TalentProbePredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD7B0BD0E5E900C6D4A0 /* TalentWertPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TalentWertPredicates.cpp; path = ../engine/dialog/src/predicates/TalentWertPredicates.cpp; sourceTree = SOURCE_ROOT; };
+		444EAD860BD0E60000C6D4A0 /* AimlNodeImplRl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AimlNodeImplRl.h; path = ../engine/dialog/include/AimlNodeImplRl.h; sourceTree = SOURCE_ROOT; };
+		444EAD870BD0E60000C6D4A0 /* AimlParserImplRl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AimlParserImplRl.h; path = ../engine/dialog/include/AimlParserImplRl.h; sourceTree = SOURCE_ROOT; };
+		444EAD880BD0E60000C6D4A0 /* ContextConditionProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContextConditionProcessor.h; path = ../engine/dialog/include/ContextConditionProcessor.h; sourceTree = SOURCE_ROOT; };
+		444EAD890BD0E60000C6D4A0 /* ContextInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContextInterpreter.h; path = ../engine/dialog/include/ContextInterpreter.h; sourceTree = SOURCE_ROOT; };
+		444EAD8A0BD0E60000C6D4A0 /* DialogCharacter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogCharacter.h; path = ../engine/dialog/include/DialogCharacter.h; sourceTree = SOURCE_ROOT; };
+		444EAD8B0BD0E60000C6D4A0 /* DialogOption.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogOption.h; path = ../engine/dialog/include/DialogOption.h; sourceTree = SOURCE_ROOT; };
+		444EAD8C0BD0E60000C6D4A0 /* DialogPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogPrerequisites.h; path = ../engine/dialog/include/DialogPrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EAD8D0BD0E60000C6D4A0 /* DialogResponse.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogResponse.h; path = ../engine/dialog/include/DialogResponse.h; sourceTree = SOURCE_ROOT; };
+		444EAD8E0BD0E60000C6D4A0 /* DialogScriptProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogScriptProcessor.h; path = ../engine/dialog/include/DialogScriptProcessor.h; sourceTree = SOURCE_ROOT; };
+		444EAD8F0BD0E60000C6D4A0 /* DialogSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogSubsystem.h; path = ../engine/dialog/include/DialogSubsystem.h; sourceTree = SOURCE_ROOT; };
+		444EAD900BD0E60000C6D4A0 /* ScriptProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptProcessor.h; path = ../engine/dialog/include/ScriptProcessor.h; sourceTree = SOURCE_ROOT; };
+		444EAD9C0BD0E61400C6D4A0 /* CreaturePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreaturePredicates.h; path = ../engine/dialog/include/predicates/CreaturePredicates.h; sourceTree = SOURCE_ROOT; };
+		444EAD9D0BD0E61400C6D4A0 /* EigenschaftsProbePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EigenschaftsProbePredicates.h; path = ../engine/dialog/include/predicates/EigenschaftsProbePredicates.h; sourceTree = SOURCE_ROOT; };
+		444EAD9E0BD0E61400C6D4A0 /* EigenschaftsWertPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EigenschaftsWertPredicates.h; path = ../engine/dialog/include/predicates/EigenschaftsWertPredicates.h; sourceTree = SOURCE_ROOT; };
+		444EAD9F0BD0E61400C6D4A0 /* GrundWertPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GrundWertPredicates.h; path = ../engine/dialog/include/predicates/GrundWertPredicates.h; sourceTree = SOURCE_ROOT; };
+		444EADA00BD0E61400C6D4A0 /* QuestKnownPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestKnownPredicates.h; path = ../engine/dialog/include/predicates/QuestKnownPredicates.h; sourceTree = SOURCE_ROOT; };
+		444EADA10BD0E61400C6D4A0 /* QuestPartsPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestPartsPredicates.h; path = ../engine/dialog/include/predicates/QuestPartsPredicates.h; sourceTree = SOURCE_ROOT; };
+		444EADA20BD0E61400C6D4A0 /* QuestStatePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestStatePredicates.h; path = ../engine/dialog/include/predicates/QuestStatePredicates.h; sourceTree = SOURCE_ROOT; };
+		444EADA30BD0E61400C6D4A0 /* ScriptPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptPredicates.h; path = ../engine/dialog/include/predicates/ScriptPredicates.h; sourceTree = SOURCE_ROOT; };
+		444EADA40BD0E61400C6D4A0 /* TalentProbePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentProbePredicates.h; path = ../engine/dialog/include/predicates/TalentProbePredicates.h; sourceTree = SOURCE_ROOT; };
+		444EADA50BD0E61400C6D4A0 /* TalentWertPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentWertPredicates.h; path = ../engine/dialog/include/predicates/TalentWertPredicates.h; sourceTree = SOURCE_ROOT; };
+		444EADB00BD0E64100C6D4A0 /* Action.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Action.cpp; path = ../engine/rules/src/Action.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActionManager.cpp; path = ../engine/rules/src/ActionManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB20BD0E64100C6D4A0 /* Armor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Armor.cpp; path = ../engine/rules/src/Armor.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB30BD0E64100C6D4A0 /* Combat.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Combat.cpp; path = ../engine/rules/src/Combat.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB40BD0E64100C6D4A0 /* CombatManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatManager.cpp; path = ../engine/rules/src/CombatManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB50BD0E64100C6D4A0 /* Container.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Container.cpp; path = ../engine/rules/src/Container.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB60BD0E64100C6D4A0 /* Creature.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Creature.cpp; path = ../engine/rules/src/Creature.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB70BD0E64100C6D4A0 /* Date.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Date.cpp; path = ../engine/rules/src/Date.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB80BD0E64100C6D4A0 /* DsaDataLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DsaDataLoader.cpp; path = ../engine/rules/src/DsaDataLoader.cpp; sourceTree = SOURCE_ROOT; };
+		444EADB90BD0E64100C6D4A0 /* DsaManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DsaManager.cpp; path = ../engine/rules/src/DsaManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EADBA0BD0E64100C6D4A0 /* Effect.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Effect.cpp; path = ../engine/rules/src/Effect.cpp; sourceTree = SOURCE_ROOT; };
+		444EADBB0BD0E64100C6D4A0 /* EffectManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EffectManager.cpp; path = ../engine/rules/src/EffectManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EADBC0BD0E64100C6D4A0 /* Eigenschaft.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Eigenschaft.cpp; path = ../engine/rules/src/Eigenschaft.cpp; sourceTree = SOURCE_ROOT; };
+		444EADBD0BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EigenschaftenStateSet.cpp; path = ../engine/rules/src/EigenschaftenStateSet.cpp; sourceTree = SOURCE_ROOT; };
+		444EADBE0BD0E64100C6D4A0 /* GameObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameObject.cpp; path = ../engine/rules/src/GameObject.cpp; sourceTree = SOURCE_ROOT; };
+		444EADBF0BD0E64100C6D4A0 /* GameObjectManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameObjectManager.cpp; path = ../engine/rules/src/GameObjectManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC10BD0E64100C6D4A0 /* Inventory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Inventory.cpp; path = ../engine/rules/src/Inventory.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC20BD0E64100C6D4A0 /* Item.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Item.cpp; path = ../engine/rules/src/Item.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC30BD0E64100C6D4A0 /* JournalEntry.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JournalEntry.cpp; path = ../engine/rules/src/JournalEntry.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC40BD0E64100C6D4A0 /* Kampftechnik.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Kampftechnik.cpp; path = ../engine/rules/src/Kampftechnik.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeEvent.cpp; path = ../engine/rules/src/ObjectStateChangeEvent.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeEventSource.cpp; path = ../engine/rules/src/ObjectStateChangeEventSource.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeListener.cpp; path = ../engine/rules/src/ObjectStateChangeListener.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC80BD0E64100C6D4A0 /* Person.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Person.cpp; path = ../engine/rules/src/Person.cpp; sourceTree = SOURCE_ROOT; };
+		444EADC90BD0E64100C6D4A0 /* Quest.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Quest.cpp; path = ../engine/rules/src/Quest.cpp; sourceTree = SOURCE_ROOT; };
+		444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestBook.cpp; path = ../engine/rules/src/QuestBook.cpp; sourceTree = SOURCE_ROOT; };
+		444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestEvent.cpp; path = ../engine/rules/src/QuestEvent.cpp; sourceTree = SOURCE_ROOT; };
+		444EADCC0BD0E64100C6D4A0 /* QuestListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestListener.cpp; path = ../engine/rules/src/QuestListener.cpp; sourceTree = SOURCE_ROOT; };
+		444EADCD0BD0E64100C6D4A0 /* RulesSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RulesSubsystem.cpp; path = ../engine/rules/src/RulesSubsystem.cpp; sourceTree = SOURCE_ROOT; };
+		444EADCE0BD0E64100C6D4A0 /* Slot.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Slot.cpp; path = ../engine/rules/src/Slot.cpp; sourceTree = SOURCE_ROOT; };
+		444EADCF0BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SonderfertigkeitenStateSet.cpp; path = ../engine/rules/src/SonderfertigkeitenStateSet.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD00BD0E64100C6D4A0 /* StateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StateSet.cpp; path = ../engine/rules/src/StateSet.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD10BD0E64100C6D4A0 /* Talent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Talent.cpp; path = ../engine/rules/src/Talent.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD20BD0E64100C6D4A0 /* Talentgruppe.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Talentgruppe.cpp; path = ../engine/rules/src/Talentgruppe.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD30BD0E64100C6D4A0 /* TalentStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TalentStateSet.cpp; path = ../engine/rules/src/TalentStateSet.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD40BD0E64100C6D4A0 /* TimerEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimerEvent.cpp; path = ../engine/rules/src/TimerEvent.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD50BD0E64100C6D4A0 /* TimerEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimerEventSource.cpp; path = ../engine/rules/src/TimerEventSource.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD60BD0E64100C6D4A0 /* TimerListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimerListener.cpp; path = ../engine/rules/src/TimerListener.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD70BD0E64100C6D4A0 /* TimerManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TimerManager.cpp; path = ../engine/rules/src/TimerManager.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD80BD0E64100C6D4A0 /* Weapon.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Weapon.cpp; path = ../engine/rules/src/Weapon.cpp; sourceTree = SOURCE_ROOT; };
+		444EADD90BD0E64100C6D4A0 /* ZauberStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ZauberStateSet.cpp; path = ../engine/rules/src/ZauberStateSet.cpp; sourceTree = SOURCE_ROOT; };
+		444EAE040BD0E65B00C6D4A0 /* Action.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Action.h; path = ../engine/rules/include/Action.h; sourceTree = SOURCE_ROOT; };
+		444EAE050BD0E65B00C6D4A0 /* ActionManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActionManager.h; path = ../engine/rules/include/ActionManager.h; sourceTree = SOURCE_ROOT; };
+		444EAE060BD0E65B00C6D4A0 /* Armor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Armor.h; path = ../engine/rules/include/Armor.h; sourceTree = SOURCE_ROOT; };
+		444EAE070BD0E65B00C6D4A0 /* Combat.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Combat.h; path = ../engine/rules/include/Combat.h; sourceTree = SOURCE_ROOT; };
+		444EAE080BD0E65B00C6D4A0 /* CombatManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatManager.h; path = ../engine/rules/include/CombatManager.h; sourceTree = SOURCE_ROOT; };
+		444EAE090BD0E65B00C6D4A0 /* Container.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Container.h; path = ../engine/rules/include/Container.h; sourceTree = SOURCE_ROOT; };
+		444EAE0A0BD0E65B00C6D4A0 /* Creature.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Creature.h; path = ../engine/rules/include/Creature.h; sourceTree = SOURCE_ROOT; };
+		444EAE0B0BD0E65B00C6D4A0 /* Date.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Date.h; path = ../engine/rules/include/Date.h; sourceTree = SOURCE_ROOT; };
+		444EAE0C0BD0E65B00C6D4A0 /* DsaDataLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DsaDataLoader.h; path = ../engine/rules/include/DsaDataLoader.h; sourceTree = SOURCE_ROOT; };
+		444EAE0D0BD0E65B00C6D4A0 /* DsaManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DsaManager.h; path = ../engine/rules/include/DsaManager.h; sourceTree = SOURCE_ROOT; };
+		444EAE0E0BD0E65B00C6D4A0 /* Effect.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Effect.h; path = ../engine/rules/include/Effect.h; sourceTree = SOURCE_ROOT; };
+		444EAE0F0BD0E65B00C6D4A0 /* EffectManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EffectManager.h; path = ../engine/rules/include/EffectManager.h; sourceTree = SOURCE_ROOT; };
+		444EAE100BD0E65B00C6D4A0 /* Eigenschaft.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Eigenschaft.h; path = ../engine/rules/include/Eigenschaft.h; sourceTree = SOURCE_ROOT; };
+		444EAE110BD0E65B00C6D4A0 /* EigenschaftenStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EigenschaftenStateSet.h; path = ../engine/rules/include/EigenschaftenStateSet.h; sourceTree = SOURCE_ROOT; };
+		444EAE120BD0E65B00C6D4A0 /* GameObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObject.h; path = ../engine/rules/include/GameObject.h; sourceTree = SOURCE_ROOT; };
+		444EAE130BD0E65B00C6D4A0 /* GameObjectManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectManager.h; path = ../engine/rules/include/GameObjectManager.h; sourceTree = SOURCE_ROOT; };
+		444EAE160BD0E65B00C6D4A0 /* GameObjectStateListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectStateListener.h; path = ../engine/rules/include/GameObjectStateListener.h; sourceTree = SOURCE_ROOT; };
+		444EAE170BD0E65B00C6D4A0 /* Inventory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Inventory.h; path = ../engine/rules/include/Inventory.h; sourceTree = SOURCE_ROOT; };
+		444EAE180BD0E65B00C6D4A0 /* Item.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Item.h; path = ../engine/rules/include/Item.h; sourceTree = SOURCE_ROOT; };
+		444EAE190BD0E65B00C6D4A0 /* JournalEntry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JournalEntry.h; path = ../engine/rules/include/JournalEntry.h; sourceTree = SOURCE_ROOT; };
+		444EAE1A0BD0E65B00C6D4A0 /* Kampftechnik.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Kampftechnik.h; path = ../engine/rules/include/Kampftechnik.h; sourceTree = SOURCE_ROOT; };
+		444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeEvent.h; path = ../engine/rules/include/ObjectStateChangeEvent.h; sourceTree = SOURCE_ROOT; };
+		444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeEventSource.h; path = ../engine/rules/include/ObjectStateChangeEventSource.h; sourceTree = SOURCE_ROOT; };
+		444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeListener.h; path = ../engine/rules/include/ObjectStateChangeListener.h; sourceTree = SOURCE_ROOT; };
+		444EAE1E0BD0E65B00C6D4A0 /* Person.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Person.h; path = ../engine/rules/include/Person.h; sourceTree = SOURCE_ROOT; };
+		444EAE1F0BD0E65B00C6D4A0 /* Quest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Quest.h; path = ../engine/rules/include/Quest.h; sourceTree = SOURCE_ROOT; };
+		444EAE200BD0E65B00C6D4A0 /* QuestBook.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestBook.h; path = ../engine/rules/include/QuestBook.h; sourceTree = SOURCE_ROOT; };
+		444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestEvent.h; path = ../engine/rules/include/QuestEvent.h; sourceTree = SOURCE_ROOT; };
+		444EAE220BD0E65B00C6D4A0 /* QuestListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestListener.h; path = ../engine/rules/include/QuestListener.h; sourceTree = SOURCE_ROOT; };
+		444EAE230BD0E65B00C6D4A0 /* RulesPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RulesPrerequisites.h; path = ../engine/rules/include/RulesPrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EAE240BD0E65B00C6D4A0 /* RulesSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RulesSubsystem.h; path = ../engine/rules/include/RulesSubsystem.h; sourceTree = SOURCE_ROOT; };
+		444EAE250BD0E65B00C6D4A0 /* Slot.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Slot.h; path = ../engine/rules/include/Slot.h; sourceTree = SOURCE_ROOT; };
+		444EAE260BD0E65B00C6D4A0 /* SonderfertigkeitenStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SonderfertigkeitenStateSet.h; path = ../engine/rules/include/SonderfertigkeitenStateSet.h; sourceTree = SOURCE_ROOT; };
+		444EAE270BD0E65B00C6D4A0 /* StateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StateSet.h; path = ../engine/rules/include/StateSet.h; sourceTree = SOURCE_ROOT; };
+		444EAE280BD0E65B00C6D4A0 /* Talent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Talent.h; path = ../engine/rules/include/Talent.h; sourceTree = SOURCE_ROOT; };
+		444EAE290BD0E65B00C6D4A0 /* Talentgruppe.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Talentgruppe.h; path = ../engine/rules/include/Talentgruppe.h; sourceTree = SOURCE_ROOT; };
+		444EAE2A0BD0E65B00C6D4A0 /* TalentInputIterator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentInputIterator.h; path = ../engine/rules/include/TalentInputIterator.h; sourceTree = SOURCE_ROOT; };
+		444EAE2B0BD0E65B00C6D4A0 /* TalentStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentStateSet.h; path = ../engine/rules/include/TalentStateSet.h; sourceTree = SOURCE_ROOT; };
+		444EAE2C0BD0E65B00C6D4A0 /* TimerEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TimerEvent.h; path = ../engine/rules/include/TimerEvent.h; sourceTree = SOURCE_ROOT; };
+		444EAE2D0BD0E65B00C6D4A0 /* TimerEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TimerEventSource.h; path = ../engine/rules/include/TimerEventSource.h; sourceTree = SOURCE_ROOT; };
+		444EAE2E0BD0E65B00C6D4A0 /* TimerListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TimerListener.h; path = ../engine/rules/include/TimerListener.h; sourceTree = SOURCE_ROOT; };
+		444EAE2F0BD0E65B00C6D4A0 /* TimerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TimerManager.h; path = ../engine/rules/include/TimerManager.h; sourceTree = SOURCE_ROOT; };
+		444EAE300BD0E65B00C6D4A0 /* Weapon.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Weapon.h; path = ../engine/rules/include/Weapon.h; sourceTree = SOURCE_ROOT; };
+		444EAE310BD0E65B00C6D4A0 /* ZauberStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZauberStateSet.h; path = ../engine/rules/include/ZauberStateSet.h; sourceTree = SOURCE_ROOT; };
+		444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptObjectMarker.h; path = ../engine/script/include/ScriptObjectMarker.h; sourceTree = SOURCE_ROOT; };
+		444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptPrerequisites.h; path = ../engine/script/include/ScriptPrerequisites.h; sourceTree = SOURCE_ROOT; };
+		444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptSubsystem.h; path = ../engine/script/include/ScriptSubsystem.h; sourceTree = SOURCE_ROOT; };
+		444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptObjectMarker.cpp; path = ../engine/script/src/ScriptObjectMarker.cpp; sourceTree = SOURCE_ROOT; };
+		444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptSubsystem.cpp; path = ../engine/script/src/ScriptSubsystem.cpp; sourceTree = SOURCE_ROOT; };
+		444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = "libxerces-c.dylib"; path = "/usr/local/lib/libxerces-c.dylib"; sourceTree = "<absolute>"; };
+		444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CEGUI.framework; path = /Library/Frameworks/CEGUI.framework; sourceTree = "<absolute>"; };
+		444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Ogre.framework; path = /Library/Frameworks/Ogre.framework; sourceTree = "<absolute>"; };
+		444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = "libboost_filesystem-1_33_1.dylib"; path = "/usr/local/lib/libboost_filesystem-1_33_1.dylib"; sourceTree = "<absolute>"; };
+		444EAECF0BD1041C00C6D4A0 /* PCRE.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = PCRE.framework; path = /Library/Frameworks/PCRE.framework; sourceTree = "<absolute>"; };
+		444EB0880BD1153500C6D4A0 /* OgreNewt.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreNewt.framework; path = /Library/Frameworks/OgreNewt.framework; sourceTree = "<absolute>"; };
+		444EB08E0BD1158700C6D4A0 /* libruby.1.8.6.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; name = libruby.1.8.6.dylib; path = /usr/local/lib/libruby.1.8.6.dylib; sourceTree = "<absolute>"; };
+		444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OpenSteer.framework; path = /Library/Frameworks/OpenSteer.framework; sourceTree = "<absolute>"; };
+		444EB3590BD174C600C6D4A0 /* libMadaBot.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libMadaBot.dylib; path = /usr/local/lib/libMadaBot.dylib; sourceTree = "<absolute>"; };
+		444EB3620BD1759500C6D4A0 /* libois.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libois.a; path = /usr/local/lib/libois.a; sourceTree = "<absolute>"; };
+		444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreCEGUIRenderer.framework; path = /Library/Frameworks/OgreCEGUIRenderer.framework; sourceTree = "<absolute>"; };
+		444EB6BC0BD1891400C6D4A0 /* RlExports.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RlExports.cpp; path = ../engine/script/swig/RlExports.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LinearSoundFadeFunctor.h; path = ../engine/core/include/LinearSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
+		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeFunctor.h; path = ../engine/core/include/SoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
+		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeJob.h; path = ../engine/core/include/SoundFadeJob.h; sourceTree = SOURCE_ROOT; };
+		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LinearSoundFadeFunctor.cpp; path = ../engine/core/src/LinearSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeFunctor.cpp; path = ../engine/core/src/SoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeJob.cpp; path = ../engine/core/src/SoundFadeJob.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4750C4532720013C214 /* CreatureController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureController.h; path = ../engine/rules/include/CreatureController.h; sourceTree = SOURCE_ROOT; };
+		446BF4760C4532720013C214 /* CreatureControllerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureControllerManager.h; path = ../engine/rules/include/CreatureControllerManager.h; sourceTree = SOURCE_ROOT; };
+		446BF4770C4532720013C214 /* EffectFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EffectFactory.h; path = ../engine/rules/include/EffectFactory.h; sourceTree = SOURCE_ROOT; };
+		446BF47B0C45329F0013C214 /* CreatureController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureController.cpp; path = ../engine/rules/src/CreatureController.cpp; sourceTree = SOURCE_ROOT; };
+		446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureControllerManager.cpp; path = ../engine/rules/src/CreatureControllerManager.cpp; sourceTree = SOURCE_ROOT; };
+		446BF47D0C45329F0013C214 /* EffectFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EffectFactory.cpp; path = ../engine/rules/src/EffectFactory.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4810C4532B50013C214 /* UnifiedFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = UnifiedFactory.h; path = ../engine/script/include/UnifiedFactory.h; sourceTree = SOURCE_ROOT; };
+		446BF4840C45335A0013C214 /* ControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ControlState.h; path = ../engine/ui/include/ControlState.h; sourceTree = SOURCE_ROOT; };
+		446BF4850C45335A0013C214 /* CutsceneControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CutsceneControlState.h; path = ../engine/ui/include/CutsceneControlState.h; sourceTree = SOURCE_ROOT; };
+		446BF4860C45335A0013C214 /* DialogControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogControlState.h; path = ../engine/ui/include/DialogControlState.h; sourceTree = SOURCE_ROOT; };
+		446BF4870C45335A0013C214 /* FreeflightControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FreeflightControlState.h; path = ../engine/ui/include/FreeflightControlState.h; sourceTree = SOURCE_ROOT; };
+		446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ItemDescriptionDragContainer.h; path = ../engine/ui/include/ItemDescriptionDragContainer.h; sourceTree = SOURCE_ROOT; };
+		446BF4890C45335A0013C214 /* ItemIconDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ItemIconDragContainer.h; path = ../engine/ui/include/ItemIconDragContainer.h; sourceTree = SOURCE_ROOT; };
+		446BF48A0C45335A0013C214 /* MovementControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MovementControlState.h; path = ../engine/ui/include/MovementControlState.h; sourceTree = SOURCE_ROOT; };
+		446BF48B0C45335A0013C214 /* PropertiesWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PropertiesWindow.h; path = ../engine/ui/include/PropertiesWindow.h; sourceTree = SOURCE_ROOT; };
+		446BF4940C4533BD0013C214 /* CombatControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatControlState.cpp; path = ../engine/ui/src/CombatControlState.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4950C4533BD0013C214 /* CombatWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatWindow.cpp; path = ../engine/ui/src/CombatWindow.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4960C4533BD0013C214 /* ControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ControlState.cpp; path = ../engine/ui/src/ControlState.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CutsceneControlState.cpp; path = ../engine/ui/src/CutsceneControlState.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4980C4533BD0013C214 /* DialogControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogControlState.cpp; path = ../engine/ui/src/DialogControlState.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FreeflightControlState.cpp; path = ../engine/ui/src/FreeflightControlState.cpp; sourceTree = SOURCE_ROOT; };
+		446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ItemIconDragContainer.cpp; path = ../engine/ui/src/ItemIconDragContainer.cpp; sourceTree = SOURCE_ROOT; };
+		446BF49B0C4533BD0013C214 /* MovementControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MovementControlState.cpp; path = ../engine/ui/src/MovementControlState.cpp; sourceTree = SOURCE_ROOT; };
+		446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PropertiesWindow.cpp; path = ../engine/ui/src/PropertiesWindow.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4D00C453B9E0013C214 /* CombatControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatControlState.h; path = ../engine/ui/include/CombatControlState.h; sourceTree = SOURCE_ROOT; };
+		446BF4D10C453B9E0013C214 /* CombatWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatWindow.h; path = ../engine/ui/include/CombatWindow.h; sourceTree = SOURCE_ROOT; };
+		446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ItemDescriptionDragContainer.cpp; path = ../engine/ui/src/ItemDescriptionDragContainer.cpp; sourceTree = SOURCE_ROOT; };
+		44D814590BF7B52600534175 /* GameObjectConstants.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectConstants.h; path = ../engine/rules/include/GameObjectConstants.h; sourceTree = SOURCE_ROOT; };
+		44D8145A0BF7B52600534175 /* SelectionHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SelectionHelper.h; path = ../engine/rules/include/SelectionHelper.h; sourceTree = SOURCE_ROOT; };
+		44D8145B0BF7B52600534175 /* Selector.h */ = {isa = PBXFileReference; explicitFileType = sourcecode.c.h; fileEncoding = 4; name = Selector.h; path = ../engine/rules/include/Selector.h; sourceTree = SOURCE_ROOT; };
+		44D8145F0BF7B58A00534175 /* ProgressWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ProgressWindow.h; path = ../engine/ui/include/ProgressWindow.h; sourceTree = SOURCE_ROOT; };
+		44D814600BF7B58A00534175 /* SaveLoadWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveLoadWindow.h; path = ../engine/ui/include/SaveLoadWindow.h; sourceTree = SOURCE_ROOT; };
+		44D814630BF7B5AD00534175 /* ProgressWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ProgressWindow.cpp; path = ../engine/ui/src/ProgressWindow.cpp; sourceTree = SOURCE_ROOT; };
+		44D814640BF7B5AD00534175 /* SaveLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveLoadWindow.cpp; path = ../engine/ui/src/SaveLoadWindow.cpp; sourceTree = SOURCE_ROOT; };
+		44D814670BF7B5C700534175 /* Landmark.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Landmark.cpp; path = ../engine/ai/src/Landmark.cpp; sourceTree = SOURCE_ROOT; };
+		44D814680BF7B5C700534175 /* LandmarkPath.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LandmarkPath.cpp; path = ../engine/ai/src/LandmarkPath.cpp; sourceTree = SOURCE_ROOT; };
+		44D8146B0BF7B5E800534175 /* Landmark.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Landmark.h; path = ../engine/ai/include/Landmark.h; sourceTree = SOURCE_ROOT; };
+		44D8146C0BF7B5E800534175 /* LandmarkPath.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LandmarkPath.h; path = ../engine/ai/include/LandmarkPath.h; sourceTree = SOURCE_ROOT; };
+		44D8146F0BF7B61500534175 /* Zone.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Zone.cpp; path = ../engine/core/src/Zone.cpp; sourceTree = SOURCE_ROOT; };
+		44D814700BF7B61500534175 /* ZoneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ZoneManager.cpp; path = ../engine/core/src/ZoneManager.cpp; sourceTree = SOURCE_ROOT; };
+		44D814730BF7B62F00534175 /* CoreDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreDefines.h; path = ../engine/core/include/CoreDefines.h; sourceTree = SOURCE_ROOT; };
+		44D814740BF7B62F00534175 /* LightFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LightFadeJob.h; path = ../engine/core/include/LightFadeJob.h; sourceTree = SOURCE_ROOT; };
+		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Trigger.h; path = ../engine/core/include/Trigger.h; sourceTree = SOURCE_ROOT; };
+		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Zone.h; path = ../engine/core/include/Zone.h; sourceTree = SOURCE_ROOT; };
+		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneManager.h; path = ../engine/core/include/ZoneManager.h; sourceTree = SOURCE_ROOT; };
+		8D0C4E960486CD37000505A6 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
+		8D0C4E970486CD37000505A6 /* Rastullah.app */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = wrapper.application; path = Rastullah.app; sourceTree = BUILT_PRODUCTS_DIR; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		4407860F0C09D602006E496D /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4407880E0C09D74C006E496D /* libxerces-c.dylib in Frameworks */,
+				440787E10C09D688006E496D /* OgreCEGUIRenderer.framework in Frameworks */,
+				440787E20C09D688006E496D /* CEGUI.framework in Frameworks */,
+				440787E30C09D688006E496D /* OpenSteer.framework in Frameworks */,
+				440787E40C09D688006E496D /* PCRE.framework in Frameworks */,
+				440787E50C09D688006E496D /* libRlDialog.dylib in Frameworks */,
+				440787E60C09D688006E496D /* libRlAi.dylib in Frameworks */,
+				440787E70C09D688006E496D /* libRlRules.dylib in Frameworks */,
+				440787E80C09D688006E496D /* libRlUi.dylib in Frameworks */,
+				440787E90C09D688006E496D /* OgreNewt.framework in Frameworks */,
+				440787EA0C09D688006E496D /* libRlCore.dylib in Frameworks */,
+				440787EB0C09D688006E496D /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				440787EC0C09D688006E496D /* Ogre.framework in Frameworks */,
+				440787ED0C09D688006E496D /* libRlCommon.dylib in Frameworks */,
+				440787EE0C09D688006E496D /* libruby.1.8.6.dylib in Frameworks */,
+				4407880D0C09D743006E496D /* libmeshmagick.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAAB00BD0E0FB00C6D4A0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAEBA0BD0F06700C6D4A0 /* libxerces-c.dylib in Frameworks */,
+				444EAEBF0BD0F09900C6D4A0 /* CEGUI.framework in Frameworks */,
+				444EAEC00BD0F09900C6D4A0 /* Ogre.framework in Frameworks */,
+				444EAEC80BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				444EAED00BD1041C00C6D4A0 /* PCRE.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAB5F0BD0E2DA00C6D4A0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EB0AB0BD115CB00C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				444EAEF30BD1150500C6D4A0 /* CEGUI.framework in Frameworks */,
+				444EAEF40BD1150500C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				444EAEF50BD1150500C6D4A0 /* libxerces-c.dylib in Frameworks */,
+				444EAEF60BD1150500C6D4A0 /* Ogre.framework in Frameworks */,
+				444EAEF70BD1150500C6D4A0 /* PCRE.framework in Frameworks */,
+				444EB0890BD1153500C6D4A0 /* OgreNewt.framework in Frameworks */,
+				444EB08F0BD1158700C6D4A0 /* libruby.1.8.6.dylib in Frameworks */,
+				440785DE0C09D231006E496D /* libmeshmagick.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC250BD0E3FF00C6D4A0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				440785EF0C09D3A8006E496D /* libmeshmagick.dylib in Frameworks */,
+				444EB34A0BD173A900C6D4A0 /* libRlRules.dylib in Frameworks */,
+				444EB12D0BD11A0C00C6D4A0 /* libRlCore.dylib in Frameworks */,
+				444EB1290BD119FB00C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				444EB1250BD119E300C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				444EB0D40BD1198B00C6D4A0 /* CEGUI.framework in Frameworks */,
+				444EB0D50BD1198B00C6D4A0 /* libxerces-c.dylib in Frameworks */,
+				444EB0D60BD1198B00C6D4A0 /* Ogre.framework in Frameworks */,
+				444EB0D70BD1198B00C6D4A0 /* PCRE.framework in Frameworks */,
+				444EB0D80BD1198B00C6D4A0 /* OgreNewt.framework in Frameworks */,
+				444EB0DB0BD119BB00C6D4A0 /* OpenSteer.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC2D0BD0E42A00C6D4A0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				440785F10C09D3D5006E496D /* libmeshmagick.dylib in Frameworks */,
+				444EB3570BD174A100C6D4A0 /* libRlRules.dylib in Frameworks */,
+				444EB34E0BD1746600C6D4A0 /* CEGUI.framework in Frameworks */,
+				444EB34F0BD1746600C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				444EB3500BD1746600C6D4A0 /* libxerces-c.dylib in Frameworks */,
+				444EB3510BD1746600C6D4A0 /* Ogre.framework in Frameworks */,
+				444EB3520BD1746600C6D4A0 /* OgreNewt.framework in Frameworks */,
+				444EB3530BD1746600C6D4A0 /* PCRE.framework in Frameworks */,
+				444EB34C0BD1744F00C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				444EB34D0BD1744F00C6D4A0 /* libRlCore.dylib in Frameworks */,
+				444EB35A0BD174C600C6D4A0 /* libMadaBot.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC350BD0E44900C6D4A0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				440785EB0C09D377006E496D /* libmeshmagick.dylib in Frameworks */,
+				444EB3470BD1733900C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				444EB3480BD1733900C6D4A0 /* OgreNewt.framework in Frameworks */,
+				444EB3440BD1730C00C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				444EB3450BD1730C00C6D4A0 /* libRlCore.dylib in Frameworks */,
+				444EB3430BD172FA00C6D4A0 /* libxerces-c.dylib in Frameworks */,
+				444EB3400BD172BA00C6D4A0 /* PCRE.framework in Frameworks */,
+				444EB3410BD172BA00C6D4A0 /* CEGUI.framework in Frameworks */,
+				444EB3420BD172BA00C6D4A0 /* Ogre.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC3C0BD0E46000C6D4A0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				440785F30C09D42B006E496D /* libmeshmagick.dylib in Frameworks */,
+				444EB3610BD1756B00C6D4A0 /* libRlRules.dylib in Frameworks */,
+				444EB35E0BD1754900C6D4A0 /* libRlDialog.dylib in Frameworks */,
+				444EB1D60BD1598F00C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				444EB1CE0BD1595100C6D4A0 /* OgreNewt.framework in Frameworks */,
+				444EB1CA0BD137FB00C6D4A0 /* libRlCore.dylib in Frameworks */,
+				444EB1C50BD1370600C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				444EB1C40BD136FA00C6D4A0 /* PCRE.framework in Frameworks */,
+				444EB1C10BD136F200C6D4A0 /* CEGUI.framework in Frameworks */,
+				444EB1C20BD136F200C6D4A0 /* libxerces-c.dylib in Frameworks */,
+				444EB1C30BD136F200C6D4A0 /* Ogre.framework in Frameworks */,
+				444EB3630BD1759500C6D4A0 /* libois.a in Frameworks */,
+				444EB3730BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		8D0C4E910486CD37000505A6 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EB7A20BD1963A00C6D4A0 /* CEGUI.framework in Frameworks */,
+				444EB7A30BD1963A00C6D4A0 /* libboost_filesystem-1_33_1.dylib in Frameworks */,
+				444EB7A40BD1963A00C6D4A0 /* libMadaBot.dylib in Frameworks */,
+				444EB7A50BD1963A00C6D4A0 /* libois.a in Frameworks */,
+				444EB7A60BD1963A00C6D4A0 /* libruby.1.8.6.dylib in Frameworks */,
+				444EB7A70BD1963A00C6D4A0 /* libxerces-c.dylib in Frameworks */,
+				444EB7A80BD1963A00C6D4A0 /* Ogre.framework in Frameworks */,
+				444EB7A90BD1963A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */,
+				444EB7AA0BD1963A00C6D4A0 /* OgreNewt.framework in Frameworks */,
+				444EB7AB0BD1963A00C6D4A0 /* OpenSteer.framework in Frameworks */,
+				444EB7AC0BD1963A00C6D4A0 /* PCRE.framework in Frameworks */,
+				444EB79A0BD195E800C6D4A0 /* libRlAi.dylib in Frameworks */,
+				444EB79B0BD195E800C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				444EB79C0BD195E800C6D4A0 /* libRlCore.dylib in Frameworks */,
+				444EB79D0BD195E800C6D4A0 /* libRlDialog.dylib in Frameworks */,
+				444EB79E0BD195E800C6D4A0 /* libRlRules.dylib in Frameworks */,
+				444EB7A00BD195E800C6D4A0 /* libRlUi.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		195DF8CFFE9D517E11CA2CBB /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				8D0C4E970486CD37000505A6 /* Rastullah.app */,
+				444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */,
+				444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */,
+				444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */,
+				444EAC2F0BD0E42A00C6D4A0 /* libRlDialog.dylib */,
+				444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */,
+				444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */,
+				440786110C09D602006E496D /* libRlScript.bundle */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		20286C29FDCF999611CA2CEA /* Rastullah */ = {
+			isa = PBXGroup;
+			children = (
+				20286C2AFDCF999611CA2CEA /* Sources */,
+				20286C2CFDCF999611CA2CEA /* Resources */,
+				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
+				195DF8CFFE9D517E11CA2CBB /* Products */,
+			);
+			name = Rastullah;
+			sourceTree = "<group>";
+		};
+		20286C2AFDCF999611CA2CEA /* Sources */ = {
+			isa = PBXGroup;
+			children = (
+				444EAC220BD0E3E000C6D4A0 /* RlAi */,
+				444EAB1F0BD0E25C00C6D4A0 /* RlCommon */,
+				444EAB200BD0E27400C6D4A0 /* RlCore */,
+				444EAC580BD0E4F900C6D4A0 /* RlDialog */,
+				444EAC590BD0E50600C6D4A0 /* RlRules */,
+				444EAE600BD0E66500C6D4A0 /* RlScript */,
+				444EAC570BD0E4CD00C6D4A0 /* RlUi */,
+				444EAAAC0BD0E0C700C6D4A0 /* RastullahMain.cpp */,
+			);
+			name = Sources;
+			sourceTree = "<group>";
+		};
+		20286C2CFDCF999611CA2CEA /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				440786120C09D602006E496D /* RlScript-Info.plist */,
+				8D0C4E960486CD37000505A6 /* Info.plist */,
+				0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */,
+				02345980000FD03B11CA0E72 /* main.nib */,
+			);
+			name = Resources;
+			sourceTree = "<group>";
+		};
+		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
+			isa = PBXGroup;
+			children = (
+				440785DD0C09D231006E496D /* libmeshmagick.dylib */,
+				444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */,
+				444EB3620BD1759500C6D4A0 /* libois.a */,
+				444EB3590BD174C600C6D4A0 /* libMadaBot.dylib */,
+				444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */,
+				444EAECF0BD1041C00C6D4A0 /* PCRE.framework */,
+				444EAEC70BD0F16000C6D4A0 /* libboost_filesystem-1_33_1.dylib */,
+				444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */,
+				444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */,
+				444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */,
+				444EB08E0BD1158700C6D4A0 /* libruby.1.8.6.dylib */,
+				444EB0880BD1153500C6D4A0 /* OgreNewt.framework */,
+			);
+			name = "External Frameworks and Libraries";
+			sourceTree = "<group>";
+		};
+		444EAB1F0BD0E25C00C6D4A0 /* RlCommon */ = {
+			isa = PBXGroup;
+			children = (
+				4404DA7C0C48CFB3007B4657 /* stdinc.h */,
+				444EAAD40BD0E1EF00C6D4A0 /* CommonPrerequisites.h */,
+				444EAAB60BD0E17000C6D4A0 /* ConfigFile.cpp */,
+				444EAAD50BD0E1EF00C6D4A0 /* ConfigFile.h */,
+				444EAAD60BD0E1EF00C6D4A0 /* EventCaster.h */,
+				444EAAD70BD0E1EF00C6D4A0 /* EventListener.h */,
+				444EAAB70BD0E17000C6D4A0 /* EventObject.cpp */,
+				444EAAD80BD0E1EF00C6D4A0 /* EventObject.h */,
+				444EAAB80BD0E17000C6D4A0 /* EventSource.cpp */,
+				444EAAD90BD0E1EF00C6D4A0 /* EventSource.h */,
+				444EAADA0BD0E1EF00C6D4A0 /* Exception.h */,
+				444EAADB0BD0E1EF00C6D4A0 /* FixRubyHeaders.h */,
+				444EAAB90BD0E17000C6D4A0 /* GameTask.cpp */,
+				444EAADC0BD0E1EF00C6D4A0 /* GameTask.h */,
+				444EAABA0BD0E17000C6D4A0 /* Logger.cpp */,
+				444EAADD0BD0E1EF00C6D4A0 /* Logger.h */,
+				444EAAC00BD0E18800C6D4A0 /* MathUtil.cpp */,
+				444EAADE0BD0E1EF00C6D4A0 /* MathUtil.h */,
+				444EAAC10BD0E18800C6D4A0 /* OgreXercesInput.cpp */,
+				444EAADF0BD0E1EF00C6D4A0 /* OgreXercesInput.h */,
+				444EAAC20BD0E18800C6D4A0 /* Properties.cpp */,
+				444EAAE00BD0E1EF00C6D4A0 /* Properties.h */,
+				444EAAC30BD0E18800C6D4A0 /* Property.cpp */,
+				444EAAE10BD0E1EF00C6D4A0 /* Property.h */,
+				444EAAC40BD0E18800C6D4A0 /* PropertyReader.cpp */,
+				444EAAE20BD0E1EF00C6D4A0 /* PropertyReader.h */,
+				444EAAE30BD0E1EF00C6D4A0 /* RastullahPrerequisites.h */,
+				444EAAC50BD0E18800C6D4A0 /* ScriptWrapper.cpp */,
+				444EAAE40BD0E1EF00C6D4A0 /* ScriptWrapper.h */,
+				444EAAE50BD0E1EF00C6D4A0 /* Sleep.h */,
+				444EAAE60BD0E1EF00C6D4A0 /* Tripel.h */,
+				444EAAC60BD0E18800C6D4A0 /* XmlErrorHandler.cpp */,
+				444EAAE70BD0E1EF00C6D4A0 /* XmlErrorHandler.h */,
+				444EAAC70BD0E18800C6D4A0 /* XmlHelper.cpp */,
+				444EAAE80BD0E1EF00C6D4A0 /* XmlHelper.h */,
+				444EAAC80BD0E18800C6D4A0 /* XmlResource.cpp */,
+				444EAAE90BD0E1EF00C6D4A0 /* XmlResource.h */,
+				444EAAC90BD0E18800C6D4A0 /* XmlResourceManager.cpp */,
+				444EAAEA0BD0E1EF00C6D4A0 /* XmlResourceManager.h */,
+			);
+			name = RlCommon;
+			sourceTree = "<group>";
+		};
+		444EAB200BD0E27400C6D4A0 /* RlCore */ = {
+			isa = PBXGroup;
+			children = (
+				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
+				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
+				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
+				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
+				446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */,
+				446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */,
+				446BF46B0C4531FA0013C214 /* SoundFadeJob.h */,
+				440785E60C09D2DF006E496D /* MergeableMeshObject.h */,
+				440785E20C09D2C1006E496D /* LightFadeJob.cpp */,
+				440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */,
+				44D814730BF7B62F00534175 /* CoreDefines.h */,
+				44D814740BF7B62F00534175 /* LightFadeJob.h */,
+				44D814750BF7B62F00534175 /* Trigger.h */,
+				44D814760BF7B62F00534175 /* Zone.h */,
+				44D814770BF7B62F00534175 /* ZoneManager.h */,
+				44D8146F0BF7B61500534175 /* Zone.cpp */,
+				44D814700BF7B61500534175 /* ZoneManager.cpp */,
+				444EAB9D0BD0E33300C6D4A0 /* Actor.h */,
+				444EAB9E0BD0E33300C6D4A0 /* ActorControlledObject.h */,
+				444EAB9F0BD0E33300C6D4A0 /* ActorManager.h */,
+				444EABA00BD0E33300C6D4A0 /* AnimationListener.h */,
+				444EABA10BD0E33300C6D4A0 /* AnimationManager.h */,
+				444EABA20BD0E33300C6D4A0 /* BaseAnimation.h */,
+				444EABA30BD0E33300C6D4A0 /* BoxPrimitive.h */,
+				444EABA40BD0E33300C6D4A0 /* CameraObject.h */,
+				444EABA50BD0E33300C6D4A0 /* ConfigurationManager.h */,
+				444EABA60BD0E33300C6D4A0 /* ContentModule.h */,
+				444EABA70BD0E33300C6D4A0 /* CoreEvents.h */,
+				444EABA80BD0E33300C6D4A0 /* CorePrerequisites.h */,
+				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
+				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
+				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
+				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
+				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
+				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
+				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
+				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
+				444EABB10BD0E33300C6D4A0 /* GameAreaListener.h */,
+				444EABB20BD0E33300C6D4A0 /* GameAreaTypes.h */,
+				444EABB30BD0E33300C6D4A0 /* GameEventManager.h */,
+				444EABB40BD0E33300C6D4A0 /* GameLoop.h */,
+				444EABB50BD0E33300C6D4A0 /* Job.h */,
+				444EABB60BD0E33300C6D4A0 /* JobListener.h */,
+				444EABB70BD0E33300C6D4A0 /* JobScheduler.h */,
+				444EABB80BD0E33300C6D4A0 /* LightObject.h */,
+				444EABBA0BD0E33300C6D4A0 /* LineSetPrimitive.h */,
+				444EABBB0BD0E33300C6D4A0 /* ListenerMovable.h */,
+				444EABBC0BD0E33300C6D4A0 /* ListenerObject.h */,
+				444EABBD0BD0E33300C6D4A0 /* MeshAnimation.h */,
+				444EABBE0BD0E33300C6D4A0 /* MeshObject.h */,
+				444EABBF0BD0E33300C6D4A0 /* MovableText.h */,
+				444EABC50BD0E33300C6D4A0 /* NullDriver.h */,
+				444EABC60BD0E33300C6D4A0 /* NullListener.h */,
+				444EABC70BD0E33300C6D4A0 /* NullSound.h */,
+				444EABC80BD0E33300C6D4A0 /* ParticleSystemObject.h */,
+				444EABC90BD0E33300C6D4A0 /* PhysicalObject.h */,
+				444EABCA0BD0E33300C6D4A0 /* PhysicalThing.h */,
+				444EABCB0BD0E33300C6D4A0 /* PhysicsContactListener.h */,
+				444EABCC0BD0E33300C6D4A0 /* PhysicsController.h */,
+				444EABCD0BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h */,
+				444EABCE0BD0E33300C6D4A0 /* PhysicsManager.h */,
+				444EABCF0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h */,
+				444EABD00BD0E33300C6D4A0 /* PlayAnimationJob.h */,
+				444EABD10BD0E33300C6D4A0 /* PlaySoundJob.h */,
+				444EABD20BD0E33300C6D4A0 /* PrimitiveObject.h */,
+				444EABD30BD0E33300C6D4A0 /* QuadTree.h */,
+				444EABD40BD0E33300C6D4A0 /* RubyInterpreter.h */,
+				444EABD50BD0E33300C6D4A0 /* SceneQuery.h */,
+				444EABD60BD0E33300C6D4A0 /* Sound.h */,
+				444EABD70BD0E33300C6D4A0 /* SoundDriver.h */,
+				444EABD80BD0E33300C6D4A0 /* SoundEvents.h */,
+				444EABD90BD0E33300C6D4A0 /* SoundManager.h */,
+				444EABDA0BD0E33300C6D4A0 /* SoundObject.h */,
+				444EABDB0BD0E33300C6D4A0 /* SoundResource.h */,
+				444EABDC0BD0E33300C6D4A0 /* TrackAnimation.h */,
+				444EABDD0BD0E33300C6D4A0 /* World.h */,
+				444EAB210BD0E2B600C6D4A0 /* Actor.cpp */,
+				444EAB220BD0E2B600C6D4A0 /* ActorControlledObject.cpp */,
+				444EAB230BD0E2B600C6D4A0 /* ActorManager.cpp */,
+				444EAB240BD0E2B600C6D4A0 /* AnimationListener.cpp */,
+				444EAB250BD0E2B600C6D4A0 /* AnimationManager.cpp */,
+				444EAB260BD0E2B600C6D4A0 /* BaseAnimation.cpp */,
+				444EAB270BD0E2B600C6D4A0 /* BoxPrimitive.cpp */,
+				444EAB280BD0E2B600C6D4A0 /* CameraObject.cpp */,
+				444EAB290BD0E2B600C6D4A0 /* ConfigurationManager.cpp */,
+				444EAB2A0BD0E2B600C6D4A0 /* ContentModule.cpp */,
+				444EAB2B0BD0E2B600C6D4A0 /* CoreEvents.cpp */,
+				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
+				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
+				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
+				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
+				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
+				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
+				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
+				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
+				444EAB340BD0E2B600C6D4A0 /* GameAreaListener.cpp */,
+				444EAB350BD0E2B600C6D4A0 /* GameAreaTypes.cpp */,
+				444EAB360BD0E2B600C6D4A0 /* GameEventManager.cpp */,
+				444EAB370BD0E2B600C6D4A0 /* GameLoop.cpp */,
+				444EAB380BD0E2B600C6D4A0 /* Job.cpp */,
+				444EAB390BD0E2B600C6D4A0 /* JobScheduler.cpp */,
+				444EAB3A0BD0E2B600C6D4A0 /* LightObject.cpp */,
+				444EAB3C0BD0E2B600C6D4A0 /* LineSetPrimitive.cpp */,
+				444EAB3D0BD0E2B600C6D4A0 /* ListenerMovable.cpp */,
+				444EAB3E0BD0E2B600C6D4A0 /* ListenerObject.cpp */,
+				444EAB3F0BD0E2B600C6D4A0 /* MeshAnimation.cpp */,
+				444EAB400BD0E2B600C6D4A0 /* MeshObject.cpp */,
+				444EAB410BD0E2B600C6D4A0 /* MovableText.cpp */,
+				444EAB420BD0E2B600C6D4A0 /* nulldriver */,
+				444EAB470BD0E2B600C6D4A0 /* NullDriver.cpp */,
+				444EAB480BD0E2B600C6D4A0 /* NullListener.cpp */,
+				444EAB490BD0E2B600C6D4A0 /* NullSound.cpp */,
+				444EAB4A0BD0E2B600C6D4A0 /* ParticleSystemObject.cpp */,
+				444EAB4B0BD0E2B600C6D4A0 /* PhysicalThing.cpp */,
+				444EAB4C0BD0E2B600C6D4A0 /* PhysicsContactListener.cpp */,
+				444EAB4D0BD0E2B600C6D4A0 /* PhysicsGenericContactCallback.cpp */,
+				444EAB4E0BD0E2B600C6D4A0 /* PhysicsManager.cpp */,
+				444EAB4F0BD0E2B600C6D4A0 /* PhysicsMaterialRaycast.cpp */,
+				444EAB500BD0E2B600C6D4A0 /* PlayAnimationJob.cpp */,
+				444EAB510BD0E2B600C6D4A0 /* PlaySoundJob.cpp */,
+				444EAB520BD0E2B600C6D4A0 /* PrimitiveObject.cpp */,
+				444EAB530BD0E2B600C6D4A0 /* RubyInterpreter.cpp */,
+				444EAB540BD0E2B600C6D4A0 /* SceneQuery.cpp */,
+				444EAB550BD0E2B600C6D4A0 /* Sound.cpp */,
+				444EAB560BD0E2B600C6D4A0 /* SoundDriver.cpp */,
+				444EAB570BD0E2B600C6D4A0 /* SoundEvents.cpp */,
+				444EAB580BD0E2B600C6D4A0 /* SoundManager.cpp */,
+				444EAB590BD0E2B600C6D4A0 /* SoundObject.cpp */,
+				444EAB5A0BD0E2B600C6D4A0 /* SoundResource.cpp */,
+				444EAB5B0BD0E2B600C6D4A0 /* TrackAnimation.cpp */,
+				444EAB5C0BD0E2B600C6D4A0 /* World.cpp */,
+			);
+			name = RlCore;
+			sourceTree = "<group>";
+		};
+		444EAC220BD0E3E000C6D4A0 /* RlAi */ = {
+			isa = PBXGroup;
+			children = (
+				4404DA6E0C48CEE2007B4657 /* stdinc.h */,
+				44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */,
+				44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */,
+				44D8146B0BF7B5E800534175 /* Landmark.h */,
+				44D8146C0BF7B5E800534175 /* LandmarkPath.h */,
+				44D814670BF7B5C700534175 /* Landmark.cpp */,
+				44D814680BF7B5C700534175 /* LandmarkPath.cpp */,
+				444EAC7C0BD0E54000C6D4A0 /* Agent.h */,
+				444EAC7D0BD0E54000C6D4A0 /* AgentManager.h */,
+				444EAC7E0BD0E54000C6D4A0 /* AiPrerequisites.h */,
+				444EAC7F0BD0E54000C6D4A0 /* AiSubsystem.h */,
+				444EAC800BD0E54000C6D4A0 /* AiWorld.h */,
+				444EAC810BD0E54000C6D4A0 /* AStar.h */,
+				444EAC820BD0E54000C6D4A0 /* AStarCosts.h */,
+				444EAC830BD0E54000C6D4A0 /* AStarHeuristic.h */,
+				444EAC840BD0E54000C6D4A0 /* AStarNodePool.h */,
+				444EAC850BD0E54000C6D4A0 /* AStarWayPointNode.h */,
+				444EAC860BD0E54100C6D4A0 /* FuzzyState.h */,
+				444EAC870BD0E54100C6D4A0 /* FuzzyStateMachine.h */,
+				444EAC880BD0E54100C6D4A0 /* PhysicalObstacle.h */,
+				444EAC890BD0E54100C6D4A0 /* PlayerVehicle.h */,
+				444EAC8A0BD0E54100C6D4A0 /* SteeringMachine.h */,
+				444EAC8B0BD0E54100C6D4A0 /* SteeringVehicle.h */,
+				444EAC8C0BD0E54100C6D4A0 /* WayPointGraph.h */,
+				444EAC8D0BD0E54100C6D4A0 /* WayPointGraphManager.h */,
+				444EAC8E0BD0E54100C6D4A0 /* WayPointNode.h */,
+				444EAC5A0BD0E52E00C6D4A0 /* Agent.cpp */,
+				444EAC5B0BD0E52E00C6D4A0 /* AgentManager.cpp */,
+				444EAC5C0BD0E52E00C6D4A0 /* AiSubsystem.cpp */,
+				444EAC5D0BD0E52E00C6D4A0 /* AiWorld.cpp */,
+				444EAC5E0BD0E52E00C6D4A0 /* AStar.cpp */,
+				444EAC5F0BD0E52E00C6D4A0 /* AStarCosts.cpp */,
+				444EAC600BD0E52E00C6D4A0 /* AStarHeuristic.cpp */,
+				444EAC610BD0E52E00C6D4A0 /* AStarNodePool.cpp */,
+				444EAC620BD0E52E00C6D4A0 /* AStarWayPointNode.cpp */,
+				444EAC630BD0E52E00C6D4A0 /* FuzzyState.cpp */,
+				444EAC640BD0E52E00C6D4A0 /* FuzzyStateMachine.cpp */,
+				444EAC650BD0E52E00C6D4A0 /* PhysicalObstacle.cpp */,
+				444EAC660BD0E52E00C6D4A0 /* PlayerVehicle.cpp */,
+				444EAC670BD0E52E00C6D4A0 /* SteeringVehicle.cpp */,
+				444EAC680BD0E52E00C6D4A0 /* WayPointGraph.cpp */,
+				444EAC690BD0E52E00C6D4A0 /* WayPointGraphManager.cpp */,
+				444EAC6A0BD0E52E00C6D4A0 /* WayPointNode.cpp */,
+			);
+			name = RlAi;
+			sourceTree = "<group>";
+		};
+		444EAC570BD0E4CD00C6D4A0 /* RlUi */ = {
+			isa = PBXGroup;
+			children = (
+				4404DA850C48D037007B4657 /* stdinc.h */,
+				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
+				446BF4D00C453B9E0013C214 /* CombatControlState.h */,
+				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
+				446BF4940C4533BD0013C214 /* CombatControlState.cpp */,
+				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
+				446BF4960C4533BD0013C214 /* ControlState.cpp */,
+				446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */,
+				446BF4980C4533BD0013C214 /* DialogControlState.cpp */,
+				446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */,
+				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
+				446BF49B0C4533BD0013C214 /* MovementControlState.cpp */,
+				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
+				446BF4840C45335A0013C214 /* ControlState.h */,
+				446BF4850C45335A0013C214 /* CutsceneControlState.h */,
+				446BF4860C45335A0013C214 /* DialogControlState.h */,
+				446BF4870C45335A0013C214 /* FreeflightControlState.h */,
+				446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */,
+				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
+				446BF48A0C45335A0013C214 /* MovementControlState.h */,
+				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
+				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
+				44D814640BF7B5AD00534175 /* SaveLoadWindow.cpp */,
+				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
+				44D814600BF7B58A00534175 /* SaveLoadWindow.h */,
+				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
+				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
+				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
+				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
+				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
+				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
+				444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */,
+				444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */,
+				444EAD0A0BD0E58C00C6D4A0 /* Console.h */,
+				444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */,
+				444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */,
+				444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */,
+				444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */,
+				444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */,
+				444EAD150BD0E58C00C6D4A0 /* GameSettings.h */,
+				444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */,
+				444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */,
+				444EAD180BD0E58C00C6D4A0 /* InputManager.h */,
+				444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */,
+				444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */,
+				444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */,
+				444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */,
+				444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */,
+				444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */,
+				444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */,
+				444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */,
+				444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */,
+				444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */,
+				444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */,
+				444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */,
+				444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */,
+				444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */,
+				444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */,
+				444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */,
+				444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */,
+				444EAD2C0BD0E58C00C6D4A0 /* WindowFadeJob.h */,
+				444EAD2D0BD0E58C00C6D4A0 /* WindowManager.h */,
+				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
+				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
+				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
+				444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */,
+				444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */,
+				444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */,
+				444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */,
+				444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */,
+				444EACAD0BD0E57100C6D4A0 /* Console.cpp */,
+				444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */,
+				444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */,
+				444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */,
+				444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */,
+				444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */,
+				444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */,
+				444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */,
+				444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */,
+				444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */,
+				444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */,
+				444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */,
+				444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */,
+				444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */,
+				444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */,
+				444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */,
+				444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */,
+				444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */,
+				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
+				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
+				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
+				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
+				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
+				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
+				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
+				444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */,
+				444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */,
+			);
+			name = RlUi;
+			sourceTree = "<group>";
+		};
+		444EAC580BD0E4F900C6D4A0 /* RlDialog */ = {
+			isa = PBXGroup;
+			children = (
+				4404DA800C48CFDE007B4657 /* stdinc.h */,
+				444EAD9C0BD0E61400C6D4A0 /* CreaturePredicates.h */,
+				444EAD9D0BD0E61400C6D4A0 /* EigenschaftsProbePredicates.h */,
+				444EAD9E0BD0E61400C6D4A0 /* EigenschaftsWertPredicates.h */,
+				444EAD9F0BD0E61400C6D4A0 /* GrundWertPredicates.h */,
+				444EADA00BD0E61400C6D4A0 /* QuestKnownPredicates.h */,
+				444EADA10BD0E61400C6D4A0 /* QuestPartsPredicates.h */,
+				444EADA20BD0E61400C6D4A0 /* QuestStatePredicates.h */,
+				444EADA30BD0E61400C6D4A0 /* ScriptPredicates.h */,
+				444EADA40BD0E61400C6D4A0 /* TalentProbePredicates.h */,
+				444EADA50BD0E61400C6D4A0 /* TalentWertPredicates.h */,
+				444EAD860BD0E60000C6D4A0 /* AimlNodeImplRl.h */,
+				444EAD870BD0E60000C6D4A0 /* AimlParserImplRl.h */,
+				444EAD880BD0E60000C6D4A0 /* ContextConditionProcessor.h */,
+				444EAD890BD0E60000C6D4A0 /* ContextInterpreter.h */,
+				444EAD8A0BD0E60000C6D4A0 /* DialogCharacter.h */,
+				444EAD8B0BD0E60000C6D4A0 /* DialogOption.h */,
+				444EAD8C0BD0E60000C6D4A0 /* DialogPrerequisites.h */,
+				444EAD8D0BD0E60000C6D4A0 /* DialogResponse.h */,
+				444EAD8E0BD0E60000C6D4A0 /* DialogScriptProcessor.h */,
+				444EAD8F0BD0E60000C6D4A0 /* DialogSubsystem.h */,
+				444EAD900BD0E60000C6D4A0 /* ScriptProcessor.h */,
+				444EAD720BD0E5E900C6D4A0 /* CreaturePredicates.cpp */,
+				444EAD730BD0E5E900C6D4A0 /* EigenschaftsProbePredicates.cpp */,
+				444EAD740BD0E5E900C6D4A0 /* EigenschaftsWertPredicates.cpp */,
+				444EAD750BD0E5E900C6D4A0 /* GrundWertPredicates.cpp */,
+				444EAD760BD0E5E900C6D4A0 /* QuestKnownPredicates.cpp */,
+				444EAD770BD0E5E900C6D4A0 /* QuestPartsPredicates.cpp */,
+				444EAD780BD0E5E900C6D4A0 /* QuestStatePredicates.cpp */,
+				444EAD790BD0E5E900C6D4A0 /* ScriptPredicates.cpp */,
+				444EAD7A0BD0E5E900C6D4A0 /* TalentProbePredicates.cpp */,
+				444EAD7B0BD0E5E900C6D4A0 /* TalentWertPredicates.cpp */,
+				444EAD5E0BD0E5D500C6D4A0 /* AimlNodeImplRl.cpp */,
+				444EAD5F0BD0E5D500C6D4A0 /* AimlParserImplRl.cpp */,
+				444EAD600BD0E5D500C6D4A0 /* ContextConditionProcessor.cpp */,
+				444EAD610BD0E5D500C6D4A0 /* ContextInterpreter.cpp */,
+				444EAD620BD0E5D500C6D4A0 /* DialogCharacter.cpp */,
+				444EAD630BD0E5D500C6D4A0 /* DialogOption.cpp */,
+				444EAD640BD0E5D500C6D4A0 /* DialogResponse.cpp */,
+				444EAD650BD0E5D500C6D4A0 /* DialogScriptProcessor.cpp */,
+				444EAD660BD0E5D500C6D4A0 /* DialogSubsystem.cpp */,
+				444EAD670BD0E5D500C6D4A0 /* ScriptProcessor.cpp */,
+			);
+			name = RlDialog;
+			sourceTree = "<group>";
+		};
+		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
+			isa = PBXGroup;
+			children = (
+				4404DA820C48D005007B4657 /* stdinc.cpp */,
+				446BF47B0C45329F0013C214 /* CreatureController.cpp */,
+				446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */,
+				446BF47D0C45329F0013C214 /* EffectFactory.cpp */,
+				446BF4750C4532720013C214 /* CreatureController.h */,
+				446BF4760C4532720013C214 /* CreatureControllerManager.h */,
+				446BF4770C4532720013C214 /* EffectFactory.h */,
+				44D814590BF7B52600534175 /* GameObjectConstants.h */,
+				44D8145A0BF7B52600534175 /* SelectionHelper.h */,
+				44D8145B0BF7B52600534175 /* Selector.h */,
+				444826030BF7B37D00C5A94F /* SelectionHelper.cpp */,
+				444826040BF7B37D00C5A94F /* Selector.cpp */,
+				444EAE040BD0E65B00C6D4A0 /* Action.h */,
+				444EAE050BD0E65B00C6D4A0 /* ActionManager.h */,
+				444EAE060BD0E65B00C6D4A0 /* Armor.h */,
+				444EAE070BD0E65B00C6D4A0 /* Combat.h */,
+				444EAE080BD0E65B00C6D4A0 /* CombatManager.h */,
+				444EAE090BD0E65B00C6D4A0 /* Container.h */,
+				444EAE0A0BD0E65B00C6D4A0 /* Creature.h */,
+				444EAE0B0BD0E65B00C6D4A0 /* Date.h */,
+				444EAE0C0BD0E65B00C6D4A0 /* DsaDataLoader.h */,
+				444EAE0D0BD0E65B00C6D4A0 /* DsaManager.h */,
+				444EAE0E0BD0E65B00C6D4A0 /* Effect.h */,
+				444EAE0F0BD0E65B00C6D4A0 /* EffectManager.h */,
+				444EAE100BD0E65B00C6D4A0 /* Eigenschaft.h */,
+				444EAE110BD0E65B00C6D4A0 /* EigenschaftenStateSet.h */,
+				444EAE120BD0E65B00C6D4A0 /* GameObject.h */,
+				444EAE130BD0E65B00C6D4A0 /* GameObjectManager.h */,
+				444EAE160BD0E65B00C6D4A0 /* GameObjectStateListener.h */,
+				444EAE170BD0E65B00C6D4A0 /* Inventory.h */,
+				444EAE180BD0E65B00C6D4A0 /* Item.h */,
+				444EAE190BD0E65B00C6D4A0 /* JournalEntry.h */,
+				444EAE1A0BD0E65B00C6D4A0 /* Kampftechnik.h */,
+				444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */,
+				444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */,
+				444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */,
+				444EAE1E0BD0E65B00C6D4A0 /* Person.h */,
+				444EAE1F0BD0E65B00C6D4A0 /* Quest.h */,
+				444EAE200BD0E65B00C6D4A0 /* QuestBook.h */,
+				444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */,
+				444EAE220BD0E65B00C6D4A0 /* QuestListener.h */,
+				444EAE230BD0E65B00C6D4A0 /* RulesPrerequisites.h */,
+				444EAE240BD0E65B00C6D4A0 /* RulesSubsystem.h */,
+				444EAE250BD0E65B00C6D4A0 /* Slot.h */,
+				444EAE260BD0E65B00C6D4A0 /* SonderfertigkeitenStateSet.h */,
+				444EAE270BD0E65B00C6D4A0 /* StateSet.h */,
+				444EAE280BD0E65B00C6D4A0 /* Talent.h */,
+				444EAE290BD0E65B00C6D4A0 /* Talentgruppe.h */,
+				444EAE2A0BD0E65B00C6D4A0 /* TalentInputIterator.h */,
+				444EAE2B0BD0E65B00C6D4A0 /* TalentStateSet.h */,
+				444EAE2C0BD0E65B00C6D4A0 /* TimerEvent.h */,
+				444EAE2D0BD0E65B00C6D4A0 /* TimerEventSource.h */,
+				444EAE2E0BD0E65B00C6D4A0 /* TimerListener.h */,
+				444EAE2F0BD0E65B00C6D4A0 /* TimerManager.h */,
+				444EAE300BD0E65B00C6D4A0 /* Weapon.h */,
+				444EAE310BD0E65B00C6D4A0 /* ZauberStateSet.h */,
+				444EADB00BD0E64100C6D4A0 /* Action.cpp */,
+				444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */,
+				444EADB20BD0E64100C6D4A0 /* Armor.cpp */,
+				444EADB30BD0E64100C6D4A0 /* Combat.cpp */,
+				444EADB40BD0E64100C6D4A0 /* CombatManager.cpp */,
+				444EADB50BD0E64100C6D4A0 /* Container.cpp */,
+				444EADB60BD0E64100C6D4A0 /* Creature.cpp */,
+				444EADB70BD0E64100C6D4A0 /* Date.cpp */,
+				444EADB80BD0E64100C6D4A0 /* DsaDataLoader.cpp */,
+				444EADB90BD0E64100C6D4A0 /* DsaManager.cpp */,
+				444EADBA0BD0E64100C6D4A0 /* Effect.cpp */,
+				444EADBB0BD0E64100C6D4A0 /* EffectManager.cpp */,
+				444EADBC0BD0E64100C6D4A0 /* Eigenschaft.cpp */,
+				444EADBD0BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp */,
+				444EADBE0BD0E64100C6D4A0 /* GameObject.cpp */,
+				444EADBF0BD0E64100C6D4A0 /* GameObjectManager.cpp */,
+				444EADC10BD0E64100C6D4A0 /* Inventory.cpp */,
+				444EADC20BD0E64100C6D4A0 /* Item.cpp */,
+				444EADC30BD0E64100C6D4A0 /* JournalEntry.cpp */,
+				444EADC40BD0E64100C6D4A0 /* Kampftechnik.cpp */,
+				444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */,
+				444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */,
+				444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */,
+				444EADC80BD0E64100C6D4A0 /* Person.cpp */,
+				444EADC90BD0E64100C6D4A0 /* Quest.cpp */,
+				444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */,
+				444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */,
+				444EADCC0BD0E64100C6D4A0 /* QuestListener.cpp */,
+				444EADCD0BD0E64100C6D4A0 /* RulesSubsystem.cpp */,
+				444EADCE0BD0E64100C6D4A0 /* Slot.cpp */,
+				444EADCF0BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp */,
+				444EADD00BD0E64100C6D4A0 /* StateSet.cpp */,
+				444EADD10BD0E64100C6D4A0 /* Talent.cpp */,
+				444EADD20BD0E64100C6D4A0 /* Talentgruppe.cpp */,
+				444EADD30BD0E64100C6D4A0 /* TalentStateSet.cpp */,
+				444EADD40BD0E64100C6D4A0 /* TimerEvent.cpp */,
+				444EADD50BD0E64100C6D4A0 /* TimerEventSource.cpp */,
+				444EADD60BD0E64100C6D4A0 /* TimerListener.cpp */,
+				444EADD70BD0E64100C6D4A0 /* TimerManager.cpp */,
+				444EADD80BD0E64100C6D4A0 /* Weapon.cpp */,
+				444EADD90BD0E64100C6D4A0 /* ZauberStateSet.cpp */,
+			);
+			name = RlRules;
+			sourceTree = "<group>";
+		};
+		444EAE600BD0E66500C6D4A0 /* RlScript */ = {
+			isa = PBXGroup;
+			children = (
+				4404DA840C48D01E007B4657 /* stdinc.h */,
+				446BF4810C4532B50013C214 /* UnifiedFactory.h */,
+				444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */,
+				444825EE0BF7B32100C5A94F /* EntityNodeProcessor.h */,
+				444825EF0BF7B32100C5A94F /* EnvironmentProcessor.h */,
+				444825F00BF7B32100C5A94F /* GameObjectNodeProcessor.h */,
+				444825F10BF7B32100C5A94F /* LightNodeProcessor.h */,
+				444825F20BF7B32100C5A94F /* MapLoader.h */,
+				444825F30BF7B32100C5A94F /* ParticleSystemNodeProcessor.h */,
+				444825F40BF7B32100C5A94F /* SoundNodeProcessor.h */,
+				444825F50BF7B32100C5A94F /* TriggerFactory.h */,
+				444825F60BF7B32100C5A94F /* WaypointProcessor.h */,
+				444825F70BF7B32100C5A94F /* ZoneProcessor.h */,
+				444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */,
+				444825DA0BF7B2B200C5A94F /* EntityNodeProcessor.cpp */,
+				444825DB0BF7B2B200C5A94F /* EnvironmentProcessor.cpp */,
+				444825DC0BF7B2B200C5A94F /* GameObjectNodeProcessor.cpp */,
+				444825DD0BF7B2B200C5A94F /* LightNodeProcessor.cpp */,
+				444825DE0BF7B2B200C5A94F /* MapLoader.cpp */,
+				444825DF0BF7B2B200C5A94F /* ParticleSystemNodeProcessor.cpp */,
+				444825E00BF7B2B200C5A94F /* SoundNodeProcessor.cpp */,
+				444825E10BF7B2B200C5A94F /* WaypointProcessor.cpp */,
+				444825E20BF7B2B200C5A94F /* ZoneProcessor.cpp */,
+				444EB6BC0BD1891400C6D4A0 /* RlExports.cpp */,
+				444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */,
+				444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */,
+				444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */,
+				444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */,
+				444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */,
+			);
+			name = RlScript;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		444EAAAE0BD0E0FB00C6D4A0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAAEB0BD0E1EF00C6D4A0 /* CommonPrerequisites.h in Headers */,
+				444EAAEC0BD0E1EF00C6D4A0 /* ConfigFile.h in Headers */,
+				444EAAED0BD0E1EF00C6D4A0 /* EventCaster.h in Headers */,
+				444EAAEE0BD0E1EF00C6D4A0 /* EventListener.h in Headers */,
+				444EAAEF0BD0E1EF00C6D4A0 /* EventObject.h in Headers */,
+				444EAAF00BD0E1EF00C6D4A0 /* EventSource.h in Headers */,
+				444EAAF10BD0E1EF00C6D4A0 /* Exception.h in Headers */,
+				444EAAF20BD0E1EF00C6D4A0 /* FixRubyHeaders.h in Headers */,
+				444EAAF30BD0E1EF00C6D4A0 /* GameTask.h in Headers */,
+				444EAAF40BD0E1EF00C6D4A0 /* Logger.h in Headers */,
+				444EAAF50BD0E1EF00C6D4A0 /* MathUtil.h in Headers */,
+				444EAAF60BD0E1EF00C6D4A0 /* OgreXercesInput.h in Headers */,
+				444EAAF70BD0E1EF00C6D4A0 /* Properties.h in Headers */,
+				444EAAF80BD0E1EF00C6D4A0 /* Property.h in Headers */,
+				444EAAF90BD0E1EF00C6D4A0 /* PropertyReader.h in Headers */,
+				444EAAFA0BD0E1EF00C6D4A0 /* RastullahPrerequisites.h in Headers */,
+				444EAAFB0BD0E1EF00C6D4A0 /* ScriptWrapper.h in Headers */,
+				444EAAFC0BD0E1EF00C6D4A0 /* Sleep.h in Headers */,
+				444EAAFD0BD0E1EF00C6D4A0 /* Tripel.h in Headers */,
+				444EAAFE0BD0E1EF00C6D4A0 /* XmlErrorHandler.h in Headers */,
+				444EAAFF0BD0E1EF00C6D4A0 /* XmlHelper.h in Headers */,
+				444EAB000BD0E1EF00C6D4A0 /* XmlResource.h in Headers */,
+				444EAB010BD0E1EF00C6D4A0 /* XmlResourceManager.h in Headers */,
+				4404DA7D0C48CFB3007B4657 /* stdinc.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAB5D0BD0E2DA00C6D4A0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EABDE0BD0E33300C6D4A0 /* Actor.h in Headers */,
+				444EABDF0BD0E33300C6D4A0 /* ActorControlledObject.h in Headers */,
+				444EABE00BD0E33300C6D4A0 /* ActorManager.h in Headers */,
+				444EABE10BD0E33300C6D4A0 /* AnimationListener.h in Headers */,
+				444EABE20BD0E33300C6D4A0 /* AnimationManager.h in Headers */,
+				444EABE30BD0E33300C6D4A0 /* BaseAnimation.h in Headers */,
+				444EABE40BD0E33300C6D4A0 /* BoxPrimitive.h in Headers */,
+				444EABE50BD0E33300C6D4A0 /* CameraObject.h in Headers */,
+				444EABE60BD0E33300C6D4A0 /* ConfigurationManager.h in Headers */,
+				444EABE70BD0E33300C6D4A0 /* ContentModule.h in Headers */,
+				444EABE80BD0E33300C6D4A0 /* CoreEvents.h in Headers */,
+				444EABE90BD0E33300C6D4A0 /* CorePrerequisites.h in Headers */,
+				444EABEA0BD0E33300C6D4A0 /* CoreSubsystem.h in Headers */,
+				444EABEB0BD0E33300C6D4A0 /* DebugVisualisable.h in Headers */,
+				444EABEC0BD0E33300C6D4A0 /* DebugVisualsManager.h in Headers */,
+				444EABED0BD0E33300C6D4A0 /* DotSceneLoader.h in Headers */,
+				444EABEE0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h in Headers */,
+				444EABEF0BD0E33300C6D4A0 /* FadeAnimation.h in Headers */,
+				444EABF00BD0E33300C6D4A0 /* GameAreaEvent.h in Headers */,
+				444EABF10BD0E33300C6D4A0 /* GameAreaEventSource.h in Headers */,
+				444EABF20BD0E33300C6D4A0 /* GameAreaListener.h in Headers */,
+				444EABF30BD0E33300C6D4A0 /* GameAreaTypes.h in Headers */,
+				444EABF40BD0E33300C6D4A0 /* GameEventManager.h in Headers */,
+				444EABF50BD0E33300C6D4A0 /* GameLoop.h in Headers */,
+				444EABF60BD0E33300C6D4A0 /* Job.h in Headers */,
+				444EABF70BD0E33300C6D4A0 /* JobListener.h in Headers */,
+				444EABF80BD0E33300C6D4A0 /* JobScheduler.h in Headers */,
+				444EABF90BD0E33300C6D4A0 /* LightObject.h in Headers */,
+				444EABFB0BD0E33300C6D4A0 /* LineSetPrimitive.h in Headers */,
+				444EABFC0BD0E33300C6D4A0 /* ListenerMovable.h in Headers */,
+				444EABFD0BD0E33300C6D4A0 /* ListenerObject.h in Headers */,
+				444EABFE0BD0E33300C6D4A0 /* MeshAnimation.h in Headers */,
+				444EABFF0BD0E33300C6D4A0 /* MeshObject.h in Headers */,
+				444EAC000BD0E33300C6D4A0 /* MovableText.h in Headers */,
+				444EAC010BD0E33300C6D4A0 /* NullDriver.h in Headers */,
+				444EAC020BD0E33300C6D4A0 /* NullListener.h in Headers */,
+				444EAC030BD0E33300C6D4A0 /* NullSound.h in Headers */,
+				444EAC040BD0E33300C6D4A0 /* ParticleSystemObject.h in Headers */,
+				444EAC050BD0E33300C6D4A0 /* PhysicalObject.h in Headers */,
+				444EAC060BD0E33300C6D4A0 /* PhysicalThing.h in Headers */,
+				444EAC070BD0E33300C6D4A0 /* PhysicsContactListener.h in Headers */,
+				444EAC080BD0E33300C6D4A0 /* PhysicsController.h in Headers */,
+				444EAC090BD0E33300C6D4A0 /* PhysicsGenericContactCallback.h in Headers */,
+				444EAC0A0BD0E33300C6D4A0 /* PhysicsManager.h in Headers */,
+				444EAC0B0BD0E33300C6D4A0 /* PhysicsMaterialRaycast.h in Headers */,
+				444EAC0C0BD0E33300C6D4A0 /* PlayAnimationJob.h in Headers */,
+				444EAC0D0BD0E33300C6D4A0 /* PlaySoundJob.h in Headers */,
+				444EAC0E0BD0E33300C6D4A0 /* PrimitiveObject.h in Headers */,
+				444EAC0F0BD0E33300C6D4A0 /* QuadTree.h in Headers */,
+				444EAC100BD0E33300C6D4A0 /* RubyInterpreter.h in Headers */,
+				444EAC110BD0E33300C6D4A0 /* SceneQuery.h in Headers */,
+				444EAC120BD0E33300C6D4A0 /* Sound.h in Headers */,
+				444EAC130BD0E33300C6D4A0 /* SoundDriver.h in Headers */,
+				444EAC140BD0E33300C6D4A0 /* SoundEvents.h in Headers */,
+				444EAC150BD0E33300C6D4A0 /* SoundManager.h in Headers */,
+				444EAC160BD0E33300C6D4A0 /* SoundObject.h in Headers */,
+				444EAC170BD0E33300C6D4A0 /* SoundResource.h in Headers */,
+				444EAC180BD0E33300C6D4A0 /* TrackAnimation.h in Headers */,
+				444EAC190BD0E33300C6D4A0 /* World.h in Headers */,
+				44D814780BF7B62F00534175 /* CoreDefines.h in Headers */,
+				44D814790BF7B62F00534175 /* LightFadeJob.h in Headers */,
+				44D8147A0BF7B62F00534175 /* Trigger.h in Headers */,
+				44D8147B0BF7B62F00534175 /* Zone.h in Headers */,
+				44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */,
+				440785E70C09D2DF006E496D /* MergeableMeshObject.h in Headers */,
+				446BF46C0C4531FA0013C214 /* LinearSoundFadeFunctor.h in Headers */,
+				446BF46D0C4531FA0013C214 /* SoundFadeFunctor.h in Headers */,
+				446BF46E0C4531FA0013C214 /* SoundFadeJob.h in Headers */,
+				4404DA7F0C48CFC7007B4657 /* stdinc.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC230BD0E3FF00C6D4A0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAC8F0BD0E54100C6D4A0 /* Agent.h in Headers */,
+				444EAC900BD0E54100C6D4A0 /* AgentManager.h in Headers */,
+				444EAC910BD0E54100C6D4A0 /* AiPrerequisites.h in Headers */,
+				444EAC920BD0E54100C6D4A0 /* AiSubsystem.h in Headers */,
+				444EAC930BD0E54100C6D4A0 /* AiWorld.h in Headers */,
+				444EAC940BD0E54100C6D4A0 /* AStar.h in Headers */,
+				444EAC950BD0E54100C6D4A0 /* AStarCosts.h in Headers */,
+				444EAC960BD0E54100C6D4A0 /* AStarHeuristic.h in Headers */,
+				444EAC970BD0E54100C6D4A0 /* AStarNodePool.h in Headers */,
+				444EAC980BD0E54100C6D4A0 /* AStarWayPointNode.h in Headers */,
+				444EAC990BD0E54100C6D4A0 /* FuzzyState.h in Headers */,
+				444EAC9A0BD0E54100C6D4A0 /* FuzzyStateMachine.h in Headers */,
+				444EAC9B0BD0E54100C6D4A0 /* PhysicalObstacle.h in Headers */,
+				444EAC9C0BD0E54100C6D4A0 /* PlayerVehicle.h in Headers */,
+				444EAC9D0BD0E54100C6D4A0 /* SteeringMachine.h in Headers */,
+				444EAC9E0BD0E54100C6D4A0 /* SteeringVehicle.h in Headers */,
+				444EAC9F0BD0E54100C6D4A0 /* WayPointGraph.h in Headers */,
+				444EACA00BD0E54100C6D4A0 /* WayPointGraphManager.h in Headers */,
+				444EACA10BD0E54100C6D4A0 /* WayPointNode.h in Headers */,
+				44D8146D0BF7B5E800534175 /* Landmark.h in Headers */,
+				44D8146E0BF7B5E800534175 /* LandmarkPath.h in Headers */,
+				44125A320C083D1100C24C0A /* CreatureWalkPathJob.h in Headers */,
+				4404DA6F0C48CEE2007B4657 /* stdinc.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC2B0BD0E42A00C6D4A0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAD910BD0E60000C6D4A0 /* AimlNodeImplRl.h in Headers */,
+				444EAD920BD0E60000C6D4A0 /* AimlParserImplRl.h in Headers */,
+				444EAD930BD0E60000C6D4A0 /* ContextConditionProcessor.h in Headers */,
+				444EAD940BD0E60000C6D4A0 /* ContextInterpreter.h in Headers */,
+				444EAD950BD0E60000C6D4A0 /* DialogCharacter.h in Headers */,
+				444EAD960BD0E60000C6D4A0 /* DialogOption.h in Headers */,
+				444EAD970BD0E60000C6D4A0 /* DialogPrerequisites.h in Headers */,
+				444EAD980BD0E60000C6D4A0 /* DialogResponse.h in Headers */,
+				444EAD990BD0E60000C6D4A0 /* DialogScriptProcessor.h in Headers */,
+				444EAD9A0BD0E60000C6D4A0 /* DialogSubsystem.h in Headers */,
+				444EAD9B0BD0E60000C6D4A0 /* ScriptProcessor.h in Headers */,
+				444EADA60BD0E61400C6D4A0 /* CreaturePredicates.h in Headers */,
+				444EADA70BD0E61400C6D4A0 /* EigenschaftsProbePredicates.h in Headers */,
+				444EADA80BD0E61400C6D4A0 /* EigenschaftsWertPredicates.h in Headers */,
+				444EADA90BD0E61400C6D4A0 /* GrundWertPredicates.h in Headers */,
+				444EADAA0BD0E61400C6D4A0 /* QuestKnownPredicates.h in Headers */,
+				444EADAB0BD0E61400C6D4A0 /* QuestPartsPredicates.h in Headers */,
+				444EADAC0BD0E61400C6D4A0 /* QuestStatePredicates.h in Headers */,
+				444EADAD0BD0E61400C6D4A0 /* ScriptPredicates.h in Headers */,
+				444EADAE0BD0E61400C6D4A0 /* TalentProbePredicates.h in Headers */,
+				444EADAF0BD0E61400C6D4A0 /* TalentWertPredicates.h in Headers */,
+				4404DA810C48CFDE007B4657 /* stdinc.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC330BD0E44900C6D4A0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAE320BD0E65B00C6D4A0 /* Action.h in Headers */,
+				444EAE330BD0E65B00C6D4A0 /* ActionManager.h in Headers */,
+				444EAE340BD0E65B00C6D4A0 /* Armor.h in Headers */,
+				444EAE350BD0E65B00C6D4A0 /* Combat.h in Headers */,
+				444EAE360BD0E65B00C6D4A0 /* CombatManager.h in Headers */,
+				444EAE370BD0E65B00C6D4A0 /* Container.h in Headers */,
+				444EAE380BD0E65B00C6D4A0 /* Creature.h in Headers */,
+				444EAE390BD0E65B00C6D4A0 /* Date.h in Headers */,
+				444EAE3A0BD0E65B00C6D4A0 /* DsaDataLoader.h in Headers */,
+				444EAE3B0BD0E65B00C6D4A0 /* DsaManager.h in Headers */,
+				444EAE3C0BD0E65B00C6D4A0 /* Effect.h in Headers */,
+				444EAE3D0BD0E65B00C6D4A0 /* EffectManager.h in Headers */,
+				444EAE3E0BD0E65B00C6D4A0 /* Eigenschaft.h in Headers */,
+				444EAE3F0BD0E65B00C6D4A0 /* EigenschaftenStateSet.h in Headers */,
+				444EAE400BD0E65B00C6D4A0 /* GameObject.h in Headers */,
+				444EAE410BD0E65B00C6D4A0 /* GameObjectManager.h in Headers */,
+				444EAE440BD0E65B00C6D4A0 /* GameObjectStateListener.h in Headers */,
+				444EAE450BD0E65B00C6D4A0 /* Inventory.h in Headers */,
+				444EAE460BD0E65B00C6D4A0 /* Item.h in Headers */,
+				444EAE470BD0E65B00C6D4A0 /* JournalEntry.h in Headers */,
+				444EAE480BD0E65B00C6D4A0 /* Kampftechnik.h in Headers */,
+				444EAE490BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h in Headers */,
+				444EAE4A0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h in Headers */,
+				444EAE4B0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h in Headers */,
+				444EAE4C0BD0E65B00C6D4A0 /* Person.h in Headers */,
+				444EAE4D0BD0E65B00C6D4A0 /* Quest.h in Headers */,
+				444EAE4E0BD0E65B00C6D4A0 /* QuestBook.h in Headers */,
+				444EAE4F0BD0E65B00C6D4A0 /* QuestEvent.h in Headers */,
+				444EAE500BD0E65B00C6D4A0 /* QuestListener.h in Headers */,
+				444EAE510BD0E65B00C6D4A0 /* RulesPrerequisites.h in Headers */,
+				444EAE520BD0E65B00C6D4A0 /* RulesSubsystem.h in Headers */,
+				444EAE530BD0E65B00C6D4A0 /* Slot.h in Headers */,
+				444EAE540BD0E65B00C6D4A0 /* SonderfertigkeitenStateSet.h in Headers */,
+				444EAE550BD0E65B00C6D4A0 /* StateSet.h in Headers */,
+				444EAE560BD0E65B00C6D4A0 /* Talent.h in Headers */,
+				444EAE570BD0E65B00C6D4A0 /* Talentgruppe.h in Headers */,
+				444EAE580BD0E65B00C6D4A0 /* TalentInputIterator.h in Headers */,
+				444EAE590BD0E65B00C6D4A0 /* TalentStateSet.h in Headers */,
+				444EAE5A0BD0E65B00C6D4A0 /* TimerEvent.h in Headers */,
+				444EAE5B0BD0E65B00C6D4A0 /* TimerEventSource.h in Headers */,
+				444EAE5C0BD0E65B00C6D4A0 /* TimerListener.h in Headers */,
+				444EAE5D0BD0E65B00C6D4A0 /* TimerManager.h in Headers */,
+				444EAE5E0BD0E65B00C6D4A0 /* Weapon.h in Headers */,
+				444EAE5F0BD0E65B00C6D4A0 /* ZauberStateSet.h in Headers */,
+				44D8145C0BF7B52600534175 /* GameObjectConstants.h in Headers */,
+				44D8145D0BF7B52600534175 /* SelectionHelper.h in Headers */,
+				44D8145E0BF7B52600534175 /* Selector.h in Headers */,
+				446BF4780C4532720013C214 /* CreatureController.h in Headers */,
+				446BF4790C4532720013C214 /* CreatureControllerManager.h in Headers */,
+				446BF47A0C4532720013C214 /* EffectFactory.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC3A0BD0E46000C6D4A0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAD2E0BD0E58C00C6D4A0 /* AboutWindow.h in Headers */,
+				444EAD2F0BD0E58C00C6D4A0 /* AbstractWindow.h in Headers */,
+				444EAD300BD0E58C00C6D4A0 /* ActionChoiceWindow.h in Headers */,
+				444EAD310BD0E58C00C6D4A0 /* CeGuiHelper.h in Headers */,
+				444EAD330BD0E58C00C6D4A0 /* CharacterSheetWindow.h in Headers */,
+				444EAD340BD0E58C00C6D4A0 /* CharacterStateWindow.h in Headers */,
+				444EAD350BD0E58C00C6D4A0 /* CloseConfirmationWindow.h in Headers */,
+				444EAD370BD0E58C00C6D4A0 /* CommandMapper.h in Headers */,
+				444EAD390BD0E58C00C6D4A0 /* ConfigComponent.h in Headers */,
+				444EAD3A0BD0E58C00C6D4A0 /* Console.h in Headers */,
+				444EAD3B0BD0E58C00C6D4A0 /* ContainerContentWindow.h in Headers */,
+				444EAD3E0BD0E58C00C6D4A0 /* DebugWindow.h in Headers */,
+				444EAD400BD0E58C00C6D4A0 /* DialogWindow.h in Headers */,
+				444EAD420BD0E58C00C6D4A0 /* GameLoggerWindow.h in Headers */,
+				444EAD430BD0E58C00C6D4A0 /* GameObjectInfoWindow.h in Headers */,
+				444EAD450BD0E58C00C6D4A0 /* GameSettings.h in Headers */,
+				444EAD460BD0E58C00C6D4A0 /* InfoPopup.h in Headers */,
+				444EAD470BD0E58C00C6D4A0 /* InGameMenuWindow.h in Headers */,
+				444EAD480BD0E58C00C6D4A0 /* InputManager.h in Headers */,
+				444EAD490BD0E58C00C6D4A0 /* InventoryWindow.h in Headers */,
+				444EAD4A0BD0E58C00C6D4A0 /* ItemDragContainer.h in Headers */,
+				444EAD4B0BD0E58C00C6D4A0 /* JournalWindow.h in Headers */,
+				444EAD4C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h in Headers */,
+				444EAD4D0BD0E58C00C6D4A0 /* LogWindow.h in Headers */,
+				444EAD4E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h in Headers */,
+				444EAD4F0BD0E58C00C6D4A0 /* MainMenuWindow.h in Headers */,
+				444EAD500BD0E58C00C6D4A0 /* MessageWindow.h in Headers */,
+				444EAD520BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h in Headers */,
+				444EAD530BD0E58C00C6D4A0 /* PlaylistWindow.h in Headers */,
+				444EAD540BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h in Headers */,
+				444EAD560BD0E58C00C6D4A0 /* SoundConfig.h in Headers */,
+				444EAD570BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h in Headers */,
+				444EAD580BD0E58C00C6D4A0 /* SubtitleWindow.h in Headers */,
+				444EAD590BD0E58C00C6D4A0 /* UiPrerequisites.h in Headers */,
+				444EAD5A0BD0E58C00C6D4A0 /* UiSubsystem.h in Headers */,
+				444EAD5B0BD0E58C00C6D4A0 /* WindowFactory.h in Headers */,
+				444EAD5C0BD0E58C00C6D4A0 /* WindowFadeJob.h in Headers */,
+				444EAD5D0BD0E58C00C6D4A0 /* WindowManager.h in Headers */,
+				44D814610BF7B58A00534175 /* ProgressWindow.h in Headers */,
+				44D814620BF7B58A00534175 /* SaveLoadWindow.h in Headers */,
+				446BF48C0C45335A0013C214 /* ControlState.h in Headers */,
+				446BF48D0C45335A0013C214 /* CutsceneControlState.h in Headers */,
+				446BF48E0C45335A0013C214 /* DialogControlState.h in Headers */,
+				446BF48F0C45335A0013C214 /* FreeflightControlState.h in Headers */,
+				446BF4900C45335A0013C214 /* ItemDescriptionDragContainer.h in Headers */,
+				446BF4910C45335A0013C214 /* ItemIconDragContainer.h in Headers */,
+				446BF4920C45335A0013C214 /* MovementControlState.h in Headers */,
+				446BF4930C45335A0013C214 /* PropertiesWindow.h in Headers */,
+				446BF4D20C453B9E0013C214 /* CombatControlState.h in Headers */,
+				446BF4D30C453B9E0013C214 /* CombatWindow.h in Headers */,
+				4404DA860C48D037007B4657 /* stdinc.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXNativeTarget section */
+		440786100C09D602006E496D /* RlScript */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 440786130C09D603006E496D /* Build configuration list for PBXNativeTarget "RlScript" */;
+			buildPhases = (
+				440787FC0C09D6C4006E496D /* ShellScript */,
+				4407860E0C09D602006E496D /* Sources */,
+				4407860F0C09D602006E496D /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				440788020C09D6DD006E496D /* PBXTargetDependency */,
+			);
+			name = RlScript;
+			productName = RlScript2;
+			productReference = 440786110C09D602006E496D /* libRlScript.bundle */;
+			productType = "com.apple.product-type.bundle";
+		};
+		444EAAB10BD0E0FB00C6D4A0 /* RlCommon */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 444EAAB30BD0E11900C6D4A0 /* Build configuration list for PBXNativeTarget "RlCommon" */;
+			buildPhases = (
+				444EAAAE0BD0E0FB00C6D4A0 /* Headers */,
+				444EAAAF0BD0E0FB00C6D4A0 /* Sources */,
+				444EAAB00BD0E0FB00C6D4A0 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = RlCommon;
+			productName = RlCommon;
+			productReference = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		444EAB600BD0E2DA00C6D4A0 /* RlCore */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 444EAB9A0BD0E31100C6D4A0 /* Build configuration list for PBXNativeTarget "RlCore" */;
+			buildPhases = (
+				444EAB5D0BD0E2DA00C6D4A0 /* Headers */,
+				444EAB5E0BD0E2DA00C6D4A0 /* Sources */,
+				444EAB5F0BD0E2DA00C6D4A0 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				444EB1320BD11A3A00C6D4A0 /* PBXTargetDependency */,
+			);
+			name = RlCore;
+			productName = RlCore;
+			productReference = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		444EAC260BD0E3FF00C6D4A0 /* RlAi */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 444EAC280BD0E42A00C6D4A0 /* Build configuration list for PBXNativeTarget "RlAi" */;
+			buildPhases = (
+				444EAC230BD0E3FF00C6D4A0 /* Headers */,
+				444EAC240BD0E3FF00C6D4A0 /* Sources */,
+				444EAC250BD0E3FF00C6D4A0 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				444EB1360BD11A5C00C6D4A0 /* PBXTargetDependency */,
+			);
+			name = RlAi;
+			productName = RlAi;
+			productReference = 444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		444EAC2E0BD0E42A00C6D4A0 /* RlDialog */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 444EAC300BD0E44800C6D4A0 /* Build configuration list for PBXNativeTarget "RlDialog" */;
+			buildPhases = (
+				444EAC2B0BD0E42A00C6D4A0 /* Headers */,
+				444EAC2C0BD0E42A00C6D4A0 /* Sources */,
+				444EAC2D0BD0E42A00C6D4A0 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				44F21A000BD2142A00EF01CF /* PBXTargetDependency */,
+			);
+			name = RlDialog;
+			productName = RlDialog;
+			productReference = 444EAC2F0BD0E42A00C6D4A0 /* libRlDialog.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		444EAC360BD0E44900C6D4A0 /* RlRules */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 444EAC3F0BD0E47F00C6D4A0 /* Build configuration list for PBXNativeTarget "RlRules" */;
+			buildPhases = (
+				444EAC330BD0E44900C6D4A0 /* Headers */,
+				444EAC340BD0E44900C6D4A0 /* Sources */,
+				444EAC350BD0E44900C6D4A0 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				44F21A060BD2143D00EF01CF /* PBXTargetDependency */,
+			);
+			name = RlRules;
+			productName = RlRules;
+			productReference = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		444EAC3D0BD0E46000C6D4A0 /* RlUi */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 444EAC420BD0E47F00C6D4A0 /* Build configuration list for PBXNativeTarget "RlUi" */;
+			buildPhases = (
+				444EAC3A0BD0E46000C6D4A0 /* Headers */,
+				444EAC3B0BD0E46000C6D4A0 /* Sources */,
+				444EAC3C0BD0E46000C6D4A0 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				444EB1DB0BD159B600C6D4A0 /* PBXTargetDependency */,
+			);
+			name = RlUi;
+			productName = RlUi;
+			productReference = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		8D0C4E890486CD37000505A6 /* Rastullah */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = C0E91AC508A95435008D54AB /* Build configuration list for PBXNativeTarget "Rastullah" */;
+			buildPhases = (
+				8D0C4E8C0486CD37000505A6 /* Resources */,
+				8D0C4E8F0486CD37000505A6 /* Sources */,
+				8D0C4E910486CD37000505A6 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				444EAC1F0BD0E3A800C6D4A0 /* PBXTargetDependency */,
+				444EAC210BD0E3A800C6D4A0 /* PBXTargetDependency */,
+				444EAC4B0BD0E49900C6D4A0 /* PBXTargetDependency */,
+				444EAC4D0BD0E49900C6D4A0 /* PBXTargetDependency */,
+				444EAC4F0BD0E49900C6D4A0 /* PBXTargetDependency */,
+				444EAC510BD0E49900C6D4A0 /* PBXTargetDependency */,
+				440788090C09D706006E496D /* PBXTargetDependency */,
+			);
+			name = Rastullah;
+			productInstallPath = "$(HOME)/Applications";
+			productName = Rastullah;
+			productReference = 8D0C4E970486CD37000505A6 /* Rastullah.app */;
+			productType = "com.apple.product-type.application";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		20286C28FDCF999611CA2CEA /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = C0E91AC908A95435008D54AB /* Build configuration list for PBXProject "Rastullah" */;
+			hasScannedForEncodings = 1;
+			mainGroup = 20286C29FDCF999611CA2CEA /* Rastullah */;
+			projectDirPath = "";
+			targets = (
+				8D0C4E890486CD37000505A6 /* Rastullah */,
+				444EAAB10BD0E0FB00C6D4A0 /* RlCommon */,
+				444EAB600BD0E2DA00C6D4A0 /* RlCore */,
+				444EAC260BD0E3FF00C6D4A0 /* RlAi */,
+				444EAC2E0BD0E42A00C6D4A0 /* RlDialog */,
+				444EAC360BD0E44900C6D4A0 /* RlRules */,
+				444EAC3D0BD0E46000C6D4A0 /* RlUi */,
+				440786100C09D602006E496D /* RlScript */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		8D0C4E8C0486CD37000505A6 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */,
+				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXShellScriptBuildPhase section */
+		440787FC0C09D6C4006E496D /* ShellScript */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "/usr/local/bin/swig -D__OSX -v -minherit -ruby -c++ -o ${SRCROOT}/../engine/script/swig/RlExports.cpp ${SRCROOT}/../engine/script/swig/RlExports.i";
+		};
+/* End PBXShellScriptBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		4407860E0C09D602006E496D /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				440787EF0C09D697006E496D /* AbstractMapNodeProcessor.cpp in Sources */,
+				440787F00C09D697006E496D /* EntityNodeProcessor.cpp in Sources */,
+				440787F10C09D697006E496D /* EnvironmentProcessor.cpp in Sources */,
+				440787F20C09D697006E496D /* GameObjectNodeProcessor.cpp in Sources */,
+				440787F30C09D697006E496D /* LightNodeProcessor.cpp in Sources */,
+				440787F40C09D697006E496D /* MapLoader.cpp in Sources */,
+				440787F50C09D697006E496D /* ParticleSystemNodeProcessor.cpp in Sources */,
+				440787F60C09D697006E496D /* RlExports.cpp in Sources */,
+				440787F70C09D697006E496D /* ScriptObjectMarker.cpp in Sources */,
+				440787F80C09D697006E496D /* ScriptSubsystem.cpp in Sources */,
+				440787F90C09D697006E496D /* SoundNodeProcessor.cpp in Sources */,
+				440787FA0C09D697006E496D /* WaypointProcessor.cpp in Sources */,
+				440787FB0C09D697006E496D /* ZoneProcessor.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAAAF0BD0E0FB00C6D4A0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAABB0BD0E17000C6D4A0 /* ConfigFile.cpp in Sources */,
+				444EAABC0BD0E17000C6D4A0 /* EventObject.cpp in Sources */,
+				444EAABD0BD0E17000C6D4A0 /* EventSource.cpp in Sources */,
+				444EAABE0BD0E17000C6D4A0 /* GameTask.cpp in Sources */,
+				444EAABF0BD0E17000C6D4A0 /* Logger.cpp in Sources */,
+				444EAACA0BD0E18800C6D4A0 /* MathUtil.cpp in Sources */,
+				444EAACB0BD0E18800C6D4A0 /* OgreXercesInput.cpp in Sources */,
+				444EAACC0BD0E18800C6D4A0 /* Properties.cpp in Sources */,
+				444EAACD0BD0E18800C6D4A0 /* Property.cpp in Sources */,
+				444EAACE0BD0E18800C6D4A0 /* PropertyReader.cpp in Sources */,
+				444EAACF0BD0E18800C6D4A0 /* ScriptWrapper.cpp in Sources */,
+				444EAAD00BD0E18800C6D4A0 /* XmlErrorHandler.cpp in Sources */,
+				444EAAD10BD0E18800C6D4A0 /* XmlHelper.cpp in Sources */,
+				444EAAD20BD0E18800C6D4A0 /* XmlResource.cpp in Sources */,
+				444EAAD30BD0E18800C6D4A0 /* XmlResourceManager.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAB5E0BD0E2DA00C6D4A0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAB620BD0E2F300C6D4A0 /* Actor.cpp in Sources */,
+				444EAB630BD0E2F300C6D4A0 /* ActorControlledObject.cpp in Sources */,
+				444EAB640BD0E2F300C6D4A0 /* ActorManager.cpp in Sources */,
+				444EAB650BD0E2F300C6D4A0 /* AnimationListener.cpp in Sources */,
+				444EAB660BD0E2F300C6D4A0 /* AnimationManager.cpp in Sources */,
+				444EAB670BD0E2F300C6D4A0 /* BaseAnimation.cpp in Sources */,
+				444EAB680BD0E2F300C6D4A0 /* BoxPrimitive.cpp in Sources */,
+				444EAB690BD0E2F300C6D4A0 /* CameraObject.cpp in Sources */,
+				444EAB6A0BD0E2F300C6D4A0 /* ConfigurationManager.cpp in Sources */,
+				444EAB6B0BD0E2F300C6D4A0 /* ContentModule.cpp in Sources */,
+				444EAB6C0BD0E2F300C6D4A0 /* CoreEvents.cpp in Sources */,
+				444EAB6D0BD0E2F300C6D4A0 /* CoreSubsystem.cpp in Sources */,
+				444EAB6E0BD0E2F300C6D4A0 /* DebugVisualisable.cpp in Sources */,
+				444EAB6F0BD0E2F300C6D4A0 /* DebugVisualsManager.cpp in Sources */,
+				444EAB700BD0E2F300C6D4A0 /* DotSceneLoader.cpp in Sources */,
+				444EAB710BD0E2F300C6D4A0 /* DotSceneOctreeWorld.cpp in Sources */,
+				444EAB720BD0E2F300C6D4A0 /* FadeAnimation.cpp in Sources */,
+				444EAB730BD0E2F300C6D4A0 /* GameAreaEvent.cpp in Sources */,
+				444EAB740BD0E2F300C6D4A0 /* GameAreaEventSource.cpp in Sources */,
+				444EAB750BD0E2F300C6D4A0 /* GameAreaListener.cpp in Sources */,
+				444EAB760BD0E2F300C6D4A0 /* GameAreaTypes.cpp in Sources */,
+				444EAB770BD0E2F300C6D4A0 /* GameEventManager.cpp in Sources */,
+				444EAB780BD0E2F300C6D4A0 /* GameLoop.cpp in Sources */,
+				444EAB790BD0E2F300C6D4A0 /* Job.cpp in Sources */,
+				444EAB7A0BD0E2F300C6D4A0 /* JobScheduler.cpp in Sources */,
+				444EAB7B0BD0E2F300C6D4A0 /* LightObject.cpp in Sources */,
+				444EAB7D0BD0E2F300C6D4A0 /* LineSetPrimitive.cpp in Sources */,
+				444EAB7E0BD0E2F300C6D4A0 /* ListenerMovable.cpp in Sources */,
+				444EAB7F0BD0E2F300C6D4A0 /* ListenerObject.cpp in Sources */,
+				444EAB800BD0E2F300C6D4A0 /* MeshAnimation.cpp in Sources */,
+				444EAB810BD0E2F300C6D4A0 /* MeshObject.cpp in Sources */,
+				444EAB820BD0E2F300C6D4A0 /* MovableText.cpp in Sources */,
+				444EAB840BD0E2F300C6D4A0 /* NullDriver.cpp in Sources */,
+				444EAB850BD0E2F300C6D4A0 /* NullListener.cpp in Sources */,
+				444EAB860BD0E2F300C6D4A0 /* NullSound.cpp in Sources */,
+				444EAB870BD0E2F300C6D4A0 /* ParticleSystemObject.cpp in Sources */,
+				444EAB880BD0E2F300C6D4A0 /* PhysicalThing.cpp in Sources */,
+				444EAB890BD0E2F300C6D4A0 /* PhysicsContactListener.cpp in Sources */,
+				444EAB8A0BD0E2F300C6D4A0 /* PhysicsGenericContactCallback.cpp in Sources */,
+				444EAB8B0BD0E2F300C6D4A0 /* PhysicsManager.cpp in Sources */,
+				444EAB8C0BD0E2F300C6D4A0 /* PhysicsMaterialRaycast.cpp in Sources */,
+				444EAB8D0BD0E2F300C6D4A0 /* PlayAnimationJob.cpp in Sources */,
+				444EAB8E0BD0E2F300C6D4A0 /* PlaySoundJob.cpp in Sources */,
+				444EAB8F0BD0E2F300C6D4A0 /* PrimitiveObject.cpp in Sources */,
+				444EAB900BD0E2F300C6D4A0 /* RubyInterpreter.cpp in Sources */,
+				444EAB910BD0E2F300C6D4A0 /* SceneQuery.cpp in Sources */,
+				444EAB920BD0E2F300C6D4A0 /* Sound.cpp in Sources */,
+				444EAB930BD0E2F300C6D4A0 /* SoundDriver.cpp in Sources */,
+				444EAB940BD0E2F300C6D4A0 /* SoundEvents.cpp in Sources */,
+				444EAB950BD0E2F300C6D4A0 /* SoundManager.cpp in Sources */,
+				444EAB960BD0E2F300C6D4A0 /* SoundObject.cpp in Sources */,
+				444EAB970BD0E2F300C6D4A0 /* SoundResource.cpp in Sources */,
+				444EAB980BD0E2F300C6D4A0 /* TrackAnimation.cpp in Sources */,
+				444EAB990BD0E2F300C6D4A0 /* World.cpp in Sources */,
+				44D814710BF7B61500534175 /* Zone.cpp in Sources */,
+				44D814720BF7B61500534175 /* ZoneManager.cpp in Sources */,
+				440785E40C09D2C1006E496D /* LightFadeJob.cpp in Sources */,
+				440785E50C09D2C1006E496D /* MergeableMeshObject.cpp in Sources */,
+				446BF4720C4532120013C214 /* LinearSoundFadeFunctor.cpp in Sources */,
+				446BF4730C4532120013C214 /* SoundFadeFunctor.cpp in Sources */,
+				446BF4740C4532120013C214 /* SoundFadeJob.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC240BD0E3FF00C6D4A0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAC6B0BD0E52E00C6D4A0 /* Agent.cpp in Sources */,
+				444EAC6C0BD0E52E00C6D4A0 /* AgentManager.cpp in Sources */,
+				444EAC6D0BD0E52E00C6D4A0 /* AiSubsystem.cpp in Sources */,
+				444EAC6E0BD0E52E00C6D4A0 /* AiWorld.cpp in Sources */,
+				444EAC6F0BD0E52E00C6D4A0 /* AStar.cpp in Sources */,
+				444EAC700BD0E52E00C6D4A0 /* AStarCosts.cpp in Sources */,
+				444EAC710BD0E52E00C6D4A0 /* AStarHeuristic.cpp in Sources */,
+				444EAC720BD0E52E00C6D4A0 /* AStarNodePool.cpp in Sources */,
+				444EAC730BD0E52E00C6D4A0 /* AStarWayPointNode.cpp in Sources */,
+				444EAC740BD0E52E00C6D4A0 /* FuzzyState.cpp in Sources */,
+				444EAC750BD0E52E00C6D4A0 /* FuzzyStateMachine.cpp in Sources */,
+				444EAC760BD0E52E00C6D4A0 /* PhysicalObstacle.cpp in Sources */,
+				444EAC770BD0E52E00C6D4A0 /* PlayerVehicle.cpp in Sources */,
+				444EAC780BD0E52E00C6D4A0 /* SteeringVehicle.cpp in Sources */,
+				444EAC790BD0E52E00C6D4A0 /* WayPointGraph.cpp in Sources */,
+				444EAC7A0BD0E52E00C6D4A0 /* WayPointGraphManager.cpp in Sources */,
+				444EAC7B0BD0E52E00C6D4A0 /* WayPointNode.cpp in Sources */,
+				44D814690BF7B5C700534175 /* Landmark.cpp in Sources */,
+				44D8146A0BF7B5C700534175 /* LandmarkPath.cpp in Sources */,
+				44125A300C083D0100C24C0A /* CreatureWalkPathJob.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC2C0BD0E42A00C6D4A0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAD680BD0E5D500C6D4A0 /* AimlNodeImplRl.cpp in Sources */,
+				444EAD690BD0E5D500C6D4A0 /* AimlParserImplRl.cpp in Sources */,
+				444EAD6A0BD0E5D500C6D4A0 /* ContextConditionProcessor.cpp in Sources */,
+				444EAD6B0BD0E5D500C6D4A0 /* ContextInterpreter.cpp in Sources */,
+				444EAD6C0BD0E5D500C6D4A0 /* DialogCharacter.cpp in Sources */,
+				444EAD6D0BD0E5D500C6D4A0 /* DialogOption.cpp in Sources */,
+				444EAD6E0BD0E5D500C6D4A0 /* DialogResponse.cpp in Sources */,
+				444EAD6F0BD0E5D500C6D4A0 /* DialogScriptProcessor.cpp in Sources */,
+				444EAD700BD0E5D500C6D4A0 /* DialogSubsystem.cpp in Sources */,
+				444EAD710BD0E5D500C6D4A0 /* ScriptProcessor.cpp in Sources */,
+				444EAD7C0BD0E5E900C6D4A0 /* CreaturePredicates.cpp in Sources */,
+				444EAD7D0BD0E5E900C6D4A0 /* EigenschaftsProbePredicates.cpp in Sources */,
+				444EAD7E0BD0E5E900C6D4A0 /* EigenschaftsWertPredicates.cpp in Sources */,
+				444EAD7F0BD0E5E900C6D4A0 /* GrundWertPredicates.cpp in Sources */,
+				444EAD800BD0E5E900C6D4A0 /* QuestKnownPredicates.cpp in Sources */,
+				444EAD810BD0E5E900C6D4A0 /* QuestPartsPredicates.cpp in Sources */,
+				444EAD820BD0E5E900C6D4A0 /* QuestStatePredicates.cpp in Sources */,
+				444EAD830BD0E5E900C6D4A0 /* ScriptPredicates.cpp in Sources */,
+				444EAD840BD0E5E900C6D4A0 /* TalentProbePredicates.cpp in Sources */,
+				444EAD850BD0E5E900C6D4A0 /* TalentWertPredicates.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC340BD0E44900C6D4A0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EADDA0BD0E64100C6D4A0 /* Action.cpp in Sources */,
+				444EADDB0BD0E64100C6D4A0 /* ActionManager.cpp in Sources */,
+				444EADDC0BD0E64100C6D4A0 /* Armor.cpp in Sources */,
+				444EADDD0BD0E64100C6D4A0 /* Combat.cpp in Sources */,
+				444EADDE0BD0E64100C6D4A0 /* CombatManager.cpp in Sources */,
+				444EADDF0BD0E64100C6D4A0 /* Container.cpp in Sources */,
+				444EADE00BD0E64100C6D4A0 /* Creature.cpp in Sources */,
+				444EADE10BD0E64100C6D4A0 /* Date.cpp in Sources */,
+				444EADE20BD0E64100C6D4A0 /* DsaDataLoader.cpp in Sources */,
+				444EADE30BD0E64100C6D4A0 /* DsaManager.cpp in Sources */,
+				444EADE40BD0E64100C6D4A0 /* Effect.cpp in Sources */,
+				444EADE50BD0E64100C6D4A0 /* EffectManager.cpp in Sources */,
+				444EADE60BD0E64100C6D4A0 /* Eigenschaft.cpp in Sources */,
+				444EADE70BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp in Sources */,
+				444EADE80BD0E64100C6D4A0 /* GameObject.cpp in Sources */,
+				444EADE90BD0E64100C6D4A0 /* GameObjectManager.cpp in Sources */,
+				444EADEB0BD0E64100C6D4A0 /* Inventory.cpp in Sources */,
+				444EADEC0BD0E64100C6D4A0 /* Item.cpp in Sources */,
+				444EADED0BD0E64100C6D4A0 /* JournalEntry.cpp in Sources */,
+				444EADEE0BD0E64100C6D4A0 /* Kampftechnik.cpp in Sources */,
+				444EADEF0BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp in Sources */,
+				444EADF00BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp in Sources */,
+				444EADF10BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp in Sources */,
+				444EADF20BD0E64100C6D4A0 /* Person.cpp in Sources */,
+				444EADF30BD0E64100C6D4A0 /* Quest.cpp in Sources */,
+				444EADF40BD0E64100C6D4A0 /* QuestBook.cpp in Sources */,
+				444EADF50BD0E64100C6D4A0 /* QuestEvent.cpp in Sources */,
+				444EADF60BD0E64100C6D4A0 /* QuestListener.cpp in Sources */,
+				444EADF70BD0E64100C6D4A0 /* RulesSubsystem.cpp in Sources */,
+				444EADF80BD0E64100C6D4A0 /* Slot.cpp in Sources */,
+				444EADF90BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp in Sources */,
+				444EADFA0BD0E64100C6D4A0 /* StateSet.cpp in Sources */,
+				444EADFB0BD0E64100C6D4A0 /* Talent.cpp in Sources */,
+				444EADFC0BD0E64100C6D4A0 /* Talentgruppe.cpp in Sources */,
+				444EADFD0BD0E64100C6D4A0 /* TalentStateSet.cpp in Sources */,
+				444EADFE0BD0E64100C6D4A0 /* TimerEvent.cpp in Sources */,
+				444EADFF0BD0E64100C6D4A0 /* TimerEventSource.cpp in Sources */,
+				444EAE000BD0E64100C6D4A0 /* TimerListener.cpp in Sources */,
+				444EAE010BD0E64100C6D4A0 /* TimerManager.cpp in Sources */,
+				444EAE020BD0E64100C6D4A0 /* Weapon.cpp in Sources */,
+				444EAE030BD0E64100C6D4A0 /* ZauberStateSet.cpp in Sources */,
+				444826050BF7B37D00C5A94F /* SelectionHelper.cpp in Sources */,
+				444826060BF7B37D00C5A94F /* Selector.cpp in Sources */,
+				446BF47E0C45329F0013C214 /* CreatureController.cpp in Sources */,
+				446BF47F0C45329F0013C214 /* CreatureControllerManager.cpp in Sources */,
+				446BF4800C45329F0013C214 /* EffectFactory.cpp in Sources */,
+				4404DA830C48D005007B4657 /* stdinc.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		444EAC3B0BD0E46000C6D4A0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EACD00BD0E57100C6D4A0 /* AboutWindow.cpp in Sources */,
+				444EACD10BD0E57100C6D4A0 /* AbstractWindow.cpp in Sources */,
+				444EACD20BD0E57100C6D4A0 /* ActionChoiceWindow.cpp in Sources */,
+				444EACD40BD0E57100C6D4A0 /* CharacterSheetWindow.cpp in Sources */,
+				444EACD50BD0E57100C6D4A0 /* CharacterStateWindow.cpp in Sources */,
+				444EACD60BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp in Sources */,
+				444EACD80BD0E57100C6D4A0 /* CommandMapper.cpp in Sources */,
+				444EACDA0BD0E57100C6D4A0 /* ConfigComponent.cpp in Sources */,
+				444EACDB0BD0E57100C6D4A0 /* Console.cpp in Sources */,
+				444EACDC0BD0E57100C6D4A0 /* ContainerContentWindow.cpp in Sources */,
+				444EACDF0BD0E57100C6D4A0 /* DebugWindow.cpp in Sources */,
+				444EACE10BD0E57100C6D4A0 /* DialogWindow.cpp in Sources */,
+				444EACE30BD0E57100C6D4A0 /* GameLoggerWindow.cpp in Sources */,
+				444EACE40BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp in Sources */,
+				444EACE60BD0E57100C6D4A0 /* GameSettings.cpp in Sources */,
+				444EACE70BD0E57100C6D4A0 /* InfoPopup.cpp in Sources */,
+				444EACE80BD0E57100C6D4A0 /* InGameMenuWindow.cpp in Sources */,
+				444EACE90BD0E57100C6D4A0 /* InputManager.cpp in Sources */,
+				444EACEA0BD0E57100C6D4A0 /* InventoryWindow.cpp in Sources */,
+				444EACEB0BD0E57100C6D4A0 /* ItemDragContainer.cpp in Sources */,
+				444EACEC0BD0E57100C6D4A0 /* JournalWindow.cpp in Sources */,
+				444EACED0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp in Sources */,
+				444EACEE0BD0E57100C6D4A0 /* LogWindow.cpp in Sources */,
+				444EACEF0BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp in Sources */,
+				444EACF00BD0E57100C6D4A0 /* MainMenuWindow.cpp in Sources */,
+				444EACF10BD0E57100C6D4A0 /* MessageWindow.cpp in Sources */,
+				444EACF30BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp in Sources */,
+				444EACF40BD0E57100C6D4A0 /* PlaylistWindow.cpp in Sources */,
+				444EACF50BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp in Sources */,
+				444EACF70BD0E57100C6D4A0 /* SoundConfig.cpp in Sources */,
+				444EACF80BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp in Sources */,
+				444EACF90BD0E57100C6D4A0 /* SubtitleWindow.cpp in Sources */,
+				444EACFA0BD0E57100C6D4A0 /* UiSubsystem.cpp in Sources */,
+				444EACFB0BD0E57100C6D4A0 /* WindowFactory.cpp in Sources */,
+				444EACFC0BD0E57100C6D4A0 /* WindowFadeJob.cpp in Sources */,
+				444EACFD0BD0E57100C6D4A0 /* WindowManager.cpp in Sources */,
+				44D814650BF7B5AD00534175 /* ProgressWindow.cpp in Sources */,
+				44D814660BF7B5AD00534175 /* SaveLoadWindow.cpp in Sources */,
+				446BF49D0C4533BD0013C214 /* CombatControlState.cpp in Sources */,
+				446BF49E0C4533BD0013C214 /* CombatWindow.cpp in Sources */,
+				446BF49F0C4533BD0013C214 /* ControlState.cpp in Sources */,
+				446BF4A00C4533BD0013C214 /* CutsceneControlState.cpp in Sources */,
+				446BF4A10C4533BD0013C214 /* DialogControlState.cpp in Sources */,
+				446BF4A20C4533BD0013C214 /* FreeflightControlState.cpp in Sources */,
+				446BF4A30C4533BD0013C214 /* ItemIconDragContainer.cpp in Sources */,
+				446BF4A40C4533BD0013C214 /* MovementControlState.cpp in Sources */,
+				446BF4A50C4533BD0013C214 /* PropertiesWindow.cpp in Sources */,
+				446BF4D60C453C1D0013C214 /* ItemDescriptionDragContainer.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		8D0C4E8F0486CD37000505A6 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EAAAD0BD0E0C700C6D4A0 /* RastullahMain.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXTargetDependency section */
+		440788020C09D6DD006E496D /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC3D0BD0E46000C6D4A0 /* RlUi */;
+			targetProxy = 440788010C09D6DD006E496D /* PBXContainerItemProxy */;
+		};
+		440788090C09D706006E496D /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 440786100C09D602006E496D /* RlScript */;
+			targetProxy = 440788080C09D706006E496D /* PBXContainerItemProxy */;
+		};
+		444EAC1F0BD0E3A800C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAAB10BD0E0FB00C6D4A0 /* RlCommon */;
+			targetProxy = 444EAC1E0BD0E3A800C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EAC210BD0E3A800C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAB600BD0E2DA00C6D4A0 /* RlCore */;
+			targetProxy = 444EAC200BD0E3A800C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EAC4B0BD0E49900C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC260BD0E3FF00C6D4A0 /* RlAi */;
+			targetProxy = 444EAC4A0BD0E49900C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EAC4D0BD0E49900C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC2E0BD0E42A00C6D4A0 /* RlDialog */;
+			targetProxy = 444EAC4C0BD0E49900C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EAC4F0BD0E49900C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC360BD0E44900C6D4A0 /* RlRules */;
+			targetProxy = 444EAC4E0BD0E49900C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EAC510BD0E49900C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC3D0BD0E46000C6D4A0 /* RlUi */;
+			targetProxy = 444EAC500BD0E49900C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EB1320BD11A3A00C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAAB10BD0E0FB00C6D4A0 /* RlCommon */;
+			targetProxy = 444EB1310BD11A3A00C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EB1360BD11A5C00C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC360BD0E44900C6D4A0 /* RlRules */;
+			targetProxy = 444EB1350BD11A5C00C6D4A0 /* PBXContainerItemProxy */;
+		};
+		444EB1DB0BD159B600C6D4A0 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC360BD0E44900C6D4A0 /* RlRules */;
+			targetProxy = 444EB1DA0BD159B600C6D4A0 /* PBXContainerItemProxy */;
+		};
+		44F21A000BD2142A00EF01CF /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC360BD0E44900C6D4A0 /* RlRules */;
+			targetProxy = 44F219FF0BD2142A00EF01CF /* PBXContainerItemProxy */;
+		};
+		44F21A060BD2143D00EF01CF /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAB600BD0E2DA00C6D4A0 /* RlCore */;
+			targetProxy = 44F21A050BD2143D00EF01CF /* PBXContainerItemProxy */;
+		};
+/* End PBXTargetDependency section */
+
+/* Begin PBXVariantGroup section */
+		02345980000FD03B11CA0E72 /* main.nib */ = {
+			isa = PBXVariantGroup;
+			children = (
+				1870340FFE93FCAF11CA0CD7 /* English */,
+			);
+			name = main.nib;
+			sourceTree = "<group>";
+		};
+		0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				0867D6ABFE840B52C02AAC07 /* English */,
+			);
+			name = InfoPlist.strings;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		440786140C09D603006E496D /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				BUNDLE_LOADER = "";
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/script/include/stdinc.h;
+				INFOPLIST_FILE = "RlScript-Info.plist";
+				INSTALL_PATH = "$(HOME)/Library/Bundles";
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlScript;
+				SHARED_PRECOMPS_DIR = "";
+				WRAPPER_EXTENSION = bundle;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		440786150C09D603006E496D /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				BUNDLE_LOADER = "";
+				COPY_PHASE_STRIP = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/script/include/stdinc.h;
+				INFOPLIST_FILE = "RlScript-Info.plist";
+				INSTALL_PATH = "$(HOME)/Library/Bundles";
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlScript;
+				SHARED_PRECOMPS_DIR = "";
+				WRAPPER_EXTENSION = bundle;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		444EAAB40BD0E11900C6D4A0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/common/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlCommon;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		444EAAB50BD0E11900C6D4A0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/common/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = RlCommon;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		444EAB9B0BD0E31100C6D4A0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/core/include/stdinc.h;
+				HEADER_SEARCH_PATHS = (
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/Library/Frameworks/Ogre.framework/Headers,
+					/Library/Frameworks/OgreNewt.framework/Headers,
+					/Library/Frameworks/OgreCEGUIRenderer.framework/Headers,
+					"/usr/local/include/boost-1_33_1",
+					"/usr/local/lib/ruby/1.8/i686-darwin8.9.1",
+					/usr/local/include/OIS,
+					/usr/local/include/meshmagick,
+				);
+				INSTALL_PATH = /usr/local/lib;
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlCore;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		444EAB9C0BD0E31100C6D4A0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/core/include/stdinc.h;
+				HEADER_SEARCH_PATHS = (
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/Library/Frameworks/Ogre.framework/Headers,
+					/Library/Frameworks/OgreNewt.framework/Headers,
+					/Library/Frameworks/OgreCEGUIRenderer.framework/Headers,
+					"/usr/local/include/boost-1_33_1",
+					"/usr/local/lib/ruby/1.8/i686-darwin8.9.1",
+					/usr/local/include/OIS,
+					/usr/local/include/meshmagick,
+				);
+				INSTALL_PATH = /usr/local/lib;
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = RlCore;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		444EAC290BD0E42A00C6D4A0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/ai/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlAi;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		444EAC2A0BD0E42A00C6D4A0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/ai/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = RlAi;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		444EAC310BD0E44800C6D4A0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/dialog/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlDialog;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		444EAC320BD0E44800C6D4A0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/dialog/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = RlDialog;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		444EAC400BD0E47F00C6D4A0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/rules/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlRules;
+				SHARED_PRECOMPS_DIR = "";
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		444EAC410BD0E47F00C6D4A0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/rules/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				OTHER_LDFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = RlRules;
+				SHARED_PRECOMPS_DIR = "";
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		444EAC430BD0E47F00C6D4A0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/ui/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = libRlUi;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		444EAC440BD0E47F00C6D4A0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = ../engine/ui/include/stdinc.h;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Debug\"";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = RlUi;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		C0E91AC608A95435008D54AB /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "";
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = "$(HOME)/Applications";
+				PRODUCT_NAME = Rastullah;
+				WRAPPER_EXTENSION = app;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		C0E91AC708A95435008D54AB /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = i386;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "";
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = "$(HOME)/Applications";
+				PRODUCT_NAME = Rastullah;
+				WRAPPER_EXTENSION = app;
+			};
+			name = Release;
+		};
+		C0E91ACA08A95435008D54AB /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = i386;
+				FRAMEWORK_SEARCH_PATHS = /Library/Frameworks;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_WARN_ABOUT_MISSING_PROTOTYPES = NO;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_EFFECTIVE_CPLUSPLUS_VIOLATIONS = NO;
+				GCC_WARN_PEDANTIC = NO;
+				GCC_WARN_SIGN_COMPARE = NO;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/Library/Frameworks/Ogre.framework/Headers,
+					/Library/Frameworks/OgreNewt.framework/Headers,
+					/Library/Frameworks/OgreCEGUIRenderer.framework/Headers,
+					"/usr/local/include/boost-1_33_1",
+					"/usr/local/lib/ruby/1.8/i686-darwin8.9.1",
+					/usr/local/include/OIS,
+				);
+				PREBINDING = NO;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+			};
+			name = Debug;
+		};
+		C0E91ACB08A95435008D54AB /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = i386;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_SIGN_COMPARE = NO;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/Library/Frameworks/Ogre.framework/Headers,
+					/Library/Frameworks/OgreNewt.framework/Headers,
+					/Library/Frameworks/OgreCEGUIRenderer.framework/Headers,
+					"/usr/local/include/boost-1_33_1",
+					"/usr/lib/ruby/1.8/universal-darwin8.0",
+					/usr/local/include/OIS,
+				);
+				PREBINDING = NO;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		440786130C09D603006E496D /* Build configuration list for PBXNativeTarget "RlScript" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				440786140C09D603006E496D /* Debug */,
+				440786150C09D603006E496D /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		444EAAB30BD0E11900C6D4A0 /* Build configuration list for PBXNativeTarget "RlCommon" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				444EAAB40BD0E11900C6D4A0 /* Debug */,
+				444EAAB50BD0E11900C6D4A0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		444EAB9A0BD0E31100C6D4A0 /* Build configuration list for PBXNativeTarget "RlCore" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				444EAB9B0BD0E31100C6D4A0 /* Debug */,
+				444EAB9C0BD0E31100C6D4A0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		444EAC280BD0E42A00C6D4A0 /* Build configuration list for PBXNativeTarget "RlAi" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				444EAC290BD0E42A00C6D4A0 /* Debug */,
+				444EAC2A0BD0E42A00C6D4A0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		444EAC300BD0E44800C6D4A0 /* Build configuration list for PBXNativeTarget "RlDialog" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				444EAC310BD0E44800C6D4A0 /* Debug */,
+				444EAC320BD0E44800C6D4A0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		444EAC3F0BD0E47F00C6D4A0 /* Build configuration list for PBXNativeTarget "RlRules" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				444EAC400BD0E47F00C6D4A0 /* Debug */,
+				444EAC410BD0E47F00C6D4A0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		444EAC420BD0E47F00C6D4A0 /* Build configuration list for PBXNativeTarget "RlUi" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				444EAC430BD0E47F00C6D4A0 /* Debug */,
+				444EAC440BD0E47F00C6D4A0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		C0E91AC508A95435008D54AB /* Build configuration list for PBXNativeTarget "Rastullah" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				C0E91AC608A95435008D54AB /* Debug */,
+				C0E91AC708A95435008D54AB /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		C0E91AC908A95435008D54AB /* Build configuration list for PBXProject "Rastullah" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				C0E91ACA08A95435008D54AB /* Debug */,
+				C0E91ACB08A95435008D54AB /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 20286C28FDCF999611CA2CEA /* Project object */;
+}

Added: rl/trunk/Mac/RlScript-Info.plist
===================================================================
--- rl/trunk/Mac/RlScript-Info.plist	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/Mac/RlScript-Info.plist	2007-07-14 10:20:14 UTC (rev 3602)
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>RlScript2</string>
+	<key>CFBundleIdentifier</key>
+	<string>com.yourcompany.RlScript2</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundlePackageType</key>
+	<string>BNDL</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+	<key>CSResourcesFileMapped</key>
+	<string>yes</string>
+</dict>
+</plist>

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/engine/rules/include/Effect.h	2007-07-14 10:20:14 UTC (rev 3602)
@@ -114,7 +114,7 @@
          * @return Returns the time to the next check. If REMOVE is returned, the 
          * effect will be removed, if PERMANENT is returned, the effect lasts permanently.
          **/
-		virtual RL_LONGLONG check();
+		virtual RL_LONGLONG test();
         
         /// Returns the status that is applied to the creature by this effect.
         virtual Status getStatus();

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/engine/rules/src/Effect.cpp	2007-07-14 10:20:14 UTC (rev 3602)
@@ -87,7 +87,7 @@
 		}
 	}
 
-    RL_LONGLONG Effect::check()
+    RL_LONGLONG Effect::test()
     {
       return PERMANENT;
     }

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2007-07-14 10:20:14 UTC (rev 3602)
@@ -48,7 +48,7 @@
             for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
             {
                 int nextCheck;
-                nextCheck = (*effIt)->check();
+                nextCheck = (*effIt)->test();
                 switch (nextCheck)
                 {
                   case Effect::REMOVE:

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-07-14 10:20:14 UTC (rev 3602)
@@ -576,7 +576,7 @@
         virtual void decreaseStufe();
         virtual void enable();
         virtual void disable();
-        virtual RL_LONGLONG check() = 0;
+        virtual RL_LONGLONG test() = 0;
 
         virtual Status getStatus();
         virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);

Modified: rl/trunk/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-07-13 21:26:04 UTC (rev 3601)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2007-07-14 10:20:14 UTC (rev 3602)
@@ -260,8 +260,8 @@
 
 	void AbstractWindow::centerWindow()
 	{
-		Size screenSize = System::getSingleton().getRenderer()->getSize();
-		Size windowSize = mWindow->getPixelSize();
+		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
+		CEGUI::Size windowSize = mWindow->getPixelSize();
 		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
 		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
 		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));



From tanis at mail.berlios.de  Mon Jul 16 22:04:30 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Mon, 16 Jul 2007 22:04:30 +0200
Subject: [Dsa-hl-svn] r3603 - in rl/trunk/engine: ai/include common/include
	core/include dialog/include rules/include script/include ui/include
Message-ID: <200707162004.l6GK4U3t017473@sheep.berlios.de>

Author: tanis
Date: 2007-07-16 22:04:05 +0200 (Mon, 16 Jul 2007)
New Revision: 3603

Modified:
   rl/trunk/engine/ai/include/stdinc.h
   rl/trunk/engine/common/include/stdinc.h
   rl/trunk/engine/core/include/stdinc.h
   rl/trunk/engine/dialog/include/stdinc.h
   rl/trunk/engine/rules/include/stdinc.h
   rl/trunk/engine/script/include/stdinc.h
   rl/trunk/engine/ui/include/stdinc.h
Log:
Fixed line endings.

Modified: rl/trunk/engine/ai/include/stdinc.h
===================================================================
--- rl/trunk/engine/ai/include/stdinc.h	2007-07-14 10:20:14 UTC (rev 3602)
+++ rl/trunk/engine/ai/include/stdinc.h	2007-07-16 20:04:05 UTC (rev 3603)
@@ -48,7 +48,7 @@
 #include <algorithm>
 #include <utility>
 
-#include <OgreCommon.h>
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 #include <OgreString.h>
 #include <OgreStringConverter.h>
@@ -67,10 +67,10 @@
 #include <OgreManualObject.h>
 #include <OgreNode.h>
 #include <OgreCamera.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
 #include <OgreLight.h>
-#include <OgreQuaternion.h>
+#include <OgreQuaternion.h>
 #include <OgreEntity.h>
 #include <OgreMesh.h>
 #include <OgreRenderable.h>

Modified: rl/trunk/engine/common/include/stdinc.h
===================================================================
--- rl/trunk/engine/common/include/stdinc.h	2007-07-14 10:20:14 UTC (rev 3602)
+++ rl/trunk/engine/common/include/stdinc.h	2007-07-16 20:04:05 UTC (rev 3603)
@@ -48,7 +48,7 @@
 #include <algorithm>
 #include <utility>
 
-#include <OgreCommon.h>
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 #include <OgreString.h>
 #include <OgreStringConverter.h>
@@ -67,10 +67,10 @@
 #include <OgreManualObject.h>
 #include <OgreNode.h>
 #include <OgreCamera.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
 #include <OgreLight.h>
-#include <OgreQuaternion.h>
+#include <OgreQuaternion.h>
 #include <OgreEntity.h>
 #include <OgreMesh.h>
 #include <OgreRenderable.h>

Modified: rl/trunk/engine/core/include/stdinc.h
===================================================================
--- rl/trunk/engine/core/include/stdinc.h	2007-07-14 10:20:14 UTC (rev 3602)
+++ rl/trunk/engine/core/include/stdinc.h	2007-07-16 20:04:05 UTC (rev 3603)
@@ -48,7 +48,7 @@
 #include <algorithm>
 #include <utility>
 
-#include <OgreCommon.h>
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 #include <OgreString.h>
 #include <OgreStringConverter.h>
@@ -67,10 +67,10 @@
 #include <OgreManualObject.h>
 #include <OgreNode.h>
 #include <OgreCamera.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
 #include <OgreLight.h>
-#include <OgreQuaternion.h>
+#include <OgreQuaternion.h>
 #include <OgreEntity.h>
 #include <OgreMesh.h>
 #include <OgreRenderable.h>

Modified: rl/trunk/engine/dialog/include/stdinc.h
===================================================================
--- rl/trunk/engine/dialog/include/stdinc.h	2007-07-14 10:20:14 UTC (rev 3602)
+++ rl/trunk/engine/dialog/include/stdinc.h	2007-07-16 20:04:05 UTC (rev 3603)
@@ -48,7 +48,7 @@
 #include <algorithm>
 #include <utility>
 
-#include <OgreCommon.h>
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 #include <OgreString.h>
 #include <OgreStringConverter.h>
@@ -67,10 +67,10 @@
 #include <OgreManualObject.h>
 #include <OgreNode.h>
 #include <OgreCamera.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
 #include <OgreLight.h>
-#include <OgreQuaternion.h>
+#include <OgreQuaternion.h>
 #include <OgreEntity.h>
 #include <OgreMesh.h>
 #include <OgreRenderable.h>

Modified: rl/trunk/engine/rules/include/stdinc.h
===================================================================
--- rl/trunk/engine/rules/include/stdinc.h	2007-07-14 10:20:14 UTC (rev 3602)
+++ rl/trunk/engine/rules/include/stdinc.h	2007-07-16 20:04:05 UTC (rev 3603)
@@ -48,7 +48,7 @@
 #include <algorithm>
 #include <utility>
 
-#include <OgreCommon.h>
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 #include <OgreString.h>
 #include <OgreStringConverter.h>
@@ -67,10 +67,10 @@
 #include <OgreManualObject.h>
 #include <OgreNode.h>
 #include <OgreCamera.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
 #include <OgreLight.h>
-#include <OgreQuaternion.h>
+#include <OgreQuaternion.h>
 #include <OgreEntity.h>
 #include <OgreMesh.h>
 #include <OgreRenderable.h>

Modified: rl/trunk/engine/script/include/stdinc.h
===================================================================
--- rl/trunk/engine/script/include/stdinc.h	2007-07-14 10:20:14 UTC (rev 3602)
+++ rl/trunk/engine/script/include/stdinc.h	2007-07-16 20:04:05 UTC (rev 3603)
@@ -48,7 +48,7 @@
 #include <algorithm>
 #include <utility>
 
-#include <OgreCommon.h>
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 #include <OgreString.h>
 #include <OgreStringConverter.h>
@@ -67,10 +67,10 @@
 #include <OgreManualObject.h>
 #include <OgreNode.h>
 #include <OgreCamera.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
 #include <OgreLight.h>
-#include <OgreQuaternion.h>
+#include <OgreQuaternion.h>
 #include <OgreEntity.h>
 #include <OgreMesh.h>
 #include <OgreRenderable.h>

Modified: rl/trunk/engine/ui/include/stdinc.h
===================================================================
--- rl/trunk/engine/ui/include/stdinc.h	2007-07-14 10:20:14 UTC (rev 3602)
+++ rl/trunk/engine/ui/include/stdinc.h	2007-07-16 20:04:05 UTC (rev 3603)
@@ -48,7 +48,7 @@
 #include <algorithm>
 #include <utility>
 
-#include <OgreCommon.h>
+#include <OgreCommon.h>
 #include <OgreConfigFile.h>
 #include <OgreString.h>
 #include <OgreStringConverter.h>
@@ -67,10 +67,10 @@
 #include <OgreManualObject.h>
 #include <OgreNode.h>
 #include <OgreCamera.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
 #include <OgreLight.h>
-#include <OgreQuaternion.h>
+#include <OgreQuaternion.h>
 #include <OgreEntity.h>
 #include <OgreMesh.h>
 #include <OgreRenderable.h>



From pnyx at mail.berlios.de  Tue Jul 17 10:55:01 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 17 Jul 2007 10:55:01 +0200
Subject: [Dsa-hl-svn] r3604 - in modules: common/materials
	common/materials/programs common/models ruchin/maps
	ruchin/materials ruchin/materials/textures ruchin/models
	ruchin/scripts/maps
Message-ID: <200707170855.l6H8t1Cc027203@sheep.berlios.de>

Author: pnyx
Date: 2007-07-17 10:46:25 +0200 (Tue, 17 Jul 2007)
New Revision: 3604

Added:
   modules/common/materials/programs/Basic_Pixel_Shader_Variation.source
   modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
   modules/common/materials/programs/Basic_Vertex_Shader_ground.material
   modules/ruchin/materials/statue02.material
   modules/ruchin/materials/textures/Statue_02_diffuse.png
   modules/ruchin/materials/textures/Statue_02_normals.png
   modules/ruchin/materials/textures/Statue_02_specular.png
   modules/ruchin/models/House_dummies.mesh
   modules/ruchin/models/Statue_02.mesh
Modified:
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/TerrainVColorBlending.material
   modules/common/materials/waf_kurzschwert_01.material
   modules/common/models/men_human_female.skeleton
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/materials/textures/karte_fliped.jpg
   modules/ruchin/models/Ruchin_map.mesh
   modules/ruchin/models/Ruchin_r.mesh
   modules/ruchin/models/Ruchintest.material
   modules/ruchin/models/Stadtmauer.material
   modules/ruchin/models/Stadtmauer.mesh
   modules/ruchin/scripts/maps/maptest.rb
Log:
Added statue02
Adjusted Ruchin to its new size
Added House Dummies and part r


Added: modules/common/materials/programs/Basic_Pixel_Shader_Variation.source
===================================================================
--- modules/common/materials/programs/Basic_Pixel_Shader_Variation.source	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/common/materials/programs/Basic_Pixel_Shader_Variation.source	2007-07-17 08:46:25 UTC (rev 3604)
@@ -0,0 +1,20 @@
+sampler2D baseMap;
+sampler2D varMap;
+
+struct PS_INPUT 
+{
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+float4 ps_main( PS_INPUT Input ) : COLOR0
+{
+   return ( tex2D( baseMap, Input.Texcoord )* Input.Color * (tex2D(varMap, Input.Texcoord1)*3));
+   
+}
+
+
+

Modified: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -15,8 +15,16 @@
 	entry_point ps_main
 }
 
+vertex_program Basic_Vertex_Shader_SR hlsl
+{
+  source SimpleShadowReceiver.hlsl
+  entry_point vs_main
+  target vs_1_1
+}
+
 material Basic_Vertex_Shader
 {
+	receive_shadows off
 	technique
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
@@ -50,6 +58,17 @@
 				param_named skycolor float4 0.5 0.5 0.5 1.0
 				param_named groundcolor float4 0.10 0.10 0.10 1.0
 			}
+			
+			// HLSL Vertex Shader
+		/*	shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
+			{
+				//Shader Constant: matWorldViewProjection
+				param_named_auto matWorldViewProjection worldviewproj_matrix
+				//Shader Constant: matWorld
+				param_named_auto matWorld world_matrix
+				//Shader Constant: matTextureViewProjection
+				param_named_auto matTextureViewProjection texture_viewproj_matrix
+			}*/
 
 			texture_unit
 			{

Added: modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -0,0 +1,77 @@
+//Effect: Textured
+
+//DirectX 9.0 HLSL Vertex Shader vs_2_0
+vertex_program Basic_Vertex_Shader hlsl
+{
+	source Basic_Vertex_Shader.source
+	target vs_2_0
+	entry_point vs_main
+}
+//DirectX 9.0 HLSL Pixel Shader ps_2_0
+fragment_program Basic_Pixel_Shader_Variation hlsl
+{
+	source Basic_Pixel_Shader_Variation.source
+	target ps_2_0
+	entry_point ps_main
+}
+
+material Basic_Vertex_Shader_Variation
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader_Variation
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			// HLSL Vertex Shader
+			shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
+			{
+				//Shader Constant: matWorldViewProjection
+				param_named_auto matWorldViewProjection worldviewproj_matrix
+				//Shader Constant: matWorld
+				param_named_auto matWorld world_matrix
+				//Shader Constant: matTextureViewProjection
+				param_named_auto matTextureViewProjection texture_viewproj_matrix
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+			texture_unit
+			{
+				texture_alias variation
+
+			}
+		}
+	}
+}

Added: modules/common/materials/programs/Basic_Vertex_Shader_ground.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_ground.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/common/materials/programs/Basic_Vertex_Shader_ground.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -0,0 +1,57 @@
+
+material Basic_Vertex_Shader_Ground
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			receive_shadows off
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Basic_Pixel_Shader
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+			
+			// HLSL Vertex Shader
+			shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
+			{
+				//Shader Constant: matWorldViewProjection
+				param_named_auto matWorldViewProjection worldviewproj_matrix
+				//Shader Constant: matWorld
+				param_named_auto matWorld world_matrix
+				//Shader Constant: matTextureViewProjection
+				param_named_auto matTextureViewProjection texture_viewproj_matrix
+			}
+
+			texture_unit
+			{
+				texture_alias diffuse
+
+			}
+		}
+	}
+}

Modified: modules/common/materials/programs/TerrainVColorBlending.material
===================================================================
--- modules/common/materials/programs/TerrainVColorBlending.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/common/materials/programs/TerrainVColorBlending.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -67,6 +67,21 @@
 														  // fuer scale_Detail4 siehe Oben (Pixelshader)
 								
 			}
+			
+			
+			
+			shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
+			{
+				//Shader Constant: matWorldViewProjection
+				param_named_auto matWorldViewProjection worldviewproj_matrix
+				//Shader Constant: matWorld
+				param_named_auto matWorld world_matrix
+				//Shader Constant: matTextureViewProjection
+				param_named_auto matTextureViewProjection texture_viewproj_matrix
+			}
+			
+			
+			
 			//Texture Schwarz
 			texture_unit
 			{

Modified: modules/common/materials/waf_kurzschwert_01.material
===================================================================
--- modules/common/materials/waf_kurzschwert_01.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/common/materials/waf_kurzschwert_01.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -1,15 +1,5 @@
 
-material waf_kurzschwert_01
+material waf_kurzschwert_01 : Basic_Vertex_Shader
 {
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture waf_kurzschwert_01.dds
-			}
-		}
-	}
+set_texture_alias diffuse waf_kurzschwert_01.dds
 }
\ No newline at end of file

Modified: modules/common/models/men_human_female.skeleton
===================================================================
(Binary files differ)

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/ruchin/maps/ruchin.scene	2007-07-17 08:46:25 UTC (rev 3604)
@@ -91,7 +91,7 @@
 
 		</node>
 		<node name="Ruchin_r" id="13" >
-			<position x="75.659" y="6.61148" z="32.229" />
+			<position x="70.0" y="8.0" z="26.0" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<entity
@@ -302,8 +302,22 @@
 				castsShadow="false"
 			/>
 
-  
+		</node>
+		
+		<node name="Dummies" id="3" >
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Statue_01"
+				id="4"
+				meshFile ="House_dummies.mesh"
+				materialFile="ruchin_terrain.material"
+				castsShadow="false"
+			/>
 
+
+
 		</node>
 	</nodes>
 </scene>
\ No newline at end of file

Added: modules/ruchin/materials/statue02.material
===================================================================
--- modules/ruchin/materials/statue02.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/ruchin/materials/statue02.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -0,0 +1,7 @@
+material Statue_02 : NormalMapMaterialSpecular2Lights1UV
+{
+	set_texture_alias diffusemap Statue_02_diffuse.png
+	set_texture_alias normalmap Statue_02_normals.png
+	set_texture_alias specmap Statue_02_specular.png
+
+}

Added: modules/ruchin/materials/textures/Statue_02_diffuse.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/Statue_02_diffuse.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/materials/textures/Statue_02_normals.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/Statue_02_normals.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/materials/textures/Statue_02_specular.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/Statue_02_specular.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/materials/textures/karte_fliped.jpg
===================================================================
(Binary files differ)

Added: modules/ruchin/models/House_dummies.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/House_dummies.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/models/Ruchin_map.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_r.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchintest.material
===================================================================
--- modules/ruchin/models/Ruchintest.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/ruchin/models/Ruchintest.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -1,83 +1,10 @@
 
-material 03_-_Default
+material Ruchin_l/base : Basic_Vertex_Shader
 {
-	lighting off
-	//receive_shadows off
-	technique
-	{
-		pass
-		{
-		
+set_texture_alias diffuse ruchin_atlasmap.png
 
-			texture_unit
-			{
-				texture karte_fliped.jpg
-			}
-
-			texture_unit
-			{
-				texture LightingmapGround.dds
-			}
-		}
-
-	}
-//	set_texture_alias DiffuseMap karte_fliped.jpg
-			
 }
 
-
-
-material Ruchin_l/base
-{
-
-	lighting off
-	receive_shadows off
-	technique
-	{
-		pass
-		{
-		lighting off
-			ambient 0.8 0.8 0.8 1
-			//ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
-
-			texture_unit
-			{
-				colour_op_ex subtract src_current src_manual 0.2 0.2 0.2
-			}
-			diffuse vertexcolour
-			
-			texture_unit
-			{
-				texture_alias 1
-				texture Ruchin_ao_l.dds
-				tex_coord_set 1
-			}
-			
-			
-			
-			texture_unit
-			{
-				texture_alias 0
-				texture ruchin_atlasmap.dds
-				colour_op_ex modulate_x2 src_texture src_current
-				colour_op_multipass_fallback dest_colour zero
-			}
-
-			
-		}
-
-	}
-
-
-}
-
 material Ruchin_l/glas :Ruchin_l/base
 {
 	technique
@@ -94,54 +21,10 @@
 
 
 
-material 04_-_Default
+material 04_-_Default : Basic_Vertex_Shader
 {
+set_texture_alias diffuse ruchin_atlasmap.png
 
-	//lighting off
-	receive_shadows off
-	technique
-	{
-		pass
-		{
-			ambient 0.8 0.8 0.8 1
-			//ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
-
-			texture_unit
-			{
-				colour_op_ex subtract src_current src_manual 0.2 0.2 0.2
-			}
-			diffuse vertexcolour
-			
-			texture_unit
-			{
-				texture_alias 1
-				texture LightingmapBlockS3.dds
-				tex_coord_set 1
-			}
-			
-			
-			
-			texture_unit
-			{
-				texture_alias 0
-				texture ruchin_atlasmap.dds
-				colour_op_ex modulate_x2 src_texture src_current
-				colour_op_multipass_fallback dest_colour zero
-			}
-
-			
-		}
-
-	}
-
-
 }
 
 
@@ -219,183 +102,42 @@
 }
 
 
-material Ruchin_map
+material Ruchin_map : Basic_Vertex_Shader_Ground
 {
-	//lighting off
-	//receive_shadows off
-	technique
-	{
-		pass
-		{
-			//ambient 0.5 0.5 0.5 1
-			ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
+set_texture_alias diffuse karte_fliped.jpg
 
-			texture_unit
-			{
-				colour_op_ex subtract src_current src_manual 0.2 0.2 0.2
-			}
-			diffuse vertexcolour
-			
-			texture_unit
-			{
-				texture_alias 1
-				texture Ruchin_ao_Ground.dds
-				tex_coord_set 1
-			}
-			
-			
-			
-			texture_unit
-			{
-				texture_alias 0
-				texture karte_fliped.jpg
-				colour_op_ex modulate_x2 src_texture src_current
-				colour_op_multipass_fallback dest_colour zero
-			}
+} 
 
-			
-		}
 
-	}
-
-}
-
-material Ruchin_s : NormalMapMaterial2LightsAO2UV
+material Ruchin_s : Basic_Vertex_Shader
 {
-	
+set_texture_alias diffuse ruchin_atlasmap.png
 
-
-			set_texture_alias normalmap ruchin_atlasmap_normal.png
-			set_texture_alias diffusemap ruchin_atlasmap.png
-			set_texture_alias aomap Ruchin_ao_sp.dds
-
 }
 
-material Ruchin_p
+material Ruchin_p : Basic_Vertex_Shader
 {
-	//lighting off
-	receive_shadows off
-	technique
-	{
-		pass
-		{
-			ambient 0.8 0.8 0.8 1
-			//ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
+set_texture_alias diffuse ruchin_atlasmap.png
 
-			texture_unit
-			{
-				colour_op_ex subtract src_current src_manual 0.2 0.2 0.2
-			}
-			diffuse vertexcolour
-			
-			texture_unit
-			{
-				texture_alias 1
-				texture Ruchin_ao_sp.dds
-				tex_coord_set 1
-			}
-			
-			
-			
-			texture_unit
-			{
-				texture_alias 0
-				texture ruchin_atlasmap.dds
-				colour_op_ex modulate_x2 src_texture src_current
-				colour_op_multipass_fallback dest_colour zero
-			}
-
-			
-		}
-
-	}
 }
 
-material Ruchin/base
+material Ruchin/base : Basic_Vertex_Shader
 {
+set_texture_alias diffuse ruchin_atlasmap.png
 
-//lighting off
-	receive_shadows off
-	
-	technique
-	{
-		lod_index 0
-		pass
-		{
-			ambient 0.8 0.8 0.8 1
-			//ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
-						
-			texture_unit
-			{
-				texture ruchin_atlasmap.dds
-			}
-
-			
-		}
-
-	}
 }
 
-material base : NormalMapMaterialSpecular2LightsAO2UV
+material base : Basic_Vertex_Shader
 {
-	
+set_texture_alias diffuse ruchin_atlasmap.png
 
-
-			set_texture_alias normalmap ruchin_atlas_normal.png
-			set_texture_alias diffusemap ruchin_atlasmap.png
-			set_texture_alias specmap ruchin_atlas_spec.png
-			set_texture_alias aomap ruchin_AO_s_n.png
-
 }
 
 
-material Ruchin/Schiefer
+material Ruchin/Schiefer : Basic_Vertex_Shader
 {
-//lighting off
-	receive_shadows off
-	technique
-	{
-		pass
-		{
-			ambient 0.8 0.8 0.8 1
-			//ambient 0.0 0.0 0.0 1
-			//ambient vertexcolour
- 
-			//specular 0 0 0 1 10
-			
-			//diffuse 0.9 0.9 0.9 
-			//emissive 0.105882 0.105882 0.105882 1
-			//emissive vertexcolour
+set_texture_alias diffuse arc_schieferdach.png
 
-			texture_unit
-			{
-				texture arc_schieferdach.png
-			}
-		}
-
-	}
-
 }
 
 material Ruchin/glas

Modified: modules/ruchin/models/Stadtmauer.material
===================================================================
--- modules/ruchin/models/Stadtmauer.material	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/ruchin/models/Stadtmauer.material	2007-07-17 08:46:25 UTC (rev 3604)
@@ -1,32 +1,11 @@
 
-material Ruchin_Stadtmauer/Wand
+material Ruchin_Stadtmauer/Wand : Basic_Vertex_Shader_Variation
 {
-	technique
-	{
-		pass
-		{
-			ambient 0.341176 0.341176 0.341176 1
-			specular 0 0 0 1 10
 
-			texture_unit
-			{
-				texture_alias 0
-				texture Ruchin_stadtmauer.png
-				colour_op_ex modulate_x2 src_texture src_current
-				colour_op_multipass_fallback dest_colour zero
-			}
+set_texture_alias diffuse Ruchin_stadtmauer.png
 
-			texture_unit
-			{
-				texture_alias 1
-				texture Ruchin_stadtmauer_variation.png
-				tex_coord_set 1
-				colour_op_ex modulate_x2 src_texture src_current
-				colour_op_multipass_fallback dest_colour zero
-			}
-		}
+set_texture_alias variation Ruchin_stadtmauer_variation.png
 
-	}
 
 }
 

Modified: modules/ruchin/models/Stadtmauer.mesh
===================================================================
(Binary files differ)

Added: modules/ruchin/models/Statue_02.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/Statue_02.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/scripts/maps/maptest.rb
===================================================================
--- modules/ruchin/scripts/maps/maptest.rb	2007-07-16 20:04:05 UTC (rev 3603)
+++ modules/ruchin/scripts/maps/maptest.rb	2007-07-17 08:46:25 UTC (rev 3604)
@@ -13,7 +13,7 @@
 $SCRIPT.log("Tageslicht erstellen..");
 sunlight = $AM.createLightActor("sunlight", LightObject::LT_DIRECTIONAL);
 sunlight.getControlledObject().setDirection(-0.17101, -0.873647, 0.969846);
-sunlight.getControlledObject().setCastShadows(false);
+sunlight.getControlledObject().setCastShadows(true);
 
 sunlight.getControlledObject().setDiffuseColour(0.8,0.8,0.8);
 sunlight.getControlledObject().setSpecularColour(1.0,1.0,1.0);



From tanis at mail.berlios.de  Tue Jul 17 16:42:30 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Tue, 17 Jul 2007 16:42:30 +0200
Subject: [Dsa-hl-svn] r3605 - in rl/trunk/engine: ai/include ai/src
	common/include core core/include core/src ui/include ui/src
Message-ID: <200707171442.l6HEgUU0002683@sheep.berlios.de>

Author: tanis
Date: 2007-07-17 16:41:51 +0200 (Tue, 17 Jul 2007)
New Revision: 3605

Added:
   rl/trunk/engine/core/include/CoreMessages.h
   rl/trunk/engine/core/include/MessageObject.h
   rl/trunk/engine/core/include/MessagePump.h
   rl/trunk/engine/core/include/MessageType.h
   rl/trunk/engine/core/src/MessagePump.cpp
Modified:
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/common/include/FixRubyHeaders.h
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/World.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/Makefile.am
   rl/trunk/engine/core/src/World.cpp
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/src/UiSubsystem.cpp
Log:
New shiny MessagePump for internal message handling. Will eventually replace all listener interfaces. SceneChangeListener is replaced now.

Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -17,7 +17,10 @@
 #define __AiSubsystem_H__
 
 #include <OgreSingleton.h>
+
 #include "AiPrerequisites.h"
+
+#include "MessagePump.h"
 #include "World.h"
 
 namespace rl
@@ -33,9 +36,7 @@
 	/** Central core of AI
 	 * Handles creation of all AI related object Managers.
 	 */
-	class _RlAiExport AiSubsystem 
-		: public Ogre::Singleton<AiSubsystem>,
-		  public SceneChangeListener
+	class _RlAiExport AiSubsystem : public Ogre::Singleton<AiSubsystem>
 	{
 	public:
 		//! default constructor
@@ -53,11 +54,11 @@
 
 		/** Trigger function triggered after scene load.
 		 */
-		virtual void onAfterSceneLoaded();
+		virtual bool onAfterSceneLoaded();
 
 		/** Trigger function triggered before scene load.
 		 */
-        virtual void onBeforeClearScene();
+        virtual bool onBeforeClearScene();
 
 		/** Creates an named LandmarkPath.
 		 * @param name the path's name
@@ -101,6 +102,9 @@
 
 		std::map<Ogre::String, LandmarkPath*> mLandmarkPaths;
 		std::map<Ogre::String, Landmark*> mLandmarks;
+
+	    MessagePump::ScopedConnection mSceneLoadedConnection;
+	    MessagePump::ScopedConnection mSceneClearingConnection;
 	};
 
 	inline AiWorld* AiSubsystem::getWorld()

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-07-17 14:41:51 UTC (rev 3605)
@@ -19,6 +19,7 @@
 
 #include "AiWorld.h"
 #include "AgentManager.h"
+#include "CoreMessages.h"
 #include "CoreSubsystem.h"
 #include "GameLoop.h"
 #include "Landmark.h"
@@ -46,7 +47,6 @@
 
 AiSubsystem::~AiSubsystem(void)
 {
-    CoreSubsystem::getSingletonPtr()->getWorld()->removeSceneChangeListener(this);
 	GameLoop::getSingleton().removeTask(AgentManager::getSingletonPtr());
     AgentManager::getSingleton().removeAllAgents();
     mWorld->removeAllObstacles();
@@ -63,43 +63,34 @@
 	mWayPointGraphManager = new WayPointGraphManager();
     mWorld = new AiWorld();
 
-    CoreSubsystem::getSingletonPtr()->getWorld()->addSceneChangeListener(this);
+    mSceneLoadedConnection =
+        MessagePump::getSingleton().addMessageHandler<MessageType_SceneLoaded>(
+		    boost::bind(&AiSubsystem::onAfterSceneLoaded, this));
+    mSceneClearingConnection =
+        MessagePump::getSingleton().addMessageHandler<MessageType_SceneClearing>(
+		    boost::bind(&AiSubsystem::onBeforeClearScene, this));
+
     GameLoop::getSingleton().addTask(AgentManager::getSingletonPtr(), GameLoop::TG_LOGIC);
 }
 
-void AiSubsystem::onBeforeClearScene()
+bool AiSubsystem::onBeforeClearScene()
 {
     AgentManager::getSingleton().removeAllAgents();
     mWorld->removeAllObstacles();
+
+    return true;
 }
 
 
 
-void AiSubsystem::onAfterSceneLoaded()
+bool AiSubsystem::onAfterSceneLoaded()
 {
     // newton world hinzuf?gen
     Obstacle *newtonWorld = new NewtonWorldAsObstacle;
     newtonWorld->setSeenFrom(AbstractObstacle::both);
     mWorld->addObstacle(newtonWorld);
 
-    // ?u?ere grenzen einf?gen
-    //PhysicsManager
-/*
-//  create an obstacle as bounding box of the walkarea for npcs
-//  this should be accessable through scripting, the Obstacles should have names
-//  for easier access
-    BoxObstacle* o = new BoxObstacle(25,50,25);
-    o->setSeenFrom(AbstractObstacle::inside);
-    o->setPosition(Vec3(-40.0f,-10.0f, 0.0f));
-    o->setForward(0,0,-1);
-    addObstacle(o);
-
-    o = new BoxObstacle(2,50,2);
-    o->setSeenFrom(AbstractObstacle::outside);
-    o->setPosition(Vec3(-31.5f,-10.0f, -3.5f));
-    o->setForward(0,0,-1);
-    addObstacle(o);
-*/
+    return true;
 }
 
 Landmark* AiSubsystem::createLandmark(const Ogre::String& name, const Ogre::Vector3& position)

Modified: rl/trunk/engine/common/include/FixRubyHeaders.h
===================================================================
--- rl/trunk/engine/common/include/FixRubyHeaders.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/common/include/FixRubyHeaders.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -20,8 +20,9 @@
  * Diese Datei muss nach einem Ruby-Header inkludiert werden, m?glicherweise auch
  * noch davor, um vorherige Makros zu l?schen.
  */
+#undef accept
+#undef bind
 #undef close
-#undef bind
 #undef select
 #undef shutdown
 #undef snprintf

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-07-17 14:41:51 UTC (rev 3605)
@@ -400,6 +400,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\CoreMessages.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\CorePrerequisites.h"
 				>
 			</File>
@@ -496,6 +500,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\MessageObject.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\MessagePump.h"
+				>
+			</File>
+			<File
+				RelativePath=".\include\MessageType.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\MovableText.h"
 				>
 			</File>
@@ -765,6 +781,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\MessagePump.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\MovableText.cpp"
 				>
 			</File>

Added: rl/trunk/engine/core/include/CoreMessages.h
===================================================================
--- rl/trunk/engine/core/include/CoreMessages.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/include/CoreMessages.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -0,0 +1,37 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Rl_CoreMessages_H__
+#define __Rl_CoreMessages_H__
+
+#include "CorePrerequisites.h"
+#include "MessageType.h"
+
+namespace rl
+{
+    enum CoreMessageTypeIds
+    {
+        RLMSG_SCENE_LOADED = 0x01000001,
+        RLMSG_SCENE_CLEARING = 0x01000002
+    };
+
+    /// Message sent right after a scene has been loaded.
+    typedef MessageType<RLMSG_SCENE_LOADED> MessageType_SceneLoaded;
+
+    /// Message sent just before a scene will be cleared.
+    typedef MessageType<RLMSG_SCENE_CLEARING> MessageType_SceneClearing;
+}
+#endif

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -1,169 +1,171 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __CoreSubsystem_H__
-#define __CoreSubsystem_H__
-
-
-#include <OgreSingleton.h>
-#include <OgreString.h>
-#include <OgreRoot.h>
-#include <OgreTimer.h>
-#include <map>
-
-#include "EventSource.h"
-#include "EventCaster.h"
-#include "CorePrerequisites.h"
-
-namespace rl {
-
-class RubyInterpreter;
-class World;
-class CoreEvent;
-class CoreEventListener;
-class Actor;
-class ContentModule;
-class ScriptWrapper;
-class PhysicsManager;
-class GameLoop;
-class AnimationManager;
-class ActorManager;
-class GameEventManager;
-class XmlResourceManager;
-class SoundManager;
-class DebugVisualsManager;
-class JobScheduler;
-class ZoneManager;
-
-typedef _RlCoreExport std::map<Ogre::String, ContentModule*> ModuleMap;
-
-/** CoreSubsystem.
-    @remarks
-        It follows the Singleton Pattern,
-        and initialises the game context.
-*/
-class _RlCoreExport CoreSubsystem : public Ogre::Singleton<CoreSubsystem>, public virtual EventSource
-{
-public:
-    /** Default Constructor */
-    CoreSubsystem();
-    /** Default Deconstructor */
-    virtual ~CoreSubsystem();
-
-    /** Starts the Game */
-    void startCore();
-
-    /** Renders one frame (for internal use) */
-    void renderOneFrame();
-
-    World* getWorld();
-    void loadMap(const Ogre::String type, const Ogre::String filename,
-        const Ogre::String module);
-
-    RubyInterpreter* getRubyInterpreter();
-
-    ContentModule* getActiveAdventureModule() const;
-    ContentModule* getModule(const Ogre::String& moduleId) const;
-    const ModuleMap& getAllModules() const;
-    void startAdventureModule(ContentModule* module);
-    void setDefaultActiveModule(const Ogre::String& moduleId);
-    const Ogre::String& getDefaultActiveModule() const;
-    void registerModule(ContentModule* module);
-
-    void setDeveloperMode(bool developerMode);
-    bool getDeveloperMode() const;
-
-    /// Returns time since game started in Milliseconds.
-    /// Uses GameLoop::getClock internally, function is here to allow access from ruby.
-    unsigned long getClock();
-
-    /** Saves a timestamped png Screenshot
-        @param sName The filename (extended with the timestamp)
-    */
-    void makeScreenshot(const Ogre::String& sName);
-
-    void addCoreEventListener(CoreEventListener* listener);
-    void removeCoreEventListener(CoreEventListener* listener);
-
-    void setScheme(const Ogre::String& schemeName);
-
-    bool isInitialized() const;
-
-    Ogre::String getEngineVersionString() const;
-    Ogre::String getEngineVersionName() const;
-    long         getEngineBuildNumber() const;
-
-    /**
-     * Retrieves a pointer to the current render window.
-     *
-     * @return pointer to render window
-     */
-    Ogre::RenderWindow* getRenderWindow();
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __CoreSubsystem_H__
+#define __CoreSubsystem_H__
+
+
+#include <OgreSingleton.h>
+#include <OgreString.h>
+#include <OgreRoot.h>
+#include <OgreTimer.h>
+#include <map>
+
+#include "EventSource.h"
+#include "EventCaster.h"
+#include "CorePrerequisites.h"
+
+namespace rl {
+
+class RubyInterpreter;
+class World;
+class CoreEvent;
+class CoreEventListener;
+class Actor;
+class ContentModule;
+class ScriptWrapper;
+class PhysicsManager;
+class MessagePump;
+class GameLoop;
+class AnimationManager;
+class ActorManager;
+class GameEventManager;
+class XmlResourceManager;
+class SoundManager;
+class DebugVisualsManager;
+class JobScheduler;
+class ZoneManager;
+
+typedef _RlCoreExport std::map<Ogre::String, ContentModule*> ModuleMap;
+
+/** CoreSubsystem.
+    @remarks
+        It follows the Singleton Pattern,
+        and initialises the game context.
+*/
+class _RlCoreExport CoreSubsystem : public Ogre::Singleton<CoreSubsystem>, public virtual EventSource
+{
+public:
+    /** Default Constructor */
+    CoreSubsystem();
+    /** Default Deconstructor */
+    virtual ~CoreSubsystem();
+
+    /** Starts the Game */
+    void startCore();
+
+    /** Renders one frame (for internal use) */
+    void renderOneFrame();
+
+    World* getWorld();
+    void loadMap(const Ogre::String type, const Ogre::String filename,
+        const Ogre::String module);
+
+    RubyInterpreter* getRubyInterpreter();
+
+    ContentModule* getActiveAdventureModule() const;
+    ContentModule* getModule(const Ogre::String& moduleId) const;
+    const ModuleMap& getAllModules() const;
+    void startAdventureModule(ContentModule* module);
+    void setDefaultActiveModule(const Ogre::String& moduleId);
+    const Ogre::String& getDefaultActiveModule() const;
+    void registerModule(ContentModule* module);
+
+    void setDeveloperMode(bool developerMode);
+    bool getDeveloperMode() const;
+
+    /// Returns time since game started in Milliseconds.
+    /// Uses GameLoop::getClock internally, function is here to allow access from ruby.
+    unsigned long getClock();
+
+    /** Saves a timestamped png Screenshot
+        @param sName The filename (extended with the timestamp)
+    */
+    void makeScreenshot(const Ogre::String& sName);
+
+    void addCoreEventListener(CoreEventListener* listener);
+    void removeCoreEventListener(CoreEventListener* listener);
+
+    void setScheme(const Ogre::String& schemeName);
+
+    bool isInitialized() const;
+
+    Ogre::String getEngineVersionString() const;
+    Ogre::String getEngineVersionName() const;
+    long         getEngineBuildNumber() const;
+
+    /**
+     * Retrieves a pointer to the current render window.
+     *
+     * @return pointer to render window
+     */
+    Ogre::RenderWindow* getRenderWindow();
+
 	/// Sets the pause state of the game
 	/// @param paused <code>true</code> if the game should be paused, <code>false</code> if it should be continued
 	void setPaused(bool paused);
-
-private:
-    World* mWorld;
-    RubyInterpreter* mRubyInterpreter;
-    ModuleMap mModules;
-    ContentModule* mActiveAdventureModule;
-    Ogre::String mDefaultActiveModule;
-    Ogre::RenderWindow* mRenderWindow;            //!< Render window for OGRE
-
-    RL_LONGLONG mClockStartTime;
-
-    bool mDeveloperMode;
-    bool mInitialized;
-    EventCaster<CoreEvent> mCoreEventCaster;
-    std::vector<Ogre::Technique*> mDefaultTechniques;
-
-    // The singletons of this subsystem
-    Ogre::Root* mOgreRoot;
-    ScriptWrapper* mScriptWrapper;
-    XmlResourceManager* mXmlResourceManager;
-    PhysicsManager* mPhysicsManager;
-    GameLoop* mGameLoop;
-    AnimationManager* mAnimationManager;
-    ActorManager* mActorManager;
-    GameEventManager* mGameEventManager;
-    SoundManager* mSoundManager;
-    DebugVisualsManager* mDebugVisualsManager;
-    JobScheduler* mJobScheduler;
-	ZoneManager* mZoneManager;
-
-    /** Runs the setup methods  */
-    bool initializeCoreSubsystem();
-
-    /** Loads all needed ressources */
-    void initializeResources();
-
-    void loadPlugins();
-    void unloadPlugins();
-
-    /**
-     * Sammelt alle Default-Techniques, um sie sp?ter bei jedem aktivierten Scheme
-     * benutzen zu k?nnen
-     */
-    void updateDefaultScheme();
-
-    void loadModule(ContentModule* module);
-};
-
-}
-#endif
-
+
+private:
+    World* mWorld;
+    RubyInterpreter* mRubyInterpreter;
+    ModuleMap mModules;
+    ContentModule* mActiveAdventureModule;
+    Ogre::String mDefaultActiveModule;
+    Ogre::RenderWindow* mRenderWindow;            //!< Render window for OGRE
+
+    RL_LONGLONG mClockStartTime;
+
+    bool mDeveloperMode;
+    bool mInitialized;
+    EventCaster<CoreEvent> mCoreEventCaster;
+    std::vector<Ogre::Technique*> mDefaultTechniques;
+
+    // The singletons of this subsystem
+    Ogre::Root* mOgreRoot;
+    ScriptWrapper* mScriptWrapper;
+    XmlResourceManager* mXmlResourceManager;
+    PhysicsManager* mPhysicsManager;
+    MessagePump* mMessagePump;
+    GameLoop* mGameLoop;
+    AnimationManager* mAnimationManager;
+    ActorManager* mActorManager;
+    GameEventManager* mGameEventManager;
+    SoundManager* mSoundManager;
+    DebugVisualsManager* mDebugVisualsManager;
+    JobScheduler* mJobScheduler;
+	ZoneManager* mZoneManager;
+
+    /** Runs the setup methods  */
+    bool initializeCoreSubsystem();
+
+    /** Loads all needed ressources */
+    void initializeResources();
+
+    void loadPlugins();
+    void unloadPlugins();
+
+    /**
+     * Sammelt alle Default-Techniques, um sie sp?ter bei jedem aktivierten Scheme
+     * benutzen zu k?nnen
+     */
+    void updateDefaultScheme();
+
+    void loadModule(ContentModule* module);
+};
+
+}
+#endif
+

Added: rl/trunk/engine/core/include/MessageObject.h
===================================================================
--- rl/trunk/engine/core/include/MessageObject.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/include/MessageObject.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -0,0 +1,157 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Rl_MessageObject_H__
+#define __Rl_MessageObject_H__
+
+#include "CorePrerequisites.h"
+
+#include <boost/function.hpp>
+#include <boost/bind.hpp>
+#include <boost/bind/placeholders.hpp>
+
+namespace rl
+{
+
+    //This class is a dummy that indicated that a parameter is not used
+    class MessageObject_EmptyParam 
+    {};
+
+    template<int MessageTypeId,
+        typename Param1 = MessageObject_EmptyParam,
+        typename Param2 = MessageObject_EmptyParam>
+    class MessageType;
+
+    class MessageObjectBase
+    {
+    public:
+        virtual ~MessageObjectBase() {}
+        virtual int getMessageTypeId() = 0;
+    };
+
+    //MessageObject with 0 parameters
+    class MessageObject_0 : public MessageObjectBase
+    {
+    public:
+        typedef boost::function< bool () > HandlerType;
+
+        template<typename Handler>
+        bool Invoke(const Handler& handler)
+        {
+            return handler();
+        }
+    };
+
+    //MessageObject with 1 parameters
+    template<typename _Param1>
+    class MessageObject_1 : public MessageObjectBase
+    {
+    public:
+        typedef _Param1 Param1;
+        Param1 param1;
+
+        typedef boost::function< bool (const Param1& p1) > HandlerType;
+
+        template<typename Handler>
+        bool Invoke(const Handler& handler)
+        {
+            return handler(param1);
+        }
+    };
+
+    //MessageObject with 2 parameters
+    template<typename _Param1, typename _Param2>
+    class MessageObject_2 : public MessageObjectBase
+    {
+    public:
+        typedef _Param1 Param1;
+        typedef _Param2 Param2;
+
+        Param1 param1;
+        Param2 param2;
+
+        typedef boost::function< bool (const Param1& p1, const Param2& p2) > HandlerType;
+
+        template<typename Handler>
+        bool Invoke(const Handler& handler)
+        {
+            return handler(param1, param2);
+        }
+    };
+
+    //forward declaration of MessageObject_x
+    //It is implemented in several specializations, 
+    //each derives from another MessageObject base 
+    //to select the correct parameter count
+    template<int _MessageTypeId, typename Param1, typename Param2>
+    class MessageObject_x;
+
+    template<int _MessageTypeId>
+    class MessageObject_x<_MessageTypeId, MessageObject_EmptyParam, MessageObject_EmptyParam>
+        : public MessageObject_0
+    {
+    public:
+        static MessageObject_x* Build()
+        {
+            MessageObject_x* msgObj = new MessageObject<_MessageTypeId>();
+            return msgObj;
+        }
+    };
+
+    template<int _MessageTypeId, typename Param1>
+    class MessageObject_x<_MessageTypeId, Param1, MessageObject_EmptyParam>
+        : public MessageObject_1<Param1>
+    {
+    public:
+        static MessageObject_x* Build(const Param1& p1)
+        {
+            MessageObject_x* msgObj = new MessageObject<_MessageTypeId, Param1>();
+            msgObj->param1 = p1;
+            return msgObj;
+        }
+    };
+
+    template<int _MessageTypeId, typename Param1, typename Param2>
+    class MessageObject_x : public MessageObject_2<Param1, Param2>
+    {
+    public:
+        static MessageObject_x* Build(const Param1& p1, const Param2& p2)
+        {
+            MessageObject_x* msgObj = new MessageObject<_MessageTypeId, Param1, Param2>();
+            msgObj->param1 = p1;
+            msgObj->param2 = p2;
+            return msgObj;
+        }
+    };
+
+    /////////////////////////////////////////////////////
+
+    //The final MessageObject. The real implementation is chosen through the given template parameters
+    template<int _MessageTypeId,
+        typename Param1 = MessageObject_EmptyParam,
+        typename Param2 = MessageObject_EmptyParam>
+    class MessageObject : public MessageObject_x<_MessageTypeId, Param1, Param2>
+    {
+    public:
+        virtual int getMessageTypeId()
+        {
+            return _MessageTypeId;
+        }
+    };
+
+}
+
+#endif

Added: rl/trunk/engine/core/include/MessagePump.h
===================================================================
--- rl/trunk/engine/core/include/MessagePump.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/include/MessagePump.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -0,0 +1,269 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Rl_MessagePump_H__
+#define __Rl_MessagePump_H__
+
+#include "CorePrerequisites.h"
+
+#include "MessageType.h"
+#include "GameTask.h"
+
+#include <OgreSingleton.h>
+
+#include <map>
+#include <queue>
+
+#include <boost/noncopyable.hpp>
+
+namespace rl
+{
+
+    class MessageHandlerWrapperBase
+    {
+    public:
+        virtual ~MessageHandlerWrapperBase() {}
+        virtual bool Invoke(MessageObjectBase* obj) = 0;
+    };
+
+    template<class _MessageType>
+    class MessageHandlerWrapper : public MessageHandlerWrapperBase
+    {
+    public:
+        typedef typename _MessageType::MessageObjectType MessageObjectType;
+        typedef typename _MessageType::HandlerType HandlerType;
+
+        MessageHandlerWrapper(const HandlerType& handler)
+            : mHandler(handler)
+        {
+        }
+
+        virtual bool Invoke(MessageObjectBase* obj)
+        {
+            MessageObjectType* obj2 = (MessageObjectType*)obj;
+            return obj2->Invoke(mHandler);
+        }
+
+    private:
+        HandlerType mHandler;
+    };
+
+    class _RlCoreExport MessagePump : public GameTask, public Ogre::Singleton<MessagePump>
+    {
+    public:
+        class Connection
+        {
+            friend class MessagePump;
+        public:
+            Connection()
+                : connectionId(-1), pump(NULL)
+            {}
+            void disconnect()
+            {
+                if(pump && connectionId != -1)
+                    pump->disconnectHandler(connectionId);
+            }
+        private:
+            MessagePump* pump;
+            int connectionId;
+        };
+
+        class ScopedConnection : boost::noncopyable
+        {
+        public:
+            ScopedConnection()
+            {}
+            ScopedConnection(const Connection& conn)
+                : mConnection(conn)
+            {}
+            ScopedConnection& operator =(const Connection& conn)
+            {
+                mConnection.disconnect();
+                mConnection = conn;
+                return *this;
+            }
+            ~ScopedConnection()
+            {
+                mConnection.disconnect();
+            }
+        private:
+            Connection mConnection;
+        };
+
+    private:
+        struct MessageHandlerMapEntry
+        {
+            int connectionId;
+            MessageHandlerWrapperBase* handlerWrapper;
+        };
+
+        typedef std::vector<MessageHandlerMapEntry> MessageHandlerMapEntries;
+        typedef std::map<int, MessageHandlerMapEntries*> MessageHandlerMap;
+        typedef std::queue<MessageObjectBase*> MessageQueue;
+
+    public:
+        MessagePump() : mNextConnectionId(0) {}
+
+        template<typename _MessageType>
+        Connection addMessageHandler( const typename _MessageType::HandlerType& handler )
+        {
+            MessageHandlerWrapper<_MessageType>* wrapper =
+                new MessageHandlerWrapper<_MessageType>(handler);
+
+            MessageHandlerMapEntries* entries = getOrCreateMapEntries(_MessageType::MessageTypeId);
+            MessageHandlerMapEntry entry = {mNextConnectionId++, wrapper};
+            entries->push_back(entry);
+
+            Connection con;
+            con.pump = this;
+            con.connectionId = entry.connectionId;
+            return con;
+        }
+
+        /*
+        * sendMessage and postMessage is implemented for all possible parameter counts
+        * Thanks to the idea of SFINAE, the compiler will choose 
+        * the correct implementation for all MessageTypes at compile time
+        *
+        * sendMessage processes the message immediatly, while postMessage delays the 
+        * processing to a later frame
+        */
+        template<typename _MessageType>
+        bool sendMessage()
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
+            return doSend(obj);
+        }
+
+        template<typename _MessageType>
+        bool sendMessage(const typename _MessageType::MessageObjectType::Param1& p1)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1);
+            return doSend(obj);
+        }
+
+        template<typename _MessageType>
+        bool sendMessage(const typename _MessageType::MessageObjectType::Param1& p1,
+            const typename _MessageType::MessageObjectType::Param2& p2)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1, p2);
+            return doSend(obj);
+        }
+
+        ////////////////////////////////
+
+        template<typename _MessageType>
+        void postMessage()
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
+            doPost(obj);
+        }
+
+        template<typename _MessageType>
+        void postMessage(const typename _MessageType::MessageObjectType::Param1& p1)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
+            doPost(obj);
+        }
+
+        template<typename _MessageType>
+        void postMessage(const typename _MessageType::MessageObjectType::Param1& p1,
+            const typename _MessageType::MessageObjectType::Param2& p2)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
+            doPost(obj);
+        }
+
+        void sendPending()
+        {
+            while(!mMessageQueue.empty())
+            {
+                doSend(mMessageQueue.front());
+                mMessageQueue.pop();
+            }
+        }
+
+        // overloads from GameTask
+
+		virtual void run(Ogre::Real elapsedTime);
+
+        virtual const Ogre::String& getName() const;
+
+    private:
+        MessageHandlerMapEntries* getOrCreateMapEntries(int id) 
+        {
+            MessageHandlerMap::iterator it = mMessageHandlerMap.find(id);
+            if(it == mMessageHandlerMap.end())
+            {
+                MessageHandlerMapEntries* entries = new MessageHandlerMapEntries();
+                mMessageHandlerMap[id] = entries;
+                return entries;
+            }
+            return it->second;
+        }
+
+        bool doSend(MessageObjectBase* msg)
+        {
+            bool msgHandled = false;
+            MessageHandlerMapEntries* entries = getOrCreateMapEntries(msg->getMessageTypeId());
+            for(MessageHandlerMapEntries::iterator it = entries->begin(); it != entries->end(); ++it)
+            {
+                if((*it).handlerWrapper->Invoke(msg))
+                {
+                    msgHandled = true;
+                }
+            }
+            delete msg;
+            return msgHandled;;
+        }
+
+        void doPost(MessageObjectBase* msg)
+        {
+            mMessageQueue.push(msg);
+        }
+
+        friend class Connection;
+        void disconnectHandler(int connectionId)
+        {
+            //not very performant...definitely needs improvement
+            for (MessageHandlerMap::iterator it = mMessageHandlerMap.begin();
+                it != mMessageHandlerMap.end(); ++it)
+            {
+                MessageHandlerMapEntries* en = it->second;
+                for (MessageHandlerMapEntries::iterator jt = en->begin(); jt != en->end(); ++jt)
+                {
+                    if (jt->connectionId == connectionId)
+                    {
+                        delete jt->handlerWrapper;
+                        en->erase(jt);
+                        if (en->empty())
+                        {
+                            delete en;
+                            mMessageHandlerMap.erase(it);
+                        }
+                        return;
+                    }
+                }
+            }
+        }
+
+    private:
+        int mNextConnectionId;
+        MessageHandlerMap mMessageHandlerMap;
+        MessageQueue mMessageQueue;
+    };
+}
+#endif

Added: rl/trunk/engine/core/include/MessageType.h
===================================================================
--- rl/trunk/engine/core/include/MessageType.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/include/MessageType.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -0,0 +1,35 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Rl_MessageType_H__
+#define __Rl_MessageType_H__
+
+#include "CorePrerequisites.h"
+#include "MessageObject.h"
+
+namespace rl
+{
+    template<int _MessageTypeId, typename Param1, typename Param2>
+    class MessageType
+    {
+    public:
+        static const int MessageTypeId = _MessageTypeId;
+
+        typedef MessageObject<_MessageTypeId, Param1, Param2> MessageObjectType;
+        typedef typename MessageObjectType::HandlerType HandlerType;
+    };
+}
+#endif

Modified: rl/trunk/engine/core/include/World.h
===================================================================
--- rl/trunk/engine/core/include/World.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/include/World.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -26,13 +26,6 @@
 
     class Actor;
 
-    class _RlCoreExport SceneChangeListener
-    {
-    public:
-        virtual void onAfterSceneLoaded() {};
-        virtual void onBeforeClearScene() {};
-    };
-
     class _RlCoreExport World
     {
     public:
@@ -93,9 +86,6 @@
 
         void setShowBoundingBoxes(bool dis);
 
-        void addSceneChangeListener(SceneChangeListener*);
-        void removeSceneChangeListener(SceneChangeListener*);
-
         /// Returns a name not yet used for an Ogre object.
         Ogre::String getUniqueName();
 
@@ -109,9 +99,6 @@
 
         Actor* mActiveActor;
 
-        typedef std::set<SceneChangeListener*> SceneChangeListenerSet;
-        SceneChangeListenerSet mSceneChangeListeners;
-
         World(Ogre::SceneType sceneType);
         
         void fireAfterSceneLoaded();

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-17 14:41:51 UTC (rev 3605)
@@ -34,6 +34,7 @@
 #include "DotSceneOctreeWorld.h"
 #include "Exception.h"
 #include "GameEventManager.h"
+#include "MessagePump.h"
 #include "GameLoop.h"
 #include "ZoneManager.h"
 #include "Logger.h"
@@ -68,6 +69,7 @@
         mScriptWrapper(NULL),
         mXmlResourceManager(NULL),
         mPhysicsManager(NULL),
+        mMessagePump(NULL),
         mGameLoop(NULL),
         mAnimationManager(NULL),
         mActorManager(NULL),
@@ -90,6 +92,7 @@
         delete mGameEventManager;
 		delete mWorld;
         delete mGameLoop;
+        delete mMessagePump;
         delete mJobScheduler;
         delete mAnimationManager;
         delete mActorManager;
@@ -264,6 +267,10 @@
         mWorld = new DotSceneOctreeWorld();
         mActorManager->setWorld(mWorld);
 
+        mMessagePump = new MessagePump();
+        GameLoop::getSingleton().addTask(mMessagePump, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,"MessagePump erzeugt");
+
         mPhysicsManager = new PhysicsManager();
         GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
         LOG_MESSAGE(Logger::CORE,"PhysicsManager erzeugt");

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/src/Makefile.am	2007-07-17 14:41:51 UTC (rev 3605)
@@ -40,6 +40,7 @@
 	MergeableMeshObject.cpp \
 	MeshAnimation.cpp \
 	MeshObject.cpp \
+	MessagePump.cpp \
 	MovableText.cpp \
 	ParticleSystemObject.cpp \
 	PhysicsContactListener.cpp \

Added: rl/trunk/engine/core/src/MessagePump.cpp
===================================================================
--- rl/trunk/engine/core/src/MessagePump.cpp	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/src/MessagePump.cpp	2007-07-17 14:41:51 UTC (rev 3605)
@@ -0,0 +1,35 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "MessagePump.h"
+
+template<> rl::MessagePump* Ogre::Singleton<rl::MessagePump>::ms_Singleton = 0;
+
+namespace rl
+{
+
+    void MessagePump::run(Ogre::Real elapsedTime)
+    {
+    }
+
+    const Ogre::String& MessagePump::getName() const
+    {
+        static Ogre::String name = "MessagePump";
+        return name;
+    }
+
+}

Modified: rl/trunk/engine/core/src/World.cpp
===================================================================
--- rl/trunk/engine/core/src/World.cpp	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/core/src/World.cpp	2007-07-17 14:41:51 UTC (rev 3605)
@@ -17,10 +17,13 @@
 
 #include "World.h"
 
+#include "Exception.h"
+#include "CoreMessages.h"
+#include "MessagePump.h"
+
 #include <OgreRoot.h>
 #include <OgreSceneManager.h>
 
-#include "Exception.h"
 
 using namespace Ogre;
 
@@ -129,39 +132,13 @@
         return "__RL_WORLD_UNIQUE_NAME__" + StringConverter::toString(++mUniqueNameSeed);
     }
 
-    void World::addSceneChangeListener(SceneChangeListener* listener)
-    {
-        SceneChangeListenerSet::iterator it = mSceneChangeListeners.find(listener);
-        if (it == mSceneChangeListeners.end())
-            mSceneChangeListeners.insert(listener);
-        else
-            Throw(IllegalArgumentException, "Listener is already registered.");
-    }
-
-    void World::removeSceneChangeListener(SceneChangeListener* listener)
-    {
-        SceneChangeListenerSet::iterator it = mSceneChangeListeners.find(listener);
-        if (it != mSceneChangeListeners.end())
-            mSceneChangeListeners.erase(listener);
-        else
-            Throw(IllegalArgumentException, "Listener is not registered.");
-    }
-
     void World::fireAfterSceneLoaded()
     {
-        for (SceneChangeListenerSet::iterator it = mSceneChangeListeners.begin();
-            it != mSceneChangeListeners.end(); ++it)
-        {
-            (*it)->onAfterSceneLoaded();
-        }
+        MessagePump::getSingleton().sendMessage<MessageType_SceneLoaded>();
     }
 
     void World::fireBeforeClearScene()
     {
-        for (SceneChangeListenerSet::iterator it = mSceneChangeListeners.begin();
-            it != mSceneChangeListeners.end(); ++it)
-        {
-            (*it)->onBeforeClearScene();
-        }
+        MessagePump::getSingleton().sendMessage<MessageType_SceneClearing>();
     }
 }

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2007-07-17 14:41:51 UTC (rev 3605)
@@ -23,6 +23,7 @@
 #include <OgreSingleton.h>
 
 #include "ControlState.h"
+#include "MessagePump.h"
 
 // Gar nicht sch?n, aber ansonsten gibt es unn?tige Abh?ngigkeiten,
 // wenn man die Header hier inkludiert.
@@ -44,8 +45,7 @@
     class WindowFactory;
     class WindowManager;
 
-    class _RlUiExport UiSubsystem : public SceneChangeListener,
-        public Ogre::Singleton<UiSubsystem>
+    class _RlUiExport UiSubsystem : public Ogre::Singleton<UiSubsystem>
     {
     public:
         static const char* CEGUI_ROOT;
@@ -60,14 +60,15 @@
         ///@todo function feels misplaced here,
         void setActiveCharacter(Person* person);
 
-        /// from SceneChangeListener
-        virtual void onBeforeClearScene();
+        virtual bool onBeforeClearScene();
 
         void initializeSubsystem();
 
     private:
         Person* mCharacter;
 
+	    MessagePump::ScopedConnection mSceneClearingConnection;
+
         // Singletons
         InputManager* mInputManager;
         WindowFactory* mWindowFactory;

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-07-17 08:46:25 UTC (rev 3604)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-07-17 14:41:51 UTC (rev 3605)
@@ -27,6 +27,7 @@
 #include "Actor.h"
 #include "ActorManager.h"
 #include "ConfigurationManager.h"
+#include "CoreMessages.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
 #include "CombatControlState.h"
@@ -65,14 +66,14 @@
         mGuiResourceProvider(NULL),
         mGuiSystem(NULL)
     {
-        CoreSubsystem::getSingletonPtr()->getWorld()->addSceneChangeListener(this);
+        mSceneClearingConnection =
+            MessagePump::getSingleton().addMessageHandler<MessageType_SceneClearing>(
+			    boost::bind(&UiSubsystem::onBeforeClearScene, this));
         mWindowFactory = new WindowFactory();
     }
 
     UiSubsystem::~UiSubsystem()
     {
-        CoreSubsystem::getSingletonPtr()->getWorld()->removeSceneChangeListener(this);
-
         delete mWindowFactory;
         delete mWindowManager;
 
@@ -188,11 +189,13 @@
         }
     }
 
-    void UiSubsystem::onBeforeClearScene()
+    bool UiSubsystem::onBeforeClearScene()
     {
         setActiveCharacter(NULL);
         // Remove control states here too, in case that there has not yet been a
         // person set active.
         mInputManager->clearControlStates();
+
+        return true;
     }
 }



From blakharaz at mail.berlios.de  Tue Jul 17 17:15:13 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 17 Jul 2007 17:15:13 +0200
Subject: [Dsa-hl-svn] r3606 - rl/trunk/engine/core/include
Message-ID: <200707171515.l6HFFDqB004778@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-17 17:15:11 +0200 (Tue, 17 Jul 2007)
New Revision: 3606

Modified:
   rl/trunk/engine/core/include/Makefile.am
   rl/trunk/engine/core/include/MessageObject.h
Log:
Fix Linux/GCC build
* strict sequence of declarations needed

Modified: rl/trunk/engine/core/include/Makefile.am
===================================================================
--- rl/trunk/engine/core/include/Makefile.am	2007-07-17 14:41:51 UTC (rev 3605)
+++ rl/trunk/engine/core/include/Makefile.am	2007-07-17 15:15:11 UTC (rev 3606)
@@ -11,6 +11,7 @@
 	ContentModule.h \
 	CoreDefines.h \
 	CoreEvents.h \
+	CoreMessages.h \
 	CorePrerequisites.h \
 	CoreSubsystem.h \
 	DebugVisualisable.h \
@@ -34,6 +35,9 @@
 	ListenerMovable.h \
 	ListenerObject.h \
 	MergeableMeshObject.h \
+	MessageObject.h \
+	MessagePump.h \
+	MessageType.h \
 	MeshAnimation.h \
 	MeshObject.h \
 	MovableText.h \

Modified: rl/trunk/engine/core/include/MessageObject.h
===================================================================
--- rl/trunk/engine/core/include/MessageObject.h	2007-07-17 14:41:51 UTC (rev 3605)
+++ rl/trunk/engine/core/include/MessageObject.h	2007-07-17 15:15:11 UTC (rev 3606)
@@ -99,6 +99,20 @@
     template<int _MessageTypeId, typename Param1, typename Param2>
     class MessageObject_x;
 
+    //The final MessageObject. The real implementation is chosen through the given template parameters
+    template<int _MessageTypeId,
+        typename Param1 = MessageObject_EmptyParam,
+        typename Param2 = MessageObject_EmptyParam>
+    class MessageObject : public MessageObject_x<_MessageTypeId, Param1, Param2>
+    {
+    public:
+        virtual int getMessageTypeId()
+        {
+            return _MessageTypeId;
+        }
+    };
+
+
     template<int _MessageTypeId>
     class MessageObject_x<_MessageTypeId, MessageObject_EmptyParam, MessageObject_EmptyParam>
         : public MessageObject_0
@@ -139,18 +153,6 @@
 
     /////////////////////////////////////////////////////
 
-    //The final MessageObject. The real implementation is chosen through the given template parameters
-    template<int _MessageTypeId,
-        typename Param1 = MessageObject_EmptyParam,
-        typename Param2 = MessageObject_EmptyParam>
-    class MessageObject : public MessageObject_x<_MessageTypeId, Param1, Param2>
-    {
-    public:
-        virtual int getMessageTypeId()
-        {
-            return _MessageTypeId;
-        }
-    };
 
 }
 



From blakharaz at mail.berlios.de  Thu Jul 19 01:27:12 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 01:27:12 +0200
Subject: [Dsa-hl-svn] r3607 - modules/common/scripts
	modules/regressiontest/dsa modules/regressiontest/materials
	modules/regressiontest/materials/textures
	modules/regressiontest/models modules/regressiontest/scripts
	modules/regressiontest/scripts/maps
	rl/trunk/engine/core/include rl/trunk/engine/core/src
	rl/trunk/engine/rules rl/trunk/engine/rules/include
	rl/trunk/engine/rules/src rl/trunk/engine/script/swig
Message-ID: <200707182327.l6INRC65014010@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 01:26:04 +0200 (Thu, 19 Jul 2007)
New Revision: 3607

Added:
   modules/regressiontest/materials/obj_Shortsleeve.material
   modules/regressiontest/materials/obj_Shortsleeve_2.material
   modules/regressiontest/materials/textures/obj_shortsleeve_dummy.png
   modules/regressiontest/models/obj_shortsleeve.mesh
   modules/regressiontest/models/obj_shortsleeve_2.mesh
   rl/trunk/engine/rules/include/RulesConstants.h
Removed:
   rl/trunk/engine/rules/include/GameObjectConstants.h
Modified:
   modules/common/scripts/gameobjectprops.rb
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   modules/regressiontest/scripts/MergeableMeshTest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
   modules/regressiontest/scripts/mckhero.rb
   rl/trunk/engine/core/include/MeshObject.h
   rl/trunk/engine/core/src/MeshObject.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/include/GameObjectStateListener.h
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/include/Slot.h
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Added a third slot type - this slot changes the material of a submesh (item must have property "material")

Modified: modules/common/scripts/gameobjectprops.rb
===================================================================
--- modules/common/scripts/gameobjectprops.rb	2007-07-17 15:15:11 UTC (rev 3606)
+++ modules/common/scripts/gameobjectprops.rb	2007-07-18 23:26:04 UTC (rev 3607)
@@ -6,8 +6,8 @@
         $SCRIPT.log("Check Ruby GameObject for properties.");
         
         #  Get all properties from the parent C++ class
-        ps = PropertySet.new
-        ps = super.getAllProperties()
+        #ps = PropertySet.new
+        ps = super()
     
         #  Get all instance variables from the ruby class
         aPropArray = instance_variables
@@ -26,5 +26,13 @@
         end
         return ps
     end
+	
+#	def setProperty(key, value)
+#		instance_variable_set("@_prop_"+key, value)
+#	end
+
+#	def getProperty(key)
+#		return instance_variable_get("@_prop_"+key)
+#	end
   
 end

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-07-17 15:15:11 UTC (rev 3606)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-07-18 23:26:04 UTC (rev 3607)
@@ -96,8 +96,10 @@
         <property name="capacity" type="REAL" data="20.0"/>
         <property name="volume" type="INTPAIR" data="8,6"/>
         <property name="size" type="INTPAIR" data="2,2"/>
+		<property name="mass" type="REAL" data="5.0"/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
         <property name="actions" type="ARRAY">
-        <property type="STRING" data="showcontainercontent"/>
+			<property type="STRING" data="showcontainercontent"/>
         </property>
         <property name="defaultaction" type="STRING" data="showcontainercontent"/>
     </gameobjectclass>
@@ -140,5 +142,20 @@
         <property name="geometrytype" type="STRING" data="box"/>
     </gameobjectclass>
 
-
+	<!--InventoryTest clothes-->
+    <gameobjectclass classid="Clothes #1" baseclass="Clothing">
+        <property name="name" type="STRING" data="Kleidung #1"/>
+        <property name="description" type="STRING" data="Kleidung, Variante 1"/>
+        <property name="meshfile" type="STRING" data="obj_shortsleeve.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="material" type="STRING" data="obj_Shortsleeve"/>
+    </gameobjectclass>
+    <gameobjectclass classid="Clothes #2" baseclass="Clothing">
+        <property name="name" type="STRING" data="Kleidung #2"/>
+        <property name="description" type="STRING" data="Kleidung, Variante 2"/>
+        <property name="meshfile" type="STRING" data="obj_shortsleeve_2.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="material" type="STRING" data="obj_Shortsleeve_2"/>
+    </gameobjectclass>
+	
 </GameObjectDefinitions>

Added: modules/regressiontest/materials/obj_Shortsleeve.material
===================================================================
--- modules/regressiontest/materials/obj_Shortsleeve.material	2007-07-17 15:15:11 UTC (rev 3606)
+++ modules/regressiontest/materials/obj_Shortsleeve.material	2007-07-18 23:26:04 UTC (rev 3607)
@@ -0,0 +1,6 @@
+
+material obj_Shortsleeve : Basic_Vertex_Shader
+{
+set_texture_alias diffuse obj_shortsleeve02_diffuse.png
+
+}

Added: modules/regressiontest/materials/obj_Shortsleeve_2.material
===================================================================
--- modules/regressiontest/materials/obj_Shortsleeve_2.material	2007-07-17 15:15:11 UTC (rev 3606)
+++ modules/regressiontest/materials/obj_Shortsleeve_2.material	2007-07-18 23:26:04 UTC (rev 3607)
@@ -0,0 +1,6 @@
+
+material obj_Shortsleeve_2 : Basic_Vertex_Shader
+{
+set_texture_alias diffuse obj_shortsleeve_dummy.png
+
+}

Added: modules/regressiontest/materials/textures/obj_shortsleeve_dummy.png
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/materials/textures/obj_shortsleeve_dummy.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/regressiontest/models/obj_shortsleeve.mesh
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/models/obj_shortsleeve.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/regressiontest/models/obj_shortsleeve_2.mesh
===================================================================
(Binary files differ)


Property changes on: modules/regressiontest/models/obj_shortsleeve_2.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2007-07-17 15:15:11 UTC (rev 3606)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2007-07-18 23:26:04 UTC (rev 3607)
@@ -24,23 +24,22 @@
         test_obj1.setPosition(rel_pos([1, 0, 0]))
         test_obj1.placeIntoScene();
 
-
         test_obj2 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj2.setPosition(rel_pos([2, 0, 0]))
         test_obj2.placeIntoScene();
 #        test_obj2.getActor().getControlledObject().startAnimation("Walk")
-        test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-        test_obj2.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-        test_obj2.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_obj2.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+        test_obj2.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
+        test_obj2.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
         test_item2 = $GOM.createGameObject("mesh construction kit test item 1")
         test_obj2.getInventory().hold(test_item2, "Armor")
 
         test_obj3 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj3.setPosition(rel_pos([3, 0, 0]))
         test_obj3.placeIntoScene();
-        test_obj3.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-        test_obj3.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-        test_obj3.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_obj3.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+        test_obj3.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
+        test_obj3.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
         test_item3 = $GOM.createGameObject("mesh construction kit test item 2")
         test_obj3.getInventory().hold(test_item3, "Armor")
         test_obj3.getActor().getControlledObject().startAnimation("Walk")
@@ -48,9 +47,9 @@
         test_obj4 = $GOM.createGameObject("mesh construction kit test creature")
         test_obj4.setPosition(rel_pos([4, 0, 0]))
         test_obj4.placeIntoScene();
-        test_obj4.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-        test_obj4.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-        test_obj4.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, false);
+        test_obj4.getInventory().addSlot("Head", "head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+        test_obj4.getInventory().addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_BONE);
+        test_obj4.getInventory().addSlot("Armor", "armor", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
         test_item4 = $GOM.createGameObject("mesh construction kit test item 2")
         test_obj4.getInventory().hold(test_item4, "Armor")
         test_obj4.getInventory().dropItem("Armor")

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-07-17 15:15:11 UTC (rev 3606)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-07-18 23:26:04 UTC (rev 3607)
@@ -15,6 +15,7 @@
 require 'effecttest.rb'
 require 'LightzoneTest.rb'
 require 'MapLoadingTest.rb'
+require 'MaterialSlotTest.rb'
 require 'MergeableMeshTest.rb'
 require 'WalkJobTest.rb'
 require 'SelectorTest.rb'
@@ -37,20 +38,21 @@
 
 $SCRIPT.log("begin tests.");
 
-         DoorTest.new([0, 0, -5]).run()
-          NpcTest.new([-5, 0, 5]).run()
-   NpcCapsuleTest.new([0, 0, 5]).run()
-         TimeTest.new([-5, 0, -5]).run()
+ MaterialSlotTest.new([-15, 0, -5]).run()
+    LightzoneTest.new([-10, 0, -5]).run()
 ErrorHandlingTest.new([-10, 0, 5]).run()
-    InventoryTest.new([0, 0, 10]).run()
-  JobSequenceTest.new([5, 0, -5]).run()
-       EffectTest.new([5, 0, 5]).run()
-        SoundTest.new([10, 0, 10]).run()
-    LightzoneTest.new([-10, 0, -5]).run()
-   MapLoadingTest.new([-5, 0, -10]).run()
-MergeableMeshTest.new([10, 0, 0]).run()
-     SelectorTest.new([5, 0, 0]).run()
-	  WalkJobTest.new([0.0,0.0,0.0]).run()
+         TimeTest.new([ -5, 0, -5]).run()
+   MapLoadingTest.new([ -5, 0, -10]).run()
+          NpcTest.new([ -5, 0, 5]).run()
+         DoorTest.new([  0, 0, -5]).run()
+	  WalkJobTest.new([  0, 0, -3]).run()
+   NpcCapsuleTest.new([  0, 0, 5]).run()
+    InventoryTest.new([  0, 0, 10]).run()
+  JobSequenceTest.new([  5, 0, -5]).run()
+     SelectorTest.new([  5, 0, 0]).run()
+       EffectTest.new([  5, 0, 5]).run()
+MergeableMeshTest.new([ 10, 0, 0]).run()
+        SoundTest.new([ 10, 0, 10]).run()
 
 $SCRIPT.log("tests initialisiert.");
 

Modified: modules/regressiontest/scripts/mckhero.rb
===================================================================
--- modules/regressiontest/scripts/mckhero.rb	2007-07-17 15:15:11 UTC (rev 3606)
+++ modules/regressiontest/scripts/mckhero.rb	2007-07-18 23:26:04 UTC (rev 3607)
@@ -35,10 +35,12 @@
 	inv.addSlot("Right Ring", "Bip01 R Finger21", Item::ITEMTYPE_RING);
 	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_ALL_ITEMS);
 	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, false);
-	inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, false);
+	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
 	#inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
-    inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, false);
+    inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
+	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR, RlScript::SLOT_MATERIAL);
+	
 
 	#addSounds()
         $SCRIPT.log("done.");

Modified: rl/trunk/engine/core/include/MeshObject.h
===================================================================
--- rl/trunk/engine/core/include/MeshObject.h	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/core/include/MeshObject.h	2007-07-18 23:26:04 UTC (rev 3607)
@@ -84,19 +84,27 @@
 		/** creates a mesh animated to the specified pose.
 		 * @param animName name of the animation to be posed at.
 		 */
-		MeshObject *createPosedCopy(const Ogre::String& animName);
+		MeshObject* createPosedCopy(const Ogre::String& animName);
 
 		const Ogre::String &getMeshName() const;
 
 		virtual bool isMeshObject() const;
 
         /// Per Skeleton-Blend-Setting
-        bool getBlendCumulative(void) const;
+        bool getBlendCumulative() const;
         void setBlendCumulative(bool cumulative);
 
         void setHighlighted( bool highlight );
         
         virtual Ogre::String getObjectType() const;
+
+        /** Changes the Material of a submesh
+         * if the submesh is not specified (or the parameter is set to "") 
+         * the first submesh's material is changed
+         * @param material the name of the new material
+         * @param submesh (optional) the name of the submesh
+         */
+        void setMaterial(const Ogre::String& material, const Ogre::String& submesh);
     private:
 		Ogre::String mMeshName;
         Ogre::AxisAlignedBox mSize;

Modified: rl/trunk/engine/core/src/MeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MeshObject.cpp	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/core/src/MeshObject.cpp	2007-07-18 23:26:04 UTC (rev 3607)
@@ -340,7 +340,7 @@
             if( subent == NULL )
                 continue;
 
-            // TODO - optimieren, nur wenn der Typ ver?ndert wird
+            // TODO - optimieren, nur wenn der Typ veraendert wird
             //if(StringUtil::endsWith(subent->getMaterialName(),nameExtension)
             // == highlight )
             //  continue;
@@ -383,4 +383,20 @@
     {
         return true;
     }
+
+    void MeshObject::setMaterial(const Ogre::String& material, const Ogre::String& submesh)
+    {
+        if (submesh == "")
+        {
+            ///@todo implement
+        }
+        else
+        {
+            SubEntity* subent = getEntity()->getSubEntity(submesh);
+            if (subent)
+            {
+                subent->setMaterialName(material);
+            }
+        }
+    }
 }

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-18 23:26:04 UTC (rev 3607)
@@ -569,10 +569,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\GameObjectConstants.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\GameObjectManager.h"
 				>
 			</File>
@@ -621,6 +617,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\RulesConstants.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\RulesPrerequisites.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/rules/include/GameObject.h	2007-07-18 23:26:04 UTC (rev 3607)
@@ -20,7 +20,7 @@
 #include "RulesPrerequisites.h"
 
 #include "Action.h"
-#include "GameObjectConstants.h"
+#include "RulesConstants.h"
 #include "ObjectStateChangeEventSource.h"
 #include "Properties.h"
 #include "CoreDefines.h"

Deleted: rl/trunk/engine/rules/include/GameObjectConstants.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectConstants.h	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/rules/include/GameObjectConstants.h	2007-07-18 23:26:04 UTC (rev 3607)
@@ -1,46 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __GAMEOBJECTSTATE_H__
-#define __GAMEOBJECTSTATE_H__
-
-namespace rl {
-
-    /// Basic states, a GameObject can have.
-    /// Values are chosen so, that they are maskable.
-    enum GameObjectState
-    {
-        GOS_UNDEFINED     =     0, ///!< Nothing known about such a GO.
-        GOS_UNLOADED      =  1<<0, ///!< GO is known, but its actual properties are not loaded yet.
-        GOS_LOADED        =  1<<1, ///!< GO is loaded, unused.
-        GOS_IN_POSSESSION =  1<<2, ///!< GO is owned by another GO. (e.g. inside a chest)
-        GOS_IN_SCENE      =  1<<3, ///!< GO is placed openly in the scene.
-        GOS_HELD          =  1<<4, ///!< GO is held openly by another GO. (e.g. apple in NPC's hand)
-        GOS_READY         =  1<<5  ///!< GO is ready for usage by another GO. (sword in NPC's hand)
-    };
-
-	static const unsigned long QUERYFLAG_GAMEOBJECT = 1<<1;
-    static const unsigned long QUERYFLAG_CREATURE   = 1<<2;
-    static const unsigned long QUERYFLAG_ITEM       = 1<<3;
-    static const unsigned long QUERYFLAG_CONTAINER  = 1<<4;
-    static const unsigned long QUERYFLAG_WEAPON     = 1<<5;
-    static const unsigned long QUERYFLAG_ARMOR      = 1<<6;
-    static const unsigned long QUERYFLAG_PERSON     = 1<<7;
-
-	static const unsigned long QUERYFLAG_PLAYER     = 1<<8;
-}
-
-#endif // GAMEOBJECTSTATE

Modified: rl/trunk/engine/rules/include/GameObjectStateListener.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectStateListener.h	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/rules/include/GameObjectStateListener.h	2007-07-18 23:26:04 UTC (rev 3607)
@@ -17,7 +17,7 @@
 #ifndef __RL_GAMEOBJECTSTATELISTENER_H__
 #define __RL_GAMEOBJECTSTATELISTENER_H__
 
-#include "GameObjectConstants.h"
+#include "RulesConstants.h"
 
 namespace rl {
 

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-07-18 23:26:04 UTC (rev 3607)
@@ -19,8 +19,8 @@
 
 #include "RulesPrerequisites.h"
 
-#include "Container.h"
 #include "Properties.h"
+#include "RulesConstants.h"
 
 namespace rl {
 
@@ -83,7 +83,7 @@
     void ready(Item* item);
 
     Item* getItem(const CeGuiString& slotName) const;
-    void addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, bool boneSlot = true);
+    void addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, SlotType type = SLOT_BONE);
     const SlotMap& getAllSlots() const;
 
 	Creature* getOwner() const;

Copied: rl/trunk/engine/rules/include/RulesConstants.h (from rev 3605, rl/trunk/engine/rules/include/GameObjectConstants.h)
===================================================================
--- rl/trunk/engine/rules/include/GameObjectConstants.h	2007-07-17 14:41:51 UTC (rev 3605)
+++ rl/trunk/engine/rules/include/RulesConstants.h	2007-07-18 23:26:04 UTC (rev 3607)
@@ -0,0 +1,54 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RULESCONSTANTS_H__
+#define __RULESCONSTANTS_H__
+
+namespace rl {
+
+    /// Basic states, a GameObject can have.
+    /// Values are chosen so, that they are maskable.
+    enum GameObjectState
+    {
+        GOS_UNDEFINED     =     0, ///!< Nothing known about such a GO.
+        GOS_UNLOADED      =  1<<0, ///!< GO is known, but its actual properties are not loaded yet.
+        GOS_LOADED        =  1<<1, ///!< GO is loaded, unused.
+        GOS_IN_POSSESSION =  1<<2, ///!< GO is owned by another GO. (e.g. inside a chest)
+        GOS_IN_SCENE      =  1<<3, ///!< GO is placed openly in the scene.
+        GOS_HELD          =  1<<4, ///!< GO is held openly by another GO. (e.g. apple in NPC's hand)
+        GOS_READY         =  1<<5  ///!< GO is ready for usage by another GO. (sword in NPC's hand)
+    };
+
+	static const unsigned long QUERYFLAG_GAMEOBJECT = 1<<1;
+    static const unsigned long QUERYFLAG_CREATURE   = 1<<2;
+    static const unsigned long QUERYFLAG_ITEM       = 1<<3;
+    static const unsigned long QUERYFLAG_CONTAINER  = 1<<4;
+    static const unsigned long QUERYFLAG_WEAPON     = 1<<5;
+    static const unsigned long QUERYFLAG_ARMOR      = 1<<6;
+    static const unsigned long QUERYFLAG_PERSON     = 1<<7;
+
+	static const unsigned long QUERYFLAG_PLAYER     = 1<<8;
+
+
+    enum SlotType
+    {
+        SLOT_BONE,
+        SLOT_SUBMESH,
+        SLOT_MATERIAL
+    };
+}
+
+#endif // __RULESCONSTANTS_H__
\ No newline at end of file

Modified: rl/trunk/engine/rules/include/Slot.h
===================================================================
--- rl/trunk/engine/rules/include/Slot.h	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/rules/include/Slot.h	2007-07-18 23:26:04 UTC (rev 3607)
@@ -29,10 +29,10 @@
     virtual void setItem(Item* item) = 0;
     Item* getItem() const;
     bool isAllowed(Item* item) const;
+    virtual ~Slot();
 
 protected:
     Slot(Creature* owner, const CeGuiString& name, int itemMask);
-    virtual ~Slot();
 
     Creature* mOwner;
     Item* mItem;
@@ -62,6 +62,16 @@
     Ogre::String mSubmesh;
 };
 
+class MaterialSlot : public Slot
+{
+public:
+    MaterialSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& submesh);
+    virtual void setItem(Item* item);
+
+private:
+    Ogre::String mSubmesh;
+};
+
 } // namespace rl
 
 #endif //__SLOT_H__

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-07-18 23:26:04 UTC (rev 3607)
@@ -15,10 +15,11 @@
  */
 #include "stdinc.h" //precompiled header
 
+#include "Inventory.h"
+
 #include "Item.h"
 #include "Armor.h"
 #include "Weapon.h"
-#include "Inventory.h"
 #include "Exception.h"
 #include "ActorManager.h"
 #include "Creature.h"
@@ -218,21 +219,25 @@
     {
     }
 
-    void Inventory::addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, bool boneSlot)
+    void Inventory::addSlot(const CeGuiString& name, const Ogre::String& meshpartname, int itemMask, SlotType type)
     {
         if (mSlots.find(name) != mSlots.end())
         {
             Throw(rl::IllegalArgumentException, Ogre::String("Slot '")+name.c_str()+"' already exists.");
         }
 
-		if (boneSlot)
-		{
-			mSlots[name] = new BoneSlot(mOwner, name, itemMask, meshpartname);
+		switch (type)
+        {
+            case SLOT_BONE:
+			    mSlots[name] = new BoneSlot(mOwner, name, itemMask, meshpartname);
+                break;
+            case SLOT_SUBMESH:
+			    mSlots[name] = new SubmeshSlot(mOwner, name, itemMask, meshpartname);
+                break;
+            case SLOT_MATERIAL:
+			    mSlots[name] = new MaterialSlot(mOwner, name, itemMask, meshpartname);
+                break;
 		}
-		else
-		{
-			mSlots[name] = new SubmeshSlot(mOwner, name, itemMask, meshpartname);
-		}
     }
 
     const Inventory::SlotMap& Inventory::getAllSlots() const

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-18 23:26:04 UTC (rev 3607)
@@ -41,6 +41,7 @@
 #include "QuestBook.h"
 #include "QuestEvent.h"
 #include "QuestListener.h"
+#include "RulesConstants.h"
 #include "RulesSubsystem.h"
 #include "Selector.h"
 #include "SonderfertigkeitenStateSet.h"

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-07-17 15:15:11 UTC (rev 3606)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-07-18 23:26:04 UTC (rev 3607)
@@ -14,7 +14,7 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
-// %template(GameObjectVector) std::vector< rl::GameObject* >;         
+//%template(GameObjectVector) std::vector< rl::GameObject* >;
 
 namespace rl {
 
@@ -598,13 +598,20 @@
         void setEffectFactory(rl::EffectFactory* factory);
         static rl::EffectFactoryManager& getSingleton();
     };
-    
+
+    enum SlotType
+    {
+        SLOT_BONE,
+        SLOT_SUBMESH,
+        SLOT_MATERIAL
+    };
+
     class Inventory 
     {
     private:
         Inventory(rl::Creature* owner);
     public:
-		void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemMask, bool boneSlot = true);
+        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemMask, SlotType type = SLOT_BONE);
         rl::Item* getItem(const rl::CeGuiString& slotName) const;
         void hold(rl::Item* item, const rl::CeGuiString& slot);
         void dropItem(const rl::CeGuiString& slotName);



From blakharaz at mail.berlios.de  Thu Jul 19 01:28:17 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 01:28:17 +0200
Subject: [Dsa-hl-svn] r3608 - rl/trunk/engine/rules/src
Message-ID: <200707182328.l6INSH2Z023382@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 01:28:16 +0200 (Thu, 19 Jul 2007)
New Revision: 3608

Modified:
   rl/trunk/engine/rules/src/Slot.cpp
Log:
Added a third slot type - this slot changes the material of a submesh (item must have property "material")

Modified: rl/trunk/engine/rules/src/Slot.cpp
===================================================================
--- rl/trunk/engine/rules/src/Slot.cpp	2007-07-18 23:26:04 UTC (rev 3607)
+++ rl/trunk/engine/rules/src/Slot.cpp	2007-07-18 23:28:16 UTC (rev 3608)
@@ -87,15 +87,27 @@
 
     void SubmeshSlot::setItem(Item* item)
     {
-		///@todo: what to do if actor is null?
-		if (mOwner->getActor() != NULL)
+		///@todo: what to do if actor is null?, think about changing the inventory of an gameobject not in scene
+		if (mOwner->getActor())
 		{
 			MergeableMeshObject* mmo = dynamic_cast<MergeableMeshObject*>(
 				mOwner->getActor()->getControlledObject());
-			if (mmo != NULL)
+
+			if (mmo)
 			{
-				if (item == NULL)
+				if (item)
 				{
+					if (isAllowed(item))
+					{
+						item->setState(GOS_IN_POSSESSION);
+						mmo->replaceSubmesh(
+							mSubmesh,
+							item->getMeshfile().c_str());
+						mItem = item;
+					}
+				}
+				else
+				{
 					MeshPartMap::const_iterator it = mOwner->getMeshParts().find(mSubmesh);
 					if (it != mOwner->getMeshParts().end())
 					{
@@ -109,17 +121,6 @@
 					}
 					mItem = NULL;
 				}
-				else
-				{
-					if (isAllowed(item))
-					{
-						item->setState(GOS_IN_POSSESSION);
-						mmo->replaceSubmesh(
-							mSubmesh,
-							item->getMeshfile().c_str());
-						mItem = item;
-					}
-				}
 			}
 
             if (mOwner->getActor()
@@ -129,4 +130,46 @@
             }
 		}
     }
+
+    MaterialSlot::MaterialSlot(Creature* owner, const CeGuiString& name, int itemMask, const Ogre::String& submesh)
+      : Slot(owner, name, itemMask),
+        mSubmesh(submesh)
+    {
+    }
+
+    void MaterialSlot::setItem(Item* item)
+    {
+        if (item)
+        {
+            try
+            {
+                CeGuiString mat = item->getProperty("material").toString();
+
+                ///@todo: what to do if actor is null?, think about changing the inventory of an gameobject not in scene
+		        if (mOwner->getActor())
+		        {
+			        MeshObject* mo = dynamic_cast<MeshObject*>(
+				        mOwner->getActor()->getControlledObject());
+
+			        if (mo)
+			        {
+                        mo->setMaterial(mat.c_str(), mSubmesh);
+                    }
+                }
+            }
+            catch (const IllegalArgumentException&)
+            {
+                LOG_ERROR(Logger::RULES, "Item " + item->getName() + " has no property material.");
+            }
+            catch (const WrongFormatException&)
+            {
+                LOG_ERROR(Logger::RULES, "Item " + item->getName() + " has a property material, but it is no string property.");
+            }
+        }
+        else
+        {
+            ///@todo reset material?
+        }
+    }
+
 } // namespace rl



From blakharaz at mail.berlios.de  Thu Jul 19 01:29:15 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 01:29:15 +0200
Subject: [Dsa-hl-svn] r3609 - rl/trunk/engine/script/src
Message-ID: <200707182329.l6INTFuZ023774@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 01:29:14 +0200 (Thu, 19 Jul 2007)
New Revision: 3609

Modified:
   rl/trunk/engine/script/src/ZoneProcessor.cpp
Log:
Added a third slot type - this slot changes the material of a submesh (item must have property "material")

Modified: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-07-18 23:28:16 UTC (rev 3608)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2007-07-18 23:29:14 UTC (rev 3609)
@@ -18,7 +18,7 @@
 #include "ZoneProcessor.h"
 
 #include "ActorManager.h"
-#include "GameObjectConstants.h"
+#include "RulesConstants.h"
 #include "ScriptSubsystem.h"
 #include "Trigger.h"
 #include "TriggerFactory.h"



From blakharaz at mail.berlios.de  Thu Jul 19 01:30:57 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 01:30:57 +0200
Subject: [Dsa-hl-svn] r3610 - in rl/trunk/engine/rules: include src
Message-ID: <200707182330.l6INUvM6023852@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 01:30:53 +0200 (Thu, 19 Jul 2007)
New Revision: 3610

Modified:
   rl/trunk/engine/rules/include/Container.h
   rl/trunk/engine/rules/src/Container.cpp
Log:
Replaces unsigned int by (signed) int to avoid warnings

Modified: rl/trunk/engine/rules/include/Container.h
===================================================================
--- rl/trunk/engine/rules/include/Container.h	2007-07-18 23:29:14 UTC (rev 3609)
+++ rl/trunk/engine/rules/include/Container.h	2007-07-18 23:30:53 UTC (rev 3610)
@@ -24,7 +24,6 @@
 namespace rl
 {
     typedef std::set<Item*> ItemSet;
-	typedef std::pair<unsigned int, unsigned int> UintPair;
 
     /// Behaelter fr Items.
     class _RlRulesExport Container : public Item
@@ -41,7 +40,7 @@
 		/** Creates a new container
 		 * @param id the gameobject ID
 		 */
-        Container(unsigned int id);
+        Container(int id);
         virtual ~Container(void);
 
 		/// Get the weight capacity (in Stein)
@@ -51,10 +50,10 @@
         void setCapacity(Ogre::Real capacity);
 
 		/// Set the "volume" to x (width) * y (height) spaces
-		void setVolume(unsigned int x, unsigned int y);
+		void setVolume(int x, int y);
 
 		/// Get the container's "volume" spaces
-		UintPair getVolume() const;
+		IntPair getVolume() const;
 
         /** Returns whether this item is a container
 		 * @return always <code>true</code>
@@ -72,29 +71,29 @@
 		 * @return <code>true</code> if adding was successful, <code>false</code> otherwise (e.g. not enough space)
 		 */
         bool addItem(Item* item);
-		bool addItem(Item* item, UintPair position);
+		bool addItem(Item* item, IntPair position);
         void removeItem(Item* item);
 
         ItemSet getItems() const;
 
 		int getItemCount() const;
 
-        bool isFree(unsigned int x, unsigned int y) const;
-        Item* getItemAt(unsigned int x, unsigned int y) const;
-        void putItemAt(Item* item, unsigned int x, unsigned int y);
-        bool canPlaceAt(Item* item, unsigned int xPos, unsigned int yPos) const;
-        void setItemPosition(Item* item, unsigned int xPos, unsigned int yPos);
-        UintPair getItemPosition(Item* item) const;
+        bool isFree(int x, int y) const;
+        Item* getItemAt(int x, int y) const;
+        void putItemAt(Item* item, int x, int y);
+        bool canPlaceAt(Item* item, int xPos, int yPos) const;
+        void setItemPosition(Item* item, int xPos, int yPos);
+        IntPair getItemPosition(Item* item) const;
 
         virtual const Property getProperty(const Ogre::String& key) const;
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
 
     private:
-		static const UintPair NO_SPACE_FOR_ITEM;
+		static const IntPair NO_SPACE_FOR_ITEM;
 
         Ogre::Real mCapacity;
-		std::pair<unsigned int,unsigned int> mVolume;
+		IntPair mVolume;
 		
 		// Speichert, wo die Items sich im Container befinden.
 		// Speichert also die IDs der Objekte in die einzelnen Volumenfelder
@@ -102,14 +101,13 @@
 
         ItemSet mItems;
 
-        std::map<Item*, UintPair> mItemPositions;
+        std::map<Item*, IntPair> mItemPositions;
 
-        std::pair<unsigned int, unsigned int> 
-			findPositionWithEnoughSpace(UintPair space) const;
+        IntPair	findPositionWithEnoughSpace(IntPair space) const;
         bool checkSpace(
-			unsigned int xStart, 
-			unsigned int yStart, 
-			UintPair space) const;
+			int xStart, 
+			int yStart, 
+			IntPair space) const;
     };
 }
 

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-07-18 23:29:14 UTC (rev 3609)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-07-18 23:30:53 UTC (rev 3610)
@@ -27,7 +27,7 @@
 
 namespace rl {
 
-	const UintPair Container::NO_SPACE_FOR_ITEM = make_pair(1999999999, 1999999999);
+	const IntPair Container::NO_SPACE_FOR_ITEM = make_pair(1999999999, 1999999999);
 
     const Ogre::String Container::CLASS_NAME = "Container";
 
@@ -37,7 +37,7 @@
     const Ogre::String Container::PROPERTY_CONTENT_OBJECTS = "objects";
     const Ogre::String Container::PROPERTY_CONTENT_POSITIONS = "positions";
 
-    Container::Container(unsigned int id)
+    Container::Container(int id)
         : Item(id),
           mCapacity(0.0),
 		  mVolume(std::make_pair(1,1))
@@ -59,12 +59,12 @@
         mCapacity = capacity;
     }
 
-    void Container::setVolume(unsigned int x, unsigned int y)
+    void Container::setVolume(int x, int y)
     {
         mVolume = make_pair(x, y);
     }
 
-    std::pair<unsigned int,unsigned int> Container::getVolume() const
+    std::pair<int,int> Container::getVolume() const
     {
         return mVolume;
     }
@@ -94,7 +94,7 @@
         return addItem(item, findPositionWithEnoughSpace(item->getSize()));
     }
 
-    bool Container::addItem(Item* item, UintPair position)
+    bool Container::addItem(Item* item, IntPair position)
     {
         if(item == NULL)
         {
@@ -102,7 +102,7 @@
         }
 
 
-        UintPair pos = position;
+        IntPair pos = position;
 		if (!canPlaceAt(item, pos.first, pos.second))
 		{
 			pos = findPositionWithEnoughSpace(item->getSize());
@@ -141,7 +141,7 @@
 		return mItems.size();
 	}
 
-    bool Container::canPlaceAt(Item* item, unsigned int xPos, unsigned int yPos) const
+    bool Container::canPlaceAt(Item* item, int xPos, int yPos) const
 	{
 		int xSize = item->getSize().first;
 		int ySize = item->getSize().second;
@@ -155,9 +155,9 @@
             return false;
         }
 
-		for (unsigned int x = xPos; x < (xPos + xSize); x++)
+		for (int x = xPos; x < (xPos + xSize); x++)
         {
-			for (unsigned int y = yPos; y < (yPos + ySize); y++)
+			for (int y = yPos; y < (yPos + ySize); y++)
             {
                 LOG_DEBUG2(Logger::RULES,
 					Ogre::String("Checking Point in Backpack: Point x:")
@@ -177,7 +177,7 @@
 		return true;
 	}
 
-    void Container::setItemPosition(Item* item, unsigned int xPos, unsigned int yPos)
+    void Container::setItemPosition(Item* item, int xPos, int yPos)
     {
         if (mItemPositions.find(item) == mItemPositions.end())
         {
@@ -187,9 +187,9 @@
         mItemPositions[item] = make_pair(xPos, yPos);
     }
 
-	UintPair Container::getItemPosition(Item* item) const
+	IntPair Container::getItemPosition(Item* item) const
     {
-		std::map<Item*, UintPair >::const_iterator it =
+		std::map<Item*, IntPair>::const_iterator it =
 			mItemPositions.find(item);
         if (it == mItemPositions.end())
         {
@@ -199,11 +199,11 @@
 		return (*it).second;
     }
 
-    UintPair Container::findPositionWithEnoughSpace(UintPair space) const
+    IntPair Container::findPositionWithEnoughSpace(IntPair space) const
     {
-		for (unsigned int x = 0; x < mVolume.first; x++)
+		for (int x = 0; x < mVolume.first; x++)
         {
-			for (unsigned int y = 0; y < mVolume.second; y++)
+			for (int y = 0; y < mVolume.second; y++)
             {
 				if (isFree(x, y) && checkSpace(x, y, space))
                 {
@@ -214,7 +214,7 @@
 		return NO_SPACE_FOR_ITEM;
 	}
 
-    bool Container::checkSpace(unsigned int xStart, unsigned int yStart, pair<unsigned int,unsigned int> space) const
+    bool Container::checkSpace(int xStart, int yStart, pair<int,int> space) const
     {
 		// Falls K?stchen nicht mehr im Rucksack, ist auch kein Platz mehr :)
         if ((xStart+space.first) > mVolume.first
@@ -223,9 +223,9 @@
 			return false;
 		}
 
-		for (unsigned int x = 0; x < space.first; x++)
+		for (int x = 0; x < space.first; x++)
         {
-			for (unsigned int y = 0; y < space.second; y++)
+			for (int y = 0; y < space.second; y++)
             {
                 if (!isFree(xStart+x, yStart+y))
                 {
@@ -236,18 +236,18 @@
 		return true;
 	}
 
-    bool Container::isFree(unsigned int x, unsigned int y) const
+    bool Container::isFree(int x, int y) const
     {
         return getItemAt(x, y) == NULL;
     }
 
-    Item* Container::getItemAt(unsigned int x, unsigned int y) const
+    Item* Container::getItemAt(int x, int y) const
     {
-        for (map<Item*, UintPair >::const_iterator iter = mItemPositions.begin();
+        for (map<Item*, IntPair >::const_iterator iter = mItemPositions.begin();
             iter != mItemPositions.end(); iter++)
         {
             Item* item = (*iter).first;
-            UintPair pos = (*iter).second;
+            IntPair pos = (*iter).second;
 
             if (pos.first <= x
                 && pos.second <= y
@@ -292,7 +292,7 @@
 			for (size_t idx = 0; idx < objects.size(); ++idx)
 			{
 				Property curObjProp = objects[idx];
-				UintPair curObjPos = positions[idx].toIntPair();
+				IntPair curObjPos = positions[idx].toIntPair();
 
 				Item* cur = dynamic_cast<Item*>(
 					GameObjectManager::getSingleton().createGameObjectFromProperty(curObjProp));
@@ -324,7 +324,7 @@
 			for (ItemSet::const_iterator it = mItems.begin(); it != mItems.end(); ++it)
 			{
 				Item* cur = *it;
-				UintPair pos = getItemPosition(cur);
+				IntPair pos = getItemPosition(cur);
 				objects.push_back(GameObjectManager::getSingleton().toProperty(cur));
 				positions.push_back(Property(pos));
 			}



From blakharaz at mail.berlios.de  Thu Jul 19 01:31:46 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 01:31:46 +0200
Subject: [Dsa-hl-svn] r3611 - in rl/trunk/engine: common/include common/src
	rules/include rules/src
Message-ID: <200707182331.l6INVkYm023881@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 01:31:40 +0200 (Thu, 19 Jul 2007)
New Revision: 3611

Modified:
   rl/trunk/engine/common/include/Properties.h
   rl/trunk/engine/common/src/Properties.cpp
   rl/trunk/engine/rules/include/Quest.h
   rl/trunk/engine/rules/include/QuestBook.h
   rl/trunk/engine/rules/src/Quest.cpp
   rl/trunk/engine/rules/src/QuestBook.cpp
Log:
Added property support for quest book

Modified: rl/trunk/engine/common/include/Properties.h
===================================================================
--- rl/trunk/engine/common/include/Properties.h	2007-07-18 23:30:53 UTC (rev 3610)
+++ rl/trunk/engine/common/include/Properties.h	2007-07-18 23:31:40 UTC (rev 3611)
@@ -32,7 +32,8 @@
         virtual const Property getProperty(const Ogre::String& key) const = 0;
         virtual void setProperty(const Ogre::String& key, const Property& value) = 0;
         virtual PropertySet* getAllProperties() const = 0;
-        virtual void setProperties(const PropertySet* props);
+        void setProperties(const PropertySet* props);
+        void setProperties(const PropertyMap& propmap);
     };
 
     class _RlCommonExport PropertySet : public PropertyHolder
@@ -40,12 +41,14 @@
 	public:
         PropertySet();
         PropertySet(const PropertySet* ps);
+        PropertySet(const PropertyMap& propmap);
 
         virtual const Property getProperty(const Ogre::String& key) const;
         virtual void setProperty(const Ogre::String& key, const Property& value);
         virtual PropertySet* getAllProperties() const;
         const PropertySetMap::const_iterator begin() const;
         const PropertySetMap::const_iterator end() const;
+        PropertyMap toPropertyMap() const;
         
     private:
         PropertySetMap mProperties;

Modified: rl/trunk/engine/common/src/Properties.cpp
===================================================================
--- rl/trunk/engine/common/src/Properties.cpp	2007-07-18 23:30:53 UTC (rev 3610)
+++ rl/trunk/engine/common/src/Properties.cpp	2007-07-18 23:31:40 UTC (rev 3611)
@@ -34,6 +34,15 @@
         }
     }
 
+    void PropertyHolder::setProperties(const PropertyMap& propmap)
+    {
+        for (PropertyMap::const_iterator it = propmap.begin();
+            it != propmap.end(); it++)
+        {
+            setProperty((*it).first.c_str(), (*it).second);
+        }
+    }
+
     PropertySet::PropertySet()
         : PropertyHolder()
     {
@@ -47,6 +56,13 @@
         setProperties(ps);
     }
 
+    PropertySet::PropertySet(const PropertyMap& propmap)
+        : PropertyHolder()
+    {
+        mProperties.clear();
+        convertToMap(propmap, mProperties);
+    }
+
     const Property PropertySet::getProperty(const Ogre::String& key) const
     {
         PropertySetMap::const_iterator it = mProperties.find(key);
@@ -77,4 +93,9 @@
     {
         return mProperties.end();
     }
+
+    PropertyMap PropertySet::toPropertyMap() const
+    {
+        return convertToPropertyMap(mProperties);
+    }
 }

Modified: rl/trunk/engine/rules/include/Quest.h
===================================================================
--- rl/trunk/engine/rules/include/Quest.h	2007-07-18 23:30:53 UTC (rev 3610)
+++ rl/trunk/engine/rules/include/Quest.h	2007-07-18 23:31:40 UTC (rev 3611)
@@ -29,11 +29,11 @@
 
     typedef std::vector<Quest*> QuestVector;
 
-#undef SUCCEEDED
+    #undef SUCCEEDED
     /**
     * @brief Verwaltet einen Quest oder Subquest
     */
-    class _RlRulesExport Quest : public PropertySet
+    class _RlRulesExport Quest : public PropertyHolder
     {
     public:
         enum State
@@ -48,16 +48,19 @@
         static const CeGuiString STATE_NAMES[5];
         static const CeGuiString KNOWN_NAMES[2];
 
-        static const Ogre::String PROP_NAME;
-        static const Ogre::String PROP_DESCRIPTION;
-        static const Ogre::String PROP_KNOWN;
+        static const Ogre::String PROPERTY_ID;
+        static const Ogre::String PROPERTY_NAME;
+        static const Ogre::String PROPERTY_DESCRIPTION;
+        static const Ogre::String PROPERTY_KNOWN;
 
         /**
         * @param id eine einzigartige ID, um den Quest wiederzufinden
         * @param name Titel des Quests
         * @param description Lange Beschreibung, die im Tagebuch angezeigt wird
         */
-        Quest(const CeGuiString id, const CeGuiString name, const CeGuiString description);
+        Quest(const CeGuiString& id, const CeGuiString& name = "", 
+            const CeGuiString& description = "");
+
         virtual ~Quest();
 
         /**
@@ -176,6 +179,7 @@
         State mState;
         Quest* mParent;
         QuestBook* mQuestBook;
+		PropertySet* mAdditionalProperties;
 
         void checkDone();
         void setParent(Quest* parentQuest);

Modified: rl/trunk/engine/rules/include/QuestBook.h
===================================================================
--- rl/trunk/engine/rules/include/QuestBook.h	2007-07-18 23:30:53 UTC (rev 3610)
+++ rl/trunk/engine/rules/include/QuestBook.h	2007-07-18 23:31:40 UTC (rev 3611)
@@ -33,20 +33,22 @@
 namespace rl {
 
 ///@todo Rename this class to reflect scope changes.
-class _RlRulesExport QuestBook : public EventSource
+class _RlRulesExport QuestBook : public EventSource, public PropertyHolder
 {
 public:
+    static const Ogre::String PROPERTY_QUESTS;
+    static const Ogre::String PROPERTY_JOURNAL;
+
 	QuestBook();
 	~QuestBook();
 
-
 	/**
 	 * Sucht einen Quest anhand einer ID
 	 * @return der Quest
 	 */
-	Quest* getQuest(const CeGuiString id);
+	Quest* getQuest(const CeGuiString id) const;
 
-	QuestVector getTopLevelQuests();
+	QuestVector getTopLevelQuests() const;
 
 	/**
 	 * Fuegt einen Quest hinzu
@@ -69,8 +71,16 @@
 
     void _fireQuestBookChanged(Quest* quest, int reason);
 
+    virtual const Property getProperty(const Ogre::String& key) const;
+    virtual void setProperty(const Ogre::String& key, const Property& value);
+    virtual PropertySet* getAllProperties() const;
+
 private:
-	Quest* getQuest(Quest* parent, const CeGuiString id);
+	Quest* getQuest(Quest* parent, const CeGuiString id) const;
+    void clear();
+    void createRoot();
+    QuestVector getAllQuests() const;
+
 	Quest* mRootQuest;
     std::vector<JournalEntry*> mJournalEntries;
 	EventCaster<QuestEvent> mQuestEventCaster;

Modified: rl/trunk/engine/rules/src/Quest.cpp
===================================================================
--- rl/trunk/engine/rules/src/Quest.cpp	2007-07-18 23:30:53 UTC (rev 3610)
+++ rl/trunk/engine/rules/src/Quest.cpp	2007-07-18 23:31:40 UTC (rev 3611)
@@ -41,13 +41,13 @@
 		{	"UNKNOWN",
             "KNOWN"};
 
-const Ogre::String Quest::PROP_NAME = "str_name";
-const Ogre::String Quest::PROP_DESCRIPTION = "str_description";
-const Ogre::String Quest::PROP_KNOWN = "bool_known";
+const Ogre::String Quest::PROPERTY_ID = "id";
+const Ogre::String Quest::PROPERTY_NAME = "name";
+const Ogre::String Quest::PROPERTY_DESCRIPTION = "description";
+const Ogre::String Quest::PROPERTY_KNOWN = "known";
 
-Quest::Quest(const CeGuiString id, const CeGuiString name, const CeGuiString description)
-:	PropertySet(),
-    mId(id),
+Quest::Quest(const CeGuiString& id, const CeGuiString& name, const CeGuiString& description)
+:	mId(id),
 	mName(name),
 	mDescription(description),
 	mPartsToDo(1),
@@ -58,13 +58,17 @@
 	mQuestBook(NULL),
     mSubquests()
 {
+	mAdditionalProperties = new PropertySet();
 }
 
 Quest::~Quest()
 {
-    for( QuestVector::iterator it = mSubquests.begin();
-        it != mSubquests.end(); it++ )
-           ScriptWrapper::getSingleton().disowned( (*it) );
+    for (QuestVector::iterator it = mSubquests.begin();
+        it != mSubquests.end(); ++it)
+    {
+       ScriptWrapper::getSingleton().disowned(*it);
+       delete *it;
+    }
     mSubquests.clear();
 }
 
@@ -293,51 +297,61 @@
 
 const Property Quest::getProperty(const Ogre::String& key) const
 {
-    if (key == PROP_KNOWN)
+    if (key == PROPERTY_KNOWN)
     {
         return Property(mKnown);
     }
-    else if (key == PROP_NAME)
+    else if (key == PROPERTY_NAME)
     {
+        return Property(mId);
+    }
+    else if (key == PROPERTY_NAME)
+    {
         return Property(mName);
     }
-    else if (key == PROP_DESCRIPTION)
+    else if (key == PROPERTY_DESCRIPTION)
     {
         return Property(mDescription);
     }
     else
     {
-        return PropertySet::getProperty(key);
+        return mAdditionalProperties->getProperty(key);
     }
 }
 
 void Quest::setProperty(const Ogre::String& key, const Property& value)
 {
-    if (key == PROP_KNOWN)
+    if (key == PROPERTY_KNOWN)
     {
         mKnown = value.toBool();
     }
-    else if (key == PROP_NAME)
+    else if (key == PROPERTY_ID)
     {
+        mId = value.toString();
+    }
+    else if (key == PROPERTY_NAME)
+    {
         mName = value.toString();
     }
-    else if (key == PROP_DESCRIPTION)
+    else if (key == PROPERTY_DESCRIPTION)
     {
         mDescription = value.toString();
     }
     else
     {
-        PropertySet::setProperty(key, value);
+        mAdditionalProperties->setProperty(key, value);
     }
 }
 
 PropertySet* Quest::getAllProperties() const
 {
-    PropertySet* ps = PropertySet::getAllProperties();
+    PropertySet* ps = new PropertySet();
 
-    ps->setProperty(PROP_NAME, Property(mName));
-    ps->setProperty(PROP_DESCRIPTION, Property(mDescription));
-    ps->setProperty(PROP_KNOWN, Property(mKnown));
+    ps->setProperty(PROPERTY_ID, Property(mId));
+    ps->setProperty(PROPERTY_NAME, Property(mName));
+    ps->setProperty(PROPERTY_DESCRIPTION, Property(mDescription));
+    ps->setProperty(PROPERTY_KNOWN, Property(mKnown));
+    ps->setProperties(mAdditionalProperties);
 
     return ps;
 }

Modified: rl/trunk/engine/rules/src/QuestBook.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestBook.cpp	2007-07-18 23:30:53 UTC (rev 3610)
+++ rl/trunk/engine/rules/src/QuestBook.cpp	2007-07-18 23:31:40 UTC (rev 3611)
@@ -23,130 +23,222 @@
 using namespace std;
 
 namespace rl {
+    const Ogre::String QuestBook::PROPERTY_QUESTS = "quests";
+    const Ogre::String QuestBook::PROPERTY_JOURNAL = "journal";
 
-QuestBook::QuestBook()
-	: mRootQuest(new Quest("<root>", "<root>", "<root>")) ,
-    mJournalEntries(),
-	mQuestEventCaster(),
-	mJournalEventCaster()
-{
-	mRootQuest->setQuestBook(this);
-	mRootQuest->setState(Quest::OPEN);
-}
+    QuestBook::QuestBook()
+	    : mJournalEntries(),
+	    mQuestEventCaster(),
+	    mJournalEventCaster()
+    {
+        createRoot();
+    }
 
-QuestBook::~QuestBook()
-{
-	delete mRootQuest;
-    for( vector<JournalEntry*>::iterator it = mJournalEntries.begin();
-        it != mJournalEntries.end(); it++ )
-        delete (*it);
-    mJournalEntries.clear();
+    QuestBook::~QuestBook()
+    {
+	    delete mRootQuest;
+        for( vector<JournalEntry*>::iterator it = mJournalEntries.begin();
+            it != mJournalEntries.end(); it++ )
+        {
+            delete *it;
+        }
+        mJournalEntries.clear();
+    }
 
-}
+    void QuestBook::createRoot()
+    {
+        mRootQuest = new Quest("<root>", "<root>", "<root>"); 
+	    mRootQuest->setQuestBook(this);
+	    mRootQuest->setState(Quest::OPEN);
+    }
 
-Quest* QuestBook::getQuest(const CeGuiString id)
-{
-	return getQuest(mRootQuest, id);
-}
+    Quest* QuestBook::getQuest(const CeGuiString id) const
+    {
+	    return getQuest(mRootQuest, id);
+    }
 
-Quest* QuestBook::getQuest(Quest* parent, const CeGuiString id)
-{
-	if (parent->getId().compare(id) == 0)
-		return parent;
+    Quest* QuestBook::getQuest(Quest* parent, const CeGuiString id) const
+    {
+	    if (parent->getId().compare(id) == 0)
+		    return parent;
 
-	QuestVector children = parent->getSubquests();
-	for(QuestVector::iterator it = children.begin(); it != children.end(); it++)
-	{
-		Quest* subquest = getQuest(*it, id);
-		if (subquest != NULL)
-			return subquest;
-	}
+	    QuestVector children = parent->getSubquests();
+	    for(QuestVector::iterator it = children.begin(); it != children.end(); it++)
+	    {
+		    Quest* subquest = getQuest(*it, id);
+		    if (subquest)
+		    {
+			    return subquest;
+		    }
+	    }
 
-	return NULL;
-}
+	    return NULL;
+    }
 
-void QuestBook::addQuest(Quest* quest)
-{
-	mRootQuest->addSubquest(quest);
-}
+    void QuestBook::addQuest(Quest* quest)
+    {
+	    mRootQuest->addSubquest(quest);
+    }
 
-void QuestBook::_fireQuestBookChanged(Quest *quest, int reason )
-{
-	QuestEvent* evt = new QuestEvent( this, reason );
-	evt->setQuest(quest);
-	mQuestEventCaster.dispatchEvent(evt);
-	delete evt;
-}
+    void QuestBook::_fireQuestBookChanged(Quest *quest, int reason)
+    {
+	    QuestEvent* evt = new QuestEvent(this, reason);
+	    evt->setQuest(quest);
+	    mQuestEventCaster.dispatchEvent(evt);
+	    delete evt;
+    }
 
-void QuestBook::fireJournalChanged(JournalEntry* entry, int reason)
-{
-	JournalEvent evt = JournalEvent(this, reason, entry);
-	mJournalEventCaster.dispatchEvent(&evt);
-}
+    void QuestBook::fireJournalChanged(JournalEntry* entry, int reason)
+    {
+	    JournalEvent evt = JournalEvent(this, reason, entry);
+	    mJournalEventCaster.dispatchEvent(&evt);
+    }
 
-void QuestBook::addQuestListener(QuestListener* listener)
-{
-	if (mQuestEventCaster.containsListener(listener) !=
-        mJournalEventCaster.containsListener(listener))
+    void QuestBook::addQuestListener(QuestListener* listener)
     {
-        Throw(AssertionFailedError, "listener registration inconsistent");
+	    if (mQuestEventCaster.containsListener(listener) !=
+            mJournalEventCaster.containsListener(listener))
+        {
+            Throw(AssertionFailedError, "listener registration inconsistent");
+        }
+	    else if (!mJournalEventCaster.containsListener(listener))
+        {
+		    mJournalEventCaster.addEventListener(listener);
+		    mQuestEventCaster.addEventListener(listener);
+            ScriptWrapper::getSingleton().owned( listener );
+        }
     }
-	else if (!mJournalEventCaster.containsListener(listener))
+
+    void QuestBook::removeQuestListener(QuestListener* listener)
     {
-		mJournalEventCaster.addEventListener(listener);
-		mQuestEventCaster.addEventListener(listener);
-        ScriptWrapper::getSingleton().owned( listener );
+	    if (mQuestEventCaster.containsListener(listener) !=
+            mJournalEventCaster.containsListener(listener))
+        {
+            Throw(AssertionFailedError, "listener registration inconsistent");
+        }
+	    else if (mJournalEventCaster.containsListener( listener ))
+        {
+	        mJournalEventCaster.removeEventListener(listener);
+	        mQuestEventCaster.removeEventListener(listener);
+            ScriptWrapper::getSingleton().disowned( listener );
+        }
     }
-}
 
-void QuestBook::removeQuestListener(QuestListener* listener)
-{
-	if (mQuestEventCaster.containsListener(listener) !=
-        mJournalEventCaster.containsListener(listener))
+    QuestVector QuestBook::getTopLevelQuests() const
     {
-        Throw(AssertionFailedError, "listener registration inconsistent");
+	    return mRootQuest->getSubquests();
     }
-	else if (mJournalEventCaster.containsListener( listener ))
+
+    void QuestBook::addJournalEntry(JournalEntry* entry)
     {
-	    mJournalEventCaster.removeEventListener(listener);
-	    mQuestEventCaster.removeEventListener(listener);
-        ScriptWrapper::getSingleton().disowned( listener );
+        mJournalEntries.push_back(entry);
+
+        LOG_MESSAGE(
+            Logger::RULES,
+            Ogre::String("Journal entry added: ") + entry->getCaption());
+
+        fireJournalChanged(entry, JournalEvent::JOURNAL_ENTRY_ADDED);
     }
-}
 
-QuestVector QuestBook::getTopLevelQuests()
-{
-	return mRootQuest->getSubquests();
-}
+    void QuestBook::addJournalEntry(CeGuiString caption, CeGuiString text)
+    {
+        addJournalEntry(new JournalEntry(caption, text));
+    }
 
-void QuestBook::addJournalEntry(JournalEntry* entry)
-{
-    mJournalEntries.push_back(entry);
+    unsigned int QuestBook::getNumJournalEntries() const
+    {
+        return mJournalEntries.size();
+    }
 
-    LOG_MESSAGE(
-        Logger::RULES,
-        Ogre::String("Journal entry added: ") + entry->getCaption());
+    JournalEntry* QuestBook::getJournalEntry(unsigned int index) const
+    {
+        if (mJournalEntries.size() <= index)
+        {
+            Throw(IllegalArgumentException, "No such JournalEntry.");
+        }
+        return mJournalEntries[index];
+    }
 
-    fireJournalChanged(entry, JournalEvent::JOURNAL_ENTRY_ADDED);
-}
+    const Property QuestBook::getProperty(const Ogre::String& key) const
+    {
+        if (key == PROPERTY_QUESTS)
+        {
+            PropertyVector quests;
+            QuestVector allQuests = getAllQuests();
+            for (QuestVector::const_iterator it = allQuests.begin();
+                it != allQuests.end(); ++it)
+            {
+                PropertySet* questProps = (*it)->getAllProperties();
+                quests.push_back(Property(questProps->toPropertyMap()));
+                delete questProps;
+            }
 
-void QuestBook::addJournalEntry(CeGuiString caption, CeGuiString text)
-{
-    addJournalEntry(new JournalEntry(caption, text));
-}
+            return Property(quests);
+        }
+        else if (key == PROPERTY_JOURNAL)
+        {
+            ///@todo implement journal properties
+            return Property();
+        }
+        else
+        {
+            Throw(IllegalArgumentException, key + " is not a property of QuestBook");
+        }
+    }
 
-unsigned int QuestBook::getNumJournalEntries() const
-{
-    return mJournalEntries.size();
-}
+    void QuestBook::setProperty(const Ogre::String& key, const Property& value)
+    {
+        if (key == PROPERTY_QUESTS)
+        {
+            PropertyVector quests = value.toArray();
+            for (PropertyVector::const_iterator it = quests.begin(); 
+                it != quests.end(); ++it)
+            {
+                PropertyMap curVal = it->toMap();
+                CeGuiString id = curVal[Quest::PROPERTY_ID];
+                Quest* quest = getQuest(id);
+                if (!quest)
+                {
+                    quest = new Quest(id);
+                }
+               
+                quest->setProperties(curVal);
+            }
+            ///@todo implement
+        }
+        else if (key == PROPERTY_JOURNAL)
+        {
+            ///@todo implement journal properties
+        }
+        else
+        {
+            Throw(IllegalArgumentException, key + " is not a property of QuestBook");
+        }
+    }
 
-JournalEntry* QuestBook::getJournalEntry(unsigned int index) const
-{
-    if (mJournalEntries.size() <= index)
+    PropertySet* QuestBook::getAllProperties() const
     {
-        Throw(IllegalArgumentException, "No such JournalEntry.");
+        PropertySet* props = new PropertySet();
+        props->setProperty(PROPERTY_QUESTS, getProperty(PROPERTY_QUESTS));
+        props->setProperty(PROPERTY_JOURNAL, getProperty(PROPERTY_JOURNAL));
+        return props;
     }
-    return mJournalEntries[index];
-}
 
+    QuestVector QuestBook::getAllQuests() const
+    {
+        QuestVector quests = getTopLevelQuests();
+        unsigned int lastPos = 0;
+        while (lastPos < quests.size())
+        {
+            QuestVector sub = quests[lastPos]->getSubquests();
+
+            for (QuestVector::const_iterator it = sub.begin(); it != sub.end(); ++it)
+            {
+                quests.push_back(*it);
+            }
+
+            ++lastPos;
+        }
+        return quests;
+    }
 }



From blakharaz at mail.berlios.de  Thu Jul 19 01:32:42 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 01:32:42 +0200
Subject: [Dsa-hl-svn] r3612 - modules/regressiontest/scripts
Message-ID: <200707182332.l6INWgcO023931@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 01:32:38 +0200 (Thu, 19 Jul 2007)
New Revision: 3612

Modified:
   modules/regressiontest/scripts/SelectorTest.rb
Log:


Modified: modules/regressiontest/scripts/SelectorTest.rb
===================================================================
--- modules/regressiontest/scripts/SelectorTest.rb	2007-07-18 23:31:40 UTC (rev 3611)
+++ modules/regressiontest/scripts/SelectorTest.rb	2007-07-18 23:32:38 UTC (rev 3612)
@@ -2,9 +2,8 @@
 require 'testcase.rb'
 
 class SelectorTest < TestCase
-    include Math
 
-    @@radius = 5
+    @@radius = 2.5
     
     def execute()
         min_base = [-@@radius, 0.05, -@@radius]



From blakharaz at mail.berlios.de  Thu Jul 19 11:05:23 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 11:05:23 +0200
Subject: [Dsa-hl-svn] r3613 - in modules/regressiontest/scripts: . maps
Message-ID: <200707190905.l6J95NXq011423@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 11:05:20 +0200 (Thu, 19 Jul 2007)
New Revision: 3613

Added:
   modules/regressiontest/scripts/MaterialSlotTest.rb
Modified:
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
Missing file for material change slot test :)

Added: modules/regressiontest/scripts/MaterialSlotTest.rb
===================================================================
--- modules/regressiontest/scripts/MaterialSlotTest.rb	2007-07-18 23:32:38 UTC (rev 3612)
+++ modules/regressiontest/scripts/MaterialSlotTest.rb	2007-07-19 09:05:20 UTC (rev 3613)
@@ -0,0 +1,40 @@
+require 'globals.rb'
+require 'gameobjectprops.rb'
+
+class Clothing < Item
+	include GameObjectProperties
+
+	def setProperty(key, value)
+		if (key == "material")
+			@_prop_material = value
+		else
+		   super(key, value)
+		end
+		
+	end
+
+	def getProperty(key)
+		if (key == "material")
+			return @_prop_material
+		else
+		    return super(key)
+		end
+		
+	end
+end
+
+class MaterialSlotTest < TestCase
+    def execute()
+        test_obj1 = $GOM.createGameObject("mckhero")
+        test_obj1.setPosition(rel_pos([0, 0, 0]))
+        test_obj1.placeIntoScene();
+        test_item1 = $GOM.createGameObject("Clothes #1")
+        test_obj1.getInventory().hold(test_item1, "Torso")
+
+        test_obj2 = $GOM.createGameObject("mckhero")
+        test_obj2.setPosition(rel_pos([2, 0, 0]))
+        test_obj2.placeIntoScene();
+        test_item2 = $GOM.createGameObject("Clothes #2")
+        test_obj2.getInventory().hold(test_item2, "Torso")
+    end
+end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2007-07-18 23:32:38 UTC (rev 3612)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2007-07-19 09:05:20 UTC (rev 3613)
@@ -2,6 +2,24 @@
 
 require 'player.rb'
 require 'hero.rb'
+
+# Physik aktivieren
+$PM.setEnabled(true)
+
+$SCRIPT.log("init map 'regressiontest'...")
+
+$SCRIPT.log("Prepare hero for being the active character")
+#$hero = $GOM.getGameObject(1); # single mesh hero
+$hero = $GOM.getGameObject(10); # construction kit hero
+PlayerSettings.preparePlayer($hero)
+
+$SCRIPT.log("Set hero as active character")
+$UI.setActiveCharacter($hero)
+
+$SCRIPT.log("Hero ready")
+
+$SCRIPT.log("begin tests.");
+
 require 'doortest.rb'
 require 'GameObjectCreationTest.rb'
 require 'GameObjectStatesTest.rb'
@@ -21,23 +39,6 @@
 require 'SelectorTest.rb'
 
 
-# Physik aktivieren
-$PM.setEnabled(true)
-
-$SCRIPT.log("init map 'regressiontest'...")
-
-$SCRIPT.log("Prepare hero for being the active character")
-#$hero = $GOM.getGameObject(1); # single mesh hero
-$hero = $GOM.getGameObject(10); # construction kit hero
-PlayerSettings.preparePlayer($hero)
-
-$SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
-
-$SCRIPT.log("Hero ready")
-
-$SCRIPT.log("begin tests.");
-
  MaterialSlotTest.new([-15, 0, -5]).run()
     LightzoneTest.new([-10, 0, -5]).run()
 ErrorHandlingTest.new([-10, 0, 5]).run()



From blakharaz at mail.berlios.de  Thu Jul 19 11:57:00 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 11:57:00 +0200
Subject: [Dsa-hl-svn] r3614 - modules/common/gui/windows
Message-ID: <200707190957.l6J9v0cp014462@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 11:56:58 +0200 (Thu, 19 Jul 2007)
New Revision: 3614

Modified:
   modules/common/gui/windows/progresswindow.xml
Log:
Use StatusBar for displaying progress 

Modified: modules/common/gui/windows/progresswindow.xml
===================================================================
--- modules/common/gui/windows/progresswindow.xml	2007-07-19 09:05:20 UTC (rev 3613)
+++ modules/common/gui/windows/progresswindow.xml	2007-07-19 09:56:58 UTC (rev 3614)
@@ -5,16 +5,17 @@
 		<Property Name="Text" Value="Bitte warten"/>
 
 		<Window Type="RastullahLook/StaticText" Name="ProgressWindow/Text">
-            <Property Name="UnifiedPosition" Value="{{0,15},{0,26}}"/>
-            <Property Name="UnifiedSize" Value="{{0,370},{0,50}}"/>
+            <Property Name="UnifiedPosition" Value="{{0,25},{0,26}}"/>
+            <Property Name="UnifiedSize" Value="{{1,-50},{0,50}}"/>
 			<Property Name="FrameEnabled" Value="False"/>
 			<Property Name="Text" Value="Rastullahs Lockenpracht l?dt Daten, bitte warten..." />
             <Property Name="HorzFormatting" Value="WordWrapCentred" />
 		</Window>
 
-		<Window Type="RastullahLook/ProgressBar" Name="ProgressWindow/ProgressBar">
-            <Property Name="UnifiedPosition" Value="{{0,15},{0,100}}"/>
-            <Property Name="UnifiedSize" Value="{{0,370},{0,50}}"/>
+		<Window Type="RastullahLook/StatusBar" Name="ProgressWindow/ProgressBar">
+            <Property Name="UnifiedPosition" Value="{{0,25},{0,100}}"/>
+            <Property Name="UnifiedSize" Value="{{1,-50},{0,20}}"/>
+			<Property Name="StatusColour" Value="FFC7B74E"/>
 		</Window>
     </Window>
 </GUILayout>



From pnyx at mail.berlios.de  Thu Jul 19 12:08:04 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 19 Jul 2007 12:08:04 +0200
Subject: [Dsa-hl-svn] r3615 - in modules: common/materials
	common/materials/programs regressiontest/materials
Message-ID: <200707191008.l6JA84hN015015@sheep.berlios.de>

Author: pnyx
Date: 2007-07-19 12:07:59 +0200 (Thu, 19 Jul 2007)
New Revision: 3615

Added:
   modules/common/materials/programs/Torso_Pixel_Shader_2.source
Modified:
   modules/common/materials/men_human_female_torso.mesh.material
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
   modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
   modules/common/materials/programs/Torso_Vertex_Shader.material
   modules/regressiontest/materials/obj_Shortsleeve.material
   modules/regressiontest/materials/obj_Shortsleeve_2.material
Log:
Fixed obj_Shortsleeve.materials
Added Shader for longsleeve

Modified: modules/common/materials/men_human_female_torso.mesh.material
===================================================================
--- modules/common/materials/men_human_female_torso.mesh.material	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/common/materials/men_human_female_torso.mesh.material	2007-07-19 10:07:59 UTC (rev 3615)
@@ -1,4 +1,4 @@
-material men_human_female_torso : Torso_Vertex_Shader
+material men_human_female_torso : Torso_Vertex_Shader_Short
 {
 	set_texture_alias skin rl_mensch_female.png
 	set_texture_alias cloth obj_shortsleeve02_diffuse.png

Modified: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-19 10:07:59 UTC (rev 3615)
@@ -59,17 +59,6 @@
 				param_named groundcolor float4 0.10 0.10 0.10 1.0
 			}
 			
-			// HLSL Vertex Shader
-		/*	shadow_receiver_vertex_program_ref Basic_Vertex_Shader_SR
-			{
-				//Shader Constant: matWorldViewProjection
-				param_named_auto matWorldViewProjection worldviewproj_matrix
-				//Shader Constant: matWorld
-				param_named_auto matWorld world_matrix
-				//Shader Constant: matTextureViewProjection
-				param_named_auto matTextureViewProjection texture_viewproj_matrix
-			}*/
-
 			texture_unit
 			{
 				texture_alias diffuse

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-19 10:07:59 UTC (rev 3615)
@@ -12,7 +12,7 @@
       		//alpha_rejection greater 50
       		
       		cull_hardware anticlockwise 
-      		cull_software anticlockwise 
+      		cull_software back 
       		
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader
@@ -57,7 +57,7 @@
       		//alpha_rejection greater 50
       		
       		cull_hardware clockwise 
-      		cull_software clockwise 
+      		cull_software front 
       		
 			//DirectX 9.0 HLSL Pixel Shader ps_2_0
 			fragment_program_ref Basic_Pixel_Shader

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-07-19 10:07:59 UTC (rev 3615)
@@ -1,12 +1,5 @@
 //Effect: Textured
 
-//DirectX 9.0 HLSL Vertex Shader vs_2_0
-vertex_program Basic_Vertex_Shader hlsl
-{
-	source Basic_Vertex_Shader.source
-	target vs_2_0
-	entry_point vs_main
-}
 //DirectX 9.0 HLSL Pixel Shader ps_2_0
 fragment_program Basic_Pixel_Shader_Variation hlsl
 {

Added: modules/common/materials/programs/Torso_Pixel_Shader_2.source
===================================================================
--- modules/common/materials/programs/Torso_Pixel_Shader_2.source	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/common/materials/programs/Torso_Pixel_Shader_2.source	2007-07-19 10:07:59 UTC (rev 3615)
@@ -0,0 +1,22 @@
+sampler2D baseMap;
+sampler2D clothMap;
+
+struct PS_INPUT 
+{
+   float2 Texcoord : TEXCOORD0;
+   float2 Texcoord1: TEXCOORD1;
+   float2 Texcoord2: TEXCOORD2;
+   float4 Color    : TEXCOORD3;
+   
+};
+
+float4 ps_main( PS_INPUT Input ) : COLOR0
+{
+
+   float4 skin = tex2D( baseMap, Input.Texcoord );	
+   float4 cloth = tex2D( clothMap, Input.Texcoord2 );
+   return float4(lerp(skin.rgb,cloth.rgb, cloth.a )* Input.Color.rgb,skin.a+cloth.a);
+}
+
+
+

Modified: modules/common/materials/programs/Torso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.material	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/common/materials/programs/Torso_Vertex_Shader.material	2007-07-19 10:07:59 UTC (rev 3615)
@@ -7,8 +7,15 @@
 	entry_point ps_main
 }
 
-material Torso_Vertex_Shader
+fragment_program Torso_Pixel_Shader_2 hlsl
 {
+	source Torso_Pixel_Shader_2.source
+	target ps_2_0
+	entry_point ps_main
+}
+
+material Torso_Vertex_Shader_Short
+{
 	technique
 	{
 		//Rendering Pass: Pass 0 (pass index: #0 )
@@ -56,3 +63,54 @@
 		}
 	}
 }
+
+
+material Torso_Vertex_Shader_Long
+{
+	technique
+	{
+		//Rendering Pass: Pass 0 (pass index: #0 )
+		pass
+		{
+			alpha_rejection greater 128
+			//DirectX 9.0 HLSL Pixel Shader ps_2_0
+			fragment_program_ref Torso_Pixel_Shader_2
+			{
+			}
+			//DirectX 9.0 HLSL Vertex Shader vs_2_0
+			vertex_program_ref Basic_Vertex_Shader
+			{
+				// param_named_auto
+
+				param_named_auto Light1_attenuation light_attenuation 0				
+				param_named_auto Light1_color light_diffuse_colour 0
+				param_named_auto Light1_position light_position_object_space 0
+				param_named Light1_spec_power float 0.3
+				
+				param_named_auto Light2_attenuation light_attenuation 1
+				param_named_auto Light2_color light_diffuse_colour 1
+				param_named_auto Light2_position light_position_object_space 1
+				param_named Light2_spec_power float 0.3
+				
+				param_named_auto matViewProjection worldviewproj_matrix
+				param_named_auto vViewPosition camera_position_object_space
+				
+				
+				param_named skycolor float4 0.5 0.5 0.5 1.0
+				param_named groundcolor float4 0.10 0.10 0.10 1.0
+			}
+
+			texture_unit
+			{
+				texture_alias skin
+				//texture nat_felsen_01.dds 2d
+			}
+			
+			texture_unit
+			{
+				texture_alias cloth
+				//texture nat_felsen_01.dds 2d
+			}
+		}
+	}
+}

Modified: modules/regressiontest/materials/obj_Shortsleeve.material
===================================================================
--- modules/regressiontest/materials/obj_Shortsleeve.material	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/regressiontest/materials/obj_Shortsleeve.material	2007-07-19 10:07:59 UTC (rev 3615)
@@ -1,6 +1,6 @@
 
-material obj_Shortsleeve : Basic_Vertex_Shader
+material obj_Shortsleeve : Torso_Vertex_Shader_Short
 {
-set_texture_alias diffuse obj_shortsleeve02_diffuse.png
-
+	set_texture_alias skin rl_mensch_female.png
+	set_texture_alias cloth obj_shortsleeve02_diffuse.png
 }

Modified: modules/regressiontest/materials/obj_Shortsleeve_2.material
===================================================================
--- modules/regressiontest/materials/obj_Shortsleeve_2.material	2007-07-19 09:56:58 UTC (rev 3614)
+++ modules/regressiontest/materials/obj_Shortsleeve_2.material	2007-07-19 10:07:59 UTC (rev 3615)
@@ -1,6 +1,6 @@
 
-material obj_Shortsleeve_2 : Basic_Vertex_Shader
+material obj_Shortsleeve_2 : Torso_Vertex_Shader_Short
 {
-set_texture_alias diffuse obj_shortsleeve_dummy.png
-
+	set_texture_alias skin rl_mensch_female.png
+	set_texture_alias cloth obj_shortsleeve_dummy.png
 }



From blakharaz at mail.berlios.de  Thu Jul 19 12:08:10 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 12:08:10 +0200
Subject: [Dsa-hl-svn] r3616 - modules/common/models
Message-ID: <200707191008.l6JA8AEG015030@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 12:07:59 +0200 (Thu, 19 Jul 2007)
New Revision: 3616

Modified:
   modules/common/models/men_alrike_mesh.skeleton
Log:
renamed some animations

Modified: modules/common/models/men_alrike_mesh.skeleton
===================================================================
(Binary files differ)



From pnyx at mail.berlios.de  Thu Jul 19 12:08:42 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 19 Jul 2007 12:08:42 +0200
Subject: [Dsa-hl-svn] r3617 - rl/trunk/engine/ui/src
Message-ID: <200707191008.l6JA8gmv015075@sheep.berlios.de>

Author: pnyx
Date: 2007-07-19 12:08:41 +0200 (Thu, 19 Jul 2007)
New Revision: 3617

Modified:
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
irgend ein include ding :)

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-19 10:07:59 UTC (rev 3616)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-07-19 10:08:41 UTC (rev 3617)
@@ -32,6 +32,7 @@
 #include "ItemIconDragContainer.h"
 #include "Selector.h"
 #include "WindowFactory.h"
+#include "Container.h"
 
 using namespace CEGUI;
 using namespace Ogre;



From blakharaz at mail.berlios.de  Thu Jul 19 12:14:16 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 12:14:16 +0200
Subject: [Dsa-hl-svn] r3618 - in rl/trunk: . engine/ai engine/common
	engine/common/src engine/core/src engine/script/include
Message-ID: <200707191014.l6JAEGvP015396@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 12:14:12 +0200 (Thu, 19 Jul 2007)
New Revision: 3618

Added:
   rl/trunk/engine/script/include/Makefile.am
Modified:
   rl/trunk/configure.in
   rl/trunk/engine/ai/Makefile.am
   rl/trunk/engine/common/Makefile.am
   rl/trunk/engine/common/src/Makefile.am
   rl/trunk/engine/core/src/Makefile.am
Log:


Modified: rl/trunk/configure.in
===================================================================
--- rl/trunk/configure.in	2007-07-19 10:08:41 UTC (rev 3617)
+++ rl/trunk/configure.in	2007-07-19 10:14:12 UTC (rev 3618)
@@ -181,7 +181,7 @@
         engine/dialog/Makefile engine/dialog/src/Makefile engine/dialog/include/Makefile \
         engine/ui/Makefile engine/ui/src/Makefile engine/ui/include/Makefile \
         engine/rules/Makefile engine/rules/src/Makefile engine/rules/include/Makefile \
-        engine/script/Makefile engine/script/swig/Makefile engine/script/src/Makefile \
+        engine/script/Makefile engine/script/swig/Makefile engine/script/src/Makefile engine/script/include/Makefile \
         engine/startup/Makefile engine/startup/src/Makefile \
         tests/Makefile tests/coretests/Makefile tests/rulestests/Makefile \
         tests/multimediatests/Makefile tests/RlDialogTests/Makefile \

Modified: rl/trunk/engine/ai/Makefile.am
===================================================================
--- rl/trunk/engine/ai/Makefile.am	2007-07-19 10:08:41 UTC (rev 3617)
+++ rl/trunk/engine/ai/Makefile.am	2007-07-19 10:14:12 UTC (rev 3618)
@@ -1,3 +1,3 @@
-SUBDIRS = src include
+SUBDIRS = include src
 
 

Modified: rl/trunk/engine/common/Makefile.am
===================================================================
--- rl/trunk/engine/common/Makefile.am	2007-07-19 10:08:41 UTC (rev 3617)
+++ rl/trunk/engine/common/Makefile.am	2007-07-19 10:14:12 UTC (rev 3618)
@@ -1,3 +1,3 @@
-SUBDIRS = src include
+SUBDIRS = include src
 
 

Modified: rl/trunk/engine/common/src/Makefile.am
===================================================================
--- rl/trunk/engine/common/src/Makefile.am	2007-07-19 10:08:41 UTC (rev 3617)
+++ rl/trunk/engine/common/src/Makefile.am	2007-07-19 10:14:12 UTC (rev 3618)
@@ -3,6 +3,7 @@
 lib_LTLIBRARIES = libRlCommon.la
 libRlCommon_la_LDFLAGS = $(RUBY_LIBS) $(OGRE_LIBS) $(CEGUI_LIBS) $(BOOST_FILESYSTEM_LIB) $(LIBS)
 libRlCommon_la_SOURCES = \
+  ../include/stdinc.h \
   ConfigFile.cpp \
   EventObject.cpp \
   EventSource.cpp \

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-07-19 10:08:41 UTC (rev 3617)
+++ rl/trunk/engine/core/src/Makefile.am	2007-07-19 10:14:12 UTC (rev 3618)
@@ -4,7 +4,7 @@
 INCLUDES = $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(CEGUI_CFLAGS) $(STLPORT_CFLAGS) -I../include -I../../common/include -I../include/nulldriver $(meshmagick_CFLAGS)
 
 lib_LTLIBRARIES = libRlCore.la
-libRlCore_la_LDFLAGS = $(OGRE_LIBS) $(CEGUI_LIBS) $(RUBY_LIBS) $(LIBS) -lmeshmagick
+libRlCore_la_LDFLAGS = $(OGRE_LIBS) $(CEGUI_LIBS) $(RUBY_LIBS) $(LIBS) $(meshmagick_LIBS)
 libRlCore_la_SOURCES = \
 	Actor.cpp \
 	ActorControlledObject.cpp \

Added: rl/trunk/engine/script/include/Makefile.am
===================================================================
--- rl/trunk/engine/script/include/Makefile.am	2007-07-19 10:08:41 UTC (rev 3617)
+++ rl/trunk/engine/script/include/Makefile.am	2007-07-19 10:14:12 UTC (rev 3618)
@@ -0,0 +1,16 @@
+noinst_HEADERS = \
+	AbstractMapNodeProcessor.h \
+	EntityNodeProcessor.h \
+	EnvironmentProcessor.h \
+	GameObjectNodeProcessor.h \
+	LightNodeProcessor.h \
+	MapLoader.h \
+	ParticleSystemNodeProcessor.h \
+	TriggerFactory.h \
+	SoundNodeProcessor.h \
+	ScriptObjectMarker.h \
+	ScriptPrerequisites.h \
+	ScriptSubsystem.h \
+	WaypointProcessor.h \
+	UnifiedFactory.h \
+	ZoneProcessor.h



From blakharaz at mail.berlios.de  Thu Jul 19 12:18:04 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 12:18:04 +0200
Subject: [Dsa-hl-svn] r3619 - rl/trunk/engine/script/src
Message-ID: <200707191018.l6JAI4oa015623@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 12:18:03 +0200 (Thu, 19 Jul 2007)
New Revision: 3619

Modified:
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
Log:
Fix null pointer assert exception when no fog is set in scene file

Modified: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-07-19 10:14:12 UTC (rev 3618)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2007-07-19 10:18:03 UTC (rev 3619)
@@ -29,141 +29,139 @@
 {
 	bool EnvironmentProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
 	{
-		if (nodeElem == NULL)
+		if (nodeElem)
 		{
-			return false;
-		}
+		    processSkySettings(XmlHelper::getChildNamed(nodeElem, "sky"));
+		    processFogSettings(XmlHelper::getChildNamed(nodeElem, "fog"));
+        }
 
-		processSkySettings(XmlHelper::getChildNamed(nodeElem, "sky"));
-		processFogSettings(XmlHelper::getChildNamed(nodeElem, "fog"));
-
 		return true;
 	}
 
-
 	void EnvironmentProcessor::processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* skyElem)
 	{
-        if (skyElem == NULL)
+        if (skyElem)
 		{
-			return;
-		}
 
-		if (!XmlHelper::hasAttribute(skyElem, "material")
-			|| !XmlHelper::hasAttribute(skyElem, "type"))
-		{
-			LOG_ERROR(Logger::RULES, "<sky> element must have at least attributes 'type' and 'material'.");
-		}
-		else
-		{
-			Ogre::String type = XmlHelper::getAttributeValueAsStdString(skyElem, "type");
-			Ogre::String material = XmlHelper::getAttributeValueAsStdString(skyElem, "material");
+		    if (!XmlHelper::hasAttribute(skyElem, "material")
+			    || !XmlHelper::hasAttribute(skyElem, "type"))
+		    {
+			    LOG_ERROR(Logger::RULES, "<sky> element must have at least attributes 'type' and 'material'.");
+		    }
+		    else
+		    {
+			    Ogre::String type = XmlHelper::getAttributeValueAsStdString(skyElem, "type");
+			    Ogre::String material = XmlHelper::getAttributeValueAsStdString(skyElem, "material");
 
-			bool drawFirst = true;
-			if (XmlHelper::hasAttribute(skyElem, "drawfirst"))
-			{
-				drawFirst = XmlHelper::getAttributeValueAsBool(skyElem, "drawfirst");
-			}
+			    bool drawFirst = true;
+			    if (XmlHelper::hasAttribute(skyElem, "drawfirst"))
+			    {
+				    drawFirst = XmlHelper::getAttributeValueAsBool(skyElem, "drawfirst");
+			    }
 
-			Ogre::Real distance = 5000;
-			if (XmlHelper::hasAttribute(skyElem, "distance"))
-			{
-				distance = XmlHelper::getAttributeValueAsReal(skyElem, "distance");
-			}
+			    Ogre::Real distance = 5000;
+			    if (XmlHelper::hasAttribute(skyElem, "distance"))
+			    {
+				    distance = XmlHelper::getAttributeValueAsReal(skyElem, "distance");
+			    }
 
-			if (type == "dome")
-			{
-				Ogre::Real curvature = 10;
-				Ogre::Real tiling = 8;
+			    if (type == "dome")
+			    {
+				    Ogre::Real curvature = 10;
+				    Ogre::Real tiling = 8;
 
-				DOMElement* domeSettings = XmlHelper::getChildNamed(skyElem, "skydomesettings");
-				if (domeSettings != NULL)
-				{
-					if (XmlHelper::hasAttribute(domeSettings, "curvature"))
-					{
-						curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "curvature");
-					}
-					if (XmlHelper::hasAttribute(domeSettings, "tiling"))
-					{
-						curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "tiling");
-					}
-				}
-				CoreSubsystem::getSingleton().getWorld()->setSkyDome(
-					true, material, curvature, tiling, distance, drawFirst);
-			}
-			else if (type == "box")
-			{
-				CoreSubsystem::getSingleton().getWorld()->setSkyBox(true, material, distance, drawFirst);
-			}
-			else if (type == "plane")
-			{
-				LOG_ERROR(Logger::RULES, "Sky Plane is not implemented yet.");
-			}
-		}
+				    DOMElement* domeSettings = XmlHelper::getChildNamed(skyElem, "skydomesettings");
+				    if (domeSettings != NULL)
+				    {
+					    if (XmlHelper::hasAttribute(domeSettings, "curvature"))
+					    {
+						    curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "curvature");
+					    }
+					    if (XmlHelper::hasAttribute(domeSettings, "tiling"))
+					    {
+						    curvature = XmlHelper::getAttributeValueAsReal(domeSettings, "tiling");
+					    }
+				    }
+				    CoreSubsystem::getSingleton().getWorld()->setSkyDome(
+					    true, material, curvature, tiling, distance, drawFirst);
+			    }
+			    else if (type == "box")
+			    {
+				    CoreSubsystem::getSingleton().getWorld()->setSkyBox(true, material, distance, drawFirst);
+			    }
+			    else if (type == "plane")
+			    {
+				    LOG_ERROR(Logger::RULES, "Sky Plane is not implemented yet.");
+			    }
+		    }
+        }
 	}
 
 
 	void EnvironmentProcessor::processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem)
 	{
-		///@todo process fog node
-		if (!XmlHelper::hasAttribute(fogElem, "material"))
-		{
-			LOG_ERROR(
-				Logger::RULES,
-				"<fog> element must have at least the attribute 'type'.");
-			return;
-		}
+        if (fogElem)
+        {
+		    if (!XmlHelper::hasAttribute(fogElem, "material"))
+		    {
+			    LOG_ERROR(
+				    Logger::RULES,
+				    "<fog> element must have at least the attribute 'type'.");
+			    return;
+		    }
 
-		DOMElement* colourElem = XmlHelper::getChildNamed(fogElem, "colour");
-		if (colourElem == NULL)
-		{
-			LOG_ERROR(Logger::RULES, "No fog colour set.");
-			return;
-		}
-		ColourValue fogColour = processColour(colourElem);
+		    DOMElement* colourElem = XmlHelper::getChildNamed(fogElem, "colour");
+		    if (colourElem == NULL)
+		    {
+			    LOG_ERROR(Logger::RULES, "No fog colour set.");
+			    return;
+		    }
+		    ColourValue fogColour = processColour(colourElem);
 
-		Ogre::String type = XmlHelper::getAttributeValueAsStdString(fogElem, "type");
-		if (type == "exp" || type == "exp2")
-		{
-			if (XmlHelper::hasAttribute(fogElem, "density"))
-			{
-				Ogre::Real density = XmlHelper::getAttributeValueAsReal(fogElem, "density");
-				if (type == "exp")
-				{
-					CoreSubsystem::getSingleton().getWorld()->setFog(
-						World::FOG_EXP, fogColour, density);
-				}
-				else if (type == "exp2")
-				{
-					CoreSubsystem::getSingleton().getWorld()->setFog(
-						World::FOG_EXP2, fogColour, density);
-				}
-			}
-			else
-			{
-				LOG_ERROR(
-					Logger::RULES, type + " fog needs attribute 'density'.");
-			}
-		}
-		else if (type == "linear")
-		{
-			if (XmlHelper::hasAttribute(fogElem, "start")
-				&& XmlHelper::hasAttribute(fogElem, "end"))
-			{
-				Ogre::Real start = XmlHelper::getAttributeValueAsReal(fogElem, "start");
-				Ogre::Real end = XmlHelper::getAttributeValueAsReal(fogElem, "end");
-				CoreSubsystem::getSingleton().getWorld()->setFog(
-					World::FOG_LINEAR, fogColour, 0, start, end);
-			}
-			else
-			{
-				LOG_ERROR(
-					Logger::RULES, "linear fog needs attributes 'start' and 'end'.");
-			}
-		}
-		else
-		{
-			LOG_ERROR(
-				Logger::RULES, type + " is an unknown fog type.");
-		}
+		    Ogre::String type = XmlHelper::getAttributeValueAsStdString(fogElem, "type");
+		    if (type == "exp" || type == "exp2")
+		    {
+			    if (XmlHelper::hasAttribute(fogElem, "density"))
+			    {
+				    Ogre::Real density = XmlHelper::getAttributeValueAsReal(fogElem, "density");
+				    if (type == "exp")
+				    {
+					    CoreSubsystem::getSingleton().getWorld()->setFog(
+						    World::FOG_EXP, fogColour, density);
+				    }
+				    else if (type == "exp2")
+				    {
+					    CoreSubsystem::getSingleton().getWorld()->setFog(
+						    World::FOG_EXP2, fogColour, density);
+				    }
+			    }
+			    else
+			    {
+				    LOG_ERROR(
+					    Logger::RULES, type + " fog needs attribute 'density'.");
+			    }
+		    }
+		    else if (type == "linear")
+		    {
+			    if (XmlHelper::hasAttribute(fogElem, "start")
+				    && XmlHelper::hasAttribute(fogElem, "end"))
+			    {
+				    Ogre::Real start = XmlHelper::getAttributeValueAsReal(fogElem, "start");
+				    Ogre::Real end = XmlHelper::getAttributeValueAsReal(fogElem, "end");
+				    CoreSubsystem::getSingleton().getWorld()->setFog(
+					    World::FOG_LINEAR, fogColour, 0, start, end);
+			    }
+			    else
+			    {
+				    LOG_ERROR(
+					    Logger::RULES, "linear fog needs attributes 'start' and 'end'.");
+			    }
+		    }
+		    else
+		    {
+			    LOG_ERROR(
+				    Logger::RULES, type + " is an unknown fog type.");
+		    }
+        }
 	}
 }



From chrber at mail.berlios.de  Thu Jul 19 13:19:46 2007
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Thu, 19 Jul 2007 13:19:46 +0200
Subject: [Dsa-hl-svn] r3620 - rl/trunk/engine/rules/include
Message-ID: <200707191119.l6JBJkev010186@sheep.berlios.de>

Author: chrber
Date: 2007-07-19 13:19:42 +0200 (Thu, 19 Jul 2007)
New Revision: 3620

Modified:
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/include/RulesConstants.h
Log:
Added a missing newline
Removed GameObjectConstants.h from Makefile


Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-07-19 10:18:03 UTC (rev 3619)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-07-19 11:19:42 UTC (rev 3620)
@@ -17,7 +17,6 @@
 	Eigenschaft.h \
 	EigenschaftenStateSet.h \
 	GameObject.h \
-	GameObjectConstants.h \
 	GameObjectStateListener.h \
 	Item.h \
 	Inventory.h \

Modified: rl/trunk/engine/rules/include/RulesConstants.h
===================================================================
--- rl/trunk/engine/rules/include/RulesConstants.h	2007-07-19 10:18:03 UTC (rev 3619)
+++ rl/trunk/engine/rules/include/RulesConstants.h	2007-07-19 11:19:42 UTC (rev 3620)
@@ -51,4 +51,5 @@
     };
 }
 
-#endif // __RULESCONSTANTS_H__
\ No newline at end of file
+#endif // __RULESCONSTANTS_H__
+



From blakharaz at mail.berlios.de  Thu Jul 19 13:39:21 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 13:39:21 +0200
Subject: [Dsa-hl-svn] r3621 - in modules: common/scripts
	regressiontest/scripts
Message-ID: <200707191139.l6JBdLC5004389@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 13:39:15 +0200 (Thu, 19 Jul 2007)
New Revision: 3621

Added:
   modules/common/scripts/mckhero.rb
Removed:
   modules/regressiontest/scripts/mckhero.rb
Log:
Moved remotely

Copied: modules/common/scripts/mckhero.rb (from rev 3620, modules/regressiontest/scripts/mckhero.rb)

Deleted: modules/regressiontest/scripts/mckhero.rb
===================================================================
--- modules/regressiontest/scripts/mckhero.rb	2007-07-19 11:19:42 UTC (rev 3620)
+++ modules/regressiontest/scripts/mckhero.rb	2007-07-19 11:39:15 UTC (rev 3621)
@@ -1,58 +0,0 @@
-load "embed.rb"
-
-class MCKHero < Person
-    def initialize(id)
-        super(id);
-        addQueryFlag(RlScript::QUERYFLAG_PLAYER)
-	setName("Alrike");
-	setDescription("Heldin von Berufung");
-	$SCRIPT.log("Gute Eigenschaften zuweisen...");
-
-        setEigenschaft("MU", 12);
-        setEigenschaft("KL", 8);
-        setEigenschaft("IN", 9);
-        setEigenschaft("CH", 10);
-        setEigenschaft("FF", 11);
-        setEigenschaft("GE", 12);
-        setEigenschaft("KO", 13); #KO
-        setEigenschaft("KK", 14); #KK
-	setWert(Creature::WERT_MOD_LE, 10); # LE-Mod
-
-	$SCRIPT.log("LeP und AuP auff?llen");
-        modifyLe(1000, false); # LeP = LE
-        modifyAu(1000); # Au = voll
-        #modifyLe(-20); # 10 LeP abziehen
-
-	$SCRIPT.log("Talente hinzuf?gen");
-	addTalent("Athletik", 3);
-	#addTalent("K?rperbeherrschung", 3);
-
-        $SCRIPT.log("Heldenaktor beschreiben...");
-
-	$SCRIPT.log("Inventar konfigurieren.");
-	inv = getInventory();
-	inv.addSlot("Left Ring", "Bip01 L Finger21", Item::ITEMTYPE_RING);
-	inv.addSlot("Right Ring", "Bip01 R Finger21", Item::ITEMTYPE_RING);
-	inv.addSlot("Left Hand", "Bip01 L SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Right Hand", "Bip01 R SlotHand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Head", "Bip01 Head", Item::ITEMTYPE_HELMET, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Back", "back", Item::ITEMTYPE_ALL_ITEMS, RlScript::SLOT_SUBMESH);
-	#inv.addSlot("Back", "Bip01 Neck", Item::ITEMTYPE_ALL_ITEMS);
-    inv.addSlot("Armor", "armor", Item::ITEMTYPE_ARMOR, RlScript::SLOT_SUBMESH);
-	inv.addSlot("Torso", "men_human_female_torso", Item::ITEMTYPE_ARMOR, RlScript::SLOT_MATERIAL);
-	
-
-	#addSounds()
-        $SCRIPT.log("done.");
-    end
-
-    def addSounds
-        heroActor = getActor()
-        soundActor = $AM.createSoundSampleActor(heroActor.getName()+"_schlucken","schlucken.ogg");
-        heroActor.attachToSlot(soundActor, "huefte");
-        @mSchmerzSchreiSound = $AM.createSoundSampleActor("SchmerzSchreiSound","schmerz_schrei_au_01.ogg");
-        heroActor.attachToSlot(@mSchmerzSchreiSound, "huefte");
-    end
-
-end
-



From blakharaz at mail.berlios.de  Thu Jul 19 13:43:06 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 19 Jul 2007 13:43:06 +0200
Subject: [Dsa-hl-svn] r3622 - modules/ruchin/scripts
Message-ID: <200707191143.l6JBh6dq004634@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-19 13:43:04 +0200 (Thu, 19 Jul 2007)
New Revision: 3622

Removed:
   modules/ruchin/scripts/mckhero.rb
Log:
Moved to common

Deleted: modules/ruchin/scripts/mckhero.rb
===================================================================
--- modules/ruchin/scripts/mckhero.rb	2007-07-19 11:39:15 UTC (rev 3621)
+++ modules/ruchin/scripts/mckhero.rb	2007-07-19 11:43:04 UTC (rev 3622)
@@ -1,55 +0,0 @@
-load "embed.rb"
-
-class MCKHero < Person
-    def initialize(id)
-        super(id);
-        addQueryFlag(RlScript::QUERYFLAG_PLAYER)
-	setName("Alrike");
-	setDescription("Heldin von Berufung");
-	$SCRIPT.log("Gute Eigenschaften zuweisen...");
-
-        setEigenschaft("MU", 12);
-        setEigenschaft("KL", 8);
-        setEigenschaft("IN", 9);
-        setEigenschaft("CH", 10);
-        setEigenschaft("FF", 11);
-        setEigenschaft("GE", 12);
-        setEigenschaft("KO", 13); #KO
-        setEigenschaft("KK", 14); #KK
-	setWert(Creature::WERT_MOD_LE, 10); # LE-Mod
-
-	$SCRIPT.log("LeP und AuP auff?llen");
-        modifyLe(1000, false); # LeP = LE
-        modifyAu(1000); # Au = voll
-        #modifyLe(-20); # 10 LeP abziehen
-
-	$SCRIPT.log("Talente hinzuf?gen");
-	addTalent("Athletik", 3);
-	#addTalent("K?rperbeherrschung", 3);
-
-        $SCRIPT.log("Heldenaktor beschreiben...");
-
-	$SCRIPT.log("Inventar konfigurieren.");
-	inv = getInventory();
-	inv.addSlot("Left Ring", "l_finger_2", Item::ITEMTYPE_RING);
-	inv.addSlot("Right Ring", "r_finger_2", Item::ITEMTYPE_RING);
-	inv.addSlot("Left Hand", "l_hand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Right Hand", "r_hand", Item::ITEMTYPE_ALL_ITEMS);
-	inv.addSlot("Head", "head", Item::ITEMTYPE_HELMET, false);
-	inv.addSlot("Back", "hals", Item::ITEMTYPE_ALL_ITEMS);
-        inv.addSlot("Armor", "torso", Item::ITEMTYPE_ARMOR, false);
-
-	#addSounds()
-        $SCRIPT.log("done.");
-    end
-
-    def addSounds
-        heroActor = getActor()
-        soundActor = $AM.createSoundSampleActor(heroActor.getName()+"_schlucken","schlucken.ogg");
-        heroActor.attachToSlot(soundActor, "huefte");
-        @mSchmerzSchreiSound = $AM.createSoundSampleActor("SchmerzSchreiSound","schmerz_schrei_au_01.ogg");
-        heroActor.attachToSlot(@mSchmerzSchreiSound, "huefte");
-    end
-
-end
-



From melven at mail.berlios.de  Thu Jul 19 19:15:06 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 19 Jul 2007 19:15:06 +0200
Subject: [Dsa-hl-svn] r3623 - in rl/trunk/engine/ui: include src
Message-ID: <200707191715.l6JHF6ak022323@sheep.berlios.de>

Author: melven
Date: 2007-07-19 19:14:44 +0200 (Thu, 19 Jul 2007)
New Revision: 3623

Modified:
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Removed "static" variables (removed problems that occured, when this class is destroyed and recreated)

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-07-19 11:43:04 UTC (rev 3622)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-07-19 17:14:44 UTC (rev 3623)
@@ -151,6 +151,16 @@
         //void interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor);
 
 
+        // only used in the two functions above
+        std::vector<Ogre::Vector3> mCharPositionsBuffer;
+        size_t mCharPositionsBufferIdx;
+        Ogre::Real mCharacterOccludedTime;
+        unsigned int mCharacterOccludedFrameCount;
+        Ogre::Real mLastDistance;
+        Ogre::Real mTimeOfLastCollision;
+        bool mIsPathfinding;
+        unsigned int mLastReachableBufPos;
+
         /** Does all camera-stuff, moves the camera to the right position 
         * and does pathfinding (in a very simple way)
         * @warning this does only work well, if the character's material is not used for other objects!

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-19 11:43:04 UTC (rev 3622)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-19 17:14:44 UTC (rev 3623)
@@ -95,7 +95,15 @@
         mRaycast(new PhysicsMaterialRaycast()),
         mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
         mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE)
+            QUERYFLAG_CREATURE),
+        mCharPositionsBuffer(20),
+        mCharPositionsBufferIdx(-1),
+        mCharacterOccludedTime(0),
+        mCharacterOccludedFrameCount(0),
+        mLastDistance(0.0f),
+        mTimeOfLastCollision(0.0f),
+        mIsPathfinding (false),
+        mLastReachableBufPos(1)
     {
         DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
 
@@ -572,35 +580,15 @@
         mCamBody->getPositionOrientation(camPos, camOri);
         SceneNode* cameraNode = mCameraActor->_getSceneNode();
 
-/*
-        // Ringbuffer mit Positionen der Kamera
-        static std::vector<Ogre::Vector3> camPositionsBuffer(20);
-        static size_t camPositionsBufferIdx = -1;
-        camPositionsBufferIdx = (camPositionsBufferIdx + 1) % camPositionsBuffer.size();
-        camPositionsBuffer[camPositionsBufferIdx] = camPos;
 
-        // Ringbuffer mit optimalen Positionen der Kamera
-        static std::vector<Ogre::Vector3> camOptPositionsBuffer(20);
-        static size_t camOptPositionsBufferIdx = -1;
-        camOptPositionsBufferIdx = (camOptPositionsBufferIdx + 1) % camOptPositionsBuffer.size();
-*/
         Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
         charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-//        camOptPositionsBuffer[camOptPositionsBufferIdx] = optimalCamPos;
 
-
         // Ringbuffer mit Positionen des Characters
-        static std::vector<Ogre::Vector3> charPositionsBuffer(20);
-        static size_t charPositionsBufferIdx = -1;
-        charPositionsBufferIdx = (charPositionsBufferIdx + 1) % charPositionsBuffer.size();
-        charPositionsBuffer[charPositionsBufferIdx] = charPos;
+        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
+        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
 
 
-        static Real characterOccludedTime = 0;
-        static unsigned int characterOccludedFrameCount = 0;
-
-
-
         // Kamera-Gr?e beziehen
         CameraObject* ogreCam = static_cast<CameraObject*>(
             mCameraActor->getControlledObject());
@@ -647,11 +635,11 @@
             Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
             if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
             {
-                characterOccludedTime += timestep;
-                characterOccludedFrameCount++;
+                mCharacterOccludedTime += timestep;
+                mCharacterOccludedFrameCount++;
 
                 // falls zu lange, Kamera resetten:
-                if( characterOccludedTime > 0.500f && characterOccludedFrameCount > 10 )
+                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
                 {
                     resetCamera();
                     return;
@@ -659,7 +647,7 @@
 
             }
             else
-                characterOccludedTime = 0;
+                mCharacterOccludedTime = 0;
 
             if( infoCastOptPos.mBody )
             {
@@ -701,8 +689,6 @@
             }
 
 
-            static bool isPathfinding (false);
-            static unsigned int lastReachableBufPos;
             // gibt an, ob schon gebufferte Daten fr den
             // neuen Weg existieren und dort weitergemacht werden kann,
             // oder ob neu nach einem Weg gesucht werden muss!
@@ -715,9 +701,9 @@
                 // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
                 // und weich (keine scharfen Kurven) erscheinen
 
-                size_t buffSize = charPositionsBuffer.size();
+                size_t buffSize = mCharPositionsBuffer.size();
 
-                if( !isPathfinding )
+                if( !mIsPathfinding )
                 {
                     LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
 
@@ -731,7 +717,7 @@
                             world,
                             &materialVector,
                             camPos,
-                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
                             true);
 
                         if( !info.mBody )
@@ -742,14 +728,14 @@
                     {
                         // is wohl irgendwas schiefgegangen!
                         LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
-                        isPathfinding = false;
+                        mIsPathfinding = false;
                         resetCamera();
                         return;
                     }
-                    lastReachableBufPos = delta;
+                    mLastReachableBufPos = delta;
 
                     // auf zu der ermittelten Position!
-                    optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
                 }
                 else
                 {
@@ -757,30 +743,30 @@
 
 
                     // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = lastReachableBufPos; // das ist die von der letzten Frame!
+                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
                     while ( delta > 0 ) // delta = 0 braucht nicht berprft zu werden, wurde oben schon ausgeschlossen!
                     {
                         RaycastInfo info = mRaycast->execute(
                             world,
                             &materialVector,
                             camPos,
-                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
                             true);
 
                         if( info.mBody )
                             break;
                         delta--;
                     }
-                    lastReachableBufPos = delta + 1;
+                    mLastReachableBufPos = delta + 1;
 
                     // auf zu der ermittelten Position!
-                    optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
                 }
-                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
             }
             else
             {
-                isPathfinding = false;
+                mIsPathfinding = false;
             }
 
             Vector3 diff = camPos - optimalCamPos;
@@ -910,12 +896,10 @@
             }
 
             // Langsames Entfernen vom Char:
-            static Real lastDistance(0.0f);
-            static Real TimeOfLastCollision(0.0f);
             if( CollisionFound )
-                TimeOfLastCollision = 0.0f;
+                mTimeOfLastCollision = 0.0f;
             else
-                TimeOfLastCollision += timestep;
+                mTimeOfLastCollision += timestep;
 
 
             Real desiredDistance = diff.length();
@@ -924,7 +908,7 @@
             mCamBody->getPositionOrientation(camPos, camOri);
 
             if( SlowlyMoveBackward &&
-                desiredDistance > lastDistance )
+                desiredDistance > mLastDistance )
             {
 
                 diff.normalise();
@@ -932,21 +916,21 @@
                 Vector3 actDiff = camPos - charPos;
                 actDiff.normalise();
 
-                if( TimeOfLastCollision > mCamMoveAwayStartTime ||
+                if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
                     diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = lastDistance + mCamMoveAwayVelocity*timestep;
+                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
                 else
-                    newDistance = lastDistance;
+                    newDistance = mLastDistance;
 
                 if( newDistance > desiredDistance )
                     newDistance = desiredDistance;
 
                 diff = diff*newDistance;
 
-                lastDistance = newDistance;
+                mLastDistance = newDistance;
             }
             else
-                lastDistance = desiredDistance;
+                mLastDistance = desiredDistance;
 
 
             targetCamPos = charPos + diff;



From melven at mail.berlios.de  Thu Jul 19 23:04:51 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 19 Jul 2007 23:04:51 +0200
Subject: [Dsa-hl-svn] r3624 - in rl/trunk/engine/rules: include src
Message-ID: <200707192104.l6JL4pLK030663@sheep.berlios.de>

Author: melven
Date: 2007-07-19 23:04:31 +0200 (Thu, 19 Jul 2007)
New Revision: 3624

Modified:
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
Now the materialId is set back to the ol material after releasing the creature from the creaturecontroller

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-07-19 17:14:44 UTC (rev 3623)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-07-19 21:04:31 UTC (rev 3624)
@@ -174,6 +174,8 @@
         // only used in userProcess
         Ogre::Real mLastFloorContact;
 
+        // used to reset the material
+        const OgreNewt::MaterialID *mOldMaterialId;
     };
 
     /// this is the base class of all movements

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-19 17:14:44 UTC (rev 3623)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-19 21:04:31 UTC (rev 3624)
@@ -1023,10 +1023,6 @@
                         Real v1x = ( sx - v0 * t1 / 2 ) / ( Math::Sqrt( mTanJumpAngle * (2*sx /g - v0 * t1/g) ) + t1/2);
                         Real v1y = mTanJumpAngle * v1x;
 
-std::ostringstream oss;
-oss << "v0: " << v0 << "    v1x: " << v1x << "    timediff: " << mApplyForceTimer - mApplyForceTime;
-LOG_MESSAGE(Logger::RULES, oss.str());
-
                         Vector3 v_now = mMovingCreature->getVelocity();
                         ax =  (v1x - -v_now.z) / timestep;
                         ay = (v1y- v_now.y)/timestep + g;
@@ -1147,6 +1143,7 @@
     {
         CreatureControllerManager::getSingleton().add(this);
 
+        mOldMaterialId = mCreature->getActor()->getPhysicalThing()->_getBody()->getMaterialGroupID();
         const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID("character");
         mCreature->getActor()->getPhysicalThing()->setMaterialID(material);
 
@@ -1204,6 +1201,7 @@
 
         mCreature->getActor()->getPhysicalThing()->setPhysicsController(NULL);
 
+        mCreature->getActor()->getPhysicalThing()->setMaterialID(mOldMaterialId);
         CreatureControllerManager::getSingleton().remove(this);
     }
 



From tanis at mail.berlios.de  Fri Jul 20 21:52:59 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Fri, 20 Jul 2007 21:52:59 +0200
Subject: [Dsa-hl-svn] r3625 - modules/common/materials/programs
Message-ID: <200707201952.l6KJqxn7014006@sheep.berlios.de>

Author: tanis
Date: 2007-07-20 21:52:49 +0200 (Fri, 20 Jul 2007)
New Revision: 3625

Modified:
   modules/common/materials/programs/Basic_Vertex_Shader.material
   modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
   modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
   modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
   modules/common/materials/programs/Basic_Vertex_Shader_ground.material
   modules/common/materials/programs/Torso_Vertex_Shader.material
Log:
Add fallback technique to base materials, used when cards don't support shaders.

Modified: modules/common/materials/programs/Basic_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-19 21:04:31 UTC (rev 3624)
+++ modules/common/materials/programs/Basic_Vertex_Shader.material	2007-07-20 19:52:49 UTC (rev 3625)
@@ -66,4 +66,15 @@
 			}
 		}
 	}
+
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
 }

Modified: modules/common/materials/programs/Basic_Vertex_ShaderUV1.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-07-19 21:04:31 UTC (rev 3624)
+++ modules/common/materials/programs/Basic_Vertex_ShaderUV1.material	2007-07-20 19:52:49 UTC (rev 3625)
@@ -48,4 +48,14 @@
 			}
 		}
 	}
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
 }

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-19 21:04:31 UTC (rev 3624)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Alpha.material	2007-07-20 19:52:49 UTC (rev 3625)
@@ -94,4 +94,15 @@
 		
 		
 	}	
-}
\ No newline at end of file
+
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
+}

Modified: modules/common/materials/programs/Basic_Vertex_Shader_Variation.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-07-19 21:04:31 UTC (rev 3624)
+++ modules/common/materials/programs/Basic_Vertex_Shader_Variation.material	2007-07-20 19:52:49 UTC (rev 3625)
@@ -67,4 +67,14 @@
 			}
 		}
 	}
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
 }

Modified: modules/common/materials/programs/Basic_Vertex_Shader_ground.material
===================================================================
--- modules/common/materials/programs/Basic_Vertex_Shader_ground.material	2007-07-19 21:04:31 UTC (rev 3624)
+++ modules/common/materials/programs/Basic_Vertex_Shader_ground.material	2007-07-20 19:52:49 UTC (rev 3625)
@@ -54,4 +54,14 @@
 			}
 		}
 	}
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias diffuse
+            }
+        }
+    }
 }

Modified: modules/common/materials/programs/Torso_Vertex_Shader.material
===================================================================
--- modules/common/materials/programs/Torso_Vertex_Shader.material	2007-07-19 21:04:31 UTC (rev 3624)
+++ modules/common/materials/programs/Torso_Vertex_Shader.material	2007-07-20 19:52:49 UTC (rev 3625)
@@ -62,6 +62,21 @@
 			}
 		}
 	}
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias skin
+            }
+            texture_unit
+            {
+                colour_op alpha_blend
+                texture_alias cloth
+            }
+        }
+    }
 }
 
 
@@ -113,4 +128,19 @@
 			}
 		}
 	}
+	technique
+	{
+        pass
+        {
+            texture_unit
+            {
+                texture_alias skin
+            }
+            texture_unit
+            {
+                colour_op alpha_blend
+                texture_alias cloth
+            }
+        }
+    }
 }



From blakharaz at mail.berlios.de  Wed Jul 25 21:15:35 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 25 Jul 2007 21:15:35 +0200
Subject: [Dsa-hl-svn] r3626 - rl/trunk/engine/core/src
Message-ID: <200707251915.l6PJFZoc009730@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-25 21:15:11 +0200 (Wed, 25 Jul 2007)
New Revision: 3626

Modified:
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
Log:
* reattach all attached movables to changed object
* resolves bug #21


Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-07-20 19:52:49 UTC (rev 3625)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-07-25 19:15:11 UTC (rev 3626)
@@ -120,6 +120,7 @@
 		Entity* newEnt = CoreSubsystem::getSingletonPtr()->getWorld()
 			->getSceneManager()->createEntity(oldEnt->getName()+"_", newMesh->getName());
 
+
 		Node* parentNode = oldEnt->getParentNode();
 		if (parentNode != NULL)
 		{
@@ -137,6 +138,38 @@
 			parentSceneNode->attachObject(newEnt);
 		}
 
+        std::map<Ogre::String, Ogre::MovableObject*> childObjectMap;
+
+        for (Entity::ChildObjectListIterator it = oldEnt->getAttachedObjectIterator();
+            it.hasMoreElements();)
+        {
+            MovableObject* mo = it.peekNextValue();
+
+            //go upwards and find first tagpoint parent (all attached objects must have a tagpoint as parent)
+            Node* parent = mo->getParentNode();
+            while (!dynamic_cast<TagPoint*>(parent) && parent)
+            {
+                parent = parent->getParent();
+            }
+
+            if (parent)
+            {
+                //tagpoints are children of a bone
+                Bone* bone = dynamic_cast<Bone*>(parent->getParent());
+                Ogre::String key = bone->getName();
+                childObjectMap[key] = mo;
+            }
+
+            it.moveNext();
+        }
+
+        for (std::map<Ogre::String, Ogre::MovableObject*>::const_iterator itChild = childObjectMap.begin();
+                itChild != childObjectMap.end(); ++itChild)
+        {
+            oldEnt->detachObjectFromBone(itChild->second);
+            newEnt->attachObjectToBone(itChild->first, itChild->second);
+        }
+
 		mMovableObject = newEnt;
 		CoreSubsystem::getSingletonPtr()->getWorld()
 			->getSceneManager()->destroyEntity(oldEnt);



From blakharaz at mail.berlios.de  Wed Jul 25 21:27:24 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 25 Jul 2007 21:27:24 +0200
Subject: [Dsa-hl-svn] r3627 - rl/trunk/engine/core/src
Message-ID: <200707251927.l6PJROhU010488@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-25 21:27:16 +0200 (Wed, 25 Jul 2007)
New Revision: 3627

Modified:
   rl/trunk/engine/core/src/MergeableMeshObject.cpp
Log:
removed unnecessary operations


Modified: rl/trunk/engine/core/src/MergeableMeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-07-25 19:15:11 UTC (rev 3626)
+++ rl/trunk/engine/core/src/MergeableMeshObject.cpp	2007-07-25 19:27:16 UTC (rev 3627)
@@ -121,14 +121,10 @@
 			->getSceneManager()->createEntity(oldEnt->getName()+"_", newMesh->getName());
 
 
-		Node* parentNode = oldEnt->getParentNode();
-		if (parentNode != NULL)
+		TagPoint* parentTp = dynamic_cast<TagPoint*>(oldEnt->getParentNode());
+		if (parentTp)
 		{
-			TagPoint* tp = dynamic_cast<TagPoint*>(parentNode);
-			if (tp != NULL)
-			{
-				tp->setChildObject(newEnt);
-			}
+			parentTp->setChildObject(newEnt);
 		}
 
 		SceneNode* parentSceneNode = oldEnt->getParentSceneNode();
@@ -145,13 +141,9 @@
         {
             MovableObject* mo = it.peekNextValue();
 
-            //go upwards and find first tagpoint parent (all attached objects must have a tagpoint as parent)
-            Node* parent = mo->getParentNode();
-            while (!dynamic_cast<TagPoint*>(parent) && parent)
-            {
-                parent = parent->getParent();
-            }
-
+            //go upwards to tagpoint (all attached objects must have a tagpoint as parent)
+            TagPoint* parent = dynamic_cast<TagPoint*>(mo->getParentNode());
+            
             if (parent)
             {
                 //tagpoints are children of a bone



From pnyx at mail.berlios.de  Thu Jul 26 22:36:14 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 26 Jul 2007 22:36:14 +0200
Subject: [Dsa-hl-svn] r3628 - in modules/ruchin: maps materials/textures
	models
Message-ID: <200707262036.l6QKaETT023966@sheep.berlios.de>

Author: pnyx
Date: 2007-07-26 22:30:36 +0200 (Thu, 26 Jul 2007)
New Revision: 3628

Added:
   modules/ruchin/materials/textures/stadtwachebanner.png
   modules/ruchin/models/Ruchin_j.mesh
   modules/ruchin/models/Ruchin_u.mesh
   modules/ruchin/models/Stadtwache.material
Modified:
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/models/House_dummies.mesh
   modules/ruchin/models/Ruchin_Stadtwache.mesh
   modules/ruchin/models/Ruchin_l.mesh
   modules/ruchin/models/Ruchin_r.mesh
Log:
added part u and j

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-07-25 19:27:16 UTC (rev 3627)
+++ modules/ruchin/maps/ruchin.scene	2007-07-26 20:30:36 UTC (rev 3628)
@@ -91,7 +91,7 @@
 
 		</node>
 		<node name="Ruchin_r" id="13" >
-			<position x="70.0" y="8.0" z="26.0" />
+			<position x="70.0" y="0.0" z="30.0" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<entity
@@ -212,7 +212,7 @@
 		</node>
 		
 		<node name="Ruchin_Stadtwache" id="28" >
-			<position x="107.681" y="4.66676" z="47.1081" />
+			<position x="105.681" y="0.0" z="45." />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<entity
@@ -315,9 +315,33 @@
 				materialFile="ruchin_terrain.material"
 				castsShadow="false"
 			/>
+		</node>
+	
+	<node name="Ruchin_u" id="3" >
+			<position x="100.0" y="0.0" z="50.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Statue_0dsf1"
+				id="4"
+				meshFile ="Ruchin_u.mesh"
+				materialFile="ruchin_terrain.material"
+				castsShadow="false"
+			/>
+		</node>
+			
+			<node name="Ruchin_j" id="3" >
+			<position x="40.0" y="0.0" z="-100.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Ruchin_j"
+				id="4"
+				meshFile ="Ruchin_j.mesh"
+				materialFile="ruchin_terrain.material"
+				castsShadow="false"
+			/>
 
-
-
 		</node>
 	</nodes>
 </scene>
\ No newline at end of file

Added: modules/ruchin/materials/textures/stadtwachebanner.png
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/materials/textures/stadtwachebanner.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/models/House_dummies.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_Stadtwache.mesh
===================================================================
(Binary files differ)

Added: modules/ruchin/models/Ruchin_j.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/Ruchin_j.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/models/Ruchin_l.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_r.mesh
===================================================================
(Binary files differ)

Added: modules/ruchin/models/Ruchin_u.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/Ruchin_u.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/ruchin/models/Stadtwache.material
===================================================================
--- modules/ruchin/models/Stadtwache.material	2007-07-25 19:27:16 UTC (rev 3627)
+++ modules/ruchin/models/Stadtwache.material	2007-07-26 20:30:36 UTC (rev 3628)
@@ -0,0 +1,24 @@
+material Stadtwache/Wand : Ruchin_Stadtmauer/Wand
+{
+
+}
+
+material Stadtwache/Base : Ruchin/base
+{
+
+}
+
+material Stadtwache/Dach : Ruchin_Stadtmauer/Dach
+{
+
+}
+
+material Stadtwache/Metall: Basic_Vertex_Shader
+{
+	set_texture_alias diffuse  metal.jpg
+}
+
+material Stadtwache/Banner: Basic_Vertex_Shader
+{
+	set_texture_alias diffuse stadtwachebanner.png
+}



From pnyx at mail.berlios.de  Thu Jul 26 22:44:32 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Thu, 26 Jul 2007 22:44:32 +0200
Subject: [Dsa-hl-svn] r3629 - modules/ruchin/maps
Message-ID: <200707262044.l6QKiWSZ024434@sheep.berlios.de>

Author: pnyx
Date: 2007-07-26 22:44:29 +0200 (Thu, 26 Jul 2007)
New Revision: 3629

Modified:
   modules/ruchin/maps/ruchin.scene
Log:
fixed Stadtwache position

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-07-26 20:30:36 UTC (rev 3628)
+++ modules/ruchin/maps/ruchin.scene	2007-07-26 20:44:29 UTC (rev 3629)
@@ -212,7 +212,7 @@
 		</node>
 		
 		<node name="Ruchin_Stadtwache" id="28" >
-			<position x="105.681" y="0.0" z="45." />
+			<position x="105.0" y="0.0" z="45.0" />
 			<rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
 			<scale x="1.0" y="1.0" z="1.0" />
 			<entity



From tanis at mail.berlios.de  Fri Jul 27 19:16:09 2007
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Fri, 27 Jul 2007 19:16:09 +0200
Subject: [Dsa-hl-svn] r3630 - in rl/trunk/engine: core core/include core/src
	script/swig
Message-ID: <200707271716.l6RHG90r006710@sheep.berlios.de>

Author: tanis
Date: 2007-07-27 19:15:42 +0200 (Fri, 27 Jul 2007)
New Revision: 3630

Removed:
   rl/trunk/engine/core/include/AnimationListener.h
   rl/trunk/engine/core/include/CoreEvents.h
   rl/trunk/engine/core/src/AnimationListener.cpp
   rl/trunk/engine/core/src/CoreEvents.cpp
Modified:
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/BaseAnimation.h
   rl/trunk/engine/core/include/CoreMessages.h
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/src/BaseAnimation.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
Log:
AnimationListener replaced by MessageSystem, CoreEvent removed, was unused.

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-07-27 17:15:42 UTC (rev 3630)
@@ -364,10 +364,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\AnimationListener.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\AnimationManager.h"
 				>
 			</File>
@@ -396,10 +392,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\CoreEvents.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\CoreMessages.h"
 				>
 			</File>
@@ -661,10 +653,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\AnimationListener.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\AnimationManager.cpp"
 				>
 			</File>
@@ -689,10 +677,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\CoreEvents.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\CoreSubsystem.cpp"
 				>
 			</File>

Deleted: rl/trunk/engine/core/include/AnimationListener.h
===================================================================
--- rl/trunk/engine/core/include/AnimationListener.h	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/include/AnimationListener.h	2007-07-27 17:15:42 UTC (rev 3630)
@@ -1,81 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __AnimationListener_H__
-#define __AnimationListener_H__
-
-#include "CorePrerequisites.h"
-
-#include "EventCaster.h"
-#include "EventSource.h"
-#include "EventObject.h"
-
-namespace rl {
-
-class BaseAnimation;
-
-class _RlCoreExport AnimationEvent : public virtual EventObject
-{
-	public:
-		static const unsigned int ANIMATION_PAUSED = 360;
-		static const unsigned int ANIMATION_UNPAUSED = 361;
-		static const unsigned int ANIMATION_FINISHED = 362;
-
-		AnimationEvent( BaseAnimation* anim,  const unsigned int reason );
-		virtual ~AnimationEvent() {};
-
-		BaseAnimation* getAnimation() const;
-};
-
-
-class _RlCoreExport AnimationListener : public virtual EventListener<AnimationEvent>
-{
-	public:
-		virtual ~AnimationListener();
-
-		virtual void animationFinished(AnimationEvent *anEvent) const = 0;
-		virtual void animationPaused(AnimationEvent *anEvent) const = 0;
- 		virtual void animationUnpaused(AnimationEvent *anEvent) const = 0;
-
-		virtual bool eventRaised(AnimationEvent *anEvent);
-};
-
-class _RlCoreExport AnimationFrameEvent : public virtual EventObject
-{
-public:
-	static const unsigned int ANIMATION_FRAMEREACHED = 363;
-
-	AnimationFrameEvent( BaseAnimation* anim,  const unsigned int reason, const Ogre::Real& frameNumber );
-	virtual ~AnimationFrameEvent() {};
-
-	BaseAnimation* getAnimation() const;
-	Ogre::Real getFrameNumber() const;
-	void setFrameNumber(const Ogre::Real& frameNumber);
-private:
-	Ogre::Real mFrameNumber;
-};
-
-class _RlCoreExport AnimationFrameListener
-{
-	public:
-		virtual ~AnimationFrameListener() {};
-		virtual void animationFrameReached( AnimationFrameEvent *anEvent ) const = 0;
-
-        virtual bool eventRaised(AnimationFrameEvent *anEvent);
-};
-
-}
-#endif

Modified: rl/trunk/engine/core/include/BaseAnimation.h
===================================================================
--- rl/trunk/engine/core/include/BaseAnimation.h	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/include/BaseAnimation.h	2007-07-27 17:15:42 UTC (rev 3630)
@@ -21,9 +21,7 @@
 
 #include <set>
 #include <map>
-#include "AnimationListener.h"
 
-
 namespace rl {
 
 /** 
@@ -32,7 +30,7 @@
 	@remarks Instanzen werden ?ber den AnimationManager erzeugt
 	@see AnimationManager
 */
-class _RlCoreExport BaseAnimation : public virtual EventSource
+class _RlCoreExport BaseAnimation
 {
     public:
 		/**
@@ -46,7 +44,7 @@
 		BaseAnimation();
 
 		/// Virtueller Destruktor
-		virtual ~BaseAnimation( );
+		virtual ~BaseAnimation();
         
 		/// Gibt zur?ck ob die Animation pausiert ist
         virtual bool isPaused() const;
@@ -54,7 +52,7 @@
 			@param	isPaused	Zuk?nftiger Status
 			@remarks	L?st einen AnimationPaused/Unpaused Event aus
 		*/
-        virtual void setPaused( bool isPaused );
+        virtual void setPaused(bool isPaused);
 
 		/// Gibt zur?ck ob die globale Beschleunigung ignoriert wird
 		virtual bool isIgnoringGlobalSpeed() const;
@@ -63,7 +61,7 @@
 			@remarks	M?glichkeit die globale SlowMotion zu umgehen
 						N?tzlich f?r Statusanzeigen, oder ?hnliche konstante Animationen
 		*/
-		virtual void setIgnoringGlobalSpeed( bool isIgnoringGlobalSpeed );
+		virtual void setIgnoringGlobalSpeed(bool isIgnoringGlobalSpeed);
 
 		/// Gibt die aktuelle Geschwindigkeit zur?ck
 		virtual Ogre::Real getSpeed() const;
@@ -73,7 +71,7 @@
 						(mLength in Sekunden), negative Werte spielen die 
 						Animation r?ckw?rts ab. Bei 0 herrscht Stillstand.
 		*/
-		virtual void setSpeed( Ogre::Real speed );
+		virtual void setSpeed(Ogre::Real speed);
 		/// Negiert die aktuelle Geschwindigkeit
 		virtual void reverseAnimation();
 
@@ -97,40 +95,16 @@
 
 		/** Setzt das Delay vor dem ersten Abspielen der Animation.
 		    @param delay Die Verz?gerung in Sekunden  */
-		virtual void setDelay( Ogre::Real delay );
+		virtual void setDelay(Ogre::Real delay);
 		/// Gibt die Verz?gerung vor dem Ersten Abspielen in Sekunden zur?ck.
 		virtual Ogre::Real getDelay() const;
 
 		/// Zeit hinzuf?gen - wird vom AnimationManager aufgerufen
-		void addTime( Ogre::Real timePassed );
+		void addTime(Ogre::Real timePassed);
 
         /// addTime f?r alle Unterklassen
-		virtual void doAddTime( Ogre::Real timePassed ) = 0;
+		virtual void doAddTime(Ogre::Real timePassed) = 0;
 
-		/** F?gt einen AnimationListener hinzu
-			@param listener Der hinzuzuf?gende Listener
-			@remarks Der Listener wird benachrichtigt, wenn
-					  * die Animation pausiert/fortgesetzt wird
-					  * die Animation ihr gesamten Wiederholungen vollendet hat
-		*/
-		virtual void addAnimationListener( AnimationListener *listener);
-		/// Entfernt einen AnimationListener
-		virtual void removeAnimationListener( AnimationListener *listener);
-
-		/** F?gt einen AnimationFrameListener hinzu
-			@param listener Der hinzuzuf?gende Listener
-			@param frameNumber Die zu ?berwachende Zeitindex
-			@remarks	Der Listener wird benachrichtigt, wenn der Zeitindex erreicht oder 
-						?bersprungen wird. Dabei wird, falls der Fortschritt gr??er als die
-						L?nge der Animation korrekt gepr?ft, so dass keine Events verloren 
-						gehen
-		*/
-		virtual void addAnimationFrameListener( AnimationFrameListener *listener, Ogre::Real frameNumber );
-		/// Entfernt einen AnimationListener an allen Zeitindizes
-		virtual void removeAnimationFrameListener( AnimationFrameListener *listener );
-		/// Entfernt einen AnimationListener an einem bestimmtem Zeitindex
-		virtual void removeAnimationFrameListener( AnimationFrameListener *listener, Ogre::Real frameNumber );
-        
         /// Starte die Animation
         virtual void start();
         /// Stoppe die Animation
@@ -155,23 +129,10 @@
 		/// Bisherige Abspielzeit
 		Ogre::Real mTimePlayed;
 
-		/// EventCaster
-		EventCaster<AnimationEvent> mAnimationCaster;
-
-        typedef std::multimap<Ogre::Real,AnimationFrameListener*> 
-            AnimationFrameListenerMap;
-		/// Die Multimap mit den FrameNummern und den dazugeh?rigen Listenern
-		AnimationFrameListenerMap mAnimationFrameListener;
-
         /// Looping setzen
 		virtual void setLoop( bool loop );
 		/// Looping zur?ckgeben
 		virtual bool isLoop() const;
-	private:
-		/// ?berwacht das erreichen der einzelnen Frames f?r die Listener
-		void checkAnimationFrameListeners( Ogre::Real timePassed );
-        /// Entfernt alle Listener
-        void removeAllListeners();
 };
 
 }

Deleted: rl/trunk/engine/core/include/CoreEvents.h
===================================================================
--- rl/trunk/engine/core/include/CoreEvents.h	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/include/CoreEvents.h	2007-07-27 17:15:42 UTC (rev 3630)
@@ -1,72 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __CoreEvent_H__
-#define __CoreEvent_H__
-
-#include "Actor.h"
-#include "EventObject.h"
-#include "EventListener.h"
-
-#include "CorePrerequisites.h"
-
-namespace rl {
-
-class _RlCoreExport CoreEvent : public EventObject 
-{
-public:
-    /// Daten wurden geladen
-    static const unsigned int DATA_LOADED = 200;
-
-    /** Der Standardkonstruktor
-      * @param src Die Eventquelle
-      * @param reason Der Grund des Events
-      */
-    CoreEvent( const unsigned int reason );
-    /// Standarddestruktor
-    virtual ~CoreEvent() {};
-};
-
-class _RlCoreExport DataLoadedEvent : public CoreEvent 
-{
-public:
-    /** Der Standardkonstruktor
-      * @param src Die Eventquelle
-      * @param reason Der Grund des Events
-      */
-    DataLoadedEvent(float percent);
-    /// Standarddestruktor
-    virtual ~DataLoadedEvent() {};
-
-	float getPercentLoaded();
-
-private:
-	float mPercentLoaded;
-};
-
-class _RlCoreExport CoreEventListener : public EventListener<CoreEvent>
-{
-public:
-	CoreEventListener();
-
-	bool eventRaised(CoreEvent* anEvent);
-
-	virtual bool dataLoadedEventRaised(DataLoadedEvent* anEvent) = 0;
-};
-
-}
-
-#endif

Modified: rl/trunk/engine/core/include/CoreMessages.h
===================================================================
--- rl/trunk/engine/core/include/CoreMessages.h	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/include/CoreMessages.h	2007-07-27 17:15:42 UTC (rev 3630)
@@ -22,10 +22,25 @@
 
 namespace rl
 {
+    class BaseAnimation;
+
     enum CoreMessageTypeIds
     {
-        RLMSG_SCENE_LOADED = 0x01000001,
-        RLMSG_SCENE_CLEARING = 0x01000002
+        // World //
+        // Mask
+        RLMSG_SCENE_EVENTS = 0x01000100,
+        // Events
+        RLMSG_SCENE_LOADED = 0x01000101,
+        RLMSG_SCENE_CLEARING = 0x01000102,
+
+        // Animations //
+        // Mask
+        RLMSG_ANIMATION_EVENTS = 0x01000200,
+        // Events
+        RLMSG_ANIMATION_PAUSED = 0x01000201,
+        RLMSG_ANIMATION_UNPAUSED = 0x01000202,
+        RLMSG_ANIMATION_FINISHED = 0x01000203,
+        RLMSG_ANIMATION_FRAMEREACHED = 0x01000204,
     };
 
     /// Message sent right after a scene has been loaded.
@@ -33,5 +48,19 @@
 
     /// Message sent just before a scene will be cleared.
     typedef MessageType<RLMSG_SCENE_CLEARING> MessageType_SceneClearing;
+
+    /// Message sent when an animation has been paused.
+    typedef MessageType<RLMSG_ANIMATION_PAUSED, BaseAnimation*> MessageType_AnimationPaused;
+
+    /// Message sent when an animation has been unpaused.
+    typedef MessageType<RLMSG_ANIMATION_UNPAUSED, BaseAnimation*> MessageType_AnimationUnpaused;
+
+    /// Message sent when an animation is finished.
+    typedef MessageType<RLMSG_ANIMATION_FINISHED, BaseAnimation*> MessageType_AnimationFinished;
+
+    /// Message sent when an animation has been paused.
+    /// Real param is the frame time reached
+    typedef MessageType<RLMSG_ANIMATION_FRAMEREACHED, BaseAnimation*, Ogre::Real>
+        MessageType_AnimationFrameReached;
 }
 #endif

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2007-07-27 17:15:42 UTC (rev 3630)
@@ -56,7 +56,7 @@
         It follows the Singleton Pattern,
         and initialises the game context.
 */
-class _RlCoreExport CoreSubsystem : public Ogre::Singleton<CoreSubsystem>, public virtual EventSource
+class _RlCoreExport CoreSubsystem : public Ogre::Singleton<CoreSubsystem>
 {
 public:
     /** Default Constructor */
@@ -96,9 +96,6 @@
     */
     void makeScreenshot(const Ogre::String& sName);
 
-    void addCoreEventListener(CoreEventListener* listener);
-    void removeCoreEventListener(CoreEventListener* listener);
-
     void setScheme(const Ogre::String& schemeName);
 
     bool isInitialized() const;
@@ -130,7 +127,6 @@
 
     bool mDeveloperMode;
     bool mInitialized;
-    EventCaster<CoreEvent> mCoreEventCaster;
     std::vector<Ogre::Technique*> mDefaultTechniques;
 
     // The singletons of this subsystem

Deleted: rl/trunk/engine/core/src/AnimationListener.cpp
===================================================================
--- rl/trunk/engine/core/src/AnimationListener.cpp	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/src/AnimationListener.cpp	2007-07-27 17:15:42 UTC (rev 3630)
@@ -1,91 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "AnimationListener.h"
-
-#include "BaseAnimation.h"
-#include "Exception.h"
-
-namespace rl {
-
-AnimationEvent::AnimationEvent( BaseAnimation* anim, const unsigned int reason ) :
-	EventObject(anim,reason)
-{}
-
-BaseAnimation* AnimationEvent::getAnimation() const
-{
-	EventSource* eve =  this->getSource();
-	return dynamic_cast<BaseAnimation*>( eve );
-}
-
-AnimationListener::~AnimationListener()
-{
-
-}
-
-bool AnimationListener::eventRaised( AnimationEvent* anEvent )
-{
-    switch( anEvent->getReason() )
-    {
-    case AnimationEvent::ANIMATION_FINISHED:
-        this->animationFinished( anEvent );
-        break;
-    case AnimationEvent::ANIMATION_UNPAUSED:
-        this->animationUnpaused( anEvent );
-        break;
-    case AnimationEvent::ANIMATION_PAUSED:
-        this->animationPaused( anEvent );
-        break;
-    }
-
-	// consumed or not ;)
-	return false;
-}
-
- bool AnimationFrameListener::eventRaised(AnimationFrameEvent *anEvent)
-{
-    this->animationFrameReached( anEvent );
-
-    // consumed or not ;)
-    return false;
-}
-
-
-AnimationFrameEvent::AnimationFrameEvent( BaseAnimation* anim,  const unsigned int reason, const Ogre::Real& frameNumber ) :
-EventObject(anim,reason)
-{
-	mFrameNumber = frameNumber;
-}
-
-BaseAnimation* AnimationFrameEvent::getAnimation() const
-{
-	EventSource* eve =  this->getSource();
-	return dynamic_cast<BaseAnimation*>( eve );
-}
-
-Ogre::Real AnimationFrameEvent::getFrameNumber() const
-{
-	return mFrameNumber;
-}
-
-void AnimationFrameEvent::setFrameNumber(const Ogre::Real& frameNumber)
-{
-	mFrameNumber = frameNumber;
-}
-
-
-}

Modified: rl/trunk/engine/core/src/BaseAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/BaseAnimation.cpp	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/src/BaseAnimation.cpp	2007-07-27 17:15:42 UTC (rev 3630)
@@ -15,13 +15,15 @@
  */
 #include "stdinc.h"
 
-#include "Exception.h"
-#include "AnimationManager.h"
+#include "BaseAnimation.h"
+
 #include "ActorManager.h"
+#include "AnimationManager.h"
+#include "CoreMessages.h"
+#include "Exception.h"
+#include "MessagePump.h"
 #include "ScriptWrapper.h"
 
-#include "BaseAnimation.h"
-
 using namespace Ogre;
 
 
@@ -29,23 +31,19 @@
 
 BaseAnimation::BaseAnimation( Ogre::Real length, Ogre::Real speed, 
     unsigned int timesToPlay, bool paused ) :
-    EventSource(),
     mLength(length),
-	mAnimationFrameListener(),
-	mAnimationCaster(),
     mPaused(paused),
-    mTimesToPlay( timesToPlay ),
-    mSpeed( speed ),
-    mDelay( 0.0f ),
+    mTimesToPlay(timesToPlay),
+    mSpeed(speed),
+    mDelay(0.0f),
     mIgnoringGlobalSpeed(false),
-    mTimePlayed( 0.0f )
+    mTimePlayed(0.0f)
 {
     setLoop( mTimesToPlay == 0 ); 
 }
 
 BaseAnimation::~BaseAnimation()
 {
-    removeAllListeners();
 }
 
 Ogre::Real BaseAnimation::getLength() const
@@ -62,15 +60,11 @@
 {
 	if( mPaused && !isPaused )
 	{
-		AnimationEvent* animEve = new AnimationEvent(this,AnimationEvent::ANIMATION_UNPAUSED);
-		mAnimationCaster.dispatchEvent( animEve );
-		delete animEve;
+        MessagePump::getSingleton().sendMessage<MessageType_AnimationUnpaused>(this);
 	}
 	else if( !mPaused && isPaused )
 	{
-		AnimationEvent* animEve = new AnimationEvent(this,AnimationEvent::ANIMATION_PAUSED);
-		mAnimationCaster.dispatchEvent( animEve );
-		delete animEve;
+        MessagePump::getSingleton().sendMessage<MessageType_AnimationPaused>(this);
 	}
 
     mPaused = isPaused;
@@ -159,100 +153,6 @@
     return mTimesToPlay!=1;
 }
 
-void BaseAnimation::addAnimationListener(AnimationListener *listener)
-{
-    if( !mAnimationCaster.containsListener(listener) )
-    {    
-	    mAnimationCaster.addEventListener(listener);
-        ScriptWrapper::getSingleton().owned( listener );
-    }
-}
-
-void BaseAnimation::removeAnimationListener(AnimationListener *listener)
-{
-    if( mAnimationCaster.containsListener( listener ) ) 
-    {
-	    mAnimationCaster.removeEventListener(listener);
-        ScriptWrapper::getSingleton().disowned( listener );
-    }
-}
-
-// @todo - Existenz berprfen
-void BaseAnimation::addAnimationFrameListener( 
-	AnimationFrameListener *listener, Ogre::Real frameNumber)
-{
-	mAnimationFrameListener.insert( 
-		std::pair<Ogre::Real,AnimationFrameListener*>(frameNumber,listener) );
-    ScriptWrapper::getSingleton().owned( listener );
-}
-
-// @todo - Existenz berprfen
-void BaseAnimation::removeAnimationFrameListener( AnimationFrameListener *listener )
-{
-    AnimationFrameListenerMap::iterator iter = mAnimationFrameListener.begin();
-
-    for (iter; iter != mAnimationFrameListener.end(); ) 
-    {
-        AnimationFrameListener* afl = iter->second;
-        
-        if( afl == listener )
-        {
-            mAnimationFrameListener.erase( iter++ );  
-            ScriptWrapper::getSingleton().disowned( listener );
-        } else {
-            ++iter;
-        }
-    }
-}
-
-void BaseAnimation::removeAnimationFrameListener( 
-	AnimationFrameListener *listener, Ogre::Real frameNumber)
-{
-    AnimationFrameListenerMap::iterator iter = mAnimationFrameListener.begin();
-
-    for (iter; iter != mAnimationFrameListener.end(); ) 
-    {
-        Real time = iter->first;
-        AnimationFrameListener* afl = iter->second;
-
-        if( afl == listener && time == frameNumber )
-        {
-            mAnimationFrameListener.erase( iter++ );  
-            ScriptWrapper::getSingleton().disowned( listener );
-        } else {
-            ++iter;
-        }
-    }
-}
-
-void BaseAnimation::removeAllListeners()
-{
-    // Alle AnimationFrameListener
-    AnimationFrameListenerMap::iterator iter = mAnimationFrameListener.begin();
-
-    for (iter; iter != mAnimationFrameListener.end(); ) 
-    {
-        AnimationFrameListener* afl = iter->second; 
-        ScriptWrapper::getSingleton().disowned( afl );
-        iter++;
-    }
-    mAnimationFrameListener.clear();
-    
-    // Alle AnimationListener
-    EventCaster<AnimationEvent>::EventSet evSet 
-        = mAnimationCaster.getEventSet();
-    EventCaster<AnimationEvent>::EventSet::iterator citer 
-        = evSet.begin();
-    for (citer; citer != evSet.end(); ) 
-    {
-        EventListener<AnimationEvent>* ev = *citer; 
-        AnimationListener* al = dynamic_cast<AnimationListener*>( ev );
-        ScriptWrapper::getSingleton().disowned( al );
-        citer++;
-    }
-    mAnimationCaster.removeEventListeners();
-}
-
 // Zeit hinzufgen // wird vom AnimationManager aufgerufen
 void BaseAnimation::addTime( Ogre::Real timePassed )
 {
@@ -271,10 +171,14 @@
 			}
 		}
 
-		timePassed = timePassed * mSpeed;
+		timePassed *= mSpeed;
 
-		if( !mAnimationFrameListener.empty() && timePassed != 0 )
-			checkAnimationFrameListeners( timePassed );
+		if (fabs(timePassed) - 0.0001 > 0)
+        {
+            Real elapsedTime = (mTimePlayed / mLength) * mLength;
+            MessagePump::getSingleton().sendMessage<MessageType_AnimationFrameReached>(
+                this, elapsedTime);
+        }
         
         doAddTime(timePassed);
 
@@ -292,140 +196,12 @@
 				setLoop(false);
 				mPaused = true;
 			
-				AnimationEvent* animEve = new AnimationEvent(this,AnimationEvent::ANIMATION_FINISHED);
-				mAnimationCaster.dispatchEvent( animEve );
-				delete animEve;	
+                MessagePump::getSingleton().sendMessage<MessageType_AnimationFinished>(this);
 			}
 		}
 	}
 }
 
-/**
-	Benachrichtigt die AnimationFrameListener
-
-	Erfolgt in drei Schritten 
-	 * Aktueller Durchlauf
-	 * Wenn ???erlauf, dann wird die Anzahl weiterer Durchl???fe bestimmt
-	 * Fr den Rest im letzten Durchlauf wird erneut geprft
-*/
-void BaseAnimation::checkAnimationFrameListeners( Ogre::Real timePassed )
-{
-	if( mAnimationFrameListener.empty() ) 
-		return;
-
-	// Iteratoren
-	std::multimap<Ogre::Real,AnimationFrameListener*>::iterator 
-		lowerBorder;
-	std::multimap<Ogre::Real,AnimationFrameListener*>::iterator 
-		upperBorder;
-	std::multimap<Ogre::Real,AnimationFrameListener*>::iterator 
-		iter;
-	float lower, upper;
-	// Event erzeugen
-	AnimationFrameEvent* animEve = new AnimationFrameEvent(this,
-		AnimationFrameEvent::ANIMATION_FRAMEREACHED,0);
-
-	// Eventuelles Vorzeichen weg
-	timePassed = fabs( timePassed );
-
-    Ogre::Real elapsedTime = (mTimePlayed/mLength)*mLength;
-
-	// Vorw???ts laufen
-	if( mSpeed > 0 )		
-	{
-        lower = std::max(elapsedTime, 0.0f);
-		upper = std::min(elapsedTime, mLength );
-	}
-	// Das ganze rckw???ts
-	else
-	{
-		// FIXME fr die erste Runde beim Rckw???tsspielen, beginnt leider bei 0, nicht Length
-		Ogre::Real timePos = elapsedTime;
-		if( timePos == 0.0f )
-			timePos = mLength;
-
-		lower = std::max(timePos-timePassed, 0.0f);
-		upper = std::min(timePos, mLength );
-	}
-
-	// Iteratoren fr die Grenzen holen
-	lowerBorder = mAnimationFrameListener.lower_bound(
-		lower);
-	upperBorder = mAnimationFrameListener.upper_bound(
-		upper);
-
-	// Alle Listener innerhalb der Grenzen benachrichtigen
-	for (iter = lowerBorder; iter != upperBorder; iter++) 
-	{
-		animEve->setFrameNumber( iter->first );
-		iter->second->eventRaised(animEve);
-	}
-
-	// Einmal abspielen abziehen
-	timePassed -= mLength;
-	// Ums Wrapping kmmern - wenn Looping - und AbspielZeit
-	if( timePassed > 0 && isLoop() && 
-		// Falls begrenzte Wiederholungen, mssen mindestens 2(1+die oben abgearbeitete) fehlen
-		( ( mTimesToPlay > 0 && getTimesToPlayLeft() > 1 ) || ( mTimesToPlay == 0 ) )
-	   )
-	{
-		// Wie oft passt die L???ge in die gesamte fortgeschrittene Zeit		
-		unsigned int timesSkipped = floor( timePassed/mLength );
-		Ogre::Real timeLeft = timePassed - timesSkipped*mLength;
-
-		// Falls die Abspielanzahlbegrenzt ist, nicht h???figer als verbliebene Anzahl abspielen
-		if( mTimesToPlay > 0 && timesSkipped >= getTimesToPlayLeft()-1)
-		{
-			timesSkipped = getTimesToPlayLeft()-1;
-			// Restzeit unwichtig, letzen Abspielvorg???ge waren komplette
-			timeLeft = 0;
-		}
-
-		lowerBorder = mAnimationFrameListener.begin();
-		upperBorder = mAnimationFrameListener.end();
-
-		// Geskippte Events
-		for( unsigned int i = 0; i < timesSkipped; i++)
-		{
-			for (iter = lowerBorder; iter != upperBorder; iter++) 
-			{
-				animEve->setFrameNumber( iter->first );
-				iter->second->eventRaised(animEve);
-			}
-		}		
-
-		// Fr letzten Event prfen, wenn noch Restzeit vorhanden ist
-		if( timeLeft > 0 )
-		{
-			// Wrapping nach oben
-			if( mSpeed > 0 )
-			{
-				lowerBorder = mAnimationFrameListener.lower_bound(
-					0);
-				upperBorder = mAnimationFrameListener.upper_bound(
-					timeLeft);
-			}
-			// Wrapping nach unten
-			else if( mSpeed < 0 )
-			{
-				lowerBorder = mAnimationFrameListener.lower_bound(
-					mLength - timeLeft );
-				upperBorder = mAnimationFrameListener.upper_bound(
-					mLength );
-			}
-
-			// Ein letztes Mal durchlaufen ^^
-			for (iter = lowerBorder; iter != upperBorder; iter++) 
-			{
-				animEve->setFrameNumber( iter->first );
-				iter->second->eventRaised(animEve);
-			}
-		}
-	}
-
-	delete animEve;
-}
-
 void BaseAnimation::start()
 {
     setPaused(false);

Deleted: rl/trunk/engine/core/src/CoreEvents.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreEvents.cpp	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/src/CoreEvents.cpp	2007-07-27 17:15:42 UTC (rev 3630)
@@ -1,58 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#ifndef __GameAreaEvent_H__
-#define __GameAreaEvent_H__
-
-#include "CoreEvents.h"
-#include "CoreSubsystem.h"
-
-namespace rl {
-
-	CoreEvent::CoreEvent(const unsigned int reason)
-		: EventObject(CoreSubsystem::getSingletonPtr(), reason)
-	{
-	}
-
-	DataLoadedEvent::DataLoadedEvent(float percent)
-		: CoreEvent(CoreEvent::DATA_LOADED),
-		mPercentLoaded(percent)
-	{
-
-	}
-
-	float DataLoadedEvent::getPercentLoaded()
-	{
-		return mPercentLoaded;
-	}
-
-	CoreEventListener::CoreEventListener()
-		: EventListener<CoreEvent>()
-	{
-	}
-
-	bool CoreEventListener::eventRaised(rl::CoreEvent *anEvent)
-	{
-		if (anEvent->getReason() == CoreEvent::DATA_LOADED)
-			return dataLoadedEventRaised(dynamic_cast<DataLoadedEvent*>(anEvent));
-
-		return false;
-	}
-
-}
-
-#endif

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-27 17:15:42 UTC (rev 3630)
@@ -30,7 +30,6 @@
 #include "AnimationManager.h"
 #include "ContentModule.h"
 #include "ConfigurationManager.h"
-#include "CoreEvents.h"
 #include "DotSceneOctreeWorld.h"
 #include "Exception.h"
 #include "GameEventManager.h"
@@ -63,7 +62,6 @@
         mClockStartTime(),
         mDeveloperMode(false),
         mInitialized(false),
-        mCoreEventCaster(),
         mDefaultTechniques(),
         mOgreRoot(NULL),
         mScriptWrapper(NULL),
@@ -85,8 +83,6 @@
 
     CoreSubsystem::~CoreSubsystem()
     {
-        mCoreEventCaster.removeEventListeners();
-
 		delete meshmagick::OgreEnvironment::getSingletonPtr();
         delete mZoneManager;
         delete mGameEventManager;
@@ -575,14 +571,4 @@
         mSoundManager->unloadAllDrivers();
         LOG_MESSAGE(Logger::CORE, "Soundtreiber entladen");
     }
-
-    void CoreSubsystem::addCoreEventListener(rl::CoreEventListener *listener)
-    {
-        mCoreEventCaster.addEventListener(listener);
-    }
-
-    void CoreSubsystem::removeCoreEventListener(CoreEventListener* listener)
-    {
-        mCoreEventCaster.removeEventListener(listener);
-    }
 }

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-07-27 17:15:42 UTC (rev 3630)
@@ -40,7 +40,6 @@
 #include "GameAreaEvent.h"
 #include "GameAreaTypes.h"
 #include "AnimationManager.h"
-#include "AnimationListener.h"
 #include "BaseAnimation.h"
 #include "MeshAnimation.h"
 #include "FadeAnimation.h"

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-07-26 20:44:29 UTC (rev 3629)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-07-27 17:15:42 UTC (rev 3630)
@@ -243,44 +243,6 @@
 /// Alles was mit Animationen zu tun hat
 %apply SWIGTYPE *DYNAMIC { BaseAnimation * };
 
-%feature("director") AnimationListener; 
-class AnimationListener
-{
-public:
-	virtual ~AnimationListener();
-
-	virtual void animationFinished(rl::AnimationEvent *anEvent) const = 0;
-	virtual void animationPaused(rl::AnimationEvent *anEvent) const = 0;
-	virtual void animationUnpaused(rl::AnimationEvent *anEvent) const = 0;
-};
-
-%feature("director") AnimationFrameListener; 
-class AnimationFrameListener
-{
-public:
-	virtual ~AnimationFrameListener();
-
-	virtual void animationFrameReached( rl::AnimationFrameEvent *anEvent ) const = 0;
-};
-
-class AnimationEvent
-{
-public:
-	rl::BaseAnimation* getAnimation() const;
-private:
-	AnimationEvent( rl::BaseAnimation* anim,  const unsigned int reason );
-};
-
-class AnimationFrameEvent
-{
-public:
-	rl::BaseAnimation* getAnimation() const;
-	Ogre::Real getFrameNumber() const;
-private:
-	AnimationFrameEvent( rl::BaseAnimation* anim,  const unsigned int reason, Ogre::Real frameNumber );
-};
-
-
 class BaseAnimation {
 public:
 	bool isPaused() const;
@@ -303,13 +265,6 @@
 	Ogre::Real getDelay(void) const;
     void setDelay(Ogre::Real delay);
     
-    void addAnimationListener( rl::AnimationListener *listener);
-	void removeAnimationListener( rl::AnimationListener *listener);
-	
-	void addAnimationFrameListener( rl::AnimationFrameListener *listener, 
-									float frameNumber );
-	void removeAnimationFrameListener( rl::AnimationFrameListener *listener );
-	void removeAnimationFrameListener( rl::AnimationFrameListener *listener, Ogre::Real frameNumber );
 private:
 	BaseAnimation(  );
 };



From melven at mail.berlios.de  Sat Jul 28 14:42:26 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 28 Jul 2007 14:42:26 +0200
Subject: [Dsa-hl-svn] r3631 - modules/techdemo2/scripts/maps
Message-ID: <200707281242.l6SCgQad003585@sheep.berlios.de>

Author: melven
Date: 2007-07-28 14:42:05 +0200 (Sat, 28 Jul 2007)
New Revision: 3631

Modified:
   modules/techdemo2/scripts/maps/techdemo2map1.rb
   modules/techdemo2/scripts/maps/techdemo2map2.rb
Log:
Doesn't add the player to the ai any more, because this prevents the creaturecontroller to work correctly. This will enable the current engine to run td2.

Modified: modules/techdemo2/scripts/maps/techdemo2map1.rb
===================================================================
--- modules/techdemo2/scripts/maps/techdemo2map1.rb	2007-07-27 17:15:42 UTC (rev 3630)
+++ modules/techdemo2/scripts/maps/techdemo2map1.rb	2007-07-28 12:42:05 UTC (rev 3631)
@@ -16,8 +16,8 @@
 $UI.setActiveCharacter($hero)
 $SCRIPT.log("Held erstellt");
 
-$heroVehicle = $AI.createAgent(AgentManager::AGENT_PLAYER, $hero);	
-$SCRIPT.log("SteeringVehicle f?r Held erstellen...");
+#$heroVehicle = $AI.createAgent(AgentManager::AGENT_PLAYER, $hero);	
+#$SCRIPT.log("SteeringVehicle f?r Held erstellen...");
 
 
 $World = $CORE.getWorld();

Modified: modules/techdemo2/scripts/maps/techdemo2map2.rb
===================================================================
--- modules/techdemo2/scripts/maps/techdemo2map2.rb	2007-07-27 17:15:42 UTC (rev 3630)
+++ modules/techdemo2/scripts/maps/techdemo2map2.rb	2007-07-28 12:42:05 UTC (rev 3631)
@@ -13,8 +13,8 @@
 $UI.setActiveCharacter($hero)
 $SCRIPT.log("Held erstellt");
 
-$heroVehicle = $AI.createAgent(AgentManager::AGENT_PLAYER, $hero);	
-$SCRIPT.log("SteeringVehicle f?r Held erstellen...");
+#$heroVehicle = $AI.createAgent(AgentManager::AGENT_PLAYER, $hero);	
+#$SCRIPT.log("SteeringVehicle f?r Held erstellen...");
 
 
 $SCRIPT.log("init map 'Techdemo2'...");



From melven at mail.berlios.de  Sat Jul 28 21:29:35 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 28 Jul 2007 21:29:35 +0200
Subject: [Dsa-hl-svn] r3632 - in rl/trunk/engine/core: include src
Message-ID: <200707281929.l6SJTZdV010902@sheep.berlios.de>

Author: melven
Date: 2007-07-28 21:29:27 +0200 (Sat, 28 Jul 2007)
New Revision: 3632

Modified:
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/src/GameLoop.cpp
Log:
Now a fixed number of frames can be smoothed (and not all frames in a period of time). You can also disable smoothing.
This prevents accelerations and slowdowns of the movement (the whole game) when the framerate changes.

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2007-07-28 12:42:05 UTC (rev 3631)
+++ rl/trunk/engine/core/include/GameLoop.h	2007-07-28 19:29:27 UTC (rev 3632)
@@ -114,12 +114,12 @@
     unsigned long mGameTime;
 
     std::deque<unsigned long> mLastTimes;
-    /// In milliseconds, because Ogre's timer works this way.
-    unsigned long mSmoothPeriod;
+    /// In milliseconds, because Ogre's timer works this way. Number of smoothed Frames, should not be 0!
+    unsigned long mSmoothedFrames;
     /// Time cap for frame time, to prevent interpolation problems during spikes.
     Ogre::Real mMaxFrameTime;
-	bool mQuitRequested;
-	bool mPaused;
+    bool mQuitRequested;
+    bool mPaused;
 
     /// Averages frame rate over mSmoothPeriod milliseconds.
     /// Steadies Controls and Physics a bit.

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-07-28 12:42:05 UTC (rev 3631)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-07-28 19:29:27 UTC (rev 3632)
@@ -41,10 +41,10 @@
           mTimer(NULL),
           mGameTime(0),
           mLastTimes(),
-          mSmoothPeriod(500),
-          mMaxFrameTime(0.250f),
+          mSmoothedFrames(3),
+          mMaxFrameTime(0.1f),
           mQuitRequested(false),
-		  mPaused(false)
+          mPaused(false)
     {
         // create five task lists, one for each taskgroup
         mTaskLists.push_back(new GameTaskList());
@@ -109,25 +109,35 @@
         }
     }
 
-	bool GameLoop::isPaused() const
-	{
-		return mPaused;
-	}
+    bool GameLoop::isPaused() const
+    {
+        return mPaused;
+    }
 
-	void GameLoop::setPaused(bool paused)
-	{
-		mPaused = paused;
-	}
+    void GameLoop::setPaused(bool paused)
+    {
+        mPaused = paused;
+    }
 
     void GameLoop::_executeOneRenderLoop()
     {
         // Calculate frame time. This time is smoothed and capped.
         unsigned long elapsedTime = mTimer->getMilliseconds();
-        Real frameTime = 0.001f * (Real) smoothFrameTime(elapsedTime - mGameTime);
+
+        unsigned long unsmoothedFrameTime = elapsedTime - mGameTime;
+
+        if( elapsedTime < mGameTime )
+            unsmoothedFrameTime = 1;
+
+        if( unsmoothedFrameTime > mMaxFrameTime*1000 )
+        {
+            LOG_MESSAGE(Logger::CORE, "Die aktuelle Frame wurde auf den festgelegten Maximalwert gek?rzt");
+            unsmoothedFrameTime = mMaxFrameTime*1000;
+        }
+        Real frameTime = 0.001f * (Real) smoothFrameTime(unsmoothedFrameTime);
         mGameTime = elapsedTime;
-        if (frameTime > mMaxFrameTime) frameTime = mMaxFrameTime;
 
-		// Let Ogre handle Windows/XServer events.
+        // Let Ogre handle Windows/XServer events.
         WindowEventUtilities::messagePump();
 
         // Render the next frame
@@ -141,7 +151,7 @@
             {
                 if (it->valid && !(it->task->isPaused()) && !isPaused())
                 {
-					it->task->run(frameTime);
+                    it->task->run(frameTime);
                 }
             }
         }
@@ -177,27 +187,22 @@
     }
 
     // Idea taken from Ogre, but implementation by us.
-    // smooths time step over the period mSmoothPeriod.
+    // fixed number of smoothed frames
     unsigned long GameLoop::smoothFrameTime(unsigned long time)
     {
+        // remove the last frame, if enough frame-times are saved
+        if( mLastTimes.size() >= std::max(mSmoothedFrames,(unsigned long)1) )
+            mLastTimes.pop_front();
         // First add time for this frame
         mLastTimes.push_back(time);
 
-        // Starting from the end of the queue, determine the element, that
-        // is just over the threshold mSmoothPeriod.
-        unsigned long limit = 0;
-        std::deque<unsigned long>::reverse_iterator i = mLastTimes.rbegin();
-        while (i != mLastTimes.rend() && limit < mSmoothPeriod)
-        {
-            limit += *i;
-            ++i;
-        }
-        // Erase all times, that are over.
-        mLastTimes.erase(mLastTimes.begin(), mLastTimes.begin() + (mLastTimes.rend() - i));
-
         // Return the mean of the remaining times.
-        return std::accumulate(mLastTimes.begin(), mLastTimes.end(), 0)
-            / std::max(mLastTimes.size(), (size_t)1);
+        // Do not return zero
+        if( mLastTimes.size() == 0 )
+            return time;
+        else
+            return std::accumulate(mLastTimes.begin(), mLastTimes.end(), 0)
+                / std::max(mLastTimes.size(), (size_t)1);
     }
 
     unsigned long GameLoop::getClock() const



From melven at mail.berlios.de  Sat Jul 28 21:31:00 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 28 Jul 2007 21:31:00 +0200
Subject: [Dsa-hl-svn] r3633 - rl/trunk/engine/ui/src
Message-ID: <200707281931.l6SJV0Js011000@sheep.berlios.de>

Author: melven
Date: 2007-07-28 21:30:53 +0200 (Sat, 28 Jul 2007)
New Revision: 3633

Modified:
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Changed information of the debug page

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-28 19:29:27 UTC (rev 3632)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-28 19:30:53 UTC (rev 3633)
@@ -546,19 +546,16 @@
         Vector3 bodpos, playpos = node->getPosition();
         Quaternion egal;
         mCamBody->getPositionOrientation(bodpos,egal);
-        static Real maxHeight(0);
-        if( playpos.y > maxHeight )
-            maxHeight = playpos.y;
         ss
             << "scene node : " << playpos << std::endl
-            << "player max Height : " << maxHeight << std::endl
+            << "player velocity : " << -mMovingCreature->getVelocity().z << std::endl
+            << "player orientation : " << mMovingCreature->getCreature()->getActor()->getOrientation() << std::endl
             << "camera posder : " << static_cast<Camera*>(
                 mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-                << "camera pos : " << static_cast<Camera*>(
-                    mCameraActor->_getMovableObject())->getPosition() << std::endl
-            << "camera actor orientation : " << mCameraActor->getWorldOrientation() << std::endl
-            << "camera actor : " << mCameraActor->getWorldPosition() << std::endl
-            << "camera body pos : " << bodpos << std::endl
+//                << "camera pos : " << static_cast<Camera*>(
+//                    mCameraActor->_getMovableObject())->getPosition() << std::endl
+            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
+            << "camera pos : " << bodpos << std::endl
             << "camera distance : " << mDesiredDistance << std::endl
             << "is airborne: " << (mMovingCreature->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
 



From melven at mail.berlios.de  Sat Jul 28 21:31:50 2007
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 28 Jul 2007 21:31:50 +0200
Subject: [Dsa-hl-svn] r3634 - rl/trunk/engine/rules/src
Message-ID: <200707281931.l6SJVolG011028@sheep.berlios.de>

Author: melven
Date: 2007-07-28 21:31:43 +0200 (Sat, 28 Jul 2007)
New Revision: 3634

Modified:
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
Movement speed of Laufen and Joggen increased.

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-28 19:30:53 UTC (rev 3633)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-28 19:31:43 UTC (rev 3634)
@@ -307,7 +307,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 2.8f;
+            velocity = mMovingCreature->getCurrentGS() / 2.0f;
             return isPossible();
         }
         virtual bool isPossible() const
@@ -363,7 +363,7 @@
         virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
         virtual bool calculateBaseVelocity(Real &velocity)
         {
-            velocity = mMovingCreature->getCurrentGS() / 2.0f;
+            velocity = mMovingCreature->getCurrentGS() / 1.6f; // was 2.0
             return isPossible();
         }
         virtual bool isPossible() const
@@ -431,7 +431,7 @@
             Date now = DsaManager::getSingleton().getCurrentDate();
             if( mLastProbe + Date::ONE_SPIELRUNDE >= now || mLastProbe == 0 )
             {
-                mTimePerAu = 180;
+                mTimePerAu = 120; // was 180
                 try
                 {
                     mLastProbe = now;
@@ -451,7 +451,7 @@
                 }
                 catch(OutOfRangeException)
                 {
-                    mTimePerAu = 180;
+                    mTimePerAu = 120; // was 180
                 }
             }
         }



From alassion at mail.berlios.de  Mon Jul 30 10:36:33 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:36:33 +0200
Subject: [Dsa-hl-svn] r3635 - content/textures
Message-ID: <200707300836.l6U8aXdP000530@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:36:22 +0200 (Mon, 30 Jul 2007)
New Revision: 3635

Added:
   content/textures/balken_01_normalmap.dds
Log:
Added a file remotely

Added: content/textures/balken_01_normalmap.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/balken_01_normalmap.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:37:20 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:37:20 +0200
Subject: [Dsa-hl-svn] r3636 - content/textures
Message-ID: <200707300837.l6U8bKON000642@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:37:08 +0200 (Mon, 30 Jul 2007)
New Revision: 3636

Added:
   content/textures/boden_01_normalmap.dds
Log:
Added a file remotely

Added: content/textures/boden_01_normalmap.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_01_normalmap.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:37:49 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:37:49 +0200
Subject: [Dsa-hl-svn] r3637 - content/textures
Message-ID: <200707300837.l6U8bn7n000707@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:37:41 +0200 (Mon, 30 Jul 2007)
New Revision: 3637

Added:
   content/textures/fachwerk_01_normalmap.dds
Log:
Added a file remotely

Added: content/textures/fachwerk_01_normalmap.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/fachwerk_01_normalmap.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:38:25 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:38:25 +0200
Subject: [Dsa-hl-svn] r3638 - content/textures
Message-ID: <200707300838.l6U8cPnT000747@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:38:07 +0200 (Mon, 30 Jul 2007)
New Revision: 3638

Added:
   content/textures/felsen_03_normalmap.dds
Log:
Added a file remotely

Added: content/textures/felsen_03_normalmap.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_03_normalmap.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:38:51 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:38:51 +0200
Subject: [Dsa-hl-svn] r3639 - content/textures
Message-ID: <200707300838.l6U8cpOW000792@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:38:40 +0200 (Mon, 30 Jul 2007)
New Revision: 3639

Added:
   content/textures/gras_01_normalmap.dds
Log:
Added a file remotely

Added: content/textures/gras_01_normalmap.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/gras_01_normalmap.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:39:49 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:39:49 +0200
Subject: [Dsa-hl-svn] r3640 - content/textures
Message-ID: <200707300839.l6U8dn7V000849@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:39:43 +0200 (Mon, 30 Jul 2007)
New Revision: 3640

Added:
   content/textures/baumstamm_02_normalmap.dds
Log:
Added a file remotely

Added: content/textures/baumstamm_02_normalmap.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/baumstamm_02_normalmap.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:41:06 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:41:06 +0200
Subject: [Dsa-hl-svn] r3641 - content/textures
Message-ID: <200707300841.l6U8f6Do000963@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:40:39 +0200 (Mon, 30 Jul 2007)
New Revision: 3641

Added:
   content/textures/kiesbett.png
Log:
Added a file remotely

Added: content/textures/kiesbett.png
===================================================================
(Binary files differ)


Property changes on: content/textures/kiesbett.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:41:35 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:41:35 +0200
Subject: [Dsa-hl-svn] r3642 - content/textures
Message-ID: <200707300841.l6U8fZ0t001001@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:41:27 +0200 (Mon, 30 Jul 2007)
New Revision: 3642

Added:
   content/textures/kiesbett.dds
Log:
Added a file remotely

Added: content/textures/kiesbett.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/kiesbett.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Mon Jul 30 10:42:00 2007
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Mon, 30 Jul 2007 10:42:00 +0200
Subject: [Dsa-hl-svn] r3643 - content/textures
Message-ID: <200707300842.l6U8g0Jt001082@sheep.berlios.de>

Author: alassion
Date: 2007-07-30 10:41:50 +0200 (Mon, 30 Jul 2007)
New Revision: 3643

Added:
   content/textures/kiesbett_normalmap.dds
Log:
Added a file remotely

Added: content/textures/kiesbett_normalmap.dds
===================================================================
(Binary files differ)


Property changes on: content/textures/kiesbett_normalmap.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From pnyx at mail.berlios.de  Mon Jul 30 11:52:10 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Mon, 30 Jul 2007 11:52:10 +0200
Subject: [Dsa-hl-svn] r3644 - in modules/ruchin: maps materials/textures
	models
Message-ID: <200707300952.l6U9qA2g005800@sheep.berlios.de>

Author: pnyx
Date: 2007-07-30 11:48:51 +0200 (Mon, 30 Jul 2007)
New Revision: 3644

Added:
   modules/ruchin/models/Ruchin_i.mesh
Modified:
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/materials/textures/karte_fliped.jpg
   modules/ruchin/models/Ruchin_j.mesh
   modules/ruchin/models/Ruchin_r.mesh
   modules/ruchin/models/Ruchin_u.mesh
Log:
added part i

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-07-30 08:41:50 UTC (rev 3643)
+++ modules/ruchin/maps/ruchin.scene	2007-07-30 09:48:51 UTC (rev 3644)
@@ -343,5 +343,19 @@
 			/>
 
 		</node>
+		
+		<node name="Ruchin_i" id="3" >
+			<position x="-5.0" y="0.0" z="-100.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Ruchin_i"
+				id="4"
+				meshFile ="Ruchin_i.mesh"
+				materialFile="ruchin_terrain.material"
+				castsShadow="false"
+			/>
+
+		</node>
 	</nodes>
 </scene>
\ No newline at end of file

Modified: modules/ruchin/materials/textures/karte_fliped.jpg
===================================================================
(Binary files differ)

Added: modules/ruchin/models/Ruchin_i.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/Ruchin_i.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/models/Ruchin_j.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_r.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_u.mesh
===================================================================
(Binary files differ)



From blakharaz at mail.berlios.de  Mon Jul 30 22:47:09 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 30 Jul 2007 22:47:09 +0200
Subject: [Dsa-hl-svn] r3645 - modules/common/scripts/jobs
	modules/regressiontest/scripts rl/trunk/engine/script/include
	rl/trunk/engine/script/src rl/trunk/engine/script/swig
Message-ID: <200707302047.l6UKl9i1015420@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-30 22:46:57 +0200 (Mon, 30 Jul 2007)
New Revision: 3645

Added:
   modules/common/scripts/jobs/closurejobs.rb
Modified:
   modules/regressiontest/scripts/JobSequenceTest.rb
   rl/trunk/engine/script/include/ScriptSubsystem.h
   rl/trunk/engine/script/src/ScriptSubsystem.cpp
   rl/trunk/engine/script/swig/RlScript.swig
Log:
* Method for logging errors in scripts
* Added job which executes a closure block


Added: modules/common/scripts/jobs/closurejobs.rb
===================================================================
--- modules/common/scripts/jobs/closurejobs.rb	2007-07-30 09:48:51 UTC (rev 3644)
+++ modules/common/scripts/jobs/closurejobs.rb	2007-07-30 20:46:57 UTC (rev 3645)
@@ -0,0 +1,27 @@
+require 'globals.rb'
+
+class ClosureJob < Job
+  def initialize()
+    super(true, true)
+  end
+
+  def setCode(&code)
+    @code = code
+  end
+  
+  def execute(time)
+	begin
+		@code.call
+	rescue StandardError => se
+		$SCRIPT.logError(se.to_s)
+	ensure
+		return true
+	end
+  end
+end
+
+def _Execute(&code)
+    job = ClosureJob.new()
+    job.setCode(&code) 
+    return job
+end

Modified: modules/regressiontest/scripts/JobSequenceTest.rb
===================================================================
--- modules/regressiontest/scripts/JobSequenceTest.rb	2007-07-30 09:48:51 UTC (rev 3644)
+++ modules/regressiontest/scripts/JobSequenceTest.rb	2007-07-30 20:46:57 UTC (rev 3645)
@@ -1,6 +1,7 @@
 require 'jobs/jobsequence.rb'
 require 'jobs/soundjobs.rb'
 require 'jobs/animationjobs.rb'
+require 'jobs/closurejobs.rb'
 
 class JobSequenceTestAction < Action
   def initialize
@@ -20,20 +21,46 @@
                 _PlaySound3d("lachen.ogg", go.getPosition()),
                 2,
                 _PlayAnimation(go.getActor(), "zu"),
-                _PlaySound3d("doorcreak.ogg", go.getPosition())
+                _PlaySound3d("doorcreak.ogg", go.getPosition()),
+				2,
+				_Execute {provokeEror},
+				2,
+				_Execute {p "FOO"}
             ]
     );
   end
 end
 
+#class JobQueueTestAction < Action
+#  def initialize
+#    super("checktime", "Zeit ansagen lassen.");
+#  end
+  
+#  def canDo(go, user)
+#    true
+#  end
+  
+#  def doAction(go, user, target)
+#    jobQueue(
+#            [
+#                jobSequence([_PlayAnimation(go.getActor(), "auf"), _PlaySound3d("doorcreak.ogg", go.getPosition())],
+#				_PlaySound3d("lachen.ogg", go.getPosition()),
+#                jobSequence([_PlayAnimation(go.getActor(), "zu"), _PlaySound3d("doorcreak.ogg", go.getPosition())],
+#				2,
+#				_ExecuteJob {$UI.requestExit}
+#            ]
+#    );
+#  end
+#end
+
 class JobSequenceTest < TestCase
     def execute()
         # Define a base box to place everything else on.
         height = 0.3
         min_base = [-2.0, 0.05, -2.0]
         max_base = [2.0, height, 2.0]
-        base = $AM.createBoxPrimitiveActor("JobSequenceTestBase",
-                                           min_base, max_base, "alpha_green")
+        base = $AM.createBoxPrimitiveActor(
+             "JobSequenceTestBase", min_base, max_base, "alpha_green")
         base.placeIntoScene(getCenter());
 
         chest = $GOM.createGameObject(

Modified: rl/trunk/engine/script/include/ScriptSubsystem.h
===================================================================
--- rl/trunk/engine/script/include/ScriptSubsystem.h	2007-07-30 09:48:51 UTC (rev 3644)
+++ rl/trunk/engine/script/include/ScriptSubsystem.h	2007-07-30 20:46:57 UTC (rev 3645)
@@ -32,6 +32,7 @@
         virtual ~ScriptSubsystem();
 
         void log(const CeGuiString& message);
+        void logError(const CeGuiString& message);
 		void setTriggerFactory(TriggerFactory* factory);
 		TriggerFactory* getTriggerFactory() const;
 

Modified: rl/trunk/engine/script/src/ScriptSubsystem.cpp
===================================================================
--- rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-07-30 09:48:51 UTC (rev 3644)
+++ rl/trunk/engine/script/src/ScriptSubsystem.cpp	2007-07-30 20:46:57 UTC (rev 3645)
@@ -41,6 +41,11 @@
         LOG_MESSAGE(Logger::SCRIPT, message);
     }
 
+    void ScriptSubsystem::logError(const rl::CeGuiString &message)
+    {
+        LOG_ERROR(Logger::SCRIPT, message);
+    }
+
 	TriggerFactory* ScriptSubsystem::getTriggerFactory() const
 	{
 		return mTriggerFactory;

Modified: rl/trunk/engine/script/swig/RlScript.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.swig	2007-07-30 09:48:51 UTC (rev 3644)
+++ rl/trunk/engine/script/swig/RlScript.swig	2007-07-30 20:46:57 UTC (rev 3645)
@@ -22,6 +22,7 @@
 		static rl::ScriptSubsystem& getSingleton();
 
 		void log(const rl::CeGuiString& message);
+        void logError(const rl::CeGuiString& message);
 		void setTriggerFactory(rl::TriggerFactory* factory);
 	};
 	  



From blakharaz at mail.berlios.de  Mon Jul 30 22:55:50 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 30 Jul 2007 22:55:50 +0200
Subject: [Dsa-hl-svn] r3646 - in rl/trunk/engine: common/include common/src
	core core/include core/src rules rules/include rules/src script/swig
Message-ID: <200707302055.l6UKtofD015943@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-30 22:55:01 +0200 (Mon, 30 Jul 2007)
New Revision: 3646

Added:
   rl/trunk/engine/core/include/JobQueue.h
   rl/trunk/engine/core/include/TimeSource.h
   rl/trunk/engine/core/src/JobQueue.cpp
   rl/trunk/engine/core/src/TimeSource.cpp
   rl/trunk/engine/rules/include/GameTimeSource.h
   rl/trunk/engine/rules/src/GameTimeSource.cpp
Removed:
   rl/trunk/engine/rules/include/TimerEvent.h
   rl/trunk/engine/rules/include/TimerEventSource.h
   rl/trunk/engine/rules/include/TimerListener.h
   rl/trunk/engine/rules/include/TimerManager.h
   rl/trunk/engine/rules/src/TimerEvent.cpp
   rl/trunk/engine/rules/src/TimerEventSource.cpp
   rl/trunk/engine/rules/src/TimerListener.cpp
   rl/trunk/engine/rules/src/TimerManager.cpp
Modified:
   rl/trunk/engine/common/include/GameTask.h
   rl/trunk/engine/common/src/GameTask.cpp
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/include/Job.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/core/src/Job.cpp
   rl/trunk/engine/core/src/JobScheduler.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/DsaManager.h
   rl/trunk/engine/rules/include/RulesSubsystem.h
   rl/trunk/engine/rules/src/DsaManager.cpp
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
* introduced 3 different time sources (continuous realtime, interruptable realtime, game time) replacing the global game clock
* removed timer classes

Modified: rl/trunk/engine/common/include/GameTask.h
===================================================================
--- rl/trunk/engine/common/include/GameTask.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/common/include/GameTask.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -26,30 +26,35 @@
 class _RlCommonExport GameTask
 {
     public:
-		/// Default Konstruktor, startet unpausiert
-        GameTask();
+		/// Konstruktor, startet unpausiert
+        /// @param interruptable set to <code>false</code> if GameTask can't be paused
+        GameTask(bool interruptable = true);
+
 		/// Virtueller Basis-Destruktor
-        virtual ~GameTask( ) {};
+        virtual ~GameTask() {};
 
 		/** Wird vom Gameloop aufgerufen, wenn nicht pausiert, 
-            wird von  Unterklassen implementiert
+            wird von Unterklassen implementiert
 
 			@param elapsedTime Die vergangene Zeit
 		*/
-		virtual void run( Ogre::Real elapsedTime ) = 0;
+		virtual void run(Ogre::Real elapsedTime) = 0;
 
-		/** Returns the name of the derived class for debugging purposes.
-		 */
+		/// Returns the name of the derived class for debugging purposes.
         virtual const Ogre::String& getName() const = 0;
+
+        bool isInterruptable() const;
         
 		/// Gibt zur?ck ob dieser GameTask pausiert ist
         bool isPaused() const;
+
 		/// Pausiert/Unpausiert den GameTask
-        void setPaused( bool isPaused );
+        void setPaused(bool isPaused);
 
     private:
 		/// Pause
         bool mPaused;
+        bool mInterruptable;
 };
 
 }

Modified: rl/trunk/engine/common/src/GameTask.cpp
===================================================================
--- rl/trunk/engine/common/src/GameTask.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/common/src/GameTask.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -18,11 +18,12 @@
 
 #include "GameTask.h"
 
-namespace rl {
+namespace rl 
+{
 
-GameTask::GameTask()
+GameTask::GameTask(bool pauseable)
+: mInterruptable(false), mPaused(false)
 {
-    mPaused = false;
 }
         
 bool GameTask::isPaused() const
@@ -32,7 +33,15 @@
 
 void GameTask::setPaused( bool isPaused )
 {
-    mPaused = isPaused;
+    if (mInterruptable)
+    {
+        mPaused = isPaused;
+    }
 }
 
+bool GameTask::isInterruptable() const
+{
+    return mInterruptable;
 }
+
+}

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-07-30 20:55:01 UTC (rev 3646)
@@ -456,6 +456,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\JobQueue.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\JobScheduler.h"
 				>
 			</File>
@@ -600,6 +604,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\TimeSource.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\TrackAnimation.h"
 				>
 			</File>
@@ -729,6 +737,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\JobQueue.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\JobScheduler.cpp"
 				>
 			</File>
@@ -877,6 +889,10 @@
 				</FileConfiguration>
 			</File>
 			<File
+				RelativePath=".\src\TimeSource.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\TrackAnimation.cpp"
 				>
 			</File>

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -48,6 +48,7 @@
 class DebugVisualsManager;
 class JobScheduler;
 class ZoneManager;
+class TimeSourceManager;
 
 typedef _RlCoreExport std::map<Ogre::String, ContentModule*> ModuleMap;
 
@@ -87,10 +88,6 @@
     void setDeveloperMode(bool developerMode);
     bool getDeveloperMode() const;
 
-    /// Returns time since game started in Milliseconds.
-    /// Uses GameLoop::getClock internally, function is here to allow access from ruby.
-    unsigned long getClock();
-
     /** Saves a timestamped png Screenshot
         @param sName The filename (extended with the timestamp)
     */
@@ -143,6 +140,7 @@
     DebugVisualsManager* mDebugVisualsManager;
     JobScheduler* mJobScheduler;
 	ZoneManager* mZoneManager;
+    TimeSourceManager* mTimeSourceManager;
 
     /** Runs the setup methods  */
     bool initializeCoreSubsystem();

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/include/GameLoop.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -67,9 +67,6 @@
 	/// @param paused <code>true</code> if the game should be paused, <code>false</code> if it should be continued
 	void setPaused(bool paused);
 
-    /// Returns time since game started in Milliseconds.
-    unsigned long getClock() const;
-
     /// Main loop of RL.
     void loop();
 
@@ -131,4 +128,3 @@
 
 }
 #endif
-

Modified: rl/trunk/engine/core/include/Job.h
===================================================================
--- rl/trunk/engine/core/include/Job.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/include/Job.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -19,6 +19,8 @@
 
 #include "CorePrerequisites.h"
 
+#include "TimeSource.h"
+
 namespace rl
 {
     /** A Job is an independent executional entity, that encapsules a singe specific task
@@ -44,7 +46,8 @@
          *         Job, after execution is finished. This should usually be the case, but
          *         sometimes it is sensible to pool a number of Jobs for reuse.
          */
-        Job(bool isDiscardable, bool destroyWhenDone);
+        Job(bool isDiscardable, bool destroyWhenDone, 
+            TimeSource::TimeSourceType type = TimeSource::REALTIME_CONTINUOUS);
         virtual ~Job();
 
         /**
@@ -67,9 +70,12 @@
         /// Returns true, if the Job shall be deleted, if the Job is finished. Returns false else.
         virtual bool destroyWhenDone();
 
+        TimeSource::TimeSourceType getTimeSource() const;
+
     protected:
         bool mIsDiscardable;
         bool mDestroyWhenDone;
+        TimeSource::TimeSourceType mTimeSource;
     };
 }
 

Added: rl/trunk/engine/core/include/JobQueue.h
===================================================================
--- rl/trunk/engine/core/include/JobQueue.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/include/JobQueue.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -0,0 +1,39 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#ifndef __JOBQUEUE_H__
+#define __JOBQUEUE_H__
+
+#include "Job.h"
+
+namespace rl
+{
+
+    class JobQueue : public Job
+    {
+    public:
+        JobQueue();
+        ~JobQueue();
+
+        void addJob(Job* job);
+        virtual bool execute(Ogre::Real elapsedTime);
+
+    private:
+        std::list<Job*> mQueue;
+    };
+
+}
+
+#endif // __JOBQUEUE_H__

Added: rl/trunk/engine/core/include/TimeSource.h
===================================================================
--- rl/trunk/engine/core/include/TimeSource.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/include/TimeSource.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -0,0 +1,98 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __TimeSource_H__
+#define __TimeSource_H__
+
+#include "CorePrerequisites.h"
+
+#include <OgreSingleton.h>
+
+#include "GameTask.h"
+
+namespace rl
+{
+    class _RlCoreExport TimeSource : public GameTask
+    {
+    public:
+        static enum TimeSourceType
+        {
+            REALTIME_CONTINUOUS,
+            REALTIME_INTERRUPTABLE,
+            GAMETIME
+        };
+
+        TimeSource(bool interruptable);
+        virtual ~TimeSource();
+
+        virtual TimeSourceType getType() const = 0;
+
+        virtual Time getClock() const = 0;
+        virtual void setClock(const Time& time) = 0;
+        virtual void setTimeFactor(Ogre::Real factor = 1.0) = 0;
+    };
+
+    class _RlCoreExport RealTimeContinuous : public TimeSource
+    {
+    public:
+        RealTimeContinuous();
+
+        virtual TimeSourceType getType() const;
+        virtual const Ogre::String& getName() const;
+
+        virtual Time getClock() const;
+        virtual void setClock(const Time& time);
+        virtual void setTimeFactor(Ogre::Real factor = 1.0);
+
+        virtual void run(Ogre::Real elapsedTime);
+    private:
+        Ogre::Real mTime;
+    };
+
+    class _RlCoreExport RealTimeInterruptable : public TimeSource
+    {
+    public:
+        RealTimeInterruptable();
+        virtual ~RealTimeInterruptable();
+
+        virtual TimeSourceType getType() const;
+        virtual const Ogre::String& getName() const;
+
+        virtual Time getClock() const;
+        virtual void setClock(const Time& time);
+        virtual void setTimeFactor(Ogre::Real factor = 1.0);
+
+        virtual void run(Ogre::Real elapsedTime);
+    private:
+        Ogre::Real mTime;
+        Ogre::Real mTimeFactor;
+    };
+
+    class _RlCoreExport TimeSourceManager 
+        : public Ogre::Singleton<TimeSourceManager>
+    {
+    public:
+        TimeSourceManager();
+
+        void registerTimeSource(TimeSource* ts);
+        TimeSource* getTimeSource(const TimeSource::TimeSourceType& type) const;
+
+    private:
+        std::map<TimeSource::TimeSourceType, TimeSource*> mTimeSources;
+    };
+}
+
+#endif // __TimeSource_H__

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -30,19 +30,20 @@
 #include "AnimationManager.h"
 #include "ContentModule.h"
 #include "ConfigurationManager.h"
+#include "DebugVisualsManager.h"
 #include "DotSceneOctreeWorld.h"
 #include "Exception.h"
 #include "GameEventManager.h"
-#include "MessagePump.h"
 #include "GameLoop.h"
-#include "ZoneManager.h"
+#include "JobScheduler.h"
 #include "Logger.h"
+#include "MessagePump.h"
 #include "PhysicsManager.h"
 #include "RubyInterpreter.h"
 #include "ScriptWrapper.h"
 #include "SoundManager.h"
-#include "DebugVisualsManager.h"
-#include "JobScheduler.h"
+#include "TimeSource.h"
+#include "ZoneManager.h"
 
 #include <ctime>
 
@@ -100,6 +101,7 @@
         delete mSoundManager;
         delete mOgreRoot;
         delete mRubyInterpreter;
+        delete mTimeSourceManager;
     }
 
     void CoreSubsystem::startCore()
@@ -234,6 +236,11 @@
         mGameLoop = new GameLoop();
         LOG_MESSAGE(Logger::CORE,"GameLoopmanager erzeugt");
 
+        mTimeSourceManager = new TimeSourceManager();
+        mTimeSourceManager->registerTimeSource(new RealTimeContinuous());
+        mTimeSourceManager->registerTimeSource(new RealTimeInterruptable());
+        LOG_MESSAGE(Logger::CORE,"Time sources (realtime) created");
+
         mScriptWrapper = new ScriptWrapper();
         LOG_MESSAGE(Logger::CORE,"Skriptwrapper erzeugt");
         // TODO: muss l?schbar werden.
@@ -496,11 +503,6 @@
         return mWorld;
     }
 
-    unsigned long CoreSubsystem::getClock()
-    {
-        return mGameLoop->getClock();
-    }
-
     Ogre::String CoreSubsystem::getEngineVersionString() const
     {
         static Ogre::String version = "0.3.0";

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -204,9 +204,4 @@
             return std::accumulate(mLastTimes.begin(), mLastTimes.end(), 0)
                 / std::max(mLastTimes.size(), (size_t)1);
     }
-
-    unsigned long GameLoop::getClock() const
-    {
-        return mGameTime;
-    }
 }

Modified: rl/trunk/engine/core/src/Job.cpp
===================================================================
--- rl/trunk/engine/core/src/Job.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/src/Job.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -20,10 +20,11 @@
 
 namespace rl
 {
-    Job::Job(bool isDiscardable, bool destroyWhenDone)
-        : mIsDiscardable(isDiscardable), mDestroyWhenDone(destroyWhenDone)
+    Job::Job(bool isDiscardable, bool destroyWhenDone, TimeSource::TimeSourceType timesource)
+        : mIsDiscardable(isDiscardable), 
+        mDestroyWhenDone(destroyWhenDone),
+        mTimeSource(timesource)
     {
-
     }
 
     Job::~Job()
@@ -44,4 +45,9 @@
     {
         RlFail("Discarded non discardable Job.");
     }
+
+    TimeSource::TimeSourceType Job::getTimeSource() const
+    {
+        return mTimeSource;
+    }
 }

Added: rl/trunk/engine/core/src/JobQueue.cpp
===================================================================
--- rl/trunk/engine/core/src/JobQueue.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/src/JobQueue.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -0,0 +1,37 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h"
+
+#include "JobQueue.h"
+
+namespace rl
+{
+
+JobQueue::JobQueue()
+: Job(true, true)
+{
+}
+
+JobQueue::~JobQueue()
+{
+}
+
+bool JobQueue::execute(Ogre::Real elapsedTime)
+{
+    return true; ///@todo
+}
+
+}

Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -19,6 +19,7 @@
 #include "Job.h"
 #include "JobListener.h"
 #include "GameLoop.h"
+#include "TimeSource.h"
 
 using namespace Ogre;
 
@@ -39,7 +40,9 @@
         JobListener* listener)
     {
         unsigned long ticket = ++mTicketCounter;
-        unsigned long clock = GameLoop::getSingleton().getClock();
+        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
+            job->getTimeSource());
+        unsigned long clock = ts->getClock();
         unsigned long start = clock + delay*1000;
         unsigned long end = maxRuntime >= Math::POS_INFINITY ?
             0xffffffff : static_cast<unsigned long>(start + maxRuntime*1000);
@@ -55,7 +58,6 @@
 
         ///@todo dynamically determine token threshold. Maybe make it work load depending.
 
-        unsigned long clock = GameLoop::getSingleton().getClock();
 
         // Queue for finished jobs
         JobQueue notDone;
@@ -64,6 +66,10 @@
         {
             JobEntry entry = *it;
 
+            TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
+                entry.job->getTimeSource());
+            Time clock = ts->getClock();
+
             if (entry.start <= clock && clock < entry.end)
             {
                 // Is the token threshold reached?

Added: rl/trunk/engine/core/src/TimeSource.cpp
===================================================================
--- rl/trunk/engine/core/src/TimeSource.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/core/src/TimeSource.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -0,0 +1,144 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h" //precompiled header
+
+#include "TimeSource.h"
+
+#include "GameLoop.h"
+
+template<> rl::TimeSourceManager* Ogre::Singleton<rl::TimeSourceManager>::ms_Singleton = 0;
+
+namespace rl
+{
+
+    TimeSource::TimeSource(bool interruptable)
+        : GameTask(interruptable)
+    {
+        GameLoop::getSingleton().addTask(this, GameLoop::TG_LOGIC);
+    }
+
+    TimeSource::~TimeSource()
+    {
+        GameLoop::getSingleton().removeTask(this);
+    }
+
+    RealTimeContinuous::RealTimeContinuous()
+        : TimeSource(false),
+        mTime(0.0)
+    {
+    }
+
+    TimeSource::TimeSourceType RealTimeContinuous::getType() const
+    {
+        return TimeSource::REALTIME_CONTINUOUS;
+    }
+
+    Time RealTimeContinuous::getClock() const
+    {
+        return mTime;
+    }
+
+    void RealTimeContinuous::setClock(const Time& time)
+    {
+        mTime = time;
+    }
+
+    void RealTimeContinuous::setTimeFactor(Ogre::Real factor)
+    {
+        // can't be accelerated or slowed down
+    }
+
+    void RealTimeContinuous::run(Ogre::Real elapsedTime)
+    {
+        mTime += elapsedTime * 1000;
+    }
+
+    const Ogre::String& RealTimeContinuous::getName() const
+    {
+        static Ogre::String NAME = "Continuous real time clock";
+        return NAME;
+    }
+
+    RealTimeInterruptable::RealTimeInterruptable()
+        : TimeSource(true),
+        mTimeFactor(1.0),
+        mTime(0.0)
+    {
+    }
+
+    RealTimeInterruptable::~RealTimeInterruptable()
+    {
+    }
+
+    TimeSource::TimeSourceType RealTimeInterruptable::getType() const
+    {
+        return TimeSource::REALTIME_INTERRUPTABLE;
+    }
+
+    Time RealTimeInterruptable::getClock() const
+    {
+        return mTime;
+    }
+
+    void RealTimeInterruptable::setClock(const Time& time)
+    {
+        mTime = time;
+    }
+
+    void RealTimeInterruptable::setTimeFactor(Ogre::Real factor)
+    {
+        mTimeFactor = factor;
+    }
+
+    void RealTimeInterruptable::run(Ogre::Real elapsedTime)
+    {
+        if (!isPaused())
+        {
+            mTime += mTimeFactor * elapsedTime * 1000;
+        }
+    }
+
+    const Ogre::String& RealTimeInterruptable::getName() const
+    {
+        static Ogre::String NAME = "Pausable real time clock";
+        return NAME;
+    }
+
+    TimeSourceManager::TimeSourceManager()
+    {
+    }
+
+    void TimeSourceManager::registerTimeSource(TimeSource* ts)
+    {
+        mTimeSources[ts->getType()] = ts;
+    }
+
+    TimeSource* TimeSourceManager::getTimeSource(
+        const TimeSource::TimeSourceType& type) const
+    {
+        std::map<TimeSource::TimeSourceType, TimeSource*>::const_iterator it
+            = mTimeSources.find(type);
+
+        if (it == mTimeSources.end())
+        {
+            return NULL;
+        }
+
+        return it->second;
+    }
+
+}

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-30 20:55:01 UTC (rev 3646)
@@ -351,6 +351,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\GameTimeSource.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\Inventory.cpp"
 				>
 			</File>
@@ -455,22 +459,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\TimerEvent.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\TimerEventSource.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\TimerListener.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\TimerManager.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\ZauberStateSet.cpp"
 				>
 			</File>
@@ -577,6 +565,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\GameTimeSource.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Inventory.h"
 				>
 			</File>
@@ -669,22 +661,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\TimerEvent.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\TimerEventSource.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\TimerListener.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\TimerManager.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\ZauberStateSet.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/include/DsaManager.h
===================================================================
--- rl/trunk/engine/rules/include/DsaManager.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/include/DsaManager.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -64,9 +64,6 @@
 		void setTimestamp(const RL_LONGLONG time);
 		void setCurrentDate(const Date& date);
 
-        Ogre::Real getTimeScale() const;
-        void setTimeScale(Ogre::Real scale);
-
         /** liefert eine Zufallszahl zwischen 1 und 20.*/
         int rollD20() const;
 

Added: rl/trunk/engine/rules/include/GameTimeSource.h
===================================================================
--- rl/trunk/engine/rules/include/GameTimeSource.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/include/GameTimeSource.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -0,0 +1,42 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __GameTimeSource_H__
+#define __GameTimeSource_H__
+
+#include "TimeSource.h"
+
+#include "Date.h"
+
+namespace rl
+{
+
+    class GameTimeSource : public RealTimeInterruptable
+    {
+    public:
+        GameTimeSource();
+        ~GameTimeSource();
+
+        Date getDate() const;
+        void setDate(const Date& date);
+
+        virtual TimeSourceType getType() const;
+        virtual const Ogre::String& getName() const;
+    };
+
+}
+
+#endif // __GameTimeSource_H__

Modified: rl/trunk/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/trunk/engine/rules/include/RulesSubsystem.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/include/RulesSubsystem.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -28,7 +28,6 @@
     class CombatManager;
     class DsaManager;
     class CreatureControllerManager;
-    class TimerManager;
     class XdimlLoader;
 
 	class _RlRulesExport RulesSubsystem : public Ogre::Singleton<RulesSubsystem>
@@ -46,7 +45,6 @@
         CombatManager* mCombatManager;
         DsaManager* mDsaManager;
         CreatureControllerManager *mMovingCreatureManager;
-        TimerManager* mTimerManager;
         XdimlLoader* mXdimlLoader;
     };
 }

Deleted: rl/trunk/engine/rules/include/TimerEvent.h
===================================================================
--- rl/trunk/engine/rules/include/TimerEvent.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/include/TimerEvent.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,65 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __TimerEvent_H__
-#define __TimerEvent_H__
-
-#include "RulesPrerequisites.h"
-
-#include "EventObject.h"
-
-#include "Date.h"
-
-namespace rl {
-
-class TimerEventSource;
-class GameObject;
-
-/** 
- *  TimerEvent
- *  Ein Event der ausgel?st wird, wenn sich eine Eigenschaft eines GameObjects ver?ndert hat 
- *
- *  @see ObjectStateChangeListener, TimerEventSource
- *  @todo Feldgenauigkeit, also auch noch im Ereignis zu kodieren, was ver?ndert wurde
- */
-class _RlRulesExport TimerEvent : public virtual EventObject 
-{
-public:
-	/** Der Standardkonstruktor
-	* @param src Die Eventquelle
-	*/
-	TimerEvent( TimerEventSource* src );
-	/// Standarddestruktor
-	virtual ~TimerEvent() {};
-
-	/// Setzt den Zeitpunkt des Events
-	void setTime(Ogre::Real time) { mTime = time; }
-	void setTime(Date gameTime) { mGameTime = gameTime; }
-
-	/// Gibt den Zeitpunkt des Events zur?ck
-	Ogre::Real getTime() { return mTime; }
-	Date getGameTime() { return mGameTime; }
-
-	/// Gibt die Eventquelle zur?ck
-	TimerEventSource* getSource() const;
-private:
-	/// Das verursachende Object
-	Ogre::Real mTime;
-	Date mGameTime;
-};
-}
-
-#endif

Deleted: rl/trunk/engine/rules/include/TimerEventSource.h
===================================================================
--- rl/trunk/engine/rules/include/TimerEventSource.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/include/TimerEventSource.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,97 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __TimerEventSource_H__
-#define __TimerEventSource_H__
-
-#include "RulesPrerequisites.h"
-
-#include "EventSource.h"
-#include "EventCaster.h"
-#include "Date.h"
-
-namespace rl {
-
-class TimerListener;
-class TimerEvent;
-
-/** 
- * TimerEventSource
- *
- *  @see TimerEvent, TimerListener
- */
-class _RlRulesExport TimerEventSource : public virtual EventSource
-{
-public:
-	static const RL_LONGLONG NO_REPEAT;
-
-    /** Konstruktor
-     */
-	TimerEventSource( const RL_LONGLONG gameTime, const RL_LONGLONG interval = NO_REPEAT );
-	TimerEventSource( const Date dsaTime, const Date interval = NO_REPEAT );
-
-	/// Dekonstruktor
-    virtual ~TimerEventSource();
-
-    /** F?gt einen TimerListener hinzu, der zuk?nftig bei TimerEvents benachrichtigt wird 
-     *
-     * @param list Der hinzuzuf?gende Listener
-     */
-    void addTimerListener( TimerListener*  list );
-    /** Entfernt einen TimerListener
-    *
-    * @param list Der zu entfernende Listener
-    */
-    void removeTimerListener( TimerListener* list );
-
-	/**
-	 * Regt eine Timer?berpr?fung an
-	 *
-	 * @param gameTime die abgelaufene Spielzeit
-	 * @param dsaTime die aktuelle DSA-Zeit
-	 * @return true, falls das Ereignis nie wieder auftreten kann und somit gel?scht werden soll
-	 */
-	bool injectTimePulse(RL_LONGLONG gameTime, Date dsaTime);
-
-    /// Gibt zur?ck ob sich Listener angemeldet haben
-    bool hasListeners( ) const;
-
-    void fireTimerEvent();
-
-private: 
-
-	enum TimerType {
-		TIMER_GAME_TIME,
-		TIMER_DSA_TIME
-	};
-
-    /// Der EventCaster der die Verteilung an die Listener ?bernimmt
-    EventCaster<TimerEvent> mTimerEventCaster;
-    /// Das Object der ?berwacht wird
-	RL_LONGLONG mGameTime;
-	RL_LONGLONG mGameTimeLastCall;
-	RL_LONGLONG mGameTimeRepeatInterval;
-
-	Date mDsaTime;
-    Date mDsaTimeLastCall;
-	Date mDsaTimeRepeatInterval;
-
-	TimerType mType;
-};
-
-}
-
-#endif

Deleted: rl/trunk/engine/rules/include/TimerListener.h
===================================================================
--- rl/trunk/engine/rules/include/TimerListener.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/include/TimerListener.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,48 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __TimerListener_H__
-#define __TimerListener_H__
-
-#include "EventListener.h"
-#include "TimerEvent.h"
-
-#include "RulesPrerequisites.h"
-
-namespace rl {
-
-/** TimerListener
- *  Eine Basisklasse f?r Listener die auf TimerEvents lauschen
- *
- *  @see TimerEvent, TimerEventSource, GameObject
- */
-class _RlRulesExport TimerListener : public virtual EventListener<TimerEvent>
-{
-public:
-    /// Dekonstruktor
-    virtual ~TimerListener();
-
-     /// K?mmert sich um das Aufrufen benannter Methoden aus Reasons
-	bool eventRaised(TimerEvent *anEvent);
-
-    /** Diese Methode wird aufgerufen, wenn der Timer ausgel?st wurde
-      * @param anEvent Der ausl?sende Event
-      */  
-	virtual void timerFired(TimerEvent* anEvent) = 0;
-};
-}
-
-#endif

Deleted: rl/trunk/engine/rules/include/TimerManager.h
===================================================================
--- rl/trunk/engine/rules/include/TimerManager.h	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/include/TimerManager.h	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,55 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __TimerManager_H__
-#define __TimerManager_H__
-
-#include "RulesPrerequisites.h"
-#include "GameTask.h"
-
-#include <OgreSingleton.h>
-
-namespace rl {
-
-class TimerEventSource;
-
-/** 
- *  TimerEvent
- *  Ein Event der ausgel?st wird, wenn ein Zeitpunkt erreicht wurde
- *
- *  @see TimerListener, TimerEventSource
- */
-class _RlRulesExport TimerManager : public GameTask, public Ogre::Singleton<TimerManager>
-{
-public:
-	TimerManager();
-	virtual ~TimerManager();
-
-	void registerTimerEventSource(TimerEventSource* source);
-	void unregisterTimerEventSource(TimerEventSource* source);
-
-    virtual const Ogre::String& getName() const;
-
-protected:
-	virtual void run( Ogre::Real elapsedTime );
-
-private:
-	std::set<TimerEventSource*> mTimers;
-};
-
-}
-
-#endif //__TimerManager_H__

Modified: rl/trunk/engine/rules/src/DsaManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaManager.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/src/DsaManager.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -26,7 +26,7 @@
 #include "DsaDataLoader.h"
 
 #include "Exception.h"
-#include "GameLoop.h"
+#include "GameTimeSource.h"
 
 #include <cstdlib>
 
@@ -130,43 +130,50 @@
 		return false;
 	}
 
-    RL_LONGLONG DsaManager::getTimestamp() const
-    {
-        unsigned long currentClock = GameLoop::getSingleton().getClock();
-        mLastGameTime += (RL_LONGLONG) (mTimeScale * (currentClock - mLastClock));
-        mLastClock = currentClock;
-		return mLastGameTime;
-    }
+    Time DsaManager::getTimestamp() const
+	{
+        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
+                TimeSource::GAMETIME);
 
+        if (ts)
+        {
+            return ts->getClock();
+        }
+        else
+        {
+            return 0; ///@todo better throw exception?
+        }
+	}
+
 	Date DsaManager::getCurrentDate() const
 	{
-		return Date(getTimestamp());
-	}
+        GameTimeSource* ts = dynamic_cast<GameTimeSource*>(
+            TimeSourceManager::getSingleton().getTimeSource(
+                TimeSource::GAMETIME));
 
-	void DsaManager::setTimestamp(const RL_LONGLONG time)
-	{
-		mLastGameTime = time;
-        mLastClock = GameLoop::getSingleton().getClock();
+        if (ts)
+        {
+            return ts->getDate();
+        }
+        else
+        {
+            return Date(0); ///@todo better throw exception?
+        }
 	}
 
 	void DsaManager::setCurrentDate(const Date& date)
 	{
-		setTimestamp(date.getTimestamp());
+        GameTimeSource* ts = dynamic_cast<GameTimeSource*>(
+            TimeSourceManager::getSingleton().getTimeSource(
+                TimeSource::GAMETIME));
+
+        if (ts)
+        {
+            ts->setDate(date);
+        }
+        //else ///@todo better throw exception?
 	}
 
-    Real DsaManager::getTimeScale() const
-    {
-        return mTimeScale;
-    }
-
-    void DsaManager::setTimeScale(Real scale)
-    {
-        // First refresh time with old scale.
-        getTimestamp();
-        // Then set new scale.
-        mTimeScale = scale;
-    }
-
     int DsaManager::rollD20() const
     {
         double d = std::rand();

Added: rl/trunk/engine/rules/src/GameTimeSource.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameTimeSource.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/src/GameTimeSource.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -0,0 +1,53 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h"
+#include "GameTimeSource.h"
+
+namespace rl
+{
+
+    GameTimeSource::GameTimeSource()
+        : RealTimeInterruptable()
+    {
+    }
+
+    GameTimeSource::~GameTimeSource()
+    {
+    }
+
+    void GameTimeSource::setDate(const Date& date)
+    {
+        setClock(date.getTimestamp());
+    }
+
+    Date GameTimeSource::getDate() const
+    {
+        return Date(getClock());
+    }
+
+    const Ogre::String& GameTimeSource::getName() const
+    {
+        static Ogre::String NAME = "Game time source";
+        return NAME;
+    }
+
+    TimeSource::TimeSourceType GameTimeSource::getType() const
+    {
+        return TimeSource::GAMETIME;
+    }
+
+}

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -24,9 +24,9 @@
 #include "EffectFactory.h"
 #include "Logger.h"
 #include "CreatureControllerManager.h"
-#include "TimerManager.h"
 #include "GameObjectManager.h"
 #include "QuestBook.h"
+#include "GameTimeSource.h"
 
 template <>
 rl::RulesSubsystem* Singleton<rl::RulesSubsystem>::ms_Singleton = 0;
@@ -38,13 +38,15 @@
         mCombatManager(NULL),
         mDsaManager(NULL),
         mMovingCreatureManager(NULL),
-        mTimerManager(NULL),
         mXdimlLoader(NULL)
     {
 		LOG_MESSAGE(Logger::RULES, "Start");
         //Zufallsgenerator initialisieren
         srand(static_cast<unsigned int>(time(NULL)));
 
+        TimeSourceManager::getSingleton().registerTimeSource(
+            new GameTimeSource());
+
         //Singletons erzeugen
         mActionManager = new ActionManager();
 		LOG_MESSAGE(Logger::RULES, "ActionManager erzeugt");
@@ -54,8 +56,6 @@
 		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
         mMovingCreatureManager = new CreatureControllerManager();
 		LOG_MESSAGE(Logger::RULES, "CreatureControllerManager erzeugt");
-        mTimerManager = new TimerManager();
-		LOG_MESSAGE(Logger::RULES, "TimerManager erzeugt");
 		resetQuestBook();
 		LOG_MESSAGE(Logger::RULES, "Questverwaltung erzeugt");
 
@@ -71,7 +71,6 @@
 	RulesSubsystem::~RulesSubsystem()
     {
         delete mQuestBook;
-        delete mTimerManager;
         delete mDsaManager;
         delete mMovingCreatureManager;
         delete mCombatManager;

Deleted: rl/trunk/engine/rules/src/TimerEvent.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerEvent.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/src/TimerEvent.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,37 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "TimerEvent.h"
-
-#include "TimerEventSource.h"
-
-namespace rl {
-
-TimerEvent::TimerEvent( TimerEventSource* src )
-    : EventObject(src,0)
-{
-
-}
-
-TimerEventSource* TimerEvent::getSource() const
-{
-	EventSource* eve =  EventObject::getSource();
-    return dynamic_cast<TimerEventSource*>( eve );
-}
-
-}
-

Deleted: rl/trunk/engine/rules/src/TimerEventSource.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,148 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "TimerEventSource.h"
-
-#include "TimerEvent.h"
-#include "TimerManager.h"
-#include "TimerListener.h"
-#include "DsaManager.h"
-#include "GameLoop.h"
-#include "ScriptWrapper.h"
-
-using Ogre::Real;
-
-namespace rl {
-
-	const RL_LONGLONG TimerEventSource::NO_REPEAT = 0L;
-
-	TimerEventSource::TimerEventSource( RL_LONGLONG time, RL_LONGLONG repeat ) :
-		mTimerEventCaster(),
-		mType(TIMER_GAME_TIME),
-		mGameTime(time),
-		mGameTimeRepeatInterval(repeat),
-		mGameTimeLastCall(0L),
-		mDsaTime(0L),
-		mDsaTimeLastCall(0L),
-		mDsaTimeRepeatInterval(0L)
-	{
-		TimerManager::getSingleton().registerTimerEventSource(this);
-	}
-
-	TimerEventSource::TimerEventSource( Date time, Date repeat ) :
-		mTimerEventCaster(),
-		mType(TIMER_DSA_TIME),
-		mGameTime(0L),
-		mGameTimeRepeatInterval(0L),
-		mGameTimeLastCall(0L),
-		mDsaTime(time),
-		mDsaTimeRepeatInterval(repeat),
-		mDsaTimeLastCall(0L)
-	{
-		TimerManager::getSingleton().registerTimerEventSource(this);
-	}
-
-    TimerEventSource::~TimerEventSource()
-    {
-		TimerManager::getSingleton().unregisterTimerEventSource(this);
-
-		// Alle TimerListener
-		EventCaster<TimerEvent>::EventSet evSet
-			= mTimerEventCaster.getEventSet();
-		EventCaster<TimerEvent>::EventSet::iterator citer
-			= evSet.begin();
-		for (citer; citer != evSet.end(); )
-		{
-			EventListener<TimerEvent>* ev = *citer;
-			TimerListener* al = dynamic_cast<TimerListener*>( ev );
-			ScriptWrapper::getSingleton().disowned( al );
-			citer++;
-		}
-        mTimerEventCaster.removeEventListeners();
-    }
-
-
-	void TimerEventSource::fireTimerEvent()
-	{
-		TimerEvent* evt = new TimerEvent(this);
-		if (mType == TIMER_DSA_TIME)
-		{
-			Date date = DsaManager::getSingleton().getCurrentDate();
-			evt->setTime(date);
-			mDsaTimeLastCall = date;
-		}
-		else if (mType == TIMER_GAME_TIME)
-		{
-			RL_LONGLONG time = GameLoop::getSingleton().getClock();
-			evt->setTime(time);
-			mGameTimeLastCall = time;
-		}
-
-		mTimerEventCaster.dispatchEvent(evt);
-        delete evt;
-	}
-
-    void TimerEventSource::addTimerListener( TimerListener*  list )
-    {
-		if( !mTimerEventCaster.containsListener( list ) )
-		{
-			mTimerEventCaster.addEventListener( list );
-			ScriptWrapper::getSingleton().owned(list);
-		}
-    }
-
-    void TimerEventSource::removeTimerListener( TimerListener* list )
-    {
-		if( mTimerEventCaster.containsListener( list ) )
-		{
-			mTimerEventCaster.removeEventListener( list );
-			ScriptWrapper::getSingleton().disowned(list);
-		}
-    }
-
-    bool TimerEventSource::hasListeners( ) const
-    {
-        return mTimerEventCaster.hasEventListeners();
-    }
-
-	bool TimerEventSource::injectTimePulse(RL_LONGLONG gameTime, Date dsaTime)
-	{
-		bool deleteSource = false;
-
-		if (mType == TIMER_DSA_TIME)
-		{
-			if (mDsaTime < dsaTime && mDsaTimeLastCall + mDsaTimeRepeatInterval <= dsaTime)
-			{
-				if (mDsaTimeRepeatInterval == NO_REPEAT)
-					deleteSource = true;
-				fireTimerEvent();
-			}
-		}
-		else if (mType == TIMER_GAME_TIME)
-		{
-			if (mGameTime < gameTime && mGameTimeLastCall + mGameTimeRepeatInterval <= gameTime)
-			{
-				if (mGameTimeRepeatInterval == NO_REPEAT)
-					deleteSource = true;
-				fireTimerEvent();
-			}
-		}
-
-		return deleteSource;
-	}
-}
-

Deleted: rl/trunk/engine/rules/src/TimerListener.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerListener.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/src/TimerListener.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,37 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "TimerListener.h"
-
-#include "CoreSubsystem.h"
-#include "Exception.h"
-
-namespace rl {
-
-    TimerListener::~TimerListener()
-    {
-	}
-
-	bool TimerListener::eventRaised(TimerEvent* evt)
-	{
-        timerFired(evt);
-
-        // consumed or not
-		return false;
-	}
-}
-

Deleted: rl/trunk/engine/rules/src/TimerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerManager.cpp	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/rules/src/TimerManager.cpp	2007-07-30 20:55:01 UTC (rev 3646)
@@ -1,100 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "TimerManager.h"
-
-#include "GameLoop.h"
-#include "CoreSubsystem.h"
-#include "DsaManager.h"
-#include "TimerEventSource.h"
-#include "ScriptWrapper.h"
-#include "Exception.h"
-
-
-using Ogre::Singleton;
-using Ogre::StringConverter;
-
-template<> rl::TimerManager* Singleton<rl::TimerManager>::ms_Singleton = 0;
-
-namespace rl {
-
-	TimerManager::TimerManager() :
-		mTimers()
-	{
-        GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
-	}
-
-	TimerManager::~TimerManager()
-	{
-		for (std::set<TimerEventSource*>::iterator timerIter = mTimers.begin();
-			timerIter != mTimers.end();timerIter++)
-		{
-			TimerEventSource* currTimer = *timerIter;
-			ScriptWrapper::getSingleton().disowned( currTimer );
-		}
-		mTimers.clear();
-		GameLoop::getSingleton().removeTask(this);
-	}
-
-	void TimerManager::run(Ogre::Real elapsedTime)
-	{
-		RL_LONGLONG nowDsa = DsaManager::getSingleton().getTimestamp();
-		RL_LONGLONG now = GameLoop::getSingleton().getClock();
-
-		for (std::set<TimerEventSource*>::iterator timerIter = mTimers.begin();
-			timerIter != mTimers.end();)
-		{
-			TimerEventSource* currTimer = *timerIter;
-			bool toDelete = currTimer->injectTimePulse(now, nowDsa);
-
-			if (toDelete)
-			{
-				mTimers.erase( timerIter++ );
-				ScriptWrapper::getSingleton().disowned( currTimer );
-			}
-			else
-				++timerIter;
-		}
-	}
-
-	void TimerManager::registerTimerEventSource(TimerEventSource* source)
-	{
-		if (mTimers.find(source) != mTimers.end())
-		{
-            Throw(IllegalArgumentException, "TimerEventSource already registered.");
-        }
-		mTimers.insert(source);
-		ScriptWrapper::getSingleton().owned( source );
-	}
-
-	void TimerManager::unregisterTimerEventSource(TimerEventSource* source)
-    {
-		if (mTimers.find(source) == mTimers.end())
-		{
-            Throw(IllegalArgumentException, "TimerEventSource not registered.");
-        }
-		mTimers.erase(source);
-		ScriptWrapper::getSingleton().disowned(source);
-    }
-
-    const Ogre::String& TimerManager::getName() const
-    {
-        static Ogre::String NAME = "TimerManager";
-
-        return NAME;
-    }
-}

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-07-30 20:55:01 UTC (rev 3646)
@@ -662,7 +662,6 @@
     rl::ContentModule* getModule(const Ogre::String& moduleId) const;
 
     rl::World* getWorld();
-    unsigned long getClock();
     void makeScreenshot(const Ogre::String& sName);
     bool isInitialized() const;
     void setScheme(const Ogre::String& schemeName);

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-07-30 20:46:57 UTC (rev 3645)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-07-30 20:55:01 UTC (rev 3646)
@@ -97,7 +97,6 @@
     public:
         RL_LONGLONG getTimestamp();
         Date getCurrentDate();
-        void setTimestamp(const RL_LONGLONG time);
         void setCurrentDate(const Date& date);
         
         int rollD20();
@@ -726,38 +725,6 @@
         static rl::ActionManager& getSingleton();
     };
     
-    %feature("director") TimerListener;
-    class TimerListener
-    {
-    public:
-        virtual ~TimerLister();
-      
-          virtual void timerFired(rl::TimerEvent* anEvent) = 0;
-    };
-    
-    class TimerEventSource
-    {
-    public:
-        static const RL_LONGLONG NO_REPEAT;
-
-        TimerEventSource( const RL_LONGLONG gameTime, const RL_LONGLONG interval = rl::TimerEventSource::NO_REPEAT );
-        TimerEventSource( const rl::Date dsaTime, const rl::Date interval = rl::TimerEventSource::NO_REPEAT );
-    
-        void addTimerListener( rl::TimerListener* ist );
-        void removeTimerListener( rl::TimerListener* ist );
-    };
-    
-    class TimerEvent
-    {
-    public:
-        TimerEvent( rl::TimerEventSource* src );
-    
-        Ogre::Real getTime();
-        rl::Date getGameTime();
-
-        rl::TimerEventSource* getSource() const;
-    };
-    
     class CreatureController
     {
     public:



From blakharaz at mail.berlios.de  Mon Jul 30 23:16:55 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 30 Jul 2007 23:16:55 +0200
Subject: [Dsa-hl-svn] r3647 - rl/trunk/engine/script/swig
Message-ID: <200707302116.l6ULGtsG017131@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-30 23:16:50 +0200 (Mon, 30 Jul 2007)
New Revision: 3647

Modified:
   rl/trunk/engine/script/swig/RlRules.head.swig
Log:
Removed #includes of deleted headers


Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-30 20:55:01 UTC (rev 3646)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-30 21:16:50 UTC (rev 3647)
@@ -48,9 +48,6 @@
 #include "StateSet.h"
 #include "Talent.h"
 #include "TalentStateSet.h"
-#include "TimerEventSource.h"
-#include "TimerEvent.h"
-#include "TimerListener.h"
 #include "Tripel.h"
 #include "Weapon.h"
 #include "CreatureController.h"



From blakharaz at mail.berlios.de  Mon Jul 30 23:41:39 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 30 Jul 2007 23:41:39 +0200
Subject: [Dsa-hl-svn] r3648 - rl/trunk/engine/script/swig
Message-ID: <200707302141.l6ULfdOj018830@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-30 23:41:36 +0200 (Mon, 30 Jul 2007)
New Revision: 3648

Modified:
   rl/trunk/engine/script/swig/RlExports.i
Log:
catch Swig::DirectorException (no subclass of std::exception)


Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-07-30 21:16:50 UTC (rev 3647)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-07-30 21:41:36 UTC (rev 3648)
@@ -46,6 +46,7 @@
 #include "FixRubyHeaders.h"
 
 #include <CEGUIExceptions.h>
+#include <vector>
 
 %}
 
@@ -62,6 +63,11 @@
 %include "RlAi.head.swig"
 %include "RlScript.head.swig"
 
+%{
+#ifndef SWIG_FLOAT_P
+#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))
+#endif
+%}
 %include "TypeMaps.i"
 
 
@@ -128,18 +134,27 @@
 
 // Converting C++ Exceptions to Ruby Exceptions
 %exception %{
-  try {
+  try 
+  {
     $action
   }
-  catch (CEGUI::Exception& ce) {
+  catch (CEGUI::Exception& ce) 
+  {
     static VALUE ceguiException = rb_define_class("CeguiException", rb_eRuntimeError);
     rb_raise(ceguiException, ce.getMessage().c_str());
   }
-  catch (std::exception& se) {
+  catch (std::exception& se) 
+  {
     static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
     rb_raise(stdException, se.what());
   }
-  catch (...) {
+  catch (Swig::DirectorException& de)
+  {
+	static VALUE swigException = rb_define_class("SwigDirectorException", rb_eRuntimeError);
+	rb_raise(swigException, de.getMessage().c_str());
+  }
+  catch (...) 
+  {
     static VALUE unknownException = rb_define_class("UnknownException", rb_eRuntimeError);
     rb_raise(unknownException,"Unbekannte Exception");
   }



From pnyx at mail.berlios.de  Tue Jul 31 10:47:59 2007
From: pnyx at mail.berlios.de (pnyx at mail.berlios.de)
Date: Tue, 31 Jul 2007 10:47:59 +0200
Subject: [Dsa-hl-svn] r3649 - in modules/ruchin: maps models
Message-ID: <200707310847.l6V8lxFI023167@sheep.berlios.de>

Author: pnyx
Date: 2007-07-31 10:42:57 +0200 (Tue, 31 Jul 2007)
New Revision: 3649

Added:
   modules/ruchin/models/Ruchin_ground.material
   modules/ruchin/models/Ruchin_ground.mesh
Modified:
   modules/ruchin/maps/ruchin.scene
   modules/ruchin/models/Ruchin_l.mesh
   modules/ruchin/models/Ruchin_map.mesh
   modules/ruchin/models/Ruchin_r.mesh
Log:
fixed Rathaus, had wrong material id resulting in unwanted transparency and z-sorting issues

added ground test in a small part of Ruchin 

Modified: modules/ruchin/maps/ruchin.scene
===================================================================
--- modules/ruchin/maps/ruchin.scene	2007-07-30 21:41:36 UTC (rev 3648)
+++ modules/ruchin/maps/ruchin.scene	2007-07-31 08:42:57 UTC (rev 3649)
@@ -357,5 +357,19 @@
 			/>
 
 		</node>
+		
+		<node name="Ruchin_ground" id="3" >
+			<position x="0.0" y="0.0" z="0.0" />
+			<rotation qx="0.0" qy="0.0" qz="0.0" qw="0.0" />
+			<scale x="1.0" y="1.0" z="1.0" />
+			<entity
+				name="Ruchin_ground"
+				id="4"
+				meshFile ="Ruchin_ground.mesh"
+				materialFile="ruchin_terrain.material"
+				castsShadow="false"
+			/>
+
+		</node>
 	</nodes>
 </scene>
\ No newline at end of file

Added: modules/ruchin/models/Ruchin_ground.material
===================================================================
--- modules/ruchin/models/Ruchin_ground.material	2007-07-30 21:41:36 UTC (rev 3648)
+++ modules/ruchin/models/Ruchin_ground.material	2007-07-31 08:42:57 UTC (rev 3649)
@@ -0,0 +1,40 @@
+material Ruchin_ground: TerrainVColorBlending
+{
+
+   set_texture_alias black       erdboden01.dds
+   set_texture_alias red         laub01.dds
+   set_texture_alias green       nat_gras_01.dds
+   set_texture_alias blue        nat_steingrund_01.dds
+   set_texture_alias alpha       Tiles.dds
+   set_texture_alias Lightingmap Lightingmap2.png
+   
+   technique
+   {
+      pass
+      {
+         fragment_program_ref
+         {
+            param_named scale_Detail4 float 0.050000 // Alpha
+         }
+
+         vertex_program_ref
+         {
+            param_named Light_Ambient float4 0.500000 0.500000 0.500000 1.000000
+
+            param_named scale_Texture0 float 0.58000 // Schwarz
+            param_named scale_Detail0 float 0.020000
+
+            param_named scale_Texture1 float 0.5700 // Rot
+            param_named scale_Detail1 float 1.00000
+
+            param_named scale_Texture2 float 0.28500 // Gruen
+            param_named scale_Detail2 float 0.60000
+
+            param_named scale_Texture3 float 0.58000 // Blau
+            param_named scale_Detail3 float 1.00000
+
+            param_named scale_Texture4 float 0.016000 // Alpha
+         }
+      }
+   }
+}

Added: modules/ruchin/models/Ruchin_ground.mesh
===================================================================
(Binary files differ)


Property changes on: modules/ruchin/models/Ruchin_ground.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/ruchin/models/Ruchin_l.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_map.mesh
===================================================================
(Binary files differ)

Modified: modules/ruchin/models/Ruchin_r.mesh
===================================================================
(Binary files differ)



From zero-gravity at mail.berlios.de  Tue Jul 31 13:09:59 2007
From: zero-gravity at mail.berlios.de (zero-gravity at mail.berlios.de)
Date: Tue, 31 Jul 2007 13:09:59 +0200
Subject: [Dsa-hl-svn] r3650 - rl/trunk/tools
Message-ID: <200707311109.l6VB9x2a015564@sheep.berlios.de>

Author: zero-gravity
Date: 2007-07-31 13:09:51 +0200 (Tue, 31 Jul 2007)
New Revision: 3650

Added:
   rl/trunk/tools/update_all_meshes.rb
Log:
Added small ruby script which collects all meshes in a given module folder, and calls OgreMeshUpgrade for those

Added: rl/trunk/tools/update_all_meshes.rb
===================================================================
--- rl/trunk/tools/update_all_meshes.rb	2007-07-31 08:42:57 UTC (rev 3649)
+++ rl/trunk/tools/update_all_meshes.rb	2007-07-31 11:09:51 UTC (rev 3650)
@@ -0,0 +1,83 @@
+# Path to modules directory
+modPath = "../rl_dist/modules/"
+# Command to start (from modules)
+runMe = '../OgreMeshUpgrade.exe'
+
+
+################################################################################
+# Class for correct execution of system commands under windows
+class ExecCmd
+        attr_reader :output,:cmd,:exec_time
+        #When a block is given, the command runs before yielding
+        def initialize( cmd )
+            @cmd=cmd
+            @cmd_run=cmd+" 2>&1" unless cmd=~/2>&1/
+            if block_given?
+                run
+                yield self
+            end
+        end
+        #Runs the command
+        def run()
+            t1=Time.now
+            IO.popen(@cmd_run){|f|
+                @output=f.read
+                @process=Process.waitpid2(f.pid)[1]
+            }
+            @exec_time=Time.now-t1
+        end
+        #Returns false if the command hasn't been executed yet
+        def run?()
+            return false unless @process
+            return true
+        end
+        #Returns the exit code for the command. Runs the command if it hasn't run yet.
+        def exitcode()
+            run unless @process
+            @process.exitstatus
+        end
+        #Returns true if the command was succesfull.
+        #
+        #Will return false if the command hasn't been executed
+        def success?()
+            return @process.success? if @process
+            return false
+        end
+end 
+
+################################################################################
+
+# Change Dir and search for all mesh files
+Dir.chdir( modPath )
+basePath = Dir.pwd + "/"
+meshes = Dir['**/*.{mesh}']
+
+
+print "Found #{meshes.size} different mesh-files.\n\n"
+
+skipped = 0;
+count = 0;
+
+# Sync print() calls
+STDOUT.sync = 1
+# Update all meshes
+meshes.each { |filename|   
+    begin 
+        runCommand = basePath + runMe + ' -b "' + basePath + filename + '"'
+        cmd = ExecCmd.new( runCommand );
+        cmd.run
+
+        if not cmd.success? then
+            raise( RuntimeError, "Command not executed\n" + cmd.output )
+        end
+        count += 1
+        print "Updated #{filename} (#{count})                                          \r";
+ 
+    rescue RuntimeError => error
+        print basePath+filename+":0:"+error.to_s
+        skipped += 1
+        exit
+    end
+}
+
+print "\nUpdated #{meshes.size-skipped} mesh files (skipped #{skipped}).\n\n"
\ No newline at end of file



From blakharaz at mail.berlios.de  Tue Jul 31 18:52:09 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 31 Jul 2007 18:52:09 +0200
Subject: [Dsa-hl-svn] r3651 - modules/common/scripts/jobs
	modules/regressiontest/scripts rl/trunk/engine/core/include
	rl/trunk/engine/core/src rl/trunk/engine/script/swig
Message-ID: <200707311652.l6VGq9c3016604@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-31 18:51:43 +0200 (Tue, 31 Jul 2007)
New Revision: 3651

Modified:
   modules/common/scripts/jobs/closurejobs.rb
   modules/common/scripts/jobs/jobsequence.rb
   modules/regressiontest/scripts/JobSequenceTest.rb
   rl/trunk/engine/core/include/JobQueue.h
   rl/trunk/engine/core/src/JobQueue.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlUi.swig
Log:
* removed reinterpret_casts from dynamic downcasts in swig code
* implemented JobQueue and JobSet

Modified: modules/common/scripts/jobs/closurejobs.rb
===================================================================
--- modules/common/scripts/jobs/closurejobs.rb	2007-07-31 11:09:51 UTC (rev 3650)
+++ modules/common/scripts/jobs/closurejobs.rb	2007-07-31 16:51:43 UTC (rev 3651)
@@ -2,7 +2,7 @@
 
 class ClosureJob < Job
   def initialize()
-    super(true, true)
+    super(false, true)
   end
 
   def setCode(&code)

Modified: modules/common/scripts/jobs/jobsequence.rb
===================================================================
--- modules/common/scripts/jobs/jobsequence.rb	2007-07-31 11:09:51 UTC (rev 3650)
+++ modules/common/scripts/jobs/jobsequence.rb	2007-07-31 16:51:43 UTC (rev 3651)
@@ -19,3 +19,30 @@
     }
 end
 
+# A queue of jobs.
+# jobs is an array of Jobs and Numerics. Numerics are accumulated pauses
+# till the next job starts.
+def jobQueue (jobs)
+    start = 0
+    p "start"
+	queue = JobQueue.new()
+    jobs.each { |x|
+		if x.is_a? Array:
+			set = JobSet.new()
+			x.each { |y|
+				set.add(y) 
+			}
+			queue.add(set)
+#       elsif x.is_a? Numeric:
+#            # This is a time, we add it to the start time, of jobs
+#            # later in the queue
+#            start += x
+#            p "starttime #start"
+        elsif x.is_a? Job
+            queue.add(x)
+            p "job added"
+        end
+    }
+	$JS.addJob(queue, 20)
+end
+

Modified: modules/regressiontest/scripts/JobSequenceTest.rb
===================================================================
--- modules/regressiontest/scripts/JobSequenceTest.rb	2007-07-31 11:09:51 UTC (rev 3650)
+++ modules/regressiontest/scripts/JobSequenceTest.rb	2007-07-31 16:51:43 UTC (rev 3651)
@@ -5,7 +5,7 @@
 
 class JobSequenceTestAction < Action
   def initialize
-    super("checktime", "Zeit ansagen lassen.");
+    super("sequence", "Test job sequence.");
   end
   
   def canDo(go, user)
@@ -31,27 +31,34 @@
   end
 end
 
-#class JobQueueTestAction < Action
-#  def initialize
-#    super("checktime", "Zeit ansagen lassen.");
-#  end
+class JobQueueTestAction < Action
+  def initialize
+    super("queue", "Test job queue");
+  end
   
-#  def canDo(go, user)
-#    true
-#  end
+  def canDo(go, user)
+    true
+  end
   
-#  def doAction(go, user, target)
-#    jobQueue(
-#            [
-#                jobSequence([_PlayAnimation(go.getActor(), "auf"), _PlaySound3d("doorcreak.ogg", go.getPosition())],
-#				_PlaySound3d("lachen.ogg", go.getPosition()),
-#                jobSequence([_PlayAnimation(go.getActor(), "zu"), _PlaySound3d("doorcreak.ogg", go.getPosition())],
-#				2,
-#				_ExecuteJob {$UI.requestExit}
-#            ]
-#    );
-#  end
-#end
+  def doAction(go, user, target)
+    jobQueue(
+            [
+                [
+					_PlayAnimation(go.getActor(), "auf"), 
+					_PlaySound3d("doorcreak.ogg", go.getPosition())
+				],
+				_PlaySound3d("lachen.ogg", go.getPosition()),
+				[
+					_PlayAnimation(go.getActor(), "zu"), 
+					_PlaySound3d("doorcreak.ogg", go.getPosition())
+				],
+				2,
+				_Execute {provokeEror},
+				_Execute {p "FOO"}
+            ]
+    )
+  end
+end
 
 class JobSequenceTest < TestCase
     def execute()
@@ -66,6 +73,7 @@
         chest = $GOM.createGameObject(
             "JobSequenceTestChest");
         chest.addAction(JobSequenceTestAction.new());
+        chest.addAction(JobQueueTestAction.new());
         chest.placeIntoScene();
         chest.setPosition(rel_pos([0.0, height, 0.0]));
 

Modified: rl/trunk/engine/core/include/JobQueue.h
===================================================================
--- rl/trunk/engine/core/include/JobQueue.h	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/core/include/JobQueue.h	2007-07-31 16:51:43 UTC (rev 3651)
@@ -16,24 +16,39 @@
 #ifndef __JOBQUEUE_H__
 #define __JOBQUEUE_H__
 
+#include "CorePrerequisites.h"
+
 #include "Job.h"
 
 namespace rl
 {
 
-    class JobQueue : public Job
+    class _RlCoreExport JobQueue : public Job
     {
     public:
         JobQueue();
         ~JobQueue();
 
-        void addJob(Job* job);
+        void add(Job* job);
         virtual bool execute(Ogre::Real elapsedTime);
 
     private:
         std::list<Job*> mQueue;
     };
 
+    class _RlCoreExport JobSet : public Job
+    {
+    public:
+        JobSet();
+        ~JobSet();
+
+        void add(Job* job);
+        virtual bool execute(Ogre::Real elapsedTime);
+
+    private:
+        std::set<Job*> mSet;
+    };
+
 }
 
 #endif // __JOBQUEUE_H__

Modified: rl/trunk/engine/core/src/JobQueue.cpp
===================================================================
--- rl/trunk/engine/core/src/JobQueue.cpp	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/core/src/JobQueue.cpp	2007-07-31 16:51:43 UTC (rev 3651)
@@ -21,7 +21,7 @@
 {
 
 JobQueue::JobQueue()
-: Job(true, true)
+: Job(false, true)
 {
 }
 
@@ -29,9 +29,90 @@
 {
 }
 
+void JobQueue::add(Job* job)
+{
+    mQueue.push_back(job);
+}
+
 bool JobQueue::execute(Ogre::Real elapsedTime)
 {
-    return true; ///@todo
+    Job* cur = *mQueue.begin();
+    bool finished = cur->execute(elapsedTime);
+    if (finished)
+    {
+        mQueue.pop_front();
+        if (cur->isDiscardable())
+        {
+            cur->discard();
+        }
+        if (cur->destroyWhenDone())
+        {
+            delete cur;
+        }
+    }
+
+    if (mQueue.empty())
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
 }
 
+JobSet::JobSet()
+: Job(false, true)
+{
 }
+
+JobSet::~JobSet()
+{
+}
+
+void JobSet::add(Job* job)
+{
+    mSet.insert(job);
+}
+
+bool JobSet::execute(Ogre::Real elapsedTime)
+{
+    std::set<Job*> toDelete;
+
+    for (std::set<Job*>::iterator it = mSet.begin(); 
+        it != mSet.end(); ++it)
+    {
+        Job* cur = *it;
+        bool finished = cur->execute(elapsedTime);
+        if (finished)
+        {
+            toDelete.insert(cur);
+        }
+    }
+
+    for (std::set<Job*>::iterator it = toDelete.begin(); 
+        it != toDelete.end(); ++it)
+    {
+        Job* cur = *it;
+        mSet.erase(cur);
+        if (cur->isDiscardable())
+        {
+            cur->discard();
+        }
+        if (cur->destroyWhenDone())
+        {
+            delete cur;
+        }
+    }
+
+    if (mSet.empty())
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+}

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-07-31 16:51:43 UTC (rev 3651)
@@ -16,9 +16,9 @@
 
 %include std_vector.i
 
-namespace std {
-	%template(Ogrevec3Vector) vector<Ogre::Vector3 >;
-};
+//namespace std {
+//	%template(Ogrevec3Vector) vector<Ogre::Vector3 >;
+//};
 
 namespace rl 
 {
@@ -271,27 +271,27 @@
 %{
 static swig_type_info *AStarHeuristic_dynamic_cast(void **ptr)
 {
-    rl::AStarHeuristic **ppAStarHeuristic = reinterpret_cast<rl::AStarHeuristic**>(ptr);
+    rl::AStarHeuristic *pAStarHeuristic = static_cast<rl::AStarHeuristic*>(*ptr);
 
-    rl::ManhattanDistance *pManhattanDistance=dynamic_cast<rl::ManhattanDistance*>(*ppAStarHeuristic);
+    rl::ManhattanDistance *pManhattanDistance=dynamic_cast<rl::ManhattanDistance*>(pAStarHeuristic);
     if (pManhattanDistance)
     {
         *ptr=pManhattanDistance;
         return SWIGTYPE_p_rl__ManhattanDistance;
     }
-    rl::DiagonalDistance *pDiagonalDistance=dynamic_cast<rl::DiagonalDistance*>(*ppAStarHeuristic);
+    rl::DiagonalDistance *pDiagonalDistance=dynamic_cast<rl::DiagonalDistance*>(pAStarHeuristic);
     if (pDiagonalDistance)
     {
         *ptr=pDiagonalDistance;
         return SWIGTYPE_p_rl__DiagonalDistance;
     }
-    rl::EuclideanDistance *pEuclideanDistance=dynamic_cast<rl::EuclideanDistance*>(*ppAStarHeuristic);
+    rl::EuclideanDistance *pEuclideanDistance=dynamic_cast<rl::EuclideanDistance*>(pAStarHeuristic);
     if (pEuclideanDistance)
     {
         *ptr=pEuclideanDistance;
         return SWIGTYPE_p_rl__EuclideanDistance;
     }
-    rl::EuclideanDistanceSquared *pEuclideanDistanceSquared=dynamic_cast<rl::EuclideanDistanceSquared*>(*ppAStarHeuristic);
+    rl::EuclideanDistanceSquared *pEuclideanDistanceSquared=dynamic_cast<rl::EuclideanDistanceSquared*>(pAStarHeuristic);
     if (pEuclideanDistanceSquared)
     {
         *ptr=pEuclideanDistanceSquared;
@@ -307,9 +307,9 @@
 %{
 static swig_type_info *AStarCosts_dynamic_cast(void **ptr)
 {
-    rl::AStarCosts **ppAStarCosts = reinterpret_cast<rl::AStarCosts**>(ptr);
+    rl::AStarCosts *pAStarCosts = static_cast<rl::AStarCosts*>(*ptr);
 
-    rl::AStarCostsDefault *pAStarCostsDefault=dynamic_cast<rl::AStarCostsDefault*>(*ppAStarCosts);
+    rl::AStarCostsDefault *pAStarCostsDefault=dynamic_cast<rl::AStarCostsDefault*>(pAStarCosts);
     if (pAStarCostsDefault)
     {
         *ptr=pAStarCostsDefault;

Modified: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-07-31 16:51:43 UTC (rev 3651)
@@ -53,6 +53,7 @@
 #include "SoundEvents.h"
 #include "JobScheduler.h"
 #include "Job.h"
+#include "JobQueue.h"
 #include "JobListener.h"
 #include "PlaySoundJob.h"
 #include "PlayAnimationJob.h"

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-07-31 16:51:43 UTC (rev 3651)
@@ -17,9 +17,9 @@
 namespace rl {
 %{
 static swig_type_info *GameAreaType_dynamic_cast(void **ptr) {
-    rl::GameAreaType **ppGameAreaType = reinterpret_cast<rl::GameAreaType **>(ptr);
+    rl::GameAreaType *pGameAreaType = static_cast<rl::GameAreaType *>(*ptr);
     
-    rl::GameSphereAreaType *pGameSphereAreaType = dynamic_cast<rl::GameSphereAreaType*>(*ppGameAreaType);
+    rl::GameSphereAreaType *pGameSphereAreaType = dynamic_cast<rl::GameSphereAreaType*>(pGameAreaType);
     if (pGameSphereAreaType){
       *ptr=pGameSphereAreaType;
       return SWIGTYPE_p_rl__GameSphereAreaType;
@@ -34,19 +34,19 @@
 
 %{
 static swig_type_info *BaseAnimation_dynamic_cast(void **ptr) {
-    rl::BaseAnimation **ppBaseAnimation = reinterpret_cast<rl::BaseAnimation **>(ptr);
+    rl::BaseAnimation *pBaseAnimation = static_cast<rl::BaseAnimation *>(*ptr);
     
-    rl::FadeAnimation *pFadeAnimation = dynamic_cast<rl::FadeAnimation*>(*ppBaseAnimation);
+    rl::FadeAnimation *pFadeAnimation = dynamic_cast<rl::FadeAnimation*>(pBaseAnimation);
     if (pFadeAnimation){
       *ptr=pFadeAnimation;
       return SWIGTYPE_p_rl__FadeAnimation;
     }    
-    rl::MeshAnimation *pMeshAnimation = dynamic_cast<rl::MeshAnimation*>(*ppBaseAnimation);
+    rl::MeshAnimation *pMeshAnimation = dynamic_cast<rl::MeshAnimation*>(pBaseAnimation);
     if (pMeshAnimation){
       *ptr=pMeshAnimation;
       return SWIGTYPE_p_rl__MeshAnimation;
     }    
-    rl::TrackAnimation *pTrackAnimation = dynamic_cast<rl::TrackAnimation*>(*ppBaseAnimation);
+    rl::TrackAnimation *pTrackAnimation = dynamic_cast<rl::TrackAnimation*>(pBaseAnimation);
     if (pTrackAnimation){
       *ptr=pTrackAnimation;
       return SWIGTYPE_p_rl__TrackAnimation;
@@ -61,35 +61,35 @@
 %{
 static swig_type_info *ActorControlledObject_dynamic_cast(void **ptr)
 {
-    rl::ActorControlledObject **ppActorControlledObject =
-        reinterpret_cast<rl::ActorControlledObject**>(ptr);
+    rl::ActorControlledObject *pActorControlledObject =
+        static_cast<rl::ActorControlledObject*>(*ptr);
 
-    rl::MergeableMeshObject *pMergeableMeshObject=dynamic_cast<rl::MergeableMeshObject*>(*ppActorControlledObject);
+    rl::MergeableMeshObject *pMergeableMeshObject=dynamic_cast<rl::MergeableMeshObject*>(pActorControlledObject);
     if (pMergeableMeshObject) {
         *ptr=pMergeableMeshObject;
         return SWIGTYPE_p_rl__MergeableMeshObject;
     }
-    rl::MeshObject *pMeshObject=dynamic_cast<rl::MeshObject*>(*ppActorControlledObject);
+    rl::MeshObject *pMeshObject=dynamic_cast<rl::MeshObject*>(pActorControlledObject);
     if (pMeshObject) {
         *ptr=pMeshObject;
         return SWIGTYPE_p_rl__MeshObject;
     }
-    rl::CameraObject *pCameraObject=dynamic_cast<rl::CameraObject*>(*ppActorControlledObject);
+    rl::CameraObject *pCameraObject=dynamic_cast<rl::CameraObject*>(pActorControlledObject);
     if (pCameraObject) {
         *ptr=pCameraObject;
         return SWIGTYPE_p_rl__CameraObject;
     }
-    rl::LightObject *pLightObject=dynamic_cast<rl::LightObject*>(*ppActorControlledObject);
+    rl::LightObject *pLightObject=dynamic_cast<rl::LightObject*>(pActorControlledObject);
     if (pLightObject) {
         *ptr=pLightObject;
         return SWIGTYPE_p_rl__LightObject;
     }
-    rl::ParticleSystemObject *pParticleSystemObject=dynamic_cast<rl::ParticleSystemObject*>(*ppActorControlledObject);
+    rl::ParticleSystemObject *pParticleSystemObject=dynamic_cast<rl::ParticleSystemObject*>(pActorControlledObject);
     if (pParticleSystemObject) {
         *ptr=pParticleSystemObject;
         return SWIGTYPE_p_rl__ParticleSystemObject;
     }
-    rl::SoundObject *pSoundObject=dynamic_cast<rl::SoundObject*>(*ppActorControlledObject);
+    rl::SoundObject *pSoundObject=dynamic_cast<rl::SoundObject*>(pActorControlledObject);
     if (pSoundObject) {
         *ptr=pSoundObject;
         return SWIGTYPE_p_rl__SoundObject;
@@ -101,24 +101,34 @@
 
 %{
 static swig_type_info *Job_dynamic_cast(void **ptr) {
-    rl::Job **ppJob = reinterpret_cast<rl::Job **>(ptr);
+    rl::Job *ppJob = static_cast<rl::Job*>(*ptr);
       
     
-    rl::PlayAnimationJob *pPlayAnimationJob = dynamic_cast<rl::PlayAnimationJob*>(*ppJob);
+    rl::PlayAnimationJob *pPlayAnimationJob = dynamic_cast<rl::PlayAnimationJob*>(ppJob);
     if (pPlayAnimationJob){
       *ptr=pPlayAnimationJob;
       return SWIGTYPE_p_rl__PlayAnimationJob;
     }    
-    rl::PlaySound3dJob *pPlaySound3dJob = dynamic_cast<rl::PlaySound3dJob*>(*ppJob);
+    rl::PlaySound3dJob *pPlaySound3dJob = dynamic_cast<rl::PlaySound3dJob*>(ppJob);
     if (pPlaySound3dJob){
       *ptr=pPlaySound3dJob;
       return SWIGTYPE_p_rl__PlaySound3dJob;
     }    
-    rl::PlaySound2dJob *pPlaySound2dJob = dynamic_cast<rl::PlaySound2dJob*>(*ppJob);
+    rl::PlaySound2dJob *pPlaySound2dJob = dynamic_cast<rl::PlaySound2dJob*>(ppJob);
     if (pPlaySound2dJob){
       *ptr=pPlaySound2dJob;
       return SWIGTYPE_p_rl__PlaySound2dJob;
-    }  
+    }
+    rl::JobQueue *pJobQueue = dynamic_cast<rl::JobQueue*>(ppJob);
+    if (pJobQueue) {
+      *ptr=pJobQueue;
+      return SWIGTYPE_p_rl__JobQueue;
+    }
+    rl::JobSet *pJobSet = dynamic_cast<rl::JobSet*>(ppJob);
+    if (pJobSet) {
+      *ptr=pJobSet;
+      return SWIGTYPE_p_rl__JobSet;
+    }
     
     return 0;
 }
@@ -840,6 +850,28 @@
 //    virtual bool execute(Ogre::Real time);
 //};
 
+class JobQueue : public rl::Job
+{
+public:
+    JobQueue();
+    virtual ~JobQueue();
+    void add(Job* job);
+    
+private:
+    bool execute(Ogre::Real time);
+};
+
+class JobSet : public rl::Job
+{
+public:
+    JobSet();
+    virtual ~JobSet();
+    void add(Job* job);
+    
+private:
+    bool execute(Ogre::Real time);
+};
+
 class JobScheduler
 {
 public:

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-07-31 16:51:43 UTC (rev 3651)
@@ -13,6 +13,7 @@
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
+#include "stdinc.h"	
 
 // Activate Directors and name the module RlScript
 %module(directors="1") RlScript

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-07-31 16:51:43 UTC (rev 3651)
@@ -809,14 +809,14 @@
 %{
 static swig_type_info *Selector_dynamic_cast(void **ptr)
 {
-	rl::Selector **ppSelector = reinterpret_cast<rl::Selector**>(ptr);
-	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(*ppSelector);
+	rl::Selector *pSelector = static_cast<rl::Selector*>(*ptr);
+	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(pSelector);
 	if (pHalfSphereSel)
 	{
 		*ptr = pHalfSphereSel;
 		return SWIGTYPE_p_rl__HalfSphereSelector;
 	}
-	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(*ppSelector);
+	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(pSelector);
 	if (pRaySel)
 	{
 		*ptr = pRaySel;
@@ -826,34 +826,34 @@
 	
 static swig_type_info *GameObject_dynamic_cast(void **ptr)
 {
-    rl::GameObject **ppGameObject = reinterpret_cast<rl::GameObject**>(ptr);
+    rl::GameObject *pGameObject = static_cast<rl::GameObject*>(*ptr);
 
-    rl::Person *pPerson=dynamic_cast<rl::Person*>(*ppGameObject);
+    rl::Person *pPerson=dynamic_cast<rl::Person*>(pGameObject);
     if (pPerson) {
         *ptr=pPerson;
         return SWIGTYPE_p_rl__Person;
     }
-    rl::Creature *pCreature=dynamic_cast<rl::Creature*>(*ppGameObject);
+    rl::Creature *pCreature=dynamic_cast<rl::Creature*>(pGameObject);
     if (pCreature) {
         *ptr=pCreature;
         return SWIGTYPE_p_rl__Creature;
     }
-    rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(*ppGameObject);
+    rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(pGameObject);
     if (pWeapon) {
         *ptr=pWeapon;
         return SWIGTYPE_p_rl__Weapon;
     }
-    rl::Armor *pArmor=dynamic_cast<rl::Armor*>(*ppGameObject);
+    rl::Armor *pArmor=dynamic_cast<rl::Armor*>(pGameObject);
     if (pArmor) {
         *ptr=pArmor;
         return SWIGTYPE_p_rl__Armor;
     }
-    rl::Container *pContainer=dynamic_cast<rl::Container*>(*ppGameObject);
+    rl::Container *pContainer=dynamic_cast<rl::Container*>(pGameObject);
     if (pContainer) {
         *ptr=pContainer;
         return SWIGTYPE_p_rl__Container;
     }
-    rl::Item *pItem=dynamic_cast<rl::Item*>(*ppGameObject);
+    rl::Item *pItem=dynamic_cast<rl::Item*>(pGameObject);
     if (pItem) {
         *ptr=pItem;
         return SWIGTYPE_p_rl__Item;

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-07-31 11:09:51 UTC (rev 3650)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-07-31 16:51:43 UTC (rev 3651)
@@ -137,11 +137,11 @@
 %{
 static swig_type_info *ControlState_dynamic_cast(void **ptr)
 {
-    rl::ControlState **ppControlState =
-        reinterpret_cast<rl::ControlState**>(ptr);
+    rl::ControlState *pControlState =
+        static_cast<rl::ControlState*>(*ptr);
 
     rl::CutsceneControlState *pCutSceneCS =
-        dynamic_cast<rl::CutsceneControlState*>(*ppControlState);
+        dynamic_cast<rl::CutsceneControlState*>(pControlState);
     if (pCutSceneCS != NULL) {
         *ptr=pCutSceneCS;
         return SWIGTYPE_p_rl__CutsceneControlState;



From blakharaz at mail.berlios.de  Tue Jul 31 18:53:11 2007
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 31 Jul 2007 18:53:11 +0200
Subject: [Dsa-hl-svn] r3652 - rl/trunk/engine/core/src
Message-ID: <200707311653.l6VGrB1S017234@sheep.berlios.de>

Author: blakharaz
Date: 2007-07-31 18:53:07 +0200 (Tue, 31 Jul 2007)
New Revision: 3652

Modified:
   rl/trunk/engine/core/src/MeshObject.cpp
Log:
Missing animation should cause a warning instead of an error

Modified: rl/trunk/engine/core/src/MeshObject.cpp
===================================================================
--- rl/trunk/engine/core/src/MeshObject.cpp	2007-07-31 16:51:43 UTC (rev 3651)
+++ rl/trunk/engine/core/src/MeshObject.cpp	2007-07-31 16:53:07 UTC (rev 3652)
@@ -110,7 +110,6 @@
         return animStates->hasAnimationState(animName);
     }
 
-	/// @todo Exception Handling
 	MeshAnimation* MeshObject::getAnimation(const String& animName)
 	{
         AnimationState* animState = 0;
@@ -119,17 +118,26 @@
 		{
 			animState = getEntity()->getAnimationState(animName);
 		}
-		catch(Ogre::Exception&)
-		{
-            Throw(IllegalArgumentException,
-                animName + " is not a valid AnimationState of " + mMeshName + ".");
-		}
+        catch(Ogre::ItemIdentityException&)
+        {
+			LOG_WARNING(Logger::CORE,
+               mMeshName + " has no animation " + animName + ".");
+			return NULL;
+        }
+        catch(Ogre::Exception&)
+        {
+			LOG_ERROR(Logger::CORE,
+               animName + " is not a valid AnimationState of " + mMeshName + ".");
+			return NULL;
+        }
 
-        MeshAnimation* anim = NULL;
-		anim = dynamic_cast<MeshAnimation*>
+		MeshAnimation* anim = dynamic_cast<MeshAnimation*>
             (AnimationManager::getSingleton().getAnimation(animState));
-        if( anim == NULL )
-            anim = AnimationManager::getSingleton().addMeshAnimation(animState,this,1.0,0,true);
+        if (!anim)
+        {
+            anim = AnimationManager::getSingleton().addMeshAnimation(
+                animState,this,1.0,0,true);
+        }
 
 		return anim;
 	}
@@ -143,10 +151,16 @@
         {
             animState = getEntity()->getAnimationState(animName);
         }
+        catch(Ogre::ItemIdentityException&)
+        {
+			LOG_WARNING(Logger::CORE,
+               mMeshName + " has no animation " + animName + ".");
+			return NULL;
+        }
         catch(Ogre::Exception&)
         {
 			LOG_ERROR(Logger::CORE,
-                animName + " is not a valid AnimationState of " + mMeshName + ".");
+               animName + " is not a valid AnimationState of " + mMeshName + ".");
 			return NULL;
         }
 
@@ -168,11 +182,16 @@
 		{
 			animState = getEntity()->getAnimationState(animName);
 		}
-		catch(Ogre::Exception&)
-		{
-            Throw(IllegalArgumentException,
-                animName + " is not a valid AnimationState of " + mMeshName + ".");
-		}
+        catch(Ogre::ItemIdentityException&)
+        {
+			LOG_WARNING(Logger::CORE,
+               mMeshName + " has no animation " + animName + ".");
+        }
+        catch(Ogre::Exception&)
+        {
+			LOG_ERROR(Logger::CORE,
+               animName + " is not a valid AnimationState of " + mMeshName + ".");
+        }
 		AnimationManager::getSingleton().removeAnimation(animState);
 	}
 



