From melven at mail.berlios.de  Mon Feb  2 01:02:17 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 2 Feb 2009 01:02:17 +0100
Subject: [Dsa-hl-svn] r4732 - in dependencies/OgreNewt_ngt: inc src
Message-ID: <200902020002.n1202HBa008242@sheep.berlios.de>

Author: melven
Date: 2009-02-02 01:02:13 +0100 (Mon, 02 Feb 2009)
New Revision: 4732

Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_World.h
   dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp
Log:
-copied some changes that looked nice from a guy from ogre (zero23)
-updated the comments about changes in OgreNewt.h


Modified: dependencies/OgreNewt_ngt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt.h	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt.h	2009-02-02 00:02:13 UTC (rev 4732)
@@ -8,11 +8,11 @@
 
 	main header file.
 
-	current version:  0.20
+	current version:  2.00  ( I only raised the version number to indicate that this is for Newton2.0! )
 
-		Newton version: 2.0
+		Newton version: 2.0 beta (31.01.2009)
 
-		Ogre version: Eihort (1.4.x)
+		Ogre version: Shoggoth (1.6.x)
 
 */
 
@@ -42,15 +42,49 @@
 
 #include "OgreNewt_BasicFrameListener.h"
 
-/*! \mainpage OgreNewt Library version 0.11
+/*! \mainpage OgreNewt Library version 2.00
 
 	\section into_sec Introduction
 
 	OgreNewt is an OOP wrapper for integrating the Newton Dynamics Physics SDK with OGRE.
 
-	\section new New in this Version
+    \section problems Problems and missing features in this version
 
-	New in this version!
+    Problems and missing features in this version
+        - PlayerController not finished
+        - only one world is possible, the Debugger and Body
+        - this library supports the newton functions for multithreading but there are several functions/classes in this
+          library itself, that are not thread safe (I don't need multiple threads)
+        - the copied MovableText class (in Tools::OgreAddons) seems to have some graphics error (it's used
+          to show the debugging information above each body)
+        - I didn't test several features:
+            - vehicle
+            - joints
+            - collsions-serializer
+        - the treecollision raycastcallback doesn't work (see comments in the TreeCollision-class!)
+        - shared pointers for collisions (atm CollisionPtr := Collision*, but should be Ogre::SharedPtr<Collision>, but there was some problem...)
+
+
+	\section new New in this version
+
+    New in this version
+        - this version uses cmake > 2.6.2!
+        - several interface-breaking changes:
+            - the ContactCallback passes a ContactJoint as argument that can be used to iterate through all contacts
+              (the callback is not called for each contact any more, but for each pair of colliding bodies!)
+            - added a lots of new simple "iterators":
+                - for Bodies use body = World->getFirstBody() and body = body->getNext()
+                - for the 
+            - BodyIterator renamed to BodyInAABBIterator, it does now only iterate throuch bodies in a specific AABB
+        - added support for trigger-volumes (ConvexCollision::setAsTriggerVolume ...)
+        - added support for convexcasts
+        - added additional debugging features:
+            - raycast/convexcast debugging
+            - information about each body as billboard above it
+        - a lot of minor changes and functions added and renamed
+
+
+	previous changes...
 		- updated to Newton version 2.0!!  Many big improvements and changes to the library, and OgreNewt now supports it.
 		- several interface-breaking changes:
 			- updated to support multithreading support now native to Newton.
@@ -59,7 +93,6 @@
 			- Body::attachToNode has been renamed to attachNode, better implying the relationship between the body and the Ogre::Node.
 			- BodyIterator class has been upgraded to use boost::function, allowing the same callback flexibility as other callbacks.
 
-	previous changes...
 		- bug fix - fixed problem with TreeCollisionSceneParser that wasn't adjusting to different scales properly.
 		- optimization - fixed several classes to only write debug data to the LOG when compiled in DEBUG mode:
 			- Custom2DJonit

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h	2009-02-02 00:02:13 UTC (rev 4732)
@@ -14,6 +14,7 @@
 
 #include "OgreNewt_Prerequisites.h"
 #include "OgreNewt_World.h"
+#include "OgreNewt_CollisionSerializer.h"
 
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
@@ -21,6 +22,23 @@
 
 class World;
 
+enum _OgreNewtExport CollisionPrimitive
+{
+	BoxPrimitive				=	SERIALIZE_ID_BOX,
+	ConePrimitive				=	SERIALIZE_ID_CONE,
+	EllipsoidPrimitive			=	SERIALIZE_ID_SPHERE,
+	CapsulePrimitive			=	SERIALIZE_ID_CAPSULE,
+	CylinderPrimitive			=	SERIALIZE_ID_CYLINDER,
+	CompoundCollisionPrimitive	=	SERIALIZE_ID_COMPOUND,
+	ConvexHullPrimitive			=	SERIALIZE_ID_CONVEXHULL,
+	ConvexHullModifierPrimitive	=	SERIALIZE_ID_CONVEXMODIFIER,
+	ChamferCylinderPrimitive	=	SERIALIZE_ID_CHAMFERCYLINDER,
+	TreeCollisionPrimitive		=	SERIALIZE_ID_TREE,
+	NullPrimitive				=	SERIALIZE_ID_NULL,
+	HeighFieldPrimitive			=	SERIALIZE_ID_HEIGHTFIELD,
+	ScenePrimitive				=	SERIALIZE_ID_SCENE
+};
+
 /*
 	CLASS DEFINITION:
 
@@ -68,15 +86,26 @@
 	//! get the Axis-Aligned Bounding Box for this collision shape.
 	Ogre::AxisAlignedBox getAABB( const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO ) const;
 
+	//! Returns the Collisiontype for this Collision
+	CollisionPrimitive getCollisionPrimitiveType() const { return getCollisionPrimitiveType( m_col ); } 
 
+	//! Returns the Collisiontype for the given Newton-Collision
+	static CollisionPrimitive getCollisionPrimitiveType(const NewtonCollision *col);
+
+	//! friend functions for the Serializer
+	friend void CollisionSerializer::exportCollision(const Collision* collision, const Ogre::String& filename);
+	friend void CollisionSerializer::importCollision(Ogre::DataStreamPtr& stream, Collision* pDest);
+
 protected:
 
 	NewtonCollision* m_col;
 	const World* m_world;
-        friend class CollisionSerializer;
 
 };
 
+//typedef Ogre::SharedPtr<Collision> CollisionPtr;
+typedef Collision* CollisionPtr;
+
 //! represents a collision shape that is explicitly convex.
 class _OgreNewtExport ConvexCollision : public Collision
 {
@@ -104,8 +133,6 @@
         void setAsTriggerVolume(bool trigger) { NewtonCollisionSetAsTriggerVolume(m_col, (int)trigger); }
 };
 
-//typedef Ogre::SharedPtr<Collision> CollisionPtr;
-typedef Collision* CollisionPtr;
 
 
 //! represents a scalable collision shape.

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h	2009-02-02 00:02:13 UTC (rev 4732)
@@ -44,6 +44,13 @@
 		public:
 			//! constructor
 			/*!
+				Create a 'blank' box collision object.  Can be used for CollisionSerializer::importCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			Box(const World* world);
+
+			//! constructor
+			/*!
 				\param world pointer to OgreNewt::World
 				\param size vector representing width, height, depth
 				\param orient orientation offset of the primitive
@@ -62,6 +69,13 @@
 		public:
 			//! constructor
 			/*!
+				Create a 'blank' ellipsoid collision object. Can be used for CollisionSerializer::importCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			Ellipsoid(const World* world);
+
+			//! constructor
+			/*!
 				for a sphere, pass the same radius for all 3 axis.
 				\param world pointer to OgreNewt::World
 				\param size vector representing radius for all 3 axis
@@ -81,6 +95,13 @@
 		public:
 			//! constructor
 			/*!
+				Create a 'blank' cylinder collision object. Can be used for CollisionSerializer::importCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			Cylinder(const World* world);
+
+			//! constructor
+			/*!
 				default aligned along the local X axis (x=height).
 				\param world pointer to OgreNewt::World
 				\param radius radius of the cylinder (Y and Z axis)
@@ -101,6 +122,13 @@
 		public:
 			//! constructor
 			/*!
+				Create a 'blank' capsule collision object. Can be used for CollisionSerializer::importCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			Capsule(const World* world);
+
+			//! constructor
+			/*!
 				default aligned along the local X axis (x=height).
 				\param world pointer to OgreNewt::World
 				\param radius radius of the capsule (Y and Z axis)
@@ -121,6 +149,13 @@
 		public:
 			//! constructor
 			/*!
+				Create a 'blank' cone collision object. Can be used for CollisionSerializer::importCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			Cone(const World* world);
+
+			//! constructor
+			/*!
 				default aligned along the local X axis (x=height).
 				\param world pointer to OgreNewt::World
 				\param radius radius of the cone (Y and Z axis)
@@ -141,6 +176,13 @@
 		public:
 			//! constructor
 			/*!
+				Create a 'blank' chamferycylinder collision object. Can be used for CollisionSerializer::importCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			ChamferCylinder(const World* world);
+
+			//! constructor
+			/*!
 				default aligned along the local X axis (x=height).
 				\param world pointer to OgreNewt::World
 				\param radius radius of the chamfer cylinder (Y and Z axis)
@@ -164,6 +206,13 @@
 		public:
 			//! constructor
 			/*!
+				Create a 'blank' convexhull collision object. Can be used for CollisionSerializer::importCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			ConvexHull(const World* world);
+
+			//! constructor
+			/*!
 				Overloaded constructor.  pass a SceneNode*, and it will use the vertex data from the first attached object.
 				\param world pointer to the OgreNewt::World
 				\param node pointer to an Ogre::SceneNode with a single entity attached
@@ -255,12 +304,28 @@
 			void addPoly( Ogre::Vector3* polys, unsigned int ID );
 
 			//! finish the tree collision
-			void finish( bool optimize = true );
+			void finish( bool optimize );
 
+			//! set RayCastCallback active/disabled
+			/*!
+                THIS IS NOT WORKING AT THE MOMENT:
+                the code is based on an assumption about the order newton processes bodies in a raycast, I want to check this first,
+                so I commented the necessary code out.
+				If this Callback is active and a Ray hit this TreeCollision, the data of the hits will be given to the OgreNewt::RayCast function usercallback
+				\param active true = Callback active; false = Callback disabled 
+			*/
+			void setRayCastCallbackactive(bool active = true)
+			{
+				setRayCastCallbackactive( active, m_col );
+			}
+
         private:
-            static float _CDECL rayHitCallback(float interception, float *normal, int faceId, void *userData);
-		};
+			static void setRayCastCallbackactive( bool active , const NewtonCollision *col );
 
+			static float _CDECL newtonRayCastCallback(float distance, float* normal, int faceId, void* userData);
+
+        };
+
 		////////////////////////////////////////////////////////
 		//! TreeCollision created by parsing a tree of SceneNodes, adding collision data of all meshes.
 		/*!
@@ -278,7 +343,7 @@
 			~TreeCollisionSceneParser() {}
 
 			//! parse the scene.
-			void parseScene( Ogre::SceneNode* startNode, bool optimize = false, FaceWinding fw = FW_DEFAULT );
+			void parseScene( Ogre::SceneNode* startNode, bool optimize = true, FaceWinding fw = FW_DEFAULT );
 
 		protected:
 
@@ -309,6 +374,13 @@
 		public:
 			//! constructor
 			/*!
+			Create a 'blank' ellipsoid compoundcollision object. Can be used for CollisionSerializer::importCollision
+			\param world pointer to the OgreNewt::World
+			*/
+			CompoundCollision(const World* world);
+
+			//! constructor
+			/*!
 				creates a compound collision object made from an array of simple primitive parts.  can be used to make very complex
 				collision shapes.
 				\param world pointer to the OgreNewt::World
@@ -335,6 +407,13 @@
 		public:
 			//! constructor
 			/*!
+			Create a 'blank' ellipsoid collision object. Can be used for CollisionSerializer::importCollision
+			\param world pointer to the OgreNewt::World
+			*/
+			Pyramid(const World* world);
+
+			//! constructor
+			/*!
 				\param world pointer to the OgreNewt::World
 				\param size Ogre::Vector3 size.
 				\param orient orientation offset of the primitive

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h	2009-02-02 00:02:13 UTC (rev 4732)
@@ -36,7 +36,7 @@
     virtual ~CollisionSerializer();
 
     /*!
-    Serialize the TreeCollision to a file with the given name.
+    Serialize the Collision to a file with the given name.
     */
 	void exportCollision(const Collision* collision, const Ogre::String& filename);
 
@@ -54,7 +54,7 @@
     static void _CDECL _newtonSerializeCallback(void* serializeHandle, const void* buffer, int size);
 
     /*!
-    Callback function for Newton. It should never be called directly, but will be called by Newton to load the TreeCollision from a stream.
+    Callback function for Newton. It should never be called directly, but will be called by Newton to load the Collision from a stream.
     (Newton calls this function several times for each deserialization, once for each chunk of its file format apparently)
     */
     static void _CDECL _newtonDeserializeCallback(void* deserializeHandle, void* buffer, int size);

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-02-02 00:02:13 UTC (rev 4732)
@@ -62,8 +62,15 @@
 		return false and the callback will call for any other bodies, even those farther than the current one.
 	*/
 	virtual bool userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID ) = 0;
+/*
+	friend float CollisionPrimitives::TreeCollision::newtonRayCastCallback(float distance, float *normal, int faceId, void *userData);
+protected:
+	//! save the last OgreNewt::Body from the newtonRaycastPreFilter to use this for example the TreeCollisionRayCallback
+	OgreNewt::Body *m_treecollisionhack_lastbody;
 
-
+	//! save if this body was already added by RayCastCallback from TreeCollision
+	bool m_treecollisionhack_bodyalreadyadded;
+*/
 private:
 
 	//! callback used for running the raycast itself... used internally

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_World.h	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_World.h	2009-02-02 00:02:13 UTC (rev 4732)
@@ -170,6 +170,11 @@
 	*/
 	void setWorldSize( const Ogre::AxisAlignedBox& box );
 
+	/*!
+		get the world limits.
+	*/
+	Ogre::AxisAlignedBox getWorldSize() { return m_limits; }
+
 	//! get the Newton SDK version.
 	int getVersion() const { return NewtonWorldGetVersion( m_world ); }
 
@@ -183,6 +188,9 @@
 		setLeaveWorldCallback( boost::bind(callback, instancedClassPointer, _1, _2) );
 	}
 
+
+	//! updates only the collision of the world and call the callback functions if necessary, can be used for an collision only system
+	void CollisionUpdate() { NewtonCollisionUpdate( m_world ); }
     //! to iterate through all bodies call this function and then use body->getNext()
     Body* getFirstBody();
 
@@ -204,6 +212,7 @@
 
 	static void _CDECL newtonLeaveWorld( const NewtonBody* body, int threadIndex );
 
+	Ogre::AxisAlignedBox m_limits;
 };
 
 }

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp	2009-02-02 00:02:13 UTC (rev 4732)
@@ -34,8 +34,17 @@
 	return box;
 }
 
+CollisionPrimitive Collision::getCollisionPrimitiveType(const NewtonCollision *col)
+{
+	NewtonCollisionInfoRecord *info = new NewtonCollisionInfoRecord();
 
+	NewtonCollisionGetInfo( col, info );
 
+	return static_cast<CollisionPrimitive>(info->m_collisionType);
+}
+
+
+
 ConvexCollision::ConvexCollision( const OgreNewt::World* world ) : Collision( world )
 {
 }

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-02-02 00:02:13 UTC (rev 4732)
@@ -19,6 +19,9 @@
 
 
 		// OgreNewt::CollisionPrimitives::Box
+		Box::Box(const World* world) : ConvexCollision( world )
+		{}
+
 		Box::Box( const World* world, const Ogre::Vector3& size, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
 			float matrix[16];
@@ -33,6 +36,9 @@
 
 
 		// OgreNewt::CollisionPrimitives::Ellipsoid
+		Ellipsoid::Ellipsoid(const World* world) : ConvexCollision( world )
+		{}
+
 		Ellipsoid::Ellipsoid( const World* world, const Ogre::Vector3& size, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
 			float matrix[16];
@@ -46,6 +52,9 @@
 
 
 		// OgreNewt::CollisionPrimitives::Cylinder
+		Cylinder::Cylinder(const World* world) : ConvexCollision( world )
+		{}
+
 		Cylinder::Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
 									const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
@@ -60,6 +69,9 @@
 
 
 		// OgreNewt::CollisionPrimitives::Capsule
+		Capsule::Capsule(const World* world) : ConvexCollision( world )
+		{}
+
 		Capsule::Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
 									const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
@@ -74,6 +86,9 @@
 
 
 		// OgreNewt::CollisionPrimitives::Cone
+		Cone::Cone(const World* world) : ConvexCollision( world )
+		{}
+
 		Cone::Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
 									const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
@@ -87,6 +102,9 @@
 		}
 
 		// OgreNewt::CollisionPrimitives::ChamferCylinder
+		ChamferCylinder::ChamferCylinder(const World* world) : ConvexCollision( world )
+		{}
+
 		ChamferCylinder::ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
 									const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
@@ -102,6 +120,9 @@
 
 		
 		// OgreNewt::CollisionPrimitives::ConvexHull
+		ConvexHull::ConvexHull(const World* world) : ConvexCollision( world )
+		{}
+
 		ConvexHull::ConvexHull( const World* world, Ogre::Entity* obj, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
 			Ogre::Vector3 scale(1.0,1.0,1.0);
@@ -496,19 +517,41 @@
 			NewtonTreeCollisionAddFace( m_col, 3, (float*)&polys[0].x, sizeof(Ogre::Vector3), ID );
 		}
 
-		void TreeCollision::finish( bool optimize)
+		void TreeCollision::finish( bool optimize )
 		{
 			NewtonTreeCollisionEndBuild( m_col, optimize );
 
             NewtonAddCollisionReference(m_col);
-            NewtonTreeCollisionSetUserRayCastCallback( m_col, rayHitCallback );
-		}
+        }
 
-        float TreeCollision::rayHitCallback(float interception, float *normal, int faceId, void *userData)
+
+        float _CDECL TreeCollision::newtonRayCastCallback(float interception, float *normal, int faceId, void *userData)
         {
             return interception;
+
+            // the following code is only based on the assumption about the order newton processes bodies in a raycast!
+            /*
+			Body* bod = ((Raycast*)userData)->m_lastbody;
+			
+            //! TODO: what do we need to return here?
+			if(!bod)
+				return 0;
+
+			((Raycast*)userData)->userCallback( bod, distance, Ogre::Vector3(normal[0], normal[1], normal[2]), faceId );
+
+			((Raycast*)userData)->bodyalreadyadded = true;
+
+			return distance;
+            */
         }
 
+		void TreeCollision::setRayCastCallbackactive(bool active, const NewtonCollision *col )
+		{
+			if(active)
+				NewtonTreeCollisionSetUserRayCastCallback( col, newtonRayCastCallback );
+			else
+				NewtonTreeCollisionSetUserRayCastCallback( col, NULL );
+		}
 
 		int TreeCollisionSceneParser::count = 0;
 		
@@ -688,6 +731,9 @@
 
 
 		// OgreNewt::CollisionPrimitives::CompoundCollision
+		CompoundCollision::CompoundCollision(const World* world) : Collision( world )
+		{}
+		
 		CompoundCollision::CompoundCollision( const World* world, std::vector<OgreNewt::Collision*> col_array ) : Collision( world )
 		{
 			//get the number of elements.
@@ -711,6 +757,9 @@
 
 		
 		// OgreNewt::CollisionPrimitives::Pyramid
+		Pyramid::Pyramid(const World* world) : ConvexCollision( world )
+		{}
+
 		Pyramid::Pyramid( const World* world, const Ogre::Vector3& size, const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) : ConvexCollision( world )
 		{
 			float matrix[16];

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-02-02 00:02:13 UTC (rev 4732)
@@ -17,33 +17,53 @@
 
   void CollisionSerializer::exportCollision(const Collision* collision, const Ogre::String& filename)
   {
-    mpfFile=fopen(filename.c_str(),"wb");
-    if (!mpfFile)
+    if( collision )
     {
-      OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, "Unable to open file " + filename + " for writing","CollisionSerializer::exportTreeCollision");
+        mpfFile=fopen(filename.c_str(),"wb");
+    
+        if (!mpfFile)
+        {
+          OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, "Unable to open file " + filename + " for writing","CollisionSerializer::exportCollision");
+        }
+    
+        NewtonCollisionSerialize(collision->getWorld()->getNewtonWorld(), collision->m_col, &CollisionSerializer::_newtonSerializeCallback, this);
+
+        fclose(mpfFile);
     }
-    NewtonCollisionSerialize(collision->getWorld()->getNewtonWorld(), collision->getNewtonCollision(), &CollisionSerializer::_newtonSerializeCallback, this);
   }
 
 
   void CollisionSerializer::importCollision(Ogre::DataStreamPtr& stream, Collision* pDest)
   {
-    NewtonCollision* col = NewtonCreateCollisionFromSerialization(pDest->getWorld()->getNewtonWorld(), &CollisionSerializer::_newtonDeserializeCallback, &stream);
-    pDest->m_col=col;
+    if( pDest )
+    {
+        if( pDest->m_col )
+        {
+            // we need an error here!!
+            NewtonReleaseCollision(pDest->m_world->getNewtonWorld(), pDest->m_col);
+        }
+
+        NewtonCollision* col = NewtonCreateCollisionFromSerialization(pDest->getWorld()->getNewtonWorld(), &CollisionSerializer::_newtonDeserializeCallback, &stream);
+
+        pDest->m_col = col;
+        // this is a bit nasty, but we need to add a reference for the collision, there should be no problems,
+        // if the OgreNewt-functions are used and the newton-collisions are not accessed directly in any way
+        NewtonAddCollisionReference(pDest->m_col);
+    }
   }
 
 
   void CollisionSerializer::_newtonSerializeCallback(void* serializeHandle, const void* buffer, int size)
   {
-    CollisionSerializer* me=(static_cast<CollisionSerializer*>(serializeHandle));
-    me->writeData(buffer,1,size);
+    CollisionSerializer* me = (static_cast<CollisionSerializer*>(serializeHandle));
+    me->writeData(buffer, 1, size);
   }
 
 
   void CollisionSerializer::_newtonDeserializeCallback(void* deserializeHandle, void* buffer, int size)
   {
-    Ogre::DataStreamPtr ptr=*(static_cast<Ogre::DataStreamPtr*>(deserializeHandle));
-    ptr->read(buffer,size);
+    Ogre::DataStreamPtr ptr =* (static_cast<Ogre::DataStreamPtr*>(deserializeHandle));
+    ptr->read(buffer, size);
   }
 }	// end namespace OgreNewt
 

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp	2009-01-31 02:01:11 UTC (rev 4731)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp	2009-02-02 00:02:13 UTC (rev 4732)
@@ -9,6 +9,8 @@
 // Constructor
 World::World()
 {
+	m_limits = Ogre::AxisAlignedBox(Ogre::Vector3(-100,-100,-100), Ogre::Vector3(100,100,100));
+
 	m_world = NewtonCreate( NULL, NULL );
 
 	if (!m_world)
@@ -43,11 +45,13 @@
 void World::setWorldSize( const Ogre::Vector3& min, const Ogre::Vector3& max )
 {
 	NewtonSetWorldSize( m_world, (float*)&min.x, (float*)&max.x );
+	m_limits = Ogre::AxisAlignedBox(min, max);
 }
 
 void World::setWorldSize( const Ogre::AxisAlignedBox& box )
 {
 	NewtonSetWorldSize( m_world, (float*)&box.getMinimum(), (float*)&box.getMaximum() );
+	m_limits = box;
 }
 
 void World::setLeaveWorldCallback( LeaveWorldCallback callback )



From timm at mail.berlios.de  Tue Feb  3 22:51:05 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 3 Feb 2009 22:51:05 +0100
Subject: [Dsa-hl-svn] r4733 - in rl/branches/persistence: common/include
	common/src core/include core/src
Message-ID: <200902032151.n13Lp5xc014606@sheep.berlios.de>

Author: timm
Date: 2009-02-03 22:50:57 +0100 (Tue, 03 Feb 2009)
New Revision: 4733

Modified:
   rl/branches/persistence/common/include/WriteableDataStream.h
   rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp
   rl/branches/persistence/core/include/SaveGameManager.h
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/core/src/SaveGameManager.cpp
Log:
a few changes for testing

Modified: rl/branches/persistence/common/include/WriteableDataStream.h
===================================================================
--- rl/branches/persistence/common/include/WriteableDataStream.h	2009-02-02 00:02:13 UTC (rev 4732)
+++ rl/branches/persistence/common/include/WriteableDataStream.h	2009-02-03 21:50:57 UTC (rev 4733)
@@ -28,8 +28,8 @@
     public:
 		WriteableDataStream() : Ogre::DataStream() {}
 		WriteableDataStream(const Ogre::String &name) : Ogre::DataStream(name) {}
-        virtual void write(void* buf, size_t count) = 0;
-        virtual void flush() = 0;
+        virtual void write(void* buf, size_t count) {}
+        virtual void flush() {}
     };
 
     typedef Ogre::SharedPtr<WriteableDataStream> WriteableDataStreamPtr;

Modified: rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp	2009-02-02 00:02:13 UTC (rev 4732)
+++ rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp	2009-02-03 21:50:57 UTC (rev 4733)
@@ -89,7 +89,7 @@
         }
 
         /// Construct return stream, tell it to delete on destroy
-        WriteableFileStreamDataStream* stream = new WriteableFileStreamDataStream(filename,
+        WriteableFileStreamDataStream* stream = OGRE_NEW WriteableFileStreamDataStream(filename,
             origStream, true);
         return DataStreamPtr(stream);
     }

Modified: rl/branches/persistence/core/include/SaveGameManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveGameManager.h	2009-02-02 00:02:13 UTC (rev 4732)
+++ rl/branches/persistence/core/include/SaveGameManager.h	2009-02-03 21:50:57 UTC (rev 4733)
@@ -67,7 +67,7 @@
         void freeSaveGameMap();
 
         Ogre::StringVector mScriptPatterns;
-        SaveGameEntryMap mSaveGames;
+        //SaveGameEntryMap mSaveGames;
 
         SaveGameDataOrderMap mSaveGameDataOrderMap;
 

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2009-02-02 00:02:13 UTC (rev 4732)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2009-02-03 21:50:57 UTC (rev 4733)
@@ -65,7 +65,7 @@
 	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
 	{
 		LOG_MESSAGE(Logger::CORE, "Parsing headers of save game file: " + stream->getName() + " Resource group: " + groupName);
-		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),(WriteableDataStreamPtr)static_cast<WriteableFileStreamDataStream*>(stream.get()));
+		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),(WriteableDataStreamPtr)static_cast<WriteableDataStream*>(stream.get()));
 		mReader.parseSaveGameFileHeader(file);
 		mHighestSaveGameNumber = Ogre::StringConverter::parseInt(stream->getName()) > mHighestSaveGameNumber ? Ogre::StringConverter::parseInt(stream->getName()) : mHighestSaveGameNumber;
 		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = file;

Modified: rl/branches/persistence/core/src/SaveGameManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameManager.cpp	2009-02-02 00:02:13 UTC (rev 4732)
+++ rl/branches/persistence/core/src/SaveGameManager.cpp	2009-02-03 21:50:57 UTC (rev 4733)
@@ -74,12 +74,12 @@
 
     SaveGameEntryMap SaveGameManager::listSaveGames()
     {
-        return mSaveGames;
+        return SaveGameEntryMap();//mSaveGames;
     }
 
     SaveGameEntryMap SaveGameManager::listSaveGames(const CeGuiString &moduleId)
     {
-        SaveGameEntryMap entries;
+        /*SaveGameEntryMap entries;
         for(SaveGameEntryMap::const_iterator iter = mSaveGames.begin(); iter != mSaveGames.end(); iter++)
         {
             if(iter->second->getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
@@ -87,7 +87,8 @@
                 entries[iter->first] = iter->second;
             }
         }
-        return entries;
+        return entries;*/
+        return SaveGameEntryMap();
     }
 
     void SaveGameManager::saveSaveGameFile(const CeGuiString &name)
@@ -149,7 +150,7 @@
 
     void SaveGameManager::loadSaveGameFile(int id)
     {
-        if(mSaveGames.find(id) != mSaveGames.end())
+        /*if(mSaveGames.find(id) != mSaveGames.end())
         {
             MessagePump::getSingleton().sendMessage<MessageType_SaveGameLoading>();
 
@@ -162,64 +163,65 @@
             ///@todo: SaveGameReader
 
             MessagePump::getSingleton().sendMessage<MessageType_SaveGameLoaded>();
-        }
+        }*/
     }
 
     void SaveGameManager::deleteSaveGameFile(const CeGuiString &name, const CeGuiString &moduleId)
     {
-        if(SaveGameFileExists(name, moduleId))
+        /*if(SaveGameFileExists(name, moduleId))
         {
             int id = getSaveGameId(name, moduleId);
             static_cast<SaveGameFile*>(mSaveGames[id])->deleteFileFromStorage();
             delete mSaveGames[id];
             mSaveGames.erase(id);
-        }
+        }*/
     }
 
     void SaveGameManager::deleteSaveGameFile(int id)
     {
-        if(mSaveGames.find(id) == mSaveGames.end())
+        /*if(mSaveGames.find(id) == mSaveGames.end())
         {
             static_cast<SaveGameFile*>(mSaveGames[id])->deleteFileFromStorage();
             delete mSaveGames[id];
             mSaveGames.erase(id);
-        }
+        }*/
     }
 
     bool SaveGameManager::SaveGameFileExists(const CeGuiString &name, const CeGuiString &moduleId)
     {
-        bool saveGameFileExists = false;
+        /*bool saveGameFileExists = false;
         for(SaveGameEntryMap::const_iterator it = mSaveGames.begin(); it != mSaveGames.end() && !saveGameFileExists; ++it)
         {
             if(it->second->getProperty(SaveGameFile::PROPERTY_NAME).toString() == name 
                 && it->second->getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
                 saveGameFileExists = true;
         }
-        return saveGameFileExists;
+        return saveGameFileExists;*/
+        return false;
     }
 
     SaveGameFile* SaveGameManager::getSaveGameFile(const CeGuiString &name, const CeGuiString &moduleId)
     {
-        if(SaveGameFileExists(name, moduleId))
-            return mSaveGames[getSaveGameId(name, moduleId)];
+       /* if(SaveGameFileExists(name, moduleId))
+            return mSaveGames[getSaveGameId(name, moduleId)];*/
         return NULL;
     }
 
     SaveGameFile* SaveGameManager::getSaveGameFile(int id)
     {
-        if(mSaveGames.find(id) != mSaveGames.end())
-            return mSaveGames[id];
+        /*if(mSaveGames.find(id) != mSaveGames.end())
+            return mSaveGames[id];*/
         return NULL;
     }
 
     int SaveGameManager::getSaveGameId(const CeGuiString &name, const CeGuiString &moduleId)
     {
-        for(SaveGameEntryMap::const_iterator it = mSaveGames.begin(); it != mSaveGames.end(); ++it)
+        /*for(SaveGameEntryMap::const_iterator it = mSaveGames.begin(); it != mSaveGames.end(); ++it)
         {
             if(it->second->getProperty(SaveGameFile::PROPERTY_NAME).toString() == name 
                 && it->second->getProperty(SaveGameFile::PROPERTY_MODULEID).toString() == moduleId)
                 return it->first;
-        }
+        }*/
         return -1;
     }
     
@@ -281,11 +283,11 @@
 
     void SaveGameManager::freeSaveGameMap()
     {
-        for(SaveGameEntryMap::const_iterator iter = mSaveGames.begin(); iter != mSaveGames.end(); iter++)
+       /* for(SaveGameEntryMap::const_iterator iter = mSaveGames.begin(); iter != mSaveGames.end(); iter++)
         {
             delete iter->second;
         }
-        mSaveGames.clear();
+        mSaveGames.clear();*/
     }
 
     int SaveGameManager::getHighestSaveGameNumber()



From melven at mail.berlios.de  Wed Feb  4 17:57:16 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 4 Feb 2009 17:57:16 +0100
Subject: [Dsa-hl-svn] r4734 - in dependencies/OgreNewt_ngt: . inc src
Message-ID: <200902041657.n14GvGhY027406@sheep.berlios.de>

Author: melven
Date: 2009-02-04 17:57:13 +0100 (Wed, 04 Feb 2009)
New Revision: 4734

Added:
   dependencies/OgreNewt_ngt/INSTALL.TXT
Removed:
   dependencies/OgreNewt_ngt/OgreNewt_Main_vc9.vcproj
   dependencies/OgreNewt_ngt/OgreNewt_vc9.sln
Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
Log:
-removed some bugs
-added the possibility to get each intersection of a raycast with a treecollision
 (you can hit the same collision several times!)
-removed VC project files, you need to create them with cmake
-added a simple "INSTALL.TXT" file


Added: dependencies/OgreNewt_ngt/INSTALL.TXT
===================================================================
--- dependencies/OgreNewt_ngt/INSTALL.TXT	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/INSTALL.TXT	2009-02-04 16:57:13 UTC (rev 4734)
@@ -0,0 +1,21 @@
+To compile and install this library you need cmake > 2.6.2 (http://www.cmake.org/)
+
+On Windows:
+    install cmake and then use cmake to create project files for Visual Studio
+
+On *nix:
+    if you have installed cmake, you can do:
+    
+    mkdir build
+    cd build
+    cmake ..
+    make
+    
+    To install the library type (as root)
+
+    make install
+
+    or
+
+    sudo make install
+

Deleted: dependencies/OgreNewt_ngt/OgreNewt_Main_vc9.vcproj
===================================================================
--- dependencies/OgreNewt_ngt/OgreNewt_Main_vc9.vcproj	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/OgreNewt_Main_vc9.vcproj	2009-02-04 16:57:13 UTC (rev 4734)
@@ -1,336 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="OgreNewt_Main"
-	ProjectGUID="{DCC3C838-9803-497D-8C32-A5985644CCE9}"
-	RootNamespace="OgreNewt_Main"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="./lib/$(ConfigurationName)"
-			IntermediateDirectory="./obj/$(ConfigurationName)"
-			ConfigurationType="2"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			UseOfMFC="0"
-			UseOfATL="0"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories=".\inc;..\NewtonSDK\sdk;..\OgreSDK\include;..\boost\include"
-				PreprocessorDefinitions="_WINDOWS;WIN32;_DEBUG;_OGRENEWT_EXPORTS;_OGRENEWT_DYNAMIC"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="Newton.lib OgreMain_d.lib"
-				OutputFile="$(OutDir)/OgreNewt_d.dll"
-				AdditionalLibraryDirectories="..\NewtonSDK\sdk\dll_vs9;..\ogresdk\lib"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/OgreNewt_d.pdb"
-				SubSystem="2"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				ImportLibrary="$(OutDir)/OgreNewt_d.lib"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="./lib/$(ConfigurationName)"
-			IntermediateDirectory="./obj/$(ConfigurationName)"
-			ConfigurationType="2"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories=".\inc;..\NewtonSDK\sdk;..\OgreSDK\include;..\boost\include"
-				PreprocessorDefinitions="_WINDOWS;WIN32;NDEBUG;_OGRENEWT_EXPORTS;_OGRENEWT_DYNAMIC"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="Newton.lib OgreMain.lib"
-				OutputFile="$(OutDir)/OgreNewt.dll"
-				AdditionalLibraryDirectories="..\NewtonSDK\sdk\dll_vs9;..\ogresdk\lib"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				ImportLibrary="$(OutDir)/OgreNewt.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="src"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath=".\src\OgreNewt_BasicJoints.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_Body.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_Collision.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_CollisionPrimitives.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_CollisionSerializer.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_ContactCallback.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_Debugger.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_Joint.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_MaterialID.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_MaterialPair.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_RayCast.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_Tools.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_Vehicle.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\OgreNewt_World.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="header"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath=".\inc\OgreNewt.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_BasicJoints.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_Body.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_BodyIterator.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_Collision.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_CollisionPrimitives.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_CollisionSerializer.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_ContactCallback.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_Debugger.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_Joint.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_MaterialID.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_MaterialPair.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_Prerequisites.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_RayCast.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_Tools.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_Vehicle.h"
-				>
-			</File>
-			<File
-				RelativePath=".\inc\OgreNewt_World.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-		<Filter
-			Name="doc"
-			>
-			<File
-				RelativePath=".\DifferencesToOgreCVS.txt"
-				>
-			</File>
-			<File
-				RelativePath=".\README"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>

Deleted: dependencies/OgreNewt_ngt/OgreNewt_vc9.sln
===================================================================
--- dependencies/OgreNewt_ngt/OgreNewt_vc9.sln	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/OgreNewt_vc9.sln	2009-02-04 16:57:13 UTC (rev 4734)
@@ -1,19 +0,0 @@
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual C++ Express 2008
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OgreNewt_Main", "OgreNewt_Main_vc9.vcproj", "{DCC3C838-9803-497D-8C32-A5985644CCE9}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Release|Win32 = Release|Win32
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{DCC3C838-9803-497D-8C32-A5985644CCE9}.Debug|Win32.ActiveCfg = Debug|Win32
-		{DCC3C838-9803-497D-8C32-A5985644CCE9}.Debug|Win32.Build.0 = Debug|Win32
-		{DCC3C838-9803-497D-8C32-A5985644CCE9}.Release|Win32.ActiveCfg = Release|Win32
-		{DCC3C838-9803-497D-8C32-A5985644CCE9}.Release|Win32.Build.0 = Release|Win32
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h	2009-02-04 16:57:13 UTC (rev 4734)
@@ -18,6 +18,7 @@
 
 #include "OgreNewt_Prerequisites.h"
 #include "OgreNewt_MaterialID.h"
+#include "OgreNewt_Collision.h"
 #include <boost/function.hpp>
 #include <boost/bind.hpp>
 
@@ -28,7 +29,6 @@
 
 class World;
 class MaterialID;
-class Collision;
 
 /*
 	CLASS DEFINITION:
@@ -393,10 +393,20 @@
 	*/
 	void addLocalForce( const Ogre::Vector3& force, const Ogre::Vector3& pos );
 
-	
+    //! Returns the Collisiontype for the Collision from this Body
+    /*!
+     * usually it is also possible to get this via: body->getCollision()->getCollisionPrimitiveType()
+    */
+    CollisionPrimitive getCollisionPrimitiveType() const { return Collision::getCollisionPrimitiveType(getNewtonCollision()); }
 
- protected:
+    //! Returns the Newton Collision for this Body
+    /*!
+     * usually it is also possible to get this via: body->getCollision()
+    */
+    NewtonCollision *getNewtonCollision() const { return NewtonBodyGetCollision( m_body ); }
 
+protected:
+
 	NewtonBody*			m_body;
 	const Collision*	m_collision;
 	const MaterialID*	m_matid;

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionPrimitives.h	2009-02-04 16:57:13 UTC (rev 4734)
@@ -308,10 +308,6 @@
 
 			//! set RayCastCallback active/disabled
 			/*!
-                THIS IS NOT WORKING AT THE MOMENT:
-                the code is based on an assumption about the order newton processes bodies in a raycast, I want to check this first,
-                so I commented the necessary code out.
-				If this Callback is active and a Ray hit this TreeCollision, the data of the hits will be given to the OgreNewt::RayCast function usercallback
 				\param active true = Callback active; false = Callback disabled 
 			*/
 			void setRayCastCallbackactive(bool active = true)
@@ -319,11 +315,12 @@
 				setRayCastCallbackactive( active, m_col );
 			}
 
+            //! used internally
+			static float _CDECL newtonRayCastCallback(float distance, float* normal, int faceId, void* userData);
+
         private:
 			static void setRayCastCallbackactive( bool active , const NewtonCollision *col );
 
-			static float _CDECL newtonRayCastCallback(float distance, float* normal, int faceId, void* userData);
-
         };
 
 		////////////////////////////////////////////////////////

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-02-04 16:57:13 UTC (rev 4734)
@@ -14,6 +14,7 @@
 
 
 #include "OgreNewt_Prerequisites.h"
+#include "OgreNewt_CollisionPrimitives.h"
 
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
@@ -21,7 +22,6 @@
 
 class World;
 class Body;
-class Collision;
 
 //! general raycast
 /*!
@@ -62,15 +62,15 @@
 		return false and the callback will call for any other bodies, even those farther than the current one.
 	*/
 	virtual bool userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID ) = 0;
-/*
+
 	friend float CollisionPrimitives::TreeCollision::newtonRayCastCallback(float distance, float *normal, int faceId, void *userData);
 protected:
 	//! save the last OgreNewt::Body from the newtonRaycastPreFilter to use this for example the TreeCollisionRayCallback
-	OgreNewt::Body *m_treecollisionhack_lastbody;
+	OgreNewt::Body *m_treecollisioncallback_lastbody;
 
 	//! save if this body was already added by RayCastCallback from TreeCollision
-	bool m_treecollisionhack_bodyalreadyadded;
-*/
+	bool m_treecollisioncallback_bodyalreadyadded;
+
 private:
 
 	//! callback used for running the raycast itself... used internally

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Collision.cpp	2009-02-04 16:57:13 UTC (rev 4734)
@@ -58,7 +58,6 @@
 ConvexModifierCollision::ConvexModifierCollision(const World* world, const Collision* col) : Collision(world)
 {
 	m_col = NewtonCreateConvexHullModifier( world->getNewtonWorld(), col->getNewtonCollision() );
-    NewtonAddCollisionReference(m_col);
 }
 
 ConvexModifierCollision::~ConvexModifierCollision()

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-02-04 16:57:13 UTC (rev 4734)
@@ -1,5 +1,6 @@
 #include "OgreNewt_CollisionPrimitives.h"
 #include "OgreNewt_Tools.h"
+#include "OgreNewt_RayCast.h"
 
 #include "Ogre.h"
 
@@ -13,8 +14,6 @@
 		Null::Null(const OgreNewt::World *world) : Collision( world )
 		{
 			m_col = NewtonCreateNull( m_world->getNewtonWorld() );
-
-            NewtonAddCollisionReference(m_col);
 		}
 
 
@@ -29,8 +28,6 @@
 			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
 			m_col = NewtonCreateBox( m_world->getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &matrix[0] );
-
-            NewtonAddCollisionReference(m_col);
 		}
 
 
@@ -46,8 +43,6 @@
 			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
 			m_col = NewtonCreateSphere( m_world->getNewtonWorld(), (float)size.x, (float)size.y, (float)size.z, &matrix[0] );
-
-            NewtonAddCollisionReference(m_col);
 		}
 
 
@@ -63,8 +58,6 @@
 			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
 			m_col = NewtonCreateCylinder( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
-
-            NewtonAddCollisionReference(m_col);
 		}
 
 
@@ -80,8 +73,6 @@
 			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
 			m_col = NewtonCreateCapsule( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
-
-            NewtonAddCollisionReference(m_col);
 		}
 
 
@@ -97,8 +88,6 @@
 			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
 			m_col = NewtonCreateCone( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
-
-            NewtonAddCollisionReference(m_col);
 		}
 
 		// OgreNewt::CollisionPrimitives::ChamferCylinder
@@ -113,8 +102,6 @@
 			OgreNewt::Converters::QuatPosToMatrix( orient, pos, &matrix[0] );
 
 			m_col = NewtonCreateChamferCylinder( m_world->getNewtonWorld(), (float)radius, (float)height, &matrix[0] );
-
-            NewtonAddCollisionReference(m_col);
 		}
 
 
@@ -239,8 +226,6 @@
 			//okay, let's try making the ConvexHull!
 			m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), (int)total_verts, (float*)&vertices[0].x, sizeof(Ogre::Vector3), 0.001f, &matrix[0] );
 
-            NewtonAddCollisionReference(m_col);
-
 			delete []vertices;
 
 		}
@@ -254,9 +239,6 @@
 
 			//make the collision primitive.
 			m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), vertcount, (float*)&verts[0].x, sizeof(Ogre::Vector3), 0.001f, &matrix[0]);
-
-            NewtonAddCollisionReference(m_col);
-
 		}
 
 
@@ -520,29 +502,22 @@
 		void TreeCollision::finish( bool optimize )
 		{
 			NewtonTreeCollisionEndBuild( m_col, optimize );
-
-            NewtonAddCollisionReference(m_col);
         }
 
 
         float _CDECL TreeCollision::newtonRayCastCallback(float interception, float *normal, int faceId, void *userData)
         {
-            return interception;
-
-            // the following code is only based on the assumption about the order newton processes bodies in a raycast!
-            /*
-			Body* bod = ((Raycast*)userData)->m_lastbody;
+			Body* bod = ((Raycast*)userData)->m_treecollisioncallback_lastbody;
 			
             //! TODO: what do we need to return here?
 			if(!bod)
 				return 0;
 
-			((Raycast*)userData)->userCallback( bod, distance, Ogre::Vector3(normal[0], normal[1], normal[2]), faceId );
+			((Raycast*)userData)->userCallback( bod, interception, Ogre::Vector3(normal[0], normal[1], normal[2]), faceId );
 
-			((Raycast*)userData)->bodyalreadyadded = true;
+			((Raycast*)userData)->m_treecollisioncallback_bodyalreadyadded = true;
 
-			return distance;
-            */
+			return interception;
         }
 
 		void TreeCollision::setRayCastCallbackactive(bool active, const NewtonCollision *col )
@@ -749,10 +724,8 @@
 
 			m_col = NewtonCreateCompoundCollision( world->getNewtonWorld(), num, array );
 
-            NewtonAddCollisionReference(m_col);
 
 			delete[] array;
-
 		}
 
 		
@@ -791,10 +764,8 @@
 			//make the collision primitive.
 			m_col = NewtonCreateConvexHull( m_world->getNewtonWorld(), 5, vertices, sizeof(float)*3, 0.001f, &matrix[0]);
 
-            NewtonAddCollisionReference(m_col);
 
 			delete []vertices;
-
 		}
 
 

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-02-04 16:57:13 UTC (rev 4734)
@@ -46,9 +46,6 @@
         NewtonCollision* col = NewtonCreateCollisionFromSerialization(pDest->getWorld()->getNewtonWorld(), &CollisionSerializer::_newtonDeserializeCallback, &stream);
 
         pDest->m_col = col;
-        // this is a bit nasty, but we need to add a reference for the collision, there should be no problems,
-        // if the OgreNewt-functions are used and the newton-collisions are not accessed directly in any way
-        NewtonAddCollisionReference(pDest->m_col);
     }
   }
 

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-03 21:50:57 UTC (rev 4733)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-04 16:57:13 UTC (rev 4734)
@@ -19,8 +19,14 @@
         {
             Debugger::getSingleton().addRay(startpt, endpt);
         }
+
+        m_treecollisioncallback_lastbody = NULL;
+
 		// perform the raycast!
 		NewtonWorldRayCast( world->getNewtonWorld(), (float*)&startpt, (float*)&endpt, OgreNewt::Raycast::newtonRaycastFilter, this, OgreNewt::Raycast::newtonRaycastPreFilter );
+
+        m_treecollisioncallback_lastbody = NULL;
+
 	}
 
 	float _CDECL Raycast::newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersectParam)
@@ -32,6 +38,10 @@
 		Ogre::Vector3 normal = Ogre::Vector3( hitNormal[0], hitNormal[1], hitNormal[2] );
 
 
+        if( me->m_treecollisioncallback_bodyalreadyadded )
+            return intersectParam;
+
+
         if( Debugger::getSingleton().isRaycastRecording() && Debugger::getSingleton().isRaycastRecordingHitBodies() )
         {
             Debugger::getSingleton().addHitBody(bod);
@@ -52,6 +62,10 @@
 
 		Body* bod = (Body*)NewtonBodyGetUserData( body );
 
+
+        me->m_treecollisioncallback_bodyalreadyadded = false;
+        me->m_treecollisioncallback_lastbody = bod;
+
 		if (me->userPreFilterCallback( bod ))
 			return 1;
 		else



From melven at mail.berlios.de  Wed Feb  4 18:15:41 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 4 Feb 2009 18:15:41 +0100
Subject: [Dsa-hl-svn] r4735 - dependencies/OgreNewt_ngt/inc
Message-ID: <200902041715.n14HFf1p028906@sheep.berlios.de>

Author: melven
Date: 2009-02-04 18:15:39 +0100 (Wed, 04 Feb 2009)
New Revision: 4735

Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt.h
Log:
some comments


Modified: dependencies/OgreNewt_ngt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt.h	2009-02-04 16:57:13 UTC (rev 4734)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt.h	2009-02-04 17:15:39 UTC (rev 4735)
@@ -61,7 +61,7 @@
             - vehicle
             - joints
             - collsions-serializer
-        - the treecollision raycastcallback doesn't work (see comments in the TreeCollision-class!)
+            - treecollision raycastcallback 
         - shared pointers for collisions (atm CollisionPtr := Collision*, but should be Ogre::SharedPtr<Collision>, but there was some problem...)
 
 



From blakharaz at mail.berlios.de  Thu Feb  5 20:57:37 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 5 Feb 2009 20:57:37 +0100
Subject: [Dsa-hl-svn] r4736 - rl/branches
Message-ID: <200902051957.n15Jvb8I018244@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-05 20:57:36 +0100 (Thu, 05 Feb 2009)
New Revision: 4736

Added:
   rl/branches/persistence2/
Log:
Branch whole RL into persistence, not just engine



From blakharaz at mail.berlios.de  Thu Feb  5 21:00:39 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 5 Feb 2009 21:00:39 +0100
Subject: [Dsa-hl-svn] r4737 - rl/branches/persistence2
Message-ID: <200902052000.n15K0dWA021116@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-05 21:00:32 +0100 (Thu, 05 Feb 2009)
New Revision: 4737

Added:
   rl/branches/persistence2/.cdtproject
   rl/branches/persistence2/.project
   rl/branches/persistence2/CMakeLists.txt
   rl/branches/persistence2/LICENSE.TXT
   rl/branches/persistence2/LICENSE_ARTS.TXT
   rl/branches/persistence2/LICENSE_PROGRAM.TXT
   rl/branches/persistence2/Mac/
   rl/branches/persistence2/README.TXT
   rl/branches/persistence2/Rastullah2005.sln
   rl/branches/persistence2/cmake/
   rl/branches/persistence2/docs/
   rl/branches/persistence2/editors/
   rl/branches/persistence2/fileheader.template
   rl/branches/persistence2/tests/
   rl/branches/persistence2/tools/
Log:
Branch whole RL into persistence, not just engine

Copied: rl/branches/persistence2/.cdtproject (from rev 4736, rl/trunk/.cdtproject)

Copied: rl/branches/persistence2/.project (from rev 4736, rl/trunk/.project)

Copied: rl/branches/persistence2/CMakeLists.txt (from rev 4736, rl/trunk/CMakeLists.txt)

Copied: rl/branches/persistence2/LICENSE.TXT (from rev 4736, rl/trunk/LICENSE.TXT)

Copied: rl/branches/persistence2/LICENSE_ARTS.TXT (from rev 4736, rl/trunk/LICENSE_ARTS.TXT)

Copied: rl/branches/persistence2/LICENSE_PROGRAM.TXT (from rev 4736, rl/trunk/LICENSE_PROGRAM.TXT)

Copied: rl/branches/persistence2/Mac (from rev 4736, rl/trunk/Mac)

Copied: rl/branches/persistence2/README.TXT (from rev 4736, rl/trunk/README.TXT)

Copied: rl/branches/persistence2/Rastullah2005.sln (from rev 4736, rl/trunk/Rastullah2005.sln)

Copied: rl/branches/persistence2/cmake (from rev 4736, rl/trunk/cmake)

Copied: rl/branches/persistence2/docs (from rev 4736, rl/trunk/docs)

Copied: rl/branches/persistence2/editors (from rev 4736, rl/trunk/editors)

Copied: rl/branches/persistence2/fileheader.template (from rev 4736, rl/trunk/fileheader.template)

Copied: rl/branches/persistence2/tests (from rev 4736, rl/trunk/tests)

Copied: rl/branches/persistence2/tools (from rev 4736, rl/trunk/tools)



From blakharaz at mail.berlios.de  Thu Feb  5 21:01:24 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 5 Feb 2009 21:01:24 +0100
Subject: [Dsa-hl-svn] r4738 - in rl/branches: . persistence2
Message-ID: <200902052001.n15K1OK4022304@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-05 21:01:23 +0100 (Thu, 05 Feb 2009)
New Revision: 4738

Added:
   rl/branches/persistence2/engine/
Removed:
   rl/branches/persistence/
Log:
Branch whole RL into persistence, not just engine

Copied: rl/branches/persistence2/engine (from rev 4737, rl/branches/persistence)



From blakharaz at mail.berlios.de  Thu Feb  5 21:59:41 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 5 Feb 2009 21:59:41 +0100
Subject: [Dsa-hl-svn] r4739 - in rl/branches/persistence2: . engine/core
Message-ID: <200902052059.n15KxfLY004161@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-05 21:59:40 +0100 (Thu, 05 Feb 2009)
New Revision: 4739

Modified:
   rl/branches/persistence2/CMakeLists.txt
   rl/branches/persistence2/engine/core/CMakeLists.txt
Log:
Fix cmake files

Modified: rl/branches/persistence2/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/CMakeLists.txt	2009-02-05 20:01:23 UTC (rev 4738)
+++ rl/branches/persistence2/CMakeLists.txt	2009-02-05 20:59:40 UTC (rev 4739)
@@ -1,15 +1,54 @@
 PROJECT(RL)
 
-CMAKE_MINIMUM_REQUIRED(VERSION 2.6.0 FATAL_ERROR)
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6.2 FATAL_ERROR)
 
-# Include required cmake macros
-INCLUDE(FeatureSummary)
+# Package and version information
+SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Rastullahs Lockenpracht ist ein auf DSA Regeln basierendes (Rollen-)Spiel")
+SET(CPACK_PACKAGE_VENDOR "Team Pantheon")
+SET(CPACK_PACKAGE_CONTACT "contact at rastullahs-lockenpracht.de")
 
-# Version information
 SET(RL_MAJOR_VERSION 0)
 SET(RL_MINOR_VERSION 3)
 SET(RL_PATCH_VERSION 0)
 
+SET(CPACK_PACKAGE_VERSION_MAJOR ${RL_MAJOR_VERSION})
+SET(CPACK_PACKAGE_VERSION_MINOR ${RL_MINOR_VERSION})
+SET(CPACK_PACKAGE_VERSION_PATCH ${RL_PATCH_VERSION})
+
+IF(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
+	SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE amd64)
+ELSEIF(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "i686")
+	SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE i386)
+ENDIF(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
+
+SET(CPACK_SOURCE_GENERATOR "TBZ2;ZIP")
+SET(CPACK_SOURCE_PACKAGE_FILE_NAME
+"${CMAKE_PROJECT_NAME}-${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}")
+
+IF(WIN32 AND NOT UNIX)
+	# TEMPLATE - Not Tested!
+	# There is a bug in NSI that does not handle full unix paths properly. Make
+	# sure there is at least one set of four (4) backlasshes.
+	SET(CPACK_PACKAGE_ICON "${CMake_SOURCE_DIR}/Utilities/Release\\\\InstallIcon.bmp")
+	SET(CPACK_NSIS_INSTALLED_ICON_NAME "bin\\\\RL_setup.exe")
+	SET(CPACK_NSIS_DISPLAY_NAME "${CPACK_PACKAGE_INSTALL_DIRECTORY} RL")
+	SET(CPACK_NSIS_HELP_LINK "http:\\\\\\\\www.rastullahs-lockenpracht.de")
+	SET(CPACK_NSIS_URL_INFO_ABOUT "http:\\\\\\\\www.wiki.team-pantheon.de")
+	SET(CPACK_NSIS_CONTACT "contact at rastullahs-lockenpracht.de")
+	SET(CPACK_NSIS_MODIFY_PATH ON)
+ELSE(WIN32 AND NOT UNIX)
+	SET(CPACK_STRIP_FILES "bin/RL")
+	SET(CPACK_SOURCE_STRIP_FILES "")
+ENDIF(WIN32 AND NOT UNIX)
+
+#Enable absolute paths
+SET(CPACK_SET_DESTDIR "ON")
+
+# Include required cmake macros
+INCLUDE(FeatureSummary)
+INCLUDE(InstallRequiredSystemLibraries)
+INCLUDE(CPack)
+
 # Add directory with RL's own macro definitions
 # (checked before ${CMAKE_ROOT}/Modules)
 SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
@@ -29,7 +68,8 @@
 FIND_PACKAGE(OIS REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
-FIND_PACKAGE(OgreNewt 1.53 REQUIRED)
+FIND_PACKAGE(FMODEx REQUIRED)
+FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
 FIND_PACKAGE(OpenSteer REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(Ruby REQUIRED)
@@ -39,6 +79,10 @@
 	SET_FEATURE_INFO(SWIG "" "" "You use an unsupported version of SWIG.")
 ENDIF(NOT SWIG_DIR MATCHES -rl$)
 
+# Compile settings for build types
+SET(CMAKE_CXX_FLAGS_DEBUG "-O0 -g -DDEBUG")
+SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g -DDEBUG")
+
 # Path options
 SET(BINDIR "bin" CACHE STRING "Where to install binaries")
 SET(DATAROOTDIR "${CMAKE_INSTALL_PREFIX}/share" CACHE STRING "Sets the root of data directories to a non-default location")
@@ -50,6 +94,5 @@
 
 # Include subdirectories
 ADD_SUBDIRECTORY(engine)
-ADD_SUBDIRECTORY(plugins)
 
 PRINT_ENABLED_FEATURES()

Modified: rl/branches/persistence2/engine/core/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/core/CMakeLists.txt	2009-02-05 20:01:23 UTC (rev 4738)
+++ rl/branches/persistence2/engine/core/CMakeLists.txt	2009-02-05 20:59:40 UTC (rev 4739)
@@ -7,7 +7,8 @@
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
 ${MESHMAGICK_INCLUDE_DIR}
-${RUBY_INCLUDE_PATH})
+${RUBY_INCLUDE_PATH}
+${FMODEX_INCLUDE_DIR})
 
 SET(RlCore_LIB_SRCS
 src/Actor.cpp
@@ -23,7 +24,6 @@
 src/CoreSubsystem.cpp
 src/DebugVisualisable.cpp
 src/DebugVisualsManager.cpp
-src/DotSceneLoader.cpp
 src/DotSceneOctreeWorld.cpp
 src/FadeAnimation.cpp
 src/GameAreaEvent.cpp
@@ -96,11 +96,11 @@
 
 ADD_LIBRARY(RlCore SHARED ${RlCore_LIB_SRCS})
 
-TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY})
+TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY} ${FMODEX_LIBRARY})
 
 SET_TARGET_PROPERTIES(RlCore PROPERTIES
 	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}
-	SOVERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}
+	SOVERSION ${RL_MAJOR_VERSION}
 	DEFINE_SYMBOL RLCORE_EXPORTS)
 
 INSTALL(TARGETS RlCore LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)



From blakharaz at mail.berlios.de  Fri Feb  6 20:35:22 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 6 Feb 2009 20:35:22 +0100
Subject: [Dsa-hl-svn] r4740 - in rl/branches/persistence2/engine: core
	core/src script
Message-ID: <200902061935.n16JZMiE026051@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-06 20:35:20 +0100 (Fri, 06 Feb 2009)
New Revision: 4740

Modified:
   rl/branches/persistence2/engine/core/CMakeLists.txt
   rl/branches/persistence2/engine/core/src/LightFadeJob.cpp
   rl/branches/persistence2/engine/script/CMakeLists.txt
Log:
Some fixes

Modified: rl/branches/persistence2/engine/core/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/core/CMakeLists.txt	2009-02-05 20:59:40 UTC (rev 4739)
+++ rl/branches/persistence2/engine/core/CMakeLists.txt	2009-02-06 19:35:20 UTC (rev 4740)
@@ -61,6 +61,7 @@
 src/SaveAbleCollection.cpp
 src/SaveAbleFactory.cpp
 src/SaveAbleManager.cpp
+src/SaveAbleSerializer.cpp
 src/SaveGameFile.cpp
 src/SaveGameFileReader.cpp
 src/SaveGameFileWriter.cpp

Modified: rl/branches/persistence2/engine/core/src/LightFadeJob.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/LightFadeJob.cpp	2009-02-05 20:59:40 UTC (rev 4739)
+++ rl/branches/persistence2/engine/core/src/LightFadeJob.cpp	2009-02-06 19:35:20 UTC (rev 4740)
@@ -22,7 +22,7 @@
 {
     LightFadeJob::LightFadeJob(LightObject* lightObject, const Ogre::ColourValue& targetDiffuse,
         const Ogre::ColourValue& targetSpecular, Ogre::Real duration)
-        : Job(true, true),
+        : Job("", true, true),
         mLightObject(lightObject),
         mDuration(duration)
     {

Modified: rl/branches/persistence2/engine/script/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/script/CMakeLists.txt	2009-02-05 20:59:40 UTC (rev 4739)
+++ rl/branches/persistence2/engine/script/CMakeLists.txt	2009-02-06 19:35:20 UTC (rev 4740)
@@ -14,7 +14,9 @@
 ${OIS_INCLUDE_DIRS}
 ${RUBY_INCLUDE_PATH})
 
-SET_SOURCE_FILES_PROPERTIES(swig/RlExports.i PROPERTIES CPLUSPLUS ON)
+SET_SOURCE_FILES_PROPERTIES(swig/RlExports.i PROPERTIES 
+        CPLUSPLUS ON
+        SWIG_FLAGS -minherit)
 
 SWIG_ADD_MODULE(RlScript RUBY
 swig/RlExports.i



From fusion2 at mail.berlios.de  Sat Feb  7 20:13:03 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sat, 7 Feb 2009 20:13:03 +0100
Subject: [Dsa-hl-svn] r4741 - in rl/trunk/editors/Lockenwickler: .
	_eric4project src src/media
Message-ID: <200902071913.n17JD3Gq008974@sheep.berlios.de>

Author: fusion2
Date: 2009-02-07 20:12:52 +0100 (Sat, 07 Feb 2009)
New Revision: 4741

Added:
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
   rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/media/
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
Log:
- work on the selection buffer began

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-07, 20:03:18 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>
@@ -37,6 +37,7 @@
     <Source>src/NewModuleWizard.py</Source>
     <Source>src/Ui_NewModuleWizard.py</Source>
     <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-07, 20:03:18 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-07, 20:03:18 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-01-26, 17:23:59</Created>
+    <Created>2009-02-07, 17:52:11</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
       <Linenumber>416</Linenumber>


Property changes on: rl/trunk/editors/Lockenwickler/src
___________________________________________________________________
Name: svn:ignore
   - ogre.cfg

   + ogre.cfg
SelectionBuffer - Kopie.py


Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -260,11 +260,11 @@
         self.moduleName = ""
         self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
 
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
-
+        
         og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
@@ -298,7 +298,7 @@
         self.moduleManager.cutObjects()
 
     def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
 
     def actionSelectSlot(self):
         self.moduleManager.pivot.hide()
@@ -397,11 +397,11 @@
 
     def keyPressEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
+            self.ogreMainWindow.keyPressEvent(event)
 
     def keyReleaseEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
+            self.ogreMainWindow.keyReleaseEvent(event)
         pass
 
     def connectActionButtons(self):

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,174 +1,176 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MyListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MyListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream << self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData("application/x-static_model", data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class ModelSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
-                               self.updateModelList)
-
-        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
-                               self.setPreviewedModel)
-
-        self.modelList = []
-
-        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName("modelPreviewDialog")
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.modelSearchBox = QLineEdit(self)
-        self.modelSearchBox.setObjectName("modelSearchBox")
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName("splitter")
-
-        self.listWidget = MyListWidget(self.splitter)
-        self.listWidget.setObjectName("listWidget")
-
-        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
-        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
-                                                         self.splitter)
-        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
-
-    def setPreviewedModel(self):
-        if self.ent != None:
-            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
-
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
-                                                                 str(self.listWidget.currentItem().text()))
-        self.node.attachObject(self.ent)
-        self.node.setScale(og.Vector3(1,1,1))
-        bb = self.ent.getBoundingBox()
-
-    def scanDirForModels(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForModels(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(".mesh"):
-                    self.modelList.append(file)
-                    self.listWidget.addItem(file)
-
-        self.listWidget.sortItems()
-
-    def updateModelList(self, text):
-        self.listWidget.clear()
-        for model in self.modelList:
-            if model.find(text) != -1:
-               self.listWidget.addItem(model)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() < 0:
-                self.ogreModelPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreModelPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
-                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MyListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MyListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData("application/x-static_model", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
+                               self.updateModelList)
+
+        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName("modelPreviewDialog")
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.modelSearchBox = QLineEdit(self)
+        self.modelSearchBox.setObjectName("modelSearchBox")
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.listWidget = MyListWidget(self.splitter)
+        self.listWidget.setObjectName("listWidget")
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
+                                                         self.splitter)
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(".mesh"):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() < 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -30,6 +30,7 @@
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+from SelectionBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
@@ -339,7 +340,8 @@
             cmd = join(self.moduleRoot, "maps/*.rlscene")
             sceneFile = glob.glob(cmd)
             self.loadScenes(sceneFile)
-
+            
+        
     def loadScenes(self, sceneFiles):
         for f in sceneFiles:
             self.scenes.append(Scene(self.moduleRoot, f, self.sceneManager, self.ogreRoot, self.gocManager))
@@ -414,6 +416,8 @@
         self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
         self.moduleConfigIsParsed = False
 
+        self.selectionBuffer = None
+    
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
         self.moduleList = []
@@ -486,20 +490,27 @@
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 
-        self.moduleExplorer.updateView()
+#        self.moduleExplorer.updateView()
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
-#        e.setMaterialName("Lockenwickler_Area")
+#        e.setMaterialName("PlainColor")
+#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
 #
 #        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
-#        e2.setMaterialName("Lockenwickler_Area")
-
+#        e2.setMaterialName("PlainColor")
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
 #        n.attachObject(e)
 #        n.attachObject(e2)
 #        n.setScale(og.Vector3(10, 5, 20))
+#        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
 
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        if self.selectionBuffer is not None:
+            self.selectionBuffer.update()
+            
         self.listenerDings.reset()
         self.lastRay = ray
         self.listenerDings.currentRay = ray

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -1,317 +1,323 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreRenderWindow = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-
-        self.setupUi(self)
-
-
-    def setupUi(self, Form):
-        Form.setObjectName("Form")
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName("gridlayout")
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName("splitter")
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
-        self.ogreRenderWindow.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
-        self.ogreRenderWindow.setSizePolicy(sizePolicy)
-        self.ogreRenderWindow.setObjectName("ogreWidget")
-        self.splitterV.addWidget(self.ogreRenderWindow)
-        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreRenderWindow.installEventFilter(self)
-        self.ogreRenderWindow.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreRenderWindow.viewport)
-        self.viewportGrid.enable()
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreRenderWindow.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print "dbg: DragLeave"
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            data = event.mimeData().data("application/x-static_model")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            data = event.mimeData().data("application/x-game_object")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        return self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        mouseRay = self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(mouseRay)
-
-
-    def updateCamera(self):
-        if self.moveCamForward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreRenderWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0.2, 0, 0))
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+
+        self.setupUi(self)
+
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName("ogreWidget")
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print "dbg: DragLeave"
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+
+    def updateCamera(self):
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -93,7 +93,13 @@
     def getCamera(self):
         assert(self.camera)
         return self.camera
-
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
     #(const Ogre::Radian& horz, const Ogre::Radian& vert)
     def orbitCamera( self, horz, vert):
         #orbit around focus node

Added: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-07 19:12:52 UTC (rev 4741)
@@ -0,0 +1,160 @@
+import ctypes as ctypes
+import random
+
+import ogre.renderer.OGRE as og
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = ""
+        self.lastTechnique = None
+        
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+        temp = str(type(subEntity))
+        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                return self.lastTechnique
+            else:
+                self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColor", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+                
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+
+                self.lastEntity = subEntity.getParent().getName()
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = ""
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera("MainCam")
+
+        self.viewport = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+#        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+#                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+#                                                                    og.TEX_TYPE_2D, 
+#                                                                    self.viewport.getActualWidth(), 
+#                                                                    self.viewport.getActualHeight(), 
+#                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        width = self.viewport.getWidth()
+        height = self.viewport.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        
+        self.createRTTOverlays()
+
+    def update(self):
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        buff = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(buff))
+
+        pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+        self.renderTexture.writeContentsToTimestampedFile("editor", ".png")
+        i = 0
+        
+        while i < len(buff):
+            #print str(buff[i + 2]) + " " + str(buff[i+1]) + " " + str(buff[i])
+            
+            i += 4
+        #for a in buff:
+            #print a
+
+        #pBox = pixelBuffer.getCurrentLock()
+        
+        #storageclass = ctypes.c_uint8 * (self.renderTexture.getWidth()*self.renderTexture.getHeight()*3) 
+        
+        
+        #pixelBuffer.unlock()
+        
+
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
+        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName("SelectionPassTex")
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create("OverlayName")
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName("SelectionDebugMaterial") 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+


Property changes on: rl/trunk/editors/Lockenwickler/src/media
___________________________________________________________________
Name: svn:ignore
   - .Bpib
skelett.blend

   + .Bpib
skelett.blend
skelett_merged.blend


Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-07 19:12:52 UTC (rev 4741)
@@ -19,6 +19,8 @@
 
 		pass
 		{
+			lighting off
+
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -94,4 +96,48 @@
 	}
 }
 
- 
+vertex_program PlainColor_VS cg
+{
+	source PlainColor.cg
+	entry_point main_plain_color_vp
+	profiles vs_1_1 arbvp1
+
+	default_params
+	{
+		param_named_auto worldViewProj worldviewproj_matrix		
+	}
+
+}
+
+fragment_program PlainColor_PS cg			
+{
+	source PlainColor.cg		
+	entry_point main_plain_color_fp	
+	profiles ps_1_1 arbfp1
+  
+	default_params
+	{
+		param_named inColor float4 1 1 1 1
+	}
+}	
+
+material PlainColor
+{
+        // Material has one technique
+	technique					
+	{
+                // This technique has one pass
+		pass					
+		{
+                        // Make this pass use the vertex shader defined above
+			vertex_program_ref PlainColor_VS	
+			{
+			}
+                        // Make this pass use the pixel shader defined above
+			fragment_program_ref PlainColor_PS	
+			{
+			      param_named_auto inColor custom 1
+			}
+		}
+	}
+}

Added: rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-06 19:35:20 UTC (rev 4740)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-07 19:12:52 UTC (rev 4741)
@@ -0,0 +1,32 @@
+void main_plain_color_vp(
+		// Vertex Inputs
+		float4 position		: POSITION,	// Vertex position in model space
+		float2 texCoord0	: TEXCOORD0,	// Texture UV set 0
+
+		// Outputs
+		out float4 oPosition	: POSITION,	// Transformed vertex position
+		out float2 uv0		: TEXCOORD0,	// UV0
+
+		// Model Level Inputs
+		uniform float4x4 worldViewProj)
+{
+	// Calculate output position
+	oPosition = mul(worldViewProj, position);
+
+	// Simply copy the input vertex UV to the output
+	uv0 = texCoord0;
+}
+
+void main_plain_color_fp(
+		// Pixel Inputs
+		float2 uv0		: TEXCOORD0,	// UV interpolated for current pixel	 
+		// Outputs
+		out float4 color	: COLOR,	// Output color we want to write
+		uniform float4 inColor
+		)
+{	 
+	// Just sample texture using supplied UV
+	//color = float4(0, 1, 0, 1);
+	//color = float4(inColor.r, inColor.g, inColor.b, 1);
+	color = inColor;
+}



From timm at mail.berlios.de  Sat Feb  7 21:53:11 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 7 Feb 2009 21:53:11 +0100
Subject: [Dsa-hl-svn] r4742 - in
	rl/branches/persistence2/editors/Lockenwickler: .
	_eric4project src src/media
Message-ID: <200902072053.n17KrBcF018612@sheep.berlios.de>

Author: timm
Date: 2009-02-07 21:53:03 +0100 (Sat, 07 Feb 2009)
New Revision: 4742

Added:
   rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColor.cg
Modified:
   rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/persistence2/editors/Lockenwickler/src/
   rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/
   rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
Log:
merged from trunk

Modified: rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-02-07 20:53:03 UTC (rev 4742)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-07, 20:03:18 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>
@@ -37,6 +37,7 @@
     <Source>src/NewModuleWizard.py</Source>
     <Source>src/Ui_NewModuleWizard.py</Source>
     <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-07 20:53:03 UTC (rev 4742)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-07, 20:03:18 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-07 20:53:03 UTC (rev 4742)
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-07, 20:03:18 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-01-26, 17:23:59</Created>
+    <Created>2009-02-07, 17:52:11</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
       <Linenumber>416</Linenumber>


Property changes on: rl/branches/persistence2/editors/Lockenwickler/src
___________________________________________________________________
Name: svn:ignore
   - ogre.cfg

   + ogre.cfg
SelectionBuffer - Kopie.py


Modified: rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-02-07 20:53:03 UTC (rev 4742)
@@ -260,11 +260,11 @@
         self.moduleName = ""
         self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
 
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
-
+        
         og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
@@ -298,7 +298,7 @@
         self.moduleManager.cutObjects()
 
     def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
 
     def actionSelectSlot(self):
         self.moduleManager.pivot.hide()
@@ -397,11 +397,11 @@
 
     def keyPressEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
+            self.ogreMainWindow.keyPressEvent(event)
 
     def keyReleaseEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
+            self.ogreMainWindow.keyReleaseEvent(event)
         pass
 
     def connectActionButtons(self):

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-07 20:53:03 UTC (rev 4742)
@@ -1,174 +1,176 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MyListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MyListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream << self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData("application/x-static_model", data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class ModelSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
-                               self.updateModelList)
-
-        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
-                               self.setPreviewedModel)
-
-        self.modelList = []
-
-        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName("modelPreviewDialog")
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.modelSearchBox = QLineEdit(self)
-        self.modelSearchBox.setObjectName("modelSearchBox")
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName("splitter")
-
-        self.listWidget = MyListWidget(self.splitter)
-        self.listWidget.setObjectName("listWidget")
-
-        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
-        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
-                                                         self.splitter)
-        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
-
-    def setPreviewedModel(self):
-        if self.ent != None:
-            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
-
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
-                                                                 str(self.listWidget.currentItem().text()))
-        self.node.attachObject(self.ent)
-        self.node.setScale(og.Vector3(1,1,1))
-        bb = self.ent.getBoundingBox()
-
-    def scanDirForModels(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForModels(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(".mesh"):
-                    self.modelList.append(file)
-                    self.listWidget.addItem(file)
-
-        self.listWidget.sortItems()
-
-    def updateModelList(self, text):
-        self.listWidget.clear()
-        for model in self.modelList:
-            if model.find(text) != -1:
-               self.listWidget.addItem(model)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() < 0:
-                self.ogreModelPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreModelPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
-                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MyListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MyListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData("application/x-static_model", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
+                               self.updateModelList)
+
+        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName("modelPreviewDialog")
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.modelSearchBox = QLineEdit(self)
+        self.modelSearchBox.setObjectName("modelSearchBox")
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.listWidget = MyListWidget(self.splitter)
+        self.listWidget.setObjectName("listWidget")
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
+                                                         self.splitter)
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(".mesh"):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() < 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-02-07 20:53:03 UTC (rev 4742)
@@ -30,6 +30,7 @@
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+from SelectionBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
@@ -339,7 +340,8 @@
             cmd = join(self.moduleRoot, "maps/*.rlscene")
             sceneFile = glob.glob(cmd)
             self.loadScenes(sceneFile)
-
+            
+        
     def loadScenes(self, sceneFiles):
         for f in sceneFiles:
             self.scenes.append(Scene(self.moduleRoot, f, self.sceneManager, self.ogreRoot, self.gocManager))
@@ -414,6 +416,8 @@
         self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
         self.moduleConfigIsParsed = False
 
+        self.selectionBuffer = None
+    
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
         self.moduleList = []
@@ -486,20 +490,27 @@
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 
-        self.moduleExplorer.updateView()
+#        self.moduleExplorer.updateView()
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
-#        e.setMaterialName("Lockenwickler_Area")
+#        e.setMaterialName("PlainColor")
+#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
 #
 #        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
-#        e2.setMaterialName("Lockenwickler_Area")
-
+#        e2.setMaterialName("PlainColor")
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
 #        n.attachObject(e)
 #        n.attachObject(e2)
 #        n.setScale(og.Vector3(10, 5, 20))
+#        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
 
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        if self.selectionBuffer is not None:
+            self.selectionBuffer.update()
+            
         self.listenerDings.reset()
         self.lastRay = ray
         self.listenerDings.currentRay = ray

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-07 20:53:03 UTC (rev 4742)
@@ -1,317 +1,323 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreRenderWindow = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-
-        self.setupUi(self)
-
-
-    def setupUi(self, Form):
-        Form.setObjectName("Form")
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName("gridlayout")
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName("splitter")
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
-        self.ogreRenderWindow.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
-        self.ogreRenderWindow.setSizePolicy(sizePolicy)
-        self.ogreRenderWindow.setObjectName("ogreWidget")
-        self.splitterV.addWidget(self.ogreRenderWindow)
-        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreRenderWindow.installEventFilter(self)
-        self.ogreRenderWindow.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreRenderWindow.viewport)
-        self.viewportGrid.enable()
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreRenderWindow.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print "dbg: DragLeave"
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            data = event.mimeData().data("application/x-static_model")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            data = event.mimeData().data("application/x-game_object")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        return self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        mouseRay = self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(mouseRay)
-
-
-    def updateCamera(self):
-        if self.moveCamForward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreRenderWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0.2, 0, 0))
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+
+        self.setupUi(self)
+
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName("ogreWidget")
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print "dbg: DragLeave"
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+
+    def updateCamera(self):
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-02-07 20:53:03 UTC (rev 4742)
@@ -93,7 +93,13 @@
     def getCamera(self):
         assert(self.camera)
         return self.camera
-
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
     #(const Ogre::Radian& horz, const Ogre::Radian& vert)
     def orbitCamera( self, horz, vert):
         #orbit around focus node

Copied: rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py (from rev 4741, rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py)


Property changes on: rl/branches/persistence2/editors/Lockenwickler/src/media
___________________________________________________________________
Name: svn:ignore
   - .Bpib
skelett.blend

   + .Bpib
skelett.blend
skelett_merged.blend


Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-07 19:12:52 UTC (rev 4741)
+++ rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-07 20:53:03 UTC (rev 4742)
@@ -19,6 +19,8 @@
 
 		pass
 		{
+			lighting off
+
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -94,4 +96,48 @@
 	}
 }
 
- 
+vertex_program PlainColor_VS cg
+{
+	source PlainColor.cg
+	entry_point main_plain_color_vp
+	profiles vs_1_1 arbvp1
+
+	default_params
+	{
+		param_named_auto worldViewProj worldviewproj_matrix		
+	}
+
+}
+
+fragment_program PlainColor_PS cg			
+{
+	source PlainColor.cg		
+	entry_point main_plain_color_fp	
+	profiles ps_1_1 arbfp1
+  
+	default_params
+	{
+		param_named inColor float4 1 1 1 1
+	}
+}	
+
+material PlainColor
+{
+        // Material has one technique
+	technique					
+	{
+                // This technique has one pass
+		pass					
+		{
+                        // Make this pass use the vertex shader defined above
+			vertex_program_ref PlainColor_VS	
+			{
+			}
+                        // Make this pass use the pixel shader defined above
+			fragment_program_ref PlainColor_PS	
+			{
+			      param_named_auto inColor custom 1
+			}
+		}
+	}
+}

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColor.cg (from rev 4741, rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg)



From fusion2 at mail.berlios.de  Sun Feb  8 16:43:16 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sun, 8 Feb 2009 16:43:16 +0100
Subject: [Dsa-hl-svn] r4743 - in rl/trunk/editors/Lockenwickler: .
	_eric4project src
Message-ID: <200902081543.n18FhGOH016951@sheep.berlios.de>

Author: fusion2
Date: 2009-02-08 16:43:10 +0100 (Sun, 08 Feb 2009)
New Revision: 4743

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
Log:
- selection buffer mostly finished (pixel perfect selection!!)

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-07 20:53:03 UTC (rev 4742)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-08 15:43:10 UTC (rev 4743)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-02-07, 20:03:18 -->
+<!-- Saved: 2009-02-08, 13:55:11 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-07 20:53:03 UTC (rev 4742)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-08 15:43:10 UTC (rev 4743)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-02-07, 20:03:18 -->
+<!-- Saved: 2009-02-08, 13:55:11 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-07 20:53:03 UTC (rev 4742)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-08 15:43:10 UTC (rev 4743)
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-02-07, 20:03:18 -->
+<!-- Saved: 2009-02-08, 13:55:11 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-02-07, 17:52:11</Created>
+    <Created>2009-02-08, 11:32:14</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
       <Linenumber>416</Linenumber>

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-07 20:53:03 UTC (rev 4742)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-08 15:43:10 UTC (rev 4743)
@@ -33,8 +33,8 @@
 from SelectionBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
 
+
 #                <zone name="Testzone">
 #                        <area type="sphere">
 #                                <position x="-10" y="0" z="-5"/>
@@ -378,8 +378,6 @@
 
         self.moduleCfgPath = ""
 
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
         self.gocManager = GameObjectClassManager()
         # we need to hold a reference to the game object representaions ourself
         # python does not recognize the a reference to a c++ object (Entity in our case) is passed
@@ -393,8 +391,6 @@
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
 
-        self.listenerDings = MyRaySceneQueryListener()
-
         self.moduleExplorer = None
 
         self.lastRay = None
@@ -507,18 +503,14 @@
             self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
 
     # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        so = None
+        
         if self.selectionBuffer is not None:
-            self.selectionBuffer.update()
-            
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        
+        
         if so is not None:
             if not so.isPivot:
                 if not controlDown and not shiftDown:
@@ -691,8 +683,6 @@
 
         self.userSelectionList = []
 
-        self.listenerDings.reset()
-        pass
 
 
     def updatePivots(self):

Modified: rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-02-07 20:53:03 UTC (rev 4742)
+++ rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-02-08 15:43:10 UTC (rev 4743)
@@ -18,7 +18,6 @@
 
 import ctypes
 import ogre.renderer.OGRE as og
-import ogre.physics.OgreNewt as on
 
 # a class to store information about a object that got selected
 class SelectionObject():
@@ -61,12 +60,9 @@
         self.currentRay = None
         self.lastRay = None
 
-        self.World = on.World()
-        self.World.setWorldSize(og.Vector3(-1000000, -1000000, -1000000), og.Vector3(1000000, 1000000, 1000000))
+    #def __del__(self):
+        #del self.World
 
-    def __del__(self):
-        del self.World
-
     # sort algorithm for the selection list
     def sortCompareImp(self,  x,  y):
         if x.distance > y.distance:
@@ -137,33 +133,9 @@
 
 
     def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-        col = on.TreeCollision(self.World, entity.getParentNode(), False)
-        bod = on.Body(self.World, col)
-
-
-        start = ray.getOrigin()
-        end = ray.getPoint(10000)
-
-        retNorm = og.Vector3(0.0, 0.0, 0.0)
-
-        val = on.CollisionRayCast(col, start, end, retNorm)
-#        print val
-#
-#        print retNorm.x
-#        print retNorm.y
-#        print retNorm.z
-        del col
-        self.World.destroyAllBodies()
+        return
         
-        if retNorm.x != 0.0 or retNorm.y != 0.0 or retNorm.z != 0.0:
-#           print "yes"
-           return True
-        else:
-#            print "no"
-            return False
-           
         
-        
 
 #    def iterateEntityUnderMouse(self):
 #        self.previousSelected = self.currentSelected

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-07 20:53:03 UTC (rev 4742)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-08 15:43:10 UTC (rev 4743)
@@ -299,11 +299,11 @@
         mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
 
         if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(mouseRay,  True,  False)
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
         elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(mouseRay,  False,  True)
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
         else:
-            self.moduleManager.selectionClick(mouseRay)
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
 
     def getWidth():
         return self.ogreWidget.getWidth()

Modified: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-07 20:53:03 UTC (rev 4742)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-08 15:43:10 UTC (rev 4743)
@@ -3,15 +3,44 @@
 
 import ogre.renderer.OGRE as og
 
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
 # class to handle material switching without having to modify scene materials individually
 class MaterialSwitcher( og.MaterialManager.Listener ):
     def __init__(self):
         og.MaterialManager.Listener.__init__(self)
       
         self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+        
         self.lastEntity = ""
         self.lastTechnique = None
         
+        self.colorDict = {}
        
     # takes into account that one Entity can have multiple SubEntities
     def handleSchemeNotFound(self, index, name, material, lod, subEntity):
@@ -26,8 +55,8 @@
                 self.randomizeColor()
                 subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
                 
-
                 self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
                 return self.lastTechnique
         
 
@@ -35,12 +64,13 @@
         r = random.randrange(1, 255)
         g = random.randrange(1, 255)
         b = random.randrange(1, 255)
-        
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
         var = 1.0 / 255.0
 
         self.currentColor = og.ColourValue(r * var, g * var, b * var)
 
-        
+        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
+    
     def reset(self):
         self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
         self.lastEntity = ""
@@ -73,13 +103,6 @@
         
         self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
         
-#        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-#                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-#                                                                    og.TEX_TYPE_2D, 
-#                                                                    self.viewport.getActualWidth(), 
-#                                                                    self.viewport.getActualHeight(), 
-#                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
         width = self.viewport.getWidth()
         height = self.viewport.getHeight()
         
@@ -110,30 +133,35 @@
         #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
         
         storageclass = ctypes.c_uint8 * (bufferSize)
-        buff = storageclass()
+        self.buffer = storageclass()
         
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(buff))
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
 
-        pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-        self.renderTexture.writeContentsToTimestampedFile("editor", ".png")
-        i = 0
-        
-        while i < len(buff):
-            #print str(buff[i + 2]) + " " + str(buff[i+1]) + " " + str(buff[i])
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i < len(self.buffer):
+#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
+#            
+#            i += 4
             
-            i += 4
-        #for a in buff:
-            #print a
-
-        #pBox = pixelBuffer.getCurrentLock()
+    def onSelectionClick(self, x, y):
+        self.update()
         
-        #storageclass = ctypes.c_uint8 * (self.renderTexture.getWidth()*self.renderTexture.getHeight()*3) 
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
         
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
         
-        #pixelBuffer.unlock()
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                so = SelectionObject(self.sceneMgr.getEntity(key))
+                return so
+
+        return None
         
-
     def createRTTOverlays(self):
         baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
         SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")



From timm at mail.berlios.de  Sun Feb  8 17:22:41 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 8 Feb 2009 17:22:41 +0100
Subject: [Dsa-hl-svn] r4744 - in rl/branches/persistence2/engine:
	common/include common/src core/include core/src
Message-ID: <200902081622.n18GMfiF022432@sheep.berlios.de>

Author: timm
Date: 2009-02-08 17:22:35 +0100 (Sun, 08 Feb 2009)
New Revision: 4744

Modified:
   rl/branches/persistence2/engine/common/include/WriteableDataStreamFormatTarget.h
   rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/persistence2/engine/core/include/SaveGameFile.h
   rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence2/engine/core/src/SaveGameFile.cpp
   rl/branches/persistence2/engine/core/src/SaveGameFileReader.cpp
Log:
experimental writing of save game files works now

Modified: rl/branches/persistence2/engine/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/branches/persistence2/engine/common/include/WriteableDataStreamFormatTarget.h	2009-02-08 15:43:10 UTC (rev 4743)
+++ rl/branches/persistence2/engine/common/include/WriteableDataStreamFormatTarget.h	2009-02-08 16:22:35 UTC (rev 4744)
@@ -25,11 +25,11 @@
     class _RlCommonExport WriteableDataStreamFormatTarget : public XERCES_CPP_NAMESPACE::XMLFormatTarget
     {
     public:
-        WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream);
+        WriteableDataStreamFormatTarget(WriteableDataStream* stream);
         virtual void writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter);
         virtual void flush ();
     protected:
-        WriteableDataStreamPtr mStream;
+        WriteableDataStream* mStream;
     };
 }
 

Modified: rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-02-08 15:43:10 UTC (rev 4743)
+++ rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-02-08 16:22:35 UTC (rev 4744)
@@ -20,29 +20,23 @@
 
 namespace rl
 {
-    WriteableDataStreamFormatTarget::WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream)
+    WriteableDataStreamFormatTarget::WriteableDataStreamFormatTarget(WriteableDataStream* stream)
     {
         mStream = stream;
     }
 
     void WriteableDataStreamFormatTarget::writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter)
     {
-        if(dynamic_cast<WriteableDataStream*>(mStream.get()))
-        {
-            mStream->write((char*)toWrite, count);
-        }
-        else
-            LOG_ERROR(Logger::COMMON, "WriteableDataStreamFormatTarget: Stream " + mStream->getName() + " is not writeable");
+        mStream->write((char*)toWrite, count);
+        /*else
+            LOG_ERROR(Logger::COMMON, "WriteableDataStreamFormatTarget: Stream " + mStream->getName() + " is not writeable");*/
     }
 
     void WriteableDataStreamFormatTarget::flush ()
     {
-        if(dynamic_cast<WriteableDataStream*>(mStream.get()))
-        {
-            mStream->flush();
-        }
-        else
-            LOG_ERROR(Logger::COMMON, "WriteableDataStreamFormatTarget: Stream " + mStream->getName() + " is not writeable");
+        mStream->flush();
+        /*else
+            LOG_ERROR(Logger::COMMON, "WriteableDataStreamFormatTarget: Stream " + mStream->getName() + " is not writeable");*/
     }
 }
 

Modified: rl/branches/persistence2/engine/core/include/SaveGameFile.h
===================================================================
--- rl/branches/persistence2/engine/core/include/SaveGameFile.h	2009-02-08 15:43:10 UTC (rev 4743)
+++ rl/branches/persistence2/engine/core/include/SaveGameFile.h	2009-02-08 16:22:35 UTC (rev 4744)
@@ -39,14 +39,14 @@
         static const Ogre::String PROPERTY_NAME;
         static const Ogre::String PROPERTY_MODULENAME;
 
-        SaveGameFile(int id, WriteableDataStreamPtr stream);
+        SaveGameFile(int id, Ogre::DataStreamPtr stream);
         ~SaveGameFile();
         CeGuiString getName() const;
 		CeGuiString getModuleId() const;
 		int getId() const;
 
         //access to file
-        WriteableDataStreamPtr getDataStream() const;
+        Ogre::DataStreamPtr getDataStream() const;
         XERCES_CPP_NAMESPACE::XMLFormatTarget* getFormatTarget();
         void deleteFileFromStorage(); //erwuenscht?
 
@@ -63,7 +63,7 @@
 
         //file access
         Ogre::StringVector mScriptPatterns;
-        WriteableDataStreamPtr mStream;
+        Ogre::DataStreamPtr mStream;
         int mSaveGameId;
     };
 }

Modified: rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp	2009-02-08 15:43:10 UTC (rev 4743)
+++ rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp	2009-02-08 16:22:35 UTC (rev 4744)
@@ -64,11 +64,15 @@
 
 	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
 	{
+        //TODO Error handling
 		LOG_MESSAGE(Logger::CORE, "Parsing headers of save game file: " + stream->getName() + " Resource group: " + groupName);
-		SaveGameFile* file = new SaveGameFile(Ogre::StringConverter::parseInt(stream->getName()),(WriteableDataStreamPtr)static_cast<WriteableDataStream*>(stream.get()));
+        int number = Ogre::StringConverter::parseInt(stream->getName());
+        if(number <= 0 && number == mHighestSaveGameNumber)
+            number = mHighestSaveGameNumber + 1;
+		SaveGameFile* file = new SaveGameFile(number,stream);
 		mReader.parseSaveGameFileHeader(file);
-		mHighestSaveGameNumber = Ogre::StringConverter::parseInt(stream->getName()) > mHighestSaveGameNumber ? Ogre::StringConverter::parseInt(stream->getName()) : mHighestSaveGameNumber;
-		mSaveGameFiles[Ogre::StringConverter::parseInt(stream->getName())] = file;
+		mHighestSaveGameNumber = number > mHighestSaveGameNumber ? Ogre::StringConverter::parseInt(stream->getName()) : mHighestSaveGameNumber;
+		mSaveGameFiles[number] = file;
 	}
 
 	const Ogre::StringVector& SaveAbleSerializer::getScriptPatterns() const

Modified: rl/branches/persistence2/engine/core/src/SaveGameFile.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SaveGameFile.cpp	2009-02-08 15:43:10 UTC (rev 4743)
+++ rl/branches/persistence2/engine/core/src/SaveGameFile.cpp	2009-02-08 16:22:35 UTC (rev 4744)
@@ -33,7 +33,7 @@
     const Ogre::String SaveGameFile::PROPERTY_MODULENAME = "modulename";
 
 
-    SaveGameFile::SaveGameFile(int id, WriteableDataStreamPtr stream) : mStream(stream)
+    SaveGameFile::SaveGameFile(int id, Ogre::DataStreamPtr stream) : mStream(stream)
     {
 		mSaveGameId = id;  
     }
@@ -57,7 +57,7 @@
         return mSaveGameId;
     }
 
-    WriteableDataStreamPtr SaveGameFile::getDataStream() const
+    Ogre::DataStreamPtr SaveGameFile::getDataStream() const
     {
 		return mStream;
     }
@@ -65,7 +65,7 @@
     XERCES_CPP_NAMESPACE::XMLFormatTarget* SaveGameFile::getFormatTarget()
     {
         ///@todo: encryption
-		return new WriteableDataStreamFormatTarget(mStream);
+        return new WriteableDataStreamFormatTarget(static_cast<WriteableDataStream*>(mStream.get()));
     }
 
     void SaveGameFile::deleteFileFromStorage()

Modified: rl/branches/persistence2/engine/core/src/SaveGameFileReader.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SaveGameFileReader.cpp	2009-02-08 15:43:10 UTC (rev 4743)
+++ rl/branches/persistence2/engine/core/src/SaveGameFileReader.cpp	2009-02-08 16:22:35 UTC (rev 4744)
@@ -61,7 +61,7 @@
     {
 		initializeXml();
 
-		WriteableDataStreamPtr stream = file->getDataStream();
+        Ogre::DataStreamPtr stream = file->getDataStream();
 
 		if(stream->size())
 		{



From blakharaz at mail.berlios.de  Sun Feb  8 23:46:17 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 8 Feb 2009 23:46:17 +0100
Subject: [Dsa-hl-svn] r4745 - in modules/ruchin: dsa maps scripts
	scripts/maps
Message-ID: <200902082246.n18MkHcU019493@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-08 23:46:14 +0100 (Sun, 08 Feb 2009)
New Revision: 4745

Added:
   modules/ruchin/dsa/nscs.gof
   modules/ruchin/maps/ruchin_chars.rlmap.xml
Modified:
   modules/ruchin/dsa/gameobjectdefinitions.gof
   modules/ruchin/maps/ruchin.rlmap.xml
   modules/ruchin/maps/ruchin.rlscene
   modules/ruchin/scripts/maps/ruchin.rb
   modules/ruchin/scripts/moduleconfig.rb
Log:
Added some NSCs for the Ruchin story

Modified: modules/ruchin/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/ruchin/dsa/gameobjectdefinitions.gof	2009-02-08 16:22:35 UTC (rev 4744)
+++ modules/ruchin/dsa/gameobjectdefinitions.gof	2009-02-08 22:46:14 UTC (rev 4745)
@@ -1,42 +1,4 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <GameObjectDefinitions>
 
-
-	<gameobjectclass classid="Hesindiane" baseclass="NPC">
-		<property name="name" type="STRING" data="Hesindiane"/>
-		<property name="description" type="STRING" data="Deine ?ltere Schwester. Sie hat sich lieber aufs lernen konzentriert, w?hrend du in den Strassen herumgetollt bist. Daf?r bist du Humorvoller."/>
-		<property name="geometrytype" type="STRING" data="ellipsoid"/>
-		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
-		<property name="mass" type="REAL" data="65"/>
-		<property name="dialogfile" type="STRING" data="testperson.xml"/>
-		<property name="behaviours" type="ARRAY">
-			<property type="STRING" data="DefaultIdleBehaviour"/>
-			<property type="STRING" data="DialogBehaviour"/>
-		</property>
-		<property name="eigenschaften" type="MAP">
-			<property name="MU" type="INT" data="12"/>
-			<property name="KL" type="INT" data="14"/>
-			<property name="IN" type="INT" data="11"/>
-			<property name="CH" type="INT" data="8"/>
-			<property name="FF" type="INT" data="13"/>
-			<property name="GE" type="INT" data="11"/>
-			<property name="KO" type="INT" data="11"/>
-			<property name="KK" type="INT" data="10"/>
-		</property>
-		<property name="werte" type="MAP">
-			<property name="ModLE" type="INT" data="10"/>
-			<property name="ModAU" type="INT" data="10"/>
-			<property name="GS" type="INT" data="7" />
-			<property name="SO" type="INT" data="6" />
-		</property>
-		<property name="current_le" type="INT" data="20"/>
-		<property name="current_au" type="INT" data="20"/>
-		<!-- todo auf das echte maximum setzen -->
-		<property name="talente" type="MAP">
-			<property name="Selbstbeherrschung" type="INT" data="8"/>
-			<property name="Lehren" type="INT" data="5"/>
-		</property>
-	</gameobjectclass>
-
-
 </GameObjectDefinitions>

Added: modules/ruchin/dsa/nscs.gof
===================================================================
--- modules/ruchin/dsa/nscs.gof	2009-02-08 16:22:35 UTC (rev 4744)
+++ modules/ruchin/dsa/nscs.gof	2009-02-08 22:46:14 UTC (rev 4745)
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+
+	<gameobjectclass classid="Hesindiane" baseclass="NPC">
+		<property name="name" type="STRING" data="Hesindiane"/>
+		<property name="description" type="STRING" data="Deine ?ltere Schwester. Sie hat sich lieber aufs lernen konzentriert, w?hrend du in den Strassen herumgetollt bist. Daf?r bist du Humorvoller."/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+		<property name="eigenschaften" type="MAP">
+			<property name="MU" type="INT" data="12"/>
+			<property name="KL" type="INT" data="14"/>
+			<property name="IN" type="INT" data="11"/>
+			<property name="CH" type="INT" data="8"/>
+			<property name="FF" type="INT" data="13"/>
+			<property name="GE" type="INT" data="11"/>
+			<property name="KO" type="INT" data="11"/>
+			<property name="KK" type="INT" data="10"/>
+		</property>
+		<property name="werte" type="MAP">
+			<property name="ModLE" type="INT" data="10"/>
+			<property name="ModAU" type="INT" data="10"/>
+			<property name="GS" type="INT" data="7" />
+			<property name="SO" type="INT" data="6" />
+		</property>
+		<property name="current_le" type="INT" data="20"/>
+		<property name="current_au" type="INT" data="20"/>
+		<!-- todo auf das echte maximum setzen -->
+		<property name="talente" type="MAP">
+			<property name="Selbstbeherrschung" type="INT" data="8"/>
+			<property name="Lehren" type="INT" data="5"/>
+		</property>
+	</gameobjectclass>
+
+	<gameobjectclass classid="Hagen" baseclass="NPC">
+		<property name="name" type="STRING" data="Hagen"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Thorben" baseclass="NPC">
+		<property name="name" type="STRING" data="Thorben"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Rafur" baseclass="NPC">
+		<property name="name" type="STRING" data="Rafur"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Larissia" baseclass="NPC">
+		<property name="name" type="STRING" data="Larissia"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Dieb" baseclass="NPC">
+		<property name="name" type="STRING" data="Dieb"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Wachoffizier" baseclass="NPC">
+		<property name="name" type="STRING" data="Wachoffizier"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Wache" baseclass="NPC">
+		<property name="name" type="STRING" data="Wache"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Advokat" baseclass="NPC">
+		<property name="name" type="STRING" data="Advokat"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+
+	<gameobjectclass classid="Handlanger" baseclass="NPC">
+		<property name="name" type="STRING" data="Handlanger"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+    
+	<gameobjectclass classid="Leibwaechter" baseclass="NPC">
+		<property name="name" type="STRING" data="Leibwaechter"/>
+		<property name="description" type="STRING" data=""/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="mass" type="REAL" data="65"/>
+		<property name="behaviours" type="ARRAY">
+			<property type="STRING" data="DefaultIdleBehaviour"/>
+			<property type="STRING" data="DialogBehaviour"/>
+		</property>
+    </gameobjectclass>
+    
+</GameObjectDefinitions>

Modified: modules/ruchin/maps/ruchin.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin.rlmap.xml	2009-02-08 16:22:35 UTC (rev 4744)
+++ modules/ruchin/maps/ruchin.rlmap.xml	2009-02-08 22:46:14 UTC (rev 4745)
@@ -1,7 +1,9 @@
 <scene formatVersion="0.4.0">
     <nodes>
-<entity name="Ivy" meshfile="Ruchin_ivy_01.mesh">
-<position x="22.5935" y="-2.88005" z="-20.0237"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
+        <entity name="Ivy" meshfile="Ruchin_ivy_01.mesh">
+            <position x="22.5935" y="-2.88005" z="-20.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+        </entity>
     </nodes>
 </scene>
\ No newline at end of file

Modified: modules/ruchin/maps/ruchin.rlscene
===================================================================
--- modules/ruchin/maps/ruchin.rlscene	2009-02-08 16:22:35 UTC (rev 4744)
+++ modules/ruchin/maps/ruchin.rlscene	2009-02-08 22:46:14 UTC (rev 4745)
@@ -1,4 +1,6 @@
 <scene name="ruchin">
 	<map file="ruchin.rlmap.xml"/>	
 	<map file="Ruchin_houses.rlmap.xml"/>
+	<map file="ruchin_lightzones.rlmap.xml"/>
+	<map file="ruchin_chars.rlmap.xml"/>
 </scene>
\ No newline at end of file

Added: modules/ruchin/maps/ruchin_chars.rlmap.xml
===================================================================
--- modules/ruchin/maps/ruchin_chars.rlmap.xml	2009-02-08 16:22:35 UTC (rev 4744)
+++ modules/ruchin/maps/ruchin_chars.rlmap.xml	2009-02-08 22:46:14 UTC (rev 4745)
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<scene formatVersion="0.4.0">
+    <nodes>
+        <gameobject class="mckhero" state="IN_SCENE" id="1">
+            <position x="-16.18" y="9.17" z="29.55"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Hesindiane" state="IN_SCENE" id="101">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Hagen" state="IN_SCENE" id="102">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Thorben" state="IN_SCENE" id="103">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Larissia" state="IN_SCENE" id="104">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Wachoffizier" state="IN_SCENE" id="105">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Wache" state="IN_SCENE" id="106">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+            <property name="name" type="STRING" data="Wache 1"/>
+        </gameobject>
+		<gameobject class="Wache" state="IN_SCENE" id="107">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+            <property name="name" type="STRING" data="Wache 2"/>
+        </gameobject>
+		<gameobject class="Rafur" state="IN_SCENE" id="201">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Dieb" state="IN_SCENE" id="202">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Advokat" state="IN_SCENE" id="203">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Handlanger" state="IN_SCENE" id="204">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+		<gameobject class="Leibwaechter" state="IN_SCENE" id="205">
+            <position x="2.5935" y="2.88005" z="-10.0237"/>
+            <rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/>
+            <scale x="1.0" y="1.0" z="1.0"/>
+		</gameobject>
+    </nodes>
+</scene>
\ No newline at end of file

Modified: modules/ruchin/scripts/maps/ruchin.rb
===================================================================
--- modules/ruchin/scripts/maps/ruchin.rb	2009-02-08 16:22:35 UTC (rev 4744)
+++ modules/ruchin/scripts/maps/ruchin.rb	2009-02-08 22:46:14 UTC (rev 4745)
@@ -1,31 +1,14 @@
 load "embed.rb"
 $World = $CORE.getWorld()
 require 'player.rb'
-require 'mckhero.rb'
-require 'npc.rb'
 
 
 $SCRIPT.log("Initialize world");
-loader = MapLoader.new("ruchin");
-loader.loadMap("ruchin_lightzones.rlmap.xml");
 $PM.setEnabled(true);
 $CORE.getWorld().setSkyBox(true, "rl/dsa07", 100.0);
 $World.setFog( World::FOG_EXP, [0.658,0.7568,0.9137,1.0], 0.00049, 0.8, 4.0);
 
 $SCRIPT.log("Initialize hero");
-$hero = $GOM.createGameObject("mckhero", 1);
-$hero.placeIntoScene();
-$hero.setPosition([ -35.3738746643066, -5.64282417297363, -64.6520767211914]);
-$hero.setOrientation([ [ -4.43614335381426e-005, -0.999999940395355, -3.53998184436932e-005 ] , 67.3891525268555]);
+$hero = $GOM.getGameObject(1);
 PlayerSettings.preparePlayer($hero);
 PartyManager.getSingleton().setActiveCharacter($hero)
-
-$SCRIPT.log("Initialize NPCs");
-$SCRIPT.log("Hesindiane...");
-Hesindiane = $GOM.createGameObject("Hesindiane", 2);
-Hesindiane.placeIntoScene();
-Hesindiane.setPosition([ 123.848808288574, 0.264747649431229, -46.4587249755859]);
-Hesindiane.setOrientation([ [ -1.40737538458779e-005, 1.0, -0.000235967105254531 ] , 230.07991027832]);
-HesindianeBot = $AI.loadBot("Hesindiane", "nscs.xml");
-HesindianeBot.setNonPlayerCharacter(Hesindiane);
-#Hesindiane.addAction(TalkAction.new("Hesindiane", "nscs.xml");

Modified: modules/ruchin/scripts/moduleconfig.rb
===================================================================
--- modules/ruchin/scripts/moduleconfig.rb	2009-02-08 16:22:35 UTC (rev 4744)
+++ modules/ruchin/scripts/moduleconfig.rb	2009-02-08 22:46:14 UTC (rev 4745)
@@ -23,10 +23,12 @@
     end
 
     def start()
+        require 'mckhero.rb'
 		require 'clothing.rb'
-		
+		require 'npc.rb'
+
 		SceneManager::getSingleton().loadScene("ruchin", false);
-        load "maptest.rb"
+        load "ruchin.rb"
         $World = $CORE.getWorld();
     end
 end



From blakharaz at mail.berlios.de  Sun Feb  8 23:51:07 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 8 Feb 2009 23:51:07 +0100
Subject: [Dsa-hl-svn] r4746 - rl/trunk/engine/script/src
Message-ID: <200902082251.n18Mp784019812@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-08 23:51:06 +0100 (Sun, 08 Feb 2009)
New Revision: 4746

Modified:
   rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
Log:
Removed NULL pointer when a game object could not be created (e.g. because Ruby class does not exist)

Modified: rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-02-08 22:46:14 UTC (rev 4745)
+++ rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-02-08 22:51:06 UTC (rev 4746)
@@ -1,114 +1,123 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "GameObjectNodeProcessor.h"
-
-#include <xercesc/dom/DOM.hpp>
-
-#include "GameObject.h"
-#include "GameObjectManager.h"
-
-using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
-
-namespace rl
-{
-    bool GameObjectNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
-    {
-        if (!hasNodeName(nodeElem, "gameobject"))
-        {
-            return false;
-        }
-
-        LOG_DEBUG(Logger::RULES,
-            "Processing game object node "
-                + getAttributeValueAsStdString(nodeElem, "name"));
-
-        Ogre::String classname = getAttributeValueAsStdString(nodeElem, "class");
-
-        unsigned int goid = GameObject::NO_OBJECT_ID;
-
-        if (hasAttribute(nodeElem, "id"))
-        {
-            goid = getAttributeValueAsInteger(nodeElem, "id");
-        }
-
-        GameObject* go = GameObjectManager::getSingleton().getGameObject(goid);
-        if(!go)
-        {
-            go = GameObjectManager::getSingleton().createGameObject(classname, goid);
-
-            DOMElement* posElem = getChildNamed(nodeElem, "position");
-            if (posElem != NULL)
-            {
-                Vector3 pos = processVector3(posElem);
-                go->setPosition(pos);
-            }
-
-            DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
-            if (oriElem != NULL)
-            {
-                Quaternion ori = processQuaternion(oriElem);
-                go->setOrientation(ori);
-            }
-
-            DOMNodeList* goElChildNodes = nodeElem->getChildNodes();
-            for (XMLSize_t idx = 0; idx < goElChildNodes->getLength(); idx++)
-            {
-                DOMNode* cur = goElChildNodes->item(idx);
-                if (cur->getNodeType() == DOMNode::ELEMENT_NODE
-                    && hasNodeName(cur, "property"))
-                {
-                    PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(cur));
-                    if (propEntry.first != "")
-                    {
-                        go->setProperty(propEntry.first, propEntry.second);
-                    }
-                }
-            } 		    
-        }
-
-        GameObjectState state = GOS_IN_SCENE;
-        if (hasAttribute(nodeElem, "state"))
-	    {
-		    Ogre::String stateStr = getAttributeValueAsStdString(nodeElem, "state");
-		    if (stateStr == "LOADED")
-		    {
-			    state = GOS_LOADED;
-		    }
-		    else if (stateStr == "HELD")
-		    {
-			    state = GOS_HELD;
-		    }
-		    else if (stateStr == "IN_POSSESSION")
-		    {
-			    state = GOS_IN_POSSESSION;
-		    }
-		    else if (stateStr == "IN_SCENE")
-		    {
-			    state = GOS_IN_SCENE;
-		    }
-		    else if (stateStr == "READY")
-		    {
-			    state = GOS_READY;
-		    }
-	    }
-		go->setState(state);
-
-        return true;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "GameObjectNodeProcessor.h"
+
+#include <xercesc/dom/DOM.hpp>
+
+#include "GameObject.h"
+#include "GameObjectManager.h"
+
+using namespace Ogre;
+using namespace XERCES_CPP_NAMESPACE;
+
+namespace rl
+{
+    bool GameObjectNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    {
+        if (!hasNodeName(nodeElem, "gameobject"))
+        {
+            return false;
+        }
+
+        LOG_DEBUG(Logger::RULES,
+            "Processing game object node "
+                + getAttributeValueAsStdString(nodeElem, "name"));
+
+        Ogre::String classname = getAttributeValueAsStdString(nodeElem, "class");
+
+        unsigned int goid = GameObject::NO_OBJECT_ID;
+
+        if (hasAttribute(nodeElem, "id"))
+        {
+            goid = getAttributeValueAsInteger(nodeElem, "id");
+        }
+
+        GameObject* go = GameObjectManager::getSingleton().getGameObject(goid);
+        if (!go)
+        {
+            go = GameObjectManager::getSingleton().createGameObject(classname, goid);
+            
+            if (!go) // Error creating the GameObject
+            {
+                LOG_ERROR(
+                    "MapLoader", 
+                    "Could not create a game object with classid '" 
+                    + classname + "' and id '" + StringConverter::toString(goid) + "'");
+                return true;
+            }
+
+            DOMElement* posElem = getChildNamed(nodeElem, "position");
+            if (posElem != NULL)
+            {
+                Vector3 pos = processVector3(posElem);
+                go->setPosition(pos);
+            }
+
+            DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
+            if (oriElem != NULL)
+            {
+                Quaternion ori = processQuaternion(oriElem);
+                go->setOrientation(ori);
+            }
+
+            DOMNodeList* goElChildNodes = nodeElem->getChildNodes();
+            for (XMLSize_t idx = 0; idx < goElChildNodes->getLength(); idx++)
+            {
+                DOMNode* cur = goElChildNodes->item(idx);
+                if (cur->getNodeType() == DOMNode::ELEMENT_NODE
+                    && hasNodeName(cur, "property"))
+                {
+                    PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(cur));
+                    if (propEntry.first != "")
+                    {
+                        go->setProperty(propEntry.first, propEntry.second);
+                    }
+                }
+            } 		    
+        }
+
+        GameObjectState state = GOS_IN_SCENE;
+        if (hasAttribute(nodeElem, "state"))
+	    {
+		    Ogre::String stateStr = getAttributeValueAsStdString(nodeElem, "state");
+		    if (stateStr == "LOADED")
+		    {
+			    state = GOS_LOADED;
+		    }
+		    else if (stateStr == "HELD")
+		    {
+			    state = GOS_HELD;
+		    }
+		    else if (stateStr == "IN_POSSESSION")
+		    {
+			    state = GOS_IN_POSSESSION;
+		    }
+		    else if (stateStr == "IN_SCENE")
+		    {
+			    state = GOS_IN_SCENE;
+		    }
+		    else if (stateStr == "READY")
+		    {
+			    state = GOS_READY;
+		    }
+	    }
+		go->setState(state);
+
+        return true;
+    }
+}



From blakharaz at mail.berlios.de  Sun Feb  8 23:52:06 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 8 Feb 2009 23:52:06 +0100
Subject: [Dsa-hl-svn] r4747 - rl/trunk/Mac/tools
Message-ID: <200902082252.n18Mq6pQ020330@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-08 23:52:05 +0100 (Sun, 08 Feb 2009)
New Revision: 4747

Modified:
   rl/trunk/Mac/tools/renameinstalldirs.sh
Log:
Some fixes with the Mac OS X library names

Modified: rl/trunk/Mac/tools/renameinstalldirs.sh
===================================================================
--- rl/trunk/Mac/tools/renameinstalldirs.sh	2009-02-08 22:51:06 UTC (rev 4746)
+++ rl/trunk/Mac/tools/renameinstalldirs.sh	2009-02-08 22:52:05 UTC (rev 4747)
@@ -1,10 +1,11 @@
 #!/bin/bash
-RASTULLAH_APP_DIR=$1
-RASTULLAH_APP_NAME=$2
+PRODUCTS_DIR=$1
+RASTULLAH_APP_DIR=${1}/${2}
+RASTULLAH_APP_NAME=$3
 RASTULLAH_APP_BIN=${RASTULLAH_APP_DIR}/${RASTULLAH_APP_NAME}
 CEGUI_DIR=${RASTULLAH_APP_DIR}/../Frameworks/CEGUI.framework
 CEGUI_BIN=${CEGUI_DIR}/CEGUI
-RASTULLAH_RES_DIR=$1/../Resources
+RASTULLAH_RES_DIR=${RASTULLAH_APP_DIR}/../Resources
 
 #TODO: Replace the absolute source paths to something with olist -L $RASTULLAH_APP_NAME and grep
 
@@ -19,7 +20,13 @@
     $RASTULLAH_RES_DIR/libRlUi.dylib \
     $RASTULLAH_RES_DIR/libboost_filesystem.dylib \
     $RASTULLAH_RES_DIR/libboost_system.dylib \
-    $RASTULLAH_RES_DIR/RlScript.bundle"
+    $RASTULLAH_RES_DIR/RlScript.bundle \
+    $PRODUCTS_DIR/libRlAi.dylib \
+    $PRODUCTS_DIR/libRlCommon.dylib \
+    $PRODUCTS_DIR/libRlCore.dylib \
+    $PRODUCTS_DIR/libRlRules.dylib \
+    $PRODUCTS_DIR/libRlScript.dylib \
+    $PRODUCTS_DIR/libRlUi.dylib"
 
 # RL Application binary
 for cur in $RL_BINARIES 



From blakharaz at mail.berlios.de  Sun Feb  8 23:52:15 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 8 Feb 2009 23:52:15 +0100
Subject: [Dsa-hl-svn] r4748 - rl/trunk/Mac/Rastullah.xcodeproj
Message-ID: <200902082252.n18MqFDK020366@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-08 23:52:13 +0100 (Sun, 08 Feb 2009)
New Revision: 4748

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
Log:
Some fixes with the Mac OS X library names

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2009-02-08 22:52:05 UTC (rev 4747)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2009-02-08 22:52:13 UTC (rev 4748)
@@ -829,7 +829,7 @@
 			isa = PBXContainerItemProxy;
 			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
 			proxyType = 1;
-			remoteGlobalIDString = 8D0C4E890486CD37000505A6 /* Rastullah */;
+			remoteGlobalIDString = 8D0C4E890486CD37000505A6;
 			remoteInfo = Rastullah;
 		};
 /* End PBXContainerItemProxy section */
@@ -3129,7 +3129,7 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR}/Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
+			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR} Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
 		};
 /* End PBXShellScriptBuildPhase section */
 



From melven at mail.berlios.de  Mon Feb  9 19:45:00 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 19:45:00 +0100
Subject: [Dsa-hl-svn] r4749 - in rl/branches/newton20:
	Mac/Rastullah.xcodeproj Mac/tools editors/Lockenwickler
	editors/Lockenwickler/_eric4project editors/Lockenwickler/src
	editors/Lockenwickler/src/media engine/core/include
	engine/core/src engine/script/src
Message-ID: <200902091845.n19Ij05d005429@sheep.berlios.de>

Author: melven
Date: 2009-02-09 19:44:47 +0100 (Mon, 09 Feb 2009)
New Revision: 4749

Added:
   rl/branches/newton20/editors/Lockenwickler/src/SelectionBuffer.py
   rl/branches/newton20/editors/Lockenwickler/src/media/PlainColor.cg
Modified:
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/Mac/tools/renameinstalldirs.sh
   rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/newton20/editors/Lockenwickler/src/
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py
   rl/branches/newton20/editors/Lockenwickler/src/media/
   rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/branches/newton20/engine/core/include/PhysicsManager.h
   rl/branches/newton20/engine/core/src/PhysicsManager.cpp
   rl/branches/newton20/engine/script/src/GameObjectNodeProcessor.cpp
Log:
-merged changes from trunk
-updated code for last version of OgreNewt


Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2009-02-09 18:44:47 UTC (rev 4749)
@@ -829,7 +829,7 @@
 			isa = PBXContainerItemProxy;
 			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
 			proxyType = 1;
-			remoteGlobalIDString = 8D0C4E890486CD37000505A6 /* Rastullah */;
+			remoteGlobalIDString = 8D0C4E890486CD37000505A6;
 			remoteInfo = Rastullah;
 		};
 /* End PBXContainerItemProxy section */
@@ -3129,7 +3129,7 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR}/Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
+			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR} Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
 		};
 /* End PBXShellScriptBuildPhase section */
 

Modified: rl/branches/newton20/Mac/tools/renameinstalldirs.sh
===================================================================
--- rl/branches/newton20/Mac/tools/renameinstalldirs.sh	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/Mac/tools/renameinstalldirs.sh	2009-02-09 18:44:47 UTC (rev 4749)
@@ -1,10 +1,11 @@
 #!/bin/bash
-RASTULLAH_APP_DIR=$1
-RASTULLAH_APP_NAME=$2
+PRODUCTS_DIR=$1
+RASTULLAH_APP_DIR=${1}/${2}
+RASTULLAH_APP_NAME=$3
 RASTULLAH_APP_BIN=${RASTULLAH_APP_DIR}/${RASTULLAH_APP_NAME}
 CEGUI_DIR=${RASTULLAH_APP_DIR}/../Frameworks/CEGUI.framework
 CEGUI_BIN=${CEGUI_DIR}/CEGUI
-RASTULLAH_RES_DIR=$1/../Resources
+RASTULLAH_RES_DIR=${RASTULLAH_APP_DIR}/../Resources
 
 #TODO: Replace the absolute source paths to something with olist -L $RASTULLAH_APP_NAME and grep
 
@@ -19,7 +20,13 @@
     $RASTULLAH_RES_DIR/libRlUi.dylib \
     $RASTULLAH_RES_DIR/libboost_filesystem.dylib \
     $RASTULLAH_RES_DIR/libboost_system.dylib \
-    $RASTULLAH_RES_DIR/RlScript.bundle"
+    $RASTULLAH_RES_DIR/RlScript.bundle \
+    $PRODUCTS_DIR/libRlAi.dylib \
+    $PRODUCTS_DIR/libRlCommon.dylib \
+    $PRODUCTS_DIR/libRlCore.dylib \
+    $PRODUCTS_DIR/libRlRules.dylib \
+    $PRODUCTS_DIR/libRlScript.dylib \
+    $PRODUCTS_DIR/libRlUi.dylib"
 
 # RL Application binary
 for cur in $RL_BINARIES 

Modified: rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2009-02-09 18:44:47 UTC (rev 4749)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-08, 13:55:11 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>
@@ -37,6 +37,7 @@
     <Source>src/NewModuleWizard.py</Source>
     <Source>src/Ui_NewModuleWizard.py</Source>
     <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>

Modified: rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-09 18:44:47 UTC (rev 4749)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-08, 13:55:11 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-09 18:44:47 UTC (rev 4749)
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-01-26, 17:27:44 -->
+<!-- Saved: 2009-02-08, 13:55:11 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-01-26, 17:23:59</Created>
+    <Created>2009-02-08, 11:32:14</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
       <Linenumber>416</Linenumber>


Property changes on: rl/branches/newton20/editors/Lockenwickler/src
___________________________________________________________________
Name: svn:ignore
   - ogre.cfg

   + ogre.cfg
SelectionBuffer - Kopie.py


Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2009-02-09 18:44:47 UTC (rev 4749)
@@ -260,11 +260,11 @@
         self.moduleName = ""
         self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
 
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
-
+        
         og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
@@ -298,7 +298,7 @@
         self.moduleManager.cutObjects()
 
     def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
 
     def actionSelectSlot(self):
         self.moduleManager.pivot.hide()
@@ -397,11 +397,11 @@
 
     def keyPressEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
+            self.ogreMainWindow.keyPressEvent(event)
 
     def keyReleaseEvent(self,  event):
         if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
+            self.ogreMainWindow.keyReleaseEvent(event)
         pass
 
     def connectActionButtons(self):

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-09 18:44:47 UTC (rev 4749)
@@ -1,174 +1,176 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MyListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MyListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream << self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData("application/x-static_model", data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class ModelSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
-                               self.updateModelList)
-
-        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
-                               self.setPreviewedModel)
-
-        self.modelList = []
-
-        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName("modelPreviewDialog")
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.modelSearchBox = QLineEdit(self)
-        self.modelSearchBox.setObjectName("modelSearchBox")
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName("splitter")
-
-        self.listWidget = MyListWidget(self.splitter)
-        self.listWidget.setObjectName("listWidget")
-
-        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
-        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
-                                                         self.splitter)
-        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
-
-    def setPreviewedModel(self):
-        if self.ent != None:
-            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
-
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
-                                                                 str(self.listWidget.currentItem().text()))
-        self.node.attachObject(self.ent)
-        self.node.setScale(og.Vector3(1,1,1))
-        bb = self.ent.getBoundingBox()
-
-    def scanDirForModels(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForModels(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(".mesh"):
-                    self.modelList.append(file)
-                    self.listWidget.addItem(file)
-
-        self.listWidget.sortItems()
-
-    def updateModelList(self, text):
-        self.listWidget.clear()
-        for model in self.modelList:
-            if model.find(text) != -1:
-               self.listWidget.addItem(model)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() < 0:
-                self.ogreModelPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreModelPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
-                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MyListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MyListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData("application/x-static_model", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
+                               self.updateModelList)
+
+        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName("modelPreviewDialog")
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.modelSearchBox = QLineEdit(self)
+        self.modelSearchBox.setObjectName("modelSearchBox")
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.listWidget = MyListWidget(self.splitter)
+        self.listWidget.setObjectName("listWidget")
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
+                                                         self.splitter)
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(".mesh"):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() < 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2009-02-09 18:44:47 UTC (rev 4749)
@@ -30,10 +30,11 @@
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+from SelectionBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
 
+
 #                <zone name="Testzone">
 #                        <area type="sphere">
 #                                <position x="-10" y="0" z="-5"/>
@@ -339,7 +340,8 @@
             cmd = join(self.moduleRoot, "maps/*.rlscene")
             sceneFile = glob.glob(cmd)
             self.loadScenes(sceneFile)
-
+            
+        
     def loadScenes(self, sceneFiles):
         for f in sceneFiles:
             self.scenes.append(Scene(self.moduleRoot, f, self.sceneManager, self.ogreRoot, self.gocManager))
@@ -376,8 +378,6 @@
 
         self.moduleCfgPath = ""
 
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
         self.gocManager = GameObjectClassManager()
         # we need to hold a reference to the game object representaions ourself
         # python does not recognize the a reference to a c++ object (Entity in our case) is passed
@@ -391,8 +391,6 @@
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
 
-        self.listenerDings = MyRaySceneQueryListener()
-
         self.moduleExplorer = None
 
         self.lastRay = None
@@ -414,6 +412,8 @@
         self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
         self.moduleConfigIsParsed = False
 
+        self.selectionBuffer = None
+    
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
         self.moduleList = []
@@ -486,28 +486,31 @@
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 
-        self.moduleExplorer.updateView()
+#        self.moduleExplorer.updateView()
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
-#        e.setMaterialName("Lockenwickler_Area")
+#        e.setMaterialName("PlainColor")
+#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
 #
 #        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
-#        e2.setMaterialName("Lockenwickler_Area")
-
+#        e2.setMaterialName("PlainColor")
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
 #        n.attachObject(e)
 #        n.attachObject(e2)
 #        n.setScale(og.Vector3(10, 5, 20))
+#        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
 
     # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        so = None
+        
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        
+        
         if so is not None:
             if not so.isPivot:
                 if not controlDown and not shiftDown:
@@ -680,8 +683,6 @@
 
         self.userSelectionList = []
 
-        self.listenerDings.reset()
-        pass
 
 
     def updatePivots(self):

Modified: rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-02-09 18:44:47 UTC (rev 4749)
@@ -18,7 +18,6 @@
 
 import ctypes
 import ogre.renderer.OGRE as og
-import ogre.physics.OgreNewt as on
 
 # a class to store information about a object that got selected
 class SelectionObject():
@@ -61,12 +60,9 @@
         self.currentRay = None
         self.lastRay = None
 
-        self.World = on.World()
-        self.World.setWorldSize(og.Vector3(-1000000, -1000000, -1000000), og.Vector3(1000000, 1000000, 1000000))
+    #def __del__(self):
+        #del self.World
 
-    def __del__(self):
-        del self.World
-
     # sort algorithm for the selection list
     def sortCompareImp(self,  x,  y):
         if x.distance > y.distance:
@@ -137,33 +133,9 @@
 
 
     def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-        col = on.TreeCollision(self.World, entity.getParentNode(), False)
-        bod = on.Body(self.World, col)
-
-
-        start = ray.getOrigin()
-        end = ray.getPoint(10000)
-
-        retNorm = og.Vector3(0.0, 0.0, 0.0)
-
-        val = on.CollisionRayCast(col, start, end, retNorm)
-#        print val
-#
-#        print retNorm.x
-#        print retNorm.y
-#        print retNorm.z
-        del col
-        self.World.destroyAllBodies()
+        return
         
-        if retNorm.x != 0.0 or retNorm.y != 0.0 or retNorm.z != 0.0:
-#           print "yes"
-           return True
-        else:
-#            print "no"
-            return False
-           
         
-        
 
 #    def iterateEntityUnderMouse(self):
 #        self.previousSelected = self.currentSelected

Modified: rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-09 18:44:47 UTC (rev 4749)
@@ -1,317 +1,323 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreRenderWindow = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-
-        self.setupUi(self)
-
-
-    def setupUi(self, Form):
-        Form.setObjectName("Form")
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName("gridlayout")
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName("splitter")
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
-        self.ogreRenderWindow.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
-        self.ogreRenderWindow.setSizePolicy(sizePolicy)
-        self.ogreRenderWindow.setObjectName("ogreWidget")
-        self.splitterV.addWidget(self.ogreRenderWindow)
-        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreRenderWindow.installEventFilter(self)
-        self.ogreRenderWindow.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreRenderWindow.viewport)
-        self.viewportGrid.enable()
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreRenderWindow.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print "dbg: DragLeave"
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            data = event.mimeData().data("application/x-static_model")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            data = event.mimeData().data("application/x-game_object")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        return self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
-
-        mouseRay = self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(mouseRay)
-
-
-    def updateCamera(self):
-        if self.moveCamForward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreRenderWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreRenderWindow.dollyCamera(og.Vector3( 0.2, 0, 0))
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+
+        self.setupUi(self)
+
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName("ogreWidget")
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print "dbg: DragLeave"
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+
+    def updateCamera(self):
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))

Modified: rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/src/OgreWidget.py	2009-02-09 18:44:47 UTC (rev 4749)
@@ -93,7 +93,13 @@
     def getCamera(self):
         assert(self.camera)
         return self.camera
-
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
     #(const Ogre::Radian& horz, const Ogre::Radian& vert)
     def orbitCamera( self, horz, vert):
         #orbit around focus node

Copied: rl/branches/newton20/editors/Lockenwickler/src/SelectionBuffer.py (from rev 4748, rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py)


Property changes on: rl/branches/newton20/editors/Lockenwickler/src/media
___________________________________________________________________
Name: svn:ignore
   - .Bpib
skelett.blend

   + .Bpib
skelett.blend
skelett_merged.blend


Modified: rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-09 18:44:47 UTC (rev 4749)
@@ -19,6 +19,8 @@
 
 		pass
 		{
+			lighting off
+
 			ambient 0.0 0.0 1.0 0.5
 			diffuse 0.0 0.0 1.0 0.5
 			specular 0.0 0.0 1.0 0.5 12.5
@@ -94,4 +96,48 @@
 	}
 }
 
- 
+vertex_program PlainColor_VS cg
+{
+	source PlainColor.cg
+	entry_point main_plain_color_vp
+	profiles vs_1_1 arbvp1
+
+	default_params
+	{
+		param_named_auto worldViewProj worldviewproj_matrix		
+	}
+
+}
+
+fragment_program PlainColor_PS cg			
+{
+	source PlainColor.cg		
+	entry_point main_plain_color_fp	
+	profiles ps_1_1 arbfp1
+  
+	default_params
+	{
+		param_named inColor float4 1 1 1 1
+	}
+}	
+
+material PlainColor
+{
+        // Material has one technique
+	technique					
+	{
+                // This technique has one pass
+		pass					
+		{
+                        // Make this pass use the vertex shader defined above
+			vertex_program_ref PlainColor_VS	
+			{
+			}
+                        // Make this pass use the pixel shader defined above
+			fragment_program_ref PlainColor_PS	
+			{
+			      param_named_auto inColor custom 1
+			}
+		}
+	}
+}

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/PlainColor.cg (from rev 4748, rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg)

Modified: rl/branches/newton20/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicsManager.h	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/engine/core/include/PhysicsManager.h	2009-02-09 18:44:47 UTC (rev 4749)
@@ -30,7 +30,6 @@
 
 namespace OgreNewt {
     class Body;
-    class Debugger;
     class MaterialID;
     class MaterialPair;
     class World;
@@ -277,7 +276,7 @@
         static Ogre::String convertGeometryTypeToString(const GeometryType& geomType);
 
         /// returns newton debugger
-        OgreNewt::Debugger* getNewtonDebugger() {return mNewtonDebugger;}
+        OgreNewt::Debugger* getNewtonDebugger() {return &mWorld->getDebugger();}
 
     private:
 
@@ -303,8 +302,6 @@
         bool mEnabled;
         //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
-        //! the visualisation for physical behaviour (actually not the best)
-        OgreNewt::Debugger* mNewtonDebugger;
         //! debug mode: 0 no debugging, 1 show debug lines (freezed state), 2 show debug lines (update every frame), 3 show raycasts from one frame, 4 upda raycasts every frame
         int mDebugMode;
 

Modified: rl/branches/newton20/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2009-02-09 18:44:47 UTC (rev 4749)
@@ -70,7 +70,6 @@
 
     PhysicsManager::PhysicsManager( )
         : mEnabled(false),
-        mNewtonDebugger(&OgreNewt::Debugger::getSingleton()),
         mPhysicalThings(),
         mDebugMode(0),
         mGravity(0, -9.81, 0),
@@ -99,7 +98,7 @@
         // setup level material
         createMaterialID("level");
 
-        mNewtonDebugger->setMaterialColor(getMaterialID("level"), Ogre::ColourValue::Blue);
+        mWorld->getDebugger().setMaterialColor(getMaterialID("level"), Ogre::ColourValue::Blue);
 
 
         // below here starts 'old' stale fix code that should be removed
@@ -133,7 +132,7 @@
         }
         mMaterials.clear();
 
-        mNewtonDebugger->deInit();
+        mWorld->getDebugger().deInit();
 
         delete mPhysicsCollisionFactory;
         delete mGenericCallback;
@@ -153,7 +152,7 @@
 
         if( mDebugMode == 4 )
         {
-            mNewtonDebugger->clearRaycastsRecorded();
+            mWorld->getDebugger().clearRaycastsRecorded();
         }
 
 
@@ -207,11 +206,11 @@
 
         if( mDebugMode == 2 )
         {
-            mNewtonDebugger->showDebugInformation(mWorld);
+            mWorld->getDebugger().showDebugInformation();
         }
         else if( mDebugMode == 3 )
         {
-            mNewtonDebugger->stopRaycastRecording();
+            mWorld->getDebugger().stopRaycastRecording();
         }
     }
 
@@ -302,27 +301,27 @@
 
     void PhysicsManager::toggleDebugMode()
     {
-        mNewtonDebugger->init(CoreSubsystem::getSingleton().getWorld()->getSceneManager());
+        mWorld->getDebugger().init(CoreSubsystem::getSingleton().getWorld()->getSceneManager());
         mDebugMode = (mDebugMode+1)%5;
         switch(mDebugMode)
         {
             case 0:
-                mNewtonDebugger->stopRaycastRecording();
-                mNewtonDebugger->clearRaycastsRecorded();
-                mNewtonDebugger->hideDebugInformation();
+                mWorld->getDebugger().stopRaycastRecording();
+                mWorld->getDebugger().clearRaycastsRecorded();
+                mWorld->getDebugger().hideDebugInformation();
                 break;
             case 1:
-                mNewtonDebugger->showDebugInformation(mWorld);
+                mWorld->getDebugger().showDebugInformation();
                 break;
             case 2:
                 break;
             case 3:
-                mNewtonDebugger->startRaycastRecording(true);
-                mNewtonDebugger->hideDebugInformation();
+                mWorld->getDebugger().startRaycastRecording(true);
+                mWorld->getDebugger().hideDebugInformation();
                 break;
             case 4:
-                mNewtonDebugger->startRaycastRecording(true);
-                mNewtonDebugger->hideDebugInformation();
+                mWorld->getDebugger().startRaycastRecording(true);
+                mWorld->getDebugger().hideDebugInformation();
                 break;
             default:
                 break;

Modified: rl/branches/newton20/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/GameObjectNodeProcessor.cpp	2009-02-08 22:52:13 UTC (rev 4748)
+++ rl/branches/newton20/engine/script/src/GameObjectNodeProcessor.cpp	2009-02-09 18:44:47 UTC (rev 4749)
@@ -1,114 +1,123 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "GameObjectNodeProcessor.h"
-
-#include <xercesc/dom/DOM.hpp>
-
-#include "GameObject.h"
-#include "GameObjectManager.h"
-
-using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
-
-namespace rl
-{
-    bool GameObjectNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
-    {
-        if (!hasNodeName(nodeElem, "gameobject"))
-        {
-            return false;
-        }
-
-        LOG_DEBUG(Logger::RULES,
-            "Processing game object node "
-                + getAttributeValueAsStdString(nodeElem, "name"));
-
-        Ogre::String classname = getAttributeValueAsStdString(nodeElem, "class");
-
-        unsigned int goid = GameObject::NO_OBJECT_ID;
-
-        if (hasAttribute(nodeElem, "id"))
-        {
-            goid = getAttributeValueAsInteger(nodeElem, "id");
-        }
-
-        GameObject* go = GameObjectManager::getSingleton().getGameObject(goid);
-        if(!go)
-        {
-            go = GameObjectManager::getSingleton().createGameObject(classname, goid);
-
-            DOMElement* posElem = getChildNamed(nodeElem, "position");
-            if (posElem != NULL)
-            {
-                Vector3 pos = processVector3(posElem);
-                go->setPosition(pos);
-            }
-
-            DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
-            if (oriElem != NULL)
-            {
-                Quaternion ori = processQuaternion(oriElem);
-                go->setOrientation(ori);
-            }
-
-            DOMNodeList* goElChildNodes = nodeElem->getChildNodes();
-            for (XMLSize_t idx = 0; idx < goElChildNodes->getLength(); idx++)
-            {
-                DOMNode* cur = goElChildNodes->item(idx);
-                if (cur->getNodeType() == DOMNode::ELEMENT_NODE
-                    && hasNodeName(cur, "property"))
-                {
-                    PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(cur));
-                    if (propEntry.first != "")
-                    {
-                        go->setProperty(propEntry.first, propEntry.second);
-                    }
-                }
-            } 		    
-        }
-
-        GameObjectState state = GOS_IN_SCENE;
-        if (hasAttribute(nodeElem, "state"))
-	    {
-		    Ogre::String stateStr = getAttributeValueAsStdString(nodeElem, "state");
-		    if (stateStr == "LOADED")
-		    {
-			    state = GOS_LOADED;
-		    }
-		    else if (stateStr == "HELD")
-		    {
-			    state = GOS_HELD;
-		    }
-		    else if (stateStr == "IN_POSSESSION")
-		    {
-			    state = GOS_IN_POSSESSION;
-		    }
-		    else if (stateStr == "IN_SCENE")
-		    {
-			    state = GOS_IN_SCENE;
-		    }
-		    else if (stateStr == "READY")
-		    {
-			    state = GOS_READY;
-		    }
-	    }
-		go->setState(state);
-
-        return true;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "GameObjectNodeProcessor.h"
+
+#include <xercesc/dom/DOM.hpp>
+
+#include "GameObject.h"
+#include "GameObjectManager.h"
+
+using namespace Ogre;
+using namespace XERCES_CPP_NAMESPACE;
+
+namespace rl
+{
+    bool GameObjectNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    {
+        if (!hasNodeName(nodeElem, "gameobject"))
+        {
+            return false;
+        }
+
+        LOG_DEBUG(Logger::RULES,
+            "Processing game object node "
+                + getAttributeValueAsStdString(nodeElem, "name"));
+
+        Ogre::String classname = getAttributeValueAsStdString(nodeElem, "class");
+
+        unsigned int goid = GameObject::NO_OBJECT_ID;
+
+        if (hasAttribute(nodeElem, "id"))
+        {
+            goid = getAttributeValueAsInteger(nodeElem, "id");
+        }
+
+        GameObject* go = GameObjectManager::getSingleton().getGameObject(goid);
+        if (!go)
+        {
+            go = GameObjectManager::getSingleton().createGameObject(classname, goid);
+            
+            if (!go) // Error creating the GameObject
+            {
+                LOG_ERROR(
+                    "MapLoader", 
+                    "Could not create a game object with classid '" 
+                    + classname + "' and id '" + StringConverter::toString(goid) + "'");
+                return true;
+            }
+
+            DOMElement* posElem = getChildNamed(nodeElem, "position");
+            if (posElem != NULL)
+            {
+                Vector3 pos = processVector3(posElem);
+                go->setPosition(pos);
+            }
+
+            DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
+            if (oriElem != NULL)
+            {
+                Quaternion ori = processQuaternion(oriElem);
+                go->setOrientation(ori);
+            }
+
+            DOMNodeList* goElChildNodes = nodeElem->getChildNodes();
+            for (XMLSize_t idx = 0; idx < goElChildNodes->getLength(); idx++)
+            {
+                DOMNode* cur = goElChildNodes->item(idx);
+                if (cur->getNodeType() == DOMNode::ELEMENT_NODE
+                    && hasNodeName(cur, "property"))
+                {
+                    PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(cur));
+                    if (propEntry.first != "")
+                    {
+                        go->setProperty(propEntry.first, propEntry.second);
+                    }
+                }
+            } 		    
+        }
+
+        GameObjectState state = GOS_IN_SCENE;
+        if (hasAttribute(nodeElem, "state"))
+	    {
+		    Ogre::String stateStr = getAttributeValueAsStdString(nodeElem, "state");
+		    if (stateStr == "LOADED")
+		    {
+			    state = GOS_LOADED;
+		    }
+		    else if (stateStr == "HELD")
+		    {
+			    state = GOS_HELD;
+		    }
+		    else if (stateStr == "IN_POSSESSION")
+		    {
+			    state = GOS_IN_POSSESSION;
+		    }
+		    else if (stateStr == "IN_SCENE")
+		    {
+			    state = GOS_IN_SCENE;
+		    }
+		    else if (stateStr == "READY")
+		    {
+			    state = GOS_READY;
+		    }
+	    }
+		go->setState(state);
+
+        return true;
+    }
+}



From melven at mail.berlios.de  Mon Feb  9 19:46:10 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 19:46:10 +0100
Subject: [Dsa-hl-svn] r4750 - in dependencies/OgreNewt_ngt: . inc src
Message-ID: <200902091846.n19IkA7H005532@sheep.berlios.de>

Author: melven
Date: 2009-02-09 19:46:03 +0100 (Mon, 09 Feb 2009)
New Revision: 4750

Added:
   dependencies/OgreNewt_ngt/src/OgreNewt_BodyInAABBIterator.cpp
Modified:
   dependencies/OgreNewt_ngt/CMakeLists.txt
   dependencies/OgreNewt_ngt/inc/OgreNewt.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_BodyInAABBIterator.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_World.h
   dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp
Log:
-removed "Singletons" and made former singleton-classes a "part" of the OgreNewt::World
-some changes in the PlayerController (not finished yet!)


Modified: dependencies/OgreNewt_ngt/CMakeLists.txt
===================================================================
--- dependencies/OgreNewt_ngt/CMakeLists.txt	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/CMakeLists.txt	2009-02-09 18:46:03 UTC (rev 4750)
@@ -71,6 +71,7 @@
 SET(OgreNewt_LIB_SRCS
 src/OgreNewt_BasicJoints.cpp
 src/OgreNewt_Body.cpp
+src/OgreNewt_BodyInAABBIterator.cpp
 src/OgreNewt_Collision.cpp
 src/OgreNewt_CollisionPrimitives.cpp
 src/OgreNewt_CollisionSerializer.cpp

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt.h	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt.h	2009-02-09 18:46:03 UTC (rev 4750)
@@ -52,7 +52,8 @@
 
     Problems and missing features in this version
         - PlayerController not finished
-        - only one world is possible, the Debugger and Body
+        - the convexcast seems to have difficulties with more than one contact (I've segfault when debugging it with the OgreNewt::Debugger...)
+          I added a hack, it only creates one contact at the maximum at the moment!
         - this library supports the newton functions for multithreading but there are several functions/classes in this
           library itself, that are not thread safe (I don't need multiple threads)
         - the copied MovableText class (in Tools::OgreAddons) seems to have some graphics error (it's used
@@ -75,7 +76,9 @@
             - added a lots of new simple "iterators":
                 - for Bodies use body = World->getFirstBody() and body = body->getNext()
                 - for the 
-            - BodyIterator renamed to BodyInAABBIterator, it does now only iterate throuch bodies in a specific AABB
+            - BodyIterator renamed to BodyInAABBIterator, it does now only iterate through bodies in a specific AABB
+            - removed "Singleton-classes", the debugger and the BodyInAABBIterator are now part of a World
+              (call world->getDebugger() / world->getBodyInAABBIterator() to use these classes!)
         - added support for trigger-volumes (ConvexCollision::setAsTriggerVolume ...)
         - added support for convexcasts
         - added additional debugging features:

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_BodyInAABBIterator.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_BodyInAABBIterator.h	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_BodyInAABBIterator.h	2009-02-09 18:46:03 UTC (rev 4750)
@@ -28,8 +28,8 @@
 //! Iterate through all bodies in a specific AABB in the world.
 /*!
 	this class is an easy way to loop through all bodies in an AABB in the world, performing some kind of action.
-    if you want to iterate through all bodies, use the world->getFirstBody and body->getNext functions
-    warning: this class is not thread safe
+    if you want to iterate through all bodies, use the world->getFirstBody and body->getNext functions.
+    You can access this class via World::getBodyInAABBIterator()
 */
 class _OgreNewtExport BodyInAABBIterator
 {
@@ -38,62 +38,39 @@
 	/*!
 		This function will be called for every body iterated.  you can put any functionality you might want inside this function.
 	*/
-	typedef boost::function<void(Body*)> IteratorCallback;
+	typedef boost::function<void(const Body*)> IteratorCallback;
 
-	//! init the singleton class.
-	/*!
-		This function must be called before any iterator functions are called!
-		\param world pointer to the OgreNewt::World.  
-	*/
-	void Init( const OgreNewt::World* world ) { m_world = world; }
-
 	//! perform an iteration
 	/*!
 		will call the provided function for all bodies in the world.
 		\param callback pointer to a function to be used
+        \warning you cannot call this functions from different threads at the same time
 	*/
-	void go( const Ogre::AxisAlignedBox &aabb, IteratorCallback callback )
+	void go( const Ogre::AxisAlignedBox &aabb, IteratorCallback callback ) const;
+	template <class c> void go( const Ogre::AxisAlignedBox &aabb, boost::function<void(c*, Body*)> callback, c* instancedClassPointer ) const
 	{
-		m_callback = callback;
-        NewtonWorldForEachBodyInAABBDo(m_world->getNewtonWorld(), &aabb.getMinimum().x, &aabb.getMaximum().x, newtonIterator);
-        
-	}
-	template <class c> void go( const Ogre::AxisAlignedBox &aabb, boost::function<void(c*, Body*)> callback, c* instancedClassPointer )
-	{
 		go ( aabb, boost::bind(callback, instancedClassPointer, _1) );
 	}
 
-	//! get the singleton.
-	/*!
-		The body iterator is a singleton class, only one instance should exist per application.  you can perform many different
-		kinds of iterations by using different callback functions.
-	*/
-	static BodyInAABBIterator& getSingleton()
-	{
-		static BodyInAABBIterator instance;
-		return instance;
-	}
+protected:
+    friend class OgreNewt::World;
+    //! this function must only be used by an instance of the OgreNewt::World class
+    BodyInAABBIterator(const OgreNewt::World* world);
 
-	//! destructor
-	~BodyInAABBIterator() {}
+	const OgreNewt::World*			m_world;
+	mutable IteratorCallback		m_callback;
 
-protected:
+private:
+    //! this function is declared private, so nobody can use it!
+	BodyInAABBIterator();
 
-	BodyInAABBIterator()
-	{
-		m_world = NULL;
-		m_callback = NULL;
-	}
+    //! this function is declared private, so nobody can use it!
+    BodyInAABBIterator(const BodyInAABBIterator&);
 
-	static void _CDECL newtonIterator( const NewtonBody* body )
-	{
-		OgreNewt::Body* bod = (OgreNewt::Body*)NewtonBodyGetUserData( body );
-		getSingleton().m_callback( bod );
-	}
+    //! this function is declared private, so nobody can use it!
+    const BodyInAABBIterator& operator=(const BodyInAABBIterator&);
 
-	const OgreNewt::World*			m_world;
-	IteratorCallback				m_callback;
-    
+	static void _CDECL newtonIterator( const NewtonBody* body );
 };
 
 

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Debugger.h	2009-02-09 18:46:03 UTC (rev 4750)
@@ -25,7 +25,8 @@
 
 	//! For viewing the Newton rigid bodies visually.
 	/*!
-		This class implements a debug view of the Newton world.  it is a Singleton!
+		This class implements a debug view of the Newton world. You can access it via World::getDebugger().
+        It needs to be initialized (call World::getDebugger().init(...)).
 	*/
 	class _OgreNewtExport Debugger
 	{
@@ -33,9 +34,6 @@
 	public:
 		~Debugger();
 
-		//! get the singleton reference
-		static Debugger& getSingleton();
-
 		//! init the debugger.
 		/*
 			\param smgr pointer to your Ogre::SceneManager
@@ -48,9 +46,8 @@
 		//! show the newton world
 		/*!
 			Draws the Newton world as 3D lines with informative text above each body
-			\param world pointer to the OgreNewt::World
 		*/
-		void showDebugInformation( OgreNewt::World* world );
+		void showDebugInformation();
 
 		//! remove lines and text drawn
 		void hideDebugInformation();
@@ -90,10 +87,13 @@
 
         //! this function is used internally
         void addHitBody(const OgreNewt::Body* body);
+
 	protected:
-		Debugger();
-	
-	protected:
+        friend class OgreNewt::World;
+        //! this function must only be used by an instance of the OgreNewt::World class
+        Debugger(const OgreNewt::World* world);
+
+        const OgreNewt::World*        m_world;
 		Ogre::SceneNode*		m_debugnode;
         typedef std::map<int, Ogre::ColourValue> MaterialIdColorMap;
         MaterialIdColorMap      m_materialcolors;
@@ -117,11 +117,20 @@
         typedef std::map<OgreNewt::Body*, BodyDebugData> BodyDebugDataMap;
         BodyDebugDataMap m_cachemap;
 
-        // create debug information for one body
+        //! create debug information for one body
         void processBody(Body* body);
 
 
     private:
+        //! this function is declared private, so nobody can use it!
+        Debugger();
+
+        //! this function is declared private, so nobody can use it!
+        Debugger(const Debugger&);
+
+        //! this function is declared private, so nobody can use it!
+        const Debugger& operator=(const Debugger&);
+
 		static void _CDECL newtonPerPoly( void* userData, int vertexCount, const float* faceVertec, int id );
 	};
 

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_PlayerController.h	2009-02-09 18:46:03 UTC (rev 4750)
@@ -80,8 +80,8 @@
 protected:
     OgreNewt::Body *m_body; // we need this again, because in the joint it's constant!
 
-    Ogre::Real m_forwardSpeed, m_sideSpeed, m_maxStepHeight;
-    Ogre::Radian m_heading, m_maxSlope, m_restitution;
+    Ogre::Real m_forwardSpeed, m_sideSpeed, m_maxStepHeight, m_restitution;
+    Ogre::Radian m_heading, m_maxSlope;
     Ogre::Vector3 m_upVector;
 
     bool m_isInJumpState;
@@ -107,7 +107,8 @@
 
 
     // other parameters
-    int m_maxCollisionsIterations;
+    int m_maxCollisionsIteration;
+    int m_maxContactsCount;
 
     // variables used in submitConstraint
     Ogre::Quaternion m_lastOri;
@@ -130,42 +131,40 @@
     class StaticConvexCast : public OgreNewt::BasicConvexcast
     {
         public:
-            StaticConvexCast(PlayerController *pc, const OgreNewt::World* world,
-                             const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
-                             const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread) :
-                    BasicConvexcast(pc->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread),
-                    m_parent(pc)
-                {}
+            StaticConvexCast(PlayerController *pc) : m_parent(pc) {}
 
+            void go(const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
+                    const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
+            {
+                go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);
+            }
+
             virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexStaticCastPreFilter(body);}
         private:
             OgreNewt::PlayerController* m_parent;
+            using BasicConvexcast::go;
     };
 
     class DynamicConvexCast : public OgreNewt::BasicConvexcast
     {
         public:
-            DynamicConvexCast(PlayerController *pc, const OgreNewt::World* world,
-                             const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
-                             const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread) :
-                    BasicConvexcast(pc->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread),
-                    m_parent(pc)
-                {}
+            DynamicConvexCast(PlayerController *pc) : m_parent(pc) {}
 
+            void go(const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
+                    const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
+            {
+                go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);
+            }
+
             virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexDynamicCastPreFilter(body);}
         private:
             OgreNewt::PlayerController* m_parent;
+            using BasicConvexcast::go;
     };
 
     class AllBodyConvexCast : public OgreNewt::BasicConvexcast
     {
         public:
-            AllBodyConvexCast(PlayerController *pc, const OgreNewt::World* world,
-                             const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
-                             const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread) :
-                    BasicConvexcast(pc->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread),
-                    m_parent(pc)
-                {}
 
             virtual bool userPreFilterCallback(OgreNewt::Body* body) {return m_parent->convexAllBodyCastPreFilter(body);}
         private:

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2009-02-09 18:46:03 UTC (rev 4750)
@@ -1,11 +1,11 @@
 /* 
-	OgreNewt Library
+    OgreNewt Library
 
-	Ogre implementation of Newton Game Dynamics SDK
+    Ogre implementation of Newton Game Dynamics SDK
 
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+    OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
 
-		by Walaber
+        by Walaber
 
 */
 
@@ -25,59 +25,59 @@
 
 //! general raycast
 /*!
-	General class representing a raycast query in the Newton world.  this class should be inherited to create specific raycast behavior.
+    General class representing a raycast query in the Newton world.  this class should be inherited to create specific raycast behavior.
 */
 class _OgreNewtExport Raycast
 {
 public:
 
-	//! constructor
-	Raycast();
-	
-	//! destuctor.
-	virtual ~Raycast();
+    //! constructor
+    Raycast();
+    
+    //! destuctor.
+    virtual ~Raycast();
 
-	//! performs the raycast.  
-	/*!
-		call after creating the object.
-		\param world pointer to the OgreNewt::World
-		\param startpt starting point of ray in global space
-		\param endpt ending point of ray in global space
-	*/
-	void go( const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt );
+    //! performs the raycast.  
+    /*!
+        call after creating the object.
+        \param world pointer to the OgreNewt::World
+        \param startpt starting point of ray in global space
+        \param endpt ending point of ray in global space
+    */
+    void go( const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt );
 
-	//! user callback pre-filter function.
-	/*!
-		This function is an optional pre-filter to completely ignore specific bodies during the raycast.
-		return false from this function to ignore this body, return true (default) to accept it.
-	*/
-	virtual bool userPreFilterCallback( OgreNewt::Body* body ) { return true; }
+    //! user callback pre-filter function.
+    /*!
+        This function is an optional pre-filter to completely ignore specific bodies during the raycast.
+        return false from this function to ignore this body, return true (default) to accept it.
+    */
+    virtual bool userPreFilterCallback( OgreNewt::Body* body ) { return true; }
 
-	//! user callback filter function
-	/*! user callback function.  
-		This function must be implemented by the user.
-		Newton calls this function for each body intersected by the ray.  however it doesn't
-		necessarily go perfect cloest-to-farthest order.
-		return true and the callback will only be called for bodies closer to the start point than the current body.
-		return false and the callback will call for any other bodies, even those farther than the current one.
-	*/
-	virtual bool userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID ) = 0;
+    //! user callback filter function
+    /*! user callback function.  
+        This function must be implemented by the user.
+        Newton calls this function for each body intersected by the ray.  however it doesn't
+        necessarily go perfect cloest-to-farthest order.
+        return true and the callback will only be called for bodies closer to the start point than the current body.
+        return false and the callback will call for any other bodies, even those farther than the current one.
+    */
+    virtual bool userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID ) = 0;
 
-	friend float CollisionPrimitives::TreeCollision::newtonRayCastCallback(float distance, float *normal, int faceId, void *userData);
+    friend float CollisionPrimitives::TreeCollision::newtonRayCastCallback(float distance, float *normal, int faceId, void *userData);
 protected:
-	//! save the last OgreNewt::Body from the newtonRaycastPreFilter to use this for example the TreeCollisionRayCallback
-	OgreNewt::Body *m_treecollisioncallback_lastbody;
+    //! save the last OgreNewt::Body from the newtonRaycastPreFilter to use this for example the TreeCollisionRayCallback
+    OgreNewt::Body *m_treecollisioncallback_lastbody;
 
-	//! save if this body was already added by RayCastCallback from TreeCollision
-	bool m_treecollisioncallback_bodyalreadyadded;
+    //! save if this body was already added by RayCastCallback from TreeCollision
+    bool m_treecollisioncallback_bodyalreadyadded;
 
 private:
 
-	//! callback used for running the raycast itself... used internally
-	static float _CDECL newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersetParam);
+    //! callback used for running the raycast itself... used internally
+    static float _CDECL newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersetParam);
 
-	//! callback used for running the raycast prefilder... used internally
-	static unsigned _CDECL newtonRaycastPreFilter( const NewtonBody* body, const NewtonCollision* collision, void* userData );
+    //! callback used for running the raycast prefilder... used internally
+    static unsigned _CDECL newtonRaycastPreFilter( const NewtonBody* body, const NewtonCollision* collision, void* userData );
 };
 
 
@@ -85,102 +85,114 @@
 
 //! Basic implementation of the raycast
 /*!
-	This class is provided for general raycast use.  it returns information about all bodies hit by the ray.
+    This class is provided for general raycast use.  it returns information about all bodies hit by the ray.
 */
 class _OgreNewtExport BasicRaycast : public Raycast
 {
 public:
-	//! simple class that represents a single raycast rigid body intersection.
-	class _OgreNewtExport BasicRaycastInfo
-	{
-	public:
-		Ogre::Real					mDistance;	//!< dist from point1 of the raycast, in range [0,1].
-		OgreNewt::Body*				mBody;	//!< pointer to body intersected with
-		int							mCollisionID;		//!< collision ID of the primitive hit by the ray (for compound collision bodies)
-		Ogre::Vector3				mNormal;	//!< normal of intersection.
+    //! simple class that represents a single raycast rigid body intersection.
+    class _OgreNewtExport BasicRaycastInfo
+    {
+    public:
+        Ogre::Real        mDistance;     //!< dist from point1 of the raycast, in range [0,1].
+        OgreNewt::Body*   mBody;         //!< pointer to body intersected with
+        int               mCollisionID;  //!< collision ID of the primitive hit by the ray (for compound collision bodies)
+        Ogre::Vector3     mNormal;       //!< normal of intersection.
 
-		BasicRaycastInfo();
-		~BasicRaycastInfo();
+        BasicRaycastInfo();
+        ~BasicRaycastInfo();
         
-                bool operator<(const BasicRaycastInfo& rhs) const
-                {
-                    return mDistance < rhs.mDistance;
-                }
-	};
+        bool operator<(const BasicRaycastInfo& rhs) const
+        {
+            return mDistance < rhs.mDistance;
+        }
+    };
 
 
-	//! constructor
-	/*!
-		performs a raycast, then the results can be queried from the object after creation.
+    //! empty constructor
+    BasicRaycast();
+
+    //! constructor
+    /*!
+        performs a raycast, then the results can be queried from the object after creation.
         \param world pointer to the OgreNewt::World
         \param startpt starting point of the ray in global space
         \param endpt ending point of the ray in global space
         \param sorted sort the results by distance
-        \param prefilter pointer to a prefilter function
-	*/
-	BasicRaycast( const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool sorted);
-	
-	//! destuctor.
-	~BasicRaycast();
+    */
+    BasicRaycast( const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool sorted);
 
-	//! the all-important custom callback function.
-	bool userCallback( Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID );
+    //! perform a raycast
+    /*!
+        performs a raycast, then the results can be queried from the object after creation.
+        \param world pointer to the OgreNewt::World
+        \param startpt starting point of the ray in global space
+        \param endpt ending point of the ray in global space
+        \param sorted sort the results by distance
+    */
+    void go( const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool sorted);
+    
+    //! destuctor.
+    ~BasicRaycast();
 
-	// ------------------------------------------------------
-	// the following functions can be used to retrieve information about the bodies collided by the ray.
-	
-	//! how many bodies did we hit?
-	int getHitCount() const;
+    //! the all-important custom callback function.
+    bool userCallback( Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID );
 
-	//! retrieve the raycast info for a specific hit.
-	BasicRaycastInfo getInfoAt( int hitnum ) const;
+    // ------------------------------------------------------
+    // the following functions can be used to retrieve information about the bodies collided by the ray.
+    
+    //! how many bodies did we hit?
+    int getHitCount() const;
 
-	//! get the closest body hit by the ray.
-	BasicRaycastInfo getFirstHit() const;
+    //! retrieve the raycast info for a specific hit.
+    BasicRaycastInfo getInfoAt( int hitnum ) const;
 
+    //! get the closest body hit by the ray.
+    BasicRaycastInfo getFirstHit() const;
 
+
 private:
 
 
-	// container for results.
-	typedef std::vector<BasicRaycastInfo> RaycastInfoList;
+    // container for results.
+    typedef std::vector<BasicRaycastInfo> RaycastInfoList;
 
-	RaycastInfoList mRayList;
+    RaycastInfoList mRayList;
 };
 
 //! general convexcast
 /*!
-	General class representing a convexcast query in the Newton world.  this class should be inherited to create specific convexcast behavior.
+    General class representing a convexcast query in the Newton world.  this class should be inherited to create specific convexcast behavior.
 */
 class _OgreNewtExport Convexcast
 {
 public:
 
-	//! constructor
-	Convexcast();
-	
-	//! destuctor.
-	virtual ~Convexcast();
+    //! constructor
+    Convexcast();
+    
+    //! destuctor.
+    virtual ~Convexcast();
 
-	//! performs the convexcast.
-	/*!
-		call after creating the object.
-		\param world pointer to the OgreNewt::World
-                \param col pointer to a convex collision shape used for the cast
-		\param startpt starting point of ray in global space
-                \param colori orientation of the collision in global space
-		\param endpt ending point of ray in global space
-                \param maxcontactscount maximum number of contacts that should be saved,
-                       set to 0 if you only need the distance to the first intersection
-	*/
-	void go( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
+    //! performs the convexcast.
+    /*!
+        call after creating the object.
+        \param world pointer to the OgreNewt::World
+        \param col pointer to a convex collision shape used for the cast
+        \param startpt starting point of ray in global space
+        \param colori orientation of the collision in global space
+        \param endpt ending point of ray in global space
+        \param maxcontactscount maximum number of contacts that should be saved,
+               set to 0 if you only need the distance to the first intersection
+    */
+    void go( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
 
-	//! user callback pre-filter function.
-	/*!
-		This function is an optional pre-filter to completely ignore specific bodies during the raycast.
-		return false from this function to ignore this body, return true (default) to accept it.
-	*/
-	virtual bool userPreFilterCallback( OgreNewt::Body* body ) { return true; }
+    //! user callback pre-filter function.
+    /*!
+        This function is an optional pre-filter to completely ignore specific bodies during the raycast.
+        return false from this function to ignore this body, return true (default) to accept it.
+    */
+    virtual bool userPreFilterCallback( OgreNewt::Body* body ) { return true; }
 
 protected:
 
@@ -198,8 +210,8 @@
 
 private:
 
-	//! callback used for running the raycast prefilter... used internally
-	static unsigned _CDECL newtonConvexcastPreFilter( const NewtonBody* body, const NewtonCollision* collision, void* userData );
+    //! callback used for running the raycast prefilter... used internally
+    static unsigned _CDECL newtonConvexcastPreFilter( const NewtonBody* body, const NewtonCollision* collision, void* userData );
 };
 
 
@@ -207,68 +219,67 @@
 
 //! Basic implementation of the convexcast
 /*!
-	This class is provided for general convexcast use.  it returns information about the body hit by the convexcast
+    This class is provided for general convexcast use.  it returns information about the body hit by the convexcast
 */
 class _OgreNewtExport BasicConvexcast : public Convexcast
 {
 public:
-	//! simple class that represents a single convexcast contact
-	class _OgreNewtExport ConvexcastContactInfo
-	{
-	public:
-		//Ogre::Real              mDistance;      //!< dist from point1 of the raycast, in range [0,1].
-		OgreNewt::Body*         mBody;          //!< pointer to body intersected with
-		int                     mCollisionID;   //!< collision ID of the primitive hit by the ray (for compound collision bodies)
-		Ogre::Vector3           mContactNormal; //!< normal of intersection.
-                Ogre::Vector3           mContactPoint;  //!< point of the contact in global space
-                Ogre::Real              mContactPenetration; //!< contact penetration at collision point
+    //! simple class that represents a single convexcast contact
+    class _OgreNewtExport ConvexcastContactInfo
+    {
+    public:
+        //Ogre::Real              mDistance;              //!< dist from point1 of the raycast, in range [0,1].
+        OgreNewt::Body*         mBody;                  //!< pointer to body intersected with
+        int                     mCollisionID;           //!< collision ID of the primitive hit by the ray (for compound collision bodies)
+        Ogre::Vector3           mContactNormal;         //!< normal of intersection.
+        Ogre::Vector3           mContactPoint;          //!< point of the contact in global space
+        Ogre::Real              mContactPenetration;    //!< contact penetration at collision point
 
-		ConvexcastContactInfo();
-		~ConvexcastContactInfo();
-	};
+        ConvexcastContactInfo();
+        ~ConvexcastContactInfo();
+    };
 
 
-        //! empty constructor
-        BasicConvexcast();
+    //! empty constructor
+    BasicConvexcast();
 
-	//! constructor
-	/*!
-		performs a raycast, then the results can be queried from the object after creation.
-		\param world pointer to the OgreNewt::World
-                \param col pointer to a convex collision shape used for the cast
-		\param startpt starting point of ray in global space
-                \param colori orientation of the collision in global space
-		\param endpt ending point of ray in global space
-                \param maxcontactscount maximum number of contacts that should be saved
-                \param prefilter pointer to a prefilter function
-	*/
-	BasicConvexcast( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
+    //! constructor
+    /*!
+        performs a raycast, then the results can be queried from the object after creation.
+        \param world pointer to the OgreNewt::World
+        \param col pointer to a convex collision shape used for the cast
+        \param startpt starting point of ray in global space
+        \param colori orientation of the collision in global space
+        \param endpt ending point of ray in global space
+        \param maxcontactscount maximum number of contacts that should be saved        
+    */
+    BasicConvexcast( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
 
-	//! destuctor.
-	~BasicConvexcast();
+    //! destuctor.
+    ~BasicConvexcast();
 
-	// ------------------------------------------------------
-	// the following functions can be used to retrieve information about the bodies collided by the convexcast.
-	
-	//! how many bodies did we hit? if maxcontactscount is to small, this value will be smaller too!
-	int calculateBodyHitCount() const;
+    // ------------------------------------------------------
+    // the following functions can be used to retrieve information about the bodies collided by the convexcast.
+    
+    //! how many bodies did we hit? if maxcontactscount is to small, this value will be smaller too!
+    int calculateBodyHitCount() const;
 
         //! how many contacts do we have
         int getContactsCount() const;
 
-	//! retrieve the raycast info for a specific hit.
-	ConvexcastContactInfo getInfoAt( int hitnum ) const;
+    //! retrieve the raycast info for a specific hit.
+    ConvexcastContactInfo getInfoAt( int hitnum ) const;
 
         //! retrieve the distance to the first contact (in range [0,1] from startpt to endpt)
         Ogre::Real getDistanceToFirstHit() const;
 };
 
 
-}	// end NAMESPACE OgreNewt
-	
+}    // end NAMESPACE OgreNewt
+    
 
 
 
 
-#endif	// _INCLUDE_OGRENEWT_RAYCAST
+#endif    // _INCLUDE_OGRENEWT_RAYCAST
 

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_World.h	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_World.h	2009-02-09 18:46:03 UTC (rev 4750)
@@ -12,6 +12,8 @@
 
 
 #include "OgreNewt_Prerequisites.h"
+#include "OgreNewt_BodyInAABBIterator.h"
+#include "OgreNewt_Debugger.h"
 #include <boost/function.hpp>
 #include <boost/bind.hpp>
 
@@ -192,14 +194,21 @@
 	//! updates only the collision of the world and call the callback functions if necessary, can be used for an collision only system
 	void CollisionUpdate() { NewtonCollisionUpdate( m_world ); }
     //! to iterate through all bodies call this function and then use body->getNext()
-    Body* getFirstBody();
+    Body* getFirstBody() const;
 
     /*
     //! to iterate through all material-pairs use this function and then call matPair->getNext()
     MaterialGroupID* getFirstMaterialGroupID();
     */
 
+    //! get a bodyInAABBIterator for this world
+    const BodyInAABBIterator& getBodyInAABBIterator() const {return m_bodyInAABBIterator;}
 
+    //! get the debugger for this world
+    /*!
+     * the debugger needs to be initialized (Debugger::init(...) ) in order to work correctly
+    */
+    Debugger& getDebugger() const {return m_debugger;}
 
 protected:
 	
@@ -207,7 +216,11 @@
 	MaterialID* m_defaultMatID;
 
 	LeaveWorldCallback m_leaveCallback;
+    
+    BodyInAABBIterator m_bodyInAABBIterator;
 
+    mutable Debugger m_debugger;
+
 private:
 
 	static void _CDECL newtonLeaveWorld( const NewtonBody* body, int threadIndex );

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp	2009-02-09 18:46:03 UTC (rev 4750)
@@ -14,7 +14,7 @@
 	m_elapsed = 0.0f;
 
 	// add the standard debug viewer.
-	Debugger::getSingleton().init( mgr );
+	W->getDebugger().init( mgr );
 
 	OIS::ParamList pl;
 	size_t windowHnd = 0;
@@ -83,11 +83,11 @@
 
 	if (mKeyboard->isKeyDown(OIS::KC_F3))
 	{
-		Debugger::getSingleton().showDebugInformation( m_World );
+		m_world->getDebugger().showDebugInformation( m_World );
 	}
 	else
 	{
-		Debugger::getSingleton().hideDebugInformation();
+		m_world->getDebugger().hideDebugInformation();
 	}
 
 	

Added: dependencies/OgreNewt_ngt/src/OgreNewt_BodyInAABBIterator.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_BodyInAABBIterator.cpp	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_BodyInAABBIterator.cpp	2009-02-09 18:46:03 UTC (rev 4750)
@@ -0,0 +1,33 @@
+#include "OgreNewt_BodyInAABBIterator.h"
+#include "OgreNewt_World.h"
+
+
+namespace OgreNewt
+{
+
+
+BodyInAABBIterator::BodyInAABBIterator(const OgreNewt::World* world) :
+    m_world(world),
+    m_callback(NULL)
+{
+}
+
+void BodyInAABBIterator::go( const Ogre::AxisAlignedBox &aabb, IteratorCallback callback) const
+{
+    m_callback = callback;
+    NewtonWorldForEachBodyInAABBDo(m_world->getNewtonWorld(), &aabb.getMinimum().x, &aabb.getMaximum().x, BodyInAABBIterator::newtonIterator);
+}
+
+
+void _CDECL BodyInAABBIterator::newtonIterator( const NewtonBody* newtonBody )
+{
+    const OgreNewt::Body* body = (const OgreNewt::Body*) NewtonBodyGetUserData(newtonBody);
+    const NewtonWorld* newtonWorld = NewtonBodyGetWorld(newtonBody);
+    const OgreNewt::World* world = (const OgreNewt::World*) NewtonWorldGetUserData(newtonWorld);
+
+    world->getBodyInAABBIterator().m_callback(body);
+}
+
+
+}
+

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Debugger.cpp	2009-02-09 18:46:03 UTC (rev 4750)
@@ -10,8 +10,9 @@
 //////////////////////////////////////////////////////////
 // DEUBBER FUNCTIONS
 //////////////////////////////////////////////////////////
-Debugger::Debugger()
+Debugger::Debugger(const OgreNewt::World* world)
 {
+    m_world = world;
     m_debugnode = NULL;
     m_defaultcolor = Ogre::ColourValue::White;
 
@@ -25,15 +26,9 @@
 
 Debugger::~Debugger()
 {
-    Debugger::getSingleton().deInit();
+    deInit();
 }
 
-Debugger& Debugger::getSingleton()
-{
-    static Debugger instance;
-    return instance;
-}
-		
 void Debugger::init( Ogre::SceneManager* smgr )
 {
     if( !m_debugnode )
@@ -75,12 +70,12 @@
 }
 
 
-void Debugger::showDebugInformation( OgreNewt::World* world )
+void Debugger::showDebugInformation( )
 {
     m_debugnode->removeAllChildren();
 
     // make the new lines.
-    for( Body* body = world->getFirstBody(); body; body = body->getNext() )
+    for( Body* body = m_world->getFirstBody(); body; body = body->getNext() )
     {
         processBody(body);
     }
@@ -89,7 +84,7 @@
 
     // delete old entries
     BodyDebugDataMap newmap;
-    for(BodyDebugDataMap::iterator it = Debugger::getSingleton().m_cachemap.begin(); it != Debugger::getSingleton().m_cachemap.end(); it++)
+    for(BodyDebugDataMap::iterator it = m_cachemap.begin(); it != m_cachemap.end(); it++)
     {
         if( it->second.m_updated )
             newmap.insert(*it);
@@ -100,7 +95,7 @@
                 delete mo;
         }
     }
-    Debugger::getSingleton().m_cachemap.swap(newmap);
+    m_cachemap.swap(newmap);
 }
 
 void Debugger::hideDebugInformation()
@@ -148,14 +143,14 @@
 
 
     // look for cached data
-    BodyDebugData* data = &Debugger::getSingleton().m_cachemap[bod];
+    BodyDebugData* data = &m_cachemap[bod];
     if( data->m_lastcol == bod->getCollision() ) // use cached data
     {
         // set new position...
         data->m_node->setPosition(pos);
         data->m_node->setOrientation(ori);
         data->m_updated = 1;
-        Debugger::getSingleton().m_debugnode->addChild(data->m_node);
+        m_debugnode->addChild(data->m_node);
         data->m_text->setCaption(oss_info.str());
         data->m_text->setLocalTranslation(bod->getAABB().getSize().y*1.1*Ogre::Vector3::UNIT_Y);
     }
@@ -171,7 +166,7 @@
             data->m_node->setOrientation(ori);
         }
         else
-            data->m_node = Debugger::getSingleton().m_debugnode->createChildSceneNode(pos, ori);
+            data->m_node = m_debugnode->createChildSceneNode(pos, ori);
 
         if( data->m_lines )
             data->m_lines->clear();

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_PlayerController.cpp	2009-02-09 18:46:03 UTC (rev 4750)
@@ -3,6 +3,7 @@
 #include "OgreNewt_Collision.h"
 #include "OgreNewt_CollisionPrimitives.h"
 #include "OgreNewt_World.h"
+#include <vector>
 
 namespace OgreNewt
 {
@@ -11,6 +12,9 @@
     CustomJoint(6, child, NULL),
     m_body(child)
 {
+    // initialize some non settable parameters
+    m_maxCollisionsIteration = 8;
+    m_maxContactsCount = 16;
     // initialize settable values
     m_forwardSpeed = 0;
     m_sideSpeed = 0;
@@ -31,6 +35,8 @@
     // initialize sensor-shape parameters
     m_staticRadiusFactor = 1.125f;
     m_dynamicRadiusFactor = 1.5f;
+    //! TODO I think there's an error with the radius...
+    m_dynamicRadiusFactor = 0.75f;
     m_floorFinderRadiusFactor = 1.0f;
     m_maxPlayerHeightPaddFactor = 0.01f;
     m_sensorShapeSegments = 32;
@@ -138,8 +144,8 @@
     height = aab.getMaximum().y - aab.getMinimum().y;
 
     Ogre::Real rx = aab.getMaximum().x - aab.getMinimum().x;
-    Ogre::Real ry = aab.getMaximum().y - aab.getMinimum().y;
-    radius = std::max(rx,ry);
+    Ogre::Real rz = aab.getMaximum().z - aab.getMinimum().z;
+    radius = std::max(rx,rz) / 2.0f;
 }
 
 
@@ -183,7 +189,69 @@
     m_body->unFreeze();
 }
 
+/*
+// helper class
+class HitBodyCache : public BasicConvexcast::ConvexcastContactInfo
+{
+    public:
+        Ogre::Vector3 mVel;
+        Ogre::Vector3 mOmega;
+        HitBodyCache() {}
+        HitBodyCache(const BasicConvexcast::ConvexcastContactInfo& info) :
+            BasicConvexcast::ConvexcastContactInfo(info)
+        {
+            mVel = mBody->getVelocity();
+            mOmega = mBody->getOmega();
+        }
+};
 
+// helper class
+class HitBodyVector : public std::vector<HitBodyCache>
+{
+    public:
+        void getCollidingBodiesFromConvexcast(const BasicConvexcast& cast)
+        {
+            // find first contact with each body and cache it
+            resize(0);
+            for(int i = 0; i < size(); i++)
+            {
+                int j;
+                for( j = 0; j < size(); j++ )
+                {
+                    if( cast.getInfoAt(i).mBody == at(j).mBody )
+                        break;
+                }
+                if( j == size() )
+                    push_back(HitBodyCache(cast.getInfoAt(0)));
+            }
+        }
+};
+*/
+
+// helper class
+class HitBodyVector : public std::vector<Body*>
+{
+    public:
+        void getCollidingBodiesFromConvexcast(const BasicConvexcast& cast)
+        {
+            // find first contact with each body and cache it
+            resize(0);
+            for(int i = 0; i < size(); i++)
+            {
+                Body* body = cast.getInfoAt(i).mBody;
+                int j;
+                for( j = 0; j < size(); j++ )
+                {
+                    if( body == at(j) )
+                        break;
+                }
+                if( j == size() )
+                    push_back(body);
+            }
+        }
+};
+
+
 void PlayerController::submitConstraint( Ogre::Real timestep, int threadindex )
 {
 
@@ -308,7 +376,197 @@
 
 
 
+
+            // ----------------- DYNAMIC CONVEXCAST ---------------------
+
+            // first cast directly in front of the player
+            Ogre::Vector3 startCast = pos;
+            Ogre::Vector3 endCast = startCast;
+            DynamicConvexCast dynamicConvexCast(this);
+            HitBodyVector hitBodyVec;
+            hitBodyVec.reserve(m_maxContactsCount);
+
+            endCast = startCast + horizontalDesiredVel*timestep;
+            dynamicConvexCast.go(m_dynamicsSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
+
+            for(int iterations = 0; iterations < m_maxCollisionsIteration; iterations++)
+            {
+                bool velocCorrection;
+                Ogre::Real timeToFirstContact;
+                int numOfContacts;
+
+
+                numOfContacts = dynamicConvexCast.getContactsCount();
+                if( numOfContacts == 0 )
+                    break;
+
+                timeToFirstContact = (dynamicConvexCast.getInfoAt(0).mContactPoint - startCast).dotProduct(horizontalDesiredVel) / 
+                                     horizontalDesiredVel.squaredLength();
+                velocCorrection = false;
+
+
+                // correct velocity if the body cannot be pushed and calculate impulse if it can be pushed
+                for(int i = 0; i < numOfContacts; i++)
+                {
+                    Ogre::Real hitMass;
+                    Ogre::Vector3 hitInertia;
+                    Ogre::Vector3 hitNormal;
+                    Body* hitBody = dynamicConvexCast.getInfoAt(i).mBody;
+                    hitBody->getMassMatrix(hitMass, hitInertia);
+                    hitNormal = dynamicConvexCast.getInfoAt(i).mContactNormal;
+                    hitNormal.y = 0;
+                    hitNormal.normalise();
+
+                    if( !canPushBody(hitBody) )
+                    {
+                        Ogre::Real reboundVel, penetrationVel;
+                        Ogre::Real penetration;
+                        penetration = dynamicConvexCast.getInfoAt(i).mContactPenetration;
+                        penetration = std::max(penetration, 0.1f);
+                        penetrationVel = -0.5f/timestep * penetration;
+
+                        reboundVel = horizontalDesiredVel.dotProduct(hitNormal) * (1.0f+m_restitution) + penetrationVel;
+                        if( reboundVel < 0.0f )
+                        {
+                            velocCorrection = true;
+                            horizontalDesiredVel -= hitNormal*reboundVel;
+                        }
+                    }
+                    else // if( !canPushBody(body) )  -> can push body
+                    {
+                        Ogre::Real relVel, projVel, massWeigh, momentumDamper, playerNormalVel;
+                        Ogre::Vector3 hitCenterOfMass, hitPos, hitContactPointVel;
+                        Ogre::Quaternion hitOri;
+
+                        hitBody->getPositionOrientation(hitPos, hitOri);
+                        hitCenterOfMass = hitBody->getCenterOfMass();
+                        // calculate hitContactPointVel
+                        hitCenterOfMass = hitOri*hitCenterOfMass;
+                        hitContactPointVel = hitBody->getOmega() * (dynamicConvexCast.getInfoAt(i).mContactPoint - hitCenterOfMass);
+                        hitContactPointVel.y = 0.0f; //! WHY??
+                        hitContactPointVel += hitBody->getVelocity();
+
+                        massWeigh = mass / (mass + hitMass);
+                        massWeigh = std::min(massWeigh, 0.5f);
+
+                        projVel = hitContactPointVel.dotProduct(hitNormal);
+                        playerNormalVel = horizontalDesiredVel.dotProduct(hitNormal);
+                        relVel = playerNormalVel * massWeigh - projVel;
+                        if( relVel < 0.0f )
+                        {
+                            momentumDamper = 0.1f;
+                            velocCorrection = true;
+                            // correct horizontalDesiredVel
+                            horizontalDesiredVel -= hitNormal*( relVel * (1.0f - momentumDamper) + playerNormalVel*(1.0f - massWeigh) );
+
+                            //apply impulse to hit body
+                            hitBody->addImpulse(hitNormal*relVel*momentumDamper, hitCenterOfMass); // not the real CenterOffMass any more!
+                        }
+                    }
+                }
+
+
+
+                // now restore hit body state and apply a force to archive the hit impulse
+                hitBodyVec.getCollidingBodiesFromConvexcast(dynamicConvexCast);
+                for(int i = 0; i < hitBodyVec.size(); i++)
+                {
+                    Ogre::Real hitMass;
+                    Ogre::Vector3 hitInertia;
+                    Body* hitBody = hitBodyVec[i];
+                    hitBody->getMassMatrix(hitMass, hitInertia);
+
+                    if( canPushBody(hitBody) && mass > 1.0e-3f )
+                    {
+                        Ogre::Vector3 hitPos, force, torque;
+                        Ogre::Quaternion hitOri;
+
+                        hitBody->getPositionOrientation(hitPos, hitOri);
+                        
+                        // calculate the force and the torque to archive the desired push
+                        force = (vel - hitBody->getVelocity())*mass/timestep - hitBody->getForceAcceleration();
+                        hitBody->addForce(force);
+                        
+                        torque = (omega - hitBody->getOmega())/timestep * (hitOri*hitInertia) - hitBody->getTorqueAcceleration();
+                        hitBody->addTorque(torque);
+                    }
+                }
+
+
+                // has the horizontalDesiredVel changed, so we need a new cast?
+                if( timeToFirstContact > 0.01*timestep && velocCorrection )
+                {
+                    endCast = startCast + horizontalDesiredVel*timestep;
+                    dynamicConvexCast.go(m_dynamicsSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
+                }
+            }
+
+
+            // ----------------- STATIC CONVEXCAST ---------------------
+            StaticConvexCast staticConvexCast(this);
+            startCast.y += 0.5f*m_maxStepHeight;
+            endCast = startCast + horizontalDesiredVel*timestep;
+
+            staticConvexCast.go(m_horizontalSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
+            for(int iterations = 0; iterations < m_maxCollisionsIteration; iterations++)
+            {
+                bool velocCorrection;
+                Ogre::Real timeToFirstContact;
+                int numOfContacts;
+
+
+                numOfContacts = staticConvexCast.getContactsCount();
+                if( numOfContacts == 0 )
+                    break;
+
+                timeToFirstContact = (staticConvexCast.getInfoAt(0).mContactPoint - startCast).dotProduct(horizontalDesiredVel) / 
+                                     horizontalDesiredVel.squaredLength();
+                velocCorrection = false;
+
+
+                // correct velocity (like body that can't be pushed above!)
+                for(int i = 0; i < numOfContacts; i++)
+                {
+                    Ogre::Real hitMass;
+                    Ogre::Vector3 hitInertia;
+                    Ogre::Vector3 hitNormal;
+                    Ogre::Real reboundVel, penetrationVel;
+                    Ogre::Real penetration;
+
+                    Body* hitBody = staticConvexCast.getInfoAt(i).mBody;
+                    hitBody->getMassMatrix(hitMass, hitInertia);
+                    hitNormal = staticConvexCast.getInfoAt(i).mContactNormal;
+                    hitNormal.y = 0;
+                    hitNormal.normalise();
+
+                    penetration = staticConvexCast.getInfoAt(i).mContactPenetration;
+                    penetration = std::max(penetration, 0.1f);
+                    penetrationVel = -0.5f/timestep * penetration;
+
+                    reboundVel = horizontalDesiredVel.dotProduct(hitNormal) * (1.0f+m_restitution) + penetrationVel;
+                    if( reboundVel < 0.0f )
+                    {
+                        velocCorrection = true;
+                        horizontalDesiredVel -= hitNormal*reboundVel;
+                    }
+                }
+
+
+                // has the horizontalDesiredVel changed, so we need a new cast?
+                if( timeToFirstContact > 0.01*timestep && velocCorrection )
+                {
+                    endCast = startCast + horizontalDesiredVel*timestep;
+                    staticConvexCast.go(m_horizontalSensorShape, startCast, yawOri, endCast, m_maxContactsCount, threadindex);
+                }
+            }
+//! TODO MISSING FURTHER CASTS ETC
+
+
+
+
+
             // calculate force needed for desired velocity
+            horizontalDesiredVel.y = 0.0f;
             Ogre::Vector3 force = m_body->calculateInverseDynamicsForce(timestep, horizontalDesiredVel);
             Ogre::Vector3 forceAcc = m_body->getForceAcceleration();
             force -= forceAcc;

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-09 18:46:03 UTC (rev 4750)
@@ -3,6 +3,7 @@
 #include "OgreNewt_Debugger.h"
 #include "OgreNewt_World.h"
 #include "OgreNewt_Collision.h"
+#include "OgreNewt_Body.h"
 
 
 namespace OgreNewt
@@ -15,9 +16,9 @@
 
 	void Raycast::go(const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt )
 	{
-        if( Debugger::getSingleton().isRaycastRecording() )
+        if( world->getDebugger().isRaycastRecording() )
         {
-            Debugger::getSingleton().addRay(startpt, endpt);
+            world->getDebugger().addRay(startpt, endpt);
         }
 
         m_treecollisioncallback_lastbody = NULL;
@@ -35,6 +36,7 @@
 		Raycast* me = (Raycast*)userData;
 
 		Body* bod = (Body*)NewtonBodyGetUserData( body );
+        const World* world = bod->getWorld();
 		Ogre::Vector3 normal = Ogre::Vector3( hitNormal[0], hitNormal[1], hitNormal[2] );
 
 
@@ -42,9 +44,9 @@
             return intersectParam;
 
 
-        if( Debugger::getSingleton().isRaycastRecording() && Debugger::getSingleton().isRaycastRecordingHitBodies() )
+        if( world->getDebugger().isRaycastRecording() && world->getDebugger().isRaycastRecordingHitBodies() )
         {
-            Debugger::getSingleton().addHitBody(bod);
+            world->getDebugger().addHitBody(bod);
         }
 
 
@@ -61,6 +63,7 @@
 		Raycast* me = (Raycast*)userData;
 
 		Body* bod = (Body*)NewtonBodyGetUserData( body );
+        const World* world = bod->getWorld();
 
 
         me->m_treecollisioncallback_bodyalreadyadded = false;
@@ -71,9 +74,9 @@
 		else
         {
 
-            if( Debugger::getSingleton().isRaycastRecording() && Debugger::getSingleton().isRaycastRecordingHitBodies() )
+            if( world->getDebugger().isRaycastRecording() && world->getDebugger().isRaycastRecordingHitBodies() )
             {
-                Debugger::getSingleton().addDiscardedBody(bod);
+                world->getDebugger().addDiscardedBody(bod);
             }
 
 			return 0;
@@ -93,16 +96,26 @@
 	BasicRaycast::BasicRaycastInfo::~BasicRaycastInfo() {}
 
 
+	BasicRaycast::BasicRaycast()    {}
+
+
 	BasicRaycast::BasicRaycast(const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool sorted)
         : Raycast()
 	{
-		go( world, startpt, endpt );
-                if( sorted )
-                {
-                    std::sort(mRayList.begin(), mRayList.end());
-                }
+		go( world, startpt, endpt, sorted );
 	}
 
+
+    void BasicRaycast::go(const OgreNewt::World* world, const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool sorted)
+	{
+        Raycast::go( world, startpt, endpt );
+        if( sorted )
+        {
+            std::sort(mRayList.begin(), mRayList.end());
+        }
+	}
+
+
 	BasicRaycast::~BasicRaycast()	{}
 
 
@@ -181,9 +194,9 @@
 	void Convexcast::go(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex)
 	{
 
-        if( Debugger::getSingleton().isRaycastRecording() )
+        if( world->getDebugger().isRaycastRecording() )
         {
-            Debugger::getSingleton().addConvexRay(col, startpt, colori, endpt);
+            world->getDebugger().addConvexRay(col, startpt, colori, endpt);
         }
                 // reserve memory
                 if( mReturnInfoListSize < maxcontactscount )
@@ -195,6 +208,7 @@
                     mReturnInfoListSize = maxcontactscount;
                 }
 
+                memset(mReturnInfoList, 0, sizeof(mReturnInfoList[0])*mReturnInfoListSize);
 		// perform the cast
                 float matrix[16];
                 OgreNewt::Converters::QuatPosToMatrix(colori, startpt, &matrix[0] );
@@ -204,12 +218,19 @@
                                                &mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
                                                mReturnInfoList, mReturnInfoListSize, threadIndex);
 
-            if( Debugger::getSingleton().isRaycastRecording() && Debugger::getSingleton().isRaycastRecordingHitBodies() )
+                //! TODO: that's a hack here!!
+                if( mReturnInfoListLength > 0 )
+                {
+                    mReturnInfoListLength = 1;
+                }
+
+            if( world->getDebugger().isRaycastRecording() && world->getDebugger().isRaycastRecordingHitBodies() )
             {
+                Body* body;
                 for(int i = 0; i < mReturnInfoListLength; i++)
                 {
-                    Body* body = (OgreNewt::Body*) NewtonBodyGetUserData(mReturnInfoList[i].m_hitBody);
-                    Debugger::getSingleton().addHitBody(body);
+                    body = (OgreNewt::Body*) NewtonBodyGetUserData(mReturnInfoList[i].m_hitBody);
+                    world->getDebugger().addHitBody(body);
                 }
             }
 	}
@@ -220,15 +241,16 @@
 		Convexcast* me = (Convexcast*)userData;
 
 		Body* bod = (Body*)NewtonBodyGetUserData( body );
+        const World* world = bod->getWorld();
 
 		if (me->userPreFilterCallback( bod ))
 			return 1;
 		else
         {
 
-            if( Debugger::getSingleton().isRaycastRecording() && Debugger::getSingleton().isRaycastRecordingHitBodies() )
+            if( world->getDebugger().isRaycastRecording() && world->getDebugger().isRaycastRecordingHitBodies() )
             {
-                Debugger::getSingleton().addDiscardedBody(bod);
+                world->getDebugger().addDiscardedBody(bod);
             }
 
 			return 0;
@@ -260,14 +282,15 @@
 	int BasicConvexcast::calculateBodyHitCount() const
         {
             int count = 0;
-            const NewtonBody * bod = NULL;
             for( int i = 0; i < mReturnInfoListLength; i++ )
             {
-                if( bod != mReturnInfoList[i].m_hitBody )
-                {
+                int j;
+                for( j = 0; j < i; j++ )
+                    if( mReturnInfoList[i].m_hitBody == mReturnInfoList[j].m_hitBody )
+                        break;
+
+                if( j == i )
                     count++;
-                    bod = mReturnInfoList[i].m_hitBody;
-                }
             }
 
             return count;

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp	2009-02-09 18:44:47 UTC (rev 4749)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_World.cpp	2009-02-09 18:46:03 UTC (rev 4750)
@@ -7,7 +7,9 @@
 
 
 // Constructor
-World::World()
+World::World() :
+    m_bodyInAABBIterator(this),
+    m_debugger(this)
 {
 	m_limits = Ogre::AxisAlignedBox(Ogre::Vector3(-100,-100,-100), Ogre::Vector3(100,100,100));
 
@@ -83,7 +85,7 @@
 	}
 }
 
-Body* World::getFirstBody()
+Body* World::getFirstBody() const
 {
     NewtonBody* body = NewtonWorldGetFirstBody( m_world );
     if( body )



From melven at mail.berlios.de  Mon Feb  9 21:00:34 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 21:00:34 +0100
Subject: [Dsa-hl-svn] r4751 - in rl/branches/newton20: cmake
	engine/common/include
Message-ID: <200902092000.n19K0Yrj015692@sheep.berlios.de>

Author: melven
Date: 2009-02-09 21:00:32 +0100 (Mon, 09 Feb 2009)
New Revision: 4751

Added:
   rl/branches/newton20/cmake/COPYING-CMAKE-SCRIPTS
Modified:
   rl/branches/newton20/engine/common/include/WriteableDataStreamFormatTarget.h
Log:
-added missing change from trunk


Copied: rl/branches/newton20/cmake/COPYING-CMAKE-SCRIPTS (from rev 4663, rl/trunk/cmake/COPYING-CMAKE-SCRIPTS)

Modified: rl/branches/newton20/engine/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/branches/newton20/engine/common/include/WriteableDataStreamFormatTarget.h	2009-02-09 18:46:03 UTC (rev 4750)
+++ rl/branches/newton20/engine/common/include/WriteableDataStreamFormatTarget.h	2009-02-09 20:00:32 UTC (rev 4751)
@@ -29,4 +29,5 @@
     protected:
         WriteableDataStreamPtr mStream;
     };
-}
\ No newline at end of file
+}
+



From melven at mail.berlios.de  Mon Feb  9 21:01:22 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 21:01:22 +0100
Subject: [Dsa-hl-svn] r4752 - rl/branches/newton20/engine/common/include
Message-ID: <200902092001.n19K1M3E015759@sheep.berlios.de>

Author: melven
Date: 2009-02-09 21:01:20 +0100 (Mon, 09 Feb 2009)
New Revision: 4752

Modified:
   rl/branches/newton20/engine/common/include/Exception.h
Log:
-added missing change from trunk


Modified: rl/branches/newton20/engine/common/include/Exception.h
===================================================================
--- rl/branches/newton20/engine/common/include/Exception.h	2009-02-09 20:00:32 UTC (rev 4751)
+++ rl/branches/newton20/engine/common/include/Exception.h	2009-02-09 20:01:20 UTC (rev 4752)
@@ -24,6 +24,7 @@
 
 #include "CommonPrerequisites.h"
 #include <string>
+#include <iostream>
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 #  include <Windows.h>
@@ -401,7 +402,7 @@
          MessageBox(NULL, message.c_str(), "Meldung",
             MB_OK | MB_ICONINFORMATION | MB_TOPMOST);
 #     else
-         printf(message.c_str());
+         std::cout << message << std::endl;
 #     endif
    }
 
@@ -418,7 +419,7 @@
          MessageBox(NULL, message.c_str(), "Fehler",
             MB_OK | MB_ICONERROR | MB_TOPMOST);
 #     else
-         fprintf(stderr, message.c_str());
+         std::cerr << message << std::endl;
 #     endif
    }
 }



From melven at mail.berlios.de  Mon Feb  9 21:05:58 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 21:05:58 +0100
Subject: [Dsa-hl-svn] r4753 - rl/branches/newton20/engine/common/include
Message-ID: <200902092005.n19K5wdv016163@sheep.berlios.de>

Author: melven
Date: 2009-02-09 21:05:56 +0100 (Mon, 09 Feb 2009)
New Revision: 4753

Modified:
   rl/branches/newton20/engine/common/include/XmlProcessor.h
Log:
-add missing changes from trunk


Modified: rl/branches/newton20/engine/common/include/XmlProcessor.h
===================================================================
--- rl/branches/newton20/engine/common/include/XmlProcessor.h	2009-02-09 20:01:20 UTC (rev 4752)
+++ rl/branches/newton20/engine/common/include/XmlProcessor.h	2009-02-09 20:05:56 UTC (rev 4753)
@@ -23,7 +23,10 @@
 #include <xercesc/sax/ErrorHandler.hpp>
 #include <xercesc/sax2/Attributes.hpp>
 
-class XERCES_CPP_NAMESPACE::SAXParseException;
+namespace XERCES_CPP_NAMESPACE
+{
+    class SAXParseException;
+}
 
 #include "CommonPrerequisites.h"
 



From melven at mail.berlios.de  Mon Feb  9 21:10:03 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 21:10:03 +0100
Subject: [Dsa-hl-svn] r4754 - in rl/branches/newton20/engine: core/include
	ui/include
Message-ID: <200902092010.n19KA3hg016526@sheep.berlios.de>

Author: melven
Date: 2009-02-09 21:10:01 +0100 (Mon, 09 Feb 2009)
New Revision: 4754

Modified:
   rl/branches/newton20/engine/core/include/DotSceneLoader.h
   rl/branches/newton20/engine/core/include/MeshAnimation.h
   rl/branches/newton20/engine/ui/include/RenderSystemConfigComponent.h
Log:
-added missing changes from trunk


Modified: rl/branches/newton20/engine/core/include/DotSceneLoader.h
===================================================================
--- rl/branches/newton20/engine/core/include/DotSceneLoader.h	2009-02-09 20:05:56 UTC (rev 4753)
+++ rl/branches/newton20/engine/core/include/DotSceneLoader.h	2009-02-09 20:10:01 UTC (rev 4754)
@@ -31,8 +31,13 @@
 #include "XmlResourceManager.h"
 #include "XmlPropertyReader.h"
 
-class Ogre::SceneNode;
-class XERCES_CPP_NAMESPACE::DOMElement;
+namespace Ogre {
+	class SceneNode;
+}
+
+namespace XERCES_CPP_NAMESPACE {
+	class DOMElement;
+}
 
 namespace rl {
 

Modified: rl/branches/newton20/engine/core/include/MeshAnimation.h
===================================================================
--- rl/branches/newton20/engine/core/include/MeshAnimation.h	2009-02-09 20:05:56 UTC (rev 4753)
+++ rl/branches/newton20/engine/core/include/MeshAnimation.h	2009-02-09 20:10:01 UTC (rev 4754)
@@ -23,7 +23,10 @@
 #include <map>
 #include "BaseAnimation.h"
 
-class Ogre::Animation;
+namespace Ogre
+{
+	class Animation;
+}
 
 namespace rl {
 

Modified: rl/branches/newton20/engine/ui/include/RenderSystemConfigComponent.h
===================================================================
--- rl/branches/newton20/engine/ui/include/RenderSystemConfigComponent.h	2009-02-09 20:05:56 UTC (rev 4753)
+++ rl/branches/newton20/engine/ui/include/RenderSystemConfigComponent.h	2009-02-09 20:10:01 UTC (rev 4754)
@@ -20,10 +20,13 @@
 #include "UiPrerequisites.h"
 #include "ConfigComponent.h"
 
+namespace Ogre
+{
+    class RenderSystem;
+}
+
 namespace rl
 {
-    class Ogre::RenderSystem;
-
     class _RlUiExport RenderSystemConfigComponent : public ConfigComponent
     {
     public:



From melven at mail.berlios.de  Mon Feb  9 21:57:08 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 21:57:08 +0100
Subject: [Dsa-hl-svn] r4755 - in rl/trunk: . engine/ai/src
	engine/core/include engine/core/src engine/rules/include
	engine/rules/src engine/script/src engine/ui/include engine/ui/src
Message-ID: <200902092057.n19Kv8Zm021425@sheep.berlios.de>

Author: melven
Date: 2009-02-09 21:56:41 +0100 (Mon, 09 Feb 2009)
New Revision: 4755

Modified:
   rl/trunk/CMakeLists.txt
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/core/include/Actor.h
   rl/trunk/engine/core/include/GameEventManager.h
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/include/PhysicsController.h
   rl/trunk/engine/core/include/PhysicsGenericContactCallback.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
   rl/trunk/engine/core/include/SaveAbleFactory.h
   rl/trunk/engine/core/include/SoundManager.h
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/core/src/ActorManager.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/core/src/ListenerObject.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/trunk/engine/core/src/SoundObject.cpp
   rl/trunk/engine/rules/include/AbstractMovement.h
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/JumpHighMovement.cpp
   rl/trunk/engine/rules/src/JumpLongMovement.cpp
   rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/ui/include/CombatControlState.h
   rl/trunk/engine/ui/include/Console.h
   rl/trunk/engine/ui/include/FreeflightControlState.h
   rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h
   rl/trunk/engine/ui/include/ItemDragContainer.h
   rl/trunk/engine/ui/include/ItemIconDragContainer.h
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/include/WindowFadeJob.h
   rl/trunk/engine/ui/src/CombatControlState.cpp
   rl/trunk/engine/ui/src/CombatGui.cpp
   rl/trunk/engine/ui/src/Console.cpp
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
   rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
   rl/trunk/engine/ui/src/WindowFadeJob.cpp
Log:
MOVED TO NEWTON20
(merged newton20 branch)


Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/CMakeLists.txt	2009-02-09 20:56:41 UTC (rev 4755)
@@ -29,7 +29,7 @@
 FIND_PACKAGE(OIS REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
-FIND_PACKAGE(OgreNewt 1.53 REQUIRED)
+FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
 FIND_PACKAGE(OpenSteer REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(Ruby REQUIRED)
@@ -39,6 +39,10 @@
 	SET_FEATURE_INFO(SWIG "" "" "You use an unsupported version of SWIG.")
 ENDIF(NOT SWIG_DIR MATCHES -rl$)
 
+# Compile settings for build types
+SET(CMAKE_CXX_FLAGS_DEBUG "-O0 -g -DDEBUG")
+SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g -DDEBUG")
+
 # Path options
 SET(BINDIR "bin" CACHE STRING "Where to install binaries")
 SET(DATAROOTDIR "${CMAKE_INSTALL_PREFIX}/share" CACHE STRING "Sets the root of data directories to a non-default location")

Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -70,8 +70,8 @@
         Quaternion orientation;
         body->getPositionOrientation(position, orientation);
 
-    	OgreNewt::CollisionPtr collision = body->getCollision();
-    	RlAssert(collision.getPointer(), "Body has no collision!");
+    	const OgreNewt::Collision* collision = body->getCollision();
+    	RlAssert(collision, "Body has no collision!");
     	AxisAlignedBox box = collision->getAABB();
     	Ogre::Vector3 dims = box.getMaximum() - box.getMinimum();
     	OpenSteer::BoxObstacle *obstacle = new OpenSteer::BoxObstacle(dims[0], dims[1], dims[2]);

Modified: rl/trunk/engine/core/include/Actor.h
===================================================================
--- rl/trunk/engine/core/include/Actor.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/Actor.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -144,6 +144,9 @@
         /// Gibt die aktuelle Position des Aktors relativ zur Welt zur?ck
         const Ogre::Vector3& getWorldPosition(void) const;
 
+        /// Ermittelt die aktuelle Geschwindigkeit des Actors, falls moeglich
+        const Ogre::Vector3 getVelocity() const;
+
         /// Setzt die Position des Aktors relativ zu seinem Parent
         void setPosition(const Ogre::Vector3& vec);
         /// Setzt die Position des Aktors relativ zu seinem Parent

Modified: rl/trunk/engine/core/include/GameEventManager.h
===================================================================
--- rl/trunk/engine/core/include/GameEventManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/GameEventManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -130,8 +130,8 @@
 	void removeQueuedDeletionSources();
 
 
-    /// newton collision callback function
-    int userProcess();
+    /// newton collision callback functions
+    void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
 
     /// notify about newton world update
     void notifyNewtonWorldUpdate();

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/GameLoop.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -116,6 +116,7 @@
     unsigned long mSmoothedFrames;
     /// Time cap for frame time, to prevent interpolation problems during spikes.
     Ogre::Real mMaxFrameTime;
+    Ogre::Real mMinFrameTime;
     bool mQuitRequested;
     bool mPaused;
 

Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -120,7 +120,7 @@
         void _detachFromSceneNode(Ogre::SceneNode* node);
 
 		/** ForceCallback for mBody (OgreNewt::Body). */
-        void onApplyForceAndTorque();
+        void onApplyForceAndTorque(float timeStep);
         void addForce(const Ogre::Vector3& force);
 
         void freeze();

Modified: rl/trunk/engine/core/include/PhysicsController.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsController.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsController.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -39,7 +39,7 @@
 		 * to be applied to the associated PhysicalThing object.
 		 * @param thing PhysicalThing to apply force and torque to.
 		 */
-        virtual void OnApplyForceAndTorque(PhysicalThing* thing) = 0;
+        virtual void OnApplyForceAndTorque(PhysicalThing* thing, float timestep) = 0;
     };
 }
 

Modified: rl/trunk/engine/core/include/PhysicsGenericContactCallback.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsGenericContactCallback.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsGenericContactCallback.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -31,12 +31,20 @@
     class _RlCoreExport PhysicsGenericContactCallback : public OgreNewt::ContactCallback
     {
     public:
-        int userBegin();
-        int userProcess();
-        /// This function calls the contact listeners. So any specialised listener overriding
-        /// this one, has to call it explicitly.
-        void userEnd();
-    private:
+        /*!
+         * this function is called, when the aabbs of two bodies overlap, return 0 to indicate, that no contact calculation
+         * should be initiated.
+         * ATTENTION: if 0 is returned, the contact-listeners cannot be called!
+        */
+        virtual int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1,  int threadindex) { return 1; }
+
+        /*!
+         * process user defined contact forces (etc) here
+        */
+        virtual void userProcess( OgreNewt::ContactJoint &contactJoint, Ogre::Real timeStep, int threadid) {}
+
+        //! this function must not be overwritten!
+        void contactsProcess( OgreNewt::ContactJoint &contactJoint, Ogre::Real timeStep, int threadid );
     };
 }
 

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -30,7 +30,6 @@
 
 namespace OgreNewt {
     class Body;
-    class Debugger;
     class MaterialID;
     class MaterialPair;
     class World;
@@ -137,17 +136,17 @@
 		/// Komplette Levelgeometrie aufl?sen
 		void clearLevelGeometry();
 		
-		void toggleDebugMode();
-        bool isDebugMode() const;
+	void toggleDebugMode();
+        int isDebugMode() const;
 
         // Newton callbacks ...
         /// generic force callback. Gravity is applied and the force,
         /// applied via PhysicalThing interface.
-        static void genericForceCallback(OgreNewt::Body* body);
+        static void genericForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         /// special force callback for controlled characters (or monsters even)
         /// those bodies have up vector and are controlled using inverse dynamics
-        static void controlledForceCallback(OgreNewt::Body* body);
+        static void controlledForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         OgreNewt::World* _getNewtonWorld() const;
 
@@ -277,7 +276,7 @@
         static Ogre::String convertGeometryTypeToString(const GeometryType& geomType);
 
         /// returns newton debugger
-        OgreNewt::Debugger* getNewtonDebugger() {return mNewtonDebugger;}
+        OgreNewt::Debugger* getNewtonDebugger() {return &mWorld->getDebugger();}
 
     private:
 
@@ -288,6 +287,7 @@
         struct CollisionInUse
         {
         public:
+            CollisionInUse() : colPtr(NULL), geomType(GT_NONE) {}
             GeometryType geomType;  //! primitive type
             OgreNewt::CollisionPtr colPtr;          //! the collision primitve
         };
@@ -302,9 +302,8 @@
         bool mEnabled;
         //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
-        //! the visualisation for physical behaviour (actually not the best)
-        OgreNewt::Debugger* mNewtonDebugger;
-        bool mDebugMode;
+        //! debug mode: 0 no debugging, 1 show debug lines (freezed state), 2 show debug lines (update every frame), 3 show raycasts from one frame, 4 upda raycasts every frame
+        int mDebugMode;
 
         //! factory for creating new collision primitives
         PhysicsCollisionFactory* mPhysicsCollisionFactory;

Modified: rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -33,11 +33,12 @@
     {
         RaycastInfo() : mDistance(), mBody(), mNormal() {}
         /// dist from point1 of the raycast, in range [0,1].
-        Ogre::Real mDistance;	
+        Ogre::Real mDistance;
         /// pointer to body intersected with
         OgreNewt::Body* mBody;
         /// normal of intersection.
         Ogre::Vector3 mNormal;
+        // the collisionID for compound collisions could be added here, but we didn't need them yet
     };
 
     class _RlCoreExport PhysicsMaterialRaycast : OgreNewt::Raycast
@@ -64,18 +65,76 @@
         * If this param is NULL, every material will be found
         * @param startpt start-point of the cast
         * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
         */
         RaycastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
             const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool invertmat = false);
 
         bool userCallback(OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID);
+
+
+        bool userPreFilterCallback( OgreNewt::Body *body );  // filtering is now done here!
     private:
         RaycastInfo mInfo;
         const MaterialVector *mMaterialVector;
         const OgreNewt::MaterialID* mMaterial;
-        bool mGetNearest;
         bool mInvertMat;
     };
+
+
+
+// --------------------------------------------------------------------------------------
+
+    // we can use the info-class from OgreNewt
+    class _RlCoreExport ConvexcastInfo : public OgreNewt::BasicConvexcast::ConvexcastContactInfo
+    {
+        public:
+            ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo& info);
+            Ogre::Real mDistance;
+    };
+
+    class _RlCoreExport PhysicsMaterialConvexcast : public OgreNewt::BasicConvexcast
+    {
+    public:
+        typedef std::vector<const OgreNewt::MaterialID*> MaterialVector;
+
+        PhysicsMaterialConvexcast();
+
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param material The material, which will be found by the raycast.
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const Ogre::Vector3& endpt, bool invertmat = false);
+        
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param materials a vector with pairs of a material and a boolean value, that describes if this material should be matched or not
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
+            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const Ogre::Vector3& endpt, bool invertmat = false);
+
+
+        bool userPreFilterCallback( OgreNewt::Body *body );
+    private:
+        const MaterialVector *mMaterialVector;
+        const OgreNewt::MaterialID* mMaterial;
+        bool mInvertMat;
+    };
 }
 
 #endif

Modified: rl/trunk/engine/core/include/SaveAbleFactory.h
===================================================================
--- rl/trunk/engine/core/include/SaveAbleFactory.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/SaveAbleFactory.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -41,3 +41,4 @@
 }
 
 #endif
+

Modified: rl/trunk/engine/core/include/SoundManager.h
===================================================================
--- rl/trunk/engine/core/include/SoundManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/SoundManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -83,7 +83,7 @@
         Ogre::NameValuePairList getSettings() const;
 
         /// 3D-Sound aktualisieren.
-        void update();
+        //void update(); // there is no implementation of this function and it is never used!
         /// Den aktiven Treiber zurckgeben.
         SoundDriver* getActiveDriver() const;
         /// Den aktiven Treiber setzen.

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/Actor.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -317,6 +317,10 @@
         {
             return mBone->getPosition();
         }
+        else if (mParent)
+        {
+            return mParent->getPosition();
+        }
         else
         {
             return Vector3::ZERO;
@@ -326,6 +330,22 @@
         }
     }
 
+    const Vector3 Actor::getVelocity() const
+    {
+        if (mPhysicalThing)
+        {
+            return mPhysicalThing->getVelocity();
+        }
+        else if ( mParent )
+        {
+            return mParent->getVelocity();
+        }
+        else
+        {
+            return Vector3::ZERO;
+        }
+    }
+
     const Quaternion& Actor::getOrientation(void) const
     {
         if (mSceneNode)
@@ -336,6 +356,10 @@
         {
             return mBone->getOrientation();
         }
+        else if (mParent)
+        {
+            return mParent->getOrientation();
+        }
         else
         {
             return Quaternion::IDENTITY;
@@ -355,6 +379,10 @@
         {
             return mBone->_getDerivedPosition();
         }
+        else if (mParent)
+        {
+            return mParent->getWorldPosition();
+        }
         else
         {
             return Vector3::ZERO;
@@ -417,6 +445,10 @@
         {
             return mBone->_getDerivedOrientation();
         }
+        else if (mParent)
+        {
+            return mParent->getWorldOrientation();
+        }
         else
         {
             Throw(IllegalStateException,
@@ -533,6 +565,7 @@
         // Erst danach Parent/Child wirklich zuweisen, falls es eine Exception gibt.
         actor->mParent = this;
         mChildren.insert(actor);
+        actor->_update();
     }
 
     void Actor::attachToSlotAxisRot(

Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -291,9 +291,11 @@
         try
         {
             CameraObject* co = new CameraObject(uniquename);
+            // the mass should be as small as possible, so the camera doesn't interact with other bodies,
+            // but setting the mass to 0 means, that the body is static!
             PhysicalThing* pt = PhysicsManager::getSingleton()
                 .createPhysicalThing(GT_SPHERE, co,
-                100.0f, true);
+                0.001f, true);
             PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
             pt->_getBody()->setMaterialGroupID(
                 PhysicsManager::getSingleton().createMaterialID("camera"));

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -283,7 +283,7 @@
         mWorld = new DotSceneOctreeWorld();
         mActorManager->setWorld(mWorld);
 
-        mPhysicsManager = new PhysicsManager();
+        mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
         GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
         LOG_MESSAGE(Logger::CORE,"PhysicsManager erzeugt");
 

Modified: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -492,7 +492,7 @@
                 child = child->getNextSibling();
                 continue;
             }
-            collision.setNull();
+            collision = NULL;
             // am Anfang steht ein Node mit dem Typ
             std::string typeAsString = transcodeToStdString(child->getNodeName());
 
@@ -701,21 +701,21 @@
                 {
                     LOG_MESSAGE(Logger::CORE,
                         " Mesh-Collisions in <collisions> werden momentan noch nicht unterst?tzt (Eintrag wird ignoriert).");
-                    collision.setNull();
+                    collision = NULL;
                 }
 /*
                 else if (typeAsString.compare("meshhull") == 0)  // automatische convexhull mit daten aus mesh
                 {
                     LOG_MESSAGE(Logger::CORE,
                         " Entityhull-Collisions werden momentan noch nicht unterst?tzt (Eintrag wird ignoriert).");
-                    collision.setNull();
+                    collision = NULL;
                 }
 */
                 else
                 {
                     LOG_MESSAGE(Logger::CORE,
                         " > Parse Error beim Erstellen einer Collision; ung?ltiger typ: '"+typeAsString+"' !");
-                    collision.setNull();
+                    collision = NULL;
                     //return OgreNewt::CollisionPtr(NULL);
                 }
 
@@ -723,7 +723,7 @@
 
 
             // Collision dem vektor hinzuf?gen
-            if (!collision.isNull())
+            if (collision != NULL)
                 mCollisions.push_back(collision);
 
             child = child->getNextSibling();
@@ -870,15 +870,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
-                                    newEnt,
-                                    false));
-                    //orientation, pos));
+                                    newEnt));
                     LOG_DEBUG(Logger::CORE, " physical_body 'convexhull' f?r Entity '"+entName+"' erstellt. ");
                 }
                 else if (physical_body.compare("mesh") == 0 || physical_body.compare("auto"))
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, newEnt, false));
+                                    thisWorld, newEnt, true));
                     LOG_DEBUG(Logger::CORE, " physical_body 'mesh' f?r Entity '"+entName+"' erstellt. ");
                 }
                 else
@@ -893,7 +891,7 @@
         }
 
         // zur liste hinzuf?gen
-        if (!collision.isNull())
+        if (collision != NULL)
         {
             mCollisions.push_back(collision);
         }
@@ -908,7 +906,7 @@
 
 
         // wieder aus der liste entfernen, falls mehrere entities hier definiert werden
-        if (!collision.isNull())
+        if (collision != NULL)
         {
             mCollisions.pop_back();
         }

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -207,7 +207,7 @@
                 mBody->getCollision(), orientationA, positionA,
                 actor->getPhysicalThing()->_getBody()->getCollision(),
                 actor->getOrientation(), actor->getPosition(),
-                retA, retB, retNorm);
+                retA, retB, retNorm, 0); // set threadindex to 0, I hope this is ok!
 
         if( intRet == 0 )
             return 0;
@@ -245,6 +245,7 @@
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
         mBody->setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
     }
 
     GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
@@ -262,6 +263,7 @@
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
         mBody->setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
     }
 
 }

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -275,24 +275,28 @@
         return NAME;
     }
 
-    int GameEventManager::userProcess()
+    void GameEventManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int)
     {
-        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(m_body0);
+        OgreNewt::Body* body0 = contactJoint.getBody0();
+        OgreNewt::Body* body1 = contactJoint.getBody1();
+
+        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(body0);
         if( it != mBodyGameAreaMap.end() )
         {
-            it->second->foundCollision(bodyToActor(m_body1));
-            return false;
+            it->second->foundCollision(bodyToActor(body1));
+            return;
         }
 
-        it = mBodyGameAreaMap.find(m_body1);
+        it = mBodyGameAreaMap.find(body1);
         if( it != mBodyGameAreaMap.end() )
         {
-            it->second->foundCollision(bodyToActor(m_body0));
-            return 0;
+            it->second->foundCollision(bodyToActor(body0));
+            return;
         }
 
         LOG_WARNING(Logger::CORE, "Der Kollisionsk?rper konnte keiner GameArea zugeordnet werden!");
-        return 0;
+
+        // there should be no contacts (trigger-volume!), so we don't need to do anything here!
     }
 
     void GameEventManager::notifyNewtonWorldUpdate()

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -40,6 +40,7 @@
           mLastTimes(),
           mSmoothedFrames(3),
           mMaxFrameTime(0.1f),
+          mMinFrameTime(1.0/60),
           mQuitRequested(false),
           mPaused(false)
     {
@@ -138,6 +139,16 @@
         if( elapsedTime < mGameTime )
             unsmoothedFrameTime = 1;
 
+        if( unsmoothedFrameTime < mMinFrameTime*1000 )
+        {
+            usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            elapsedTime = mTimer->getMilliseconds();
+            unsmoothedFrameTime = elapsedTime - mGameTime;
+            if( elapsedTime < mGameTime )
+                unsmoothedFrameTime = 1;
+        }
+
+
         if( unsmoothedFrameTime > mMaxFrameTime*1000 )
         {
             LOG_DEBUG(Logger::CORE, "The current frame time was truncated at maximum.");

Modified: rl/trunk/engine/core/src/ListenerObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ListenerObject.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/ListenerObject.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -71,7 +71,8 @@
         return;
     }
     listener->setPosition(actor->getWorldPosition());
-	listener->setOrientation(actor->getWorldOrientation());
+    listener->setOrientation(actor->getWorldOrientation());
+    listener->setVelocity(actor->getVelocity());
     LOG_DEBUG(Logger::CORE, "Pos Listener: "
         + StringConverter::toString(actor->getWorldPosition().x) + " "
         + StringConverter::toString(actor->getWorldPosition().y) + " "
@@ -81,8 +82,6 @@
         + StringConverter::toString(actor->getWorldOrientation().x) + " "
         + StringConverter::toString(actor->getWorldOrientation().y) + ", "
         + StringConverter::toString(actor->getWorldOrientation().z));
-//    listener->setOrientation(*temp1, *temp1);
-    // TODO Orientation korrigieren
 }
 
 /**

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -145,7 +145,7 @@
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
     {
-        mBody->attachToNode(node);
+        mBody->attachNode(node);
     }
 
     void PhysicalThing::_attachToBone(MeshObject* object, const std::string& boneName )
@@ -189,7 +189,7 @@
         mUpVectorJoint = NULL;
     }
 
-    void PhysicalThing::onApplyForceAndTorque()
+    void PhysicalThing::onApplyForceAndTorque(float timestep)
     {
         Vector3 gravity = mOverrideGravity ?
             mGravity : PhysicsManager::getSingleton().getGravity();
@@ -210,8 +210,10 @@
 
     void PhysicalThing::setMass(Ogre::Real mass)
     {
+        Vector3 inertia;
+        mBody->getMassMatrix(mMass, inertia);
         mMass = mass;
-        mBody->setMass(mass);
+        mBody->setMassMatrix(mass, inertia);
     }
 
     void PhysicalThing::setGravityOverride(bool override, const Vector3& gravity)
@@ -297,7 +299,7 @@
 		else if (mGeometryType == GT_MESH)
 		{
 	        CollisionPtr collision(new TreeCollision(
-				PhysicsManager::getSingleton()._getNewtonWorld(), entity, false));
+				PhysicsManager::getSingleton()._getNewtonWorld(), entity, true));
 		    mBody->setCollision(collision);
 		}
 
@@ -482,7 +484,7 @@
         {
             // prepare for control
             mPhysicsController = controller;
-            mBody->setAutoFreeze(0);
+            //mBody->setAutoFreeze(0);
             mBody->unFreeze();
             mBody->setLinearDamping(0.0f);
             mBody->setAngularDamping(Vector3::ZERO);

Modified: rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -20,22 +20,17 @@
 #include "Actor.h"
 #include "PhysicalThing.h"
 
+
+using namespace Ogre;
+
 namespace rl
 {
-    int PhysicsGenericContactCallback::userBegin()
+    void PhysicsGenericContactCallback::contactsProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
-        return 1;
-    }
+        userProcess(contactJoint, timestep, threadid);
 
-    int PhysicsGenericContactCallback::userProcess()
-    {
-        return 1;
-    }
-
-    void PhysicsGenericContactCallback::userEnd()
-    {
-        Actor* a1 = static_cast<Actor*>(m_body0->getUserData());
-        Actor* a2 = static_cast<Actor*>(m_body1->getUserData());
+        Actor* a1 = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        Actor* a2 = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
         if (a1 && a1->getPhysicalThing()->getContactListener())
         {
             a1->getPhysicalThing()->getContactListener()->

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -70,9 +70,8 @@
 
     PhysicsManager::PhysicsManager( )
         : mEnabled(false),
-        mNewtonDebugger(&OgreNewt::Debugger::getSingleton()),
         mPhysicalThings(),
-        mDebugMode(false),
+        mDebugMode(0),
         mGravity(0, -9.81, 0),
         mTimeFactor(1.0f),
         mWorldAABB(Vector3(-100, -100, -100), Vector3(100, 100, 100)),
@@ -99,8 +98,9 @@
         // setup level material
         createMaterialID("level");
 
-        mNewtonDebugger->setMaterialColor(getMaterialID("level"), Ogre::ColourValue::Blue);
+        mWorld->getDebugger().setMaterialColor(getMaterialID("level"), Ogre::ColourValue::Blue);
 
+
         // below here starts 'old' stale fix code that should be removed
 
         // setup level quadtree extents
@@ -132,6 +132,8 @@
         }
         mMaterials.clear();
 
+        mWorld->getDebugger().deInit();
+
         delete mPhysicsCollisionFactory;
         delete mGenericCallback;
         delete mWorld;
@@ -148,6 +150,12 @@
         //NewtonSetMinimumFrameRate(mWorld->getNewtonWorld(), 1./mMaxTimestep);
 
 
+        if( mDebugMode == 4 )
+        {
+            mWorld->getDebugger().clearRaycastsRecorded();
+        }
+
+
         // Newton kann timesteps zwischen 1/20 und 1/600!
         mElapsed += elapsedTime * mTimeFactor;
         while( mElapsed >= mMaxTimestep)
@@ -156,6 +164,7 @@
             // know if it's really neccessary
             GameEventManager::getSingleton().notifyNewtonWorldUpdate();
 
+
             mWorld->update(mMaxTimestep);
             mElapsed-=mMaxTimestep;
 #ifdef _DEBUG
@@ -165,7 +174,10 @@
                     "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
                 if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
-                    NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);
+                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
+                     body != NULL;
+                     body = NewtonWorldGetNextBody(mWorld->getNewtonWorld(), body)  )
+                    newtonPerBodyLogProperties(body);
             }
 #endif
         }
@@ -183,10 +195,23 @@
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
                     "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
-                if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
-                    NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);            }
+                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
+                     body != NULL;
+                     body = NewtonWorldGetNextBody(mWorld->getNewtonWorld(), body)  )
+                    newtonPerBodyLogProperties(body);
+            }
 #endif
         }
+
+
+        if( mDebugMode == 2 )
+        {
+            mWorld->getDebugger().showDebugInformation();
+        }
+        else if( mDebugMode == 3 )
+        {
+            mWorld->getDebugger().stopRaycastRecording();
+        }
     }
 
 #ifdef _DEBUG
@@ -269,31 +294,38 @@
         mEnabled = enabled;
     }
 
-    bool PhysicsManager::isDebugMode() const
+    int PhysicsManager::isDebugMode() const
     {
         return mDebugMode;
     }
 
     void PhysicsManager::toggleDebugMode()
     {
-        if (mDebugMode)
-		{
-            mNewtonDebugger->hideLines();
-		}
-        else
+        mWorld->getDebugger().init(CoreSubsystem::getSingleton().getWorld()->getSceneManager());
+        mDebugMode = (mDebugMode+1)%5;
+        switch(mDebugMode)
         {
-            mNewtonDebugger = &OgreNewt::Debugger::getSingleton();
-
-			try
-			{
-				mNewtonDebugger->init(
-					CoreSubsystem::getSingleton().getWorld()->getSceneManager());
-			}
-			catch(Ogre::Exception) {}
-
-            mNewtonDebugger->showLines(mWorld);
+            case 0:
+                mWorld->getDebugger().stopRaycastRecording();
+                mWorld->getDebugger().clearRaycastsRecorded();
+                mWorld->getDebugger().hideDebugInformation();
+                break;
+            case 1:
+                mWorld->getDebugger().showDebugInformation();
+                break;
+            case 2:
+                break;
+            case 3:
+                mWorld->getDebugger().startRaycastRecording(true);
+                mWorld->getDebugger().hideDebugInformation();
+                break;
+            case 4:
+                mWorld->getDebugger().startRaycastRecording(true);
+                mWorld->getDebugger().hideDebugInformation();
+                break;
+            default:
+                break;
         }
-        mDebugMode = !mDebugMode;
     }
 
     void PhysicsManager::addLevelGeometry( Ogre::Entity* levelEntity, const std::vector<OgreNewt::CollisionPtr> &collisions)
@@ -303,23 +335,33 @@
 
         SceneNode* node = levelEntity->getParentSceneNode();
         //Level entity has to be attached to a scene node.
+        
 
-        for( size_t i = 0; i < collisions.size(); i++)
+        // try one compound collision for the entity if there are several collisions
+        OgreNewt::CollisionPtr collision(NULL);
+        switch( collisions.size() )
         {
-		    if( collisions[i].isNull() )
-                continue;
+            case 0:
+                break;
+            case 1:
+                collision = collisions[0];
+                break;
+            default:
+                collision = new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions);
+                break;
+        }
 
-            OgreNewt::CollisionPtr collision = collisions[i];
+        if( collision )
+        {
+            OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
 
-		    OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
 
-
-            body->attachToNode(node);
+            body->attachNode(node);
             body->setPositionOrientation(node->_getDerivedPosition(),
                 node->_getDerivedOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
 
-			mLevelBodiesQuadTree.add(body);
+            mLevelBodiesQuadTree.add(body);
             //mLevelBodies.push_back(body);
         }
 
@@ -364,26 +406,23 @@
 		*/
     }
 
-    // adopted from the chararcter demo in the newton sdk
-    // copyright 2000-2004
-    // By Julio Jerez
-    void PhysicsManager::genericForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::genericForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         // apply saved forces in the PhysicalThing
         PhysicalThing* thing =
             static_cast<Actor*>(body->getUserData())->getPhysicalThing();
 
-        thing->onApplyForceAndTorque();
+        thing->onApplyForceAndTorque(timestep);
     }
 
-    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         PhysicalThing* thing =
             static_cast<Actor*>(body->getUserData())->getPhysicalThing();
 
         if (thing->getPhysicsController())
         {
-            thing->getPhysicsController()->OnApplyForceAndTorque(thing);
+            thing->getPhysicsController()->OnApplyForceAndTorque(thing, timestep);
         }
         else
         {
@@ -460,7 +499,15 @@
     void PhysicsManager::resetMaterialPair(const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2)
     {
-        getMaterialPair(M1,M2)->setContactCallback(mGenericCallback);
+        OgreNewt::MaterialPair *mat_pair = getMaterialPair(M1,M2);
+        mat_pair->setContactCallback(mGenericCallback);
+        mat_pair->setContinuousCollisionMode(0);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultElasticity(0.4f);
+        mat_pair->setDefaultSoftness(0.1f);
+        mat_pair->setDefaultFriction(0.9f, 0.5f);
+        //! TODO find a good value here, until now I hope nobody is changing the default from newton :-P
+        //mat_pair->setDefaultSurfaceThickness(); 
     }
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
@@ -480,7 +527,8 @@
         CollisionInUse &usedcol (mCollisionPrimitives[collisionName]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -495,7 +543,28 @@
 
                 if( inertia )
                 {
+
                     // we must set inertia here, the calling function doesn't know we are not creating a new collision
+                    switch(usedcol.geomType)
+                    {
+                    case GT_BOX: // from createBox
+                    case GT_CAPSULE: // from createCapsule
+                    case GT_CONVEXHULL: // from createCollisionFromEntity
+                    case GT_ELLIPSOID: // from createEllipsoid
+                    case GT_PYRAMID: // createPyramid
+                    case GT_SPHERE:
+                        {
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+                            *inertia *= mass;
+                        }
+                        break;
+                    case GT_MESH:
+                    case GT_NONE:
+                        *inertia = Ogre::Vector3::ZERO;
+                        break;
+                    }
+/*
                     Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
                     Vector3 size( aabb.getSize() );
                     switch(usedcol.geomType)
@@ -539,11 +608,12 @@
                         }
                         break;
                     }
+*/
                 }
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromEntity(
@@ -568,7 +638,8 @@
         CollisionInUse &usedcol (mCollisionPrimitives[name]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -582,7 +653,7 @@
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromAABB(
@@ -804,14 +875,13 @@
 			// calculate the convex hull of the animated mesh
 			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-				entity, entity->hasSkeleton(), *orientation, *offset));
+				entity, /*entity->hasSkeleton(),*/ *orientation, *offset));
 
 			if (inertia != NULL)
 			{
-				*inertia = Vector3(
-				size.x*size.x/6.0f,
-				size.y*size.y/6.0f,
-				size.z*size.z/6.0f) * Mass;
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+                            *inertia *= Mass;
 			}
         }
         else if (geomType == GT_MESH)
@@ -821,14 +891,14 @@
 
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-                entity, false, true));
+                entity, true ));
         }
         else
         {
             Throw(IllegalArgumentException, "unknown geometry type.");
         }
 
-        if (rval.isNull())
+        if ( rval == NULL )
         {
             LOG_DEBUG(Logger::CORE, " creating collision primitiv '"+
                 PhysicsManager::convertGeometryTypeToString(geomType)+"' for Entity '"+
@@ -860,13 +930,19 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia)
-            *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
 
-		// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
+        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
@@ -886,12 +962,18 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia)
-            *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
 
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
@@ -914,14 +996,18 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
+ 
+        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            Vector3(radius, radius, radius), *orientation, *offset));
         if (inertia)
-            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
-            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
-
-		// a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-    		PhysicsManager::getSingleton()._getNewtonWorld(),
-            Vector3(radius, radius, radius), *orientation, *offset));
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
@@ -945,13 +1031,20 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia)
-            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
@@ -975,16 +1068,21 @@
     		offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia) {
-            double sradius = radius*radius;
-			*inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
-        }
 
-		// an capsule primitiv has got its coordinate system at its center, so shift it with radius
-		// additionally it is x axis aligned, so rotate it 90 degrees around z axis
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
+
+        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
+        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+        return rval;
     }
+}
 
-}

Modified: rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -23,7 +23,7 @@
 
 namespace rl {
     PhysicsMaterialRaycast::PhysicsMaterialRaycast()
-        : Raycast(), mInfo(), mMaterial(0), mGetNearest(false)
+        : Raycast(), mInfo(), mMaterial(0)
     {
     }
 
@@ -38,7 +38,6 @@
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
 
-        mGetNearest = false;
         go(world, start, end);
 
         return mInfo;
@@ -55,14 +54,66 @@
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
 
-        mGetNearest = false;
         go(world, start, end);
 
         return mInfo;
     }
 
+    bool PhysicsMaterialRaycast::userPreFilterCallback( OgreNewt::Body *body )
+    {
+        if( body->getMaterialGroupID() == NULL )
+        {
+            LOG_MESSAGE(Logger::CORE, "Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!");
+            return true;
+        }
+        else if( body->getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID("gamearea") ) // don't trigger gameareas
+        {
+            return false;
+        }
+        else
+        {
+            if( mMaterial == NULL && mMaterialVector == NULL)
+            {
+                return true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body->getMaterialGroupID()->getID() == mMaterial->getID() && !mInvertMat ||
+                    body->getMaterialGroupID()->getID() != mMaterial->getID() && mInvertMat)
+                {
+                    return true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector->begin(); iter != mMaterialVector->end(); iter++)
+                {
+                    if (body->getMaterialGroupID()->getID() == (*iter)->getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found && !mInvertMat || !found && mInvertMat )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
     bool PhysicsMaterialRaycast::userCallback(Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID)
     {
+        mInfo.mBody = body;
+        mInfo.mDistance = distance;
+        mInfo.mNormal = normal;
+        return true;
+        /*
         if( body->getMaterialGroupID() == NULL )
         {
             mInfo.mBody = body;
@@ -110,14 +161,107 @@
 
                 if( found && !mInvertMat || !found && mInvertMat )
                 {
-                    mInfo.mBody = body;
-                    mInfo.mDistance = distance;
-                    mInfo.mNormal = normal;
                     mGetNearest = true;
                 }
             }
         }
         return mGetNearest;
+        */
     }
 
+
+// -------------------------------------------------------------------------------------------------
+
+    ConvexcastInfo::ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo &info) :
+        ConvexcastContactInfo(info),
+        mDistance(0)
+    {
+    }
+
+    PhysicsMaterialConvexcast::PhysicsMaterialConvexcast() :
+        mMaterialVector(NULL),
+        mMaterial(NULL),
+        mInvertMat(false)
+    {
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const Vector3& endpt, bool invertmat)
+    {
+        mMaterialVector = NULL;
+        mMaterial = material;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1, 0); // set threadindex to 0, I hope this is ok
+
+        ConvexcastInfo info(BasicConvexcast::getInfoAt(0));
+        info.mDistance = getDistanceToFirstHit();
+        return info;
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const MaterialVector* materials,
+                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const Vector3& endpt, bool invertmat)
+    {
+        mMaterialVector = materials;
+        mMaterial = NULL;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1, 0); // set threadindex to 0, I hope this is ok
+
+        ConvexcastInfo info(BasicConvexcast::getInfoAt(0));
+        info.mDistance = getDistanceToFirstHit();
+        return info;
+    }
+
+    bool PhysicsMaterialConvexcast::userPreFilterCallback( OgreNewt::Body *body )
+    {
+        if( body->getMaterialGroupID() == NULL )
+        {
+            LOG_MESSAGE(Logger::CORE, "Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!");
+            return true;
+        }
+        else if( body->getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID("gamearea") ) // don't trigger gameareas
+        {
+            return false;
+        }
+        else
+        {
+            if( mMaterial == NULL && mMaterialVector == NULL)
+            {
+                return true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body->getMaterialGroupID()->getID() == mMaterial->getID() && !mInvertMat ||
+                    body->getMaterialGroupID()->getID() != mMaterial->getID() && mInvertMat)
+                {
+                    return true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector->begin(); iter != mMaterialVector->end(); iter++)
+                {
+                    if (body->getMaterialGroupID()->getID() == (*iter)->getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found && !mInvertMat || !found && mInvertMat )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
 }
+

Modified: rl/trunk/engine/core/src/SoundObject.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundObject.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/SoundObject.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -144,6 +144,7 @@
 void SoundObject::set3d( bool is3d )
 {
 	getSound()->set3d(is3d);
+        _update(); // do we need this here?
 }
 
 void SoundObject::load()

Modified: rl/trunk/engine/rules/include/AbstractMovement.h
===================================================================
--- rl/trunk/engine/rules/include/AbstractMovement.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/include/AbstractMovement.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -26,8 +26,7 @@
 namespace rl
 {
     /// this is the base class of all movements and provides a general interface for movements
-    class AbstractMovement : 
-        public OgreNewt::ContactCallback
+    class AbstractMovement // : public PhysicsGenericContactCallback
     {
     public:
         AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
@@ -55,7 +54,7 @@
          * this method is called, when this movement is currently used to enable 
          * an individual procession of collisions contacts for each movement
          */
-        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
+        virtual void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid) {}
 
         /**
          * this method is called by OnApplyTorqueAndForceCallback of the CreatureController

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/include/CreatureController.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -20,7 +20,6 @@
 
 #include "RulesPrerequisites.h"
 #include "PhysicsController.h"
-#include "PhysicsGenericContactCallback.h"
 #include "PhysicsMaterialRaycast.h"
 #include "Creature.h"
 #include "Actor.h"
@@ -40,8 +39,7 @@
      * It handles all nessessary things like animations and calculates the movement speed.
      */
     class _RlRulesExport CreatureController :
-        public PhysicsController,
-        public PhysicsGenericContactCallback
+        public PhysicsController
     {
     public:
         static const Ogre::String PROPERTY_CREATUREID;
@@ -52,10 +50,10 @@
         bool run(Ogre::Real elapsedTime);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// Newton contact callback called by the movingCreatureManager
-        int userProcess();
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
 
         Creature* getCreature() {return mCreature;}
         bool refetchCreature();
@@ -114,7 +112,7 @@
          * @param direction This is the movement direction in local space.
 		 *                  If the direction isn't possible (see AbstractMovement::isDirectionPossible),
 		 *                  only a "part" of the direction is applied.
-         * @param rotation like above
+         * @param rotation like above (in radians)
          * @retval false signifies that the change to this movement was not possible (possibly because the present movement forbade it)
          */
         bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -60,7 +60,7 @@
         const Ogre::String& getName() const;
 
         // Newton Contact Callback
-        int userProcess();
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
     protected:
         typedef std::map<Creature*, CreatureController*> ControllerMap;
         ControllerMap mControllers;

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -80,7 +80,10 @@
 
         mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
 
+//        mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0*Vector3::UNIT_SCALE);
+        mCreature->getActor()->getPhysicalThing()->_getBody()->setContinuousCollisionMode(1);
 
+
         std::pair<MovementType, AbstractMovement*> movementPair;
         movementPair.first = MT_NONE;
         movementPair.second = NULL;
@@ -154,6 +157,8 @@
                 mCreature->getActor()->getPhysicalThing()->setPhysicsController(NULL);
 
                 mCreature->getActor()->getPhysicalThing()->setMaterialID(mOldMaterialId);
+        
+//                mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0.1*Vector3::UNIT_SCALE);
             }
         }
     }
@@ -170,7 +175,7 @@
     {
         int act_gs = mCreature->getWert(Creature::WERT_GS);
         ///@todo wy does this not work
-        //act_gs -= mCreature->getWert(Creature::WERT_BE);
+        act_gs -= mCreature->getWert(Creature::WERT_BE);
         return max(act_gs,1);
     }
 
@@ -297,7 +302,7 @@
         {
             // find a reason why we now are AL_FLOOR
             if( timeSinceLastFloorContact < Time(Date::ONE_SECOND)*0.19 &&
-                -speed.y < 0.6 )
+                abs(speed.y) < 0.6 )
             {
                 setAbstractLocation(AL_FLOOR);
             }
@@ -306,7 +311,7 @@
         {
             // find a reason why we now are AL_AIRBORNE
             if( timeSinceLastFloorContact >= Time(Date::ONE_SECOND)*0.2 && // 2 seconds?
-                -speed.y > 0.6 )
+                abs(speed.y) > 0.6 )
             {
                 //std::ostringstream oss;
                 //oss << "Raycast for floor: speed.y: " << speed.y << "      timeSinceLastFloorContact: " << timeSinceLastFloorContact;
@@ -316,8 +321,8 @@
 		// find the distance to the floor:
                 // raycasts
                 PhysicsMaterialRaycast::MaterialVector materialVector;
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("default")); // should we perhaps only use level here?
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("level"));
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("camera")); // should we perhaps only use level here?
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("character"));
 
                 Vector3 start = getCreature()->getPosition();
                 Vector3 end = start + Vector3::NEGATIVE_UNIT_Y*0.4;
@@ -325,7 +330,7 @@
                 RaycastInfo info = mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &materialVector,
-                            start, end);
+                            start, end, false);
 
 		if( info.mBody == NULL )
 		{
@@ -359,14 +364,13 @@
         return false;
     }
 
-    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing)
+    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         Vector3 force, torque;
         OgreNewt::Body *body = thing->_getBody();
         force = Vector3::ZERO;
         torque = Vector3::ZERO;
         OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
         Real mass;
         Vector3 inertia;
         body->getMassMatrix(mass, inertia);
@@ -387,12 +391,15 @@
         body->setTorque(torque);
     }
 
-    int CreatureController::userProcess()
+    void CreatureController::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
+for(OgreNewt::Contact contact = contactJoint.getFirstContact(); contact; contact = contact.getNext() )
+{
+
         // own collision handling (floor, in order to get information for mAbstractLocation)
         Vector3 point;
         Vector3 normal;
-        getContactPositionAndNormal(point, normal);
+        contact.getPositionAndNormal(point, normal);
 
         // determine if this contact is with the floor.
         // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
@@ -419,7 +426,32 @@
                 mLastFloorContact = time;
             }
         }
+/*
+//        setContactNormalDirection(((Vector3::UNIT_Y.dotProduct(point-charPos)*Vector3::UNIT_Y + charPos) - point).normalisedCopy());
+        setContactNormalDirection(point - (charPos + charHeight/2));
+        setContactNormalAcceleration(0);
+        setContactFrictionState(0,0);
+        setContactFrictionState(0,1);
+        setContactTangentAcceleration(0, 0);
+        setContactTangentAcceleration(0, 1);
 
+*/
+//std::ostringstream oss;
+//Vector3 vec1, vec2;
+//oss << " Collision: Point: " << point-charPos;
+//    << "  \t Normal: " << normal
+//    << "  \t Force: " << getContactForce()
+//    << "  \t Normal-Speed: " << getContactNormalSpeed()
+//    << "  \t Contact-Speed: " << point
+//    << "  \t Contact-Normal: " << normal;
+//getContactTangentDirections(vec1, vec2);
+//oss << "  \t Tangent-Directions: " << vec1 << " " << vec2;
+//LOG_MESSAGE(Logger::RULES, oss.str());
+
+        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
+        contact.setFrictionState(1,0);
+        contact.setFrictionState(0,1);
+
         if( stepHeight < 0.4 )
         {
             if(stepHeight > 0.01f) // experimantal value, 
@@ -427,17 +459,15 @@
                                    // too high means the creature stops if moving slowly onto a step because of the friction
             {
                 //setContactNormalAcceleration(5);
-                rotateTangentDirections(charOri*mDirection + Vector3::UNIT_Y);
-                setContactTangentAcceleration(5,0);
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);
+                contact.setTangentAcceleration(5,0);
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);
             }
             else
             {
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);
             }
-            //setContactTangentAcceleration(5);
             //setContactElasticity(0.0f);
         }
         else
@@ -446,29 +476,22 @@
             vel = mCreature->getActor()->getPhysicalThing()->getVelocity();
             if( vel.y >= 0 )
             {
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);    
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);    
             }
             else
             {
-                setContactFrictionState(0,0);
-                setContactFrictionState(0,1);
+                //setContactFrictionState(0,0);
+                //setContactFrictionState(0,1);
             }
         }
+}
 
         if(mMovement != NULL)
         {
-            // @XXX Evil code!
-            // Protected members from type OgreNewt::ContactCallback have to be overridden in order
-            // for the movements to work. This is because these members are used by OgreNewt functions
-            // for processing this contact. Should probably be solved in OgreNewt directly.
-            OgreNewt::ContactCallback *movement = mMovement;
-            *movement = (OgreNewt::ContactCallback)(*this);
-            return movement->userProcess();
+            // give the movement a chance to modify the contact
+            mMovement->userProcess(contactJoint, timestep, threadid);
         }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
     }
 
     AbstractMovement *CreatureController::getMovementFromId(CreatureController::MovementType id)

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -44,14 +44,32 @@
 
         physicsManager->createMaterialPair(char_mat, def_mat)->setContactCallback(this);
         physicsManager->createMaterialPair(char_mat, level_mat)->setContactCallback(this);
-        
+        physicsManager->createMaterialPair(char_mat, char_mat); //->setContactCallback(this);
+
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultFriction(0.0f,0.0f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultFriction(0.0f,0.0f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultFriction(0.0f,0.0f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultElasticity(0.1f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultElasticity(0.1f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultElasticity(0.1f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSoftness(0.1f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSoftness(0.1f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultSoftness(0.1f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSurfaceThickness(0.0f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSurfaceThickness(0.0f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultSurfaceThickness(0.0f);
+
+/*        
         physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultFriction(0.8f,0.4f);
         physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultFriction(0.8f,0.4f);
-        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultElasticity(0.0f);
-        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultElasticity(0.0f);
-        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSoftness(1.0f);
-        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSoftness(1.0f);
-
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultFriction(0.8f,0.4f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultElasticity(0.01f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultElasticity(0.01f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultElasticity(0.01);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSoftness(0.8f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSoftness(0.8f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultSoftness(0.8f);
+*/
         physicsManager->getNewtonDebugger()->setMaterialColor(char_mat, Ogre::ColourValue::Red);
     }
 
@@ -146,27 +164,34 @@
         }
     }
 
-    int CreatureControllerManager::userProcess()
+    void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
-        Actor *actor = static_cast<Actor*>(m_body0->getUserData());
+        Actor *actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));
             if (it != mControllers.end())
             {
-                // @XXX Evil code!
-                // Protected members from type OgreNewt::ContactCallback have to be overridden in order
-                // for the controllers to work. This is because these members are used by OgreNewt functions
-                // for processing this contact. Should probably be solved in OgreNewt directly.
-                OgreNewt::ContactCallback* controller = it->second;
-                *controller = (OgreNewt::ContactCallback)(*this);
-                return controller->userProcess();
+                it->second->userProcess(contactJoint, timestep, threadid);
+                return;
             }
         }
 
+        // if the controlled body is the second body...
+        actor = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+        if( actor != NULL )
+        {
+            ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));
+            if (it != mControllers.end())
+            {
+                it->second->userProcess(contactJoint, timestep, threadid);
+                return;
+            }
+        }
+
+
         LOG_ERROR(Logger::RULES,
             "Der Kollisionsk?rper konnte keinem CreatureController zugeordnet werden.");
-        return 1;
     }
 
     const Ogre::String& CreatureControllerManager::getName() const

Modified: rl/trunk/engine/rules/src/JumpHighMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpHighMovement.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/JumpHighMovement.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -147,7 +147,7 @@
         }
 
         Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * inertia;
     }
 
     bool JumpHighMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)

Modified: rl/trunk/engine/rules/src/JumpLongMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpLongMovement.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/JumpLongMovement.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -186,7 +186,7 @@
         }
 
         Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * inertia;
     }
 
     bool JumpLongMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)

Modified: rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -21,6 +21,8 @@
 using namespace Ogre;
 
 
+/// @todo: use TriggerVolumes
+// void NewtonCollisionSetAsTriggerVolume(const NewtonCollision* convexCollision, int trigger);
 
 
 namespace rl
@@ -98,8 +100,8 @@
 
         // the materials that are triggered here
         PhysicsMaterialRaycast::MaterialVector materialVector;
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("default")); // should we perhaps only use level here?
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("level"));
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("character")); // should we perhaps only use level here?
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("camera"));
 
 
 
@@ -113,7 +115,8 @@
                 PhysicsManager::getSingleton()._getNewtonWorld(),
                 &materialVector,
                 start,
-                end);
+                end,
+                true);
         if(info.mBody)
         {
             mMoveToNextTarget = false;
@@ -149,7 +152,7 @@
                     mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &materialVector,
-                            start, end);
+                            start, end, true);
 
                 // do we need to check bodies left and right of this ray? (step width?)
 

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -250,15 +250,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
-                                    entity,
-                                    false));
-                    //orientation, pos));
+                                    entity));
                     LOG_DEBUG(Logger::RULES, "Created physics proxy type 'convexhull' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "mesh" || physicsProxyType == "auto")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, entity, false));
+                                    thisWorld, entity, true));
                     LOG_DEBUG(Logger::RULES, "Created physics proxy type 'mesh' for entity '"+entity->getName()+"'.");
                 }
                 else
@@ -274,7 +272,7 @@
             }
         }
 
-        if (!collision.isNull())
+        if ( collision != NULL )
         {
             collisions.push_back(collision);
         }

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -150,7 +150,7 @@
 
 			collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
 
-			if (!collision.isNull())
+			if ( collision != NULL )
 			{
 				collisions.push_back(collision);
 			}

Modified: rl/trunk/engine/ui/include/CombatControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CombatControlState.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/CombatControlState.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,6 +22,8 @@
 #include "ControlState.h"
 #include "Combatant.h"
 #include "MessagePump.h"
+#include "PhysicsController.h"
+#include "PhysicsGenericContactCallback.h"
 #include "Selector.h"
 
 
@@ -32,9 +34,21 @@
     class CombatGui;
     class CombatManager;
 
-	class _RlUiExport CombatControlState : public ControlState, public Combatant
+	class _RlUiExport CombatControlState :
+            public ControlState,
+            public Combatant,
+            public PhysicsController,
+            public PhysicsGenericContactCallback
 	{
 	public:
+        /** 
+         * Different view-modes:
+         * @VM_COMBAT_CENTERED: "cameraLookAt" to center of combat (middle of all combatant positions)
+         * @VM_THIRD_PERSON: zooms to one combatant (not only hero!)
+        */
+        typedef enum {VM_COMBAT_CENTERED, VM_THIRD_PERSON} ViewMode;
+
+
 		/**
 		*  @throw NullPointerException if camera is NULL.
 		*  @warning Ownership of combat is taken by the CombatControlState.
@@ -46,6 +60,8 @@
 
         virtual void pause();
         virtual void resume();
+        virtual bool keyPressed(const OIS::KeyEvent& evt, bool handled);
+        virtual bool keyReleased(const OIS::KeyEvent& evt, bool handled);
 
 		void run(Ogre::Real elapsedTime);
 
@@ -54,6 +70,21 @@
         virtual Ogre::String getCombatantTypeName() const;
         virtual void requestCombatantAction();
 
+
+        // camera collision: OgreNewt::ContactCallback overides
+        int onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex);
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadIndex);
+
+        // camera movement: Newton force and torque callback
+        void OnApplyForceAndTorque(PhysicalThing *pt, float timstep);
+
+        // Change ViewMode
+        void setViewMode(ViewMode mode);
+        ViewMode getViewMode();
+        void toggleViewMode();
+        // set the combatant (must be part of this combat), the camera should focus on (VM_THIRD_PERSON) (only used internally?)
+        void setCameraFocusedCombatant(Combatant* combatant);
+
     private:
 		enum State {REQUEST_USER_INPUT, ROUND_EXECUTION};
 
@@ -74,6 +105,36 @@
         CameraObject* mCamera;
 
 		State mState;
+
+        // Camera:
+        Ogre::Degree mCameraYaw, mCameraPitch;
+        Ogre::Real mCameraMaxDistance, mCameraCombatCenteredMinDistance, mCameraThirdPersonMinDistance;
+        int mMovementState; // keyboard input
+        Ogre::Real mCameraLinearDampingK, mCameraLinearSpringK;
+        ViewMode mViewMode;
+        Ogre::Vector3 mCameraLookAt; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Vector3 mCameraOptPos; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Real mCameraDistance; // only used in third-person, changed by calculateOptimalCameraAndPosition
+        Ogre::Real mCameraSwitchDist; // set by calculateOptimalCameraPositionAndLookAt, dist at which switches to third-person
+        Ogre::Real mCameraSwitchTransitionDist; // relative value (0-1) of mCameraSwitchDist
+        Combatant* mCameraFocusedCombatant;  // the combatant currently focused by camera (VM_THIRD_PERSON)
+        // when switching from one view-mode to another or when changing focused combatant, these variables are used
+        // to provide smooth camera movement
+        bool mCameraTransitionLookAtActive;
+        bool mCameraTransitionPositionActive;
+        Ogre::Vector3 mCameraTransitionPosition;
+        Ogre::Vector3 mCameraTransitionLookAt;
+        // buffered values needed fo camera-movement, calculated once per frame:
+        Ogre::Vector3 mCombatCenter; // result of calculateCombatCenterPosition
+        Ogre::Real mCombatRadius; // result of calculateCombatRadius
+
+        // Camera helper functions
+        void resetCamera();
+        void updateCameraLookAt(Ogre::Real timestep);
+        Ogre::Vector3 calculateCombatCenterPosition();
+        Ogre::Real calculateCombatRadius(Ogre::Vector3 center);
+        // sets the variables mCameraLookAt, mCameraOptPos, mCameraDistance, usually called in OnApplyForceAndTorque
+        void calculateOptimalCameraPositionAndLookAt();
         
         // Event handlers
 		bool userRequestAttackOpponent(Combatant*);

Modified: rl/trunk/engine/ui/include/Console.h
===================================================================
--- rl/trunk/engine/ui/include/Console.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/Console.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -53,6 +53,7 @@
 
 			bool handleKeyDown(const CEGUI::EventArgs& e);
             bool handleKeyUp(const CEGUI::EventArgs& e);
+            bool handleActivated(const CEGUI::EventArgs& e);
 			void appendTextRow(const CeGuiString& text, const CEGUI::colour color);
 
 			std::vector<CeGuiString> mHistory;

Modified: rl/trunk/engine/ui/include/FreeflightControlState.h
===================================================================
--- rl/trunk/engine/ui/include/FreeflightControlState.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/FreeflightControlState.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -26,6 +26,7 @@
 #   include <OgreNewt/OgreNewt.h>
 #else
 #   include <OgreNewt.h>
+#   include <OgreNewt_PlayerController.h>
 #endif
 
 namespace rl {
@@ -57,12 +58,10 @@
 	    void toggleCameraCollision();
 	    void resetCamera();
 
-        /// This is the OgreNewt contact process callback for the combination
-        /// Character <-> Level
-        int userProcess();
-
+        /// Newton contacts callback
+        int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex );
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
 	private:		
 		int mCurrentMovementState;
@@ -78,6 +77,8 @@
         Ogre::Real mMouseSensitivity;
         bool mInvertedMouse;
         std::pair<Ogre::Degree, Ogre::Degree> mPitchRange;
+
+        OgreNewt::PlayerController *mOgreNewtPlayerController;
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -25,9 +25,17 @@
 	class ItemDescriptionDragContainer : public ItemDragContainer
 	{
 	public:
-		ItemDescriptionDragContainer(Item* item, const CeGuiString& name);
+		ItemDescriptionDragContainer(const CeGuiString &type, const CeGuiString& name);
+                void setItem(Item*);
+                static const CeGuiString WidgetTypeName; // for CEGUI
 	};
 
 } // namespace rl
+namespace CEGUI{
 
+    using rl::ItemDescriptionDragContainer;
+
+    CEGUI_DECLARE_WINDOW_FACTORY(ItemDescriptionDragContainer)
+}
+
 #endif //__ItemDescriptionDragContainer_H__

Modified: rl/trunk/engine/ui/include/ItemDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDragContainer.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/ItemDragContainer.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -18,6 +18,7 @@
 
 #include "UiPrerequisites.h"
 
+#include <CEGUI.h>
 #include <elements/CEGUIDragContainer.h>
 
 namespace rl 
@@ -41,6 +42,7 @@
 		const CeGuiString& getItemParentSlot() const;
 		Inventory* getItemParentInventory() const;
 		Item* getItem() const;
+                virtual void setItem(Item*); // can only be used once to initialize the Container
 		CEGUI::Window* getContentWindow() const;
 	
 		bool _handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
@@ -49,13 +51,15 @@
         bool fadeOutAndHide(Ogre::Real delay);
         bool stopFadeOut();
 
-        void destroyWindow(); // this is internally done with a windowfadejob to prevent problems
+        virtual void destroy(void); // inherited from CEGUI::WINDOW
 
-        void setDestroyListener(ItemDragContainerDestroyListener *listener) {mDestroyListener = listener;}
+        //void destroyWindow(); // this is internally done with a windowfadejob to prevent problems
+
+        void setDestroyListener(ItemDragContainerDestroyListener *listener);
 	protected:
 		CEGUI::Window* mContentWindow;
 		
-		ItemDragContainer(Item* item, const CeGuiString& name);
+		ItemDragContainer(const CeGuiString &type, const CeGuiString& name);
 		virtual bool testClassName_impl(const CEGUI::String& class_name) const;
 
 	private:
@@ -71,7 +75,17 @@
     class ItemDragContainerDestroyListener
     {
     public:
+        ItemDragContainerDestroyListener();
+        virtual ~ItemDragContainerDestroyListener();
         virtual void notifyItemDragContainerDestroyed(ItemDragContainer* cont) = 0;
+    protected:
+        void addDragContainer(ItemDragContainer* dragcont);
+        void removeDragContainer(ItemDragContainer* dragcont);
+        friend class ItemDragContainer;
+    private:
+        typedef std::map<CeGuiString, ItemDragContainer*> DndContainerMap;
+        DndContainerMap mContainers;
+        bool mIsDestroying;
     };
 
 } // namespace rl

Modified: rl/trunk/engine/ui/include/ItemIconDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemIconDragContainer.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/ItemIconDragContainer.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -27,9 +27,19 @@
 	class ItemIconDragContainer : public ItemDragContainer
 	{
 	public:
-		ItemIconDragContainer(Item* item, const CeGuiString& name);
+		ItemIconDragContainer(const CeGuiString &type, const CeGuiString& name);
+                void setItem(Item* item);
+                static const CeGuiString WidgetTypeName; // for CEGUI
 	};
 
 } // namespace rl
 
+namespace CEGUI{
+
+    using rl::ItemIconDragContainer;
+
+    CEGUI_DECLARE_WINDOW_FACTORY(ItemIconDragContainer)
+
+}
+
 #endif //__ItemIconDragContainer_H__

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -60,10 +60,11 @@
 
         /// This is the OgreNewt contact process callback for the combination
         /// Character <-> Level
-        int userProcess();
+        int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex );
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// First oder Third person view.
         void setViewMode(ViewMode mode);
@@ -123,12 +124,9 @@
 
         ViewMode mViewMode;
 
-        int mObstractedFrameCount;
-        Ogre::Real mObstractedTime;
-        int mCameraJammedFrameCount;
-        Ogre::Real mCameraJammedTime;
-
         PhysicsMaterialRaycast* mRaycast;
+        PhysicsMaterialConvexcast * mConvexcast;
+        OgreNewt::Collision *mCameraCastCollision;
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 

Modified: rl/trunk/engine/ui/include/WindowFadeJob.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFadeJob.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/WindowFadeJob.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -40,8 +40,8 @@
             Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
         WindowFadeJob(CEGUI::Window* window, Mode mode, 
             Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
-        WindowFadeJob(ItemDragContainer* window, Mode mode, 
-            Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
+        //WindowFadeJob(ItemDragContainer* window, Mode mode, 
+        //    Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
 
         virtual bool execute(Ogre::Real time);
         virtual void discard();
@@ -49,7 +49,7 @@
     protected:
         AbstractWindow* mAbstractWindow;
         CEGUI::Window* mCEGUIWindow;
-        ItemDragContainer* mItemDragContainer;
+        //ItemDragContainer* mItemDragContainer;
         Mode mMode;
         Ogre::Real mChangeRate;
         Ogre::Real mCurrentAlpha;

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,6 +22,7 @@
 #include "Combat.h"
 #include "CombatGui.h"
 #include "CombatManager.h"
+#include "CommandMapper.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
 #include "CreatureController.h"
@@ -49,7 +50,21 @@
           mEnemySelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
             QUERYFLAG_CREATURE),
           mCamera(NULL),
-		  mState(ROUND_EXECUTION)
+		  mState(ROUND_EXECUTION),
+          mCameraYaw(0),
+          mCameraPitch(60), // the same value as in resetCamera
+          mMovementState(0),
+          mCameraLinearSpringK(100.0f),
+          mCameraLinearDampingK(Math::NEG_INFINITY),
+          mViewMode(VM_COMBAT_CENTERED),
+          mCameraFocusedCombatant(NULL),
+          mCameraTransitionLookAtActive(false),
+          mCameraTransitionPositionActive(false),
+          mCameraMaxDistance(30.0f),
+          mCameraCombatCenteredMinDistance(5.0f),
+          mCameraThirdPersonMinDistance(1.0f),
+          mCameraSwitchDist(30.0f),
+          mCameraSwitchTransitionDist(0.8f)
     {
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
@@ -74,6 +89,11 @@
 
         mCamera = static_cast<CameraObject*>(mCameraActor->getControlledObject());
 		mCombatGui = new CombatGui(mCombat, mCamera);
+
+
+        // calculate camera spring-damping system coefficients
+        Real relationCoefficient = 0.8f;
+        mCameraLinearDampingK = relationCoefficient * 2.0 * Math::Sqrt(mCameraLinearSpringK);
     }
 
 	CombatControlState::~CombatControlState()
@@ -85,9 +105,40 @@
 
     void CombatControlState::resume()
     {
-        mCameraActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->freeze();
+        // control camera
+        mCameraActor->getPhysicalThing()->setMaterialID(
+        PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
+        
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
 
+       
+
+
         ///\todo Richtig machen, nur tempor?r Ani hier setzen.
         static_cast<MeshObject*>(mCharacterActor->getControlledObject())
             ->startAnimation("kampf_schwerter_idle");
@@ -119,24 +170,361 @@
         mCombat->addAlly(this);
 
         mCombat->start();
+
+        // reset camera
+        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -> looks nicer
+        // perhaps this should be handled differently!
+        mMovementState = 0;
+        // calculate some buffered values, so they are initialized:
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraFocusedCombatant = this;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        mCameraDistance = 30.0f; // only used for third-person
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        calculateOptimalCameraPositionAndLookAt();
+ 
+        // update CombatGui
+        mCombatGui->update();
     }
 
     void CombatControlState::pause()
     {
-		mCombatGui->hide();
+        mCombatGui->hide();
 
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCharacterActor->getPhysicalThing()->unfreeze();
+
+        // stop controlling camera actor
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
+        // cam<->Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        // cam<->Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+
         static_cast<MeshObject*>(mCharacterActor->getControlledObject())->stopAllAnimations();
 
         mCombat->pause();
     }
 
-	void CombatControlState::run(Ogre::Real elapsedTime)
+    bool CombatControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
     {
-		mCombatGui->update();
+        bool retval = false;
+        if( !handled )
+        {
+            int movement = mCommandMapper->getMovement(evt.key);
+            mMovementState |= movement;
+            
+            if( movement != MOVE_NONE )
+                retval = true;
+        }
+
+        if( ControlState::keyPressed(evt, handled || retval) )
+            retval = true;
+
+        return retval;
     }
+     
+    bool CombatControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper->getMovement(evt.key);
+        if( movement != MOVE_NONE )
+        {
+            mMovementState &= (~movement);
+            retval = true;
+        }
 
+        if( ControlState::keyReleased(evt, handled || retval) )
+            retval = true;
+        return retval;
+    }
+
+    void CombatControlState::run(Ogre::Real elapsedTime)
+    {
+        // updateCameraLookAt should be called before mCombatGui->update()!
+
+        // update camera look-at position
+        updateCameraLookAt(elapsedTime);
+
+
+        // update CombatGui
+        mCombatGui->update();
+
+
+        // slow down rotational movement, when radius grows
+        if( mMovementState & MOVE_RIGHT )
+            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState & MOVE_LEFT )
+            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState & MOVE_FORWARD )
+            mCameraDistance -= 5 * elapsedTime;
+        if( mMovementState & MOVE_BACKWARD )
+            mCameraDistance += 5 * elapsedTime;
+
+        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
+        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
+
+        // switch view mode smoothly if nearer:
+        if( mViewMode == VM_COMBAT_CENTERED )
+        {
+            if( mMovementState & MOVE_FORWARD )
+            {
+                mViewMode = VM_THIRD_PERSON;
+            }
+        }
+        else // VM_THIRD_PERSON
+        {
+            if( mCameraDistance >= mCameraSwitchDist - 0.05f && mMovementState & MOVE_BACKWARD )
+            {
+                mViewMode = VM_COMBAT_CENTERED;
+            }
+        }
+    }
+
+    void CombatControlState::resetCamera(void)
+    {
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        if( mViewMode == VM_THIRD_PERSON )
+            mCameraDistance = 2.0f; // only used for third-person
+        calculateOptimalCameraPositionAndLookAt();
+        mCameraActor->setPosition(mCameraOptPos);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    void CombatControlState::updateCameraLookAt(Real elapsedTime)
+    {
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    Vector3 CombatControlState::calculateCombatCenterPosition()
+    {
+        // get the center of all persons (allies and opponents)
+        int n = 0;
+        Vector3 pos = Vector3::ZERO;
+
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            pos += (*it)->getCreature()->getPosition();
+            n++;
+        }
+
+        const Combat::CombatantSet &opponents (mCombat->getAllPlayerOpponents());
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            pos += (*it)->getCreature()->getPosition();
+            n++;
+        }
+
+        if( n > 0 )
+            pos /= n;
+        else
+        {
+            pos = mCharacter->getPosition();
+        }
+
+        return pos;
+    }
+
+    Real CombatControlState::calculateCombatRadius(Vector3 center)
+    {
+        // get the greatest distance from center from all persons
+        Real distance = 0;
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
+        }
+        const Combat::CombatantSet &opponents = mCombat->getAllPlayerOpponents();
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
+        }
+        return distance;
+    }
+    
+    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
+    {
+        // some variables:
+        Vector3 playerPos = mCharacter->getPosition();
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+
+
+
+        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
+        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
+            
+        // put camera on the line player-center far enough to see all persons
+        // if player is "exactly" in the center, use player orientation as fallback orientation
+        // + rotation from mCameraYaw
+        Vector3 diff = playerPos - mCombatCenter;
+        diff.y = 0;
+        Quaternion combatCenteredCamYaw;
+        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
+        if( diff.squaredLength() < 0.01 )
+        {
+            diff = mCharacterActor->getOrientation()*Vector3::UNIT_Z;
+        }
+        diff.y = 0;
+        diff.normalise();
+        diff = combatCenteredCamYaw*diff;
+        diff.y = Math::Tan(mCameraPitch.valueRadians());
+
+        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
+        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
+        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
+ 
+
+
+
+
+        // TODO
+        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
+        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
+        // ideal scheint mir eine "runde" bewegung, a la kamerafahrt!
+
+
+        Vector3 center;
+        Vector3 dist;
+        if( mViewMode == VM_THIRD_PERSON && mCameraFocusedCombatant )
+        {
+            center = mCameraFocusedCombatant->getPosition();
+            // if mCameraDistance is near the one needed for combatCentered,
+            // interpolate the center (between center of third-person-view
+            // and center of combat-centered-view)
+            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
+            if( interpolateDist <  mCameraSwitchTransitionDist*mCameraSwitchDist )
+            {
+                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
+            }
+            dist = mCameraDistance*cosPitch;
+        }
+        else // assume VM_COMBAT_CENTERED
+        {
+            center = mCombatCenter;
+            // update camera-distance variable
+            mCameraDistance = (combatCenteredDistance*diff).length();
+            dist = combatCenteredDistance;
+        }
+
+        mCameraSwitchDist = (combatCenteredDistance*diff).length();
+        mCameraOptPos = center + dist*diff;
+        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
+    }
+
+    void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+
+        calculateOptimalCameraPositionAndLookAt();
+
+        // handle transition
+        if( mCameraTransitionPositionActive )
+        {
+            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
+            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() < 0.02 )
+                mCameraTransitionPositionActive = false;
+            mCameraOptPos = mCameraTransitionPosition;
+        }
+        if( mCameraTransitionLookAtActive )
+        {
+            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
+            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() < 0.02 )
+                mCameraTransitionLookAtActive = false;
+            mCameraLookAt = mCameraTransitionLookAt;
+        }
+
+
+        Vector3 diff = camPos - mCameraOptPos;
+        Vector3 cameraVelocity;
+        cameraVelocity = mCamBody->getVelocity();
+        // spring velocity
+        Vector3 springAcc = -mCameraLinearSpringK*diff - mCameraLinearDampingK * cameraVelocity;
+                                            
+        // get the camera mass
+        Real mass;
+        Vector3 inertia;
+        mCamBody->getMassMatrix(mass, inertia);
+                                                
+        mCamBody->setForce(springAcc * mass);
+    }
+
+    void CombatControlState::setViewMode(ViewMode mode)
+    {
+        if(mode != mViewMode)
+        {
+            mViewMode = mode;
+            mCameraTransitionPosition = mCameraActor->getPosition();
+            mCameraTransitionLookAt = mCameraLookAt;
+            mCameraTransitionLookAtActive = true;
+            mCameraTransitionPositionActive = true;
+        }
+    }
+
+    void CombatControlState::toggleViewMode()
+    {
+        if( mViewMode == VM_COMBAT_CENTERED )
+            setViewMode(VM_THIRD_PERSON);
+        else
+            setViewMode(VM_COMBAT_CENTERED);
+    }
+
+    CombatControlState::ViewMode CombatControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
+    {
+        if( combatant != mCameraFocusedCombatant )
+        {
+            if( mViewMode == VM_THIRD_PERSON )
+            {
+                mCameraTransitionPosition = mCameraActor->getPosition();
+                mCameraTransitionLookAt = mCameraLookAt;
+                mCameraTransitionLookAtActive = true;
+                mCameraTransitionPositionActive = true;
+            }
+        }
+        mCameraFocusedCombatant = combatant;
+    }
+
+    int CombatControlState::onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex)
+    {
+        // TODO handle camera collisions here
+        return 0;
+    }
+   
+    void CombatControlState::userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadIndex)
+    {
+        // TODO handle camera collisions here
+    }
+
     Ogre::String CombatControlState::getCombatantTypeName() const
     {
         return "CombatControlState";

Modified: rl/trunk/engine/ui/src/CombatGui.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatGui.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/CombatGui.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -106,14 +106,15 @@
                 (*it)->getCreatureController()->getCreature()->getActor()
                     ->_getSceneNode()->_getWorldAABB());
 
-			// Place buttons, if needed by current state
-			if (mUserInputEnabled)
-			{
-				Ogre::Rect screenRect = mCamera->getPixelRectOnScreen(rec);
-				// Place button set above opponent, horizontally centered.
-				int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
-				mCombatWindow->placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
-			}
+			// Place buttons, update every frame (camera movement requires this)
+                        // TODO: is there any better possibility (attach button-windows to ogre node?!?)
+			//if (mUserInputEnabled)
+			//{
+			Ogre::Rect screenRect = mCamera->getPixelRectOnScreen(rec);
+			// Place button set above opponent, horizontally centered.
+			int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
+			mCombatWindow->placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
+			//}
 
 			// draw Hud
 

Modified: rl/trunk/engine/ui/src/Console.cpp
===================================================================
--- rl/trunk/engine/ui/src/Console.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/Console.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -57,9 +57,15 @@
 		mCommandLine->subscribeEvent(
 			Editbox::EventKeyUp,
 			boost::bind(&Console::handleKeyUp, this, _1));
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-            boost::bind(&Console::hideWindow, this));
+		mWindow->subscribeEvent(
+                        FrameWindow::EventCloseClicked,
+                        boost::bind(&Console::hideWindow, this));
+                mWindow->subscribeEvent(
+                        FrameWindow::EventActivated,
+                        boost::bind(&Console::handleActivated, this, _1));
 
+                mWindow->setAlwaysOnTop(true);
+
 		// load history from file
         if( ConfigurationManager::getSingleton().getIntSetting("General", "Save Console History") > 0 )
         {
@@ -282,5 +288,11 @@
 		else
 			mCommandLine->setText(mHistory[mHistoryMarker]);
 	}
+
+        bool Console::handleActivated(const CEGUI::EventArgs&)
+        {
+            mCommandLine->activate();
+            return false;
+        }
 }
 

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -72,7 +72,7 @@
 
 		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
 		{
-			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+			ItemDragContainer* dragcont = dynamic_cast<ItemDragContainer*>(
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
 
@@ -158,7 +158,7 @@
 
 		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
 		{
-			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+			ItemDragContainer* dragcont = dynamic_cast<ItemDragContainer*>(
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
 
@@ -179,7 +179,8 @@
             {
                 if( dragcont != getItemWindow(item) )
                 {
-                    dragcont->destroyWindow();
+                    CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+                    //dragcont->destroyWindow();
                     dragcont = createItemWindow(item);
                     mContentWindow->addChildWindow(dragcont);
                 }
@@ -211,8 +212,11 @@
 			mWindow->getName() +  "/item/"
 			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
 
-		itemhandler = new ItemIconDragContainer(item,
-			dragContainerName);
+                itemhandler = dynamic_cast<ItemIconDragContainer*>(
+                    AbstractWindow::loadWindow("itemicondragcontainer.xml", dragContainerName));
+                    //CEGUI::WindowManager::getSingleton().createWindow("ItemIconDragContainer", dragContainerName));
+                itemhandler->setItem(item);
+		//itemhandler = new ItemIconDragContainer(item, dragContainerName);
         itemhandler->setDestroyListener(this);
         mItemDragContainerMap.insert(std::make_pair(item, itemhandler));
 		itemhandler->setItemParent(mContainer);

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -46,7 +46,8 @@
         mCollisionsEnabled(false),
         mPitchRange(Degree(-89), Degree(89)),
         mYaw(Degree(0)),
-        mPitch(Degree(0))
+        mPitch(Degree(0)),
+        mOgreNewtPlayerController(NULL)
 	{
         mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
         mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
@@ -59,7 +60,10 @@
     void FreeflightControlState::pause()
     {
 		mCameraActor->getPhysicalThing()->freeze();
-		mCharacterActor->getPhysicalThing()->unfreeze();
+		//mCharacterActor->getPhysicalThing()->unfreeze();
+        delete mOgreNewtPlayerController;
+        mOgreNewtPlayerController = NULL;
+        mCharacterActor->getPhysicalThing()->setUpConstraint();
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
 
         // Char<->Level collision back to default
@@ -78,7 +82,9 @@
     void FreeflightControlState::resume()
     {
         mCameraActor->getPhysicalThing()->unfreeze();
-		mCharacterActor->getPhysicalThing()->freeze();
+		//mCharacterActor->getPhysicalThing()->freeze();
+        mCharacterActor->getPhysicalThing()->clearUpConstraint();
+        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
 
@@ -92,21 +98,30 @@
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID("camera"),
                     PhysicsManager::getSingleton().getMaterialID("default"));
-        mat_pair->setContactCallback(this);
+        mat_pair->setContactCallback(NULL);
         mat_pair->setContinuousCollisionMode(1);
+        mat_pair->setDefaultSoftness(1.0f);
         mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setContactCallback(this);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID("camera"),
                     PhysicsManager::getSingleton().getMaterialID("level"));
-        mat_pair->setContactCallback(this);
+        mat_pair->setContactCallback(NULL);
         mat_pair->setContinuousCollisionMode(1);
+        mat_pair->setDefaultSoftness(1.0f);
         mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setContactCallback(this);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID("camera"),
                     PhysicsManager::getSingleton().getMaterialID("character"));
-        mat_pair->setContactCallback(this);
+        mat_pair->setContactCallback(NULL);
         mat_pair->setContinuousCollisionMode(1);
+        mat_pair->setDefaultSoftness(1.0f);
         mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setContactCallback(this);
     }
 
 	void FreeflightControlState::run(Real elapsedTime)
@@ -198,11 +213,20 @@
         if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
         if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
 
+if( mCollisionsEnabled )
+    mOgreNewtPlayerController->setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
+
         mCameraActor->setOrientation(Quaternion::IDENTITY);
         mCameraActor->yaw(mYaw.valueDegrees());
         mCameraActor->pitch(mPitch.valueDegrees());
     }
 
+    
+    int FreeflightControlState::onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex )
+    {
+        return mCollisionsEnabled;
+    }
+
 	void FreeflightControlState::toggleCameraCollision()
 	{
 		// with or without collision?
@@ -286,35 +310,12 @@
         return retval;
 	}
 
-    int FreeflightControlState::userProcess()
-    {
-        if (m_body0 == mCamBody || m_body1 == mCamBody)
-        {
-            // this is camera collision
 
-            if( !mCollisionsEnabled )
-                return 0;
-
-            setContactSoftness(1.0f);  // "weiche" Collision
-            setContactElasticity(0.0f);
-
-            return 1;
-        }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
-    }
-
-
-
-    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
         OgreNewt::Body* body = thing->_getBody();
 
-        // Get the current world timestep
-        Real timestep = world->getTimeStep();
-
         if (body == mCamBody)
         {
             // apply camera force
@@ -332,7 +333,8 @@
             Vector3 currentVel = body->getVelocity();
             Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
             Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
-
+if( mCollisionsEnabled )
+    force = mass*(- currentVel) / delay;
             body->setForce(force);
         }
     }

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -23,6 +23,7 @@
 #include <CEGUIWindowManager.h>
 #include <elements/CEGUIFrameWindow.h>
 
+#include "AbstractWindow.h"
 #include "Actor.h"
 #include "ActorManager.h"
 #include "CameraObject.h"
@@ -213,10 +214,19 @@
 		else
 		{
 			if (showdescription)
-				itemhandler = new ItemDescriptionDragContainer(item, dragContainerName);
+                        {
+				itemhandler = dynamic_cast<ItemDescriptionDragContainer*> (
+                                        AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", dragContainerName));
+                                //new ItemDescriptionDragContainer(item, dragContainerName);
+                                itemhandler->setItem(item);
+                        }
 			else
             {
-				itemhandler = new ItemIconDragContainer(item, dragContainerName);
+				itemhandler = dynamic_cast<ItemIconDragContainer*> (
+                                        AbstractWindow::loadWindow("itemicondragcontainer.xml", dragContainerName));
+                                    //CEGUI::WindowManager::getSingleton().createWindow("ItemIconDragContainer", dragContainerName));
+                                itemhandler->setItem(item);
+				//itemhandler = new ItemIconDragContainer(item, dragContainerName);
                 itemhandler->setTooltipText(item->getName());
             }
 
@@ -286,20 +296,14 @@
 
 			if (mInventory->canHold(item, targetSlot))
 			{
-				if (dragcont->getItemParentContainer() != NULL)
-				{
-					dragcont->getParent()->removeChildWindow(dragcont);
-				}
-				else if (dragcont->getItemParentSlot() != "")
-				{
-					dragcont->getParent()->removeChildWindow(dragcont);
-				}
+				dragcont->getParent()->removeChildWindow(dragcont);
 
 				ItemDragContainer* newCont = createItemDragContainer(item, false, targetSlot);
 
 				if (newCont)
 				{
-                    dragcont->destroyWindow();
+                                    CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+//                    dragcont->destroyWindow();
 				}
 				else
 				{
@@ -412,7 +416,8 @@
 				-1);
 
 
-            dragcont->destroyWindow();
+                        CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+//            dragcont->destroyWindow();
 
 			Ogre::Vector3 targetPosWorldSpace =
 				mInventory->getOwner()->getPosition()

Modified: rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,10 +22,34 @@
 #include "AbstractWindow.h"
 #include "Item.h"
 
+
+
+namespace CEGUI
+{
+    CEGUI_DEFINE_WINDOW_FACTORY(ItemDescriptionDragContainer)
+}
+
 namespace rl {
-	ItemDescriptionDragContainer::ItemDescriptionDragContainer(Item* item, const CeGuiString& name)
-		: ItemDragContainer(item, name)
+
+    const CeGuiString ItemDescriptionDragContainer::WidgetTypeName("ItemDescriptionDragContainer");
+
+
+
+
+	ItemDescriptionDragContainer::ItemDescriptionDragContainer(const CeGuiString &type, const CeGuiString& name)
+		: ItemDragContainer(type, name)
 	{
+		CeGuiString prefix = name;
+
+		mContentWindow = this; //AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", prefix);
+		addChildWindow(mContentWindow);
+                mContentWindow->setDestroyedByParent(true);
+	}
+
+        void ItemDescriptionDragContainer::setItem(Item* item)
+        {
+            ItemDragContainer::setItem(item);
+
 		CeGuiString icon = item->getImageName();
 
 		if (icon == "")
@@ -33,19 +57,20 @@
 			icon = ICON_UNKNOWN_ITEM;
 		}
 
-		CeGuiString prefix = name;
-		mContentWindow = AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", prefix);
+                const CeGuiString &name = getName();
 
+
 		mContentWindow->getChild(
-			name+"ItemDescriptionDragContainer/Icon")
+			name+"/Icon")
 			->setProperty("Image", icon);
 		mContentWindow->getChild(
-			name+"ItemDescriptionDragContainer/Name")
+			name+"/Name")
 			->setText(item->getName());
 		mContentWindow->getChild(
-			name+"ItemDescriptionDragContainer/Description")
+			name+"/Description")
 			->setText(item->getDescription());
 
+
 		mContentWindow->subscribeEvent(
 			Window::EventMouseClick,
 			boost::bind(&ItemDragContainer::_handleItemMouseClick, this, _1, item));
@@ -54,7 +79,8 @@
 			Window::EventMouseDoubleClick,
 			boost::bind(&ItemDragContainer::_handleItemDoubleClick, this, _1, item));
 
-		setSize(mContentWindow->getSize());
-		addChildWindow(mContentWindow);
-	}
+
+
+	    setSize(mContentWindow->getSize());
+        }
 }

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -31,9 +31,9 @@
 namespace rl {
 	const Ogre::String ItemDragContainer::ICON_UNKNOWN_ITEM = "set:ModelThumbnails image:item_unknown";
 
-	ItemDragContainer::ItemDragContainer(Item* item, const CeGuiString& name)
-		: CEGUI::DragContainer("DragContainer", name),
-		mItem(item),
+	ItemDragContainer::ItemDragContainer(const CeGuiString &type, const CeGuiString& name)
+		: CEGUI::DragContainer(type, name),
+		mItem(NULL),
 		mParentContainer(NULL),
 		mParentSlot(""),
 		mContentWindow(NULL),
@@ -43,10 +43,28 @@
 	{
 	}
 
-	ItemDragContainer::~ItemDragContainer()
+        void ItemDragContainer::setItem(Item* item)
+        {
+            if( mItem != NULL )
+                Throw(IllegalArgumentException,"The item of an ItemDragContainer can only be set once!");
+            mItem = item;
+        }
+
+        ItemDragContainer::~ItemDragContainer()
+        {
+            if(mDestroyListener)
+                mDestroyListener->notifyItemDragContainerDestroyed(this);
+            setDestroyListener(NULL);
+        }
+
+	void ItemDragContainer::destroy()
 	{
-        if(mDestroyListener)
-            mDestroyListener->notifyItemDragContainerDestroyed(this);
+            if(mDestroyListener)
+                mDestroyListener->notifyItemDragContainerDestroyed(this);
+            setDestroyListener(NULL);
+
+            CEGUI::DragContainer::destroy();
+/*        
         stopFadeOut();
 
         hide();
@@ -59,8 +77,9 @@
 		removeChildWindow(mContentWindow);
 		CEGUI::WindowManager::getSingleton().destroyWindow(mContentWindow);
         CEGUI::WindowManager::getSingleton().destroyWindow(this);
+*/
 	}
-
+/*
     void ItemDragContainer::destroyWindow()
     {
         if(mDestroyListener)
@@ -80,7 +99,7 @@
             JobScheduler::JP_NORMAL,
             0.0f);
     }
-
+*/
 	void ItemDragContainer::setItemParent(Container* container)
 	{
 		mParentContainer = container;
@@ -179,4 +198,65 @@
 
         return true;
     }
+
+    void ItemDragContainer::setDestroyListener(ItemDragContainerDestroyListener *listener)
+    {
+        if( listener == mDestroyListener )
+            return ;
+
+        if( mDestroyListener )
+            mDestroyListener->removeDragContainer(this);
+
+        mDestroyListener = listener;
+
+        if( listener )
+            mDestroyListener->addDragContainer(this);
+    }
+
+
+    ItemDragContainerDestroyListener::ItemDragContainerDestroyListener() : mIsDestroying(false)
+    {
+    }
+
+    ItemDragContainerDestroyListener::~ItemDragContainerDestroyListener()
+    {
+        // remove all dragContainers from list
+        mIsDestroying = true;
+        for( DndContainerMap::iterator it = mContainers.begin(); it != mContainers.end(); it++ )
+            it->second->setDestroyListener(NULL);
+    }
+
+    void ItemDragContainerDestroyListener::addDragContainer(ItemDragContainer *dragcont)
+    {
+        if( dragcont == NULL )
+            Throw(NullPointerException, "Parameter dragcont in ItemDragContainerDestroyListener::addDragContainer should not be NULL!");
+
+        DndContainerMap::iterator it = mContainers.find(dragcont->getName());
+        if( it != mContainers.end() )
+        {
+            Throw(IllegalArgumentException, "ItemDragContainerDestroyListener::addDragContainer: ItemDragContainer with name '"+
+                    dragcont->getName()+"' already added!");
+        }
+
+        mContainers.insert(std::make_pair(dragcont->getName(), dragcont));
+    }
+
+    void ItemDragContainerDestroyListener::removeDragContainer(ItemDragContainer *dragcont)
+    {
+        if( mIsDestroying )  // if this Listener is destroyed, we don't need to care about the list
+            return ;
+
+        if( dragcont == NULL )
+            Throw(NullPointerException, "Parameter dragcont in ItemDragContainerDestroyListener::removeDragContainer should not be NULL!");
+
+        DndContainerMap::iterator it = mContainers.find(dragcont->getName());
+        if( it == mContainers.end() )
+        {
+            Throw(IllegalArgumentException, "ItemDragContainerDestroyListener::removeDragContainer: ItemDragContainer with name '"+
+                    dragcont->getName()+"' was not added before!");
+        }
+
+        mContainers.erase(it);
+   }
+
 }

Modified: rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,26 +22,49 @@
 #include "AbstractWindow.h"
 #include "Item.h"
 
+namespace CEGUI{
+    CEGUI_DEFINE_WINDOW_FACTORY(ItemIconDragContainer)
+}
 namespace rl {
-	ItemIconDragContainer::ItemIconDragContainer(Item* item, const CeGuiString& name)
-		: ItemDragContainer(item, name)
+
+    const CeGuiString ItemIconDragContainer::WidgetTypeName("ItemIconDragContainer");
+
+
+
+	ItemIconDragContainer::ItemIconDragContainer(const CeGuiString &type, const CeGuiString& name)
+		: ItemDragContainer(type, name)
 	{
+		CeGuiString prefix = name;
+		mContentWindow = this; //AbstractWindow::loadWindow("itemicondragcontainer.xml", prefix);
+
+
+		for (size_t idx = 0; idx < mContentWindow->getChildCount(); ++idx)
+		{
+			LOG_MESSAGE(Logger::UI, mContentWindow->getChildAtIdx(idx)->getName());
+		}
+
+		addChildWindow(mContentWindow);
+                mContentWindow->setDestroyedByParent(true);
+	}
+
+        void ItemIconDragContainer::setItem(Item* item)
+        {
+            ItemDragContainer::setItem(item);
+
+
+
+
 		CeGuiString icon = item->getImageName();
 
 		if (icon == "")
 		{
 			icon = ICON_UNKNOWN_ITEM;
 		}
+                const CeGuiString &name = getName();
 
-		CeGuiString prefix = name;
-		mContentWindow = AbstractWindow::loadWindow("itemicondragcontainer.xml", prefix);
 
-		for (size_t idx = 0; idx < mContentWindow->getChildCount(); ++idx)
-		{
-			LOG_MESSAGE(Logger::UI, mContentWindow->getChildAtIdx(idx)->getName());
-		}
 
-		mContentWindow->getChild(name+"ItemIconDragContainer/Icon")
+		mContentWindow->getChild(name+"/Icon")
 			->setProperty("Image", icon);
 
 		mContentWindow->subscribeEvent(
@@ -59,6 +82,6 @@
 			cegui_absdim(item->getSize().first*30),
 			cegui_absdim(item->getSize().second*30)));
 
-		addChildWindow(mContentWindow);
-	}
+
+        }
 }

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -1,1535 +1,1498 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h"
-
-#include "MovementControlState.h"
-
-#include <utility>
-
-#include "AbstractMovement.h"
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "CreatureControllerManager.h"
-#include "DebugWindow.h"
-#include "Exception.h"
-#include "GameObjectManager.h"
-#include "InputManager.h"
-#include "Logger.h"
-#include "MeshObject.h"
-#include "MeshAnimation.h"
-#include "MovementControlState.h"
-#include "PhysicsManager.h"
-#include "PhysicsMaterialRaycast.h"
-#include "PhysicalThing.h"
-#include "RulesMessages.h"
-#include "World.h"
-#include "LineSetPrimitive.h"
-#include "WindowFactory.h"
-#include "AnimationManager.h"
-#include "UiSubsystem.h"
-#include "WindowManager.h"
-
-#include <numeric>
-
-using namespace Ogre;
-
-namespace rl {
-
-    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mController(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mNewCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE),
-        mCharPositionsBuffer(20),
-        mCharPositionsBufferIdx(-1),
-        mCharacterOccludedTime(0),
-        mCharacterOccludedFrameCount(0),
-        mLastDistance(0.0f),
-        mTimeOfLastCollision(0.0f),
-        mIsPathfinding (false),
-        mLastReachableBufPos(1),
-        mLastCameraCollision(0)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 0.8f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(
-            mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb = charMesh->getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-
-        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
-            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
-
-        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
-            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        mCombatSelector.setFilter(NULL);
-        delete mSelector.getFilter();
-        mSelector.setFilter(NULL);
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
-        {
-            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        mController = NULL;
-
-        // actors aren't controlled anymore
-        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-        mCameraActor->getPhysicalThing()->freeze();
-        // cam<->Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        // cam<->Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL && go->isHighlighted())
-        {
-            go->setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if (mController == NULL )
-        {
-            mController =
-                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
-        }
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID("camera"));
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
-
-        // We also handle cam<->level, cam<->default cam<->char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-
-        mCharacterState.mCurrentMovementState = MOVE_NONE;
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (!isMouseUsedByCegui() )
-        {
-            if (mInvertedMouse)
-                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            else
-                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
-        }
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor->getWorldPosition();
-        Quaternion charOri = mCharacterActor->getWorldOrientation();
-        //mCharBody->getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear() && !(mCharacter->getLifeState() & Effect::LS_NO_COMBAT))
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mController != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen->calculateBaseVelocity(baseVelocity) )
-            {
-                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
-                {
-                    Degree baseVel(baseVelocity*360);
-                    if( mViewMode != VM_PNYX_MODE )
-                    {
-                        if (movement & TURN_LEFT)
-                            rotation = elapsedTime * baseVel;
-                        if (movement & TURN_RIGHT)
-                            rotation = -elapsedTime * baseVel;
-                    }
-
-                    // mouse
-                    if( !isMouseUsedByCegui() )
-                    {
-                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                        {
-                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
-                            {
-                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
-                            }
-                        }
-                    }
-                }
-
-
-                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
-                {
-                    // virtual yaw
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        mCamVirtualYaw = mNewCamVirtualYaw;
-                    }
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(45);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(-45);
-                    }
-                    else
-                    {
-                        mNewCamVirtualYaw =Degree(0);
-                    }
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
-                    }
-                }
-
-                if( mViewMode == VM_FIRST_PERSON )
-                {
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mCamVirtualYaw -= Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw <= Degree(-90) )
-                            mCamVirtualYaw = Degree(-90);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mCamVirtualYaw += Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw >= Degree(90) )
-                            mCamVirtualYaw = Degree(90);
-                    }
-                    else
-                    {
-                        if( mCamVirtualYaw > Degree(0) )
-                        {
-                            mCamVirtualYaw -= Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw <= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                        else if( mCamVirtualYaw < Degree(0) )
-                        {
-                            mCamVirtualYaw += Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw >= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                    }
-                }
-            }
-
-
-
-            if( mViewMode != VM_PNYX_MODE )
-            {
-                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
-                {
-                    // move forward or backward if wanted
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    else if( movement & MOVE_BACKWARD )
-                        direction += Vector3::UNIT_Z;
-
-                    mController->setMovement(
-                        CreatureController::MT_HOCHSPRUNG,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_SNEAK )
-                {
-                    Vector3 direction(Vector3::ZERO);
-                    if (movement & MOVE_FORWARD)
-                        direction.z = -1;
-                    else if( movement & MOVE_BACKWARD)
-                        direction.z = 1;
-                    mController->setMovement(
-                        CreatureController::MT_SCHLEICHEN,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_JUMP && 
-                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                    {
-                        type = CreatureController::MT_WEITSPRUNG;
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    }
-                    mController->setMovement(
-                        type,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_FORWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
-                    if( movement & MOVE_RUN_LOCK )
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_RENNEN;
-                        else
-                            type = CreatureController::MT_LAUFEN;
-                    }
-                    else
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_GEHEN;
-                        else
-                            type = CreatureController::MT_JOGGEN;
-                    }
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,-1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_BACKWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
-                    if( !(movement & MOVE_RUN) )
-                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
-                {
-                    Vector3 direction = Vector3::UNIT_X;
-                    if( movement & MOVE_LEFT )
-                        direction = Vector3::NEGATIVE_UNIT_X;
-                    mController->setMovement(
-                        CreatureController::MT_SEITWAERTS_GEHEN,
-                        direction, 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else
-                {
-                    mController->setMovement(
-                        CreatureController::MT_STEHEN, 
-                        Vector3(0,0,0),
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-            }
-            else // VM_PNYX_MODE
-            {
-                // turn to the direction entered
-                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
-                {
-                    // direction to turn to
-                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
-                    Degree yaw(0);
-                    switch(direction)
-                    {
-                    case MOVE_FORWARD:
-                        yaw = Degree(0);
-                        break;
-                    case MOVE_FORWARD | MOVE_LEFT:
-                        yaw = Degree(45);
-                        break;
-                    case MOVE_FORWARD | MOVE_RIGHT:
-                        yaw = Degree(-45);
-                        break;
-                    case MOVE_RIGHT:
-                        yaw = Degree(-90);
-                        break;
-                    case MOVE_LEFT:
-                        yaw = Degree(90);
-                        break;
-                    case MOVE_BACKWARD:
-                        yaw = Degree(180);
-                        break;
-                    case MOVE_BACKWARD | MOVE_LEFT:
-                        yaw = Degree(-225);
-                        break;
-                    case MOVE_BACKWARD | MOVE_RIGHT:
-                        yaw = Degree(225);
-                        break;
-                    default:
-                        break;
-                    }
-                    yaw+=mCamYaw;
-
-                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else
-                    {
-                        if( movement & MOVE_JUMP )
-                            type = CreatureController::MT_WEITSPRUNG;
-                        else
-                        {
-                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
-                            {
-                            case MOVE_RUN:
-                                type = CreatureController::MT_GEHEN;
-                                break;
-                            case MOVE_RUN_LOCK:
-                                type = CreatureController::MT_LAUFEN;
-                                break;
-                            case MOVE_RUN | MOVE_RUN_LOCK:
-                                type = CreatureController::MT_RENNEN;
-                                break;
-                            default:
-                                break;
-                            }
-                        }
-                    }
-
-
-                    mController->setMovement(
-                        type,
-                        Vector3::NEGATIVE_UNIT_Z,
-                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
-                }
-                else
-                {
-                    // don't move
-                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else if( movement & MOVE_JUMP )
-                        type = CreatureController::MT_HOCHSPRUNG;
-                    mController->setMovement(
-                        type,
-                        Vector3::ZERO,
-                        Vector3::ZERO);
-                }
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        if ( !isMouseUsedByCegui() )
-        {
-            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
-            if (mDesiredDistance < mDistanceRange.first)
-            {
-                mDesiredDistance = mDistanceRange.first;
-            }
-            if (mDesiredDistance > mDistanceRange.second)
-            {
-                mDesiredDistance = mDistanceRange.second;
-            }
-
-            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-            {
-                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
-
-                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
-                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
-            }
-        }
-
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        // Kamera-Gr???e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-        AxisAlignedBox aabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
- 
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode->lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-           cameraNode->lookAt(
-                charPos
-                + charOri * /* virtualCamOri * */  mLookAtOffset
-                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-            Real dist = (mCameraActor->getPosition() - charPos).length();
-            cameraNode->lookAt(
-                charPos
-                + camOri * virtualCamOri * mLookAtOffset
-                + camOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody->getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody->getCollision(), camOri, camPos,
-                    mCharBody->getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor->setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor->setVisible(true);
-            }
-        }
-        mCameraActor->setOrientation(cameraNode->getOrientation());
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to CreatureController(Manager)
-    int MovementControlState::userProcess()
-    {
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        // test if this is cam-player-collide
-        if( ( m_body0 == mCamBody && m_body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
-            ( m_body1 == mCamBody && m_body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
-        {
-            return 0;
-        }
-
-        setContactSoftness(0.8f);
-        setContactElasticity(0.0f);
-        mLastCameraCollision = 0;
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to CreatureController
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to CreatureController?
-        SceneNode* node = mCharacterActor->_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node->getPosition();
-        Quaternion egal;
-        mCamBody->getPositionOrientation(bodpos,egal);
-        ss
-            << "scene node : " << playpos << std::endl
-            << "player velocity : " << -mController->getVelocity().z << std::endl
-            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
-            << "camera posder : " << static_cast<Camera*>(
-                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
-            << "camera pos : " << bodpos << std::endl
-            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
-            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
-    {
-        mLastCameraCollision += timestep;
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-
-        // Ringbuffer mit Positionen des Characters
-        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
-        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
-
-
-        // Kamera-Gr???e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-            mCameraActor->getControlledObject());
-        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr???e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr???e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
-            {
-                mCharacterOccludedTime += timestep;
-                mCharacterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                mCharacterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Groesse der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            // gibt an, ob schon gebufferte Daten fuer den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
-                // und durch "Geraden" miteinander verbunden werden koennen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = mCharPositionsBuffer.size();
-
-                if( !mIsPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta < buffSize )
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta >= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
-                        mIsPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    mLastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    mLastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                mIsPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody->getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody->getMassMatrix(mass, inertia);
-
-            //mCamBody->setPositionOrientation(newCamPos, camOri);
-            mCamBody->setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody->setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_PNYX_MODE)
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr???e beziehen
-            CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-            AxisAlignedBox aabb = ogreCam->getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody->getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i < 6; i++ )
-            {
-                RaycastInfo info = mRaycast->execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody && info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() < diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() < radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            if( CollisionFound )
-                mTimeOfLastCollision = 0.0f;
-            else
-                mTimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-
-            if( slowlyMoveBackward &&
-                desiredDistance > mLastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
-                {
-                    newDistance = mLastDistance;
-                }
-                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = mLastDistance;
-
-                if( newDistance > desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                mLastDistance = newDistance;
-            }
-            else
-                mLastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i < end; ++i)
-        {
-            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
-            if (creature &&
-				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
-				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if ( isMouseUsedByCegui() )
-            return;
-
-        //InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL && oldGo != newGo)
-        {
-            oldGo->setHighlighted(false);
-        }
-
-        if (newGo != NULL && newGo != oldGo)
-        {
-            newGo->setHighlighted(true);
-        }
-/*
-        // Optionen anzeigen
-        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
-        {
-            newGo->doDefaultAction(mCharacter, NULL);
-        }
-*/
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
-        }
-        catch(...)
-        {
-            aabb = charMesh->getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
-            resetCamera();
-        }
-        else if(mode == VM_FREE_CAMERA)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
-            resetCamera();
-        }
-        else // mode == VM_PNYX_MODE
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.5;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr???e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        aab = mesh->getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh->getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr???e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else if(getViewMode() == VM_FREE_CAMERA)
-            setViewMode(VM_PNYX_MODE);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        mCamVirtualYaw = Degree(0);
-        mNewCamVirtualYaw = Degree(0);
-        mLastCameraCollision = 0;
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor->setVisible(false);
-        else
-            mCharacterActor->setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, "Camera resetted.");
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
-            // First see, if a control state action is defined
-	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
-            if (command == "")
-            {
-                // No. So try global actions.
-                command = mCommandMapper->getGlobalAction(code);
-            }
-            else if (command == "freeflight_mode")
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                retval = true;
-            }
-            else if (command == "reset_camera")
-            {
-                resetCamera();
-                retval = true;
-            }
-            else if (command == "toggle_view_mode")
-            {
-                toggleViewMode();
-                retval = true;
-            }
-            else if( startAction(command, mCharacter) )
-                retval = true;
-
-
-
-            if( !retval )
-            {
-                int movement = mCommandMapper->getMovement(evt.key);
-
-                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
-                {
-                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-                    movement &= ~MOVE_RUN_LOCK;
-                    retval = true;
-                }
-
-                if (movement != MOVE_NONE)
-                {
-                    mCharacterState.mCurrentMovementState |= movement;
-                    retval = true;
-                }
-            }
-        }
-
-
-        if( ControlState::keyPressed(evt, handled || retval ) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper->getMovement(evt.key);
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, retval) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-/*
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-*/
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-        // default action und action-selektor, falls object selected
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-        if( newGo != NULL && !isMouseUsedByCegui() )
-        {
-            if( id == OIS::MB_Left )
-            {
-                if( newGo->getDefaultAction(mCharacter) != NULL )
-                {
-                    newGo->doDefaultAction(mCharacter, NULL);
-                    handled = true;
-                }
-            }
-            else if( id == OIS::MB_Right )
-            {
-                WindowFactory::getSingleton().showActionChoice(newGo);
-                handled = true;
-            }
-        }
-
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode->getParent() == NULL)
-        {
-            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        lineSet->clear();
-        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-    bool MovementControlState::updateAfterGameObjectLoading()
-    {
-        resume(); //saving/loading only possible in movement state
-        //// We want to check for visibility from char's POV.
-        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mSelector.track(mCharacter);
-        //mSelector.setRadius(3.0);
-
-        //// Same for combat selector
-        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mCombatSelector.track(mCharacter);
-        //mCombatSelector.setRadius(10.0);
-
-        return false;
-    }
-
-    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
-    {
-        if(mSelector.getFirstSelectedObject())
-        {
-            mSelector.getFirstSelectedObject()->setHighlighted(false);
-        }
-
-        pause(); //saving/loading only possible in movement state
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "MovementControlState.h"
+
+#include <utility>
+
+#include "AbstractMovement.h"
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
+#include "CommandMapper.h"
+#include "ConfigurationManager.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "CreatureControllerManager.h"
+#include "DebugWindow.h"
+#include "Exception.h"
+#include "GameObjectManager.h"
+#include "InputManager.h"
+#include "Logger.h"
+#include "MeshObject.h"
+#include "MeshAnimation.h"
+#include "MovementControlState.h"
+#include "PhysicsManager.h"
+#include "PhysicsMaterialRaycast.h"
+#include "PhysicalThing.h"
+#include "RulesMessages.h"
+#include "World.h"
+#include "LineSetPrimitive.h"
+#include "WindowFactory.h"
+#include "AnimationManager.h"
+#include "UiSubsystem.h"
+#include "WindowManager.h"
+
+#include <numeric>
+
+using namespace Ogre;
+
+namespace rl {
+
+    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
+
+    MovementControlState::CharacterState::CharacterState()
+        :
+        mCurrentMovementState(MOVE_NONE),
+        mLastMovementState(MOVE_NONE)
+    {
+    }
+
+    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
+        mController(NULL),
+        mCharacterState(),
+        mDesiredDistance(2.00),
+        mDistanceRange(0.60, 7.00),
+        mCamYaw(0),
+        mCamVirtualYaw(0),
+        mNewCamVirtualYaw(0),
+        mPitch(20),
+        mRoll(0),
+        mPitchRange(Degree(-75), Degree(85)),
+        mLinearSpringK(400.0f),
+        mLinearDampingK(Math::NEG_INFINITY),
+        mCamMoveAwayVelocity(4.0f),
+        mCamMoveAwayStartTime(0.25f),
+        mCamMoveAwayRange(8.0f),
+        mLookAtOffset(),
+        mRotationSpeed(Degree(120.0f)),
+        mMouseSensitivity(4.0f),
+        mViewMode(VM_THIRD_PERSON),
+        mRaycast(new PhysicsMaterialRaycast()),
+        mConvexcast(new PhysicsMaterialConvexcast()),
+        mCameraCastCollision(NULL),
+        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
+        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
+            QUERYFLAG_CREATURE),
+        mCharPositionsBuffer(100),
+        mCharPositionsBufferIdx(-1),
+        mCharacterOccludedTime(0),
+        mCharacterOccludedFrameCount(0),
+        mLastDistance(0.0f),
+        mTimeOfLastCollision(0.0f),
+        mIsPathfinding (false),
+        mLastReachableBufPos(1),
+        mLastCameraCollision(0)
+    {
+        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
+
+
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
+
+        // The relationCoefficient determines the relation between spring accel in target direction
+        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
+        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
+        // in a damped ozillation before reaching equilibrium.
+        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
+        Real relationCoefficient = 0.8f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+
+        // Offset for the look at point,
+        // so the cam does look at the characters head instead of the feet.
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(
+            mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb = charMesh->getDefaultSize();
+
+        // this will be recalculated in calculateOptimalCameraPosition
+        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
+
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mCombatSelector.setFilter(filter);
+
+        mSelector.setFilter(new InSceneSelectionFilter());
+
+        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
+            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
+
+        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
+            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
+
+        // Kamera-Groesse beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+            mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+        camRadius *= 1.1f;
+        Vector3 verts[80];
+        int k = 0;
+        for(int i = 0; i < 16; i++)
+        {
+            int n;
+            n = abs(abs(i-8)-8)+1;
+            for(int j = 0; j < n; j++)
+            {
+                Real h = (i-7.5f)/7.5f;
+                Degree angle(360.0f/(n+1)*j);
+                Real rad = Math::Sqrt(1-h*h);
+                verts[k++] = camRadius*Vector3(rad*Math::Cos(angle),rad*Math::Sin(angle),h);
+            }
+        }
+        //! TODO: remove this workaround (newton-bug: "spheres don't cast"!)
+        mCameraCastCollision = new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80);
+        //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody->getWorld(), Vector3::UNIT_SCALE * camRadius);
+    }
+
+    //------------------------------------------------------------------------
+    MovementControlState::~MovementControlState()
+    {
+        delete mCombatSelector.getFilter();
+        mCombatSelector.setFilter(NULL);
+        delete mSelector.getFilter();
+        mSelector.setFilter(NULL);
+        delete mRaycast;
+        delete mConvexcast;
+        delete mCameraCastCollision;
+
+        if (DebugWindow::getSingletonPtr())
+        {
+            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
+        }
+
+        // Remove debug scene node from character node, if debugview was used.
+        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
+        {
+            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::pause()
+    {
+        mController = NULL;
+
+        // actors aren't controlled anymore
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
+        // cam<->Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        // cam<->Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+
+
+        // Unhighlight selected object, if any.
+        GameObject* go = mSelector.getFirstSelectedObject();
+        if (go != NULL && go->isHighlighted())
+        {
+            go->setHighlighted(false);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resume()
+    {
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
+        // We want to check for visibility from char's POV.
+        mSelector.setCheckVisibility(true, mCharacter);
+        mSelector.track(mCharacter);
+        mSelector.setRadius(3.0);
+
+        // Same for combat selector
+        mCombatSelector.setCheckVisibility(true, mCharacter);
+        mCombatSelector.track(mCharacter);
+        mCombatSelector.setRadius(10.0);
+
+
+        // control camera
+        mCameraActor->getPhysicalThing()->setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
+
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultSoftness(0.8f);
+        mat_pair->setDefaultElasticity(0.4f);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultSoftness(0.8f);
+        mat_pair->setDefaultElasticity(0.4f);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultSoftness(0.8f);
+        mat_pair->setDefaultElasticity(0.4f);
+
+        mCharacterState.mCurrentMovementState = MOVE_NONE;
+
+        setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::run(Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        updateCharacter(elapsedTime);
+        updateCameraLookAt(elapsedTime);
+        updateSelection();
+
+
+
+        // camera pitch
+        if (!isMouseUsedByCegui() )
+        {
+            if (mInvertedMouse)
+                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            else
+                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
+            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
+        }
+
+
+        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
+
+        if (isEnemyNear() && !(mCharacter->getLifeState() & Effect::LS_NO_COMBAT))
+        {
+            InputManager::getSingleton().pushControlState(CST_COMBAT);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+        if( mController != NULL )
+        {
+            int movement = mCharacterState.mCurrentMovementState;
+            Degree rotation(0);
+
+            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
+            Real baseVelocity = 0;
+            if( drehen->calculateBaseVelocity(baseVelocity) )
+            {
+                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
+                {
+                    Degree baseVel(baseVelocity*360);
+                    if( mViewMode != VM_PNYX_MODE )
+                    {
+                        if (movement & TURN_LEFT)
+                            rotation = elapsedTime * baseVel;
+                        if (movement & TURN_RIGHT)
+                            rotation = -elapsedTime * baseVel;
+                    }
+
+                    // mouse
+                    if( !isMouseUsedByCegui() )
+                    {
+                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                        {
+                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                            {
+                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
+                            }
+                        }
+                    }
+                }
+
+
+                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
+                {
+                    // virtual yaw
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        mCamVirtualYaw = mNewCamVirtualYaw;
+                    }
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(45);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(-45);
+                    }
+                    else
+                    {
+                        mNewCamVirtualYaw =Degree(0);
+                    }
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
+                    }
+                }
+
+                if( mViewMode == VM_FIRST_PERSON )
+                {
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mCamVirtualYaw -= Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw <= Degree(-90) )
+                            mCamVirtualYaw = Degree(-90);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mCamVirtualYaw += Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw >= Degree(90) )
+                            mCamVirtualYaw = Degree(90);
+                    }
+                    else
+                    {
+                        if( mCamVirtualYaw > Degree(0) )
+                        {
+                            mCamVirtualYaw -= Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw <= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                        else if( mCamVirtualYaw < Degree(0) )
+                        {
+                            mCamVirtualYaw += Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw >= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                    }
+                }
+            }
+
+
+
+            if( mViewMode != VM_PNYX_MODE )
+            {
+                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
+                {
+                    // move forward or backward if wanted
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    else if( movement & MOVE_BACKWARD )
+                        direction += Vector3::UNIT_Z;
+
+                    mController->setMovement(
+                        CreatureController::MT_HOCHSPRUNG,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_SNEAK )
+                {
+                    Vector3 direction(Vector3::ZERO);
+                    if (movement & MOVE_FORWARD)
+                        direction.z = -1;
+                    else if( movement & MOVE_BACKWARD)
+                        direction.z = 1;
+                    mController->setMovement(
+                        CreatureController::MT_SCHLEICHEN,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_JUMP && 
+                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                    {
+                        type = CreatureController::MT_WEITSPRUNG;
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    }
+                    mController->setMovement(
+                        type,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_FORWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
+                    if( movement & MOVE_RUN_LOCK )
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_RENNEN;
+                        else
+                            type = CreatureController::MT_LAUFEN;
+                    }
+                    else
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_GEHEN;
+                        else
+                            type = CreatureController::MT_JOGGEN;
+                    }
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,-1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_BACKWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
+                    if( !(movement & MOVE_RUN) )
+                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
+                {
+                    Vector3 direction = Vector3::UNIT_X;
+                    if( movement & MOVE_LEFT )
+                        direction = Vector3::NEGATIVE_UNIT_X;
+                    mController->setMovement(
+                        CreatureController::MT_SEITWAERTS_GEHEN,
+                        direction, 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else
+                {
+                    mController->setMovement(
+                        CreatureController::MT_STEHEN, 
+                        Vector3(0,0,0),
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+            }
+            else // VM_PNYX_MODE
+            {
+                // turn to the direction entered
+                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
+                {
+                    // direction to turn to
+                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
+                    Degree yaw(0);
+                    switch(direction)
+                    {
+                    case MOVE_FORWARD:
+                        yaw = Degree(0);
+                        break;
+                    case MOVE_FORWARD | MOVE_LEFT:
+                        yaw = Degree(45);
+                        break;
+                    case MOVE_FORWARD | MOVE_RIGHT:
+                        yaw = Degree(-45);
+                        break;
+                    case MOVE_RIGHT:
+                        yaw = Degree(-90);
+                        break;
+                    case MOVE_LEFT:
+                        yaw = Degree(90);
+                        break;
+                    case MOVE_BACKWARD:
+                        yaw = Degree(180);
+                        break;
+                    case MOVE_BACKWARD | MOVE_LEFT:
+                        yaw = Degree(-225);
+                        break;
+                    case MOVE_BACKWARD | MOVE_RIGHT:
+                        yaw = Degree(225);
+                        break;
+                    default:
+                        break;
+                    }
+                    yaw+=mCamYaw;
+
+                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else
+                    {
+                        if( movement & MOVE_JUMP )
+                            type = CreatureController::MT_WEITSPRUNG;
+                        else
+                        {
+                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
+                            {
+                            case MOVE_RUN:
+                                type = CreatureController::MT_GEHEN;
+                                break;
+                            case MOVE_RUN_LOCK:
+                                type = CreatureController::MT_LAUFEN;
+                                break;
+                            case MOVE_RUN | MOVE_RUN_LOCK:
+                                type = CreatureController::MT_RENNEN;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+
+                    mController->setMovement(
+                        type,
+                        Vector3::NEGATIVE_UNIT_Z,
+                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
+                }
+                else
+                {
+                    // don't move
+                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else if( movement & MOVE_JUMP )
+                        type = CreatureController::MT_HOCHSPRUNG;
+                    mController->setMovement(
+                        type,
+                        Vector3::ZERO,
+                        Vector3::ZERO);
+                }
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        // camera position (distance)
+        if ( !isMouseUsedByCegui() )
+        {
+            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
+            if (mDesiredDistance < mDistanceRange.first)
+            {
+                mDesiredDistance = mDistanceRange.first;
+            }
+            if (mDesiredDistance > mDistanceRange.second)
+            {
+                mDesiredDistance = mDistanceRange.second;
+            }
+
+            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+            {
+                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
+
+                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
+                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
+            }
+        }
+
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+        Vector3 charPos;
+        charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        // Kamera-Gr???e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+        AxisAlignedBox aabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
+ 
+
+        if( mViewMode == VM_FIRST_PERSON)
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
+            cameraNode->lookAt(
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
+                Node::TS_WORLD);
+        }
+        else if( mViewMode == VM_THIRD_PERSON )
+        {
+           cameraNode->lookAt(
+                charPos
+                + charOri * /* virtualCamOri * */  mLookAtOffset
+                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
+                Node::TS_WORLD);
+
+        }
+        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+            Real dist = (mCameraActor->getPosition() - charPos).length();
+            cameraNode->lookAt(
+                charPos
+                + camOri * virtualCamOri * mLookAtOffset
+                + camOri * (-Vector3::UNIT_Z*radius),
+                Node::TS_WORLD);
+        }
+
+
+        // Character ausblenden, wenn Kamera zu nah.
+        if( mViewMode != VM_FIRST_PERSON )
+        {
+            // here the real charOri of the object is needed
+            Vector3 charPos;
+            Quaternion charOri;
+            mCharBody->getPositionOrientation(charPos, charOri);
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+            Vector3 camPoint, charPoint, normal;
+            int collisionPoints =
+                OgreNewt::CollisionTools::CollisionClosestPoint(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    mCamBody->getCollision(), camOri, camPos,
+                    mCharBody->getCollision(), charOri, charPos,
+                    camPoint, charPoint, normal, 0 // set threadindex to 0, I hope this is ok!
+                    );
+            if( collisionPoints == 0 )
+                mCharacterActor->setVisible(false);
+            else
+            {
+                // eigentlich muss hier transparent gemacht werden!
+                mCharacterActor->setVisible(true);
+            }
+        }
+        mCameraActor->setOrientation(cameraNode->getOrientation());
+    }
+
+
+    int MovementControlState::onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex )
+    {
+        if( mViewMode == VM_FIRST_PERSON )
+            return 0;
+
+        // test if this is cam-player-collide
+        if( ( body0 == mCamBody && body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
+            ( body1 == mCamBody && body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
+        {
+            return 0;
+        }
+
+        return 1;
+    }
+
+    void MovementControlState::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int)
+    {
+        mLastCameraCollision = 0;
+    }
+
+    //------------------------------------------------------------------------
+    // character callback moved to CreatureController
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+        calculateCamera(timestep);
+
+
+
+
+        ///@todo move to CreatureController?
+        SceneNode* node = mCharacterActor->_getSceneNode();
+        std::ostringstream ss;
+        Vector3 bodpos, playpos = node->getPosition();
+        Quaternion egal;
+        mCamBody->getPositionOrientation(bodpos,egal);
+        ss
+            << "scene node : " << playpos << std::endl
+            << "player velocity : " << -mController->getVelocity().z << std::endl
+            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
+            << "camera posder : " << static_cast<Camera*>(
+                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
+            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
+            << "camera pos : " << bodpos << std::endl
+            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
+            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
+
+        LOG_DEBUG(Logger::UI, ss.str());
+        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
+    {
+        mLastCameraCollision += timestep;
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+
+        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
+        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
+
+        // Ringbuffer mit Positionen des Characters
+        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
+        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
+
+
+        // Kamera-Gr???e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+            mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+
+            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
+            // so zur optimalen kommen
+            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
+            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
+            PhysicsMaterialRaycast::MaterialVector materialVector;
+            materialVector.push_back(charMaterialId);
+            materialVector.push_back(camMaterialId);
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 normToOptCamPos = (optimalCamPos - charPos);
+            normToOptCamPos.normalise();
+
+
+
+            RaycastInfo infoCastOptPos = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos + camRadius * normToOptCamPos, // Gr???e der Kamera einbeziehen
+                optimalCamPos + camRadius * normToOptCamPos,
+                true); // Gr???e der Kamera einbeziehen
+
+            RaycastInfo infoCastChar = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos,
+                charPos,
+                true);
+
+
+            // reset the camera if the character is to far away or cannot be seen any more (Raycast)
+            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
+            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
+            {
+                mCharacterOccludedTime += timestep;
+                mCharacterOccludedFrameCount++;
+
+                // falls zu lange, Kamera resetten:
+                if( mCharacterOccludedTime > 0.250f && mCharacterOccludedFrameCount > 5 )
+                {
+                    resetCamera();
+                    return;
+                }
+
+            }
+            else
+            {
+                mCharacterOccludedTime = 0;
+                mCharacterOccludedFrameCount = 0;
+            }
+
+            if( infoCastOptPos.mBody && !infoCastChar.mBody )
+            {
+                // andere Position ermitteln, die ziwschen optimaler und Character liegt
+                // und erreichbar ist
+                Real lenToOptCamPos = (optimalCamPos - charPos).length();
+
+                RaycastInfo infoCastNewPos;
+                Real delta = lenToOptCamPos/2.0f;
+                Vector3 temp = charPos + delta * normToOptCamPos;
+                // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
+                {
+                    infoCastNewPos = mRaycast->execute(
+                        world,
+                        &materialVector,
+                        camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
+                        temp,
+                        true);
+                    delta = delta/2.0f;
+                    if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
+                    {
+                        temp = temp - delta * normToOptCamPos;
+                    }
+                    else // kein Hindernis gefunden, weiter von Char weg
+                    {
+                        temp = temp + delta * normToOptCamPos;
+                    }
+                }
+
+                // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
+                temp = temp - 0.05 * normToOptCamPos;
+                // Groesse der Kamera einbeziehen
+                optimalCamPos = temp - camRadius * normToOptCamPos;
+                // so ab hier kann ganz normal weiter gerechnet werden!
+            }
+
+
+            // gibt an, ob schon gebufferte Daten fuer den
+            // neuen Weg existieren und dort weitergemacht werden kann,
+            // oder ob neu nach einem Weg gesucht werden muss!
+            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
+            {
+                // anderen Weg finden
+                // hier werden erstmal nur alte Player-Positionen betrachtet
+                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
+                // und durch "Geraden" miteinander verbunden werden koennen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fluessig
+                // und weich (keine scharfen Kurven) erscheinen
+
+                size_t buffSize = mCharPositionsBuffer.size();
+
+                if( !mIsPathfinding )
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
+
+
+                    // letzte Character - Position suchen, die erreichbar ist...
+                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
+                    unsigned int delta = 1;
+                    while ( delta < buffSize )
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( !info.mBody )
+                            break;
+                        delta++;
+                    }
+                    if( delta >= buffSize )
+                    {
+                        // is wohl irgendwas schiefgegangen!
+                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
+                        mIsPathfinding = false;
+                        resetCamera();
+                        return;
+                    }
+                    mLastReachableBufPos = delta;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                else
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
+
+
+                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
+                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
+                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( info.mBody )
+                            break;
+                        delta--;
+                    }
+                    mLastReachableBufPos = delta + 1;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+            }
+            else
+            {
+                mIsPathfinding = false;
+            }
+
+            Vector3 diff = camPos - optimalCamPos;
+
+            Vector3 cameraVelocity;
+            cameraVelocity = mCamBody->getVelocity();
+            // spring velocity
+            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
+
+            // get the camera mass
+            Real mass;
+            Vector3 inertia;
+            mCamBody->getMassMatrix(mass, inertia);
+
+            //mCamBody->setPositionOrientation(newCamPos, camOri);
+            mCamBody->setForce(springAcc * mass);
+        }
+        else if( mViewMode == VM_FIRST_PERSON )
+        {
+            mCamBody->setPositionOrientation(optimalCamPos, camOri);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
+    {
+        Vector3 targetCamPos;
+
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+        // get camera size
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+            charPos = charPos + charOri * mLookAtOffset;
+            if(mViewMode == VM_PNYX_MODE)
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else if(mViewMode == VM_THIRD_PERSON)
+            {
+                targetCamPos =
+                    charPos
+                    + charOri * virtualCamOri * Vector3(
+                                    0,
+                                    Math::Sin(mPitch) * mDesiredDistance,
+                                    Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + charOri * camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+
+            Vector3 diff = targetCamPos - charPos;
+
+            // Convexcast
+            PhysicsMaterialConvexcast::MaterialVector materialVector;
+            materialVector.push_back( mCharBody->getMaterialGroupID() );
+            materialVector.push_back( mCamBody->getMaterialGroupID() );
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            ConvexcastInfo info = mConvexcast->execute(
+                    world,
+                    &materialVector,
+                    mCameraCastCollision,
+                    charPos,
+                    Quaternion::IDENTITY,
+                    targetCamPos,
+                    true);
+
+            bool CollisionFound = false;
+            if( info.mBody )
+            {
+                CollisionFound = true;
+                Real hitBodyVel = info.mBody->getVelocity().dotProduct(diff.normalisedCopy());
+                hitBodyVel = std::min(0.0f, hitBodyVel); // if the body moves, try to avoid it
+                Real dist = std::max(info.mDistance  + (hitBodyVel*timestep - 0.01)/diff.length(), 0.0);
+                diff *= dist;
+
+                mLastCameraCollision = 0;
+            }
+
+
+            // Langsames Entfernen vom Char:
+            if( CollisionFound )
+                mTimeOfLastCollision = 0.0f;
+            else
+                mTimeOfLastCollision += timestep;
+
+
+            Real desiredDistance = diff.length();
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+
+            if( slowlyMoveBackward &&
+                desiredDistance > mLastDistance )
+            {
+
+                diff.normalise();
+                Real newDistance;
+                Vector3 actDiff = camPos - charPos;
+                actDiff.normalise();
+
+                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
+                {
+                    newDistance = mLastDistance;
+                }
+                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
+                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
+                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
+                else
+                    newDistance = mLastDistance;
+
+                if( newDistance > desiredDistance )
+                    newDistance = desiredDistance;
+
+                diff = diff*newDistance;
+
+                mLastDistance = newDistance;
+            }
+            else
+                mLastDistance = desiredDistance;
+
+
+            targetCamPos = charPos + diff;
+        }
+        else  // FIRST_PERSON
+        {
+            // determine the optimal target position of the camera
+            targetCamPos =
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * virtualCamOri * Vector3(
+                                0,
+                                Math::Sin(mPitch) * mDesiredDistance,
+                                Math::Cos(mPitch) * mDesiredDistance);
+        }
+
+
+        return targetCamPos;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::isEnemyNear()
+    {
+        mCombatSelector.updateSelection();
+
+        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
+        for (size_t i = 0, end = gov.size(); i < end; ++i)
+        {
+            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
+            if (creature &&
+				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
+				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
+            {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateSelection()
+    {
+        if ( isMouseUsedByCegui() )
+            return;
+
+        InputManager* im = InputManager::getSingletonPtr();
+
+        GameObject* oldGo = mSelector.getFirstSelectedObject();
+
+        mSelector.updateSelection();
+
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+
+        if (oldGo != NULL && oldGo != newGo)
+        {
+            oldGo->setHighlighted(false);
+        }
+
+        if (newGo != NULL && newGo != oldGo)
+        {
+            newGo->setHighlighted(true);
+        }
+/*
+        // Optionen anzeigen
+        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
+        {
+            WindowFactory::getSingleton().showActionChoice(newGo);
+        }
+        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
+        {
+            newGo->doDefaultAction(mCharacter, NULL);
+        }
+*/
+    }
+
+
+    void MovementControlState::setViewMode(ViewMode mode)
+    {
+        mViewMode = mode;
+
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb;
+        try
+        {
+			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
+        }
+        catch(...)
+        {
+            aabb = charMesh->getDefaultSize();
+        }
+        if (mode == VM_FIRST_PERSON)
+        {
+            mLookAtOffset = Vector3(
+                    0,
+                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
+                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
+            mDistanceRange.first = 0.0;
+            mDistanceRange.second = 0.0;
+            mDesiredDistance = 0.0;
+            mPitchRange.first = Degree(-85);
+            mPitchRange.second = Degree(85);
+            mPitch = 0;
+            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
+            resetCamera();
+        }
+        else if(mode == VM_THIRD_PERSON)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
+            resetCamera();
+        }
+        else if(mode == VM_FREE_CAMERA)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
+            resetCamera();
+        }
+        else // mode == VM_PNYX_MODE
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.5;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
+            resetCamera();
+        }
+    }
+
+    //------------------------------------------------------------------------
+/*
+    // not used at the moment!
+    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
+    {
+        AxisAlignedBox aab;
+        Vector3 size[2];
+        Vector3 interpolatedSize;
+
+
+        // Die Gr???e der beiden Animationen abfragen
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        aab = mesh->getPoseSize(actAnim);
+        size[0] = aab.getMaximum() - aab.getMinimum();
+
+        aab = mesh->getPoseSize(newAnim);
+        size[1] = aab.getMaximum() - aab.getMinimum();
+
+        // interpolierte Gr???e (linear) berechnen
+        interpolatedSize = size[0] + factor*(size[1] - size[0]);
+
+        // LookAtOffset berechnen!
+        switch(mViewMode)
+        {
+        case VM_FIRST_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
+            break;
+        case VM_THIRD_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
+            break;
+        case VM_FREE_CAMERA:
+        default:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
+        }
+    }
+*/
+
+    //------------------------------------------------------------------------
+    MovementControlState::ViewMode MovementControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::toggleViewMode()
+    {
+        if (getViewMode() == VM_THIRD_PERSON)
+            setViewMode(VM_FIRST_PERSON);
+        else if(getViewMode() == VM_FIRST_PERSON)
+            setViewMode(VM_FREE_CAMERA);
+        else if(getViewMode() == VM_FREE_CAMERA)
+            setViewMode(VM_PNYX_MODE);
+        else
+            setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resetCamera()
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
+        mCamVirtualYaw = Degree(0);
+        mNewCamVirtualYaw = Degree(0);
+        mLastCameraCollision = 0;
+        if(mViewMode == VM_FIRST_PERSON)
+            mCharacterActor->setVisible(false);
+        else
+            mCharacterActor->setVisible(true);
+        
+        LOG_MESSAGE(Logger::UI, "Camera resetted.");
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
+            // First see, if a control state action is defined
+	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
+            if (command == "")
+            {
+                // No. So try global actions.
+                command = mCommandMapper->getGlobalAction(code);
+            }
+            else if (command == "freeflight_mode")
+            {
+                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
+                retval = true;
+            }
+            else if (command == "reset_camera")
+            {
+                resetCamera();
+                retval = true;
+            }
+            else if (command == "toggle_view_mode")
+            {
+                toggleViewMode();
+                retval = true;
+            }
+            else if( startAction(command, mCharacter) )
+                retval = true;
+
+
+
+            if( !retval )
+            {
+                int movement = mCommandMapper->getMovement(evt.key);
+
+                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
+                {
+                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
+                    movement &= ~MOVE_RUN_LOCK;
+                    retval = true;
+                }
+
+                if (movement != MOVE_NONE)
+                {
+                    mCharacterState.mCurrentMovementState |= movement;
+                    retval = true;
+                }
+            }
+        }
+
+
+        if( ControlState::keyPressed(evt, handled || retval ) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper->getMovement(evt.key);
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, retval) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+/*
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+*/
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+        // default action und action-selektor, falls object selected
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+        if( newGo != NULL && !isMouseUsedByCegui() )
+        {
+            if( id == OIS::MB_Left )
+            {
+                if( newGo->getDefaultAction(mCharacter) != NULL )
+                {
+                    newGo->doDefaultAction(mCharacter, NULL);
+                    handled = true;
+                }
+            }
+            else if( id == OIS::MB_Right )
+            {
+                WindowFactory::getSingleton().showActionChoice(newGo);
+                handled = true;
+            }
+        }
+
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    DebugVisualisableFlag MovementControlState::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updatePrimitive()
+    {
+        if (mSceneNode->getParent() == NULL)
+        {
+            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
+        }
+
+        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+        lineSet->clear();
+        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    bool MovementControlState::updateAfterGameObjectLoading()
+    {
+        resume(); //saving/loading only possible in movement state
+        //// We want to check for visibility from char's POV.
+        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mSelector.track(mCharacter);
+        //mSelector.setRadius(3.0);
+
+        //// Same for combat selector
+        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mCombatSelector.track(mCharacter);
+        //mCombatSelector.setRadius(10.0);
+
+        return false;
+    }
+
+    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
+    {
+        if(mSelector.getFirstSelectedObject())
+        {
+            mSelector.getFirstSelectedObject()->setHighlighted(false);
+        }
+
+        pause(); //saving/loading only possible in movement state
+
+        return false;
+    }
+}

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -17,9 +17,7 @@
 
 #include "UiSubsystem.h"
 
-#include <CEGUISystem.h>
-#include <CEGUIWindow.h>
-#include <CEGUIWindowManager.h>
+#include <CEGUI.h>
 
 #ifdef __APPLE__
 #   include <OgreCEGUIRenderer/OgreCEGUIRenderer.h>
@@ -39,6 +37,8 @@
 #include "GameLoop.h"
 #include "GameObjectManager.h"
 #include "InputManager.h"
+#include "ItemDescriptionDragContainer.h"
+#include "ItemIconDragContainer.h"
 #include "Logger.h"
 #include "RulesMessages.h"
 #include "ScriptWrapper.h"
@@ -50,6 +50,18 @@
 using namespace Ogre;
 template<> rl::UiSubsystem* Singleton<rl::UiSubsystem>::ms_Singleton = 0;
 
+// this function needs to be in the CEGUI-namespace
+namespace CEGUI{
+    void initializeOwnCeguiWindowFactories()
+    {
+            CEGUI::WindowFactoryManager& wfMgr = CEGUI::WindowFactoryManager::getSingleton();
+            wfMgr.addFactory(&CEGUI_WINDOW_FACTORY(ItemDescriptionDragContainer)); // ohne rl:: davor hier!
+            //wfMgr.addFalagardWindowMapping("ItemDescriptionDragContainer", "CEGUI/ItemDescriptionDragContainer", "", "Falagard/Default");
+            wfMgr.addFactory(&CEGUI_WINDOW_FACTORY(ItemIconDragContainer)); // ohne rl:: davor hier!
+            //wfMgr.addFalagardWindowMapping("ItemIconDragContainer", "CEGUI/ItemIconDragContainer", "", "Falagard/Default");
+    }
+}
+
 namespace rl {
     const char* UiSubsystem::CEGUI_ROOT = "RootWindow";
 
@@ -138,9 +150,14 @@
         sheet->setZOrderingEnabled(true);
         sheet->moveToBack();
         System::getSingleton().setDefaultTooltip("RastullahLook/Tooltip");
+
+        CEGUI::initializeOwnCeguiWindowFactories();
+
         LOG_MESSAGE2(Logger::UI, "CEGUI initialized.",
             "UiSubsystem::initializeUiSubsystem");
 
+
+
         mWindowManager = new WindowManager();
 
         //Initializing InputManager
@@ -149,6 +166,7 @@
             "UiSubsystem::initializeUiSubsystem");
 
         mWindowFactory->initialize();
+        LOG_MESSAGE2(Logger::UI, "WindowFactory initialized.", "UiSubsystem::initializeUiSubsystem");
     }
 
     CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -164,6 +164,8 @@
     void WindowFactory::toggleConsole()
     {
         mConsole->setVisible(!mConsole->isVisible());
+        if( mConsole->isVisible() )
+            mConsole->getWindow()->activate();
     }
 
     void WindowFactory::toggleDebugWindow()

Modified: rl/trunk/engine/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFadeJob.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/WindowFadeJob.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -32,7 +32,7 @@
         : Job(true, true),
         mAbstractWindow(window),
         mCEGUIWindow(window->getWindow()),
-        mItemDragContainer(NULL),
+//        mItemDragContainer(NULL),
         mMode(mode),
         mChangeRate(changeRate),
         mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
@@ -47,7 +47,7 @@
         : Job(true, true),
         mAbstractWindow(NULL),
         mCEGUIWindow(window),
-        mItemDragContainer(NULL),
+//        mItemDragContainer(NULL),
         mMode(mode),
         mChangeRate(changeRate),
         mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
@@ -57,7 +57,7 @@
         mCEGUIWindow->setVisible(true);
         mCEGUIWindow->setAlpha(mCurrentAlpha);
     }
-
+/*
     WindowFadeJob::WindowFadeJob(ItemDragContainer* window, Mode mode, Real targetAlpha, Real changeRate)
         : Job(true, true),
         mAbstractWindow(NULL),
@@ -72,7 +72,7 @@
         mCEGUIWindow->setVisible(true);
         mCEGUIWindow->setAlpha(mCurrentAlpha);
     }
-
+*/
     bool WindowFadeJob::execute(Real time)
     {
         mCurrentAlpha += time * mChangeRate * Math::Sign(mTargetAlpha - mCurrentAlpha);
@@ -97,8 +97,8 @@
         {
             if( mAbstractWindow )
                 WindowManager::getSingleton().destroyWindow(mAbstractWindow);
-            else if(mItemDragContainer)
-                delete mItemDragContainer;
+//            else if(mItemDragContainer)
+//                delete mItemDragContainer;
             else
                 CEGUI::WindowManager::getSingleton().destroyWindow(mCEGUIWindow);
         }



From melven at mail.berlios.de  Mon Feb  9 21:57:50 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 21:57:50 +0100
Subject: [Dsa-hl-svn] r4756 - modules/common/gui/windows
Message-ID: <200902092057.n19Kvoo0021454@sheep.berlios.de>

Author: melven
Date: 2009-02-09 21:57:48 +0100 (Mon, 09 Feb 2009)
New Revision: 4756

Modified:
   modules/common/gui/windows/itemdescriptiondragcontainer.xml
   modules/common/gui/windows/itemicondragcontainer.xml
Log:
MERGED TO NEWTON20
(some time ago a fixed an error with the inventory in the newton20-branch)


Modified: modules/common/gui/windows/itemdescriptiondragcontainer.xml
===================================================================
--- modules/common/gui/windows/itemdescriptiondragcontainer.xml	2009-02-09 20:56:41 UTC (rev 4755)
+++ modules/common/gui/windows/itemdescriptiondragcontainer.xml	2009-02-09 20:57:48 UTC (rev 4756)
@@ -1,5 +1,5 @@
 <GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
-    <Window Type="DefaultWindow" Name="ItemDescriptionDragContainer">
+    <Window Type="ItemDescriptionDragContainer" Name="ItemDescriptionDragContainer">
 		<Property Name="UnifiedSize" Value="{{0,250},{0,120}}" />
         <Window Type="RastullahLook/StaticImage" Name="ItemDescriptionDragContainer/Icon">
             <Property Name="VerticalAlignment" Value="Bottom" />

Modified: modules/common/gui/windows/itemicondragcontainer.xml
===================================================================
--- modules/common/gui/windows/itemicondragcontainer.xml	2009-02-09 20:56:41 UTC (rev 4755)
+++ modules/common/gui/windows/itemicondragcontainer.xml	2009-02-09 20:57:48 UTC (rev 4756)
@@ -1,5 +1,5 @@
 <GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
-    <Window Type="DefaultWindow" Name="ItemIconDragContainer">
+    <Window Type="ItemIconDragContainer" Name="ItemIconDragContainer">
         <Window Type="RastullahLook/StaticImage" Name="ItemIconDragContainer/Icon">
             <Property Name="VerticalAlignment" Value="Bottom" />
             <Property Name="HorizontalAlignment" Value="Left" />



From melven at mail.berlios.de  Mon Feb  9 22:11:06 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 22:11:06 +0100
Subject: [Dsa-hl-svn] r4757 - rl/trunk
Message-ID: <200902092111.n19LB6RY023193@sheep.berlios.de>

Author: melven
Date: 2009-02-09 22:11:05 +0100 (Mon, 09 Feb 2009)
New Revision: 4757

Modified:
   rl/trunk/CMakeLists.txt
Log:
-removed plugins directory from cmake


Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-02-09 20:57:48 UTC (rev 4756)
+++ rl/trunk/CMakeLists.txt	2009-02-09 21:11:05 UTC (rev 4757)
@@ -54,6 +54,6 @@
 
 # Include subdirectories
 ADD_SUBDIRECTORY(engine)
-ADD_SUBDIRECTORY(plugins)
+#ADD_SUBDIRECTORY(plugins)
 
 PRINT_ENABLED_FEATURES()



From melven at mail.berlios.de  Mon Feb  9 22:25:58 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 9 Feb 2009 22:25:58 +0100
Subject: [Dsa-hl-svn] r4758 - rl/trunk/engine/core
Message-ID: <200902092125.n19LPwCb024595@sheep.berlios.de>

Author: melven
Date: 2009-02-09 22:25:56 +0100 (Mon, 09 Feb 2009)
New Revision: 4758

Modified:
   rl/trunk/engine/core/CMakeLists.txt
Log:
-added missing FMODEX include-dir/library to cmake


Modified: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2009-02-09 21:11:05 UTC (rev 4757)
+++ rl/trunk/engine/core/CMakeLists.txt	2009-02-09 21:25:56 UTC (rev 4758)
@@ -7,7 +7,8 @@
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
 ${MESHMAGICK_INCLUDE_DIR}
-${RUBY_INCLUDE_PATH})
+${RUBY_INCLUDE_PATH}
+${FMODEX_INCLUDE_DIR})
 
 SET(RlCore_LIB_SRCS
 src/Actor.cpp
@@ -96,7 +97,7 @@
 
 ADD_LIBRARY(RlCore SHARED ${RlCore_LIB_SRCS})
 
-TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY})
+TARGET_LINK_LIBRARIES(RlCore ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${OGRENEWT_LIBRARY} ${MESHMAGICK_LIBRARY} ${OIS_LIBRARIES} ${RUBY_LIBRARY} ${FMODEX_LIBRARY})
 
 SET_TARGET_PROPERTIES(RlCore PROPERTIES
 	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}



From fusion2 at mail.berlios.de  Mon Feb  9 23:05:00 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Mon, 9 Feb 2009 23:05:00 +0100
Subject: [Dsa-hl-svn] r4759 - in rl/trunk/editors/Lockenwickler: .
	_eric4project src
Message-ID: <200902092205.n19M50BE029581@sheep.berlios.de>

Author: fusion2
Date: 2009-02-09 23:04:51 +0100 (Mon, 09 Feb 2009)
New Revision: 4759

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MovePivot.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
Log:
- add new scenes/maps with the module explorer
- scenes are saved to xml (maps are still WIP)
- selection buffer now updates its size

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-09 22:04:51 UTC (rev 4759)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-02-08, 13:55:11 -->
+<!-- Saved: 2009-02-09, 18:57:06 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-09 22:04:51 UTC (rev 4759)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-02-08, 13:55:11 -->
+<!-- Saved: 2009-02-09, 18:57:06 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-09 22:04:51 UTC (rev 4759)
@@ -1,15 +1,33 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-02-08, 13:55:11 -->
+<!-- Saved: 2009-02-09, 18:57:06 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
+    <Summary>TODO: not implemented yet</Summary>
+    <Description></Description>
+    <Created>2009-02-09, 14:05:47</Created>
+    <Resource>
+      <Filename>src/GOIntEditor.py</Filename>
+      <Linenumber>28</Linenumber>
+    </Resource>
+  </Task>
+  <Task priority="1" completed="False" bugfix="False">
+    <Summary>TODO: not implemented yet</Summary>
+    <Description></Description>
+    <Created>2009-02-09, 14:05:47</Created>
+    <Resource>
+      <Filename>src/GOIntEditor.py</Filename>
+      <Linenumber>36</Linenumber>
+    </Resource>
+  </Task>
+  <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-02-08, 11:32:14</Created>
+    <Created>2009-02-09, 16:16:17</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
-      <Linenumber>416</Linenumber>
+      <Linenumber>424</Linenumber>
     </Resource>
   </Task>
 </Tasks>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-09 22:04:51 UTC (rev 4759)
@@ -76,7 +76,7 @@
             self.prefDialog.show()
 
         self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        self.moduleManager.moduleExplorer = self.moduleExplorerWin
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
         
         self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
         self.setWindowTitle("Rastullahs Lockenwickler")
@@ -142,6 +142,9 @@
 
         self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "filenew.png",  "Open Module")
         self.actionOpen.setObjectName("actionOpen")
+        
+        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filenew.png",  "Save Module")
+        self.actionSave.setObjectName("actionSave")
 
         self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
         self.actionClose.setObjectName("actionQuit")
@@ -200,6 +203,7 @@
 
         self.menuFile.addAction(self.actionNeu)
         self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
         self.menuFile.addAction(self.actionClose)
 
         self.menuEdit.addAction(self.actionSelect)
@@ -284,7 +288,10 @@
         newModuleWiz = NewModuleWizard(self.moduleManager, self)
         newModuleWiz.exec_()
         return
-
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
     def actionQuitSlot(self):
         self.close()
 
@@ -368,7 +375,7 @@
         self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
 
         self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
-        self.moduleExplorerDock.setObjectName("SceneExplorerDockWindow")
+        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
         self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
         self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
         self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
@@ -383,6 +390,7 @@
         self.fileToolBar.setObjectName("FileToolBar")
         self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
         self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionSave)
         self.fileToolBar.addAction(self.actionClose)
         self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
 

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-09 22:04:51 UTC (rev 4759)
@@ -16,17 +16,60 @@
  # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
 
-
+#dienstag 24.03 15.50
 import sys
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 import ogre.renderer.OGRE as og
 
+class NameInputDlg(QDialog):
+    def __init__(self, parent = None):
+        super(NameInputDlg, self).__init__(parent)
+        
+        self.nameInput = QLineEdit(self)
+        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        layout = QVBoxLayout()
+        layout.addWidget(self.nameInput)
+        layout.addWidget(buttonBox)
+        self.setLayout(layout)
+        
+        self.connect(buttonBox, SIGNAL("accepted()"), self, SLOT("accept()"))        
+        self.connect(buttonBox, SIGNAL("rejected()"), self, SLOT("reject()"))
+        
+        
+class ModuleTreeWidget(QTreeWidget):
+    def __init__(self, parent = None):
+        super(ModuleTreeWidget, self).__init__(parent)
+        
+        self.connect(self, SIGNAL("itemClicked (QTreeWidgetItem *,int)"), self.onClick)
+        self.setContextMenuPolicy(Qt.CustomContextMenu)        
+        self.connect(self, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
+
+        self.onMenuCallback = None
+
+
+#        clearAction= QAction("Clear Window",  self)
+#        self.consoleWindow.textEdit.addAction(clearAction)
+#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+#        clearAction.setShortcut("Ctrl + R")
+#        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
+
+    def setMenuCallback(self, callback):
+        self.onMenuCallback = callback
+        
+    def doMenu(self, point):
+        self.onMenuCallback(self.mapToGlobal(point))
+
+    def onClick(self, item, column):
+        pass
+
 class ModuleExplorer(QWidget):
     def __init__(self, parent=None):
         QWidget.__init__(self, parent)
-        self.sceneTreeView = QTreeWidget()
-
+        self.sceneTreeView = ModuleTreeWidget()
+        
+        self.sceneTreeView.setMenuCallback(self.onMenu)
+        
         vBoxLayout = QVBoxLayout()
         vBoxLayout.addWidget(self.sceneTreeView)
 
@@ -34,12 +77,49 @@
         
         self.nodeDict = {}
         
+        self.moduleManager = None
+      
+    def onMenu(self, point):
+        if self.moduleManager is not None:
+            menu = QMenu(self)
+            
+            newSceneAction= QAction("New Scene",  self)
+            menu.addAction(newSceneAction)
+            self.connect(newSceneAction, SIGNAL("triggered()"), self.onNewScene)
+
+            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith("Scene:"):
+                newMapAction= QAction("New Map",  self)
+                menu.addAction(newMapAction)
+                self.connect(newMapAction, SIGNAL("triggered()"), self.onNewMap)
+
+            deleteAction= QAction("Delete",  self)
+            menu.addAction(deleteAction)
+            self.connect(deleteAction, SIGNAL("triggered()"), self.onDelete)
+            
+            menu.exec_(point)
+      
+    def onNewScene(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            self.moduleManager.addSceneToModule(str(dlg.nameInput.text()))
+            self.updateView()
+            
+    def onNewMap(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            sceneName = str(self.sceneTreeView.currentItem().text(0)).replace("Scene: ", "")
+            self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
+            self.updateView()
+        
+    def onDelete(self):
+        print "delete"
+      
     def updateView(self):
         self.sceneTreeView.clear()
         
         for s in self.module.scenes:
             sceneRootItem = QTreeWidgetItem(self.sceneTreeView)
-            sceneRootItem.setText(0, s.name)
+            sceneRootItem.setText(0, "Scene: " + s.name)
             
             for m in s.mapFiles:
                 self.parseMap(m, sceneRootItem)
@@ -47,7 +127,7 @@
                 
     def parseMap(self, map, sceneRootItem):
         childItem =  QTreeWidgetItem(sceneRootItem)
-        childItem.setText(0, map.mapName)
+        childItem.setText(0, "Map: " + map.mapName)
         
         iter = map.mapNode.getChildIterator()
         while iter.hasMoreElements():
@@ -59,3 +139,5 @@
         self.module = module
         self.updateView()
 
+    def setModuleManager(self, moduleManager):
+        self.moduleManager = moduleManager

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-09 22:04:51 UTC (rev 4759)
@@ -57,8 +57,24 @@
 #                        </trigger>
 #                </zone>
 
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
 class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager):
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
         self.pathToMapFile = pathToFile
         
         mapName = pathToFile.replace("\\", "/")
@@ -66,21 +82,23 @@
         mapName = mapName[len(mapName) - 1].split(".")
         mapName = mapName[len(mapName) - 3]
         self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
         
         self.sceneManager = sceneManager
         self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
 
-        xmlTree = xml.parse(pathToFile)
-        root = xmlTree.getroot()
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
 
-        if root.attrib["formatVersion"] == "0.4.0":
-            self.parseMapNodes(root.find("nodes"))
-            #self.parseMapZones(root.find("zones"))
-        else:
-            print pathToFile + " has wrong format version. It needs to be 0.4.0"
-            return
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                #self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
 
     def parseMapNodes(self, nodeElement):
         nodes = nodeElement.getiterator("entity")
@@ -148,7 +166,7 @@
             colourSpecular = None
             lightAttenuationRange = None
             lightAttenuationConstant= None
-            lightAttenuationlinear = None
+            lightAttenuationLinear = None
             lightAttenuationQuadratic = None
 
             transformations = l.getiterator()
@@ -171,14 +189,27 @@
                 elif t.tag == "lightAttenuation":
                     lightAttenuationRange = float(t.attrib["range"])
                     lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationlinear = float(t.attrib["linear"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
                     lightAttenuationQuadratic = float(t.attrib["quadratic"])
+            
 
-            e = self.sceneManager.createEntity(lightName, "lightbulp.mesh")
+            light = self.sceneManager.createLight(lightName)
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
+            light.setDiffuseColour(colourDiffuse)
+            light.setSpecularColour(colourSpecular)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
             n = self.mapNode.createChild(lightName + "_node")
             n.attachObject(e)
+            n.attachObject(light)
             n.setPosition(lightPosition)
 
+            
     def createSound(self, soundNodes):
         #raise NotImplementedError
         return
@@ -233,34 +264,59 @@
     def createParticleSystems(self, particleNodes):
         #raise NotImplementedError
         return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        iter = self.mapNode.getChildIterator()
+        while iter.hasMoreElements():
+            iter.getNext().getName()
 
 class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager):
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
         self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
-        
-        xmlTree = xml.parse(pathToFile)
-        root = xmlTree.getroot()
-        self.name = root.attrib["name"]
-        
         self.mapFiles = [] # a list in case the module has more than one map file
         mappaths = []
+        self.name = sceneName
+
         
-        maps = root.getiterator("map")
-        for m in maps:
-            mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
             
-        for m in mappaths:
-            self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-            
-        #cmd = join(self.moduleRoot, "maps/*.rlmap.xml")
-        #maps = glob.glob(cmd)
-        #for m in maps:
-            #self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
 
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
 
+
+
 class Module():
     def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
         self.sceneManager = sceneManager
@@ -281,6 +337,18 @@
 
         self.isLoaded = False
 
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
     def isCommon(self):
         modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
         if isfile(modConfig): # is the modconfig existing?
@@ -343,15 +411,13 @@
             
         
     def loadScenes(self, sceneFiles):
-        for f in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, f, self.sceneManager, self.ogreRoot, self.gocManager))
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
 
-    def saveMaps(self):
-        return
+    def save(self):
+        for s in self.scenes:
+            s.save()
 
-    def saveScenes(self):
-        return
-
     def setResourcePaths(self, recurseFolder = ""):
         if recurseFolder == "":
             rootFolder = self.moduleRoot
@@ -384,7 +450,7 @@
         # and deletes the object
         self.gameObjectRepresentationDict = []
 
-        self.mainModule = []
+        self.mainModule = None
         self.mainModuledependencieList =[]
         self.moduleList = []
         self.userSelectionList = []
@@ -486,7 +552,7 @@
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 
-#        self.moduleExplorer.updateView()
+        self.moduleExplorer.updateView()
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
 #        e.setMaterialName("PlainColor")
@@ -502,15 +568,24 @@
         if self.selectionBuffer is None:
             self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
 
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setModuleManager(self)
+        
     # called when a click into Main Ogre Window occurs
     def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
         so = None
-        
         if self.selectionBuffer is not None:
             so = self.selectionBuffer.onSelectionClick(screenX, screenY)
         
-        
-        
         if so is not None:
             if not so.isPivot:
                 if not controlDown and not shiftDown:
@@ -697,7 +772,7 @@
         pass
 
     def save(self):
-        pass
+        self.mainModule.save()
 
     def startDropGameObjectAction(self, classid, ray):
         go = self.gocManager.getGameObjectWithClassId(classid)

Modified: rl/trunk/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MovePivot.py	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/src/MovePivot.py	2009-02-09 22:04:51 UTC (rev 4759)
@@ -191,7 +191,7 @@
                 transVec = transVec * transFactor
                 for so in self.selectionList:
                     so.entity.getParentNode().translate(transVec)
-
+                    
                 self.pivotNode.translate(transVec)
 
             # rotate mode
@@ -211,8 +211,16 @@
         self.update()
 
     def update(self):
-        if not self.isHidden:
-            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
-            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
+        vSize = og.Vector3(1.0,1.0,1.0)
+        vScale = og.Vector3(1.0,1.0,1.0)
+
+        dist = (self.camera.getDerivedPosition() - self.pivotNode._getDerivedPosition()).length()
+        vScale *= dist / 90.0
 
+        self.pivotNode.setScale(vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z)
+        #print vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z
+#        if not self.isHidden:
+#            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
+#            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
 
+

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-09 22:04:51 UTC (rev 4759)
@@ -312,7 +312,7 @@
         return self.ogreWidget.getHeight()
 
 
-    def updateCamera(self):
+    def updateCamera(self):        
         if self.moveCamForward:
             self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
         if self.moveCamBackward:
@@ -321,3 +321,5 @@
             self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
         if self.strafeCamRight:
             self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        self.moduleManager.pivot.update()

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-09 22:04:51 UTC (rev 4759)
@@ -33,6 +33,7 @@
         self.sceneManager = sceneManager
         self.camDistFromFocusNode = camDistFromFocusNode
         self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
 
     def initOgreWindow(self, renderWindowName, cameraName):
         self.renderParameters = og.NameValuePairList()
@@ -86,7 +87,13 @@
 
         if self.camera:
             self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+            
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
 
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
     def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
         og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
 

Modified: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-09 21:25:56 UTC (rev 4758)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-09 22:04:51 UTC (rev 4759)
@@ -95,7 +95,7 @@
         self.sceneMgr = sceneManager
         self.camera = sceneManager.getCamera("MainCam")
 
-        self.viewport = renderTarget
+        self.renderTarget = renderTarget
         
         # This is the material listener - Note: it is controlled by a seperate
         # RenderTargetListener, not applied globally to all targets
@@ -103,8 +103,8 @@
         
         self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
         
-        width = self.viewport.getWidth()
-        height = self.viewport.getHeight()
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
         
         self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
                                                                     og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
@@ -122,9 +122,11 @@
         self.renderTexture.addListener( self.selectionTargetListener )
         self.renderTexture.getViewport(0).setMaterialScheme("aa")
         
-        self.createRTTOverlays()
+        #self.createRTTOverlays()
 
     def update(self):
+        self.updateBufferSize()
+        
         self.renderTexture.update()        
         self.materialSwitchListener.reset()
         
@@ -146,7 +148,38 @@
 #            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
 #            
 #            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
+        
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload("SelectionPassTex")
             
+            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        else:
+            return
+            
     def onSelectionClick(self, x, y):
         self.update()
         
@@ -157,8 +190,31 @@
         
         for key in self.materialSwitchListener.colorDict:
             if self.materialSwitchListener.colorDict[key] == colVec:
-                so = SelectionObject(self.sceneMgr.getEntity(key))
-                return so
+                if key == "OgreMainWin::0::ViewportGrid":
+                    return None
+                elif key == "rayLine":
+                    return None
+                elif key == "EditorXArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorYArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorZArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorFreeMover":
+                    return None
+                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
 
         return None
         



From blakharaz at mail.berlios.de  Tue Feb 10 00:10:19 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 10 Feb 2009 00:10:19 +0100
Subject: [Dsa-hl-svn] r4760 - in rl/trunk: . docs/documents
	engine/ui/include engine/ui/src
Message-ID: <200902092310.n19NAJ0A006111@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-10 00:10:17 +0100 (Tue, 10 Feb 2009)
New Revision: 4760

Modified:
   rl/trunk/.project
   rl/trunk/docs/documents/scene_format_proposal.xml
   rl/trunk/engine/ui/include/CutsceneControlState.h
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
Log:
Interface for camera change during cutscenes


Modified: rl/trunk/.project
===================================================================
--- rl/trunk/.project	2009-02-09 22:04:51 UTC (rev 4759)
+++ rl/trunk/.project	2009-02-09 23:10:17 UTC (rev 4760)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>RL_trunk</name>
+	<name>RL</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -11,124 +11,100 @@
 			<arguments>
 				<dictionary>
 					<key>org.eclipse.cdt.core.errorOutputParser</key>
-					<value>org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GASErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.VCErrorParser;</value>
+					<value>org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GASErrorParser;org.eclipse.cdt.core.GLDErrorParser;</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
-					<value>clean all</value>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.incrementalBuildTarget</key>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
 					<value>all</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<key>org.eclipse.cdt.make.core.build.arguments</key>
 					<value></value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
-					<value>false</value>
+					<key>org.eclipse.cdt.make.core.build.command</key>
+					<value>/usr/bin/make</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.environment</key>
-					<value></value>
+					<key>org.eclipse.cdt.make.core.build.location</key>
+					<value>/home/blakharaz/rastullah/current</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
-					<value>true</value>
+					<key>org.eclipse.cdt.make.core.build.target.auto</key>
+					<value>all</value>
 				</dictionary>
 				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.target.clean</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
 					<key>org.eclipse.cdt.make.core.build.target.inc</key>
 					<value>all</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enabledIncrementalBuild</key>
-					<value>true</value>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.location</key>
-					<value></value>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>/home/blakharaz/rastullah/current</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.target.clean</key>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
 					<value>clean</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
-					<value>true</value>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
-					<value>clean</value>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
 					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.target.full</key>
-					<value>clean all</value>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<key>org.eclipse.cdt.make.core.enabledIncrementalBuild</key>
 					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildCommand</key>
-					<value>make</value>
+					<key>org.eclipse.cdt.make.core.environment</key>
+					<value></value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.stopOnError</key>
-					<value>false</value>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
-					<value>all</value>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.target.auto</key>
-					<value>all</value>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>false</value>
 				</dictionary>
 			</arguments>
 		</buildCommand>
 		<buildCommand>
 			<name>org.eclipse.cdt.make.core.ScannerConfigBuilder</name>
 			<arguments>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.ScannerConfigDiscoveryEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.makeBuilderParserId</key>
-					<value>org.eclipse.cdt.make.core.GCCScannerInfoConsoleParser</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.esiProviderCommandEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.siProblemGenerationEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.useDefaultESIProviderCmd</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.makeBuilderParserEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.esiProviderParserId</key>
-					<value>org.eclipse.cdt.make.core.GCCSpecsConsoleParser</value>
-				</dictionary>
 			</arguments>
 		</buildCommand>
 	</buildSpec>
 	<natures>
-		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
 		<nature>org.eclipse.cdt.make.core.makeNature</nature>
 		<nature>org.eclipse.cdt.make.core.ScannerConfigNature</nature>
-		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
 	</natures>
 </projectDescription>

Modified: rl/trunk/docs/documents/scene_format_proposal.xml
===================================================================
--- rl/trunk/docs/documents/scene_format_proposal.xml	2009-02-09 22:04:51 UTC (rev 4759)
+++ rl/trunk/docs/documents/scene_format_proposal.xml	2009-02-09 23:10:17 UTC (rev 4760)
@@ -192,6 +192,16 @@
         	     <colour r="0.5" g="0.5" b="0.5" />
         	</fog>
 
-       	</environment>
+       	</environment>
+
+        <camerapaths>
+            <camerapath name="bauerrogalfsbetrunkenerheimweg">
+               <cameraposition>
+                  <position x="15" y="0.5" z="-23.4"/>
+                  <rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+                  <rotation qx="0.707" qy="0.0" qz="0.707" qw="1.0" /> <!-- Two rotations define a rotating camera -->
+               </cameraposition>
+            </camerapath>
+        </camerapaths>
 
 </rastullahmap>

Modified: rl/trunk/engine/ui/include/CutsceneControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneControlState.h	2009-02-09 22:04:51 UTC (rev 4759)
+++ rl/trunk/engine/ui/include/CutsceneControlState.h	2009-02-09 23:10:17 UTC (rev 4760)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -23,7 +23,22 @@
 namespace rl {
 
 	class Actor;
+	class GameObject;
 
+	enum CameraPositionType
+	{
+	    CPT_FIXED,
+	    CPT_ROTATING
+	};
+
+	struct CameraPosition
+	{
+	    CameraPositionType type;
+	    Ogre::Vector3 position;
+	    Ogre::Quaternion orientation1;
+	    Ogre::Quaternion orientation2;
+	};
+
 	class _RlUiExport CutsceneControlState : public ControlState
 	{
 	public:
@@ -41,6 +56,17 @@
         void setCameraPosition(const Ogre::Vector3& pos);
         void setCameraOrientation(const Ogre::Quaternion& orient);
         void lookAt(const Ogre::Vector3& point);
+        void setCameraTarget(GameObject* target);
+
+        void addCamera(const Ogre::Vector3& position, const Ogre::Quaternion& orientation);
+        void addCamera(const Ogre::Vector3& position, const Ogre::Quaternion& orientation1,
+                       const Ogre::Quaternion& orientation2);
+
+	private:
+	    std::vector<CameraPosition> mPositions;
+	    GameObject* mTarget;
+
+	    CameraPosition getBestCameraPosition() const;
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-02-09 22:04:51 UTC (rev 4759)
+++ rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-02-09 23:10:17 UTC (rev 4760)
@@ -21,6 +21,7 @@
 #include "Actor.h"
 #include "CameraObject.h"
 #include "CommandMapper.h"
+#include "GameObject.h"
 #include "PhysicalThing.h"
 
 using namespace Ogre;
@@ -28,7 +29,8 @@
 namespace rl {
 
 	CutsceneControlState::CutsceneControlState(CommandMapper* cmdMapper,
-        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE)
+        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE),
+        mTarget(NULL)
 	{
 	}
 
@@ -49,23 +51,63 @@
 		mCameraActor->_getSceneNode()->setFixedYawAxis(true);
     }
 
-	void CutsceneControlState::run(Ogre::Real elapsedTime)
+	void CutsceneControlState::run(Real elapsedTime)
 	{
+	    CameraPosition pos = getBestCameraPosition();
+	    switch (pos.type)
+	    {
+	    case CPT_FIXED:
+	        setCameraPosition(pos.position);
+	        setCameraOrientation(pos.orientation1);
+	        break;
+	    case CPT_ROTATING:
+	        setCameraPosition(pos.position);
+	        lookAt(mTarget->getPosition());
+	        break;
+	    }
 	}
 
-    void CutsceneControlState::setCameraPosition(const Ogre::Vector3& pos)
+	void CutsceneControlState::setCameraTarget(GameObject* target)
+	{
+	    mTarget = target;
+	}
+
+    void CutsceneControlState::setCameraPosition(const Vector3& pos)
     {
         mCameraActor->setPosition(pos);
     }
 
-    void CutsceneControlState::setCameraOrientation(const Ogre::Quaternion& orient)
+    void CutsceneControlState::setCameraOrientation(const Quaternion& orient)
     {
         mCameraActor->setOrientation(orient);
     }
 
-    void CutsceneControlState::lookAt(const Ogre::Vector3& point)
+    void CutsceneControlState::lookAt(const Vector3& point)
     {
-        dynamic_cast<Ogre::Camera*>(mCameraActor->getControlledObject()->getMovableObject())
+        dynamic_cast<Camera*>(mCameraActor->getControlledObject()->getMovableObject())
             ->lookAt(point);
     }
+
+    CameraPosition CutsceneControlState::getBestCameraPosition() const
+    {
+        if (mPositions.empty())
+        {
+            CameraPosition nullPos = {CPT_FIXED, Vector3::ZERO, Quaternion::IDENTITY, Quaternion::IDENTITY};
+            return nullPos;
+        }
+        return *mPositions.begin();
+    }
+
+    void CutsceneControlState::addCamera(const Vector3& position, const Quaternion& orientation)
+    {
+        CameraPosition cpos = {CPT_FIXED, position, orientation, orientation};
+        mPositions.push_back(cpos);
+    }
+
+    void CutsceneControlState::addCamera(const Vector3& position, const Quaternion& orientation1,
+            const Quaternion& orientation2)
+    {
+        CameraPosition cpos = {CPT_ROTATING, position, orientation1, orientation2};
+        mPositions.push_back(cpos);
+    }
 }



From melven at mail.berlios.de  Tue Feb 10 00:51:20 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 10 Feb 2009 00:51:20 +0100
Subject: [Dsa-hl-svn] r4761 - rl/trunk
Message-ID: <200902092351.n19NpKRY029243@sheep.berlios.de>

Author: melven
Date: 2009-02-10 00:51:18 +0100 (Tue, 10 Feb 2009)
New Revision: 4761

Modified:
   rl/trunk/CMakeLists.txt
Log:
marked FMODEx as required


Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-02-09 23:10:17 UTC (rev 4760)
+++ rl/trunk/CMakeLists.txt	2009-02-09 23:51:18 UTC (rev 4761)
@@ -35,6 +35,7 @@
 FIND_PACKAGE(Ruby REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
 FIND_PACKAGE(SWIG REQUIRED)
+FIND_PACKAGE(FMODEx 4.20.06 REQUIRED)
 IF (NOT SWIG_DIR MATCHES -rl$)
 	SET_FEATURE_INFO(SWIG "" "" "You use an unsupported version of SWIG.")
 ENDIF(NOT SWIG_DIR MATCHES -rl$)
@@ -49,7 +50,7 @@
 SET(DATADIRNAME "rastullah" CACHE STRING "change the name of the directory for the read-only architecture-independent game data")
 
 # Game options
-SET(WITH_FMOD4 ON CACHE BOOL "Enable FMOD 4.xx (FMODex) sound support")
+#SET(WITH_FMOD4 ON CACHE BOOL "Enable FMOD 4.xx (FMODex) sound support")
 SET(WITH_OPENAL OFF CACHE BOOL "Enable OpenAL sound support (unsupported)")
 
 # Include subdirectories



From fusion2 at mail.berlios.de  Tue Feb 10 21:45:53 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 10 Feb 2009 21:45:53 +0100
Subject: [Dsa-hl-svn] r4762 - in rl/trunk/editors/Lockenwickler: .
	_eric4project src
Message-ID: <200902102045.n1AKjrkb005246@sheep.berlios.de>

Author: fusion2
Date: 2009-02-10 21:45:46 +0100 (Tue, 10 Feb 2009)
New Revision: 4762

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
Log:
- Property Window now shows properties
- Changed how objects are created

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-09 23:51:18 UTC (rev 4761)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-10 20:45:46 UTC (rev 4762)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-02-09, 18:57:06 -->
+<!-- Saved: 2009-02-10, 21:36:41 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-09 23:51:18 UTC (rev 4761)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-10 20:45:46 UTC (rev 4762)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-02-09, 18:57:06 -->
+<!-- Saved: 2009-02-10, 21:36:41 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-09 23:51:18 UTC (rev 4761)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-10 20:45:46 UTC (rev 4762)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-02-09, 18:57:06 -->
+<!-- Saved: 2009-02-10, 21:36:41 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: not implemented yet</Summary>
@@ -24,10 +24,10 @@
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-02-09, 16:16:17</Created>
+    <Created>2009-02-10, 12:40:21</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
-      <Linenumber>424</Linenumber>
+      <Linenumber>426</Linenumber>
     </Resource>
   </Task>
 </Tasks>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-09 23:51:18 UTC (rev 4761)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-10 20:45:46 UTC (rev 4762)
@@ -1,4 +1,5 @@
  #################################################
+ #################################################
  # Copyright (C) 2008  Stefan Stammberger
  #
  # This library is free software; you can redistribute it and/or
@@ -77,6 +78,7 @@
 
         self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
         self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
         
         self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
         self.setWindowTitle("Rastullahs Lockenwickler")

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-09 23:51:18 UTC (rev 4761)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-10 20:45:46 UTC (rev 4762)
@@ -41,7 +41,6 @@
     def __init__(self, parent = None):
         super(ModuleTreeWidget, self).__init__(parent)
         
-        self.connect(self, SIGNAL("itemClicked (QTreeWidgetItem *,int)"), self.onClick)
         self.setContextMenuPolicy(Qt.CustomContextMenu)        
         self.connect(self, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
 
@@ -60,15 +59,13 @@
     def doMenu(self, point):
         self.onMenuCallback(self.mapToGlobal(point))
 
-    def onClick(self, item, column):
-        pass
-
 class ModuleExplorer(QWidget):
     def __init__(self, parent=None):
         QWidget.__init__(self, parent)
         self.sceneTreeView = ModuleTreeWidget()
         
         self.sceneTreeView.setMenuCallback(self.onMenu)
+        self.connect(self.sceneTreeView, SIGNAL("itemClicked (QTreeWidgetItem *,int)"), self.onClick)
         
         vBoxLayout = QVBoxLayout()
         vBoxLayout.addWidget(self.sceneTreeView)
@@ -78,7 +75,22 @@
         self.nodeDict = {}
         
         self.moduleManager = None
-      
+        self.mapSelectedCallback = None
+        
+    def onClick(self, item, column):
+        if self.mapSelectedCallback is None:
+            return
+        
+        name = str(item.text(0))
+        if name.startswith("Map: "):
+            self.mapSelectedCallback(str(item.parent().text(0)).replace("Scene: ", ""), name.replace("Map: ", ""))
+        elif name.startswith("Scene: "):
+            if item.childCount > 0:
+                self.mapSelectedCallback(name.replace("Scene: ", ""), None)
+                return
+                
+            self.mapSelectedCallback(name.replace("Scene: ", ""), str(item.child(0).text(0)).replace("Map: ", ""))
+        
     def onMenu(self, point):
         if self.moduleManager is not None:
             menu = QMenu(self)
@@ -103,6 +115,7 @@
         if dlg.exec_():
             self.moduleManager.addSceneToModule(str(dlg.nameInput.text()))
             self.updateView()
+            self.onNewMap()
             
     def onNewMap(self):
         dlg = NameInputDlg(self)
@@ -134,10 +147,12 @@
             childItem2 = QTreeWidgetItem(childItem) 
             childItem2.setText(0, iter.getNext().getName())
         
-        
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()
 
     def setModuleManager(self, moduleManager):
         self.moduleManager = moduleManager
+        
+    def setMapSelectedCallback(self, callback):
+        self.mapSelectedCallback = callback

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-09 23:51:18 UTC (rev 4761)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-10 20:45:46 UTC (rev 4762)
@@ -57,22 +57,25 @@
 #                        </trigger>
 #                </zone>
 
-def indent(elem, level=0):
+
+# make the xml file more pretty
+def indent(elem, level=0):
     i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
             elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
 
+
 class Map():
     def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
         self.pathToMapFile = pathToFile
@@ -149,7 +152,7 @@
                 print "Warning: Meshfile " + meshFile + " could not be found."
                 continue
 
-            n = self.mapNode.createChild(entityName + "_node")
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
             n.attachObject(e)
             n.setPosition(nodePosition)
             n.setOrientation(qw, qx, qy, qz)
@@ -204,7 +207,7 @@
                 light.setType(og.Light.LT_POINT)
             
             e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild(lightName + "_node")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
             n.attachObject(e)
             n.attachObject(light)
             n.setPosition(lightPosition)
@@ -246,7 +249,7 @@
             if go is not None:
                 meshFile = go.getMeshFileName()
                 ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
-                dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(id))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
                 dropNode.attachObject(ent)
 
                 if nodePosition:
@@ -273,7 +276,8 @@
         
         iter = self.mapNode.getChildIterator()
         while iter.hasMoreElements():
-            iter.getNext().getName()
+            name = iter.getNext().getName()
+            print name
 
 class Scene():
     def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
@@ -435,7 +439,20 @@
                 self.setResourcePaths(curFile)
             if os.path.isfile(curFile):
                 pass
-
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+                            
 class ModuleManager():
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
@@ -456,7 +473,7 @@
         self.userSelectionList = []
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-
+        self.currentMap = None
         self.moduleExplorer = None
 
         self.lastRay = None
@@ -479,6 +496,7 @@
         self.moduleConfigIsParsed = False
 
         self.selectionBuffer = None
+        self.propertyWindow = None
     
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
@@ -578,8 +596,18 @@
 
     def setModuleExplorer(self, moduleExplorer):
         self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
         self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
         
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        if self.currentMap is None:
+            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
+
+        
     # called when a click into Main Ogre Window occurs
     def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
         so = None
@@ -588,6 +616,8 @@
         
         if so is not None:
             if not so.isPivot:
+                self.propertyWindow.showProperties(so)
+                
                 if not controlDown and not shiftDown:
                     self.resetSelection()
                     so.setSelected(True)
@@ -750,6 +780,8 @@
 
     def leftMouseUp(self):
         if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.moduleExplorer.updateView()
             self.pivot.stopTransforming()
 
     def resetSelection(self):
@@ -780,7 +812,7 @@
         if go is not None:
             meshFile = go.getMeshFileName()
             dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
             dropNode.attachObject(dropEntity)
 
             result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -806,7 +838,7 @@
 
     def startDropModelAction(self, meshFile, ray):
         self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
         self.dropNode.attachObject(self.dropEntity)
 
         result = og.Math.intersects(ray, self.dropCollisionPlane)

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-09 23:51:18 UTC (rev 4761)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-10 20:45:46 UTC (rev 4762)
@@ -1,54 +1,129 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from Property import *
-
-class ObjectPropertyWin(QDialog):
-    def __init__(self, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setupUi()
-
-        self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
-                               self.onItemClicked)
-
-    def setupUi(self):
-        self.setObjectName("ObjectPropertys")
-        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
-
-        self.treeWidget = QTreeWidget(self)
-        self.treeWidget.setGeometry(QRect(0,0,901,721))
-        self.treeWidget.setMinimumSize(QSize(400,400))
-        self.treeWidget.setObjectName("treeWidget")
-
-        self.retranslateUi()
-        QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.treeWidget.headerItem().setText(0,QApplication.translate("ObjectPropertys", "Property", None, QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(1,QApplication.translate("ObjectPropertys", "Value", None, QApplication.UnicodeUTF8))
-        self.treeWidget.clear()
-
-
-    def onItemClicked(self, item, column):
-        pass
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from Property import *
+
+class ObjectPropertyWin(QDialog):
+    def __init__(self, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setupUi()
+
+        self.so = None
+
+        self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
+                               self.onItemClicked)
+
+    def setupUi(self):
+        self.setObjectName("ObjectPropertys")
+        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
+
+        self.treeWidget = QTreeWidget(self)
+        self.treeWidget.setGeometry(QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QSize(400,400))
+        self.treeWidget.setObjectName("treeWidget")
+        self.treeWidget.setAlternatingRowColors(True)
+        
+        self.retranslateUi()
+        QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.treeWidget.headerItem().setText(0,QApplication.translate("ObjectPropertys", "Property", None, QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QApplication.translate("ObjectPropertys", "Value", None, QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+
+    def onItemClicked(self, item, column):
+        pass
+        
+    def showProperties(self, so):
+        self.so=so
+        self.treeWidget.clear()
+        
+        name = so.entity.getParentNode().getName()
+        node = so.entity.getParentNode()
+        
+        if name.startswith("entity_"):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Name")
+            item.setText(1, name.replace("entity_", ""))
+            
+            self.parsePosition(node)
+            self.parseOrientation(node)
+            self.parseScale(node)
+            
+    def parsePosition(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Position")
+        item.setText(1, str(node.getPosition().x) + " " + str(node.getPosition().y) + " " + str(node.getPosition().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getPosition().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getPosition().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getPosition().z))
+        
+    def parseOrientation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Orientation")
+        item.setText(1, str(node.getOrientation().x) + " " + str(node.getOrientation().y) + " " + str(node.getOrientation().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getOrientation().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getOrientation().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getOrientation().z))
+    
+    def parseScale(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Scale")
+        item.setText(1, str(node.getScale().x) + " " + str(node.getScale().y) + " " + str(node.getScale().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getScale().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getScale().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getScale().z))
+            
+    def updateProperties(self):
+        if self.so is not None:
+            self.showProperties(self.so)
+            



From timm at mail.berlios.de  Wed Feb 11 14:07:44 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 11 Feb 2009 14:07:44 +0100
Subject: [Dsa-hl-svn] r4763 - in rl/branches/persistence2:
	Mac/Rastullah.xcodeproj Mac/tools engine/common/include
	engine/common/src engine/core/src engine/script/src
Message-ID: <200902111307.n1BD7iY0020330@sheep.berlios.de>

Author: timm
Date: 2009-02-11 14:07:32 +0100 (Wed, 11 Feb 2009)
New Revision: 4763

Modified:
   rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/persistence2/Mac/tools/renameinstalldirs.sh
   rl/branches/persistence2/engine/common/include/WriteableDataStream.h
   rl/branches/persistence2/engine/common/src/WriteableDataStream.cpp
   rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp
   rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp
   rl/branches/persistence2/engine/script/src/GameObjectNodeProcessor.cpp
Log:
- merged blak's changes from trunk
- proceedings on write save games

Modified: rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj	2009-02-11 13:07:32 UTC (rev 4763)
@@ -829,7 +829,7 @@
 			isa = PBXContainerItemProxy;
 			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
 			proxyType = 1;
-			remoteGlobalIDString = 8D0C4E890486CD37000505A6 /* Rastullah */;
+			remoteGlobalIDString = 8D0C4E890486CD37000505A6;
 			remoteInfo = Rastullah;
 		};
 /* End PBXContainerItemProxy section */
@@ -3129,7 +3129,7 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR}/Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
+			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR} Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
 		};
 /* End PBXShellScriptBuildPhase section */
 

Modified: rl/branches/persistence2/Mac/tools/renameinstalldirs.sh
===================================================================
--- rl/branches/persistence2/Mac/tools/renameinstalldirs.sh	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/Mac/tools/renameinstalldirs.sh	2009-02-11 13:07:32 UTC (rev 4763)
@@ -1,10 +1,11 @@
 #!/bin/bash
-RASTULLAH_APP_DIR=$1
-RASTULLAH_APP_NAME=$2
+PRODUCTS_DIR=$1
+RASTULLAH_APP_DIR=${1}/${2}
+RASTULLAH_APP_NAME=$3
 RASTULLAH_APP_BIN=${RASTULLAH_APP_DIR}/${RASTULLAH_APP_NAME}
 CEGUI_DIR=${RASTULLAH_APP_DIR}/../Frameworks/CEGUI.framework
 CEGUI_BIN=${CEGUI_DIR}/CEGUI
-RASTULLAH_RES_DIR=$1/../Resources
+RASTULLAH_RES_DIR=${RASTULLAH_APP_DIR}/../Resources
 
 #TODO: Replace the absolute source paths to something with olist -L $RASTULLAH_APP_NAME and grep
 
@@ -19,7 +20,13 @@
     $RASTULLAH_RES_DIR/libRlUi.dylib \
     $RASTULLAH_RES_DIR/libboost_filesystem.dylib \
     $RASTULLAH_RES_DIR/libboost_system.dylib \
-    $RASTULLAH_RES_DIR/RlScript.bundle"
+    $RASTULLAH_RES_DIR/RlScript.bundle \
+    $PRODUCTS_DIR/libRlAi.dylib \
+    $PRODUCTS_DIR/libRlCommon.dylib \
+    $PRODUCTS_DIR/libRlCore.dylib \
+    $PRODUCTS_DIR/libRlRules.dylib \
+    $PRODUCTS_DIR/libRlScript.dylib \
+    $PRODUCTS_DIR/libRlUi.dylib"
 
 # RL Application binary
 for cur in $RL_BINARIES 

Modified: rl/branches/persistence2/engine/common/include/WriteableDataStream.h
===================================================================
--- rl/branches/persistence2/engine/common/include/WriteableDataStream.h	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/engine/common/include/WriteableDataStream.h	2009-02-11 13:07:32 UTC (rev 4763)
@@ -28,8 +28,9 @@
     public:
 		WriteableDataStream() : Ogre::DataStream() {}
 		WriteableDataStream(const Ogre::String &name) : Ogre::DataStream(name) {}
-        virtual void write(void* buf, size_t count) {}
-        virtual void flush() {}
+        virtual void write(void* buf, size_t count) = 0;
+        virtual void flush() = 0;
+        virtual void beginWrite() = 0;
     };
 
     typedef Ogre::SharedPtr<WriteableDataStream> WriteableDataStreamPtr;
@@ -73,6 +74,8 @@
         virtual void write(void* buf, size_t count);
 
         virtual void flush();
+
+        virtual void beginWrite();
     };
 
     typedef Ogre::SharedPtr<WriteableFileStreamDataStream> WriteableFileStreamDataStreamPtr;

Modified: rl/branches/persistence2/engine/common/src/WriteableDataStream.cpp
===================================================================
--- rl/branches/persistence2/engine/common/src/WriteableDataStream.cpp	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/engine/common/src/WriteableDataStream.cpp	2009-02-11 13:07:32 UTC (rev 4763)
@@ -189,6 +189,13 @@
     void WriteableFileStreamDataStream::flush()
     {
         mpStream->clear();
+        mpStream->put('\0');
         mpStream->flush();
     }
+
+    void WriteableFileStreamDataStream::beginWrite()
+    {
+        mpStream->clear();
+        mpStream->seekp(std::ios_base::beg);
+    }
 }

Modified: rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-02-11 13:07:32 UTC (rev 4763)
@@ -23,6 +23,7 @@
     WriteableDataStreamFormatTarget::WriteableDataStreamFormatTarget(WriteableDataStream* stream)
     {
         mStream = stream;
+        mStream->beginWrite();
     }
 
     void WriteableDataStreamFormatTarget::writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter)

Modified: rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/engine/core/src/SaveAbleSerializer.cpp	2009-02-11 13:07:32 UTC (rev 4763)
@@ -133,7 +133,7 @@
 
 	void SaveAbleSerializer::updateFileList()
 	{
-		Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup("SaveGameFiles");
+		Ogre::ResourceGroupManager::getSingleton().unloadResourceGroup("SaveGameFiles");
 
 		SaveGameEntryMap::iterator iter;
 		for(iter = mSaveGameFiles.begin(); iter != mSaveGameFiles.end(); iter++)

Modified: rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/engine/core/src/SaveGameFileWriter.cpp	2009-02-11 13:07:32 UTC (rev 4763)
@@ -63,7 +63,7 @@
 
 		mDocument->setNodeValue(XMLString::transcode("SaveGameFile")); //Set name of document root node
 
-		setAttributeValueAsString(mDocument->getDocumentElement(), "SaveGameFormatVersion", "0.6");
+		setAttributeValueAsString(mDocument->getDocumentElement(), "SaveGameFormatVersion", "0.8");
 		setAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion", CoreSubsystem::getSingleton().getEngineBuildNumber());
 
 

Modified: rl/branches/persistence2/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/GameObjectNodeProcessor.cpp	2009-02-10 20:45:46 UTC (rev 4762)
+++ rl/branches/persistence2/engine/script/src/GameObjectNodeProcessor.cpp	2009-02-11 13:07:32 UTC (rev 4763)
@@ -48,11 +48,20 @@
         }
 
         GameObject* go = GameObjectManager::getSingleton().getGameObject(goid);
-        if(!go)
+        if (!go)
         {
             go = GameObjectManager::getSingleton().createGameObject(classname, goid);
-			LOG_MESSAGE("Maploader", "Created GameObject with id: " + goid);
-
+            LOG_MESSAGE("Maploader", "Created GameObject with id: " + goid);
+
+            if (!go) // Error creating the GameObject
+            {
+                LOG_ERROR(
+                    "MapLoader", 
+                    "Could not create a game object with classid '" 
+                    + classname + "' and id '" + goid + "'");
+                return true;
+            }
+
             DOMElement* posElem = getChildNamed(nodeElem, "position");
             if (posElem != NULL)
             {



From timm at mail.berlios.de  Wed Feb 11 14:25:41 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 11 Feb 2009 14:25:41 +0100
Subject: [Dsa-hl-svn] r4764 - in rl/branches/persistence2: . docs/documents
	editors/Lockenwickler editors/Lockenwickler/_eric4project
	editors/Lockenwickler/src engine/ai/src engine/core/include
	engine/core/src engine/rules/include engine/rules/src
	engine/script/src engine/ui/include engine/ui/src
Message-ID: <200902111325.n1BDPf1c022830@sheep.berlios.de>

Author: timm
Date: 2009-02-11 14:24:47 +0100 (Wed, 11 Feb 2009)
New Revision: 4764

Modified:
   rl/branches/persistence2/.project
   rl/branches/persistence2/CMakeLists.txt
   rl/branches/persistence2/docs/documents/scene_format_proposal.xml
   rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
   rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
   rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp
   rl/branches/persistence2/engine/core/include/Actor.h
   rl/branches/persistence2/engine/core/include/GameEventManager.h
   rl/branches/persistence2/engine/core/include/GameLoop.h
   rl/branches/persistence2/engine/core/include/PhysicalThing.h
   rl/branches/persistence2/engine/core/include/PhysicsController.h
   rl/branches/persistence2/engine/core/include/PhysicsGenericContactCallback.h
   rl/branches/persistence2/engine/core/include/PhysicsManager.h
   rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h
   rl/branches/persistence2/engine/core/include/SaveAbleFactory.h
   rl/branches/persistence2/engine/core/include/SoundManager.h
   rl/branches/persistence2/engine/core/src/Actor.cpp
   rl/branches/persistence2/engine/core/src/ActorManager.cpp
   rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp
   rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
   rl/branches/persistence2/engine/core/src/GameEventManager.cpp
   rl/branches/persistence2/engine/core/src/GameLoop.cpp
   rl/branches/persistence2/engine/core/src/ListenerObject.cpp
   rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
   rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/branches/persistence2/engine/core/src/SoundObject.cpp
   rl/branches/persistence2/engine/rules/include/AbstractMovement.h
   rl/branches/persistence2/engine/rules/include/CreatureController.h
   rl/branches/persistence2/engine/rules/include/CreatureControllerManager.h
   rl/branches/persistence2/engine/rules/src/CreatureController.cpp
   rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
   rl/branches/persistence2/engine/rules/src/JumpHighMovement.cpp
   rl/branches/persistence2/engine/rules/src/JumpLongMovement.cpp
   rl/branches/persistence2/engine/rules/src/StepRecognitionMovement.cpp
   rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp
   rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/persistence2/engine/ui/include/CombatControlState.h
   rl/branches/persistence2/engine/ui/include/Console.h
   rl/branches/persistence2/engine/ui/include/CutsceneControlState.h
   rl/branches/persistence2/engine/ui/include/FreeflightControlState.h
   rl/branches/persistence2/engine/ui/include/ItemDescriptionDragContainer.h
   rl/branches/persistence2/engine/ui/include/ItemDragContainer.h
   rl/branches/persistence2/engine/ui/include/ItemIconDragContainer.h
   rl/branches/persistence2/engine/ui/include/MovementControlState.h
   rl/branches/persistence2/engine/ui/include/WindowFadeJob.h
   rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
   rl/branches/persistence2/engine/ui/src/CombatGui.cpp
   rl/branches/persistence2/engine/ui/src/Console.cpp
   rl/branches/persistence2/engine/ui/src/ContainerContentWindow.cpp
   rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp
   rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
   rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp
   rl/branches/persistence2/engine/ui/src/ItemDescriptionDragContainer.cpp
   rl/branches/persistence2/engine/ui/src/ItemDragContainer.cpp
   rl/branches/persistence2/engine/ui/src/ItemIconDragContainer.cpp
   rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
   rl/branches/persistence2/engine/ui/src/UiSubsystem.cpp
   rl/branches/persistence2/engine/ui/src/WindowFactory.cpp
   rl/branches/persistence2/engine/ui/src/WindowFadeJob.cpp
Log:
merged the rest from trunk

Modified: rl/branches/persistence2/.project
===================================================================
--- rl/branches/persistence2/.project	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/.project	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>RL_trunk</name>
+	<name>RL</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -11,124 +11,100 @@
 			<arguments>
 				<dictionary>
 					<key>org.eclipse.cdt.core.errorOutputParser</key>
-					<value>org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GASErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.VCErrorParser;</value>
+					<value>org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GASErrorParser;org.eclipse.cdt.core.GLDErrorParser;</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
-					<value>clean all</value>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.incrementalBuildTarget</key>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
 					<value>all</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<key>org.eclipse.cdt.make.core.build.arguments</key>
 					<value></value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
-					<value>false</value>
+					<key>org.eclipse.cdt.make.core.build.command</key>
+					<value>/usr/bin/make</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.environment</key>
-					<value></value>
+					<key>org.eclipse.cdt.make.core.build.location</key>
+					<value>/home/blakharaz/rastullah/current</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
-					<value>true</value>
+					<key>org.eclipse.cdt.make.core.build.target.auto</key>
+					<value>all</value>
 				</dictionary>
 				<dictionary>
+					<key>org.eclipse.cdt.make.core.build.target.clean</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
 					<key>org.eclipse.cdt.make.core.build.target.inc</key>
 					<value>all</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enabledIncrementalBuild</key>
-					<value>true</value>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.location</key>
-					<value></value>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>/home/blakharaz/rastullah/current</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.target.clean</key>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
 					<value>clean</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
-					<value>true</value>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
-					<value>clean</value>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
 					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.target.full</key>
-					<value>clean all</value>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<key>org.eclipse.cdt.make.core.enabledIncrementalBuild</key>
 					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildCommand</key>
-					<value>make</value>
+					<key>org.eclipse.cdt.make.core.environment</key>
+					<value></value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.stopOnError</key>
-					<value>false</value>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
-					<value>all</value>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
 				</dictionary>
 				<dictionary>
-					<key>org.eclipse.cdt.make.core.build.target.auto</key>
-					<value>all</value>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>false</value>
 				</dictionary>
 			</arguments>
 		</buildCommand>
 		<buildCommand>
 			<name>org.eclipse.cdt.make.core.ScannerConfigBuilder</name>
 			<arguments>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.ScannerConfigDiscoveryEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.makeBuilderParserId</key>
-					<value>org.eclipse.cdt.make.core.GCCScannerInfoConsoleParser</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.esiProviderCommandEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.siProblemGenerationEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.useDefaultESIProviderCmd</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.makeBuilderParserEnabled</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.esiProviderParserId</key>
-					<value>org.eclipse.cdt.make.core.GCCSpecsConsoleParser</value>
-				</dictionary>
 			</arguments>
 		</buildCommand>
 	</buildSpec>
 	<natures>
-		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
 		<nature>org.eclipse.cdt.make.core.makeNature</nature>
 		<nature>org.eclipse.cdt.make.core.ScannerConfigNature</nature>
-		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
 	</natures>
 </projectDescription>

Modified: rl/branches/persistence2/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/CMakeLists.txt	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/CMakeLists.txt	2009-02-11 13:24:47 UTC (rev 4764)
@@ -75,6 +75,7 @@
 FIND_PACKAGE(Ruby REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
 FIND_PACKAGE(SWIG REQUIRED)
+FIND_PACKAGE(FMODEx 4.20.06 REQUIRED)
 IF (NOT SWIG_DIR MATCHES -rl$)
 	SET_FEATURE_INFO(SWIG "" "" "You use an unsupported version of SWIG.")
 ENDIF(NOT SWIG_DIR MATCHES -rl$)
@@ -89,7 +90,7 @@
 SET(DATADIRNAME "rastullah" CACHE STRING "change the name of the directory for the read-only architecture-independent game data")
 
 # Game options
-SET(WITH_FMOD4 ON CACHE BOOL "Enable FMOD 4.xx (FMODex) sound support")
+#SET(WITH_FMOD4 ON CACHE BOOL "Enable FMOD 4.xx (FMODex) sound support")
 SET(WITH_OPENAL OFF CACHE BOOL "Enable OpenAL sound support (unsupported)")
 
 # Include subdirectories

Modified: rl/branches/persistence2/docs/documents/scene_format_proposal.xml
===================================================================
--- rl/branches/persistence2/docs/documents/scene_format_proposal.xml	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/docs/documents/scene_format_proposal.xml	2009-02-11 13:24:47 UTC (rev 4764)
@@ -192,6 +192,16 @@
         	     <colour r="0.5" g="0.5" b="0.5" />
         	</fog>
 
-       	</environment>
+       	</environment>
+
+        <camerapaths>
+            <camerapath name="bauerrogalfsbetrunkenerheimweg">
+               <cameraposition>
+                  <position x="15" y="0.5" z="-23.4"/>
+                  <rotation qx="0.0" qy="0.0" qz="0.0" qw="1.0" />
+                  <rotation qx="0.707" qy="0.0" qz="0.707" qw="1.0" /> <!-- Two rotations define a rotating camera -->
+               </cameraposition>
+            </camerapath>
+        </camerapaths>
 
 </rastullahmap>

Modified: rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-02-07, 20:03:18 -->
+<!-- Saved: 2009-02-10, 21:36:41 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-02-07, 20:03:18 -->
+<!-- Saved: 2009-02-10, 21:36:41 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,15 +1,33 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-02-07, 20:03:18 -->
+<!-- Saved: 2009-02-10, 21:36:41 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
+    <Summary>TODO: not implemented yet</Summary>
+    <Description></Description>
+    <Created>2009-02-09, 14:05:47</Created>
+    <Resource>
+      <Filename>src/GOIntEditor.py</Filename>
+      <Linenumber>28</Linenumber>
+    </Resource>
+  </Task>
+  <Task priority="1" completed="False" bugfix="False">
+    <Summary>TODO: not implemented yet</Summary>
+    <Description></Description>
+    <Created>2009-02-09, 14:05:47</Created>
+    <Resource>
+      <Filename>src/GOIntEditor.py</Filename>
+      <Linenumber>36</Linenumber>
+    </Resource>
+  </Task>
+  <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-02-07, 17:52:11</Created>
+    <Created>2009-02-10, 12:40:21</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
-      <Linenumber>416</Linenumber>
+      <Linenumber>426</Linenumber>
     </Resource>
   </Task>
 </Tasks>
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,4 +1,5 @@
  #################################################
+ #################################################
  # Copyright (C) 2008  Stefan Stammberger
  #
  # This library is free software; you can redistribute it and/or
@@ -76,7 +77,8 @@
             self.prefDialog.show()
 
         self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        self.moduleManager.moduleExplorer = self.moduleExplorerWin
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
         
         self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
         self.setWindowTitle("Rastullahs Lockenwickler")
@@ -142,6 +144,9 @@
 
         self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "filenew.png",  "Open Module")
         self.actionOpen.setObjectName("actionOpen")
+        
+        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filenew.png",  "Save Module")
+        self.actionSave.setObjectName("actionSave")
 
         self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
         self.actionClose.setObjectName("actionQuit")
@@ -200,6 +205,7 @@
 
         self.menuFile.addAction(self.actionNeu)
         self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
         self.menuFile.addAction(self.actionClose)
 
         self.menuEdit.addAction(self.actionSelect)
@@ -284,7 +290,10 @@
         newModuleWiz = NewModuleWizard(self.moduleManager, self)
         newModuleWiz.exec_()
         return
-
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
     def actionQuitSlot(self):
         self.close()
 
@@ -368,7 +377,7 @@
         self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
 
         self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
-        self.moduleExplorerDock.setObjectName("SceneExplorerDockWindow")
+        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
         self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
         self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
         self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
@@ -383,6 +392,7 @@
         self.fileToolBar.setObjectName("FileToolBar")
         self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
         self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionSave)
         self.fileToolBar.addAction(self.actionClose)
         self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -16,17 +16,57 @@
  # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
 
-
+#dienstag 24.03 15.50
 import sys
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 import ogre.renderer.OGRE as og
 
+class NameInputDlg(QDialog):
+    def __init__(self, parent = None):
+        super(NameInputDlg, self).__init__(parent)
+        
+        self.nameInput = QLineEdit(self)
+        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        layout = QVBoxLayout()
+        layout.addWidget(self.nameInput)
+        layout.addWidget(buttonBox)
+        self.setLayout(layout)
+        
+        self.connect(buttonBox, SIGNAL("accepted()"), self, SLOT("accept()"))        
+        self.connect(buttonBox, SIGNAL("rejected()"), self, SLOT("reject()"))
+        
+        
+class ModuleTreeWidget(QTreeWidget):
+    def __init__(self, parent = None):
+        super(ModuleTreeWidget, self).__init__(parent)
+        
+        self.setContextMenuPolicy(Qt.CustomContextMenu)        
+        self.connect(self, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
+
+        self.onMenuCallback = None
+
+
+#        clearAction= QAction("Clear Window",  self)
+#        self.consoleWindow.textEdit.addAction(clearAction)
+#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+#        clearAction.setShortcut("Ctrl + R")
+#        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
+
+    def setMenuCallback(self, callback):
+        self.onMenuCallback = callback
+        
+    def doMenu(self, point):
+        self.onMenuCallback(self.mapToGlobal(point))
+
 class ModuleExplorer(QWidget):
     def __init__(self, parent=None):
         QWidget.__init__(self, parent)
-        self.sceneTreeView = QTreeWidget()
-
+        self.sceneTreeView = ModuleTreeWidget()
+        
+        self.sceneTreeView.setMenuCallback(self.onMenu)
+        self.connect(self.sceneTreeView, SIGNAL("itemClicked (QTreeWidgetItem *,int)"), self.onClick)
+        
         vBoxLayout = QVBoxLayout()
         vBoxLayout.addWidget(self.sceneTreeView)
 
@@ -34,12 +74,65 @@
         
         self.nodeDict = {}
         
+        self.moduleManager = None
+        self.mapSelectedCallback = None
+        
+    def onClick(self, item, column):
+        if self.mapSelectedCallback is None:
+            return
+        
+        name = str(item.text(0))
+        if name.startswith("Map: "):
+            self.mapSelectedCallback(str(item.parent().text(0)).replace("Scene: ", ""), name.replace("Map: ", ""))
+        elif name.startswith("Scene: "):
+            if item.childCount > 0:
+                self.mapSelectedCallback(name.replace("Scene: ", ""), None)
+                return
+                
+            self.mapSelectedCallback(name.replace("Scene: ", ""), str(item.child(0).text(0)).replace("Map: ", ""))
+        
+    def onMenu(self, point):
+        if self.moduleManager is not None:
+            menu = QMenu(self)
+            
+            newSceneAction= QAction("New Scene",  self)
+            menu.addAction(newSceneAction)
+            self.connect(newSceneAction, SIGNAL("triggered()"), self.onNewScene)
+
+            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith("Scene:"):
+                newMapAction= QAction("New Map",  self)
+                menu.addAction(newMapAction)
+                self.connect(newMapAction, SIGNAL("triggered()"), self.onNewMap)
+
+            deleteAction= QAction("Delete",  self)
+            menu.addAction(deleteAction)
+            self.connect(deleteAction, SIGNAL("triggered()"), self.onDelete)
+            
+            menu.exec_(point)
+      
+    def onNewScene(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            self.moduleManager.addSceneToModule(str(dlg.nameInput.text()))
+            self.updateView()
+            self.onNewMap()
+            
+    def onNewMap(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            sceneName = str(self.sceneTreeView.currentItem().text(0)).replace("Scene: ", "")
+            self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
+            self.updateView()
+        
+    def onDelete(self):
+        print "delete"
+      
     def updateView(self):
         self.sceneTreeView.clear()
         
         for s in self.module.scenes:
             sceneRootItem = QTreeWidgetItem(self.sceneTreeView)
-            sceneRootItem.setText(0, s.name)
+            sceneRootItem.setText(0, "Scene: " + s.name)
             
             for m in s.mapFiles:
                 self.parseMap(m, sceneRootItem)
@@ -47,15 +140,19 @@
                 
     def parseMap(self, map, sceneRootItem):
         childItem =  QTreeWidgetItem(sceneRootItem)
-        childItem.setText(0, map.mapName)
+        childItem.setText(0, "Map: " + map.mapName)
         
         iter = map.mapNode.getChildIterator()
         while iter.hasMoreElements():
             childItem2 = QTreeWidgetItem(childItem) 
             childItem2.setText(0, iter.getNext().getName())
         
-        
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()
 
+    def setModuleManager(self, moduleManager):
+        self.moduleManager = moduleManager
+        
+    def setMapSelectedCallback(self, callback):
+        self.mapSelectedCallback = callback

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -33,8 +33,8 @@
 from SelectionBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
 
+
 #                <zone name="Testzone">
 #                        <area type="sphere">
 #                                <position x="-10" y="0" z="-5"/>
@@ -57,8 +57,27 @@
 #                        </trigger>
 #                </zone>
 
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+
 class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager):
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
         self.pathToMapFile = pathToFile
         
         mapName = pathToFile.replace("\\", "/")
@@ -66,21 +85,23 @@
         mapName = mapName[len(mapName) - 1].split(".")
         mapName = mapName[len(mapName) - 3]
         self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
         
         self.sceneManager = sceneManager
         self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
 
-        xmlTree = xml.parse(pathToFile)
-        root = xmlTree.getroot()
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
 
-        if root.attrib["formatVersion"] == "0.4.0":
-            self.parseMapNodes(root.find("nodes"))
-            #self.parseMapZones(root.find("zones"))
-        else:
-            print pathToFile + " has wrong format version. It needs to be 0.4.0"
-            return
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                #self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
 
     def parseMapNodes(self, nodeElement):
         nodes = nodeElement.getiterator("entity")
@@ -131,7 +152,7 @@
                 print "Warning: Meshfile " + meshFile + " could not be found."
                 continue
 
-            n = self.mapNode.createChild(entityName + "_node")
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
             n.attachObject(e)
             n.setPosition(nodePosition)
             n.setOrientation(qw, qx, qy, qz)
@@ -148,7 +169,7 @@
             colourSpecular = None
             lightAttenuationRange = None
             lightAttenuationConstant= None
-            lightAttenuationlinear = None
+            lightAttenuationLinear = None
             lightAttenuationQuadratic = None
 
             transformations = l.getiterator()
@@ -171,14 +192,27 @@
                 elif t.tag == "lightAttenuation":
                     lightAttenuationRange = float(t.attrib["range"])
                     lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationlinear = float(t.attrib["linear"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
                     lightAttenuationQuadratic = float(t.attrib["quadratic"])
+            
 
-            e = self.sceneManager.createEntity(lightName, "lightbulp.mesh")
-            n = self.mapNode.createChild(lightName + "_node")
+            light = self.sceneManager.createLight(lightName)
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
+            light.setDiffuseColour(colourDiffuse)
+            light.setSpecularColour(colourSpecular)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
             n.attachObject(e)
+            n.attachObject(light)
             n.setPosition(lightPosition)
 
+            
     def createSound(self, soundNodes):
         #raise NotImplementedError
         return
@@ -215,7 +249,7 @@
             if go is not None:
                 meshFile = go.getMeshFileName()
                 ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
-                dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(id))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
                 dropNode.attachObject(ent)
 
                 if nodePosition:
@@ -233,34 +267,60 @@
     def createParticleSystems(self, particleNodes):
         #raise NotImplementedError
         return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        iter = self.mapNode.getChildIterator()
+        while iter.hasMoreElements():
+            name = iter.getNext().getName()
+            print name
 
 class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager):
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
         self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
-        
-        xmlTree = xml.parse(pathToFile)
-        root = xmlTree.getroot()
-        self.name = root.attrib["name"]
-        
         self.mapFiles = [] # a list in case the module has more than one map file
         mappaths = []
+        self.name = sceneName
+
         
-        maps = root.getiterator("map")
-        for m in maps:
-            mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
             
-        for m in mappaths:
-            self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-            
-        #cmd = join(self.moduleRoot, "maps/*.rlmap.xml")
-        #maps = glob.glob(cmd)
-        #for m in maps:
-            #self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
 
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
 
+
+
 class Module():
     def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
         self.sceneManager = sceneManager
@@ -281,6 +341,18 @@
 
         self.isLoaded = False
 
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
     def isCommon(self):
         modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
         if isfile(modConfig): # is the modconfig existing?
@@ -343,15 +415,13 @@
             
         
     def loadScenes(self, sceneFiles):
-        for f in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, f, self.sceneManager, self.ogreRoot, self.gocManager))
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
 
-    def saveMaps(self):
-        return
+    def save(self):
+        for s in self.scenes:
+            s.save()
 
-    def saveScenes(self):
-        return
-
     def setResourcePaths(self, recurseFolder = ""):
         if recurseFolder == "":
             rootFolder = self.moduleRoot
@@ -369,7 +439,20 @@
                 self.setResourcePaths(curFile)
             if os.path.isfile(curFile):
                 pass
-
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+                            
 class ModuleManager():
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
@@ -378,23 +461,19 @@
 
         self.moduleCfgPath = ""
 
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
         self.gocManager = GameObjectClassManager()
         # we need to hold a reference to the game object representaions ourself
         # python does not recognize the a reference to a c++ object (Entity in our case) is passed
         # and deletes the object
         self.gameObjectRepresentationDict = []
 
-        self.mainModule = []
+        self.mainModule = None
         self.mainModuledependencieList =[]
         self.moduleList = []
         self.userSelectionList = []
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-
-        self.listenerDings = MyRaySceneQueryListener()
-
+        self.currentMap = None
         self.moduleExplorer = None
 
         self.lastRay = None
@@ -417,6 +496,7 @@
         self.moduleConfigIsParsed = False
 
         self.selectionBuffer = None
+        self.propertyWindow = None
     
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
@@ -490,7 +570,7 @@
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 
-#        self.moduleExplorer.updateView()
+        self.moduleExplorer.updateView()
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
 #        e.setMaterialName("PlainColor")
@@ -506,21 +586,38 @@
         if self.selectionBuffer is None:
             self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
 
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        if self.currentMap is None:
+            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
+
+        
     # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        so = None
         if self.selectionBuffer is not None:
-            self.selectionBuffer.update()
-            
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
         if so is not None:
             if not so.isPivot:
+                self.propertyWindow.showProperties(so)
+                
                 if not controlDown and not shiftDown:
                     self.resetSelection()
                     so.setSelected(True)
@@ -683,6 +780,8 @@
 
     def leftMouseUp(self):
         if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.moduleExplorer.updateView()
             self.pivot.stopTransforming()
 
     def resetSelection(self):
@@ -691,8 +790,6 @@
 
         self.userSelectionList = []
 
-        self.listenerDings.reset()
-        pass
 
 
     def updatePivots(self):
@@ -707,7 +804,7 @@
         pass
 
     def save(self):
-        pass
+        self.mainModule.save()
 
     def startDropGameObjectAction(self, classid, ray):
         go = self.gocManager.getGameObjectWithClassId(classid)
@@ -715,7 +812,7 @@
         if go is not None:
             meshFile = go.getMeshFileName()
             dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
             dropNode.attachObject(dropEntity)
 
             result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -741,7 +838,7 @@
 
     def startDropModelAction(self, meshFile, ray):
         self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
         self.dropNode.attachObject(self.dropEntity)
 
         result = og.Math.intersects(ray, self.dropCollisionPlane)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -191,7 +191,7 @@
                 transVec = transVec * transFactor
                 for so in self.selectionList:
                     so.entity.getParentNode().translate(transVec)
-
+                    
                 self.pivotNode.translate(transVec)
 
             # rotate mode
@@ -211,8 +211,16 @@
         self.update()
 
     def update(self):
-        if not self.isHidden:
-            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
-            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
+        vSize = og.Vector3(1.0,1.0,1.0)
+        vScale = og.Vector3(1.0,1.0,1.0)
+
+        dist = (self.camera.getDerivedPosition() - self.pivotNode._getDerivedPosition()).length()
+        vScale *= dist / 90.0
 
+        self.pivotNode.setScale(vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z)
+        #print vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z
+#        if not self.isHidden:
+#            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
+#            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
 
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,54 +1,129 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from Property import *
-
-class ObjectPropertyWin(QDialog):
-    def __init__(self, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setupUi()
-
-        self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
-                               self.onItemClicked)
-
-    def setupUi(self):
-        self.setObjectName("ObjectPropertys")
-        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
-
-        self.treeWidget = QTreeWidget(self)
-        self.treeWidget.setGeometry(QRect(0,0,901,721))
-        self.treeWidget.setMinimumSize(QSize(400,400))
-        self.treeWidget.setObjectName("treeWidget")
-
-        self.retranslateUi()
-        QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.treeWidget.headerItem().setText(0,QApplication.translate("ObjectPropertys", "Property", None, QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(1,QApplication.translate("ObjectPropertys", "Value", None, QApplication.UnicodeUTF8))
-        self.treeWidget.clear()
-
-
-    def onItemClicked(self, item, column):
-        pass
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from Property import *
+
+class ObjectPropertyWin(QDialog):
+    def __init__(self, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setupUi()
+
+        self.so = None
+
+        self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
+                               self.onItemClicked)
+
+    def setupUi(self):
+        self.setObjectName("ObjectPropertys")
+        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
+
+        self.treeWidget = QTreeWidget(self)
+        self.treeWidget.setGeometry(QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QSize(400,400))
+        self.treeWidget.setObjectName("treeWidget")
+        self.treeWidget.setAlternatingRowColors(True)
+        
+        self.retranslateUi()
+        QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.treeWidget.headerItem().setText(0,QApplication.translate("ObjectPropertys", "Property", None, QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QApplication.translate("ObjectPropertys", "Value", None, QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+
+    def onItemClicked(self, item, column):
+        pass
+        
+    def showProperties(self, so):
+        self.so=so
+        self.treeWidget.clear()
+        
+        name = so.entity.getParentNode().getName()
+        node = so.entity.getParentNode()
+        
+        if name.startswith("entity_"):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Name")
+            item.setText(1, name.replace("entity_", ""))
+            
+            self.parsePosition(node)
+            self.parseOrientation(node)
+            self.parseScale(node)
+            
+    def parsePosition(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Position")
+        item.setText(1, str(node.getPosition().x) + " " + str(node.getPosition().y) + " " + str(node.getPosition().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getPosition().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getPosition().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getPosition().z))
+        
+    def parseOrientation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Orientation")
+        item.setText(1, str(node.getOrientation().x) + " " + str(node.getOrientation().y) + " " + str(node.getOrientation().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getOrientation().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getOrientation().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getOrientation().z))
+    
+    def parseScale(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Scale")
+        item.setText(1, str(node.getScale().x) + " " + str(node.getScale().y) + " " + str(node.getScale().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getScale().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getScale().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getScale().z))
+            
+    def updateProperties(self):
+        if self.so is not None:
+            self.showProperties(self.so)
+            

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -312,7 +312,7 @@
         return self.ogreWidget.getHeight()
 
 
-    def updateCamera(self):
+    def updateCamera(self):        
         if self.moveCamForward:
             self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
         if self.moveCamBackward:
@@ -321,3 +321,5 @@
             self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
         if self.strafeCamRight:
             self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        self.moduleManager.pivot.update()

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -33,6 +33,7 @@
         self.sceneManager = sceneManager
         self.camDistFromFocusNode = camDistFromFocusNode
         self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
 
     def initOgreWindow(self, renderWindowName, cameraName):
         self.renderParameters = og.NameValuePairList()
@@ -86,7 +87,13 @@
 
         if self.camera:
             self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+            
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
 
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
     def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
         og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-11 13:24:47 UTC (rev 4764)
@@ -3,15 +3,44 @@
 
 import ogre.renderer.OGRE as og
 
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
 # class to handle material switching without having to modify scene materials individually
 class MaterialSwitcher( og.MaterialManager.Listener ):
     def __init__(self):
         og.MaterialManager.Listener.__init__(self)
       
         self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+        
         self.lastEntity = ""
         self.lastTechnique = None
         
+        self.colorDict = {}
        
     # takes into account that one Entity can have multiple SubEntities
     def handleSchemeNotFound(self, index, name, material, lod, subEntity):
@@ -26,8 +55,8 @@
                 self.randomizeColor()
                 subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
                 
-
                 self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
                 return self.lastTechnique
         
 
@@ -35,12 +64,13 @@
         r = random.randrange(1, 255)
         g = random.randrange(1, 255)
         b = random.randrange(1, 255)
-        
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
         var = 1.0 / 255.0
 
         self.currentColor = og.ColourValue(r * var, g * var, b * var)
 
-        
+        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
+    
     def reset(self):
         self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
         self.lastEntity = ""
@@ -65,7 +95,7 @@
         self.sceneMgr = sceneManager
         self.camera = sceneManager.getCamera("MainCam")
 
-        self.viewport = renderTarget
+        self.renderTarget = renderTarget
         
         # This is the material listener - Note: it is controlled by a seperate
         # RenderTargetListener, not applied globally to all targets
@@ -73,15 +103,8 @@
         
         self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
         
-#        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-#                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-#                                                                    og.TEX_TYPE_2D, 
-#                                                                    self.viewport.getActualWidth(), 
-#                                                                    self.viewport.getActualHeight(), 
-#                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-        width = self.viewport.getWidth()
-        height = self.viewport.getHeight()
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
         
         self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
                                                                     og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
@@ -99,9 +122,11 @@
         self.renderTexture.addListener( self.selectionTargetListener )
         self.renderTexture.getViewport(0).setMaterialScheme("aa")
         
-        self.createRTTOverlays()
+        #self.createRTTOverlays()
 
     def update(self):
+        self.updateBufferSize()
+        
         self.renderTexture.update()        
         self.materialSwitchListener.reset()
         
@@ -110,30 +135,89 @@
         #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
         
         storageclass = ctypes.c_uint8 * (bufferSize)
-        buff = storageclass()
+        self.buffer = storageclass()
         
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(buff))
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
 
-        pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-        self.renderTexture.writeContentsToTimestampedFile("editor", ".png")
-        i = 0
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i < len(self.buffer):
+#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
+#            
+#            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
         
-        while i < len(buff):
-            #print str(buff[i + 2]) + " " + str(buff[i+1]) + " " + str(buff[i])
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload("SelectionPassTex")
             
-            i += 4
-        #for a in buff:
-            #print a
-
-        #pBox = pixelBuffer.getCurrentLock()
+            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        else:
+            return
+            
+    def onSelectionClick(self, x, y):
+        self.update()
         
-        #storageclass = ctypes.c_uint8 * (self.renderTexture.getWidth()*self.renderTexture.getHeight()*3) 
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
         
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
         
-        #pixelBuffer.unlock()
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                if key == "OgreMainWin::0::ViewportGrid":
+                    return None
+                elif key == "rayLine":
+                    return None
+                elif key == "EditorXArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorYArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorZArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorFreeMover":
+                    return None
+                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
+
+        return None
         
-
     def createRTTOverlays(self):
         baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
         SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")

Modified: rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -70,8 +70,8 @@
         Quaternion orientation;
         body->getPositionOrientation(position, orientation);
 
-    	OgreNewt::CollisionPtr collision = body->getCollision();
-    	RlAssert(collision.getPointer(), "Body has no collision!");
+    	const OgreNewt::Collision* collision = body->getCollision();
+    	RlAssert(collision, "Body has no collision!");
     	AxisAlignedBox box = collision->getAABB();
     	Ogre::Vector3 dims = box.getMaximum() - box.getMinimum();
     	OpenSteer::BoxObstacle *obstacle = new OpenSteer::BoxObstacle(dims[0], dims[1], dims[2]);

Modified: rl/branches/persistence2/engine/core/include/Actor.h
===================================================================
--- rl/branches/persistence2/engine/core/include/Actor.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/Actor.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -144,6 +144,9 @@
         /// Gibt die aktuelle Position des Aktors relativ zur Welt zur?ck
         const Ogre::Vector3& getWorldPosition(void) const;
 
+        /// Ermittelt die aktuelle Geschwindigkeit des Actors, falls moeglich
+        const Ogre::Vector3 getVelocity() const;
+
         /// Setzt die Position des Aktors relativ zu seinem Parent
         void setPosition(const Ogre::Vector3& vec);
         /// Setzt die Position des Aktors relativ zu seinem Parent

Modified: rl/branches/persistence2/engine/core/include/GameEventManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/GameEventManager.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/GameEventManager.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -130,8 +130,8 @@
 	void removeQueuedDeletionSources();
 
 
-    /// newton collision callback function
-    int userProcess();
+    /// newton collision callback functions
+    void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
 
     /// notify about newton world update
     void notifyNewtonWorldUpdate();

Modified: rl/branches/persistence2/engine/core/include/GameLoop.h
===================================================================
--- rl/branches/persistence2/engine/core/include/GameLoop.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/GameLoop.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -116,6 +116,7 @@
     unsigned long mSmoothedFrames;
     /// Time cap for frame time, to prevent interpolation problems during spikes.
     Ogre::Real mMaxFrameTime;
+    Ogre::Real mMinFrameTime;
     bool mQuitRequested;
     bool mPaused;
 

Modified: rl/branches/persistence2/engine/core/include/PhysicalThing.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -120,7 +120,7 @@
         void _detachFromSceneNode(Ogre::SceneNode* node);
 
 		/** ForceCallback for mBody (OgreNewt::Body). */
-        void onApplyForceAndTorque();
+        void onApplyForceAndTorque(float timeStep);
         void addForce(const Ogre::Vector3& force);
 
         void freeze();

Modified: rl/branches/persistence2/engine/core/include/PhysicsController.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsController.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/PhysicsController.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -39,7 +39,7 @@
 		 * to be applied to the associated PhysicalThing object.
 		 * @param thing PhysicalThing to apply force and torque to.
 		 */
-        virtual void OnApplyForceAndTorque(PhysicalThing* thing) = 0;
+        virtual void OnApplyForceAndTorque(PhysicalThing* thing, float timestep) = 0;
     };
 }
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsGenericContactCallback.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsGenericContactCallback.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/PhysicsGenericContactCallback.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -31,12 +31,20 @@
     class _RlCoreExport PhysicsGenericContactCallback : public OgreNewt::ContactCallback
     {
     public:
-        int userBegin();
-        int userProcess();
-        /// This function calls the contact listeners. So any specialised listener overriding
-        /// this one, has to call it explicitly.
-        void userEnd();
-    private:
+        /*!
+         * this function is called, when the aabbs of two bodies overlap, return 0 to indicate, that no contact calculation
+         * should be initiated.
+         * ATTENTION: if 0 is returned, the contact-listeners cannot be called!
+        */
+        virtual int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1,  int threadindex) { return 1; }
+
+        /*!
+         * process user defined contact forces (etc) here
+        */
+        virtual void userProcess( OgreNewt::ContactJoint &contactJoint, Ogre::Real timeStep, int threadid) {}
+
+        //! this function must not be overwritten!
+        void contactsProcess( OgreNewt::ContactJoint &contactJoint, Ogre::Real timeStep, int threadid );
     };
 }
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -30,7 +30,6 @@
 
 namespace OgreNewt {
     class Body;
-    class Debugger;
     class MaterialID;
     class MaterialPair;
     class World;
@@ -137,17 +136,17 @@
 		/// Komplette Levelgeometrie aufl?sen
 		void clearLevelGeometry();
 		
-		void toggleDebugMode();
-        bool isDebugMode() const;
+	void toggleDebugMode();
+        int isDebugMode() const;
 
         // Newton callbacks ...
         /// generic force callback. Gravity is applied and the force,
         /// applied via PhysicalThing interface.
-        static void genericForceCallback(OgreNewt::Body* body);
+        static void genericForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         /// special force callback for controlled characters (or monsters even)
         /// those bodies have up vector and are controlled using inverse dynamics
-        static void controlledForceCallback(OgreNewt::Body* body);
+        static void controlledForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         OgreNewt::World* _getNewtonWorld() const;
 
@@ -277,7 +276,7 @@
         static Ogre::String convertGeometryTypeToString(const GeometryType& geomType);
 
         /// returns newton debugger
-        OgreNewt::Debugger* getNewtonDebugger() {return mNewtonDebugger;}
+        OgreNewt::Debugger* getNewtonDebugger() {return &mWorld->getDebugger();}
 
     private:
 
@@ -288,6 +287,7 @@
         struct CollisionInUse
         {
         public:
+            CollisionInUse() : colPtr(NULL), geomType(GT_NONE) {}
             GeometryType geomType;  //! primitive type
             OgreNewt::CollisionPtr colPtr;          //! the collision primitve
         };
@@ -302,9 +302,8 @@
         bool mEnabled;
         //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
-        //! the visualisation for physical behaviour (actually not the best)
-        OgreNewt::Debugger* mNewtonDebugger;
-        bool mDebugMode;
+        //! debug mode: 0 no debugging, 1 show debug lines (freezed state), 2 show debug lines (update every frame), 3 show raycasts from one frame, 4 upda raycasts every frame
+        int mDebugMode;
 
         //! factory for creating new collision primitives
         PhysicsCollisionFactory* mPhysicsCollisionFactory;

Modified: rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -33,11 +33,12 @@
     {
         RaycastInfo() : mDistance(), mBody(), mNormal() {}
         /// dist from point1 of the raycast, in range [0,1].
-        Ogre::Real mDistance;	
+        Ogre::Real mDistance;
         /// pointer to body intersected with
         OgreNewt::Body* mBody;
         /// normal of intersection.
         Ogre::Vector3 mNormal;
+        // the collisionID for compound collisions could be added here, but we didn't need them yet
     };
 
     class _RlCoreExport PhysicsMaterialRaycast : OgreNewt::Raycast
@@ -64,18 +65,76 @@
         * If this param is NULL, every material will be found
         * @param startpt start-point of the cast
         * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
         */
         RaycastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
             const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool invertmat = false);
 
         bool userCallback(OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID);
+
+
+        bool userPreFilterCallback( OgreNewt::Body *body );  // filtering is now done here!
     private:
         RaycastInfo mInfo;
         const MaterialVector *mMaterialVector;
         const OgreNewt::MaterialID* mMaterial;
-        bool mGetNearest;
         bool mInvertMat;
     };
+
+
+
+// --------------------------------------------------------------------------------------
+
+    // we can use the info-class from OgreNewt
+    class _RlCoreExport ConvexcastInfo : public OgreNewt::BasicConvexcast::ConvexcastContactInfo
+    {
+        public:
+            ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo& info);
+            Ogre::Real mDistance;
+    };
+
+    class _RlCoreExport PhysicsMaterialConvexcast : public OgreNewt::BasicConvexcast
+    {
+    public:
+        typedef std::vector<const OgreNewt::MaterialID*> MaterialVector;
+
+        PhysicsMaterialConvexcast();
+
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param material The material, which will be found by the raycast.
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const Ogre::Vector3& endpt, bool invertmat = false);
+        
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param materials a vector with pairs of a material and a boolean value, that describes if this material should be matched or not
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
+            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const Ogre::Vector3& endpt, bool invertmat = false);
+
+
+        bool userPreFilterCallback( OgreNewt::Body *body );
+    private:
+        const MaterialVector *mMaterialVector;
+        const OgreNewt::MaterialID* mMaterial;
+        bool mInvertMat;
+    };
 }
 
 #endif

Modified: rl/branches/persistence2/engine/core/include/SaveAbleFactory.h
===================================================================
--- rl/branches/persistence2/engine/core/include/SaveAbleFactory.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/SaveAbleFactory.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -43,3 +43,4 @@
 }
 
 #endif
+

Modified: rl/branches/persistence2/engine/core/include/SoundManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/SoundManager.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/include/SoundManager.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -83,7 +83,7 @@
         Ogre::NameValuePairList getSettings() const;
 
         /// 3D-Sound aktualisieren.
-        void update();
+        //void update(); // there is no implementation of this function and it is never used!
         /// Den aktiven Treiber zurckgeben.
         SoundDriver* getActiveDriver() const;
         /// Den aktiven Treiber setzen.

Modified: rl/branches/persistence2/engine/core/src/Actor.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/Actor.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/Actor.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -317,6 +317,10 @@
         {
             return mBone->getPosition();
         }
+        else if (mParent)
+        {
+            return mParent->getPosition();
+        }
         else
         {
             return Vector3::ZERO;
@@ -326,6 +330,22 @@
         }
     }
 
+    const Vector3 Actor::getVelocity() const
+    {
+        if (mPhysicalThing)
+        {
+            return mPhysicalThing->getVelocity();
+        }
+        else if ( mParent )
+        {
+            return mParent->getVelocity();
+        }
+        else
+        {
+            return Vector3::ZERO;
+        }
+    }
+
     const Quaternion& Actor::getOrientation(void) const
     {
         if (mSceneNode)
@@ -336,6 +356,10 @@
         {
             return mBone->getOrientation();
         }
+        else if (mParent)
+        {
+            return mParent->getOrientation();
+        }
         else
         {
             return Quaternion::IDENTITY;
@@ -355,6 +379,10 @@
         {
             return mBone->_getDerivedPosition();
         }
+        else if (mParent)
+        {
+            return mParent->getWorldPosition();
+        }
         else
         {
             return Vector3::ZERO;
@@ -417,6 +445,10 @@
         {
             return mBone->_getDerivedOrientation();
         }
+        else if (mParent)
+        {
+            return mParent->getWorldOrientation();
+        }
         else
         {
             Throw(IllegalStateException,
@@ -533,6 +565,7 @@
         // Erst danach Parent/Child wirklich zuweisen, falls es eine Exception gibt.
         actor->mParent = this;
         mChildren.insert(actor);
+        actor->_update();
     }
 
     void Actor::attachToSlotAxisRot(

Modified: rl/branches/persistence2/engine/core/src/ActorManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/ActorManager.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/ActorManager.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -291,9 +291,11 @@
         try
         {
             CameraObject* co = new CameraObject(uniquename);
+            // the mass should be as small as possible, so the camera doesn't interact with other bodies,
+            // but setting the mass to 0 means, that the body is static!
             PhysicalThing* pt = PhysicsManager::getSingleton()
                 .createPhysicalThing(GT_SPHERE, co,
-                100.0f, true);
+                0.001f, true);
             PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
             pt->_getBody()->setMaterialGroupID(
                 PhysicsManager::getSingleton().createMaterialID("camera"));

Modified: rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -291,7 +291,7 @@
         mWorld = new DotSceneOctreeWorld();
         mActorManager->setWorld(mWorld);
 
-        mPhysicsManager = new PhysicsManager();
+        mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
         GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
         LOG_MESSAGE(Logger::CORE,"PhysicsManager erzeugt");
 

Modified: rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -207,7 +207,7 @@
                 mBody->getCollision(), orientationA, positionA,
                 actor->getPhysicalThing()->_getBody()->getCollision(),
                 actor->getOrientation(), actor->getPosition(),
-                retA, retB, retNorm);
+                retA, retB, retNorm, 0); // set threadindex to 0, I hope this is ok!
 
         if( intRet == 0 )
             return 0;
@@ -245,6 +245,7 @@
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
         mBody->setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
     }
 
     GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
@@ -262,6 +263,7 @@
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
         mBody->setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
     }
 
 }

Modified: rl/branches/persistence2/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -275,24 +275,28 @@
         return NAME;
     }
 
-    int GameEventManager::userProcess()
+    void GameEventManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int)
     {
-        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(m_body0);
+        OgreNewt::Body* body0 = contactJoint.getBody0();
+        OgreNewt::Body* body1 = contactJoint.getBody1();
+
+        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(body0);
         if( it != mBodyGameAreaMap.end() )
         {
-            it->second->foundCollision(bodyToActor(m_body1));
-            return false;
+            it->second->foundCollision(bodyToActor(body1));
+            return;
         }
 
-        it = mBodyGameAreaMap.find(m_body1);
+        it = mBodyGameAreaMap.find(body1);
         if( it != mBodyGameAreaMap.end() )
         {
-            it->second->foundCollision(bodyToActor(m_body0));
-            return 0;
+            it->second->foundCollision(bodyToActor(body0));
+            return;
         }
 
         LOG_WARNING(Logger::CORE, "Der Kollisionsk?rper konnte keiner GameArea zugeordnet werden!");
-        return 0;
+
+        // there should be no contacts (trigger-volume!), so we don't need to do anything here!
     }
 
     void GameEventManager::notifyNewtonWorldUpdate()

Modified: rl/branches/persistence2/engine/core/src/GameLoop.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameLoop.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/GameLoop.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -40,6 +40,7 @@
           mLastTimes(),
           mSmoothedFrames(3),
           mMaxFrameTime(0.1f),
+          mMinFrameTime(1.0/60),
           mQuitRequested(false),
           mPaused(false)
     {
@@ -138,6 +139,16 @@
         if( elapsedTime < mGameTime )
             unsmoothedFrameTime = 1;
 
+        if( unsmoothedFrameTime < mMinFrameTime*1000 )
+        {
+            usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            elapsedTime = mTimer->getMilliseconds();
+            unsmoothedFrameTime = elapsedTime - mGameTime;
+            if( elapsedTime < mGameTime )
+                unsmoothedFrameTime = 1;
+        }
+
+
         if( unsmoothedFrameTime > mMaxFrameTime*1000 )
         {
             LOG_DEBUG(Logger::CORE, "The current frame time was truncated at maximum.");

Modified: rl/branches/persistence2/engine/core/src/ListenerObject.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/ListenerObject.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/ListenerObject.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -71,7 +71,8 @@
         return;
     }
     listener->setPosition(actor->getWorldPosition());
-	listener->setOrientation(actor->getWorldOrientation());
+    listener->setOrientation(actor->getWorldOrientation());
+    listener->setVelocity(actor->getVelocity());
     LOG_DEBUG(Logger::CORE, "Pos Listener: "
         + StringConverter::toString(actor->getWorldPosition().x) + " "
         + StringConverter::toString(actor->getWorldPosition().y) + " "
@@ -81,8 +82,6 @@
         + StringConverter::toString(actor->getWorldOrientation().x) + " "
         + StringConverter::toString(actor->getWorldOrientation().y) + ", "
         + StringConverter::toString(actor->getWorldOrientation().z));
-//    listener->setOrientation(*temp1, *temp1);
-    // TODO Orientation korrigieren
 }
 
 /**

Modified: rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -145,7 +145,7 @@
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
     {
-        mBody->attachToNode(node);
+        mBody->attachNode(node);
     }
 
     void PhysicalThing::_attachToBone(MeshObject* object, const std::string& boneName )
@@ -189,7 +189,7 @@
         mUpVectorJoint = NULL;
     }
 
-    void PhysicalThing::onApplyForceAndTorque()
+    void PhysicalThing::onApplyForceAndTorque(float timestep)
     {
         Vector3 gravity = mOverrideGravity ?
             mGravity : PhysicsManager::getSingleton().getGravity();
@@ -210,8 +210,10 @@
 
     void PhysicalThing::setMass(Ogre::Real mass)
     {
+        Vector3 inertia;
+        mBody->getMassMatrix(mMass, inertia);
         mMass = mass;
-        mBody->setMass(mass);
+        mBody->setMassMatrix(mass, inertia);
     }
 
     void PhysicalThing::setGravityOverride(bool override, const Vector3& gravity)
@@ -297,7 +299,7 @@
 		else if (mGeometryType == GT_MESH)
 		{
 	        CollisionPtr collision(new TreeCollision(
-				PhysicsManager::getSingleton()._getNewtonWorld(), entity, false));
+				PhysicsManager::getSingleton()._getNewtonWorld(), entity, true));
 		    mBody->setCollision(collision);
 		}
 
@@ -482,7 +484,7 @@
         {
             // prepare for control
             mPhysicsController = controller;
-            mBody->setAutoFreeze(0);
+            //mBody->setAutoFreeze(0);
             mBody->unFreeze();
             mBody->setLinearDamping(0.0f);
             mBody->setAngularDamping(Vector3::ZERO);

Modified: rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -20,22 +20,17 @@
 #include "Actor.h"
 #include "PhysicalThing.h"
 
+
+using namespace Ogre;
+
 namespace rl
 {
-    int PhysicsGenericContactCallback::userBegin()
+    void PhysicsGenericContactCallback::contactsProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
-        return 1;
-    }
+        userProcess(contactJoint, timestep, threadid);
 
-    int PhysicsGenericContactCallback::userProcess()
-    {
-        return 1;
-    }
-
-    void PhysicsGenericContactCallback::userEnd()
-    {
-        Actor* a1 = static_cast<Actor*>(m_body0->getUserData());
-        Actor* a2 = static_cast<Actor*>(m_body1->getUserData());
+        Actor* a1 = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        Actor* a2 = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
         if (a1 && a1->getPhysicalThing()->getContactListener())
         {
             a1->getPhysicalThing()->getContactListener()->

Modified: rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -70,9 +70,8 @@
 
     PhysicsManager::PhysicsManager( )
         : mEnabled(false),
-        mNewtonDebugger(&OgreNewt::Debugger::getSingleton()),
         mPhysicalThings(),
-        mDebugMode(false),
+        mDebugMode(0),
         mGravity(0, -9.81, 0),
         mTimeFactor(1.0f),
         mWorldAABB(Vector3(-100, -100, -100), Vector3(100, 100, 100)),
@@ -99,8 +98,9 @@
         // setup level material
         createMaterialID("level");
 
-        mNewtonDebugger->setMaterialColor(getMaterialID("level"), Ogre::ColourValue::Blue);
+        mWorld->getDebugger().setMaterialColor(getMaterialID("level"), Ogre::ColourValue::Blue);
 
+
         // below here starts 'old' stale fix code that should be removed
 
         // setup level quadtree extents
@@ -132,6 +132,8 @@
         }
         mMaterials.clear();
 
+        mWorld->getDebugger().deInit();
+
         delete mPhysicsCollisionFactory;
         delete mGenericCallback;
         delete mWorld;
@@ -148,6 +150,12 @@
         //NewtonSetMinimumFrameRate(mWorld->getNewtonWorld(), 1./mMaxTimestep);
 
 
+        if( mDebugMode == 4 )
+        {
+            mWorld->getDebugger().clearRaycastsRecorded();
+        }
+
+
         // Newton kann timesteps zwischen 1/20 und 1/600!
         mElapsed += elapsedTime * mTimeFactor;
         while( mElapsed >= mMaxTimestep)
@@ -156,6 +164,7 @@
             // know if it's really neccessary
             GameEventManager::getSingleton().notifyNewtonWorldUpdate();
 
+
             mWorld->update(mMaxTimestep);
             mElapsed-=mMaxTimestep;
 #ifdef _DEBUG
@@ -165,7 +174,10 @@
                     "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
                 if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
-                    NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);
+                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
+                     body != NULL;
+                     body = NewtonWorldGetNextBody(mWorld->getNewtonWorld(), body)  )
+                    newtonPerBodyLogProperties(body);
             }
 #endif
         }
@@ -183,10 +195,23 @@
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
                     "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
-                if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
-                    NewtonWorldForEachBodyDo(mWorld->getNewtonWorld(), newtonPerBodyLogProperties);            }
+                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
+                     body != NULL;
+                     body = NewtonWorldGetNextBody(mWorld->getNewtonWorld(), body)  )
+                    newtonPerBodyLogProperties(body);
+            }
 #endif
         }
+
+
+        if( mDebugMode == 2 )
+        {
+            mWorld->getDebugger().showDebugInformation();
+        }
+        else if( mDebugMode == 3 )
+        {
+            mWorld->getDebugger().stopRaycastRecording();
+        }
     }
 
 #ifdef _DEBUG
@@ -269,31 +294,38 @@
         mEnabled = enabled;
     }
 
-    bool PhysicsManager::isDebugMode() const
+    int PhysicsManager::isDebugMode() const
     {
         return mDebugMode;
     }
 
     void PhysicsManager::toggleDebugMode()
     {
-        if (mDebugMode)
-		{
-            mNewtonDebugger->hideLines();
-		}
-        else
+        mWorld->getDebugger().init(CoreSubsystem::getSingleton().getWorld()->getSceneManager());
+        mDebugMode = (mDebugMode+1)%5;
+        switch(mDebugMode)
         {
-            mNewtonDebugger = &OgreNewt::Debugger::getSingleton();
-
-			try
-			{
-				mNewtonDebugger->init(
-					CoreSubsystem::getSingleton().getWorld()->getSceneManager());
-			}
-			catch(Ogre::Exception) {}
-
-            mNewtonDebugger->showLines(mWorld);
+            case 0:
+                mWorld->getDebugger().stopRaycastRecording();
+                mWorld->getDebugger().clearRaycastsRecorded();
+                mWorld->getDebugger().hideDebugInformation();
+                break;
+            case 1:
+                mWorld->getDebugger().showDebugInformation();
+                break;
+            case 2:
+                break;
+            case 3:
+                mWorld->getDebugger().startRaycastRecording(true);
+                mWorld->getDebugger().hideDebugInformation();
+                break;
+            case 4:
+                mWorld->getDebugger().startRaycastRecording(true);
+                mWorld->getDebugger().hideDebugInformation();
+                break;
+            default:
+                break;
         }
-        mDebugMode = !mDebugMode;
     }
 
     void PhysicsManager::addLevelGeometry( Ogre::Entity* levelEntity, const std::vector<OgreNewt::CollisionPtr> &collisions)
@@ -303,23 +335,33 @@
 
         SceneNode* node = levelEntity->getParentSceneNode();
         //Level entity has to be attached to a scene node.
+        
 
-        for( size_t i = 0; i < collisions.size(); i++)
+        // try one compound collision for the entity if there are several collisions
+        OgreNewt::CollisionPtr collision(NULL);
+        switch( collisions.size() )
         {
-		    if( collisions[i].isNull() )
-                continue;
+            case 0:
+                break;
+            case 1:
+                collision = collisions[0];
+                break;
+            default:
+                collision = new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions);
+                break;
+        }
 
-            OgreNewt::CollisionPtr collision = collisions[i];
+        if( collision )
+        {
+            OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
 
-		    OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
 
-
-            body->attachToNode(node);
+            body->attachNode(node);
             body->setPositionOrientation(node->_getDerivedPosition(),
                 node->_getDerivedOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
 
-			mLevelBodiesQuadTree.add(body);
+            mLevelBodiesQuadTree.add(body);
             //mLevelBodies.push_back(body);
         }
 
@@ -364,26 +406,23 @@
 		*/
     }
 
-    // adopted from the chararcter demo in the newton sdk
-    // copyright 2000-2004
-    // By Julio Jerez
-    void PhysicsManager::genericForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::genericForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         // apply saved forces in the PhysicalThing
         PhysicalThing* thing =
             static_cast<Actor*>(body->getUserData())->getPhysicalThing();
 
-        thing->onApplyForceAndTorque();
+        thing->onApplyForceAndTorque(timestep);
     }
 
-    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         PhysicalThing* thing =
             static_cast<Actor*>(body->getUserData())->getPhysicalThing();
 
         if (thing->getPhysicsController())
         {
-            thing->getPhysicsController()->OnApplyForceAndTorque(thing);
+            thing->getPhysicsController()->OnApplyForceAndTorque(thing, timestep);
         }
         else
         {
@@ -460,7 +499,15 @@
     void PhysicsManager::resetMaterialPair(const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2)
     {
-        getMaterialPair(M1,M2)->setContactCallback(mGenericCallback);
+        OgreNewt::MaterialPair *mat_pair = getMaterialPair(M1,M2);
+        mat_pair->setContactCallback(mGenericCallback);
+        mat_pair->setContinuousCollisionMode(0);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultElasticity(0.4f);
+        mat_pair->setDefaultSoftness(0.1f);
+        mat_pair->setDefaultFriction(0.9f, 0.5f);
+        //! TODO find a good value here, until now I hope nobody is changing the default from newton :-P
+        //mat_pair->setDefaultSurfaceThickness(); 
     }
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
@@ -480,7 +527,8 @@
         CollisionInUse &usedcol (mCollisionPrimitives[collisionName]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -495,7 +543,28 @@
 
                 if( inertia )
                 {
+
                     // we must set inertia here, the calling function doesn't know we are not creating a new collision
+                    switch(usedcol.geomType)
+                    {
+                    case GT_BOX: // from createBox
+                    case GT_CAPSULE: // from createCapsule
+                    case GT_CONVEXHULL: // from createCollisionFromEntity
+                    case GT_ELLIPSOID: // from createEllipsoid
+                    case GT_PYRAMID: // createPyramid
+                    case GT_SPHERE:
+                        {
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+                            *inertia *= mass;
+                        }
+                        break;
+                    case GT_MESH:
+                    case GT_NONE:
+                        *inertia = Ogre::Vector3::ZERO;
+                        break;
+                    }
+/*
                     Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
                     Vector3 size( aabb.getSize() );
                     switch(usedcol.geomType)
@@ -539,11 +608,12 @@
                         }
                         break;
                     }
+*/
                 }
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromEntity(
@@ -568,7 +638,8 @@
         CollisionInUse &usedcol (mCollisionPrimitives[name]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -582,7 +653,7 @@
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromAABB(
@@ -804,14 +875,13 @@
 			// calculate the convex hull of the animated mesh
 			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-				entity, entity->hasSkeleton(), *orientation, *offset));
+				entity, /*entity->hasSkeleton(),*/ *orientation, *offset));
 
 			if (inertia != NULL)
 			{
-				*inertia = Vector3(
-				size.x*size.x/6.0f,
-				size.y*size.y/6.0f,
-				size.z*size.z/6.0f) * Mass;
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+                            *inertia *= Mass;
 			}
         }
         else if (geomType == GT_MESH)
@@ -821,14 +891,14 @@
 
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-                entity, false, true));
+                entity, true ));
         }
         else
         {
             Throw(IllegalArgumentException, "unknown geometry type.");
         }
 
-        if (rval.isNull())
+        if ( rval == NULL )
         {
             LOG_DEBUG(Logger::CORE, " creating collision primitiv '"+
                 PhysicsManager::convertGeometryTypeToString(geomType)+"' for Entity '"+
@@ -860,13 +930,19 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia)
-            *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
 
-		// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
+        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
@@ -886,12 +962,18 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia)
-            *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
 
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
@@ -914,14 +996,18 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
+ 
+        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            Vector3(radius, radius, radius), *orientation, *offset));
         if (inertia)
-            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
-            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
-
-		// a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-    		PhysicsManager::getSingleton()._getNewtonWorld(),
-            Vector3(radius, radius, radius), *orientation, *offset));
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
@@ -945,13 +1031,20 @@
 			offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia)
-            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
@@ -975,16 +1068,21 @@
     		offset = &object_offset;
 		if (! orientation)
 			orientation = &object_orientation;
-        if (inertia) {
-            double sradius = radius*radius;
-			*inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
-        }
 
-		// an capsule primitiv has got its coordinate system at its center, so shift it with radius
-		// additionally it is x axis aligned, so rotate it 90 degrees around z axis
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
+
+        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
+        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+        return rval;
     }
+}
 
-}

Modified: rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -23,7 +23,7 @@
 
 namespace rl {
     PhysicsMaterialRaycast::PhysicsMaterialRaycast()
-        : Raycast(), mInfo(), mMaterial(0), mGetNearest(false)
+        : Raycast(), mInfo(), mMaterial(0)
     {
     }
 
@@ -38,7 +38,6 @@
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
 
-        mGetNearest = false;
         go(world, start, end);
 
         return mInfo;
@@ -55,14 +54,66 @@
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
 
-        mGetNearest = false;
         go(world, start, end);
 
         return mInfo;
     }
 
+    bool PhysicsMaterialRaycast::userPreFilterCallback( OgreNewt::Body *body )
+    {
+        if( body->getMaterialGroupID() == NULL )
+        {
+            LOG_MESSAGE(Logger::CORE, "Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!");
+            return true;
+        }
+        else if( body->getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID("gamearea") ) // don't trigger gameareas
+        {
+            return false;
+        }
+        else
+        {
+            if( mMaterial == NULL && mMaterialVector == NULL)
+            {
+                return true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body->getMaterialGroupID()->getID() == mMaterial->getID() && !mInvertMat ||
+                    body->getMaterialGroupID()->getID() != mMaterial->getID() && mInvertMat)
+                {
+                    return true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector->begin(); iter != mMaterialVector->end(); iter++)
+                {
+                    if (body->getMaterialGroupID()->getID() == (*iter)->getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found && !mInvertMat || !found && mInvertMat )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
     bool PhysicsMaterialRaycast::userCallback(Body* body, Ogre::Real distance, const Ogre::Vector3& normal, int collisionID)
     {
+        mInfo.mBody = body;
+        mInfo.mDistance = distance;
+        mInfo.mNormal = normal;
+        return true;
+        /*
         if( body->getMaterialGroupID() == NULL )
         {
             mInfo.mBody = body;
@@ -110,14 +161,107 @@
 
                 if( found && !mInvertMat || !found && mInvertMat )
                 {
-                    mInfo.mBody = body;
-                    mInfo.mDistance = distance;
-                    mInfo.mNormal = normal;
                     mGetNearest = true;
                 }
             }
         }
         return mGetNearest;
+        */
     }
 
+
+// -------------------------------------------------------------------------------------------------
+
+    ConvexcastInfo::ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo &info) :
+        ConvexcastContactInfo(info),
+        mDistance(0)
+    {
+    }
+
+    PhysicsMaterialConvexcast::PhysicsMaterialConvexcast() :
+        mMaterialVector(NULL),
+        mMaterial(NULL),
+        mInvertMat(false)
+    {
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const Vector3& endpt, bool invertmat)
+    {
+        mMaterialVector = NULL;
+        mMaterial = material;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1, 0); // set threadindex to 0, I hope this is ok
+
+        ConvexcastInfo info(BasicConvexcast::getInfoAt(0));
+        info.mDistance = getDistanceToFirstHit();
+        return info;
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const MaterialVector* materials,
+                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const Vector3& endpt, bool invertmat)
+    {
+        mMaterialVector = materials;
+        mMaterial = NULL;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1, 0); // set threadindex to 0, I hope this is ok
+
+        ConvexcastInfo info(BasicConvexcast::getInfoAt(0));
+        info.mDistance = getDistanceToFirstHit();
+        return info;
+    }
+
+    bool PhysicsMaterialConvexcast::userPreFilterCallback( OgreNewt::Body *body )
+    {
+        if( body->getMaterialGroupID() == NULL )
+        {
+            LOG_MESSAGE(Logger::CORE, "Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!");
+            return true;
+        }
+        else if( body->getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID("gamearea") ) // don't trigger gameareas
+        {
+            return false;
+        }
+        else
+        {
+            if( mMaterial == NULL && mMaterialVector == NULL)
+            {
+                return true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body->getMaterialGroupID()->getID() == mMaterial->getID() && !mInvertMat ||
+                    body->getMaterialGroupID()->getID() != mMaterial->getID() && mInvertMat)
+                {
+                    return true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector->begin(); iter != mMaterialVector->end(); iter++)
+                {
+                    if (body->getMaterialGroupID()->getID() == (*iter)->getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found && !mInvertMat || !found && mInvertMat )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
 }
+

Modified: rl/branches/persistence2/engine/core/src/SoundObject.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SoundObject.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/core/src/SoundObject.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -144,6 +144,7 @@
 void SoundObject::set3d( bool is3d )
 {
 	getSound()->set3d(is3d);
+        _update(); // do we need this here?
 }
 
 void SoundObject::load()

Modified: rl/branches/persistence2/engine/rules/include/AbstractMovement.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/AbstractMovement.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/include/AbstractMovement.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -26,8 +26,7 @@
 namespace rl
 {
     /// this is the base class of all movements and provides a general interface for movements
-    class AbstractMovement : 
-        public OgreNewt::ContactCallback
+    class AbstractMovement // : public PhysicsGenericContactCallback
     {
     public:
         AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
@@ -55,7 +54,7 @@
          * this method is called, when this movement is currently used to enable 
          * an individual procession of collisions contacts for each movement
          */
-        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
+        virtual void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid) {}
 
         /**
          * this method is called by OnApplyTorqueAndForceCallback of the CreatureController

Modified: rl/branches/persistence2/engine/rules/include/CreatureController.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/CreatureController.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/include/CreatureController.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -20,7 +20,6 @@
 
 #include "RulesPrerequisites.h"
 #include "PhysicsController.h"
-#include "PhysicsGenericContactCallback.h"
 #include "PhysicsMaterialRaycast.h"
 #include "Creature.h"
 #include "Actor.h"
@@ -40,8 +39,7 @@
      * It handles all nessessary things like animations and calculates the movement speed.
      */
     class _RlRulesExport CreatureController :
-        public PhysicsController,
-        public PhysicsGenericContactCallback
+        public PhysicsController
     {
     public:
         static const Ogre::String PROPERTY_CREATUREID;
@@ -52,10 +50,10 @@
         bool run(Ogre::Real elapsedTime);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// Newton contact callback called by the movingCreatureManager
-        int userProcess();
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
 
         Creature* getCreature() {return mCreature;}
         bool refetchCreature();
@@ -114,7 +112,7 @@
          * @param direction This is the movement direction in local space.
 		 *                  If the direction isn't possible (see AbstractMovement::isDirectionPossible),
 		 *                  only a "part" of the direction is applied.
-         * @param rotation like above
+         * @param rotation like above (in radians)
          * @retval false signifies that the change to this movement was not possible (possibly because the present movement forbade it)
          */
         bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);

Modified: rl/branches/persistence2/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/CreatureControllerManager.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/include/CreatureControllerManager.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -60,7 +60,7 @@
         const Ogre::String& getName() const;
 
         // Newton Contact Callback
-        int userProcess();
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
     protected:
         typedef std::map<Creature*, CreatureController*> ControllerMap;
         ControllerMap mControllers;

Modified: rl/branches/persistence2/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/CreatureController.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/src/CreatureController.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -80,7 +80,10 @@
 
         mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
 
+//        mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0*Vector3::UNIT_SCALE);
+        mCreature->getActor()->getPhysicalThing()->_getBody()->setContinuousCollisionMode(1);
 
+
         std::pair<MovementType, AbstractMovement*> movementPair;
         movementPair.first = MT_NONE;
         movementPair.second = NULL;
@@ -154,6 +157,8 @@
                 mCreature->getActor()->getPhysicalThing()->setPhysicsController(NULL);
 
                 mCreature->getActor()->getPhysicalThing()->setMaterialID(mOldMaterialId);
+        
+//                mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0.1*Vector3::UNIT_SCALE);
             }
         }
     }
@@ -170,7 +175,7 @@
     {
         int act_gs = mCreature->getWert(Creature::WERT_GS);
         ///@todo wy does this not work
-        //act_gs -= mCreature->getWert(Creature::WERT_BE);
+        act_gs -= mCreature->getWert(Creature::WERT_BE);
         return max(act_gs,1);
     }
 
@@ -297,7 +302,7 @@
         {
             // find a reason why we now are AL_FLOOR
             if( timeSinceLastFloorContact < Time(Date::ONE_SECOND)*0.19 &&
-                -speed.y < 0.6 )
+                abs(speed.y) < 0.6 )
             {
                 setAbstractLocation(AL_FLOOR);
             }
@@ -306,7 +311,7 @@
         {
             // find a reason why we now are AL_AIRBORNE
             if( timeSinceLastFloorContact >= Time(Date::ONE_SECOND)*0.2 && // 2 seconds?
-                -speed.y > 0.6 )
+                abs(speed.y) > 0.6 )
             {
                 //std::ostringstream oss;
                 //oss << "Raycast for floor: speed.y: " << speed.y << "      timeSinceLastFloorContact: " << timeSinceLastFloorContact;
@@ -316,8 +321,8 @@
 		// find the distance to the floor:
                 // raycasts
                 PhysicsMaterialRaycast::MaterialVector materialVector;
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("default")); // should we perhaps only use level here?
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("level"));
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("camera")); // should we perhaps only use level here?
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("character"));
 
                 Vector3 start = getCreature()->getPosition();
                 Vector3 end = start + Vector3::NEGATIVE_UNIT_Y*0.4;
@@ -325,7 +330,7 @@
                 RaycastInfo info = mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &materialVector,
-                            start, end);
+                            start, end, false);
 
 		if( info.mBody == NULL )
 		{
@@ -359,14 +364,13 @@
         return false;
     }
 
-    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing)
+    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         Vector3 force, torque;
         OgreNewt::Body *body = thing->_getBody();
         force = Vector3::ZERO;
         torque = Vector3::ZERO;
         OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
         Real mass;
         Vector3 inertia;
         body->getMassMatrix(mass, inertia);
@@ -387,12 +391,15 @@
         body->setTorque(torque);
     }
 
-    int CreatureController::userProcess()
+    void CreatureController::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
+for(OgreNewt::Contact contact = contactJoint.getFirstContact(); contact; contact = contact.getNext() )
+{
+
         // own collision handling (floor, in order to get information for mAbstractLocation)
         Vector3 point;
         Vector3 normal;
-        getContactPositionAndNormal(point, normal);
+        contact.getPositionAndNormal(point, normal);
 
         // determine if this contact is with the floor.
         // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
@@ -419,7 +426,32 @@
                 mLastFloorContact = time;
             }
         }
+/*
+//        setContactNormalDirection(((Vector3::UNIT_Y.dotProduct(point-charPos)*Vector3::UNIT_Y + charPos) - point).normalisedCopy());
+        setContactNormalDirection(point - (charPos + charHeight/2));
+        setContactNormalAcceleration(0);
+        setContactFrictionState(0,0);
+        setContactFrictionState(0,1);
+        setContactTangentAcceleration(0, 0);
+        setContactTangentAcceleration(0, 1);
 
+*/
+//std::ostringstream oss;
+//Vector3 vec1, vec2;
+//oss << " Collision: Point: " << point-charPos;
+//    << "  \t Normal: " << normal
+//    << "  \t Force: " << getContactForce()
+//    << "  \t Normal-Speed: " << getContactNormalSpeed()
+//    << "  \t Contact-Speed: " << point
+//    << "  \t Contact-Normal: " << normal;
+//getContactTangentDirections(vec1, vec2);
+//oss << "  \t Tangent-Directions: " << vec1 << " " << vec2;
+//LOG_MESSAGE(Logger::RULES, oss.str());
+
+        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
+        contact.setFrictionState(1,0);
+        contact.setFrictionState(0,1);
+
         if( stepHeight < 0.4 )
         {
             if(stepHeight > 0.01f) // experimantal value, 
@@ -427,17 +459,15 @@
                                    // too high means the creature stops if moving slowly onto a step because of the friction
             {
                 //setContactNormalAcceleration(5);
-                rotateTangentDirections(charOri*mDirection + Vector3::UNIT_Y);
-                setContactTangentAcceleration(5,0);
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);
+                contact.setTangentAcceleration(5,0);
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);
             }
             else
             {
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);
             }
-            //setContactTangentAcceleration(5);
             //setContactElasticity(0.0f);
         }
         else
@@ -446,29 +476,22 @@
             vel = mCreature->getActor()->getPhysicalThing()->getVelocity();
             if( vel.y >= 0 )
             {
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);    
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);    
             }
             else
             {
-                setContactFrictionState(0,0);
-                setContactFrictionState(0,1);
+                //setContactFrictionState(0,0);
+                //setContactFrictionState(0,1);
             }
         }
+}
 
         if(mMovement != NULL)
         {
-            // @XXX Evil code!
-            // Protected members from type OgreNewt::ContactCallback have to be overridden in order
-            // for the movements to work. This is because these members are used by OgreNewt functions
-            // for processing this contact. Should probably be solved in OgreNewt directly.
-            OgreNewt::ContactCallback *movement = mMovement;
-            *movement = (OgreNewt::ContactCallback)(*this);
-            return movement->userProcess();
+            // give the movement a chance to modify the contact
+            mMovement->userProcess(contactJoint, timestep, threadid);
         }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
     }
 
     AbstractMovement *CreatureController::getMovementFromId(CreatureController::MovementType id)

Modified: rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -44,14 +44,32 @@
 
         physicsManager->createMaterialPair(char_mat, def_mat)->setContactCallback(this);
         physicsManager->createMaterialPair(char_mat, level_mat)->setContactCallback(this);
-        
+        physicsManager->createMaterialPair(char_mat, char_mat); //->setContactCallback(this);
+
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultFriction(0.0f,0.0f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultFriction(0.0f,0.0f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultFriction(0.0f,0.0f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultElasticity(0.1f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultElasticity(0.1f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultElasticity(0.1f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSoftness(0.1f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSoftness(0.1f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultSoftness(0.1f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSurfaceThickness(0.0f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSurfaceThickness(0.0f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultSurfaceThickness(0.0f);
+
+/*        
         physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultFriction(0.8f,0.4f);
         physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultFriction(0.8f,0.4f);
-        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultElasticity(0.0f);
-        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultElasticity(0.0f);
-        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSoftness(1.0f);
-        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSoftness(1.0f);
-
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultFriction(0.8f,0.4f);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultElasticity(0.01f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultElasticity(0.01f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultElasticity(0.01);
+        physicsManager->getMaterialPair(char_mat, def_mat)->setDefaultSoftness(0.8f);
+        physicsManager->getMaterialPair(char_mat, level_mat)->setDefaultSoftness(0.8f);
+        physicsManager->getMaterialPair(char_mat, char_mat)->setDefaultSoftness(0.8f);
+*/
         physicsManager->getNewtonDebugger()->setMaterialColor(char_mat, Ogre::ColourValue::Red);
     }
 
@@ -146,27 +164,34 @@
         }
     }
 
-    int CreatureControllerManager::userProcess()
+    void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
-        Actor *actor = static_cast<Actor*>(m_body0->getUserData());
+        Actor *actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));
             if (it != mControllers.end())
             {
-                // @XXX Evil code!
-                // Protected members from type OgreNewt::ContactCallback have to be overridden in order
-                // for the controllers to work. This is because these members are used by OgreNewt functions
-                // for processing this contact. Should probably be solved in OgreNewt directly.
-                OgreNewt::ContactCallback* controller = it->second;
-                *controller = (OgreNewt::ContactCallback)(*this);
-                return controller->userProcess();
+                it->second->userProcess(contactJoint, timestep, threadid);
+                return;
             }
         }
 
+        // if the controlled body is the second body...
+        actor = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+        if( actor != NULL )
+        {
+            ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));
+            if (it != mControllers.end())
+            {
+                it->second->userProcess(contactJoint, timestep, threadid);
+                return;
+            }
+        }
+
+
         LOG_ERROR(Logger::RULES,
             "Der Kollisionsk?rper konnte keinem CreatureController zugeordnet werden.");
-        return 1;
     }
 
     const Ogre::String& CreatureControllerManager::getName() const

Modified: rl/branches/persistence2/engine/rules/src/JumpHighMovement.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/JumpHighMovement.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/src/JumpHighMovement.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -147,7 +147,7 @@
         }
 
         Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * inertia;
     }
 
     bool JumpHighMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)

Modified: rl/branches/persistence2/engine/rules/src/JumpLongMovement.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/JumpLongMovement.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/src/JumpLongMovement.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -186,7 +186,7 @@
         }
 
         Vector3 omega = mMovingCreature->getCreature()->getActor()->getPhysicalThing()->_getBody()->getOmega();
-        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * inertia;
     }
 
     bool JumpLongMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)

Modified: rl/branches/persistence2/engine/rules/src/StepRecognitionMovement.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/StepRecognitionMovement.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/rules/src/StepRecognitionMovement.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -21,6 +21,8 @@
 using namespace Ogre;
 
 
+/// @todo: use TriggerVolumes
+// void NewtonCollisionSetAsTriggerVolume(const NewtonCollision* convexCollision, int trigger);
 
 
 namespace rl
@@ -98,8 +100,8 @@
 
         // the materials that are triggered here
         PhysicsMaterialRaycast::MaterialVector materialVector;
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("default")); // should we perhaps only use level here?
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("level"));
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("character")); // should we perhaps only use level here?
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID("camera"));
 
 
 
@@ -113,7 +115,8 @@
                 PhysicsManager::getSingleton()._getNewtonWorld(),
                 &materialVector,
                 start,
-                end);
+                end,
+                true);
         if(info.mBody)
         {
             mMoveToNextTarget = false;
@@ -149,7 +152,7 @@
                     mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &materialVector,
-                            start, end);
+                            start, end, true);
 
                 // do we need to check bodies left and right of this ray? (step width?)
 

Modified: rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -250,15 +250,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
-                                    entity,
-                                    false));
-                    //orientation, pos));
+                                    entity));
                     LOG_DEBUG(Logger::RULES, "Created physics proxy type 'convexhull' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "mesh" || physicsProxyType == "auto")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, entity, false));
+                                    thisWorld, entity, true));
                     LOG_DEBUG(Logger::RULES, "Created physics proxy type 'mesh' for entity '"+entity->getName()+"'.");
                 }
                 else
@@ -274,7 +272,7 @@
             }
         }
 
-        if (!collision.isNull())
+        if ( collision != NULL )
         {
             collisions.push_back(collision);
         }

Modified: rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -150,7 +150,7 @@
 
 			collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
 
-			if (!collision.isNull())
+			if ( collision != NULL )
 			{
 				collisions.push_back(collision);
 			}

Modified: rl/branches/persistence2/engine/ui/include/CombatControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/CombatControlState.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/CombatControlState.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -22,6 +22,8 @@
 #include "ControlState.h"
 #include "Combatant.h"
 #include "MessagePump.h"
+#include "PhysicsController.h"
+#include "PhysicsGenericContactCallback.h"
 #include "Selector.h"
 
 
@@ -32,9 +34,21 @@
     class CombatGui;
     class CombatManager;
 
-	class _RlUiExport CombatControlState : public ControlState, public Combatant
+	class _RlUiExport CombatControlState :
+            public ControlState,
+            public Combatant,
+            public PhysicsController,
+            public PhysicsGenericContactCallback
 	{
 	public:
+        /** 
+         * Different view-modes:
+         * @VM_COMBAT_CENTERED: "cameraLookAt" to center of combat (middle of all combatant positions)
+         * @VM_THIRD_PERSON: zooms to one combatant (not only hero!)
+        */
+        typedef enum {VM_COMBAT_CENTERED, VM_THIRD_PERSON} ViewMode;
+
+
 		/**
 		*  @throw NullPointerException if camera is NULL.
 		*  @warning Ownership of combat is taken by the CombatControlState.
@@ -46,6 +60,8 @@
 
         virtual void pause();
         virtual void resume();
+        virtual bool keyPressed(const OIS::KeyEvent& evt, bool handled);
+        virtual bool keyReleased(const OIS::KeyEvent& evt, bool handled);
 
 		void run(Ogre::Real elapsedTime);
 
@@ -54,6 +70,21 @@
         virtual Ogre::String getCombatantTypeName() const;
         virtual void requestCombatantAction();
 
+
+        // camera collision: OgreNewt::ContactCallback overides
+        int onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex);
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadIndex);
+
+        // camera movement: Newton force and torque callback
+        void OnApplyForceAndTorque(PhysicalThing *pt, float timstep);
+
+        // Change ViewMode
+        void setViewMode(ViewMode mode);
+        ViewMode getViewMode();
+        void toggleViewMode();
+        // set the combatant (must be part of this combat), the camera should focus on (VM_THIRD_PERSON) (only used internally?)
+        void setCameraFocusedCombatant(Combatant* combatant);
+
     private:
 		enum State {REQUEST_USER_INPUT, ROUND_EXECUTION};
 
@@ -74,6 +105,36 @@
         CameraObject* mCamera;
 
 		State mState;
+
+        // Camera:
+        Ogre::Degree mCameraYaw, mCameraPitch;
+        Ogre::Real mCameraMaxDistance, mCameraCombatCenteredMinDistance, mCameraThirdPersonMinDistance;
+        int mMovementState; // keyboard input
+        Ogre::Real mCameraLinearDampingK, mCameraLinearSpringK;
+        ViewMode mViewMode;
+        Ogre::Vector3 mCameraLookAt; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Vector3 mCameraOptPos; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Real mCameraDistance; // only used in third-person, changed by calculateOptimalCameraAndPosition
+        Ogre::Real mCameraSwitchDist; // set by calculateOptimalCameraPositionAndLookAt, dist at which switches to third-person
+        Ogre::Real mCameraSwitchTransitionDist; // relative value (0-1) of mCameraSwitchDist
+        Combatant* mCameraFocusedCombatant;  // the combatant currently focused by camera (VM_THIRD_PERSON)
+        // when switching from one view-mode to another or when changing focused combatant, these variables are used
+        // to provide smooth camera movement
+        bool mCameraTransitionLookAtActive;
+        bool mCameraTransitionPositionActive;
+        Ogre::Vector3 mCameraTransitionPosition;
+        Ogre::Vector3 mCameraTransitionLookAt;
+        // buffered values needed fo camera-movement, calculated once per frame:
+        Ogre::Vector3 mCombatCenter; // result of calculateCombatCenterPosition
+        Ogre::Real mCombatRadius; // result of calculateCombatRadius
+
+        // Camera helper functions
+        void resetCamera();
+        void updateCameraLookAt(Ogre::Real timestep);
+        Ogre::Vector3 calculateCombatCenterPosition();
+        Ogre::Real calculateCombatRadius(Ogre::Vector3 center);
+        // sets the variables mCameraLookAt, mCameraOptPos, mCameraDistance, usually called in OnApplyForceAndTorque
+        void calculateOptimalCameraPositionAndLookAt();
         
         // Event handlers
 		bool userRequestAttackOpponent(Combatant*);

Modified: rl/branches/persistence2/engine/ui/include/Console.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/Console.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/Console.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -53,6 +53,7 @@
 
 			bool handleKeyDown(const CEGUI::EventArgs& e);
             bool handleKeyUp(const CEGUI::EventArgs& e);
+            bool handleActivated(const CEGUI::EventArgs& e);
 			void appendTextRow(const CeGuiString& text, const CEGUI::colour color);
 
 			std::vector<CeGuiString> mHistory;

Modified: rl/branches/persistence2/engine/ui/include/CutsceneControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/CutsceneControlState.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/CutsceneControlState.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -23,7 +23,22 @@
 namespace rl {
 
 	class Actor;
+	class GameObject;
 
+	enum CameraPositionType
+	{
+	    CPT_FIXED,
+	    CPT_ROTATING
+	};
+
+	struct CameraPosition
+	{
+	    CameraPositionType type;
+	    Ogre::Vector3 position;
+	    Ogre::Quaternion orientation1;
+	    Ogre::Quaternion orientation2;
+	};
+
 	class _RlUiExport CutsceneControlState : public ControlState
 	{
 	public:
@@ -41,6 +56,17 @@
         void setCameraPosition(const Ogre::Vector3& pos);
         void setCameraOrientation(const Ogre::Quaternion& orient);
         void lookAt(const Ogre::Vector3& point);
+        void setCameraTarget(GameObject* target);
+
+        void addCamera(const Ogre::Vector3& position, const Ogre::Quaternion& orientation);
+        void addCamera(const Ogre::Vector3& position, const Ogre::Quaternion& orientation1,
+                       const Ogre::Quaternion& orientation2);
+
+	private:
+	    std::vector<CameraPosition> mPositions;
+	    GameObject* mTarget;
+
+	    CameraPosition getBestCameraPosition() const;
 	};
 }
 #endif

Modified: rl/branches/persistence2/engine/ui/include/FreeflightControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/FreeflightControlState.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/FreeflightControlState.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -26,6 +26,7 @@
 #   include <OgreNewt/OgreNewt.h>
 #else
 #   include <OgreNewt.h>
+#   include <OgreNewt_PlayerController.h>
 #endif
 
 namespace rl {
@@ -57,12 +58,10 @@
 	    void toggleCameraCollision();
 	    void resetCamera();
 
-        /// This is the OgreNewt contact process callback for the combination
-        /// Character <-> Level
-        int userProcess();
-
+        /// Newton contacts callback
+        int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex );
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
 	private:		
 		int mCurrentMovementState;
@@ -78,6 +77,8 @@
         Ogre::Real mMouseSensitivity;
         bool mInvertedMouse;
         std::pair<Ogre::Degree, Ogre::Degree> mPitchRange;
+
+        OgreNewt::PlayerController *mOgreNewtPlayerController;
 	};
 }
 #endif

Modified: rl/branches/persistence2/engine/ui/include/ItemDescriptionDragContainer.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/ItemDescriptionDragContainer.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/ItemDescriptionDragContainer.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -25,9 +25,17 @@
 	class ItemDescriptionDragContainer : public ItemDragContainer
 	{
 	public:
-		ItemDescriptionDragContainer(Item* item, const CeGuiString& name);
+		ItemDescriptionDragContainer(const CeGuiString &type, const CeGuiString& name);
+                void setItem(Item*);
+                static const CeGuiString WidgetTypeName; // for CEGUI
 	};
 
 } // namespace rl
+namespace CEGUI{
 
+    using rl::ItemDescriptionDragContainer;
+
+    CEGUI_DECLARE_WINDOW_FACTORY(ItemDescriptionDragContainer)
+}
+
 #endif //__ItemDescriptionDragContainer_H__

Modified: rl/branches/persistence2/engine/ui/include/ItemDragContainer.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/ItemDragContainer.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/ItemDragContainer.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -18,6 +18,7 @@
 
 #include "UiPrerequisites.h"
 
+#include <CEGUI.h>
 #include <elements/CEGUIDragContainer.h>
 
 namespace rl 
@@ -41,6 +42,7 @@
 		const CeGuiString& getItemParentSlot() const;
 		Inventory* getItemParentInventory() const;
 		Item* getItem() const;
+                virtual void setItem(Item*); // can only be used once to initialize the Container
 		CEGUI::Window* getContentWindow() const;
 	
 		bool _handleItemMouseClick(const CEGUI::EventArgs& evt, Item* item);
@@ -49,13 +51,15 @@
         bool fadeOutAndHide(Ogre::Real delay);
         bool stopFadeOut();
 
-        void destroyWindow(); // this is internally done with a windowfadejob to prevent problems
+        virtual void destroy(void); // inherited from CEGUI::WINDOW
 
-        void setDestroyListener(ItemDragContainerDestroyListener *listener) {mDestroyListener = listener;}
+        //void destroyWindow(); // this is internally done with a windowfadejob to prevent problems
+
+        void setDestroyListener(ItemDragContainerDestroyListener *listener);
 	protected:
 		CEGUI::Window* mContentWindow;
 		
-		ItemDragContainer(Item* item, const CeGuiString& name);
+		ItemDragContainer(const CeGuiString &type, const CeGuiString& name);
 		virtual bool testClassName_impl(const CEGUI::String& class_name) const;
 
 	private:
@@ -71,7 +75,17 @@
     class ItemDragContainerDestroyListener
     {
     public:
+        ItemDragContainerDestroyListener();
+        virtual ~ItemDragContainerDestroyListener();
         virtual void notifyItemDragContainerDestroyed(ItemDragContainer* cont) = 0;
+    protected:
+        void addDragContainer(ItemDragContainer* dragcont);
+        void removeDragContainer(ItemDragContainer* dragcont);
+        friend class ItemDragContainer;
+    private:
+        typedef std::map<CeGuiString, ItemDragContainer*> DndContainerMap;
+        DndContainerMap mContainers;
+        bool mIsDestroying;
     };
 
 } // namespace rl

Modified: rl/branches/persistence2/engine/ui/include/ItemIconDragContainer.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/ItemIconDragContainer.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/ItemIconDragContainer.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -27,9 +27,19 @@
 	class ItemIconDragContainer : public ItemDragContainer
 	{
 	public:
-		ItemIconDragContainer(Item* item, const CeGuiString& name);
+		ItemIconDragContainer(const CeGuiString &type, const CeGuiString& name);
+                void setItem(Item* item);
+                static const CeGuiString WidgetTypeName; // for CEGUI
 	};
 
 } // namespace rl
 
+namespace CEGUI{
+
+    using rl::ItemIconDragContainer;
+
+    CEGUI_DECLARE_WINDOW_FACTORY(ItemIconDragContainer)
+
+}
+
 #endif //__ItemIconDragContainer_H__

Modified: rl/branches/persistence2/engine/ui/include/MovementControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/MovementControlState.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/MovementControlState.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -60,10 +60,11 @@
 
         /// This is the OgreNewt contact process callback for the combination
         /// Character <-> Level
-        int userProcess();
+        int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex );
+        void userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadid);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// First oder Third person view.
         void setViewMode(ViewMode mode);
@@ -123,12 +124,9 @@
 
         ViewMode mViewMode;
 
-        int mObstractedFrameCount;
-        Ogre::Real mObstractedTime;
-        int mCameraJammedFrameCount;
-        Ogre::Real mCameraJammedTime;
-
         PhysicsMaterialRaycast* mRaycast;
+        PhysicsMaterialConvexcast * mConvexcast;
+        OgreNewt::Collision *mCameraCastCollision;
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 

Modified: rl/branches/persistence2/engine/ui/include/WindowFadeJob.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/WindowFadeJob.h	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/include/WindowFadeJob.h	2009-02-11 13:24:47 UTC (rev 4764)
@@ -40,8 +40,8 @@
             Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
         WindowFadeJob(CEGUI::Window* window, Mode mode, 
             Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
-        WindowFadeJob(ItemDragContainer* window, Mode mode, 
-            Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
+        //WindowFadeJob(ItemDragContainer* window, Mode mode, 
+        //    Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
 
         virtual bool execute(Ogre::Real time);
         virtual void discard();
@@ -49,7 +49,7 @@
     protected:
         AbstractWindow* mAbstractWindow;
         CEGUI::Window* mCEGUIWindow;
-        ItemDragContainer* mItemDragContainer;
+        //ItemDragContainer* mItemDragContainer;
         Mode mMode;
         Ogre::Real mChangeRate;
         Ogre::Real mCurrentAlpha;

Modified: rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -22,6 +22,7 @@
 #include "Combat.h"
 #include "CombatGui.h"
 #include "CombatManager.h"
+#include "CommandMapper.h"
 #include "CoreSubsystem.h"
 #include "Creature.h"
 #include "CreatureController.h"
@@ -49,7 +50,21 @@
           mEnemySelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
             QUERYFLAG_CREATURE),
           mCamera(NULL),
-		  mState(ROUND_EXECUTION)
+		  mState(ROUND_EXECUTION),
+          mCameraYaw(0),
+          mCameraPitch(60), // the same value as in resetCamera
+          mMovementState(0),
+          mCameraLinearSpringK(100.0f),
+          mCameraLinearDampingK(Math::NEG_INFINITY),
+          mViewMode(VM_COMBAT_CENTERED),
+          mCameraFocusedCombatant(NULL),
+          mCameraTransitionLookAtActive(false),
+          mCameraTransitionPositionActive(false),
+          mCameraMaxDistance(30.0f),
+          mCameraCombatCenteredMinDistance(5.0f),
+          mCameraThirdPersonMinDistance(1.0f),
+          mCameraSwitchDist(30.0f),
+          mCameraSwitchTransitionDist(0.8f)
     {
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
@@ -74,6 +89,11 @@
 
         mCamera = static_cast<CameraObject*>(mCameraActor->getControlledObject());
 		mCombatGui = new CombatGui(mCombat, mCamera);
+
+
+        // calculate camera spring-damping system coefficients
+        Real relationCoefficient = 0.8f;
+        mCameraLinearDampingK = relationCoefficient * 2.0 * Math::Sqrt(mCameraLinearSpringK);
     }
 
 	CombatControlState::~CombatControlState()
@@ -85,9 +105,40 @@
 
     void CombatControlState::resume()
     {
-        mCameraActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->freeze();
+        // control camera
+        mCameraActor->getPhysicalThing()->setMaterialID(
+        PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
+        
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
 
+       
+
+
         ///\todo Richtig machen, nur tempor?r Ani hier setzen.
         static_cast<MeshObject*>(mCharacterActor->getControlledObject())
             ->startAnimation("kampf_schwerter_idle");
@@ -119,24 +170,361 @@
         mCombat->addAlly(this);
 
         mCombat->start();
+
+        // reset camera
+        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -> looks nicer
+        // perhaps this should be handled differently!
+        mMovementState = 0;
+        // calculate some buffered values, so they are initialized:
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraFocusedCombatant = this;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        mCameraDistance = 30.0f; // only used for third-person
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        calculateOptimalCameraPositionAndLookAt();
+ 
+        // update CombatGui
+        mCombatGui->update();
     }
 
     void CombatControlState::pause()
     {
-		mCombatGui->hide();
+        mCombatGui->hide();
 
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCharacterActor->getPhysicalThing()->unfreeze();
+
+        // stop controlling camera actor
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
+        // cam<->Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        // cam<->Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+
         static_cast<MeshObject*>(mCharacterActor->getControlledObject())->stopAllAnimations();
 
         mCombat->pause();
     }
 
-	void CombatControlState::run(Ogre::Real elapsedTime)
+    bool CombatControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
     {
-		mCombatGui->update();
+        bool retval = false;
+        if( !handled )
+        {
+            int movement = mCommandMapper->getMovement(evt.key);
+            mMovementState |= movement;
+            
+            if( movement != MOVE_NONE )
+                retval = true;
+        }
+
+        if( ControlState::keyPressed(evt, handled || retval) )
+            retval = true;
+
+        return retval;
     }
+     
+    bool CombatControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper->getMovement(evt.key);
+        if( movement != MOVE_NONE )
+        {
+            mMovementState &= (~movement);
+            retval = true;
+        }
 
+        if( ControlState::keyReleased(evt, handled || retval) )
+            retval = true;
+        return retval;
+    }
+
+    void CombatControlState::run(Ogre::Real elapsedTime)
+    {
+        // updateCameraLookAt should be called before mCombatGui->update()!
+
+        // update camera look-at position
+        updateCameraLookAt(elapsedTime);
+
+
+        // update CombatGui
+        mCombatGui->update();
+
+
+        // slow down rotational movement, when radius grows
+        if( mMovementState & MOVE_RIGHT )
+            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState & MOVE_LEFT )
+            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState & MOVE_FORWARD )
+            mCameraDistance -= 5 * elapsedTime;
+        if( mMovementState & MOVE_BACKWARD )
+            mCameraDistance += 5 * elapsedTime;
+
+        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
+        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
+
+        // switch view mode smoothly if nearer:
+        if( mViewMode == VM_COMBAT_CENTERED )
+        {
+            if( mMovementState & MOVE_FORWARD )
+            {
+                mViewMode = VM_THIRD_PERSON;
+            }
+        }
+        else // VM_THIRD_PERSON
+        {
+            if( mCameraDistance >= mCameraSwitchDist - 0.05f && mMovementState & MOVE_BACKWARD )
+            {
+                mViewMode = VM_COMBAT_CENTERED;
+            }
+        }
+    }
+
+    void CombatControlState::resetCamera(void)
+    {
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        if( mViewMode == VM_THIRD_PERSON )
+            mCameraDistance = 2.0f; // only used for third-person
+        calculateOptimalCameraPositionAndLookAt();
+        mCameraActor->setPosition(mCameraOptPos);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    void CombatControlState::updateCameraLookAt(Real elapsedTime)
+    {
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    Vector3 CombatControlState::calculateCombatCenterPosition()
+    {
+        // get the center of all persons (allies and opponents)
+        int n = 0;
+        Vector3 pos = Vector3::ZERO;
+
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            pos += (*it)->getCreature()->getPosition();
+            n++;
+        }
+
+        const Combat::CombatantSet &opponents (mCombat->getAllPlayerOpponents());
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            pos += (*it)->getCreature()->getPosition();
+            n++;
+        }
+
+        if( n > 0 )
+            pos /= n;
+        else
+        {
+            pos = mCharacter->getPosition();
+        }
+
+        return pos;
+    }
+
+    Real CombatControlState::calculateCombatRadius(Vector3 center)
+    {
+        // get the greatest distance from center from all persons
+        Real distance = 0;
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
+        }
+        const Combat::CombatantSet &opponents = mCombat->getAllPlayerOpponents();
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
+        }
+        return distance;
+    }
+    
+    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
+    {
+        // some variables:
+        Vector3 playerPos = mCharacter->getPosition();
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+
+
+
+        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
+        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
+            
+        // put camera on the line player-center far enough to see all persons
+        // if player is "exactly" in the center, use player orientation as fallback orientation
+        // + rotation from mCameraYaw
+        Vector3 diff = playerPos - mCombatCenter;
+        diff.y = 0;
+        Quaternion combatCenteredCamYaw;
+        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
+        if( diff.squaredLength() < 0.01 )
+        {
+            diff = mCharacterActor->getOrientation()*Vector3::UNIT_Z;
+        }
+        diff.y = 0;
+        diff.normalise();
+        diff = combatCenteredCamYaw*diff;
+        diff.y = Math::Tan(mCameraPitch.valueRadians());
+
+        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
+        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
+        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
+ 
+
+
+
+
+        // TODO
+        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
+        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
+        // ideal scheint mir eine "runde" bewegung, a la kamerafahrt!
+
+
+        Vector3 center;
+        Vector3 dist;
+        if( mViewMode == VM_THIRD_PERSON && mCameraFocusedCombatant )
+        {
+            center = mCameraFocusedCombatant->getPosition();
+            // if mCameraDistance is near the one needed for combatCentered,
+            // interpolate the center (between center of third-person-view
+            // and center of combat-centered-view)
+            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
+            if( interpolateDist <  mCameraSwitchTransitionDist*mCameraSwitchDist )
+            {
+                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
+            }
+            dist = mCameraDistance*cosPitch;
+        }
+        else // assume VM_COMBAT_CENTERED
+        {
+            center = mCombatCenter;
+            // update camera-distance variable
+            mCameraDistance = (combatCenteredDistance*diff).length();
+            dist = combatCenteredDistance;
+        }
+
+        mCameraSwitchDist = (combatCenteredDistance*diff).length();
+        mCameraOptPos = center + dist*diff;
+        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
+    }
+
+    void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+
+        calculateOptimalCameraPositionAndLookAt();
+
+        // handle transition
+        if( mCameraTransitionPositionActive )
+        {
+            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
+            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() < 0.02 )
+                mCameraTransitionPositionActive = false;
+            mCameraOptPos = mCameraTransitionPosition;
+        }
+        if( mCameraTransitionLookAtActive )
+        {
+            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
+            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() < 0.02 )
+                mCameraTransitionLookAtActive = false;
+            mCameraLookAt = mCameraTransitionLookAt;
+        }
+
+
+        Vector3 diff = camPos - mCameraOptPos;
+        Vector3 cameraVelocity;
+        cameraVelocity = mCamBody->getVelocity();
+        // spring velocity
+        Vector3 springAcc = -mCameraLinearSpringK*diff - mCameraLinearDampingK * cameraVelocity;
+                                            
+        // get the camera mass
+        Real mass;
+        Vector3 inertia;
+        mCamBody->getMassMatrix(mass, inertia);
+                                                
+        mCamBody->setForce(springAcc * mass);
+    }
+
+    void CombatControlState::setViewMode(ViewMode mode)
+    {
+        if(mode != mViewMode)
+        {
+            mViewMode = mode;
+            mCameraTransitionPosition = mCameraActor->getPosition();
+            mCameraTransitionLookAt = mCameraLookAt;
+            mCameraTransitionLookAtActive = true;
+            mCameraTransitionPositionActive = true;
+        }
+    }
+
+    void CombatControlState::toggleViewMode()
+    {
+        if( mViewMode == VM_COMBAT_CENTERED )
+            setViewMode(VM_THIRD_PERSON);
+        else
+            setViewMode(VM_COMBAT_CENTERED);
+    }
+
+    CombatControlState::ViewMode CombatControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
+    {
+        if( combatant != mCameraFocusedCombatant )
+        {
+            if( mViewMode == VM_THIRD_PERSON )
+            {
+                mCameraTransitionPosition = mCameraActor->getPosition();
+                mCameraTransitionLookAt = mCameraLookAt;
+                mCameraTransitionLookAtActive = true;
+                mCameraTransitionPositionActive = true;
+            }
+        }
+        mCameraFocusedCombatant = combatant;
+    }
+
+    int CombatControlState::onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex)
+    {
+        // TODO handle camera collisions here
+        return 0;
+    }
+   
+    void CombatControlState::userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadIndex)
+    {
+        // TODO handle camera collisions here
+    }
+
     Ogre::String CombatControlState::getCombatantTypeName() const
     {
         return "CombatControlState";

Modified: rl/branches/persistence2/engine/ui/src/CombatGui.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CombatGui.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/CombatGui.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -106,14 +106,15 @@
                 (*it)->getCreatureController()->getCreature()->getActor()
                     ->_getSceneNode()->_getWorldAABB());
 
-			// Place buttons, if needed by current state
-			if (mUserInputEnabled)
-			{
-				Ogre::Rect screenRect = mCamera->getPixelRectOnScreen(rec);
-				// Place button set above opponent, horizontally centered.
-				int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
-				mCombatWindow->placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
-			}
+			// Place buttons, update every frame (camera movement requires this)
+                        // TODO: is there any better possibility (attach button-windows to ogre node?!?)
+			//if (mUserInputEnabled)
+			//{
+			Ogre::Rect screenRect = mCamera->getPixelRectOnScreen(rec);
+			// Place button set above opponent, horizontally centered.
+			int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
+			mCombatWindow->placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
+			//}
 
 			// draw Hud
 

Modified: rl/branches/persistence2/engine/ui/src/Console.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/Console.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/Console.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -57,9 +57,15 @@
 		mCommandLine->subscribeEvent(
 			Editbox::EventKeyUp,
 			boost::bind(&Console::handleKeyUp, this, _1));
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-            boost::bind(&Console::hideWindow, this));
+		mWindow->subscribeEvent(
+                        FrameWindow::EventCloseClicked,
+                        boost::bind(&Console::hideWindow, this));
+                mWindow->subscribeEvent(
+                        FrameWindow::EventActivated,
+                        boost::bind(&Console::handleActivated, this, _1));
 
+                mWindow->setAlwaysOnTop(true);
+
 		// load history from file
         if( ConfigurationManager::getSingleton().getIntSetting("General", "Save Console History") > 0 )
         {
@@ -282,5 +288,11 @@
 		else
 			mCommandLine->setText(mHistory[mHistoryMarker]);
 	}
+
+        bool Console::handleActivated(const CEGUI::EventArgs&)
+        {
+            mCommandLine->activate();
+            return false;
+        }
 }
 

Modified: rl/branches/persistence2/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/ContainerContentWindow.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/ContainerContentWindow.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -72,7 +72,7 @@
 
 		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
 		{
-			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+			ItemDragContainer* dragcont = dynamic_cast<ItemDragContainer*>(
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
 
@@ -158,7 +158,7 @@
 
 		if (evtArgs.dragDropItem->testClassName("ItemDragContainer"))
 		{
-			ItemDragContainer* dragcont = static_cast<ItemDragContainer*>(
+			ItemDragContainer* dragcont = dynamic_cast<ItemDragContainer*>(
 				evtArgs.dragDropItem);
 			Item* item = dragcont->getItem();
 
@@ -179,7 +179,8 @@
             {
                 if( dragcont != getItemWindow(item) )
                 {
-                    dragcont->destroyWindow();
+                    CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+                    //dragcont->destroyWindow();
                     dragcont = createItemWindow(item);
                     mContentWindow->addChildWindow(dragcont);
                 }
@@ -211,8 +212,11 @@
 			mWindow->getName() +  "/item/"
 			+ item->getId()+"_DragContainer";
 
-		itemhandler = new ItemIconDragContainer(item,
-			dragContainerName);
+                itemhandler = dynamic_cast<ItemIconDragContainer*>(
+                    AbstractWindow::loadWindow("itemicondragcontainer.xml", dragContainerName));
+                    //CEGUI::WindowManager::getSingleton().createWindow("ItemIconDragContainer", dragContainerName));
+                itemhandler->setItem(item);
+		//itemhandler = new ItemIconDragContainer(item, dragContainerName);
         itemhandler->setDestroyListener(this);
         mItemDragContainerMap.insert(std::make_pair(item, itemhandler));
 		itemhandler->setItemParent(mContainer);

Modified: rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/CutsceneControlState.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -21,6 +21,7 @@
 #include "Actor.h"
 #include "CameraObject.h"
 #include "CommandMapper.h"
+#include "GameObject.h"
 #include "PhysicalThing.h"
 
 using namespace Ogre;
@@ -28,7 +29,8 @@
 namespace rl {
 
 	CutsceneControlState::CutsceneControlState(CommandMapper* cmdMapper,
-        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE)
+        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE),
+        mTarget(NULL)
 	{
 	}
 
@@ -49,23 +51,63 @@
 		mCameraActor->_getSceneNode()->setFixedYawAxis(true);
     }
 
-	void CutsceneControlState::run(Ogre::Real elapsedTime)
+	void CutsceneControlState::run(Real elapsedTime)
 	{
+	    CameraPosition pos = getBestCameraPosition();
+	    switch (pos.type)
+	    {
+	    case CPT_FIXED:
+	        setCameraPosition(pos.position);
+	        setCameraOrientation(pos.orientation1);
+	        break;
+	    case CPT_ROTATING:
+	        setCameraPosition(pos.position);
+	        lookAt(mTarget->getPosition());
+	        break;
+	    }
 	}
 
-    void CutsceneControlState::setCameraPosition(const Ogre::Vector3& pos)
+	void CutsceneControlState::setCameraTarget(GameObject* target)
+	{
+	    mTarget = target;
+	}
+
+    void CutsceneControlState::setCameraPosition(const Vector3& pos)
     {
         mCameraActor->setPosition(pos);
     }
 
-    void CutsceneControlState::setCameraOrientation(const Ogre::Quaternion& orient)
+    void CutsceneControlState::setCameraOrientation(const Quaternion& orient)
     {
         mCameraActor->setOrientation(orient);
     }
 
-    void CutsceneControlState::lookAt(const Ogre::Vector3& point)
+    void CutsceneControlState::lookAt(const Vector3& point)
     {
-        dynamic_cast<Ogre::Camera*>(mCameraActor->getControlledObject()->getMovableObject())
+        dynamic_cast<Camera*>(mCameraActor->getControlledObject()->getMovableObject())
             ->lookAt(point);
     }
+
+    CameraPosition CutsceneControlState::getBestCameraPosition() const
+    {
+        if (mPositions.empty())
+        {
+            CameraPosition nullPos = {CPT_FIXED, Vector3::ZERO, Quaternion::IDENTITY, Quaternion::IDENTITY};
+            return nullPos;
+        }
+        return *mPositions.begin();
+    }
+
+    void CutsceneControlState::addCamera(const Vector3& position, const Quaternion& orientation)
+    {
+        CameraPosition cpos = {CPT_FIXED, position, orientation, orientation};
+        mPositions.push_back(cpos);
+    }
+
+    void CutsceneControlState::addCamera(const Vector3& position, const Quaternion& orientation1,
+            const Quaternion& orientation2)
+    {
+        CameraPosition cpos = {CPT_ROTATING, position, orientation1, orientation2};
+        mPositions.push_back(cpos);
+    }
 }

Modified: rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -46,7 +46,8 @@
         mCollisionsEnabled(false),
         mPitchRange(Degree(-89), Degree(89)),
         mYaw(Degree(0)),
-        mPitch(Degree(0))
+        mPitch(Degree(0)),
+        mOgreNewtPlayerController(NULL)
 	{
         mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
         mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
@@ -59,7 +60,10 @@
     void FreeflightControlState::pause()
     {
 		mCameraActor->getPhysicalThing()->freeze();
-		mCharacterActor->getPhysicalThing()->unfreeze();
+		//mCharacterActor->getPhysicalThing()->unfreeze();
+        delete mOgreNewtPlayerController;
+        mOgreNewtPlayerController = NULL;
+        mCharacterActor->getPhysicalThing()->setUpConstraint();
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
 
         // Char<->Level collision back to default
@@ -78,7 +82,9 @@
     void FreeflightControlState::resume()
     {
         mCameraActor->getPhysicalThing()->unfreeze();
-		mCharacterActor->getPhysicalThing()->freeze();
+		//mCharacterActor->getPhysicalThing()->freeze();
+        mCharacterActor->getPhysicalThing()->clearUpConstraint();
+        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
 
@@ -92,21 +98,30 @@
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID("camera"),
                     PhysicsManager::getSingleton().getMaterialID("default"));
-        mat_pair->setContactCallback(this);
+        mat_pair->setContactCallback(NULL);
         mat_pair->setContinuousCollisionMode(1);
+        mat_pair->setDefaultSoftness(1.0f);
         mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setContactCallback(this);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID("camera"),
                     PhysicsManager::getSingleton().getMaterialID("level"));
-        mat_pair->setContactCallback(this);
+        mat_pair->setContactCallback(NULL);
         mat_pair->setContinuousCollisionMode(1);
+        mat_pair->setDefaultSoftness(1.0f);
         mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setContactCallback(this);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID("camera"),
                     PhysicsManager::getSingleton().getMaterialID("character"));
-        mat_pair->setContactCallback(this);
+        mat_pair->setContactCallback(NULL);
         mat_pair->setContinuousCollisionMode(1);
+        mat_pair->setDefaultSoftness(1.0f);
         mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setContactCallback(this);
     }
 
 	void FreeflightControlState::run(Real elapsedTime)
@@ -198,11 +213,20 @@
         if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
         if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
 
+if( mCollisionsEnabled )
+    mOgreNewtPlayerController->setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
+
         mCameraActor->setOrientation(Quaternion::IDENTITY);
         mCameraActor->yaw(mYaw.valueDegrees());
         mCameraActor->pitch(mPitch.valueDegrees());
     }
 
+    
+    int FreeflightControlState::onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex )
+    {
+        return mCollisionsEnabled;
+    }
+
 	void FreeflightControlState::toggleCameraCollision()
 	{
 		// with or without collision?
@@ -286,35 +310,12 @@
         return retval;
 	}
 
-    int FreeflightControlState::userProcess()
-    {
-        if (m_body0 == mCamBody || m_body1 == mCamBody)
-        {
-            // this is camera collision
 
-            if( !mCollisionsEnabled )
-                return 0;
-
-            setContactSoftness(1.0f);  // "weiche" Collision
-            setContactElasticity(0.0f);
-
-            return 1;
-        }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
-    }
-
-
-
-    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
         OgreNewt::Body* body = thing->_getBody();
 
-        // Get the current world timestep
-        Real timestep = world->getTimeStep();
-
         if (body == mCamBody)
         {
             // apply camera force
@@ -332,7 +333,8 @@
             Vector3 currentVel = body->getVelocity();
             Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
             Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
-
+if( mCollisionsEnabled )
+    force = mass*(- currentVel) / delay;
             body->setForce(force);
         }
     }

Modified: rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -23,6 +23,7 @@
 #include <CEGUIWindowManager.h>
 #include <elements/CEGUIFrameWindow.h>
 
+#include "AbstractWindow.h"
 #include "Actor.h"
 #include "ActorManager.h"
 #include "CameraObject.h"
@@ -213,10 +214,19 @@
 		else
 		{
 			if (showdescription)
-				itemhandler = new ItemDescriptionDragContainer(item, dragContainerName);
+                        {
+				itemhandler = dynamic_cast<ItemDescriptionDragContainer*> (
+                                        AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", dragContainerName));
+                                //new ItemDescriptionDragContainer(item, dragContainerName);
+                                itemhandler->setItem(item);
+                        }
 			else
             {
-				itemhandler = new ItemIconDragContainer(item, dragContainerName);
+				itemhandler = dynamic_cast<ItemIconDragContainer*> (
+                                        AbstractWindow::loadWindow("itemicondragcontainer.xml", dragContainerName));
+                                    //CEGUI::WindowManager::getSingleton().createWindow("ItemIconDragContainer", dragContainerName));
+                                itemhandler->setItem(item);
+				//itemhandler = new ItemIconDragContainer(item, dragContainerName);
                 itemhandler->setTooltipText(item->getName());
             }
 
@@ -286,20 +296,14 @@
 
 			if (mInventory->canHold(item, targetSlot))
 			{
-				if (dragcont->getItemParentContainer() != NULL)
-				{
-					dragcont->getParent()->removeChildWindow(dragcont);
-				}
-				else if (dragcont->getItemParentSlot() != "")
-				{
-					dragcont->getParent()->removeChildWindow(dragcont);
-				}
+				dragcont->getParent()->removeChildWindow(dragcont);
 
 				ItemDragContainer* newCont = createItemDragContainer(item, false, targetSlot);
 
 				if (newCont)
 				{
-                    dragcont->destroyWindow();
+                                    CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+//                    dragcont->destroyWindow();
 				}
 				else
 				{
@@ -412,7 +416,8 @@
 				-1);
 
 
-            dragcont->destroyWindow();
+                        CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+//            dragcont->destroyWindow();
 
 			Ogre::Vector3 targetPosWorldSpace =
 				mInventory->getOwner()->getPosition()

Modified: rl/branches/persistence2/engine/ui/src/ItemDescriptionDragContainer.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/ItemDescriptionDragContainer.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/ItemDescriptionDragContainer.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -22,10 +22,34 @@
 #include "AbstractWindow.h"
 #include "Item.h"
 
+
+
+namespace CEGUI
+{
+    CEGUI_DEFINE_WINDOW_FACTORY(ItemDescriptionDragContainer)
+}
+
 namespace rl {
-	ItemDescriptionDragContainer::ItemDescriptionDragContainer(Item* item, const CeGuiString& name)
-		: ItemDragContainer(item, name)
+
+    const CeGuiString ItemDescriptionDragContainer::WidgetTypeName("ItemDescriptionDragContainer");
+
+
+
+
+	ItemDescriptionDragContainer::ItemDescriptionDragContainer(const CeGuiString &type, const CeGuiString& name)
+		: ItemDragContainer(type, name)
 	{
+		CeGuiString prefix = name;
+
+		mContentWindow = this; //AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", prefix);
+		addChildWindow(mContentWindow);
+                mContentWindow->setDestroyedByParent(true);
+	}
+
+        void ItemDescriptionDragContainer::setItem(Item* item)
+        {
+            ItemDragContainer::setItem(item);
+
 		CeGuiString icon = item->getImageName();
 
 		if (icon == "")
@@ -33,19 +57,20 @@
 			icon = ICON_UNKNOWN_ITEM;
 		}
 
-		CeGuiString prefix = name;
-		mContentWindow = AbstractWindow::loadWindow("itemdescriptiondragcontainer.xml", prefix);
+                const CeGuiString &name = getName();
 
+
 		mContentWindow->getChild(
-			name+"ItemDescriptionDragContainer/Icon")
+			name+"/Icon")
 			->setProperty("Image", icon);
 		mContentWindow->getChild(
-			name+"ItemDescriptionDragContainer/Name")
+			name+"/Name")
 			->setText(item->getName());
 		mContentWindow->getChild(
-			name+"ItemDescriptionDragContainer/Description")
+			name+"/Description")
 			->setText(item->getDescription());
 
+
 		mContentWindow->subscribeEvent(
 			Window::EventMouseClick,
 			boost::bind(&ItemDragContainer::_handleItemMouseClick, this, _1, item));
@@ -54,7 +79,8 @@
 			Window::EventMouseDoubleClick,
 			boost::bind(&ItemDragContainer::_handleItemDoubleClick, this, _1, item));
 
-		setSize(mContentWindow->getSize());
-		addChildWindow(mContentWindow);
-	}
+
+
+	    setSize(mContentWindow->getSize());
+        }
 }

Modified: rl/branches/persistence2/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/ItemDragContainer.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/ItemDragContainer.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -31,9 +31,9 @@
 namespace rl {
 	const Ogre::String ItemDragContainer::ICON_UNKNOWN_ITEM = "set:ModelThumbnails image:item_unknown";
 
-	ItemDragContainer::ItemDragContainer(Item* item, const CeGuiString& name)
-		: CEGUI::DragContainer("DragContainer", name),
-		mItem(item),
+	ItemDragContainer::ItemDragContainer(const CeGuiString &type, const CeGuiString& name)
+		: CEGUI::DragContainer(type, name),
+		mItem(NULL),
 		mParentContainer(NULL),
 		mParentSlot(""),
 		mContentWindow(NULL),
@@ -43,10 +43,28 @@
 	{
 	}
 
-	ItemDragContainer::~ItemDragContainer()
+        void ItemDragContainer::setItem(Item* item)
+        {
+            if( mItem != NULL )
+                Throw(IllegalArgumentException,"The item of an ItemDragContainer can only be set once!");
+            mItem = item;
+        }
+
+        ItemDragContainer::~ItemDragContainer()
+        {
+            if(mDestroyListener)
+                mDestroyListener->notifyItemDragContainerDestroyed(this);
+            setDestroyListener(NULL);
+        }
+
+	void ItemDragContainer::destroy()
 	{
-        if(mDestroyListener)
-            mDestroyListener->notifyItemDragContainerDestroyed(this);
+            if(mDestroyListener)
+                mDestroyListener->notifyItemDragContainerDestroyed(this);
+            setDestroyListener(NULL);
+
+            CEGUI::DragContainer::destroy();
+/*        
         stopFadeOut();
 
         hide();
@@ -59,8 +77,9 @@
 		removeChildWindow(mContentWindow);
 		CEGUI::WindowManager::getSingleton().destroyWindow(mContentWindow);
         CEGUI::WindowManager::getSingleton().destroyWindow(this);
+*/
 	}
-
+/*
     void ItemDragContainer::destroyWindow()
     {
         if(mDestroyListener)
@@ -80,7 +99,7 @@
             JobScheduler::JP_NORMAL,
             0.0f);
     }
-
+*/
 	void ItemDragContainer::setItemParent(Container* container)
 	{
 		mParentContainer = container;
@@ -179,4 +198,65 @@
 
         return true;
     }
+
+    void ItemDragContainer::setDestroyListener(ItemDragContainerDestroyListener *listener)
+    {
+        if( listener == mDestroyListener )
+            return ;
+
+        if( mDestroyListener )
+            mDestroyListener->removeDragContainer(this);
+
+        mDestroyListener = listener;
+
+        if( listener )
+            mDestroyListener->addDragContainer(this);
+    }
+
+
+    ItemDragContainerDestroyListener::ItemDragContainerDestroyListener() : mIsDestroying(false)
+    {
+    }
+
+    ItemDragContainerDestroyListener::~ItemDragContainerDestroyListener()
+    {
+        // remove all dragContainers from list
+        mIsDestroying = true;
+        for( DndContainerMap::iterator it = mContainers.begin(); it != mContainers.end(); it++ )
+            it->second->setDestroyListener(NULL);
+    }
+
+    void ItemDragContainerDestroyListener::addDragContainer(ItemDragContainer *dragcont)
+    {
+        if( dragcont == NULL )
+            Throw(NullPointerException, "Parameter dragcont in ItemDragContainerDestroyListener::addDragContainer should not be NULL!");
+
+        DndContainerMap::iterator it = mContainers.find(dragcont->getName());
+        if( it != mContainers.end() )
+        {
+            Throw(IllegalArgumentException, "ItemDragContainerDestroyListener::addDragContainer: ItemDragContainer with name '"+
+                    dragcont->getName()+"' already added!");
+        }
+
+        mContainers.insert(std::make_pair(dragcont->getName(), dragcont));
+    }
+
+    void ItemDragContainerDestroyListener::removeDragContainer(ItemDragContainer *dragcont)
+    {
+        if( mIsDestroying )  // if this Listener is destroyed, we don't need to care about the list
+            return ;
+
+        if( dragcont == NULL )
+            Throw(NullPointerException, "Parameter dragcont in ItemDragContainerDestroyListener::removeDragContainer should not be NULL!");
+
+        DndContainerMap::iterator it = mContainers.find(dragcont->getName());
+        if( it == mContainers.end() )
+        {
+            Throw(IllegalArgumentException, "ItemDragContainerDestroyListener::removeDragContainer: ItemDragContainer with name '"+
+                    dragcont->getName()+"' was not added before!");
+        }
+
+        mContainers.erase(it);
+   }
+
 }

Modified: rl/branches/persistence2/engine/ui/src/ItemIconDragContainer.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/ItemIconDragContainer.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/ItemIconDragContainer.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -22,26 +22,49 @@
 #include "AbstractWindow.h"
 #include "Item.h"
 
+namespace CEGUI{
+    CEGUI_DEFINE_WINDOW_FACTORY(ItemIconDragContainer)
+}
 namespace rl {
-	ItemIconDragContainer::ItemIconDragContainer(Item* item, const CeGuiString& name)
-		: ItemDragContainer(item, name)
+
+    const CeGuiString ItemIconDragContainer::WidgetTypeName("ItemIconDragContainer");
+
+
+
+	ItemIconDragContainer::ItemIconDragContainer(const CeGuiString &type, const CeGuiString& name)
+		: ItemDragContainer(type, name)
 	{
+		CeGuiString prefix = name;
+		mContentWindow = this; //AbstractWindow::loadWindow("itemicondragcontainer.xml", prefix);
+
+
+		for (size_t idx = 0; idx < mContentWindow->getChildCount(); ++idx)
+		{
+			LOG_MESSAGE(Logger::UI, mContentWindow->getChildAtIdx(idx)->getName());
+		}
+
+		addChildWindow(mContentWindow);
+                mContentWindow->setDestroyedByParent(true);
+	}
+
+        void ItemIconDragContainer::setItem(Item* item)
+        {
+            ItemDragContainer::setItem(item);
+
+
+
+
 		CeGuiString icon = item->getImageName();
 
 		if (icon == "")
 		{
 			icon = ICON_UNKNOWN_ITEM;
 		}
+                const CeGuiString &name = getName();
 
-		CeGuiString prefix = name;
-		mContentWindow = AbstractWindow::loadWindow("itemicondragcontainer.xml", prefix);
 
-		for (size_t idx = 0; idx < mContentWindow->getChildCount(); ++idx)
-		{
-			LOG_MESSAGE(Logger::UI, mContentWindow->getChildAtIdx(idx)->getName());
-		}
 
-		mContentWindow->getChild(name+"ItemIconDragContainer/Icon")
+		mContentWindow->getChild(name+"/Icon")
 			->setProperty("Image", icon);
 
 		mContentWindow->subscribeEvent(
@@ -59,6 +82,6 @@
 			cegui_absdim(item->getSize().first*30),
 			cegui_absdim(item->getSize().second*30)));
 
-		addChildWindow(mContentWindow);
-	}
+
+        }
 }

Modified: rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -1,1535 +1,1498 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h"
-
-#include "MovementControlState.h"
-
-#include <utility>
-
-#include "AbstractMovement.h"
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CommandMapper.h"
-#include "ConfigurationManager.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "CreatureControllerManager.h"
-#include "DebugWindow.h"
-#include "Exception.h"
-#include "GameObjectManager.h"
-#include "InputManager.h"
-#include "Logger.h"
-#include "MeshObject.h"
-#include "MeshAnimation.h"
-#include "MovementControlState.h"
-#include "PhysicsManager.h"
-#include "PhysicsMaterialRaycast.h"
-#include "PhysicalThing.h"
-#include "RulesMessages.h"
-#include "World.h"
-#include "LineSetPrimitive.h"
-#include "WindowFactory.h"
-#include "AnimationManager.h"
-#include "UiSubsystem.h"
-#include "WindowManager.h"
-
-#include <numeric>
-
-using namespace Ogre;
-
-namespace rl {
-
-    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mController(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mNewCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE),
-        mCharPositionsBuffer(20),
-        mCharPositionsBufferIdx(-1),
-        mCharacterOccludedTime(0),
-        mCharacterOccludedFrameCount(0),
-        mLastDistance(0.0f),
-        mTimeOfLastCollision(0.0f),
-        mIsPathfinding (false),
-        mLastReachableBufPos(1),
-        mLastCameraCollision(0)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 0.8f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(
-            mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb = charMesh->getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-
-        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
-            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
-
-        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
-            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        mCombatSelector.setFilter(NULL);
-        delete mSelector.getFilter();
-        mSelector.setFilter(NULL);
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
-        {
-            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        mController = NULL;
-
-        // actors aren't controlled anymore
-        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-        mCameraActor->getPhysicalThing()->freeze();
-        // cam<->Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        // cam<->Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL && go->isHighlighted())
-        {
-            go->setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if (mController == NULL )
-        {
-            mController =
-                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
-        }
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor->getPhysicalThing()->setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID("camera"));
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
-
-        // We also handle cam<->level, cam<->default cam<->char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-
-        mCharacterState.mCurrentMovementState = MOVE_NONE;
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (!isMouseUsedByCegui() )
-        {
-            if (mInvertedMouse)
-                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            else
-                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
-            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
-            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
-        }
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor->getWorldPosition();
-        Quaternion charOri = mCharacterActor->getWorldOrientation();
-        //mCharBody->getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear() && !(mCharacter->getLifeState() & Effect::LS_NO_COMBAT))
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mController != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen->calculateBaseVelocity(baseVelocity) )
-            {
-                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
-                {
-                    Degree baseVel(baseVelocity*360);
-                    if( mViewMode != VM_PNYX_MODE )
-                    {
-                        if (movement & TURN_LEFT)
-                            rotation = elapsedTime * baseVel;
-                        if (movement & TURN_RIGHT)
-                            rotation = -elapsedTime * baseVel;
-                    }
-
-                    // mouse
-                    if( !isMouseUsedByCegui() )
-                    {
-                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                        {
-                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
-                            {
-                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
-                            }
-                        }
-                    }
-                }
-
-
-                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
-                {
-                    // virtual yaw
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        mCamVirtualYaw = mNewCamVirtualYaw;
-                    }
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(45);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(-45);
-                    }
-                    else
-                    {
-                        mNewCamVirtualYaw =Degree(0);
-                    }
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
-                    }
-                }
-
-                if( mViewMode == VM_FIRST_PERSON )
-                {
-                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
-                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
-                    {
-                        mCamVirtualYaw -= Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw <= Degree(-90) )
-                            mCamVirtualYaw = Degree(-90);
-                    }
-                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
-                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
-                    {
-                        mCamVirtualYaw += Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw >= Degree(90) )
-                            mCamVirtualYaw = Degree(90);
-                    }
-                    else
-                    {
-                        if( mCamVirtualYaw > Degree(0) )
-                        {
-                            mCamVirtualYaw -= Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw <= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                        else if( mCamVirtualYaw < Degree(0) )
-                        {
-                            mCamVirtualYaw += Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw >= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                    }
-                }
-            }
-
-
-
-            if( mViewMode != VM_PNYX_MODE )
-            {
-                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
-                {
-                    // move forward or backward if wanted
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    else if( movement & MOVE_BACKWARD )
-                        direction += Vector3::UNIT_Z;
-
-                    mController->setMovement(
-                        CreatureController::MT_HOCHSPRUNG,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_SNEAK )
-                {
-                    Vector3 direction(Vector3::ZERO);
-                    if (movement & MOVE_FORWARD)
-                        direction.z = -1;
-                    else if( movement & MOVE_BACKWARD)
-                        direction.z = 1;
-                    mController->setMovement(
-                        CreatureController::MT_SCHLEICHEN,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_JUMP && 
-                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement & MOVE_FORWARD )
-                    {
-                        type = CreatureController::MT_WEITSPRUNG;
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    }
-                    mController->setMovement(
-                        type,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement & MOVE_FORWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
-                    if( movement & MOVE_RUN_LOCK )
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_RENNEN;
-                        else
-                            type = CreatureController::MT_LAUFEN;
-                    }
-                    else
-                    {
-                        if( movement & MOVE_RUN )
-                            type = CreatureController::MT_GEHEN;
-                        else
-                            type = CreatureController::MT_JOGGEN;
-                    }
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,-1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_BACKWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
-                    if( !(movement & MOVE_RUN) )
-                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                    mController->setMovement(
-                        type,
-                        Vector3(0,0,1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
-                {
-                    Vector3 direction = Vector3::UNIT_X;
-                    if( movement & MOVE_LEFT )
-                        direction = Vector3::NEGATIVE_UNIT_X;
-                    mController->setMovement(
-                        CreatureController::MT_SEITWAERTS_GEHEN,
-                        direction, 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else
-                {
-                    mController->setMovement(
-                        CreatureController::MT_STEHEN, 
-                        Vector3(0,0,0),
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-            }
-            else // VM_PNYX_MODE
-            {
-                // turn to the direction entered
-                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
-                {
-                    // direction to turn to
-                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
-                    Degree yaw(0);
-                    switch(direction)
-                    {
-                    case MOVE_FORWARD:
-                        yaw = Degree(0);
-                        break;
-                    case MOVE_FORWARD | MOVE_LEFT:
-                        yaw = Degree(45);
-                        break;
-                    case MOVE_FORWARD | MOVE_RIGHT:
-                        yaw = Degree(-45);
-                        break;
-                    case MOVE_RIGHT:
-                        yaw = Degree(-90);
-                        break;
-                    case MOVE_LEFT:
-                        yaw = Degree(90);
-                        break;
-                    case MOVE_BACKWARD:
-                        yaw = Degree(180);
-                        break;
-                    case MOVE_BACKWARD | MOVE_LEFT:
-                        yaw = Degree(-225);
-                        break;
-                    case MOVE_BACKWARD | MOVE_RIGHT:
-                        yaw = Degree(225);
-                        break;
-                    default:
-                        break;
-                    }
-                    yaw+=mCamYaw;
-
-                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else
-                    {
-                        if( movement & MOVE_JUMP )
-                            type = CreatureController::MT_WEITSPRUNG;
-                        else
-                        {
-                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
-                            {
-                            case MOVE_RUN:
-                                type = CreatureController::MT_GEHEN;
-                                break;
-                            case MOVE_RUN_LOCK:
-                                type = CreatureController::MT_LAUFEN;
-                                break;
-                            case MOVE_RUN | MOVE_RUN_LOCK:
-                                type = CreatureController::MT_RENNEN;
-                                break;
-                            default:
-                                break;
-                            }
-                        }
-                    }
-
-
-                    mController->setMovement(
-                        type,
-                        Vector3::NEGATIVE_UNIT_Z,
-                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
-                }
-                else
-                {
-                    // don't move
-                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
-                    if( movement & MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else if( movement & MOVE_JUMP )
-                        type = CreatureController::MT_HOCHSPRUNG;
-                    mController->setMovement(
-                        type,
-                        Vector3::ZERO,
-                        Vector3::ZERO);
-                }
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        if ( !isMouseUsedByCegui() )
-        {
-            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
-            if (mDesiredDistance < mDistanceRange.first)
-            {
-                mDesiredDistance = mDistanceRange.first;
-            }
-            if (mDesiredDistance > mDistanceRange.second)
-            {
-                mDesiredDistance = mDistanceRange.second;
-            }
-
-            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-            {
-                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
-
-                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
-                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
-            }
-        }
-
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        // Kamera-Gr???e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-        AxisAlignedBox aabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
- 
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode->lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-           cameraNode->lookAt(
-                charPos
-                + charOri * /* virtualCamOri * */  mLookAtOffset
-                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-            Real dist = (mCameraActor->getPosition() - charPos).length();
-            cameraNode->lookAt(
-                charPos
-                + camOri * virtualCamOri * mLookAtOffset
-                + camOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody->getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody->getCollision(), camOri, camPos,
-                    mCharBody->getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor->setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor->setVisible(true);
-            }
-        }
-        mCameraActor->setOrientation(cameraNode->getOrientation());
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to CreatureController(Manager)
-    int MovementControlState::userProcess()
-    {
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        // test if this is cam-player-collide
-        if( ( m_body0 == mCamBody && m_body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
-            ( m_body1 == mCamBody && m_body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
-        {
-            return 0;
-        }
-
-        setContactSoftness(0.8f);
-        setContactElasticity(0.0f);
-        mLastCameraCollision = 0;
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to CreatureController
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world->getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to CreatureController?
-        SceneNode* node = mCharacterActor->_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node->getPosition();
-        Quaternion egal;
-        mCamBody->getPositionOrientation(bodpos,egal);
-        ss
-            << "scene node : " << playpos << std::endl
-            << "player velocity : " << -mController->getVelocity().z << std::endl
-            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
-            << "camera posder : " << static_cast<Camera*>(
-                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
-            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
-            << "camera pos : " << bodpos << std::endl
-            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
-            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
-    {
-        mLastCameraCollision += timestep;
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-
-        // Ringbuffer mit Positionen des Characters
-        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
-        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
-
-
-        // Kamera-Gr???e beziehen
-        CameraObject* ogreCam = static_cast<CameraObject*>(
-            mCameraActor->getControlledObject());
-        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr???e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr???e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast->execute(
-                world,
-                &materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
-            {
-                mCharacterOccludedTime += timestep;
-                mCharacterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                mCharacterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Groesse der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            // gibt an, ob schon gebufferte Daten fuer den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
-                // und durch "Geraden" miteinander verbunden werden koennen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = mCharPositionsBuffer.size();
-
-                if( !mIsPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta < buffSize )
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta >= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
-                        mIsPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    mLastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    mLastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                mIsPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody->getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody->getMassMatrix(mass, inertia);
-
-            //mCamBody->setPositionOrientation(newCamPos, camOri);
-            mCamBody->setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody->setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
-        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
-        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_PNYX_MODE)
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr???e beziehen
-            CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-            AxisAlignedBox aabb = ogreCam->getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody->getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i < 6; i++ )
-            {
-                RaycastInfo info = mRaycast->execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody && info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() < diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() < radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            if( CollisionFound )
-                mTimeOfLastCollision = 0.0f;
-            else
-                mTimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody->getPositionOrientation(camPos, camOri);
-
-            if( slowlyMoveBackward &&
-                desiredDistance > mLastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
-                {
-                    newDistance = mLastDistance;
-                }
-                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = mLastDistance;
-
-                if( newDistance > desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                mLastDistance = newDistance;
-            }
-            else
-                mLastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i < end; ++i)
-        {
-            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
-            if (creature &&
-				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
-				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if ( isMouseUsedByCegui() )
-            return;
-
-        //InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL && oldGo != newGo)
-        {
-            oldGo->setHighlighted(false);
-        }
-
-        if (newGo != NULL && newGo != oldGo)
-        {
-            newGo->setHighlighted(true);
-        }
-/*
-        // Optionen anzeigen
-        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
-        {
-            newGo->doDefaultAction(mCharacter, NULL);
-        }
-*/
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
-        }
-        catch(...)
-        {
-            aabb = charMesh->getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
-            resetCamera();
-        }
-        else if(mode == VM_FREE_CAMERA)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
-            resetCamera();
-        }
-        else // mode == VM_PNYX_MODE
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.5;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr???e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
-        aab = mesh->getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh->getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr???e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else if(getViewMode() == VM_FREE_CAMERA)
-            setViewMode(VM_PNYX_MODE);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        mCamVirtualYaw = Degree(0);
-        mNewCamVirtualYaw = Degree(0);
-        mLastCameraCollision = 0;
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor->setVisible(false);
-        else
-            mCharacterActor->setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, "Camera resetted.");
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
-            // First see, if a control state action is defined
-	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
-            if (command == "")
-            {
-                // No. So try global actions.
-                command = mCommandMapper->getGlobalAction(code);
-            }
-            else if (command == "freeflight_mode")
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                retval = true;
-            }
-            else if (command == "reset_camera")
-            {
-                resetCamera();
-                retval = true;
-            }
-            else if (command == "toggle_view_mode")
-            {
-                toggleViewMode();
-                retval = true;
-            }
-            else if( startAction(command, mCharacter) )
-                retval = true;
-
-
-
-            if( !retval )
-            {
-                int movement = mCommandMapper->getMovement(evt.key);
-
-                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
-                {
-                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-                    movement &= ~MOVE_RUN_LOCK;
-                    retval = true;
-                }
-
-                if (movement != MOVE_NONE)
-                {
-                    mCharacterState.mCurrentMovementState |= movement;
-                    retval = true;
-                }
-            }
-        }
-
-
-        if( ControlState::keyPressed(evt, handled || retval ) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper->getMovement(evt.key);
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, retval) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-/*
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-*/
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-        // default action und action-selektor, falls object selected
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-        if( newGo != NULL && !isMouseUsedByCegui() )
-        {
-            if( id == OIS::MB_Left )
-            {
-                if( newGo->getDefaultAction(mCharacter) != NULL )
-                {
-                    newGo->doDefaultAction(mCharacter, NULL);
-                    handled = true;
-                }
-            }
-            else if( id == OIS::MB_Right )
-            {
-                WindowFactory::getSingleton().showActionChoice(newGo);
-                handled = true;
-            }
-        }
-
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
-            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode->getParent() == NULL)
-        {
-            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        lineSet->clear();
-        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-    bool MovementControlState::updateAfterGameObjectLoading()
-    {
-        resume(); //saving/loading only possible in movement state
-        //// We want to check for visibility from char's POV.
-        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mSelector.track(mCharacter);
-        //mSelector.setRadius(3.0);
-
-        //// Same for combat selector
-        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mCombatSelector.track(mCharacter);
-        //mCombatSelector.setRadius(10.0);
-
-        return false;
-    }
-
-    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
-    {
-        if(mSelector.getFirstSelectedObject())
-        {
-            mSelector.getFirstSelectedObject()->setHighlighted(false);
-        }
-
-        pause(); //saving/loading only possible in movement state
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "MovementControlState.h"
+
+#include <utility>
+
+#include "AbstractMovement.h"
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
+#include "CommandMapper.h"
+#include "ConfigurationManager.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "CreatureControllerManager.h"
+#include "DebugWindow.h"
+#include "Exception.h"
+#include "GameObjectManager.h"
+#include "InputManager.h"
+#include "Logger.h"
+#include "MeshObject.h"
+#include "MeshAnimation.h"
+#include "MovementControlState.h"
+#include "PhysicsManager.h"
+#include "PhysicsMaterialRaycast.h"
+#include "PhysicalThing.h"
+#include "RulesMessages.h"
+#include "World.h"
+#include "LineSetPrimitive.h"
+#include "WindowFactory.h"
+#include "AnimationManager.h"
+#include "UiSubsystem.h"
+#include "WindowManager.h"
+
+#include <numeric>
+
+using namespace Ogre;
+
+namespace rl {
+
+    Ogre::String MovementControlState::msDebugWindowPageName = "MovementControlState";
+
+    MovementControlState::CharacterState::CharacterState()
+        :
+        mCurrentMovementState(MOVE_NONE),
+        mLastMovementState(MOVE_NONE)
+    {
+    }
+
+    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
+        mController(NULL),
+        mCharacterState(),
+        mDesiredDistance(2.00),
+        mDistanceRange(0.60, 7.00),
+        mCamYaw(0),
+        mCamVirtualYaw(0),
+        mNewCamVirtualYaw(0),
+        mPitch(20),
+        mRoll(0),
+        mPitchRange(Degree(-75), Degree(85)),
+        mLinearSpringK(400.0f),
+        mLinearDampingK(Math::NEG_INFINITY),
+        mCamMoveAwayVelocity(4.0f),
+        mCamMoveAwayStartTime(0.25f),
+        mCamMoveAwayRange(8.0f),
+        mLookAtOffset(),
+        mRotationSpeed(Degree(120.0f)),
+        mMouseSensitivity(4.0f),
+        mViewMode(VM_THIRD_PERSON),
+        mRaycast(new PhysicsMaterialRaycast()),
+        mConvexcast(new PhysicsMaterialConvexcast()),
+        mCameraCastCollision(NULL),
+        mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
+        mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
+            QUERYFLAG_CREATURE),
+        mCharPositionsBuffer(100),
+        mCharPositionsBufferIdx(-1),
+        mCharacterOccludedTime(0),
+        mCharacterOccludedFrameCount(0),
+        mLastDistance(0.0f),
+        mTimeOfLastCollision(0.0f),
+        mIsPathfinding (false),
+        mLastReachableBufPos(1),
+        mLastCameraCollision(0)
+    {
+        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
+
+
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting("Input", "Mouse Sensitivity");
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting("Input", "Mouse Invert");
+
+        // The relationCoefficient determines the relation between spring accel in target direction
+        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
+        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
+        // in a damped ozillation before reaching equilibrium.
+        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
+        Real relationCoefficient = 0.8f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+
+        // Offset for the look at point,
+        // so the cam does look at the characters head instead of the feet.
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(
+            mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb = charMesh->getDefaultSize();
+
+        // this will be recalculated in calculateOptimalCameraPosition
+        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
+
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mCombatSelector.setFilter(filter);
+
+        mSelector.setFilter(new InSceneSelectionFilter());
+
+        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
+            boost::bind(&MovementControlState::updateAfterGameObjectLoading, this));
+
+        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_SaveGameLoading>(
+            boost::bind(&MovementControlState::beforeLoadingSaveGame, this));
+
+        // Kamera-Groesse beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+            mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+        camRadius *= 1.1f;
+        Vector3 verts[80];
+        int k = 0;
+        for(int i = 0; i < 16; i++)
+        {
+            int n;
+            n = abs(abs(i-8)-8)+1;
+            for(int j = 0; j < n; j++)
+            {
+                Real h = (i-7.5f)/7.5f;
+                Degree angle(360.0f/(n+1)*j);
+                Real rad = Math::Sqrt(1-h*h);
+                verts[k++] = camRadius*Vector3(rad*Math::Cos(angle),rad*Math::Sin(angle),h);
+            }
+        }
+        //! TODO: remove this workaround (newton-bug: "spheres don't cast"!)
+        mCameraCastCollision = new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80);
+        //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody->getWorld(), Vector3::UNIT_SCALE * camRadius);
+    }
+
+    //------------------------------------------------------------------------
+    MovementControlState::~MovementControlState()
+    {
+        delete mCombatSelector.getFilter();
+        mCombatSelector.setFilter(NULL);
+        delete mSelector.getFilter();
+        mSelector.setFilter(NULL);
+        delete mRaycast;
+        delete mConvexcast;
+        delete mCameraCastCollision;
+
+        if (DebugWindow::getSingletonPtr())
+        {
+            DebugWindow::getSingletonPtr()->unregisterPage(msDebugWindowPageName);
+        }
+
+        // Remove debug scene node from character node, if debugview was used.
+        if (mSceneNode != NULL && mSceneNode->getParent() != NULL)
+        {
+            mCharacterActor->_getSceneNode()->removeChild(mSceneNode);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::pause()
+    {
+        mController = NULL;
+
+        // actors aren't controlled anymore
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
+        // cam<->Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        // cam<->Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+
+
+        // Unhighlight selected object, if any.
+        GameObject* go = mSelector.getFirstSelectedObject();
+        if (go != NULL && go->isHighlighted())
+        {
+            go->setHighlighted(false);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resume()
+    {
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
+        // We want to check for visibility from char's POV.
+        mSelector.setCheckVisibility(true, mCharacter);
+        mSelector.track(mCharacter);
+        mSelector.setRadius(3.0);
+
+        // Same for combat selector
+        mCombatSelector.setCheckVisibility(true, mCharacter);
+        mCombatSelector.track(mCharacter);
+        mCombatSelector.setRadius(10.0);
+
+
+        // control camera
+        mCameraActor->getPhysicalThing()->setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
+
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultSoftness(0.8f);
+        mat_pair->setDefaultElasticity(0.4f);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultSoftness(0.8f);
+        mat_pair->setDefaultElasticity(0.4f);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultSoftness(0.8f);
+        mat_pair->setDefaultElasticity(0.4f);
+
+        mCharacterState.mCurrentMovementState = MOVE_NONE;
+
+        setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::run(Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        updateCharacter(elapsedTime);
+        updateCameraLookAt(elapsedTime);
+        updateSelection();
+
+
+
+        // camera pitch
+        if (!isMouseUsedByCegui() )
+        {
+            if (mInvertedMouse)
+                mPitch -= 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            else
+                mPitch += 0.5 * mMouseSensitivity * Degree(im->getMouseRelativeY() / 10);
+            if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
+            if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
+        }
+
+
+        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
+
+        if (isEnemyNear() && !(mCharacter->getLifeState() & Effect::LS_NO_COMBAT))
+        {
+            InputManager::getSingleton().pushControlState(CST_COMBAT);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+        if( mController != NULL )
+        {
+            int movement = mCharacterState.mCurrentMovementState;
+            Degree rotation(0);
+
+            AbstractMovement *drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
+            Real baseVelocity = 0;
+            if( drehen->calculateBaseVelocity(baseVelocity) )
+            {
+                if( !(movement & MOVE_RIGHT || movement & MOVE_LEFT) )
+                {
+                    Degree baseVel(baseVelocity*360);
+                    if( mViewMode != VM_PNYX_MODE )
+                    {
+                        if (movement & TURN_LEFT)
+                            rotation = elapsedTime * baseVel;
+                        if (movement & TURN_RIGHT)
+                            rotation = -elapsedTime * baseVel;
+                    }
+
+                    // mouse
+                    if( !isMouseUsedByCegui() )
+                    {
+                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                        {
+                            if( !(movement & TURN_LEFT || movement & TURN_RIGHT) )
+                            {
+                                rotation = -mMouseSensitivity/3.0f * Degree(im->getMouseRelativeX())/200.0 * baseVel;
+                            }
+                        }
+                    }
+                }
+
+
+                if( mViewMode != VM_PNYX_MODE  && mViewMode != VM_FIRST_PERSON )
+                {
+                    // virtual yaw
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        mCamVirtualYaw = mNewCamVirtualYaw;
+                    }
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(45);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(-45);
+                    }
+                    else
+                    {
+                        mNewCamVirtualYaw =Degree(0);
+                    }
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
+                    }
+                }
+
+                if( mViewMode == VM_FIRST_PERSON )
+                {
+                    if( ((movement & MOVE_FORWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) ||
+                        ((movement & MOVE_BACKWARD) && (movement & MOVE_RIGHT) && !(movement & MOVE_LEFT)) )
+                    {
+                        mCamVirtualYaw -= Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw <= Degree(-90) )
+                            mCamVirtualYaw = Degree(-90);
+                    }
+                    else if( ((movement & MOVE_FORWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) ||
+                             ((movement & MOVE_BACKWARD) && (movement & MOVE_LEFT) && !(movement & MOVE_RIGHT)) )
+                    {
+                        mCamVirtualYaw += Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw >= Degree(90) )
+                            mCamVirtualYaw = Degree(90);
+                    }
+                    else
+                    {
+                        if( mCamVirtualYaw > Degree(0) )
+                        {
+                            mCamVirtualYaw -= Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw <= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                        else if( mCamVirtualYaw < Degree(0) )
+                        {
+                            mCamVirtualYaw += Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw >= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                    }
+                }
+            }
+
+
+
+            if( mViewMode != VM_PNYX_MODE )
+            {
+                if( mController->getMovementId() == CreatureController::MT_HOCHSPRUNG )
+                {
+                    // move forward or backward if wanted
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    else if( movement & MOVE_BACKWARD )
+                        direction += Vector3::UNIT_Z;
+
+                    mController->setMovement(
+                        CreatureController::MT_HOCHSPRUNG,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_SNEAK )
+                {
+                    Vector3 direction(Vector3::ZERO);
+                    if (movement & MOVE_FORWARD)
+                        direction.z = -1;
+                    else if( movement & MOVE_BACKWARD)
+                        direction.z = 1;
+                    mController->setMovement(
+                        CreatureController::MT_SCHLEICHEN,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_JUMP && 
+                    mController->getMovementFromId(CreatureController::MT_HOCHSPRUNG)->isPossible() )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement & MOVE_FORWARD )
+                    {
+                        type = CreatureController::MT_WEITSPRUNG;
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    }
+                    mController->setMovement(
+                        type,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement & MOVE_FORWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
+                    if( movement & MOVE_RUN_LOCK )
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_RENNEN;
+                        else
+                            type = CreatureController::MT_LAUFEN;
+                    }
+                    else
+                    {
+                        if( movement & MOVE_RUN )
+                            type = CreatureController::MT_GEHEN;
+                        else
+                            type = CreatureController::MT_JOGGEN;
+                    }
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,-1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_BACKWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
+                    if( !(movement & MOVE_RUN) )
+                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
+                    mController->setMovement(
+                        type,
+                        Vector3(0,0,1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement & MOVE_LEFT || movement & MOVE_RIGHT)
+                {
+                    Vector3 direction = Vector3::UNIT_X;
+                    if( movement & MOVE_LEFT )
+                        direction = Vector3::NEGATIVE_UNIT_X;
+                    mController->setMovement(
+                        CreatureController::MT_SEITWAERTS_GEHEN,
+                        direction, 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else
+                {
+                    mController->setMovement(
+                        CreatureController::MT_STEHEN, 
+                        Vector3(0,0,0),
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+            }
+            else // VM_PNYX_MODE
+            {
+                // turn to the direction entered
+                if( movement & MOVE_FORWARD || movement & MOVE_BACKWARD || movement & MOVE_LEFT || movement & MOVE_RIGHT )
+                {
+                    // direction to turn to
+                    int direction = movement & (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
+                    Degree yaw(0);
+                    switch(direction)
+                    {
+                    case MOVE_FORWARD:
+                        yaw = Degree(0);
+                        break;
+                    case MOVE_FORWARD | MOVE_LEFT:
+                        yaw = Degree(45);
+                        break;
+                    case MOVE_FORWARD | MOVE_RIGHT:
+                        yaw = Degree(-45);
+                        break;
+                    case MOVE_RIGHT:
+                        yaw = Degree(-90);
+                        break;
+                    case MOVE_LEFT:
+                        yaw = Degree(90);
+                        break;
+                    case MOVE_BACKWARD:
+                        yaw = Degree(180);
+                        break;
+                    case MOVE_BACKWARD | MOVE_LEFT:
+                        yaw = Degree(-225);
+                        break;
+                    case MOVE_BACKWARD | MOVE_RIGHT:
+                        yaw = Degree(225);
+                        break;
+                    default:
+                        break;
+                    }
+                    yaw+=mCamYaw;
+
+                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else
+                    {
+                        if( movement & MOVE_JUMP )
+                            type = CreatureController::MT_WEITSPRUNG;
+                        else
+                        {
+                            switch( movement & (MOVE_RUN | MOVE_RUN_LOCK) )
+                            {
+                            case MOVE_RUN:
+                                type = CreatureController::MT_GEHEN;
+                                break;
+                            case MOVE_RUN_LOCK:
+                                type = CreatureController::MT_LAUFEN;
+                                break;
+                            case MOVE_RUN | MOVE_RUN_LOCK:
+                                type = CreatureController::MT_RENNEN;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+
+                    mController->setMovement(
+                        type,
+                        Vector3::NEGATIVE_UNIT_Z,
+                        Vector3::UNIT_Y * (yaw-mController->getYaw()).valueRadians());
+                }
+                else
+                {
+                    // don't move
+                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
+                    if( movement & MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else if( movement & MOVE_JUMP )
+                        type = CreatureController::MT_HOCHSPRUNG;
+                    mController->setMovement(
+                        type,
+                        Vector3::ZERO,
+                        Vector3::ZERO);
+                }
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        // camera position (distance)
+        if ( !isMouseUsedByCegui() )
+        {
+            mDesiredDistance -= im->getMouseRelativeZ() * 0.002;
+            if (mDesiredDistance < mDistanceRange.first)
+            {
+                mDesiredDistance = mDistanceRange.first;
+            }
+            if (mDesiredDistance > mDistanceRange.second)
+            {
+                mDesiredDistance = mDistanceRange.second;
+            }
+
+            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+            {
+                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im->getMouseRelativeX() / 15);
+
+                while (mCamYaw.valueDegrees() > 360.0f) mCamYaw -= Degree(360.0f);
+                while (mCamYaw.valueDegrees() < -360.0f) mCamYaw += Degree(360.0f);
+            }
+        }
+
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+        Vector3 charPos;
+        charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        // Kamera-Gr???e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+        AxisAlignedBox aabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
+ 
+
+        if( mViewMode == VM_FIRST_PERSON)
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
+            cameraNode->lookAt(
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
+                Node::TS_WORLD);
+        }
+        else if( mViewMode == VM_THIRD_PERSON )
+        {
+           cameraNode->lookAt(
+                charPos
+                + charOri * /* virtualCamOri * */  mLookAtOffset
+                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
+                Node::TS_WORLD);
+
+        }
+        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+            Real dist = (mCameraActor->getPosition() - charPos).length();
+            cameraNode->lookAt(
+                charPos
+                + camOri * virtualCamOri * mLookAtOffset
+                + camOri * (-Vector3::UNIT_Z*radius),
+                Node::TS_WORLD);
+        }
+
+
+        // Character ausblenden, wenn Kamera zu nah.
+        if( mViewMode != VM_FIRST_PERSON )
+        {
+            // here the real charOri of the object is needed
+            Vector3 charPos;
+            Quaternion charOri;
+            mCharBody->getPositionOrientation(charPos, charOri);
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+            Vector3 camPoint, charPoint, normal;
+            int collisionPoints =
+                OgreNewt::CollisionTools::CollisionClosestPoint(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    mCamBody->getCollision(), camOri, camPos,
+                    mCharBody->getCollision(), charOri, charPos,
+                    camPoint, charPoint, normal, 0 // set threadindex to 0, I hope this is ok!
+                    );
+            if( collisionPoints == 0 )
+                mCharacterActor->setVisible(false);
+            else
+            {
+                // eigentlich muss hier transparent gemacht werden!
+                mCharacterActor->setVisible(true);
+            }
+        }
+        mCameraActor->setOrientation(cameraNode->getOrientation());
+    }
+
+
+    int MovementControlState::onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex )
+    {
+        if( mViewMode == VM_FIRST_PERSON )
+            return 0;
+
+        // test if this is cam-player-collide
+        if( ( body0 == mCamBody && body1 == mCharacterActor->getPhysicalThing()->_getBody() ) ||
+            ( body1 == mCamBody && body0 == mCharacterActor->getPhysicalThing()->_getBody() ) )
+        {
+            return 0;
+        }
+
+        return 1;
+    }
+
+    void MovementControlState::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int)
+    {
+        mLastCameraCollision = 0;
+    }
+
+    //------------------------------------------------------------------------
+    // character callback moved to CreatureController
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+        calculateCamera(timestep);
+
+
+
+
+        ///@todo move to CreatureController?
+        SceneNode* node = mCharacterActor->_getSceneNode();
+        std::ostringstream ss;
+        Vector3 bodpos, playpos = node->getPosition();
+        Quaternion egal;
+        mCamBody->getPositionOrientation(bodpos,egal);
+        ss
+            << "scene node : " << playpos << std::endl
+            << "player velocity : " << -mController->getVelocity().z << std::endl
+            << "player orientation : " << mController->getCreature()->getActor()->getOrientation() << std::endl
+            << "camera posder : " << static_cast<Camera*>(
+                mCameraActor->_getMovableObject())->getDerivedPosition() << std::endl
+            << "camera orientation : " << mCameraActor->getWorldOrientation() << std::endl
+            << "camera pos : " << bodpos << std::endl
+            << "camera distance : " << mLastDistance << " ( " << mDesiredDistance << " ) " << std::endl
+            << "is airborne: " << (mController->getAbstractLocation() == CreatureController::AL_AIRBORNE ? "true" : "false") << std::endl;
+
+        LOG_DEBUG(Logger::UI, ss.str());
+        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::calculateCamera(const Ogre::Real& timestep)
+    {
+        mLastCameraCollision += timestep;
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+
+
+        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
+        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
+
+        // Ringbuffer mit Positionen des Characters
+        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
+        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
+
+
+        // Kamera-Gr???e beziehen
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+            mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+
+            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
+            // so zur optimalen kommen
+            const OgreNewt::MaterialID *charMaterialId = mCharBody->getMaterialGroupID();
+            const OgreNewt::MaterialID *camMaterialId = mCamBody->getMaterialGroupID();
+            PhysicsMaterialRaycast::MaterialVector materialVector;
+            materialVector.push_back(charMaterialId);
+            materialVector.push_back(camMaterialId);
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 normToOptCamPos = (optimalCamPos - charPos);
+            normToOptCamPos.normalise();
+
+
+
+            RaycastInfo infoCastOptPos = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos + camRadius * normToOptCamPos, // Gr???e der Kamera einbeziehen
+                optimalCamPos + camRadius * normToOptCamPos,
+                true); // Gr???e der Kamera einbeziehen
+
+            RaycastInfo infoCastChar = mRaycast->execute(
+                world,
+                &materialVector,
+                camPos,
+                charPos,
+                true);
+
+
+            // reset the camera if the character is to far away or cannot be seen any more (Raycast)
+            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
+            if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
+            {
+                mCharacterOccludedTime += timestep;
+                mCharacterOccludedFrameCount++;
+
+                // falls zu lange, Kamera resetten:
+                if( mCharacterOccludedTime > 0.250f && mCharacterOccludedFrameCount > 5 )
+                {
+                    resetCamera();
+                    return;
+                }
+
+            }
+            else
+            {
+                mCharacterOccludedTime = 0;
+                mCharacterOccludedFrameCount = 0;
+            }
+
+            if( infoCastOptPos.mBody && !infoCastChar.mBody )
+            {
+                // andere Position ermitteln, die ziwschen optimaler und Character liegt
+                // und erreichbar ist
+                Real lenToOptCamPos = (optimalCamPos - charPos).length();
+
+                RaycastInfo infoCastNewPos;
+                Real delta = lenToOptCamPos/2.0f;
+                Vector3 temp = charPos + delta * normToOptCamPos;
+                // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
+                {
+                    infoCastNewPos = mRaycast->execute(
+                        world,
+                        &materialVector,
+                        camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
+                        temp,
+                        true);
+                    delta = delta/2.0f;
+                    if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
+                    {
+                        temp = temp - delta * normToOptCamPos;
+                    }
+                    else // kein Hindernis gefunden, weiter von Char weg
+                    {
+                        temp = temp + delta * normToOptCamPos;
+                    }
+                }
+
+                // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
+                temp = temp - 0.05 * normToOptCamPos;
+                // Groesse der Kamera einbeziehen
+                optimalCamPos = temp - camRadius * normToOptCamPos;
+                // so ab hier kann ganz normal weiter gerechnet werden!
+            }
+
+
+            // gibt an, ob schon gebufferte Daten fuer den
+            // neuen Weg existieren und dort weitergemacht werden kann,
+            // oder ob neu nach einem Weg gesucht werden muss!
+            if( infoCastChar.mBody && infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
+            {
+                // anderen Weg finden
+                // hier werden erstmal nur alte Player-Positionen betrachtet
+                // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
+                // und durch "Geraden" miteinander verbunden werden koennen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fluessig
+                // und weich (keine scharfen Kurven) erscheinen
+
+                size_t buffSize = mCharPositionsBuffer.size();
+
+                if( !mIsPathfinding )
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte jetzt anfangen!");
+
+
+                    // letzte Character - Position suchen, die erreichbar ist...
+                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
+                    unsigned int delta = 1;
+                    while ( delta < buffSize )
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( !info.mBody )
+                            break;
+                        delta++;
+                    }
+                    if( delta >= buffSize )
+                    {
+                        // is wohl irgendwas schiefgegangen!
+                        LOG_MESSAGE(Logger::UI, " Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! ");
+                        mIsPathfinding = false;
+                        resetCamera();
+                        return;
+                    }
+                    mLastReachableBufPos = delta;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                else
+                {
+                    LOG_DEBUG(Logger::UI, " Pathfinding der Kamera sollte weitergefhrt werden!");
+
+
+                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
+                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
+                    while ( delta > 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
+                    {
+                        RaycastInfo info = mRaycast->execute(
+                            world,
+                            &materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( info.mBody )
+                            break;
+                        delta--;
+                    }
+                    mLastReachableBufPos = delta + 1;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+            }
+            else
+            {
+                mIsPathfinding = false;
+            }
+
+            Vector3 diff = camPos - optimalCamPos;
+
+            Vector3 cameraVelocity;
+            cameraVelocity = mCamBody->getVelocity();
+            // spring velocity
+            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
+
+            // get the camera mass
+            Real mass;
+            Vector3 inertia;
+            mCamBody->getMassMatrix(mass, inertia);
+
+            //mCamBody->setPositionOrientation(newCamPos, camOri);
+            mCamBody->setForce(springAcc * mass);
+        }
+        else if( mViewMode == VM_FIRST_PERSON )
+        {
+            mCamBody->setPositionOrientation(optimalCamPos, camOri);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &timestep)
+    {
+        Vector3 targetCamPos;
+
+        Vector3 charPos = mCharacter->getActor()->getWorldPosition();
+        //Quaternion charOri = mCharacter->getActor()->getWorldOrientation();
+        Quaternion charOri (mController->getYaw(), Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+        // get camera size
+        CameraObject* ogreCam = static_cast<CameraObject*>(
+                mCameraActor->getControlledObject());
+        AxisAlignedBox camAabb = ogreCam->getDefaultSize();
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+            charPos = charPos + charOri * mLookAtOffset;
+            if(mViewMode == VM_PNYX_MODE)
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else if(mViewMode == VM_THIRD_PERSON)
+            {
+                targetCamPos =
+                    charPos
+                    + charOri * virtualCamOri * Vector3(
+                                    0,
+                                    Math::Sin(mPitch) * mDesiredDistance,
+                                    Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + charOri * camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+
+            Vector3 diff = targetCamPos - charPos;
+
+            // Convexcast
+            PhysicsMaterialConvexcast::MaterialVector materialVector;
+            materialVector.push_back( mCharBody->getMaterialGroupID() );
+            materialVector.push_back( mCamBody->getMaterialGroupID() );
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            ConvexcastInfo info = mConvexcast->execute(
+                    world,
+                    &materialVector,
+                    mCameraCastCollision,
+                    charPos,
+                    Quaternion::IDENTITY,
+                    targetCamPos,
+                    true);
+
+            bool CollisionFound = false;
+            if( info.mBody )
+            {
+                CollisionFound = true;
+                Real hitBodyVel = info.mBody->getVelocity().dotProduct(diff.normalisedCopy());
+                hitBodyVel = std::min(0.0f, hitBodyVel); // if the body moves, try to avoid it
+                Real dist = std::max(info.mDistance  + (hitBodyVel*timestep - 0.01)/diff.length(), 0.0);
+                diff *= dist;
+
+                mLastCameraCollision = 0;
+            }
+
+
+            // Langsames Entfernen vom Char:
+            if( CollisionFound )
+                mTimeOfLastCollision = 0.0f;
+            else
+                mTimeOfLastCollision += timestep;
+
+
+            Real desiredDistance = diff.length();
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody->getPositionOrientation(camPos, camOri);
+
+            if( slowlyMoveBackward &&
+                desiredDistance > mLastDistance )
+            {
+
+                diff.normalise();
+                Real newDistance;
+                Vector3 actDiff = camPos - charPos;
+                actDiff.normalise();
+
+                if( mLastCameraCollision <= 0.5 ) // there was a cam collision 0.5 seconds ago
+                {
+                    newDistance = mLastDistance;
+                }
+                else if( mTimeOfLastCollision > mCamMoveAwayStartTime ||
+                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
+                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
+                else
+                    newDistance = mLastDistance;
+
+                if( newDistance > desiredDistance )
+                    newDistance = desiredDistance;
+
+                diff = diff*newDistance;
+
+                mLastDistance = newDistance;
+            }
+            else
+                mLastDistance = desiredDistance;
+
+
+            targetCamPos = charPos + diff;
+        }
+        else  // FIRST_PERSON
+        {
+            // determine the optimal target position of the camera
+            targetCamPos =
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * virtualCamOri * Vector3(
+                                0,
+                                Math::Sin(mPitch) * mDesiredDistance,
+                                Math::Cos(mPitch) * mDesiredDistance);
+        }
+
+
+        return targetCamPos;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::isEnemyNear()
+    {
+        mCombatSelector.updateSelection();
+
+        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
+        for (size_t i = 0, end = gov.size(); i < end; ++i)
+        {
+            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
+            if (creature &&
+				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
+				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)
+            {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateSelection()
+    {
+        if ( isMouseUsedByCegui() )
+            return;
+
+        InputManager* im = InputManager::getSingletonPtr();
+
+        GameObject* oldGo = mSelector.getFirstSelectedObject();
+
+        mSelector.updateSelection();
+
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+
+        if (oldGo != NULL && oldGo != newGo)
+        {
+            oldGo->setHighlighted(false);
+        }
+
+        if (newGo != NULL && newGo != oldGo)
+        {
+            newGo->setHighlighted(true);
+        }
+/*
+        // Optionen anzeigen
+        if (im->isMouseButtonDown(OIS::MB_Right) && newGo != NULL)
+        {
+            WindowFactory::getSingleton().showActionChoice(newGo);
+        }
+        else if (im->isMouseButtonDown(OIS::MB_Left) && newGo != NULL)
+        {
+            newGo->doDefaultAction(mCharacter, NULL);
+        }
+*/
+    }
+
+
+    void MovementControlState::setViewMode(ViewMode mode)
+    {
+        mViewMode = mode;
+
+        MeshObject* charMesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        AxisAlignedBox aabb;
+        try
+        {
+			aabb = charMesh->getPoseSize(mCharacter->getAnimation("stehen").first);
+        }
+        catch(...)
+        {
+            aabb = charMesh->getDefaultSize();
+        }
+        if (mode == VM_FIRST_PERSON)
+        {
+            mLookAtOffset = Vector3(
+                    0,
+                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
+                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
+            mDistanceRange.first = 0.0;
+            mDistanceRange.second = 0.0;
+            mDesiredDistance = 0.0;
+            mPitchRange.first = Degree(-85);
+            mPitchRange.second = Degree(85);
+            mPitch = 0;
+            LOG_MESSAGE(Logger::UI, "Switch to 1st person view");
+            resetCamera();
+        }
+        else if(mode == VM_THIRD_PERSON)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            LOG_MESSAGE(Logger::UI, "Switch to 3rd person view");
+            resetCamera();
+        }
+        else if(mode == VM_FREE_CAMERA)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to free camera view");
+            resetCamera();
+        }
+        else // mode == VM_PNYX_MODE
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.5;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter->getActor()->getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, "Switch to pnyx mode movementcontroller");
+            resetCamera();
+        }
+    }
+
+    //------------------------------------------------------------------------
+/*
+    // not used at the moment!
+    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
+    {
+        AxisAlignedBox aab;
+        Vector3 size[2];
+        Vector3 interpolatedSize;
+
+
+        // Die Gr???e der beiden Animationen abfragen
+        MeshObject* mesh = dynamic_cast<MeshObject*>(mCharacterActor->getControlledObject());
+        aab = mesh->getPoseSize(actAnim);
+        size[0] = aab.getMaximum() - aab.getMinimum();
+
+        aab = mesh->getPoseSize(newAnim);
+        size[1] = aab.getMaximum() - aab.getMinimum();
+
+        // interpolierte Gr???e (linear) berechnen
+        interpolatedSize = size[0] + factor*(size[1] - size[0]);
+
+        // LookAtOffset berechnen!
+        switch(mViewMode)
+        {
+        case VM_FIRST_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
+            break;
+        case VM_THIRD_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
+            break;
+        case VM_FREE_CAMERA:
+        default:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
+        }
+    }
+*/
+
+    //------------------------------------------------------------------------
+    MovementControlState::ViewMode MovementControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::toggleViewMode()
+    {
+        if (getViewMode() == VM_THIRD_PERSON)
+            setViewMode(VM_FIRST_PERSON);
+        else if(getViewMode() == VM_FIRST_PERSON)
+            setViewMode(VM_FREE_CAMERA);
+        else if(getViewMode() == VM_FREE_CAMERA)
+            setViewMode(VM_PNYX_MODE);
+        else
+            setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resetCamera()
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+        mCamBody->setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
+        mCamVirtualYaw = Degree(0);
+        mNewCamVirtualYaw = Degree(0);
+        mLastCameraCollision = 0;
+        if(mViewMode == VM_FIRST_PERSON)
+            mCharacterActor->setVisible(false);
+        else
+            mCharacterActor->setVisible(true);
+        
+        LOG_MESSAGE(Logger::UI, "Camera resetted.");
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
+            // First see, if a control state action is defined
+	        CeGuiString command = mCommandMapper->getControlStateAction(code, mType);
+            if (command == "")
+            {
+                // No. So try global actions.
+                command = mCommandMapper->getGlobalAction(code);
+            }
+            else if (command == "freeflight_mode")
+            {
+                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
+                retval = true;
+            }
+            else if (command == "reset_camera")
+            {
+                resetCamera();
+                retval = true;
+            }
+            else if (command == "toggle_view_mode")
+            {
+                toggleViewMode();
+                retval = true;
+            }
+            else if( startAction(command, mCharacter) )
+                retval = true;
+
+
+
+            if( !retval )
+            {
+                int movement = mCommandMapper->getMovement(evt.key);
+
+                if (movement & MOVE_RUN_LOCK) // dieses einrasten lassen
+                {
+                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
+                    movement &= ~MOVE_RUN_LOCK;
+                    retval = true;
+                }
+
+                if (movement != MOVE_NONE)
+                {
+                    mCharacterState.mCurrentMovementState |= movement;
+                    retval = true;
+                }
+            }
+        }
+
+
+        if( ControlState::keyPressed(evt, handled || retval ) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper->getMovement(evt.key);
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState &= (~movement | MOVE_RUN_LOCK);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, retval) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+/*
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+*/
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mousePressed(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+        // default action und action-selektor, falls object selected
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+        if( newGo != NULL && !isMouseUsedByCegui() )
+        {
+            if( id == OIS::MB_Left )
+            {
+                if( newGo->getDefaultAction(mCharacter) != NULL )
+                {
+                    newGo->doDefaultAction(mCharacter, NULL);
+                    handled = true;
+                }
+            }
+            else if( id == OIS::MB_Right )
+            {
+                WindowFactory::getSingleton().showActionChoice(newGo);
+                handled = true;
+            }
+        }
+
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im->getModifierCode());
+            return startAction(mCommandMapper->getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    DebugVisualisableFlag MovementControlState::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updatePrimitive()
+    {
+        if (mSceneNode->getParent() == NULL)
+        {
+            mCharacterActor->_getSceneNode()->addChild(mSceneNode);
+        }
+
+        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+        lineSet->clear();
+        lineSet->addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    bool MovementControlState::updateAfterGameObjectLoading()
+    {
+        resume(); //saving/loading only possible in movement state
+        //// We want to check for visibility from char's POV.
+        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mSelector.track(mCharacter);
+        //mSelector.setRadius(3.0);
+
+        //// Same for combat selector
+        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mCombatSelector.track(mCharacter);
+        //mCombatSelector.setRadius(10.0);
+
+        return false;
+    }
+
+    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
+    {
+        if(mSelector.getFirstSelectedObject())
+        {
+            mSelector.getFirstSelectedObject()->setHighlighted(false);
+        }
+
+        pause(); //saving/loading only possible in movement state
+
+        return false;
+    }
+}

Modified: rl/branches/persistence2/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/UiSubsystem.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/UiSubsystem.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -17,9 +17,7 @@
 
 #include "UiSubsystem.h"
 
-#include <CEGUISystem.h>
-#include <CEGUIWindow.h>
-#include <CEGUIWindowManager.h>
+#include <CEGUI.h>
 
 #ifdef __APPLE__
 #   include <OgreCEGUIRenderer/OgreCEGUIRenderer.h>
@@ -39,6 +37,8 @@
 #include "GameLoop.h"
 #include "GameObjectManager.h"
 #include "InputManager.h"
+#include "ItemDescriptionDragContainer.h"
+#include "ItemIconDragContainer.h"
 #include "Logger.h"
 #include "RulesMessages.h"
 #include "ScriptWrapper.h"
@@ -50,6 +50,18 @@
 using namespace Ogre;
 template<> rl::UiSubsystem* Singleton<rl::UiSubsystem>::ms_Singleton = 0;
 
+// this function needs to be in the CEGUI-namespace
+namespace CEGUI{
+    void initializeOwnCeguiWindowFactories()
+    {
+            CEGUI::WindowFactoryManager& wfMgr = CEGUI::WindowFactoryManager::getSingleton();
+            wfMgr.addFactory(&CEGUI_WINDOW_FACTORY(ItemDescriptionDragContainer)); // ohne rl:: davor hier!
+            //wfMgr.addFalagardWindowMapping("ItemDescriptionDragContainer", "CEGUI/ItemDescriptionDragContainer", "", "Falagard/Default");
+            wfMgr.addFactory(&CEGUI_WINDOW_FACTORY(ItemIconDragContainer)); // ohne rl:: davor hier!
+            //wfMgr.addFalagardWindowMapping("ItemIconDragContainer", "CEGUI/ItemIconDragContainer", "", "Falagard/Default");
+    }
+}
+
 namespace rl {
     const char* UiSubsystem::CEGUI_ROOT = "RootWindow";
 
@@ -138,9 +150,14 @@
         sheet->setZOrderingEnabled(true);
         sheet->moveToBack();
         System::getSingleton().setDefaultTooltip("RastullahLook/Tooltip");
+
+        CEGUI::initializeOwnCeguiWindowFactories();
+
         LOG_MESSAGE2(Logger::UI, "CEGUI initialized.",
             "UiSubsystem::initializeUiSubsystem");
 
+
+
         mWindowManager = new WindowManager();
 
         //Initializing InputManager
@@ -149,6 +166,7 @@
             "UiSubsystem::initializeUiSubsystem");
 
         mWindowFactory->initialize();
+        LOG_MESSAGE2(Logger::UI, "WindowFactory initialized.", "UiSubsystem::initializeUiSubsystem");
     }
 
     CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()

Modified: rl/branches/persistence2/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/WindowFactory.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/WindowFactory.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -164,6 +164,8 @@
     void WindowFactory::toggleConsole()
     {
         mConsole->setVisible(!mConsole->isVisible());
+        if( mConsole->isVisible() )
+            mConsole->getWindow()->activate();
     }
 
     void WindowFactory::toggleDebugWindow()

Modified: rl/branches/persistence2/engine/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/WindowFadeJob.cpp	2009-02-11 13:07:32 UTC (rev 4763)
+++ rl/branches/persistence2/engine/ui/src/WindowFadeJob.cpp	2009-02-11 13:24:47 UTC (rev 4764)
@@ -32,7 +32,7 @@
         : Job("", true, true),
         mAbstractWindow(window),
         mCEGUIWindow(window->getWindow()),
-        mItemDragContainer(NULL),
+//        mItemDragContainer(NULL),
         mMode(mode),
         mChangeRate(changeRate),
         mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
@@ -47,7 +47,7 @@
         : Job("", true, true),
         mAbstractWindow(NULL),
         mCEGUIWindow(window),
-        mItemDragContainer(NULL),
+//        mItemDragContainer(NULL),
         mMode(mode),
         mChangeRate(changeRate),
         mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
@@ -57,7 +57,7 @@
         mCEGUIWindow->setVisible(true);
         mCEGUIWindow->setAlpha(mCurrentAlpha);
     }
-
+/*
     WindowFadeJob::WindowFadeJob(ItemDragContainer* window, Mode mode, Real targetAlpha, Real changeRate)
         : Job("", true, true),
         mAbstractWindow(NULL),
@@ -72,7 +72,7 @@
         mCEGUIWindow->setVisible(true);
         mCEGUIWindow->setAlpha(mCurrentAlpha);
     }
-
+*/
     bool WindowFadeJob::execute(Real time)
     {
         mCurrentAlpha += time * mChangeRate * Math::Sign(mTargetAlpha - mCurrentAlpha);
@@ -97,8 +97,8 @@
         {
             if( mAbstractWindow )
                 WindowManager::getSingleton().destroyWindow(mAbstractWindow);
-            else if(mItemDragContainer)
-                delete mItemDragContainer;
+//            else if(mItemDragContainer)
+//                delete mItemDragContainer;
             else
                 CEGUI::WindowManager::getSingleton().destroyWindow(mCEGUIWindow);
         }



From timm at mail.berlios.de  Fri Feb 13 17:24:07 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 13 Feb 2009 17:24:07 +0100
Subject: [Dsa-hl-svn] r4765 - in rl/branches/persistence2/engine: ai core
	core/src rules script ui
Message-ID: <200902131624.n1DGO713021126@sheep.berlios.de>

Author: timm
Date: 2009-02-13 17:23:58 +0100 (Fri, 13 Feb 2009)
New Revision: 4765

Modified:
   rl/branches/persistence2/engine/ai/RlAI2005.vcproj
   rl/branches/persistence2/engine/core/RlCore2005.vcproj
   rl/branches/persistence2/engine/core/src/GameLoop.cpp
   rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
   rl/branches/persistence2/engine/rules/RlRules2005.vcproj
   rl/branches/persistence2/engine/script/RlScript2005.vcproj
   rl/branches/persistence2/engine/ui/RlUI2005.vcproj
Log:
- fixed vs makefiles for windows build with newton v2
- usleep isn't available for windows

Modified: rl/branches/persistence2/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/ai/RlAI2005.vcproj	2009-02-11 13:24:47 UTC (rev 4764)
+++ rl/branches/persistence2/engine/ai/RlAI2005.vcproj	2009-02-13 16:23:58 UTC (rev 4765)
@@ -39,9 +39,9 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="-Zm130"
+				AdditionalOptions="-Zm146"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ois\includes;..\..\dependencies\xerces\include;..\..\dependencies\ogrenew\Dependencies\include"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS;_DEBUG;WIN32;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -76,7 +76,7 @@
 				AdditionalDependencies="OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib xerces-c_2D.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\xerces\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt_ngt\lib\;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlAI.pdb"
@@ -141,7 +141,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="2"

Modified: rl/branches/persistence2/engine/core/RlCore2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-02-11 13:24:47 UTC (rev 4764)
+++ rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-02-13 16:23:58 UTC (rev 4765)
@@ -48,7 +48,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc"
+				AdditionalIncludeDirectories=".\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -90,7 +90,7 @@
 				OutputFile="./lib/$(ConfigurationName)/RlCore.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt_ngt\lib\;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
 				IgnoreDefaultLibraryNames=""
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				GenerateDebugInformation="true"
@@ -679,7 +679,6 @@
 					>
 				</File>
 			</Filter>
-
 			<Filter
 				Name="SaveGame"
 				>

Modified: rl/branches/persistence2/engine/core/src/GameLoop.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameLoop.cpp	2009-02-11 13:24:47 UTC (rev 4764)
+++ rl/branches/persistence2/engine/core/src/GameLoop.cpp	2009-02-13 16:23:58 UTC (rev 4765)
@@ -141,7 +141,7 @@
 
         if( unsmoothedFrameTime < mMinFrameTime*1000 )
         {
-            usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            //usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
             elapsedTime = mTimer->getMilliseconds();
             unsmoothedFrameTime = elapsedTime - mGameTime;
             if( elapsedTime < mGameTime )

Modified: rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-02-11 13:24:47 UTC (rev 4764)
+++ rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-02-13 16:23:58 UTC (rev 4765)
@@ -171,7 +171,7 @@
             if( mDebugMode )
             {
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
-                    "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
+                    "Omega  Force  Torque  NewtonBodyGetSleepState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
                 if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
                 for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
@@ -193,7 +193,7 @@
             if( mDebugMode )
             {
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
-                    "Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  "\
+                    "Omega  Force  Torque  NewtonBodyGetSleepState  NewtonBodyGetAutoFreeze  "\
                     "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
                 for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
                      body != NULL;
@@ -234,8 +234,8 @@
         Vector3 invMass, invIxx, invIyy, invIzz;
         NewtonBodyGetInvMass(body, &invMass.x, &invIxx.x, &invIyy.x, &invIzz.x);
         oss << "\tNewtonBodyLog: " << body << "  " << pos << "  " << orient << "  " << velocity << "  "
-            << omega << "  " << force << "  " << torque << "  " << NewtonBodyGetSleepingState(body)
-            << "  " << NewtonBodyGetAutoFreeze(body) << "  " << NewtonBodyGetContinuousCollisionMode(body) << "  ( "
+            << omega << "  " << force << "  " << torque << "  " << NewtonBodyGetSleepState(body)
+            << "  " << NewtonBodyGetAutoSleep(body) << "  " << NewtonBodyGetContinuousCollisionMode(body) << "  ( "
             << invMass << "  " << invIxx << "  " << invIyy << "  " << invIzz << " )";
         LOG_DEBUG(Logger::CORE, oss.str());
     }

Modified: rl/branches/persistence2/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/rules/RlRules2005.vcproj	2009-02-11 13:24:47 UTC (rev 4764)
+++ rl/branches/persistence2/engine/rules/RlRules2005.vcproj	2009-02-13 16:23:58 UTC (rev 4765)
@@ -42,7 +42,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -72,7 +72,7 @@
 				AdditionalDependencies="msvcrt-ruby18.lib xerces-c_2D.lib OgreMain_d.lib CEGUIBase_d.lib RlCore.lib OgreNewt_d.lib Newton.lib"
 				OutputFile="$(OutDir)/RlRules.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\OgreNewt_ngt\lib"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlRules.pdb"

Modified: rl/branches/persistence2/engine/script/RlScript2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/script/RlScript2005.vcproj	2009-02-11 13:24:47 UTC (rev 4764)
+++ rl/branches/persistence2/engine/script/RlScript2005.vcproj	2009-02-13 16:23:58 UTC (rev 4765)
@@ -41,7 +41,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -69,7 +69,7 @@
 				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain_d.lib msvcrt-ruby18.lib CEGUIBase_d.lib xerces-c_2D.lib OgreNewt_d.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt_ngt\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlScript.pdb"

Modified: rl/branches/persistence2/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/ui/RlUI2005.vcproj	2009-02-11 13:24:47 UTC (rev 4764)
+++ rl/branches/persistence2/engine/ui/RlUI2005.vcproj	2009-02-13 16:23:58 UTC (rev 4765)
@@ -48,7 +48,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm140"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -90,7 +90,7 @@
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt_ngt\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				IgnoreDefaultLibraryNames=""
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"



From melven at mail.berlios.de  Fri Feb 13 22:21:44 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 13 Feb 2009 22:21:44 +0100
Subject: [Dsa-hl-svn] r4766 - rl/trunk/engine/core/src
Message-ID: <200902132121.n1DLLiPI004373@sheep.berlios.de>

Author: melven
Date: 2009-02-13 22:21:43 +0100 (Fri, 13 Feb 2009)
New Revision: 4766

Modified:
   rl/trunk/engine/core/src/GameLoop.cpp
Log:
-fixed the "usleep" error... we have a msleep in Sleep.h that should handle this correctly...


Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2009-02-13 16:23:58 UTC (rev 4765)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2009-02-13 21:21:43 UTC (rev 4766)
@@ -22,6 +22,7 @@
 #include "CoreSubsystem.h"
 #include "FixRubyHeaders.h"
 #include "Exception.h"
+#include "Sleep.h"
 
 #include <numeric>
 
@@ -141,7 +142,7 @@
 
         if( unsmoothedFrameTime < mMinFrameTime*1000 )
         {
-            usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            msleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
             elapsedTime = mTimer->getMilliseconds();
             unsmoothedFrameTime = elapsedTime - mGameTime;
             if( elapsedTime < mGameTime )



From melven at mail.berlios.de  Sat Feb 14 00:30:18 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 14 Feb 2009 00:30:18 +0100
Subject: [Dsa-hl-svn] r4767 - rl/trunk/engine/core/src
Message-ID: <200902132330.n1DNUIAl019974@sheep.berlios.de>

Author: melven
Date: 2009-02-14 00:30:16 +0100 (Sat, 14 Feb 2009)
New Revision: 4767

Modified:
   rl/trunk/engine/core/src/GameLoop.cpp
Log:
-fixed bug from last commit: usleep takes milliseconds/1000 as parameter...


Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2009-02-13 21:21:43 UTC (rev 4766)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2009-02-13 23:30:16 UTC (rev 4767)
@@ -142,7 +142,7 @@
 
         if( unsmoothedFrameTime < mMinFrameTime*1000 )
         {
-            msleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            msleep(floor((mMinFrameTime*1000 - unsmoothedFrameTime)));
             elapsedTime = mTimer->getMilliseconds();
             unsmoothedFrameTime = elapsedTime - mGameTime;
             if( elapsedTime < mGameTime )



From blakharaz at mail.berlios.de  Sat Feb 14 22:36:29 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 14 Feb 2009 22:36:29 +0100
Subject: [Dsa-hl-svn] r4768 - in dependencies/OgreNewt_ngt: . Mac
	Mac/English.lproj Mac/OgreNewt.xcodeproj inc src
Message-ID: <200902142136.n1ELaT1P005439@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-14 22:36:25 +0100 (Sat, 14 Feb 2009)
New Revision: 4768

Added:
   dependencies/OgreNewt_ngt/Mac/
   dependencies/OgreNewt_ngt/Mac/English.lproj/
   dependencies/OgreNewt_ngt/Mac/English.lproj/InfoPlist.strings
   dependencies/OgreNewt_ngt/Mac/Info.plist
   dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/
   dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj
Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h
   dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp
Log:
Make OgreNewt_ngt compile on Mac OS X (with some nasty #ifdefs, and on 10.5 only)

Added: dependencies/OgreNewt_ngt/Mac/English.lproj/InfoPlist.strings
===================================================================
(Binary files differ)


Property changes on: dependencies/OgreNewt_ngt/Mac/English.lproj/InfoPlist.strings
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/OgreNewt_ngt/Mac/Info.plist
===================================================================
--- dependencies/OgreNewt_ngt/Mac/Info.plist	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/Mac/Info.plist	2009-02-14 21:36:25 UTC (rev 4768)
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>OgreNewt</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>com.apple.carbonframeworktemplate</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundlePackageType</key>
+	<string>FMWK</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+        <key>CFBundleShortVersionString</key>
+        <string>1.0</string>
+	<key>CSResourcesFileMapped</key>
+	<true/>
+</dict>
+</plist>

Added: dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj
===================================================================
--- dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj	2009-02-14 21:36:25 UTC (rev 4768)
@@ -0,0 +1,446 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 42;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		444EA9A30BD0D33B00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EA9A20BD0D33B00C6D4A0 /* Ogre.framework */; };
+		444EA9A70BD0D35800C6D4A0 /* libnewton32.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EA9A60BD0D35800C6D4A0 /* libnewton32.a */; };
+		487D45C30F47388600D1D69F /* OgreNewt.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45AF0F47388600D1D69F /* OgreNewt.h */; };
+		487D45C50F47388600D1D69F /* OgreNewt_BasicJoints.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B10F47388600D1D69F /* OgreNewt_BasicJoints.h */; };
+		487D45C60F47388600D1D69F /* OgreNewt_Body.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B20F47388600D1D69F /* OgreNewt_Body.h */; };
+		487D45C70F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B30F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h */; };
+		487D45C80F47388600D1D69F /* OgreNewt_Collision.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B40F47388600D1D69F /* OgreNewt_Collision.h */; };
+		487D45C90F47388600D1D69F /* OgreNewt_CollisionPrimitives.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B50F47388600D1D69F /* OgreNewt_CollisionPrimitives.h */; };
+		487D45CA0F47388600D1D69F /* OgreNewt_CollisionSerializer.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B60F47388600D1D69F /* OgreNewt_CollisionSerializer.h */; };
+		487D45CB0F47388600D1D69F /* OgreNewt_ContactCallback.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B70F47388600D1D69F /* OgreNewt_ContactCallback.h */; };
+		487D45CC0F47388600D1D69F /* OgreNewt_ContactJoint.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B80F47388600D1D69F /* OgreNewt_ContactJoint.h */; };
+		487D45CD0F47388600D1D69F /* OgreNewt_Debugger.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B90F47388600D1D69F /* OgreNewt_Debugger.h */; };
+		487D45CE0F47388600D1D69F /* OgreNewt_Joint.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BA0F47388600D1D69F /* OgreNewt_Joint.h */; };
+		487D45CF0F47388600D1D69F /* OgreNewt_MaterialID.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BB0F47388600D1D69F /* OgreNewt_MaterialID.h */; };
+		487D45D00F47388600D1D69F /* OgreNewt_MaterialPair.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BC0F47388600D1D69F /* OgreNewt_MaterialPair.h */; };
+		487D45D10F47388600D1D69F /* OgreNewt_PlayerController.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BD0F47388600D1D69F /* OgreNewt_PlayerController.h */; };
+		487D45D20F47388600D1D69F /* OgreNewt_Prerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BE0F47388600D1D69F /* OgreNewt_Prerequisites.h */; };
+		487D45D30F47388600D1D69F /* OgreNewt_RayCast.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BF0F47388600D1D69F /* OgreNewt_RayCast.h */; };
+		487D45D40F47388600D1D69F /* OgreNewt_Tools.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45C00F47388600D1D69F /* OgreNewt_Tools.h */; };
+		487D45D50F47388600D1D69F /* OgreNewt_Vehicle.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45C10F47388600D1D69F /* OgreNewt_Vehicle.h */; };
+		487D45D60F47388600D1D69F /* OgreNewt_World.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45C20F47388600D1D69F /* OgreNewt_World.h */; };
+		487D45EA0F47389A00D1D69F /* OgreNewt_BasicJoints.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45D80F47389A00D1D69F /* OgreNewt_BasicJoints.cpp */; };
+		487D45EB0F47389A00D1D69F /* OgreNewt_Body.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45D90F47389A00D1D69F /* OgreNewt_Body.cpp */; };
+		487D45EC0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DA0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp */; };
+		487D45ED0F47389A00D1D69F /* OgreNewt_Collision.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DB0F47389A00D1D69F /* OgreNewt_Collision.cpp */; };
+		487D45EE0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DC0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp */; };
+		487D45EF0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DD0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp */; };
+		487D45F00F47389A00D1D69F /* OgreNewt_ContactCallback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DE0F47389A00D1D69F /* OgreNewt_ContactCallback.cpp */; };
+		487D45F10F47389A00D1D69F /* OgreNewt_ContactJoint.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DF0F47389A00D1D69F /* OgreNewt_ContactJoint.cpp */; };
+		487D45F20F47389A00D1D69F /* OgreNewt_Debugger.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E00F47389A00D1D69F /* OgreNewt_Debugger.cpp */; };
+		487D45F30F47389A00D1D69F /* OgreNewt_Joint.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E10F47389A00D1D69F /* OgreNewt_Joint.cpp */; };
+		487D45F40F47389A00D1D69F /* OgreNewt_MaterialID.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E20F47389A00D1D69F /* OgreNewt_MaterialID.cpp */; };
+		487D45F50F47389A00D1D69F /* OgreNewt_MaterialPair.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E30F47389A00D1D69F /* OgreNewt_MaterialPair.cpp */; };
+		487D45F60F47389A00D1D69F /* OgreNewt_PlayerController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E40F47389A00D1D69F /* OgreNewt_PlayerController.cpp */; };
+		487D45F70F47389A00D1D69F /* OgreNewt_RayCast.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E50F47389A00D1D69F /* OgreNewt_RayCast.cpp */; };
+		487D45F80F47389A00D1D69F /* OgreNewt_Tools.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E60F47389A00D1D69F /* OgreNewt_Tools.cpp */; };
+		487D45F90F47389A00D1D69F /* OgreNewt_Vehicle.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E70F47389A00D1D69F /* OgreNewt_Vehicle.cpp */; };
+		487D45FA0F47389A00D1D69F /* OgreNewt_World.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E80F47389A00D1D69F /* OgreNewt_World.cpp */; };
+		48A94EC50F476C1700252666 /* libc.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A94EC10F476B1400252666 /* libc.dylib */; };
+		8D07F2C00486CC7A007CD1D0 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 089C1666FE841158C02AAC07 /* InfoPlist.strings */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		089C1667FE841158C02AAC07 /* English */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = English; path = English.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		444EA9A20BD0D33B00C6D4A0 /* Ogre.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Ogre.framework; path = /Library/Frameworks/Ogre.framework; sourceTree = "<absolute>"; };
+		444EA9A60BD0D35800C6D4A0 /* libnewton32.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libnewton32.a; path = /usr/local/lib/libnewton32.a; sourceTree = "<absolute>"; };
+		487D45AF0F47388600D1D69F /* OgreNewt.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt.h; path = ../inc/OgreNewt.h; sourceTree = SOURCE_ROOT; };
+		487D45B10F47388600D1D69F /* OgreNewt_BasicJoints.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_BasicJoints.h; path = ../inc/OgreNewt_BasicJoints.h; sourceTree = SOURCE_ROOT; };
+		487D45B20F47388600D1D69F /* OgreNewt_Body.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Body.h; path = ../inc/OgreNewt_Body.h; sourceTree = SOURCE_ROOT; };
+		487D45B30F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_BodyInAABBIterator.h; path = ../inc/OgreNewt_BodyInAABBIterator.h; sourceTree = SOURCE_ROOT; };
+		487D45B40F47388600D1D69F /* OgreNewt_Collision.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Collision.h; path = ../inc/OgreNewt_Collision.h; sourceTree = SOURCE_ROOT; };
+		487D45B50F47388600D1D69F /* OgreNewt_CollisionPrimitives.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_CollisionPrimitives.h; path = ../inc/OgreNewt_CollisionPrimitives.h; sourceTree = SOURCE_ROOT; };
+		487D45B60F47388600D1D69F /* OgreNewt_CollisionSerializer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_CollisionSerializer.h; path = ../inc/OgreNewt_CollisionSerializer.h; sourceTree = SOURCE_ROOT; };
+		487D45B70F47388600D1D69F /* OgreNewt_ContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_ContactCallback.h; path = ../inc/OgreNewt_ContactCallback.h; sourceTree = SOURCE_ROOT; };
+		487D45B80F47388600D1D69F /* OgreNewt_ContactJoint.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_ContactJoint.h; path = ../inc/OgreNewt_ContactJoint.h; sourceTree = SOURCE_ROOT; };
+		487D45B90F47388600D1D69F /* OgreNewt_Debugger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Debugger.h; path = ../inc/OgreNewt_Debugger.h; sourceTree = SOURCE_ROOT; };
+		487D45BA0F47388600D1D69F /* OgreNewt_Joint.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Joint.h; path = ../inc/OgreNewt_Joint.h; sourceTree = SOURCE_ROOT; };
+		487D45BB0F47388600D1D69F /* OgreNewt_MaterialID.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_MaterialID.h; path = ../inc/OgreNewt_MaterialID.h; sourceTree = SOURCE_ROOT; };
+		487D45BC0F47388600D1D69F /* OgreNewt_MaterialPair.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_MaterialPair.h; path = ../inc/OgreNewt_MaterialPair.h; sourceTree = SOURCE_ROOT; };
+		487D45BD0F47388600D1D69F /* OgreNewt_PlayerController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_PlayerController.h; path = ../inc/OgreNewt_PlayerController.h; sourceTree = SOURCE_ROOT; };
+		487D45BE0F47388600D1D69F /* OgreNewt_Prerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Prerequisites.h; path = ../inc/OgreNewt_Prerequisites.h; sourceTree = SOURCE_ROOT; };
+		487D45BF0F47388600D1D69F /* OgreNewt_RayCast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_RayCast.h; path = ../inc/OgreNewt_RayCast.h; sourceTree = SOURCE_ROOT; };
+		487D45C00F47388600D1D69F /* OgreNewt_Tools.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Tools.h; path = ../inc/OgreNewt_Tools.h; sourceTree = SOURCE_ROOT; };
+		487D45C10F47388600D1D69F /* OgreNewt_Vehicle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Vehicle.h; path = ../inc/OgreNewt_Vehicle.h; sourceTree = SOURCE_ROOT; };
+		487D45C20F47388600D1D69F /* OgreNewt_World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_World.h; path = ../inc/OgreNewt_World.h; sourceTree = SOURCE_ROOT; };
+		487D45D80F47389A00D1D69F /* OgreNewt_BasicJoints.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_BasicJoints.cpp; path = ../src/OgreNewt_BasicJoints.cpp; sourceTree = SOURCE_ROOT; };
+		487D45D90F47389A00D1D69F /* OgreNewt_Body.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Body.cpp; path = ../src/OgreNewt_Body.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DA0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_BodyInAABBIterator.cpp; path = ../src/OgreNewt_BodyInAABBIterator.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DB0F47389A00D1D69F /* OgreNewt_Collision.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Collision.cpp; path = ../src/OgreNewt_Collision.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DC0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_CollisionPrimitives.cpp; path = ../src/OgreNewt_CollisionPrimitives.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DD0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_CollisionSerializer.cpp; path = ../src/OgreNewt_CollisionSerializer.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DE0F47389A00D1D69F /* OgreNewt_ContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_ContactCallback.cpp; path = ../src/OgreNewt_ContactCallback.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DF0F47389A00D1D69F /* OgreNewt_ContactJoint.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_ContactJoint.cpp; path = ../src/OgreNewt_ContactJoint.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E00F47389A00D1D69F /* OgreNewt_Debugger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Debugger.cpp; path = ../src/OgreNewt_Debugger.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E10F47389A00D1D69F /* OgreNewt_Joint.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Joint.cpp; path = ../src/OgreNewt_Joint.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E20F47389A00D1D69F /* OgreNewt_MaterialID.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_MaterialID.cpp; path = ../src/OgreNewt_MaterialID.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E30F47389A00D1D69F /* OgreNewt_MaterialPair.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_MaterialPair.cpp; path = ../src/OgreNewt_MaterialPair.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E40F47389A00D1D69F /* OgreNewt_PlayerController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_PlayerController.cpp; path = ../src/OgreNewt_PlayerController.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E50F47389A00D1D69F /* OgreNewt_RayCast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_RayCast.cpp; path = ../src/OgreNewt_RayCast.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E60F47389A00D1D69F /* OgreNewt_Tools.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Tools.cpp; path = ../src/OgreNewt_Tools.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E70F47389A00D1D69F /* OgreNewt_Vehicle.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Vehicle.cpp; path = ../src/OgreNewt_Vehicle.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E80F47389A00D1D69F /* OgreNewt_World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_World.cpp; path = ../src/OgreNewt_World.cpp; sourceTree = SOURCE_ROOT; };
+		48A94EBE0F476A8700252666 /* libstdc++.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = "libstdc++.dylib"; path = "usr/lib/i686-apple-darwin9/4.0.1/libstdc++.dylib"; sourceTree = SDKROOT; };
+		48A94EC10F476B1400252666 /* libc.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libc.dylib; path = usr/lib/libc.dylib; sourceTree = SDKROOT; };
+		8D07F2C70486CC7A007CD1D0 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
+		8D07F2C80486CC7A007CD1D0 /* OgreNewt.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = OgreNewt.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		8D07F2C30486CC7A007CD1D0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EA9A30BD0D33B00C6D4A0 /* Ogre.framework in Frameworks */,
+				444EA9A70BD0D35800C6D4A0 /* libnewton32.a in Frameworks */,
+				48A94EC50F476C1700252666 /* libc.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		034768DDFF38A45A11DB9C8B /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				8D07F2C80486CC7A007CD1D0 /* OgreNewt.framework */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		0867D691FE84028FC02AAC07 /* OgreNewt */ = {
+			isa = PBXGroup;
+			children = (
+				08FB77ACFE841707C02AAC07 /* Source */,
+				089C1665FE841158C02AAC07 /* Resources */,
+				0867D69AFE84028FC02AAC07 /* External Frameworks and Libraries */,
+				034768DDFF38A45A11DB9C8B /* Products */,
+				48A94EBE0F476A8700252666 /* libstdc++.dylib */,
+				48A94EC10F476B1400252666 /* libc.dylib */,
+			);
+			name = OgreNewt;
+			sourceTree = "<group>";
+		};
+		0867D69AFE84028FC02AAC07 /* External Frameworks and Libraries */ = {
+			isa = PBXGroup;
+			children = (
+				444EA9A60BD0D35800C6D4A0 /* libnewton32.a */,
+				444EA9A20BD0D33B00C6D4A0 /* Ogre.framework */,
+			);
+			name = "External Frameworks and Libraries";
+			sourceTree = "<group>";
+		};
+		089C1665FE841158C02AAC07 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				8D07F2C70486CC7A007CD1D0 /* Info.plist */,
+				089C1666FE841158C02AAC07 /* InfoPlist.strings */,
+			);
+			name = Resources;
+			sourceTree = "<group>";
+		};
+		08FB77ACFE841707C02AAC07 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				487D45D80F47389A00D1D69F /* OgreNewt_BasicJoints.cpp */,
+				487D45D90F47389A00D1D69F /* OgreNewt_Body.cpp */,
+				487D45DA0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp */,
+				487D45DB0F47389A00D1D69F /* OgreNewt_Collision.cpp */,
+				487D45DC0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp */,
+				487D45DD0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp */,
+				487D45DE0F47389A00D1D69F /* OgreNewt_ContactCallback.cpp */,
+				487D45DF0F47389A00D1D69F /* OgreNewt_ContactJoint.cpp */,
+				487D45E00F47389A00D1D69F /* OgreNewt_Debugger.cpp */,
+				487D45E10F47389A00D1D69F /* OgreNewt_Joint.cpp */,
+				487D45E20F47389A00D1D69F /* OgreNewt_MaterialID.cpp */,
+				487D45E30F47389A00D1D69F /* OgreNewt_MaterialPair.cpp */,
+				487D45E40F47389A00D1D69F /* OgreNewt_PlayerController.cpp */,
+				487D45E50F47389A00D1D69F /* OgreNewt_RayCast.cpp */,
+				487D45E60F47389A00D1D69F /* OgreNewt_Tools.cpp */,
+				487D45E70F47389A00D1D69F /* OgreNewt_Vehicle.cpp */,
+				487D45E80F47389A00D1D69F /* OgreNewt_World.cpp */,
+				487D45AF0F47388600D1D69F /* OgreNewt.h */,
+				487D45B10F47388600D1D69F /* OgreNewt_BasicJoints.h */,
+				487D45B20F47388600D1D69F /* OgreNewt_Body.h */,
+				487D45B30F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h */,
+				487D45B40F47388600D1D69F /* OgreNewt_Collision.h */,
+				487D45B50F47388600D1D69F /* OgreNewt_CollisionPrimitives.h */,
+				487D45B60F47388600D1D69F /* OgreNewt_CollisionSerializer.h */,
+				487D45B70F47388600D1D69F /* OgreNewt_ContactCallback.h */,
+				487D45B80F47388600D1D69F /* OgreNewt_ContactJoint.h */,
+				487D45B90F47388600D1D69F /* OgreNewt_Debugger.h */,
+				487D45BA0F47388600D1D69F /* OgreNewt_Joint.h */,
+				487D45BB0F47388600D1D69F /* OgreNewt_MaterialID.h */,
+				487D45BC0F47388600D1D69F /* OgreNewt_MaterialPair.h */,
+				487D45BD0F47388600D1D69F /* OgreNewt_PlayerController.h */,
+				487D45BE0F47388600D1D69F /* OgreNewt_Prerequisites.h */,
+				487D45BF0F47388600D1D69F /* OgreNewt_RayCast.h */,
+				487D45C00F47388600D1D69F /* OgreNewt_Tools.h */,
+				487D45C10F47388600D1D69F /* OgreNewt_Vehicle.h */,
+				487D45C20F47388600D1D69F /* OgreNewt_World.h */,
+			);
+			name = Source;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		8D07F2BD0486CC7A007CD1D0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				487D45C30F47388600D1D69F /* OgreNewt.h in Headers */,
+				487D45C50F47388600D1D69F /* OgreNewt_BasicJoints.h in Headers */,
+				487D45C60F47388600D1D69F /* OgreNewt_Body.h in Headers */,
+				487D45C70F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h in Headers */,
+				487D45C80F47388600D1D69F /* OgreNewt_Collision.h in Headers */,
+				487D45C90F47388600D1D69F /* OgreNewt_CollisionPrimitives.h in Headers */,
+				487D45CA0F47388600D1D69F /* OgreNewt_CollisionSerializer.h in Headers */,
+				487D45CB0F47388600D1D69F /* OgreNewt_ContactCallback.h in Headers */,
+				487D45CC0F47388600D1D69F /* OgreNewt_ContactJoint.h in Headers */,
+				487D45CD0F47388600D1D69F /* OgreNewt_Debugger.h in Headers */,
+				487D45CE0F47388600D1D69F /* OgreNewt_Joint.h in Headers */,
+				487D45CF0F47388600D1D69F /* OgreNewt_MaterialID.h in Headers */,
+				487D45D00F47388600D1D69F /* OgreNewt_MaterialPair.h in Headers */,
+				487D45D10F47388600D1D69F /* OgreNewt_PlayerController.h in Headers */,
+				487D45D20F47388600D1D69F /* OgreNewt_Prerequisites.h in Headers */,
+				487D45D30F47388600D1D69F /* OgreNewt_RayCast.h in Headers */,
+				487D45D40F47388600D1D69F /* OgreNewt_Tools.h in Headers */,
+				487D45D50F47388600D1D69F /* OgreNewt_Vehicle.h in Headers */,
+				487D45D60F47388600D1D69F /* OgreNewt_World.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXNativeTarget section */
+		8D07F2BC0486CC7A007CD1D0 /* OgreNewt */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 4FADC24208B4156D00ABE55E /* Build configuration list for PBXNativeTarget "OgreNewt" */;
+			buildPhases = (
+				8D07F2BD0486CC7A007CD1D0 /* Headers */,
+				8D07F2BF0486CC7A007CD1D0 /* Resources */,
+				8D07F2C10486CC7A007CD1D0 /* Sources */,
+				8D07F2C30486CC7A007CD1D0 /* Frameworks */,
+				8D07F2C50486CC7A007CD1D0 /* Rez */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = OgreNewt;
+			productInstallPath = "$(HOME)/Library/Frameworks";
+			productName = OgreNewt;
+			productReference = 8D07F2C80486CC7A007CD1D0 /* OgreNewt.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		0867D690FE84028FC02AAC07 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = 4FADC24608B4156D00ABE55E /* Build configuration list for PBXProject "OgreNewt" */;
+			compatibilityVersion = "Xcode 2.4";
+			hasScannedForEncodings = 1;
+			mainGroup = 0867D691FE84028FC02AAC07 /* OgreNewt */;
+			productRefGroup = 034768DDFF38A45A11DB9C8B /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				8D07F2BC0486CC7A007CD1D0 /* OgreNewt */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		8D07F2BF0486CC7A007CD1D0 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				8D07F2C00486CC7A007CD1D0 /* InfoPlist.strings in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXRezBuildPhase section */
+		8D07F2C50486CC7A007CD1D0 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXRezBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		8D07F2C10486CC7A007CD1D0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				487D45EA0F47389A00D1D69F /* OgreNewt_BasicJoints.cpp in Sources */,
+				487D45EB0F47389A00D1D69F /* OgreNewt_Body.cpp in Sources */,
+				487D45EC0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp in Sources */,
+				487D45ED0F47389A00D1D69F /* OgreNewt_Collision.cpp in Sources */,
+				487D45EE0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp in Sources */,
+				487D45EF0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp in Sources */,
+				487D45F00F47389A00D1D69F /* OgreNewt_ContactCallback.cpp in Sources */,
+				487D45F10F47389A00D1D69F /* OgreNewt_ContactJoint.cpp in Sources */,
+				487D45F20F47389A00D1D69F /* OgreNewt_Debugger.cpp in Sources */,
+				487D45F30F47389A00D1D69F /* OgreNewt_Joint.cpp in Sources */,
+				487D45F40F47389A00D1D69F /* OgreNewt_MaterialID.cpp in Sources */,
+				487D45F50F47389A00D1D69F /* OgreNewt_MaterialPair.cpp in Sources */,
+				487D45F60F47389A00D1D69F /* OgreNewt_PlayerController.cpp in Sources */,
+				487D45F70F47389A00D1D69F /* OgreNewt_RayCast.cpp in Sources */,
+				487D45F80F47389A00D1D69F /* OgreNewt_Tools.cpp in Sources */,
+				487D45F90F47389A00D1D69F /* OgreNewt_Vehicle.cpp in Sources */,
+				487D45FA0F47389A00D1D69F /* OgreNewt_World.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXVariantGroup section */
+		089C1666FE841158C02AAC07 /* InfoPlist.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				089C1667FE841158C02AAC07 /* English */,
+			);
+			name = InfoPlist.strings;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		4FADC24308B4156D00ABE55E /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					i386,
+					ppc,
+				);
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "";
+				HEADER_SEARCH_PATHS = (
+					/Library/Frameworks/Ogre.framework/Headers,
+					/usr/local/include,
+				);
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = "$(HOME)/Library/Frameworks";
+				LIBRARY_SEARCH_PATHS = (
+					/usr/local/lib,
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SDKROOT)/usr/lib/i686-apple-darwin9/4.0.1\"";
+				LIBRARY_STYLE = DYNAMIC;
+				MACH_O_TYPE = mh_dylib;
+				PRODUCT_NAME = OgreNewt;
+				SDKROOT = /Developer/SDKs/MacOSX10.5.sdk;
+				WRAPPER_EXTENSION = framework;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		4FADC24408B4156D00ABE55E /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					i386,
+					ppc,
+				);
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = "/Library/Frameworks/Ogre.framework/**";
+				FRAMEWORK_VERSION = A;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "";
+				HEADER_SEARCH_PATHS = /usr/local/include;
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = "$(HOME)/Library/Frameworks";
+				LIBRARY_SEARCH_PATHS = (
+					/usr/local/lib,
+					"$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SDKROOT)/usr/lib/i686-apple-darwin9/4.0.1\"";
+				LIBRARY_STYLE = DYNAMIC;
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = (
+					"-framework",
+					Ogre,
+				);
+				PRODUCT_NAME = OgreNewt;
+				SDKROOT = /Developer/SDKs/MacOSX10.5.sdk;
+				WRAPPER_EXTENSION = framework;
+			};
+			name = Release;
+		};
+		4FADC24708B4156D00ABE55E /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = /Library/Frameworks/Ogre.framework/Headers;
+				PREBINDING = NO;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+			};
+			name = Debug;
+		};
+		4FADC24808B4156D00ABE55E /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					/usr/local/include,
+					/Library/Frameworks/Ogre.framework/Headers,
+				);
+				PREBINDING = NO;
+				SCAN_ALL_SOURCE_FILES_FOR_INCLUDES = YES;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		4FADC24208B4156D00ABE55E /* Build configuration list for PBXNativeTarget "OgreNewt" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4FADC24308B4156D00ABE55E /* Debug */,
+				4FADC24408B4156D00ABE55E /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		4FADC24608B4156D00ABE55E /* Build configuration list for PBXProject "OgreNewt" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4FADC24708B4156D00ABE55E /* Debug */,
+				4FADC24808B4156D00ABE55E /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 0867D690FE84028FC02AAC07 /* Project object */;
+}

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h	2009-02-14 21:36:25 UTC (rev 4768)
@@ -13,8 +13,6 @@
 
 
 #include "OgreNewt_Prerequisites.h"
-#include "OgreSerializer.h"
-#include "OgreString.h"
 
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,34 +1,40 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-
-
-#ifndef __INCLUDE_OGRENEWT_PREREQ__
-#define __INCLUDE_OGRENEWT_PREREQ__
-
-#include <Ogre.h>
-#include <Newton.h>
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-#   define _CDECL _cdecl
-#   if defined( _OGRENEWT_EXPORTS ) && defined( _OGRENEWT_DYNAMIC )
-#       define _OgreNewtExport __declspec( dllexport )
-#   elif defined( _OGRENEWT_DYNAMIC )
-#       define _OgreNewtExport __declspec( dllimport )
-#   else
-#       define _OgreNewtExport
-#   endif
-#else // Linux / Mac OSX etc
-#   define _OgreNewtExport
-#   define _CDECL
-#endif
-
-#endif 
-
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+
+
+#ifndef __INCLUDE_OGRENEWT_PREREQ__
+#define __INCLUDE_OGRENEWT_PREREQ__
+
+#ifdef __APPLE__
+#    include <Carbon/Carbon.h>
+#    include <Ogre/Ogre.h>
+#else
+#    include <Ogre.h>
+#endif
+
+#include <Newton.h>
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#   define _CDECL _cdecl
+#   if defined( _OGRENEWT_EXPORTS ) && defined( _OGRENEWT_DYNAMIC )
+#       define _OgreNewtExport __declspec( dllexport )
+#   elif defined( _OGRENEWT_DYNAMIC )
+#       define _OgreNewtExport __declspec( dllimport )
+#   else
+#       define _OgreNewtExport
+#   endif
+#else // Linux / Mac OSX etc
+#   define _OgreNewtExport
+#   define _CDECL
+#endif
+
+#endif 
+

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h	2009-02-14 21:36:25 UTC (rev 4768)
@@ -13,8 +13,6 @@
 
 
 #include "OgreNewt_Prerequisites.h"
-#include <OgreMovableObject.h>
-#include <OgreRenderable.h>
 
 namespace OgreNewt
 {

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,5 +1,6 @@
 #include "OgreNewt_BasicFrameListener.h"
 #include "OgreNewt_Debugger.h"
+#include "OgreNewt_World.h"
 
 namespace OgreNewt
 {

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -2,8 +2,6 @@
 #include "OgreNewt_Tools.h"
 #include "OgreNewt_RayCast.h"
 
-#include "Ogre.h"
-
 namespace OgreNewt
 {
 

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,8 +1,6 @@
 #include "OgreNewt_CollisionSerializer.h"
 #include "OgreNewt_Collision.h"
 
-#include "Ogre.h"
-
 namespace OgreNewt
 {
   CollisionSerializer::CollisionSerializer()

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -213,11 +213,18 @@
                 float matrix[16];
                 OgreNewt::Converters::QuatPosToMatrix(colori, startpt, &matrix[0] );
                 mFirstContactDistance = -1;
+#ifdef __APPLE__
                 mReturnInfoListLength = 
-                        NewtonWorldConvexCast( world->getNewtonWorld(), &matrix[0], (float*)&endpt, col->getNewtonCollision(),
+                    NewtonWorldConvexCast( world->getNewtonWorld(), &matrix[0], (float*)&endpt, col->getNewtonCollision(),
                                                &mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
-                                               mReturnInfoList, mReturnInfoListSize, threadIndex);
-
+                                               mReturnInfoList, mReturnInfoListSize);
+#else
+                mReturnInfoListLength = 
+                    NewtonWorldConvexCast( world->getNewtonWorld(), &matrix[0], (float*)&endpt, col->getNewtonCollision(),
+                              &mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
+                              mReturnInfoList, mReturnInfoListSize, threadIndex);
+#endif
+        
                 //! TODO: that's a hack here!!
                 if( mReturnInfoListLength > 0 )
                 {

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,738 +1,763 @@
-#include "OgreNewt_Tools.h"
-#include "OgreNewt_World.h"
-#include "OgreNewt_Body.h"
-#include "OgreNewt_Collision.h"
-#include <iostream>
-#include <OgreFontManager.h>
-
-namespace OgreNewt
-{
-
-	namespace Converters
-	{
-		
-		//! Take a Newton matrix and create a Quaternion + Position_vector
-		void MatrixToQuatPos( const float* matrix, Ogre::Quaternion& quat, Ogre::Vector3 &pos )
-		{
-			// this takes a matrix returned by Newton, and creates a Quaternion
-			// and position Vector3, which is more meaningful for Ogre.
-			using namespace Ogre;
-			quat = Quaternion( Matrix3(	matrix[0], matrix[4], matrix[8],
-							matrix[1], matrix[5], matrix[9],
-							matrix[2], matrix[6], matrix[10] ) );
-		
-			pos = Vector3( matrix[12], matrix[13], matrix[14] );
-		}
-
-		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
-		void QuatPosToMatrix( const Ogre::Quaternion& quat, const Ogre::Vector3 &pos, float* matrix )
-		{
-			// this takes a Quaternion and a Vector3 and creates a float array
-			// which is more meaningful to Newton.
-			using namespace Ogre;
-			Matrix3 rot;
-			Vector3 xcol, ycol, zcol;
-			
-			quat.ToRotationMatrix( rot );	// creates a 3x3 rotation matrix from the Quaternion.
-
-			xcol = rot.GetColumn(0);
-			ycol = rot.GetColumn(1);
-			zcol = rot.GetColumn(2);
-		
-			// now fill the final matrix with the appropriate data:
-			matrix[0] = xcol.x;
-			matrix[1] = xcol.y;
-			matrix[2] = xcol.z;
-			matrix[3] = 0.0f;
-		
-			matrix[4] = ycol.x;
-			matrix[5] = ycol.y;
-			matrix[6] = ycol.z;
-			matrix[7] = 0.0f;
-		
-			matrix[8] = zcol.x;
-			matrix[9] = zcol.y;
-			matrix[10] = zcol.z;
-			matrix[11] = 0.0f;
-		
-			matrix[12] = pos.x;
-			matrix[13] = pos.y;
-			matrix[14] = pos.z;
-			matrix[15] = 1.0;
-		}
-
-		void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4& matrix_out )
-		{
-			// from Newton to Ogre::Matrix4
-			matrix_out = Ogre::Matrix4( matrix_in[0], matrix_in[4], matrix_in[8], matrix_in[12],
-				matrix_in[1], matrix_in[5], matrix_in[9], matrix_in[13],
-				matrix_in[2], matrix_in[6], matrix_in[10], matrix_in[14],
-				matrix_in[3], matrix_in[7], matrix_in[11], matrix_in[15] );
-		}
-
-		void Matrix4ToMatrix( const Ogre::Matrix4& matrix_in, float* matrix_out )
-		{
-			// from Ogre to Newton.
-			matrix_out[0] = matrix_in[0][0];
-			matrix_out[1] = matrix_in[1][0];
-			matrix_out[2] = matrix_in[2][0];
-			matrix_out[3] = matrix_in[3][0];
-
-			matrix_out[4] = matrix_in[0][1];
-			matrix_out[5] = matrix_in[1][1];
-			matrix_out[6] = matrix_in[2][1];
-			matrix_out[7] = matrix_in[3][1];
-
-			matrix_out[8] = matrix_in[0][2];
-			matrix_out[9] = matrix_in[1][2];
-			matrix_out[10] = matrix_in[2][2];
-			matrix_out[11] = matrix_in[3][2];
-
-			matrix_out[12] = matrix_in[0][3];
-			matrix_out[13] = matrix_in[1][3];
-			matrix_out[14] = matrix_in[2][3];
-			matrix_out[15] = matrix_in[3][3];
-		}
-
-
-	} // end namespace "converters"
-
-	
-	namespace CollisionTools
-	{
-		//! find the point on a collision primitive closest to a global point.
-		
-		int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3& globalpt, 
-									const OgreNewt::Collision* col, const Ogre::Quaternion& colorient, const Ogre::Vector3& colpos, 
-									Ogre::Vector3& retpt, Ogre::Vector3& retnormal, int threadIndex )
-		{
-			float matrix[16];
-			Converters::QuatPosToMatrix( colorient, colpos, matrix );
-
-			return NewtonCollisionPointDistance( world->getNewtonWorld(), &globalpt.x, col->getNewtonCollision(), matrix, &retpt.x, &retnormal.x, threadIndex);
-		}
-		
-
-
-		
-		int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
-															const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
-															Ogre::Vector3& retPosA, Ogre::Vector3& retPosB, Ogre::Vector3& retNorm, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
-
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
-
-			return NewtonCollisionClosestPoint( world->getNewtonWorld(), colA->getNewtonCollision(), matrixA, colB->getNewtonCollision(), matrixB,
-												&retPosA.x, &retPosB.x, &retNorm.x, threadIndex );
-		}
-
-
-		int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
-			const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
-			Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
-
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
-
-			return NewtonCollisionCollide( world->getNewtonWorld(), maxSize, colA->getNewtonCollision(), matrixA,
-				colB->getNewtonCollision(), matrixB, &retContactPts[0].x, &retNormals[0].x, retPenetrations, threadIndex );
-		}
-
-
-		int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
-			const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA, const Ogre::Vector3& colVelA, const Ogre::Vector3& colOmegaA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB, const Ogre::Vector3& colVelB, const Ogre::Vector3& colOmegaB,
-			Ogre::Real& retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
-
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
-
-			return NewtonCollisionCollideContinue( world->getNewtonWorld(), maxSize, timeStep,
-				colA->getNewtonCollision(), matrixA, &colVelA.x, &colOmegaA.x, 
-				colB->getNewtonCollision(), matrixB, &colVelB.x, &colOmegaB.x,
-				&retTimeOfImpact, &retContactPts[0].x, &retNormals[0].x, retPenetrations, threadIndex );
-		}
-
-
-		Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3& startPt, const Ogre::Vector3& endPt, 
-			Ogre::Vector3& retNorm, int& retColID )
-		{
-			return NewtonCollisionRayCast( col->getNewtonCollision(), &startPt.x, &endPt.x, &retNorm.x, &retColID );
-		}
-
-		Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos )
-		{
-			float matrix[16];
-			Converters::QuatPosToMatrix( orient, pos, matrix );
-			Ogre::Vector3 min, max;
-
-			NewtonCollisionCalculateAABB( col->getNewtonCollision(), matrix, &min.x, &max.x );
-
-			return Ogre::AxisAlignedBox( min, max );
-		}
-
-	}	// end namespace "CollisionTools"
-
-	namespace Springs
-	{
-
-		Ogre::Real calculateSpringDamperAcceleration(Ogre::Real deltaTime, Ogre::Real springK,
-						Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity )
-		{
-			return NewtonCalculateSpringDamperAcceleration( deltaTime, springK, stretchDistance, springDamping, dampVelocity );
-		}
-	}
-
-
-        namespace OgreAddons
-        {
-            /**
-             * File: MovableText.cpp
-             *
-             * description: This create create a billboarding object that display a text.
-             * 
-             * @author  2003 by cTh see gavocanov at rambler.ru
-             * @update  2006 by barraq see nospam at barraquand.com
-            */
-
-
-            using namespace Ogre;
-
-            const unsigned short POS_TEX_BINDING = 0;
-            const unsigned short COLOUR_BINDING = 1;
-
-            MovableText::MovableText(const String &name, const String &caption, const String &fontName, Real charHeight, const ColourValue &color)
-                : mpCam(NULL)
-                  , mpWin(NULL)
-                  , mpFont(NULL)
-                  , mName(name)
-                  , mCaption(caption)
-                  , mFontName(fontName)
-                  , mCharHeight(charHeight)
-                  , mColor(color)
-                  , mType("MovableText")
-                  , mTimeUntilNextToggle(0)
-                  , mSpaceWidth(0)
-                  , mUpdateColors(true)
-                  , mOnTop(false)
-                  , mHorizontalAlignment(H_LEFT)
-                  , mVerticalAlignment(V_BELOW)
-                  , mGlobalTranslation(0.0)
-                  , mLocalTranslation(0.0)
-            {
-                if (name == "")
-                    throw Exception(Exception::ERR_INVALIDPARAMS, "Trying to create MovableText without name", "MovableText::MovableText");
-
-                if (caption == "")
-                    throw Exception(Exception::ERR_INVALIDPARAMS, "Trying to create MovableText without caption", "MovableText::MovableText");
-
-                mRenderOp.vertexData = NULL;
-                this->setFontName(mFontName);
-                this->_setupGeometry();
-            }
-
-            MovableText::~MovableText()
-            {
-                if (mRenderOp.vertexData)
-                    delete mRenderOp.vertexData;
-                // May cause crashing... check this and comment if it does
-                if (!mpMaterial.isNull())
-                    MaterialManager::getSingletonPtr()->remove(mpMaterial->getName());
-            }
-
-            void MovableText::setFontName(const String &fontName)
-            {
-                if((Ogre::MaterialManager::getSingletonPtr()->resourceExists(mName + "Material"))) 
-                { 
-                    Ogre::MaterialManager::getSingleton().remove(mName + "Material"); 
-                }
-
-                if (mFontName != fontName || mpMaterial.isNull() || !mpFont)
-                {
-                    mFontName = fontName;
-                    mpFont = (Font *)FontManager::getSingleton().getByName(mFontName).getPointer();
-                    if (!mpFont)
-                        throw Exception(Exception::ERR_ITEM_NOT_FOUND, "Could not find font " + fontName, "MovableText::setFontName");
-
-                    mpFont->load();
-                    if (!mpMaterial.isNull())
-                    {
-                        MaterialManager::getSingletonPtr()->remove(mpMaterial->getName());
-                        mpMaterial.setNull();
-                    }
-
-                    mpMaterial = mpFont->getMaterial()->clone(mName + "Material");
-                    if (!mpMaterial->isLoaded())
-                        mpMaterial->load();
-
-                    mpMaterial->setDepthCheckEnabled(!mOnTop);
-                    mpMaterial->setDepthBias(1.0,1.0);
-                    mpMaterial->setDepthWriteEnabled(mOnTop);
-                    mpMaterial->setLightingEnabled(false);
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setCaption(const String &caption)
-            {
-                if (caption != mCaption)
-                {
-                    mCaption = caption;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setColor(const ColourValue &color)
-            {
-                if (color != mColor)
-                {
-                    mColor = color;
-                    mUpdateColors = true;
-                }
-            }
-
-            void MovableText::setCharacterHeight(Real height)
-            {
-                if (height != mCharHeight)
-                {
-                    mCharHeight = height;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setSpaceWidth(Real width)
-            {
-                if (width != mSpaceWidth)
-                {
-                    mSpaceWidth = width;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setTextAlignment(const HorizontalAlignment& horizontalAlignment, const VerticalAlignment& verticalAlignment)
-            {
-                if(mHorizontalAlignment != horizontalAlignment)
-                {
-                    mHorizontalAlignment = horizontalAlignment;
-                    mNeedUpdate = true;
-                }
-                if(mVerticalAlignment != verticalAlignment)
-                {
-                    mVerticalAlignment = verticalAlignment;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setGlobalTranslation( Vector3 trans )
-            {
-                mGlobalTranslation = trans;
-            }
-
-            void MovableText::setLocalTranslation( Vector3 trans )
-            {
-                mLocalTranslation = trans;
-            }
-
-            void MovableText::showOnTop(bool show)
-            {
-                if( mOnTop != show && !mpMaterial.isNull() )
-                {
-                    mOnTop = show;
-                    mpMaterial->setDepthBias(1.0,1.0);
-                    mpMaterial->setDepthCheckEnabled(!mOnTop);
-                    mpMaterial->setDepthWriteEnabled(mOnTop);
-                }
-            }
-
-            void MovableText::_setupGeometry()
-            {
-                assert(mpFont);
-                assert(!mpMaterial.isNull());
-
-                unsigned int vertexCount = static_cast<unsigned int>(mCaption.size() * 6);
-
-                if (mRenderOp.vertexData)
-                {
-                    // Removed this test as it causes problems when replacing a caption
-                    // of the same size: replacing "Hello" with "hello"
-                    // as well as when changing the text alignment
-                    //if (mRenderOp.vertexData->vertexCount != vertexCount)
-                    {
-                        delete mRenderOp.vertexData;
-                        mRenderOp.vertexData = NULL;
-                        mUpdateColors = true;
-                    }
-                }
-
-                if (!mRenderOp.vertexData)
-                    mRenderOp.vertexData = new VertexData();
-
-                mRenderOp.indexData = 0;
-                mRenderOp.vertexData->vertexStart = 0;
-                mRenderOp.vertexData->vertexCount = vertexCount;
-                mRenderOp.operationType = RenderOperation::OT_TRIANGLE_LIST; 
-                mRenderOp.useIndexes = false; 
-
-                VertexDeclaration  *decl = mRenderOp.vertexData->vertexDeclaration;
-                VertexBufferBinding   *bind = mRenderOp.vertexData->vertexBufferBinding;
-                size_t offset = 0;
-
-                // create/bind positions/tex.ccord. buffer
-                if (!decl->findElementBySemantic(VES_POSITION))
-                    decl->addElement(POS_TEX_BINDING, offset, VET_FLOAT3, VES_POSITION);
-
-                offset += VertexElement::getTypeSize(VET_FLOAT3);
-
-                if (!decl->findElementBySemantic(VES_TEXTURE_COORDINATES))
-                    decl->addElement(POS_TEX_BINDING, offset, Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES, 0);
-
-                HardwareVertexBufferSharedPtr ptbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl->getVertexSize(POS_TEX_BINDING),
-                        mRenderOp.vertexData->vertexCount,
-                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
-                bind->setBinding(POS_TEX_BINDING, ptbuf);
-
-                // Colours - store these in a separate buffer because they change less often
-                if (!decl->findElementBySemantic(VES_DIFFUSE))
-                    decl->addElement(COLOUR_BINDING, 0, VET_COLOUR, VES_DIFFUSE);
-
-                HardwareVertexBufferSharedPtr cbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl->getVertexSize(COLOUR_BINDING),
-                        mRenderOp.vertexData->vertexCount,
-                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
-                bind->setBinding(COLOUR_BINDING, cbuf);
-
-                size_t charlen = mCaption.size();
-                float *pPCBuff = static_cast<float*>(ptbuf->lock(HardwareBuffer::HBL_DISCARD));
-
-                float largestWidth = 0;
-                float left = 0 * 2.0 - 1.0;
-                float top = -((0 * 2.0) - 1.0);
-
-                Real spaceWidth = mSpaceWidth;
-                // Derive space width from a capital A
-                if (spaceWidth == 0)
-                    spaceWidth = mpFont->getGlyphAspectRatio('A') * mCharHeight * 2.0;
-
-                // for calculation of AABB
-                Ogre::Vector3 min, max, currPos;
-                Ogre::Real maxSquaredRadius;
-                bool first = true;
-
-                // Use iterator
-                String::iterator i, iend;
-                iend = mCaption.end();
-                bool newLine = true;
-                Real len = 0.0f;
-
-                Real verticalOffset = 0;
-                switch (mVerticalAlignment)
-                {
-                    case MovableText::V_ABOVE:
-                        verticalOffset = mCharHeight;
-                        break;
-                    case MovableText::V_CENTER:
-                        verticalOffset = 0.5*mCharHeight;
-                        break;
-                    case MovableText::V_BELOW:
-                        verticalOffset = 0;
-                        break;
-                }
-                // Raise the first line of the caption
-                top += verticalOffset;
-                for (i = mCaption.begin(); i != iend; ++i)
-                {
-                    if (*i == '\n')
-                        top += verticalOffset * 2.0;
-                }
-
-                for (i = mCaption.begin(); i != iend; ++i)
-                {
-                    if (newLine)
-                    {
-                        len = 0.0f;
-                        for (String::iterator j = i; j != iend && *j != '\n'; j++)
-                        {
-                            if (*j == ' ')
-                                len += spaceWidth;
-                            else 
-                                len += mpFont->getGlyphAspectRatio(*j) * mCharHeight * 2.0;
-                        }
-                        newLine = false;
-                    }
-
-                    if (*i == '\n')
-                    {
-                        left = 0 * 2.0 - 1.0;
-                        top -= mCharHeight * 2.0;
-                        newLine = true;
-                        continue;
-                    }
-
-                    if (*i == ' ')
-                    {
-                        // Just leave a gap, no tris
-                        left += spaceWidth;
-                        // Also reduce tri count
-                        mRenderOp.vertexData->vertexCount -= 6;
-                        continue;
-                    }
-
-                    Real horiz_height = mpFont->getGlyphAspectRatio(*i);
-                    Real u1, u2, v1, v2; 
-                    Ogre::Font::UVRect utmp;
-                    utmp = mpFont->getGlyphTexCoords(*i);
-                    u1 = utmp.left;
-                    u2 = utmp.right;
-                    v1 = utmp.top;
-                    v2 = utmp.bottom;
-
-                    // each vert is (x, y, z, u, v)
-                    //-------------------------------------------------------------------------------------
-                    // First tri
-                    //
-                    // Upper left
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u1;
-                    *pPCBuff++ = v1;
-
-                    // Deal with bounds
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        currPos = Ogre::Vector3(left, top, -1.0);
-                    else
-                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
-                    if (first)
-                    {
-                        min = max = currPos;
-                        maxSquaredRadius = currPos.squaredLength();
-                        first = false;
-                    }
-                    else
-                    {
-                        min.makeFloor(currPos);
-                        max.makeCeil(currPos);
-                        maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-                    }
-
-                    top -= mCharHeight * 2.0;
-
-                    // Bottom left
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u1;
-                    *pPCBuff++ = v2;
-
-                    // Deal with bounds
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        currPos = Ogre::Vector3(left, top, -1.0);
-                    else
-                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    top += mCharHeight * 2.0;
-                    left += horiz_height * mCharHeight * 2.0;
-
-                    // Top right
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u2;
-                    *pPCBuff++ = v1;
-                    //-------------------------------------------------------------------------------------
-
-                    // Deal with bounds
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        currPos = Ogre::Vector3(left, top, -1.0);
-                    else
-                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    //-------------------------------------------------------------------------------------
-                    // Second tri
-                    //
-                    // Top right (again)
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u2;
-                    *pPCBuff++ = v1;
-
-                    currPos = Ogre::Vector3(left, top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    top -= mCharHeight * 2.0;
-                    left -= horiz_height  * mCharHeight * 2.0;
-
-                    // Bottom left (again)
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u1;
-                    *pPCBuff++ = v2;
-
-                    currPos = Ogre::Vector3(left, top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    left += horiz_height  * mCharHeight * 2.0;
-
-                    // Bottom right
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u2;
-                    *pPCBuff++ = v2;
-                    //-------------------------------------------------------------------------------------
-
-                    currPos = Ogre::Vector3(left, top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    // Go back up with top
-                    top += mCharHeight * 2.0;
-
-                    float currentWidth = (left + 1)/2 - 0;
-                    if (currentWidth > largestWidth)
-                        largestWidth = currentWidth;
-                }
-
-                // Unlock vertex buffer
-                ptbuf->unlock();
-
-                // update AABB/Sphere radius
-                mAABB = Ogre::AxisAlignedBox(min, max);
-                mRadius = Ogre::Math::Sqrt(maxSquaredRadius);
-
-                if (mUpdateColors)
-                    this->_updateColors();
-
-                mNeedUpdate = false;
-            }
-
-            void MovableText::_updateColors(void)
-            {
-                assert(mpFont);
-                assert(!mpMaterial.isNull());
-
-                // Convert to system-specific
-                RGBA color;
-                Root::getSingleton().convertColourValue(mColor, &color);
-                HardwareVertexBufferSharedPtr vbuf = mRenderOp.vertexData->vertexBufferBinding->getBuffer(COLOUR_BINDING);
-                RGBA *pDest = static_cast<RGBA*>(vbuf->lock(HardwareBuffer::HBL_DISCARD));
-                for (int i = 0; i < (int)mRenderOp.vertexData->vertexCount; ++i)
-                    *pDest++ = color;
-                vbuf->unlock();
-                mUpdateColors = false;
-            }
-
-            const Quaternion& MovableText::getWorldOrientation(void) const
-            {
-                assert(mpCam);
-                return const_cast<Quaternion&>(mpCam->getDerivedOrientation());
-            }
-
-            const Vector3& MovableText::getWorldPosition(void) const
-            {
-                assert(mParentNode);
-                return mParentNode->_getDerivedPosition();
-            }
-
-            void MovableText::getWorldTransforms(Matrix4 *xform) const 
-            {
-                if (this->isVisible() && mpCam)
-                {
-                    Matrix3 rot3x3, scale3x3 = Matrix3::IDENTITY;
-
-                    // store rotation in a matrix
-                    mpCam->getDerivedOrientation().ToRotationMatrix(rot3x3);
-
-                    // parent node position
-                    Vector3 ppos = mParentNode->_getDerivedPosition() + Vector3::UNIT_Y*mGlobalTranslation;
-                    ppos += rot3x3*mLocalTranslation;
-
-                    // apply scale
-                    scale3x3[0][0] = mParentNode->_getDerivedScale().x / 2;
-                    scale3x3[1][1] = mParentNode->_getDerivedScale().y / 2;
-                    scale3x3[2][2] = mParentNode->_getDerivedScale().z / 2;
-
-                    // apply all transforms to xform       
-                    *xform = (rot3x3 * scale3x3);
-                    xform->setTrans(ppos);
-                }
-            }
-
-            void MovableText::getRenderOperation(RenderOperation &op)
-            {
-                if (this->isVisible())
-                {
-                    if (mNeedUpdate)
-                        this->_setupGeometry();
-                    if (mUpdateColors)
-                        this->_updateColors();
-                    op = mRenderOp;
-                }
-            }
-
-            void MovableText::_notifyCurrentCamera(Camera *cam)
-            {
-                mpCam = cam;
-            }
-
-            void MovableText::_updateRenderQueue(RenderQueue* queue)
-            {
-                if (this->isVisible())
-                {
-                    if (mNeedUpdate)
-                        this->_setupGeometry();
-                    if (mUpdateColors)
-                        this->_updateColors();
-
-                    queue->addRenderable(this, mRenderQueueID, OGRE_RENDERABLE_DEFAULT_PRIORITY);
-                    //queue->addRenderable(this, mRenderQueueID, RENDER_QUEUE_SKIES_LATE);
-                }
-            }
-
-            void MovableText::visitRenderables(Renderable::Visitor* visitor, bool debugRenderables)
-            {
-                visitor->visit(this, 0, debugRenderables);
-            }
-        }
-}
-
+#include "OgreNewt_Tools.h"
+#include "OgreNewt_World.h"
+#include "OgreNewt_Body.h"
+#include "OgreNewt_Collision.h"
+#include <iostream>
+
+#ifdef __APPLE__
+#    include <Ogre/OgreFontManager.h>
+#else
+#    include <OgreFontManager.h>
+#endif
+
+namespace OgreNewt
+{
+
+	namespace Converters
+	{
+		
+		//! Take a Newton matrix and create a Quaternion + Position_vector
+		void MatrixToQuatPos( const float* matrix, Ogre::Quaternion& quat, Ogre::Vector3 &pos )
+		{
+			// this takes a matrix returned by Newton, and creates a Quaternion
+			// and position Vector3, which is more meaningful for Ogre.
+			using namespace Ogre;
+			quat = Quaternion( Matrix3(	matrix[0], matrix[4], matrix[8],
+							matrix[1], matrix[5], matrix[9],
+							matrix[2], matrix[6], matrix[10] ) );
+		
+			pos = Vector3( matrix[12], matrix[13], matrix[14] );
+		}
+
+		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
+		void QuatPosToMatrix( const Ogre::Quaternion& quat, const Ogre::Vector3 &pos, float* matrix )
+		{
+			// this takes a Quaternion and a Vector3 and creates a float array
+			// which is more meaningful to Newton.
+			using namespace Ogre;
+			Matrix3 rot;
+			Vector3 xcol, ycol, zcol;
+			
+			quat.ToRotationMatrix( rot );	// creates a 3x3 rotation matrix from the Quaternion.
+
+			xcol = rot.GetColumn(0);
+			ycol = rot.GetColumn(1);
+			zcol = rot.GetColumn(2);
+		
+			// now fill the final matrix with the appropriate data:
+			matrix[0] = xcol.x;
+			matrix[1] = xcol.y;
+			matrix[2] = xcol.z;
+			matrix[3] = 0.0f;
+		
+			matrix[4] = ycol.x;
+			matrix[5] = ycol.y;
+			matrix[6] = ycol.z;
+			matrix[7] = 0.0f;
+		
+			matrix[8] = zcol.x;
+			matrix[9] = zcol.y;
+			matrix[10] = zcol.z;
+			matrix[11] = 0.0f;
+		
+			matrix[12] = pos.x;
+			matrix[13] = pos.y;
+			matrix[14] = pos.z;
+			matrix[15] = 1.0;
+		}
+
+		void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4& matrix_out )
+		{
+			// from Newton to Ogre::Matrix4
+			matrix_out = Ogre::Matrix4( matrix_in[0], matrix_in[4], matrix_in[8], matrix_in[12],
+				matrix_in[1], matrix_in[5], matrix_in[9], matrix_in[13],
+				matrix_in[2], matrix_in[6], matrix_in[10], matrix_in[14],
+				matrix_in[3], matrix_in[7], matrix_in[11], matrix_in[15] );
+		}
+
+		void Matrix4ToMatrix( const Ogre::Matrix4& matrix_in, float* matrix_out )
+		{
+			// from Ogre to Newton.
+			matrix_out[0] = matrix_in[0][0];
+			matrix_out[1] = matrix_in[1][0];
+			matrix_out[2] = matrix_in[2][0];
+			matrix_out[3] = matrix_in[3][0];
+
+			matrix_out[4] = matrix_in[0][1];
+			matrix_out[5] = matrix_in[1][1];
+			matrix_out[6] = matrix_in[2][1];
+			matrix_out[7] = matrix_in[3][1];
+
+			matrix_out[8] = matrix_in[0][2];
+			matrix_out[9] = matrix_in[1][2];
+			matrix_out[10] = matrix_in[2][2];
+			matrix_out[11] = matrix_in[3][2];
+
+			matrix_out[12] = matrix_in[0][3];
+			matrix_out[13] = matrix_in[1][3];
+			matrix_out[14] = matrix_in[2][3];
+			matrix_out[15] = matrix_in[3][3];
+		}
+
+
+	} // end namespace "converters"
+
+	
+	namespace CollisionTools
+	{
+		//! find the point on a collision primitive closest to a global point.
+		
+		int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3& globalpt, 
+									const OgreNewt::Collision* col, const Ogre::Quaternion& colorient, const Ogre::Vector3& colpos, 
+									Ogre::Vector3& retpt, Ogre::Vector3& retnormal, int threadIndex )
+		{
+			float matrix[16];
+			Converters::QuatPosToMatrix( colorient, colpos, matrix );
+#ifdef __APPLE__
+			return NewtonCollisionPointDistance( world->getNewtonWorld(), &globalpt.x, col->getNewtonCollision(), matrix, &retpt.x, &retnormal.x);
+#else
+			return NewtonCollisionPointDistance( world->getNewtonWorld(), &globalpt.x, col->getNewtonCollision(), matrix, &retpt.x, &retnormal.x, threadIndex);
+#endif
+		}
+		
+
+
+		
+		int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
+															const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
+															Ogre::Vector3& retPosA, Ogre::Vector3& retPosB, Ogre::Vector3& retNorm, int threadIndex )
+		{
+			float matrixA[16];
+			float matrixB[16];
+
+			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+
+#ifdef __APPLE__
+			return NewtonCollisionClosestPoint( world->getNewtonWorld(), colA->getNewtonCollision(), matrixA, colB->getNewtonCollision(), matrixB,
+												&retPosA.x, &retPosB.x, &retNorm.x);
+#else
+			return NewtonCollisionClosestPoint( world->getNewtonWorld(), colA->getNewtonCollision(), matrixA, colB->getNewtonCollision(), matrixB,
+                                               &retPosA.x, &retPosB.x, &retNorm.x, threadIndex );
+#endif
+		}
+
+
+		int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
+			const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
+			const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
+			Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
+		{
+			float matrixA[16];
+			float matrixB[16];
+
+			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+
+#ifdef __APPLE__
+			return NewtonCollisionCollide( world->getNewtonWorld(), maxSize, colA->getNewtonCollision(), matrixA,
+				colB->getNewtonCollision(), matrixB, &retContactPts[0].x, &retNormals[0].x, retPenetrations);
+#else
+			return NewtonCollisionCollide( world->getNewtonWorld(), maxSize, colA->getNewtonCollision(), matrixA,
+                                          colB->getNewtonCollision(), matrixB, &retContactPts[0].x, &retNormals[0].x, retPenetrations, threadIndex );
+#endif
+		}
+
+
+		int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
+			const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA, const Ogre::Vector3& colVelA, const Ogre::Vector3& colOmegaA,
+			const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB, const Ogre::Vector3& colVelB, const Ogre::Vector3& colOmegaB,
+			Ogre::Real& retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
+		{
+			float matrixA[16];
+			float matrixB[16];
+
+			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+
+#ifdef __APPLE__
+			return NewtonCollisionCollideContinue( world->getNewtonWorld(), maxSize, timeStep,
+                                                  colA->getNewtonCollision(), matrixA, &colVelA.x, &colOmegaA.x, 
+                                                  colB->getNewtonCollision(), matrixB, &colVelB.x, &colOmegaB.x,
+                                                  &retTimeOfImpact, &retContactPts[0].x, &retNormals[0].x, retPenetrations);
+#else
+			return NewtonCollisionCollideContinue( world->getNewtonWorld(), maxSize, timeStep,
+                                                  colA->getNewtonCollision(), matrixA, &colVelA.x, &colOmegaA.x, 
+                                                  colB->getNewtonCollision(), matrixB, &colVelB.x, &colOmegaB.x,
+                                                  &retTimeOfImpact, &retContactPts[0].x, &retNormals[0].x, retPenetrations, threadIndex );
+#endif
+		}
+
+
+		Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3& startPt, const Ogre::Vector3& endPt, 
+			Ogre::Vector3& retNorm, int& retColID )
+		{
+			return NewtonCollisionRayCast( col->getNewtonCollision(), &startPt.x, &endPt.x, &retNorm.x, &retColID );
+		}
+
+		Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos )
+		{
+			float matrix[16];
+			Converters::QuatPosToMatrix( orient, pos, matrix );
+			Ogre::Vector3 min, max;
+
+			NewtonCollisionCalculateAABB( col->getNewtonCollision(), matrix, &min.x, &max.x );
+
+			return Ogre::AxisAlignedBox( min, max );
+		}
+
+	}	// end namespace "CollisionTools"
+
+	namespace Springs
+	{
+
+		Ogre::Real calculateSpringDamperAcceleration(Ogre::Real deltaTime, Ogre::Real springK,
+						Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity )
+		{
+			return NewtonCalculateSpringDamperAcceleration( deltaTime, springK, stretchDistance, springDamping, dampVelocity );
+		}
+	}
+
+
+        namespace OgreAddons
+        {
+            /**
+             * File: MovableText.cpp
+             *
+             * description: This create create a billboarding object that display a text.
+             * 
+             * @author  2003 by cTh see gavocanov at rambler.ru
+             * @update  2006 by barraq see nospam at barraquand.com
+            */
+
+
+            using namespace Ogre;
+
+            const unsigned short POS_TEX_BINDING = 0;
+            const unsigned short COLOUR_BINDING = 1;
+
+            MovableText::MovableText(const String &name, const String &caption, const String &fontName, Real charHeight, const ColourValue &color)
+                : mpCam(NULL)
+                  , mpWin(NULL)
+                  , mpFont(NULL)
+                  , mName(name)
+                  , mCaption(caption)
+                  , mFontName(fontName)
+                  , mCharHeight(charHeight)
+                  , mColor(color)
+                  , mType("MovableText")
+                  , mTimeUntilNextToggle(0)
+                  , mSpaceWidth(0)
+                  , mUpdateColors(true)
+                  , mOnTop(false)
+                  , mHorizontalAlignment(H_LEFT)
+                  , mVerticalAlignment(V_BELOW)
+                  , mGlobalTranslation(0.0)
+                  , mLocalTranslation(0.0)
+            {
+                if (name == "")
+                    throw Exception(Exception::ERR_INVALIDPARAMS, "Trying to create MovableText without name", "MovableText::MovableText");
+
+                if (caption == "")
+                    throw Exception(Exception::ERR_INVALIDPARAMS, "Trying to create MovableText without caption", "MovableText::MovableText");
+
+                mRenderOp.vertexData = NULL;
+                this->setFontName(mFontName);
+                this->_setupGeometry();
+            }
+
+            MovableText::~MovableText()
+            {
+                if (mRenderOp.vertexData)
+                    delete mRenderOp.vertexData;
+                // May cause crashing... check this and comment if it does
+                if (!mpMaterial.isNull())
+                    MaterialManager::getSingletonPtr()->remove(mpMaterial->getName());
+            }
+
+            void MovableText::setFontName(const String &fontName)
+            {
+                if((Ogre::MaterialManager::getSingletonPtr()->resourceExists(mName + "Material"))) 
+                { 
+                    Ogre::MaterialManager::getSingleton().remove(mName + "Material"); 
+                }
+
+                if (mFontName != fontName || mpMaterial.isNull() || !mpFont)
+                {
+                    mFontName = fontName;
+                    mpFont = (Font *)FontManager::getSingleton().getByName(mFontName).getPointer();
+                    if (!mpFont)
+                        throw Exception(Exception::ERR_ITEM_NOT_FOUND, "Could not find font " + fontName, "MovableText::setFontName");
+
+                    mpFont->load();
+                    if (!mpMaterial.isNull())
+                    {
+                        MaterialManager::getSingletonPtr()->remove(mpMaterial->getName());
+                        mpMaterial.setNull();
+                    }
+
+                    mpMaterial = mpFont->getMaterial()->clone(mName + "Material");
+                    if (!mpMaterial->isLoaded())
+                        mpMaterial->load();
+
+                    mpMaterial->setDepthCheckEnabled(!mOnTop);
+                    mpMaterial->setDepthBias(1.0,1.0);
+                    mpMaterial->setDepthWriteEnabled(mOnTop);
+                    mpMaterial->setLightingEnabled(false);
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setCaption(const String &caption)
+            {
+                if (caption != mCaption)
+                {
+                    mCaption = caption;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setColor(const ColourValue &color)
+            {
+                if (color != mColor)
+                {
+                    mColor = color;
+                    mUpdateColors = true;
+                }
+            }
+
+            void MovableText::setCharacterHeight(Real height)
+            {
+                if (height != mCharHeight)
+                {
+                    mCharHeight = height;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setSpaceWidth(Real width)
+            {
+                if (width != mSpaceWidth)
+                {
+                    mSpaceWidth = width;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setTextAlignment(const HorizontalAlignment& horizontalAlignment, const VerticalAlignment& verticalAlignment)
+            {
+                if(mHorizontalAlignment != horizontalAlignment)
+                {
+                    mHorizontalAlignment = horizontalAlignment;
+                    mNeedUpdate = true;
+                }
+                if(mVerticalAlignment != verticalAlignment)
+                {
+                    mVerticalAlignment = verticalAlignment;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setGlobalTranslation( Vector3 trans )
+            {
+                mGlobalTranslation = trans;
+            }
+
+            void MovableText::setLocalTranslation( Vector3 trans )
+            {
+                mLocalTranslation = trans;
+            }
+
+            void MovableText::showOnTop(bool show)
+            {
+                if( mOnTop != show && !mpMaterial.isNull() )
+                {
+                    mOnTop = show;
+                    mpMaterial->setDepthBias(1.0,1.0);
+                    mpMaterial->setDepthCheckEnabled(!mOnTop);
+                    mpMaterial->setDepthWriteEnabled(mOnTop);
+                }
+            }
+
+            void MovableText::_setupGeometry()
+            {
+                assert(mpFont);
+                assert(!mpMaterial.isNull());
+
+                unsigned int vertexCount = static_cast<unsigned int>(mCaption.size() * 6);
+
+                if (mRenderOp.vertexData)
+                {
+                    // Removed this test as it causes problems when replacing a caption
+                    // of the same size: replacing "Hello" with "hello"
+                    // as well as when changing the text alignment
+                    //if (mRenderOp.vertexData->vertexCount != vertexCount)
+                    {
+                        delete mRenderOp.vertexData;
+                        mRenderOp.vertexData = NULL;
+                        mUpdateColors = true;
+                    }
+                }
+
+                if (!mRenderOp.vertexData)
+                    mRenderOp.vertexData = new VertexData();
+
+                mRenderOp.indexData = 0;
+                mRenderOp.vertexData->vertexStart = 0;
+                mRenderOp.vertexData->vertexCount = vertexCount;
+                mRenderOp.operationType = RenderOperation::OT_TRIANGLE_LIST; 
+                mRenderOp.useIndexes = false; 
+
+                VertexDeclaration  *decl = mRenderOp.vertexData->vertexDeclaration;
+                VertexBufferBinding   *bind = mRenderOp.vertexData->vertexBufferBinding;
+                size_t offset = 0;
+
+                // create/bind positions/tex.ccord. buffer
+                if (!decl->findElementBySemantic(VES_POSITION))
+                    decl->addElement(POS_TEX_BINDING, offset, VET_FLOAT3, VES_POSITION);
+
+                offset += VertexElement::getTypeSize(VET_FLOAT3);
+
+                if (!decl->findElementBySemantic(VES_TEXTURE_COORDINATES))
+                    decl->addElement(POS_TEX_BINDING, offset, Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES, 0);
+
+                HardwareVertexBufferSharedPtr ptbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl->getVertexSize(POS_TEX_BINDING),
+                        mRenderOp.vertexData->vertexCount,
+                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
+                bind->setBinding(POS_TEX_BINDING, ptbuf);
+
+                // Colours - store these in a separate buffer because they change less often
+                if (!decl->findElementBySemantic(VES_DIFFUSE))
+                    decl->addElement(COLOUR_BINDING, 0, VET_COLOUR, VES_DIFFUSE);
+
+                HardwareVertexBufferSharedPtr cbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl->getVertexSize(COLOUR_BINDING),
+                        mRenderOp.vertexData->vertexCount,
+                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
+                bind->setBinding(COLOUR_BINDING, cbuf);
+
+                size_t charlen = mCaption.size();
+                float *pPCBuff = static_cast<float*>(ptbuf->lock(HardwareBuffer::HBL_DISCARD));
+
+                float largestWidth = 0;
+                float left = 0 * 2.0 - 1.0;
+                float top = -((0 * 2.0) - 1.0);
+
+                Real spaceWidth = mSpaceWidth;
+                // Derive space width from a capital A
+                if (spaceWidth == 0)
+                    spaceWidth = mpFont->getGlyphAspectRatio('A') * mCharHeight * 2.0;
+
+                // for calculation of AABB
+                Ogre::Vector3 min, max, currPos;
+                Ogre::Real maxSquaredRadius;
+                bool first = true;
+
+                // Use iterator
+                String::iterator i, iend;
+                iend = mCaption.end();
+                bool newLine = true;
+                Real len = 0.0f;
+
+                Real verticalOffset = 0;
+                switch (mVerticalAlignment)
+                {
+                    case MovableText::V_ABOVE:
+                        verticalOffset = mCharHeight;
+                        break;
+                    case MovableText::V_CENTER:
+                        verticalOffset = 0.5*mCharHeight;
+                        break;
+                    case MovableText::V_BELOW:
+                        verticalOffset = 0;
+                        break;
+                }
+                // Raise the first line of the caption
+                top += verticalOffset;
+                for (i = mCaption.begin(); i != iend; ++i)
+                {
+                    if (*i == '\n')
+                        top += verticalOffset * 2.0;
+                }
+
+                for (i = mCaption.begin(); i != iend; ++i)
+                {
+                    if (newLine)
+                    {
+                        len = 0.0f;
+                        for (String::iterator j = i; j != iend && *j != '\n'; j++)
+                        {
+                            if (*j == ' ')
+                                len += spaceWidth;
+                            else 
+                                len += mpFont->getGlyphAspectRatio(*j) * mCharHeight * 2.0;
+                        }
+                        newLine = false;
+                    }
+
+                    if (*i == '\n')
+                    {
+                        left = 0 * 2.0 - 1.0;
+                        top -= mCharHeight * 2.0;
+                        newLine = true;
+                        continue;
+                    }
+
+                    if (*i == ' ')
+                    {
+                        // Just leave a gap, no tris
+                        left += spaceWidth;
+                        // Also reduce tri count
+                        mRenderOp.vertexData->vertexCount -= 6;
+                        continue;
+                    }
+
+                    Real horiz_height = mpFont->getGlyphAspectRatio(*i);
+                    Real u1, u2, v1, v2; 
+                    Ogre::Font::UVRect utmp;
+                    utmp = mpFont->getGlyphTexCoords(*i);
+                    u1 = utmp.left;
+                    u2 = utmp.right;
+                    v1 = utmp.top;
+                    v2 = utmp.bottom;
+
+                    // each vert is (x, y, z, u, v)
+                    //-------------------------------------------------------------------------------------
+                    // First tri
+                    //
+                    // Upper left
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u1;
+                    *pPCBuff++ = v1;
+
+                    // Deal with bounds
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        currPos = Ogre::Vector3(left, top, -1.0);
+                    else
+                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
+                    if (first)
+                    {
+                        min = max = currPos;
+                        maxSquaredRadius = currPos.squaredLength();
+                        first = false;
+                    }
+                    else
+                    {
+                        min.makeFloor(currPos);
+                        max.makeCeil(currPos);
+                        maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+                    }
+
+                    top -= mCharHeight * 2.0;
+
+                    // Bottom left
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u1;
+                    *pPCBuff++ = v2;
+
+                    // Deal with bounds
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        currPos = Ogre::Vector3(left, top, -1.0);
+                    else
+                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    top += mCharHeight * 2.0;
+                    left += horiz_height * mCharHeight * 2.0;
+
+                    // Top right
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u2;
+                    *pPCBuff++ = v1;
+                    //-------------------------------------------------------------------------------------
+
+                    // Deal with bounds
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        currPos = Ogre::Vector3(left, top, -1.0);
+                    else
+                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    //-------------------------------------------------------------------------------------
+                    // Second tri
+                    //
+                    // Top right (again)
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u2;
+                    *pPCBuff++ = v1;
+
+                    currPos = Ogre::Vector3(left, top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    top -= mCharHeight * 2.0;
+                    left -= horiz_height  * mCharHeight * 2.0;
+
+                    // Bottom left (again)
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u1;
+                    *pPCBuff++ = v2;
+
+                    currPos = Ogre::Vector3(left, top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    left += horiz_height  * mCharHeight * 2.0;
+
+                    // Bottom right
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u2;
+                    *pPCBuff++ = v2;
+                    //-------------------------------------------------------------------------------------
+
+                    currPos = Ogre::Vector3(left, top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    // Go back up with top
+                    top += mCharHeight * 2.0;
+
+                    float currentWidth = (left + 1)/2 - 0;
+                    if (currentWidth > largestWidth)
+                        largestWidth = currentWidth;
+                }
+
+                // Unlock vertex buffer
+                ptbuf->unlock();
+
+                // update AABB/Sphere radius
+                mAABB = Ogre::AxisAlignedBox(min, max);
+                mRadius = Ogre::Math::Sqrt(maxSquaredRadius);
+
+                if (mUpdateColors)
+                    this->_updateColors();
+
+                mNeedUpdate = false;
+            }
+
+            void MovableText::_updateColors(void)
+            {
+                assert(mpFont);
+                assert(!mpMaterial.isNull());
+
+                // Convert to system-specific
+                RGBA color;
+                Root::getSingleton().convertColourValue(mColor, &color);
+                HardwareVertexBufferSharedPtr vbuf = mRenderOp.vertexData->vertexBufferBinding->getBuffer(COLOUR_BINDING);
+                RGBA *pDest = static_cast<RGBA*>(vbuf->lock(HardwareBuffer::HBL_DISCARD));
+                for (int i = 0; i < (int)mRenderOp.vertexData->vertexCount; ++i)
+                    *pDest++ = color;
+                vbuf->unlock();
+                mUpdateColors = false;
+            }
+
+            const Quaternion& MovableText::getWorldOrientation(void) const
+            {
+                assert(mpCam);
+                return const_cast<Quaternion&>(mpCam->getDerivedOrientation());
+            }
+
+            const Vector3& MovableText::getWorldPosition(void) const
+            {
+                assert(mParentNode);
+                return mParentNode->_getDerivedPosition();
+            }
+
+            void MovableText::getWorldTransforms(Matrix4 *xform) const 
+            {
+                if (this->isVisible() && mpCam)
+                {
+                    Matrix3 rot3x3, scale3x3 = Matrix3::IDENTITY;
+
+                    // store rotation in a matrix
+                    mpCam->getDerivedOrientation().ToRotationMatrix(rot3x3);
+
+                    // parent node position
+                    Vector3 ppos = mParentNode->_getDerivedPosition() + Vector3::UNIT_Y*mGlobalTranslation;
+                    ppos += rot3x3*mLocalTranslation;
+
+                    // apply scale
+                    scale3x3[0][0] = mParentNode->_getDerivedScale().x / 2;
+                    scale3x3[1][1] = mParentNode->_getDerivedScale().y / 2;
+                    scale3x3[2][2] = mParentNode->_getDerivedScale().z / 2;
+
+                    // apply all transforms to xform       
+                    *xform = (rot3x3 * scale3x3);
+                    xform->setTrans(ppos);
+                }
+            }
+
+            void MovableText::getRenderOperation(RenderOperation &op)
+            {
+                if (this->isVisible())
+                {
+                    if (mNeedUpdate)
+                        this->_setupGeometry();
+                    if (mUpdateColors)
+                        this->_updateColors();
+                    op = mRenderOp;
+                }
+            }
+
+            void MovableText::_notifyCurrentCamera(Camera *cam)
+            {
+                mpCam = cam;
+            }
+
+            void MovableText::_updateRenderQueue(RenderQueue* queue)
+            {
+                if (this->isVisible())
+                {
+                    if (mNeedUpdate)
+                        this->_setupGeometry();
+                    if (mUpdateColors)
+                        this->_updateColors();
+
+                    queue->addRenderable(this, mRenderQueueID, OGRE_RENDERABLE_DEFAULT_PRIORITY);
+                    //queue->addRenderable(this, mRenderQueueID, RENDER_QUEUE_SKIES_LATE);
+                }
+            }
+
+            void MovableText::visitRenderables(Renderable::Visitor* visitor, bool debugRenderables)
+            {
+                visitor->visit(this, 0, debugRenderables);
+            }
+        }
+}
+



From fusion2 at mail.berlios.de  Tue Feb 17 20:21:09 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 17 Feb 2009 20:21:09 +0100
Subject: [Dsa-hl-svn] r4769 - in rl/trunk/editors/Lockenwickler: . src
Message-ID: <200902171921.n1HJL95s023176@sheep.berlios.de>

Author: fusion2
Date: 2009-02-17 20:20:38 +0100 (Tue, 17 Feb 2009)
New Revision: 4769

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
Log:
- fixes for linux Ogre/Qt connection 

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-14 21:36:25 UTC (rev 4768)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-17 19:20:38 UTC (rev 4769)
@@ -1,180 +1,180 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-02-10, 21:36:41 -->
-<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.6">
-  <Language>en</Language>
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>src/Lockenwickler.py</Source>
-    <Source>src/ConsoleWindow.py</Source>
-    <Source>src/ModelSelectionDialog.py</Source>
-    <Source>src/ModuleManager.py</Source>
-    <Source>src/MovePivot.py</Source>
-    <Source>src/ObjectPropertyWin.py</Source>
-    <Source>src/OgreMainWindow.py</Source>
-    <Source>src/OgreWidget.py</Source>
-    <Source>src/PreferencesDialog.py</Source>
-    <Source>src/PythonOgreConfig.py</Source>
-    <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/Property.py</Source>
-    <Source>src/ViewportGrid.py</Source>
-    <Source>src/ObjectPropertyModel.py</Source>
-    <Source>src/GameObjectClass.py</Source>
-    <Source>src/GameObjectClassManager.py</Source>
-    <Source>src/setup.py</Source>
-    <Source>src/GameObjectClassView.py</Source>
-    <Source>src/MyRaySceneQueryListener.py</Source>
-    <Source>src/GOStringEditor.py</Source>
-    <Source>src/GOIntEditor.py</Source>
-    <Source>src/CodeDump.py</Source>
-    <Source>src/NewModuleWizard.py</Source>
-    <Source>src/Ui_NewModuleWizard.py</Source>
-    <Source>src/ModuleExplorer.py</Source>
-    <Source>src/SelectionBuffer.py</Source>
-  </Sources>
-  <Forms>
-    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
-    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
-    <Form>ui files/NewModuleWizard.ui</Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>src/Lockenwickler.py</MainScript>
-  <Vcs>
-    <VcsType>None</VcsType>
-    <VcsOptions>
-      <dict>
-        <key>
-          <string>add</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>checkout</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>commit</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>diff</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>export</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>global</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>history</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>log</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>remove</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>status</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>tag</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>update</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-      </dict>
-    </VcsOptions>
-    <VcsOtherData>
-      <dict>
-        <key>
-          <string>standardLayout</string>
-        </key>
-        <value>
-          <bool>True</bool>
-        </value>
-      </dict>
-    </VcsOtherData>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2009-02-15, 13:32:17 -->
+<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.6">
+  <Language>en</Language>
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/Property.py</Source>
+    <Source>src/ViewportGrid.py</Source>
+    <Source>src/ObjectPropertyModel.py</Source>
+    <Source>src/GameObjectClass.py</Source>
+    <Source>src/GameObjectClassManager.py</Source>
+    <Source>src/setup.py</Source>
+    <Source>src/GameObjectClassView.py</Source>
+    <Source>src/MyRaySceneQueryListener.py</Source>
+    <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/CodeDump.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
+    <Source>src/Ui_NewModuleWizard.py</Source>
+    <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>Subversion</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-14 21:36:25 UTC (rev 4768)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-17 19:20:38 UTC (rev 4769)
@@ -1,325 +1,328 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-
-        self.setupUi(self)
-
-
-    def setupUi(self, Form):
-        Form.setObjectName("Form")
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName("gridlayout")
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName("splitter")
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName("ogreWidget")
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print "dbg: DragLeave"
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            data = event.mimeData().data("application/x-static_model")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            data = event.mimeData().data("application/x-game_object")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        self.moduleManager.pivot.update()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName("ogreWidget")
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print "dbg: DragLeave"
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        self.moduleManager.pivot.update()

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-14 21:36:25 UTC (rev 4768)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-17 19:20:38 UTC (rev 4769)
@@ -1,133 +1,151 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-
-        if platform.system() == "Windows" or platform.system() == "MAC":
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            import sip
-            info = self.x11Info()
-            disp =  str(sip.unwrapinstance(info.display()))
-            scr = str(info.screen())
-            win = str(int(self.winId()))
-            winHandle = disp + ':' + scr + ':' + win
-            self.renderParameters['parentWindowHandle'] = winHandle
-
-        renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
-                                                        False, self.renderParameters)
-
-        renderWindow.active = True
-        self.renderWindow = renderWindow
-
-        self.camera = self.sceneManager.createCamera(cameraName)
-        self.camera.NearClipDistance = 0.1
-
-        # Create focus node (camera always points at this)
-        self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-        self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-        # camera node is offset a ways along the Z axis of focus node
-        self.camNode = self.camFocusNode.createChildSceneNode()
-        # fix yaw on this one too for when we manipulate it directly
-        self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-        self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-        self.camNode.attachObject(self.camera)
-
-        self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-        self.viewport.setClearEveryFrame(True)
-
-    def setBackgroundColor(self, colorValue):
-        self.viewport.BackgroundColour = colorValue
-
-    def resizeEvent(self, event):
-        self.renderWindow.resize(event.size().width(), event.size().height())
-        self.renderWindow.windowMovedOrResized()
-
-        if platform.system() == "Linux":
-            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-        self.renderWindow.update(True)
-        self.ogreRoot.renderOneFrame()
-
-        if self.camera:
-            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-            
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z < self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3& trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+
+        if platform.system() == "Windows" or platform.system() == "MAC":
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            import sip
+            info = self.x11Info()
+            disp =  str(sip.unwrapinstance(info.display()))
+            scr = str(info.screen())
+            win = str(int(self.winId()))
+            winHandle = disp + ':' + scr + ':' + win
+            
+            self.renderParameters['parentWindowHandle'] = winHandle
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(cameraName)
+            self.camera.NearClipDistance = 0.1
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+
+    def resizeEvent(self, event):
+        self.renderWindow.resize(event.size().width(), event.size().height())
+        self.renderWindow.windowMovedOrResized()
+
+        if platform.system() == "Linux":
+            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+        self.renderWindow.update(True)
+        self.ogreRoot.renderOneFrame()
+
+        if self.camera:
+            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+            
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z < self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3& trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)

Modified: rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg	2009-02-14 21:36:25 UTC (rev 4768)
+++ rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg	2009-02-17 19:20:38 UTC (rev 4769)
@@ -1,8 +1,8 @@
 # Defines plugins to load
 
 # Define plugin folder
-#PluginFolder=/home/stefan/development/root/usr/lib/OGRE/
-PluginFolder=/usr/lib/OGRE
+PluginFolder=/home/fusion/development/root/usr/lib/OGRE/
+#PluginFolder=/usr/lib/OGRE
 
 # default plugins installed with the libogre14 package
 Plugin=RenderSystem_GL.so

Modified: rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2009-02-14 21:36:25 UTC (rev 4768)
+++ rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2009-02-17 19:20:38 UTC (rev 4769)
@@ -26,7 +26,7 @@
 #########################################################################
 ### Override this setting if you are using non standard locations
 
-libpath = "/home/stefan/development/root/usr/lib/"
+libpath = "/home/fusion/development/root/usr/lib/"
 
 #########################################################################
 



From fusion2 at mail.berlios.de  Tue Feb 17 21:41:11 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 17 Feb 2009 21:41:11 +0100
Subject: [Dsa-hl-svn] r4770 - in rl/trunk/editors/Lockenwickler: .
	_eric4project src
Message-ID: <200902172041.n1HKfBtn031071@sheep.berlios.de>

Author: fusion2
Date: 2009-02-17 21:41:04 +0100 (Tue, 17 Feb 2009)
New Revision: 4770

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
Log:
- more fixes for Linux

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,180 +1,180 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-02-15, 13:32:17 -->
-<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.6">
-  <Language>en</Language>
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>src/Lockenwickler.py</Source>
-    <Source>src/ConsoleWindow.py</Source>
-    <Source>src/ModelSelectionDialog.py</Source>
-    <Source>src/ModuleManager.py</Source>
-    <Source>src/MovePivot.py</Source>
-    <Source>src/ObjectPropertyWin.py</Source>
-    <Source>src/OgreMainWindow.py</Source>
-    <Source>src/OgreWidget.py</Source>
-    <Source>src/PreferencesDialog.py</Source>
-    <Source>src/PythonOgreConfig.py</Source>
-    <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/Property.py</Source>
-    <Source>src/ViewportGrid.py</Source>
-    <Source>src/ObjectPropertyModel.py</Source>
-    <Source>src/GameObjectClass.py</Source>
-    <Source>src/GameObjectClassManager.py</Source>
-    <Source>src/setup.py</Source>
-    <Source>src/GameObjectClassView.py</Source>
-    <Source>src/MyRaySceneQueryListener.py</Source>
-    <Source>src/GOStringEditor.py</Source>
-    <Source>src/GOIntEditor.py</Source>
-    <Source>src/CodeDump.py</Source>
-    <Source>src/NewModuleWizard.py</Source>
-    <Source>src/Ui_NewModuleWizard.py</Source>
-    <Source>src/ModuleExplorer.py</Source>
-    <Source>src/SelectionBuffer.py</Source>
-  </Sources>
-  <Forms>
-    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
-    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
-    <Form>ui files/NewModuleWizard.ui</Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>src/Lockenwickler.py</MainScript>
-  <Vcs>
-    <VcsType>Subversion</VcsType>
-    <VcsOptions>
-      <dict>
-        <key>
-          <string>add</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>checkout</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>commit</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>diff</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>export</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>global</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>history</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>log</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>remove</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>status</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>tag</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>update</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-      </dict>
-    </VcsOptions>
-    <VcsOtherData>
-      <dict>
-        <key>
-          <string>standardLayout</string>
-        </key>
-        <value>
-          <bool>True</bool>
-        </value>
-      </dict>
-    </VcsOtherData>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2009-02-17, 21:39:20 -->
+<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.6">
+  <Language>en</Language>
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/Property.py</Source>
+    <Source>src/ViewportGrid.py</Source>
+    <Source>src/ObjectPropertyModel.py</Source>
+    <Source>src/GameObjectClass.py</Source>
+    <Source>src/GameObjectClassManager.py</Source>
+    <Source>src/setup.py</Source>
+    <Source>src/GameObjectClassView.py</Source>
+    <Source>src/MyRaySceneQueryListener.py</Source>
+    <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/CodeDump.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
+    <Source>src/Ui_NewModuleWizard.py</Source>
+    <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>None</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-02-10, 21:36:41 -->
+<!-- Saved: 2009-02-17, 21:39:20 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-02-10, 21:36:41 -->
+<!-- Saved: 2009-02-17, 21:39:20 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: not implemented yet</Summary>
@@ -24,10 +24,10 @@
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-02-10, 12:40:21</Created>
+    <Created>2009-02-17, 21:38:59</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
-      <Linenumber>426</Linenumber>
+      <Linenumber>431</Linenumber>
     </Resource>
   </Task>
 </Tasks>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -82,7 +82,9 @@
         
         self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
         self.setWindowTitle("Rastullahs Lockenwickler")
-
+        
+        self.editorSetupFinished = False
+        
 #        splash.finish(self)
 
     def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
@@ -271,19 +273,22 @@
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
         
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
         og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
         self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
         self.moduleManager.pivot.hide()
-
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
+        self.editorSetupFinished = True
+        
     def update(self):
         self.ogreRoot.renderOneFrame()
 
     def actionOpenSlot(self):
+        self.finishEditorSetup()
         self.moduleManager.openLoadModuleDialog()
 
     def actionNewSlot(self):

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -92,15 +92,18 @@
         self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
         self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
                                                          self.splitter)
-        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        self.ogreModelPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
         
+        
         self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
         self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
         self.gridlayout.addWidget(self.splitter,1,0,1,1)
 
         self.retranslateUi()
 
-
+    def ogreViewportCreatedCallback(self):
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
     def retranslateUi(self):
         self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
 

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,328 +1,329 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-        
-        self.setupUi(self)
-
-    def setupUi(self, Form):
-        Form.setObjectName("Form")
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName("gridlayout")
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName("splitter")
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName("ogreWidget")
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-        
-        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
-        
-    def ogreViewportCreatedCallback(self):
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-        
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print "dbg: DragLeave"
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            data = event.mimeData().data("application/x-static_model")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            data = event.mimeData().data("application/x-game_object")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        self.moduleManager.pivot.update()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName("ogreWidget")
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print "dbg: DragLeave"
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-17 19:20:38 UTC (rev 4769)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-17 20:41:04 UTC (rev 4770)
@@ -1,151 +1,154 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.painted = False
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-        self.ogreViewportCreatedCallback = None
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-
-        if platform.system() == "Windows" or platform.system() == "MAC":
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            import sip
-            info = self.x11Info()
-            disp =  str(sip.unwrapinstance(info.display()))
-            scr = str(info.screen())
-            win = str(int(self.winId()))
-            winHandle = disp + ':' + scr + ':' + win
-            
-            self.renderParameters['parentWindowHandle'] = winHandle
-
-
-    def setBackgroundColor(self, colorValue):
-        if self.painted:
-            self.viewport.BackgroundColour = colorValue
-        else:
-            self.backGroundColor = colorValue
-
-    def setOgreViewportCreatedCallback(self, callback):
-        self.ogreViewportCreatedCallback = callback
-    
-    def paintEvent(self, event):
-        if not self.painted:
-            renderWindow = self.ogreRoot.createRenderWindow(renderWindowName, self.width(), self.height(),
-                                                False, self.renderParameters)
-
-            renderWindow.active = True
-            self.renderWindow = renderWindow
-            
-            self.camera = self.sceneManager.createCamera(cameraName)
-            self.camera.NearClipDistance = 0.1
-
-            # Create focus node (camera always points at this)
-            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            # camera node is offset a ways along the Z axis of focus node
-            self.camNode = self.camFocusNode.createChildSceneNode()
-            # fix yaw on this one too for when we manipulate it directly
-            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-            self.camNode.attachObject(self.camera)
-            
-            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-            self.viewport.setClearEveryFrame(True)
-            self.viewport.BackgroundColour = self.backGroundColor
-            
-            if self.ogreViewportCreatedCallback:
-                self.ogreViewportCreatedCallback()
-            
-            self.painted = True
-
-    def resizeEvent(self, event):
-        self.renderWindow.resize(event.size().width(), event.size().height())
-        self.renderWindow.windowMovedOrResized()
-
-        if platform.system() == "Linux":
-            self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-        self.renderWindow.update(True)
-        self.ogreRoot.renderOneFrame()
-
-        if self.camera:
-            self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-            
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z < self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3& trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.cameraName = cameraName
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+
+        if platform.system() == "Windows" or platform.system() == "MAC":
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            import sip
+            info = self.x11Info()
+            disp =  str(sip.unwrapinstance(info.display()))
+            scr = str(info.screen())
+            win = str(int(self.winId()))
+            winHandle = disp + ':' + scr + ':' + win
+            
+            self.renderParameters['parentWindowHandle'] = winHandle
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.1
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+
+    def resizeEvent(self, event):
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
+
+            if platform.system() == "Linux":
+                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
+
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z < self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3& trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)



From blakharaz at mail.berlios.de  Sun Feb 22 01:15:41 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 22 Feb 2009 01:15:41 +0100
Subject: [Dsa-hl-svn] r4771 - rl/trunk/engine/script
Message-ID: <200902220015.n1M0Ffov016435@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-22 01:15:32 +0100 (Sun, 22 Feb 2009)
New Revision: 4771

Modified:
   rl/trunk/engine/script/CMakeLists.txt
Log:
Enable multiple inheritance in SWIG in the cmake files

Modified: rl/trunk/engine/script/CMakeLists.txt
===================================================================
--- rl/trunk/engine/script/CMakeLists.txt	2009-02-17 20:41:04 UTC (rev 4770)
+++ rl/trunk/engine/script/CMakeLists.txt	2009-02-22 00:15:32 UTC (rev 4771)
@@ -14,7 +14,9 @@
 ${OIS_INCLUDE_DIRS}
 ${RUBY_INCLUDE_PATH})
 
-SET_SOURCE_FILES_PROPERTIES(swig/RlExports.i PROPERTIES CPLUSPLUS ON)
+SET_SOURCE_FILES_PROPERTIES(swig/RlExports.i PROPERTIES 
+	CPLUSPLUS ON
+	SWIG_FLAGS -minherit)
 
 SWIG_ADD_MODULE(RlScript RUBY
 swig/RlExports.i



From blakharaz at mail.berlios.de  Sun Feb 22 12:46:12 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 22 Feb 2009 12:46:12 +0100
Subject: [Dsa-hl-svn] r4772 - modules/common/scripts
	rl/trunk/engine/ai/include rl/trunk/engine/ai/src
	rl/trunk/engine/script/swig rl/trunk/engine/ui
	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
Message-ID: <200902221146.n1MBkCls030876@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-22 12:45:48 +0100 (Sun, 22 Feb 2009)
New Revision: 4772

Added:
   rl/trunk/engine/ui/include/DialogController.h
   rl/trunk/engine/ui/src/DialogController.cpp
Modified:
   modules/common/scripts/npc.rb
   rl/trunk/engine/ai/include/Dialog.h
   rl/trunk/engine/ai/include/DialogElement.h
   rl/trunk/engine/ai/include/DialogLoader.h
   rl/trunk/engine/ai/include/DialogLoaderImpl.h
   rl/trunk/engine/ai/include/DialogManager.h
   rl/trunk/engine/ai/include/DialogOption.h
   rl/trunk/engine/ai/include/DialogParagraph.h
   rl/trunk/engine/ai/include/DialogResponse.h
   rl/trunk/engine/ai/src/Dialog.cpp
   rl/trunk/engine/ai/src/DialogElement.cpp
   rl/trunk/engine/ai/src/DialogImplication.cpp
   rl/trunk/engine/ai/src/DialogLoader.cpp
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/DialogOption.cpp
   rl/trunk/engine/ai/src/DialogParagraph.cpp
   rl/trunk/engine/ai/src/DialogResponse.cpp
   rl/trunk/engine/ai/src/DialogVariable.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/ui/CMakeLists.txt
   rl/trunk/engine/ui/include/CutsceneControlState.h
   rl/trunk/engine/ui/include/DialogControlState.h
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
   rl/trunk/engine/ui/src/DialogControlState.cpp
Log:
Added functions to have more than 2 persons in a dialog
Refactored DialogControlState to allow some reuse in CutsceneControlState


Modified: modules/common/scripts/npc.rb
===================================================================
--- modules/common/scripts/npc.rb	2009-02-22 00:15:32 UTC (rev 4771)
+++ modules/common/scripts/npc.rb	2009-02-22 11:45:48 UTC (rev 4772)
@@ -6,7 +6,7 @@
   end
 
   def doAction(object, actor, target)
-    dialog = DialogManager::getSingleton().createDialog(object.getDialog(), object, actor)  
+    dialog = DialogManager::getSingleton().createDialog(object.getDialog(), object)  
 	  agent = AgentManager::getSingleton().createAgent(object)
 	  agent.pushState(RlScript::AST_DIALOG);
 	  agent.getCurrentState().setDialogPartner(

Modified: rl/trunk/engine/ai/include/Dialog.h
===================================================================
--- rl/trunk/engine/ai/include/Dialog.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/Dialog.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,27 +22,23 @@
 
 namespace rl
 {
+    class Creature;
     class DialogOption;
     class DialogResponse;
     class DialogVariable;
-    class Creature;
 
     class _RlAiExport Dialog : public PropertyHolder
     {
     public:
 		static const Ogre::String PROP_EXIT_REQUESTED;
 
-        Dialog(const std::vector<Creature*>& pc, const std::vector<Creature*>& npc);
+        Dialog();
         ~Dialog();
 
         DialogResponse* getDialogStart() const;
         void setStartResponse(DialogResponse* start);
         void addVariable(DialogVariable* variable);
         void initialize();
-        Creature* getNpc(int id) const;
-        Creature* getPc(int id) const;
-        std::vector<Creature*> getNonPlayerCharacters() const;
-        std::vector<Creature*> getPlayerCharacters() const;
 		bool isExitRequested() const;
         CeGuiString getVariableValue(const Ogre::String& variableName) const;
 
@@ -50,10 +46,14 @@
         virtual void setProperty(const CeGuiString& key, const Property& value);
         virtual PropertyKeys getAllPropertyKeys() const;
 
+        void addParticipant(const CeGuiString& personId, Creature* person);
+        std::list<Creature*> getParticipants() const;
+        Creature* getParticipant(const CeGuiString& id) const;
+
     private:
         DialogResponse* mDialogStart;
-        std::vector<Creature*> mNonPlayerCharacters;
-        std::vector<Creature*> mPlayerCharacters;
+        std::list<Creature*> mAllParticipants;
+        std::map<CeGuiString, Creature*> mParticipantMap;
         std::map<Ogre::String, DialogVariable*> mVariables;
         PropertyRecord mPropertyVariables;
 		bool mExitRequested;

Modified: rl/trunk/engine/ai/include/DialogElement.h
===================================================================
--- rl/trunk/engine/ai/include/DialogElement.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogElement.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -33,13 +33,17 @@
         void addParagraph(DialogParagraph* paragraph);
         virtual std::list<DialogParagraph*> getParagraphs(Dialog* dialog);
 		virtual bool isSelection() const;
+		const CeGuiString& getPerson() const;
 
     protected:
-        DialogElement(const CeGuiString& id);
+        DialogElement(const CeGuiString& id, const CeGuiString& person = "");
         virtual ~DialogElement();
 
+        virtual const CeGuiString& getDefaultPerson() const = 0;
+
     private:
         CeGuiString mId;
+        CeGuiString mPerson;
         std::list<DialogParagraph*> mParagraphs;
     };
 
@@ -66,10 +70,10 @@
         {
             return (mVariable != NULL);
         }
-            
+
         virtual const CeGuiString& getConditionVariableType()
         {
-            RlAssert(mVariable, CeGuiString("No variable found for option with id: " + DialogElementType::getId()).c_str()); 
+            RlAssert(mVariable, CeGuiString("No variable found for option with id: " + DialogElementType::getId()).c_str());
             return mVariable->getType();
         }
 

Modified: rl/trunk/engine/ai/include/DialogLoader.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoader.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogLoader.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,7 +18,9 @@
 
 #include "AiPrerequisites.h"
 
-namespace rl 
+#include <list>
+
+namespace rl
 {
 	class Creature;
     class Dialog;
@@ -29,14 +31,14 @@
 	public:
 		DialogLoader();
 		~DialogLoader();
-	
+
 		virtual const Ogre::StringVector& getScriptPatterns() const;
         virtual void parseScript(Ogre::DataStreamPtr& stream, const Ogre::String& groupName);
 		virtual Ogre::Real getLoadingOrder() const;
-		
-		Dialog* createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const;
 
-	private: 
+		Dialog* createDialog(const Ogre::String& name, const std::list<Creature*>& participants) const;
+
+	private:
         Ogre::StringVector mScriptPatterns;
         DialogLoaderImpl* mLoaderImplementation;
     };

Modified: rl/trunk/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -9,6 +9,8 @@
 
 #include "AiPrerequisites.h"
 
+#include <list>
+
 #include "Properties.h"
 #include "XmlProcessor.h"
 
@@ -24,17 +26,33 @@
     class DialogResponse;
     class DialogVariable;
 	class Property;
-    
+
     class DialogLoaderImpl : private XmlProcessor
     {
     public:
         DialogLoaderImpl();
         ~DialogLoaderImpl();
-        
-        Dialog* createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const;
+
+        Dialog* createDialog(const Ogre::String& name, const std::list<Creature*>& participants) const;
         void parseDialog(Ogre::DataStreamPtr& stream, const Ogre::String& groupName);
 
     private:
+        class DialogParticipant
+        {
+        public:
+            DialogParticipant(const CeGuiString& personId,
+                    int goId, const CeGuiString& goClass, const CeGuiString& name);
+
+            bool isMatching(Creature* go) const;
+            const CeGuiString& getPersonId() const;
+
+        private:
+            const CeGuiString& mPersonId;
+            int mGoId;
+            const CeGuiString& mGoClass;
+            const CeGuiString& mName;
+        };
+
         class DialogPrototype
         {
         public:
@@ -44,14 +62,17 @@
             DialogOption* getOption(const CeGuiString& id) const;
             void addResponse(DialogResponse* option);
             DialogResponse* getResponse(const CeGuiString& id) const;
-            
+
             void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs);
+            Dialog* createDialog(const std::list<Creature*>& participants);
             void setProperty(const CeGuiString& key, const Property& value);
-            
+
+            void addParticipant(DialogParticipant* participant);
+
         private:
             std::map<CeGuiString, DialogOption*> mOptionCache;
             std::map<CeGuiString, DialogResponse*> mResponseCache;
+            std::list<DialogParticipant*> mParticipantFilter;
             DialogResponse* mDialogStart;
             PropertyRecord mPropertyVariables;
         };
@@ -69,6 +90,7 @@
         DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
         DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
         DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
+        DialogParticipant* processPerson(XERCES_CPP_NAMESPACE::DOMElement* personXml);
         void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
         void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
         void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String& nodeName, DialogPrototype* dialogPrototype);
@@ -77,4 +99,3 @@
 
     };
 }
-

Modified: rl/trunk/engine/ai/include/DialogManager.h
===================================================================
--- rl/trunk/engine/ai/include/DialogManager.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogManager.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,6 +18,8 @@
 
 #include "AiPrerequisites.h"
 
+#include <list>
+
 #include "Properties.h"
 #include "SaveGameData.h"
 #include "XmlProcessor.h"
@@ -28,8 +30,8 @@
 	class Dialog;
 	class DialogLoader;
 
-    class _RlAiExport DialogManager 
-        : public Ogre::Singleton<DialogManager>, 
+    class _RlAiExport DialogManager
+        : public Ogre::Singleton<DialogManager>,
         public PropertyHolder,
         public SaveGameData
     {
@@ -42,8 +44,8 @@
         DialogManager();
         ~DialogManager();
 
-        Dialog* createDialog(const Ogre::String& name, rl::Creature* npc, rl::Creature* pc);
-        Dialog* createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs);
+        Dialog* createDialog(const Ogre::String& name, Creature* npc);
+        Dialog* createDialog(const Ogre::String& name, const std::list<Creature*>& npcs);
 
         virtual const Property getProperty(const CeGuiString& key) const;
         virtual void setProperty(const CeGuiString& key, const Property& value);
@@ -54,20 +56,20 @@
         virtual int getPriority() const;
 
     private:
- 
+
         class DialogConfiguration
         {
         public:
-            DialogConfiguration(const Ogre::String& name, const std::vector<Creature*>& npcs);
+            DialogConfiguration(const Ogre::String& name, const std::list<Creature*>& participants);
 
             const Ogre::String& getName() const;
-            const std::vector<Creature*>& getNpcs() const;
-            
+            const std::list<Creature*>& getParticipants() const;
+
             bool operator==(const DialogConfiguration&) const;
             bool operator<(const DialogConfiguration&) const;
         private:
             Ogre::String mDialogName;
-            std::vector<Creature*> mNpcs;
+            std::list<Creature*> mParticipants;
         };
 
 

Modified: rl/trunk/engine/ai/include/DialogOption.h
===================================================================
--- rl/trunk/engine/ai/include/DialogOption.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogOption.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -36,14 +36,12 @@
         DialogOption(const CeGuiString& id, bool isAutoSelected);
         ~DialogOption();
 
-
         const CeGuiString& getLabel() const;
         void setLabel(const CeGuiString& label);
 
+        DialogResponse* getResponse() const;
         void setResponse(DialogResponse* response);
-        DialogResponse* getResponse() const;
 
-
         void setPrecondition(DialogCondition* precondition);
         virtual const CeGuiString& getConditionVariableType();
         virtual bool isConditional();
@@ -51,13 +49,16 @@
         bool isAutoSelected() const;
         bool isAvailable(Dialog* dialog) const;
 
+    protected:
+        virtual const CeGuiString& getDefaultPerson() const;
+
     private:
         DialogResponse* mResponse;
         DialogCondition* mPrecondition;
         CeGuiString mLabel;
         bool mIsAutoSelected;
     };
-    
+
     typedef DialogSelection<DialogOption> DialogOptionSelection;
 }
 

Modified: rl/trunk/engine/ai/include/DialogParagraph.h
===================================================================
--- rl/trunk/engine/ai/include/DialogParagraph.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogParagraph.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -21,21 +21,31 @@
 
 namespace rl
 {
+    class Creature;
+    class Dialog;
+    class DialogElement;
     class DialogResponse;
 
     class _RlAiExport DialogParagraph
     {
     public:
-        DialogParagraph(const CeGuiString& text, const Ogre::String& voicefile = "");
+        DialogParagraph(const CeGuiString& text, const CeGuiString& person = "", const Ogre::String& voicefile = "");
         virtual ~DialogParagraph();
 
         const CeGuiString& getText() const;
+        const CeGuiString& getPerson() const;
         const Ogre::String& getVoiceFile() const;
+        DialogElement* getParent() const;
+        void _setParent(DialogElement* parent);
         virtual DialogResponse* getResponse() const;
+        Creature* getSpeaker(Dialog* dialog) const;
+        std::list<Creature*> getListeners(Dialog* dialog) const;
 
     private:
         CeGuiString mText;
+        CeGuiString mPerson;
         Ogre::String mVoiceFile;
+        DialogElement* mParent;
     };
 
     class _RlAiExport DialogGotoResponse : public DialogParagraph

Modified: rl/trunk/engine/ai/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/ai/include/DialogResponse.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogResponse.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -24,11 +24,11 @@
 {
     class Dialog;
     class DialogImplication;
-	class DialogOption;   
+	class DialogOption;
     class Creature;
 
     /**
-     * The reponse a DialogCharacter can give in a Dialog
+     * The response a DialogCharacter can give in a Dialog
      */
     class _RlAiExport DialogResponse : public DialogElement
     {
@@ -39,7 +39,6 @@
         DialogResponse(const CeGuiString& id, int npcId = 0);
         virtual ~DialogResponse();
 
-
         void addOption(DialogOption* option);
         void addImplication(DialogImplication* effect);
         virtual const Options& getOptions(Dialog* dialog) const;
@@ -47,14 +46,15 @@
 
         void applyImplications(Dialog* dialog);
 
-        Creature* getNpc(Dialog* dialog) const;
+    protected:
+        virtual const CeGuiString& getDefaultPerson() const;
 
     private:
         Options mOptions;
         Implications mEffects;
         int mNpcId;
     };
-    
+
     class DialogResponseSelection : public DialogSelection<DialogResponse>
     {
     public:

Modified: rl/trunk/engine/ai/src/Dialog.cpp
===================================================================
--- rl/trunk/engine/ai/src/Dialog.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/Dialog.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,14 +18,14 @@
 #include "Dialog.h"
 #include "DialogResponse.h"
 
+using namespace std;
+
 namespace rl
 {
 	const Ogre::String Dialog::PROP_EXIT_REQUESTED = "exit_requested";
 
-    Dialog::Dialog(const std::vector<Creature*>& npc, const std::vector<Creature*>& pc)
+    Dialog::Dialog()
     {
-        mNonPlayerCharacters = npc;
-        mPlayerCharacters = pc;
     }
 
     Dialog::~Dialog()
@@ -52,16 +52,6 @@
         //mVariables[vkey] = variable;
     }
 
-    Creature* Dialog::getNpc(int id) const
-    {
-        return mNonPlayerCharacters[id];
-    }
-
-    Creature* Dialog::getPc(int id) const
-    {
-        return mPlayerCharacters[id];
-    }
-
     const Property Dialog::getProperty(const CeGuiString& key) const
     {
         ///@todo dialog's state
@@ -104,14 +94,27 @@
         return getProperty(key).getAsString();
     }
 
-    std::vector<Creature*> Dialog::getNonPlayerCharacters() const
+    void Dialog::addParticipant(const CeGuiString& personId, Creature* person)
     {
-        return mNonPlayerCharacters;
+        mParticipantMap[personId] = person;
+        mAllParticipants.push_back(person);
     }
 
-    std::vector<Creature*> Dialog::getPlayerCharacters() const
+    list<Creature*> Dialog::getParticipants() const
     {
-        return mPlayerCharacters;
+        return mAllParticipants;
     }
 
+    Creature* Dialog::getParticipant(const CeGuiString& personId) const
+    {
+        map<CeGuiString, Creature*>::const_iterator it = mParticipantMap.find(personId);
+
+        if (it == mParticipantMap.end())
+        {
+            LOG_ERROR("Dialog", "Could not find participant with ID '" + personId + "'");
+            return NULL;
+        }
+
+        return it->second;
+    }
 }

Modified: rl/trunk/engine/ai/src/DialogElement.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogElement.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogElement.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -22,8 +22,8 @@
 
 namespace rl
 {
-    DialogElement::DialogElement(const CeGuiString& id)
-        : mId(id)
+    DialogElement::DialogElement(const CeGuiString& id, const CeGuiString& person)
+        : mId(id), mPerson(person)
     {
     }
 
@@ -41,9 +41,20 @@
         return mId;
     }
 
+    const CeGuiString& DialogElement::getPerson() const
+    {
+        if (mPerson.empty())
+        {
+            return getDefaultPerson();
+        }
+
+        return mPerson;
+    }
+
     void DialogElement::addParagraph(DialogParagraph* paragraph)
     {
         mParagraphs.push_back(paragraph);
+        paragraph->_setParent(this);
     }
 
     std::list<DialogParagraph*> DialogElement::getParagraphs(Dialog* dialog)
@@ -55,5 +66,4 @@
 	{
 		return false;
 	}
-
 }

Modified: rl/trunk/engine/ai/src/DialogImplication.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogImplication.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogImplication.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -37,7 +37,7 @@
     {
     }
 
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName, 
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String& variableName,
                                                        const CeGuiString& value)
         : mVariableName(variableName), mValue(value)
     {
@@ -50,7 +50,7 @@
         dialog->setProperty(mVariableName, prop);
     }
 
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName, 
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String& variableName,
                                                    const CeGuiString& value)
         : DialogVariableAssignment(variableName, value)
     {
@@ -69,13 +69,13 @@
         }
         else
         {
-            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '" 
+            LOG_ERROR(Logger::DIALOG, "You can not increase the variable '"
                                       + mVariableName
                                       + "'. The variable's type is not a number");
         }
     }
 
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName, 
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String& variableName,
                                                    const CeGuiString& value)
         : DialogVariableAssignment(variableName, value)
     {
@@ -94,13 +94,13 @@
         }
         else
         {
-            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '" 
+            LOG_ERROR(Logger::DIALOG, "You can not decrease the variable '"
                                       + mVariableName
                                       + "'. The variable's type is not a number");
         }
     }
 
-    DialogElementActivation::DialogElementActivation(const CeGuiString& id, 
+    DialogElementActivation::DialogElementActivation(const CeGuiString& id,
                                                      bool value,
                                                      bool isOption)
         : mElementId(id), mValue(value), mIsOption(isOption)
@@ -135,24 +135,25 @@
         Quest* quest = RulesSubsystem::getSingleton().getQuestBook()->getQuest(mQuestId);
         quest->setPropertyAsString(mProperty, mNewValue);
     }
-    
+
     CombatStart::CombatStart()
     {
     }
-    
+
     void CombatStart::apply(Dialog* dialog)
     {
         Combat* combat = CombatManager::getSingleton().startCombat();
-        std::vector<Creature*> allies = dialog->getPlayerCharacters();
+        ///@FIXME: fix starting combat from dialog
+/*        std::vector<Creature*> allies = dialog->getPlayerCharacters();
         for (std::vector<Creature*>::iterator it = allies.begin(); it != allies.end(); ++it)
         {
-            combat->addAlly(*it);            
+            combat->addAlly(*it);
         }
         std::vector<Creature*> enemies = dialog->getNonPlayerCharacters();
         for (std::vector<Creature*>::iterator it = enemies.begin(); it != enemies.end(); ++it)
         {
             combat->addOpponent(*it);
-        }
+        }*/
         combat->start();
     }
 

Modified: rl/trunk/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoader.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogLoader.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -29,30 +29,30 @@
         mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back("*.dialog");
   	}
-	
+
     DialogLoader::~DialogLoader()
     {
         delete mLoaderImplementation;
 	}
- 
+
     const StringVector& DialogLoader::getScriptPatterns() const
     {
         return mScriptPatterns;
     }
-    
+
 	Ogre::Real DialogLoader::getLoadingOrder() const
     {
         return 1000;
     }
-    
+
     void DialogLoader::parseScript(Ogre::DataStreamPtr& stream, const Ogre::String& groupName)
     {
         mLoaderImplementation->parseDialog(stream, groupName);
     }
-    
-    Dialog* DialogLoader::createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs) const
+
+    Dialog* DialogLoader::createDialog(const Ogre::String& name, const std::list<Creature*>& participants) const
     {
-        return mLoaderImplementation->createDialog(name, pcs, npcs);
+        return mLoaderImplementation->createDialog(name, participants);
     }
 
 }

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -13,6 +13,7 @@
 #include "DialogLoaderImpl.h"
 
 #include "ConfigurationManager.h"
+#include "Creature.h"
 #include "Dialog.h"
 #include "DialogCondition.h"
 #include "DialogElement.h"
@@ -21,9 +22,11 @@
 #include "DialogParagraph.h"
 #include "DialogResponse.h"
 #include "DialogVariable.h"
+#include "PartyManager.h"
 #include "XmlPropertyReader.h"
 
 using namespace Ogre;
+using namespace std;
 using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
@@ -32,51 +35,50 @@
     : XmlProcessor()
     {
     }
-    
+
     DialogLoaderImpl::~DialogLoaderImpl()
     {
 		std::map<Ogre::String, DialogPrototype*>::iterator itr = mDialogs.begin();
         std::map<Ogre::String, DialogPrototype*>::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
+        for (; itr != end; ++itr)
         {
 			DialogPrototype* p = itr->second;
 			delete p;
 		}
         mDialogs.clear();
 	}
-    
 
+
     void DialogLoaderImpl::parseDialog(DataStreamPtr& stream, const Ogre::String& groupName)
     {
         initializeXml();
-        
+
         DOMDocument* doc = loadDocument(stream);
         if (doc)
         {
             DOMNodeList* dialogNodes = doc->getElementsByTagName(AutoXMLCh("dialog").data());
-            
+
             for (XMLSize_t i = 0; i < dialogNodes->getLength(); ++i)
             {
                 DOMNode* cur = dialogNodes->item(i);
                 processDialog(static_cast<DOMElement*>(cur));
             }
         }
-        
+
         shutdownXml();
     }
 
-    Dialog* DialogLoaderImpl::createDialog(const String& name, const std::vector<Creature*>& pcs, 
-                                       const std::vector<Creature*>& npcs) const
+    Dialog* DialogLoaderImpl::createDialog(const String& name, const std::list<Creature*>& participants) const
     {
         std::map<Ogre::String, DialogPrototype*>::const_iterator it =
         mDialogs.find(name);
-        
+
         if (it == mDialogs.end())
         {
             return NULL;
         }
-        
-        return it->second->createDialog(pcs, npcs);
+
+        return it->second->createDialog(participants);
     }
 
     void DialogLoaderImpl::processDialog(DOMElement* dialogElem)
@@ -84,13 +86,13 @@
         DialogPrototype* dialogPrototype = new DialogPrototype();
         Ogre::String name = getAttributeValueAsStdString(dialogElem, "name");
         mDialogs[name] = dialogPrototype;
-        
+
         // first step: process all possible references
         processElementNodes(dialogElem, "option", dialogPrototype);
         processElementNodes(dialogElem, "switchoption", dialogPrototype);
         processElementNodes(dialogElem, "response", dialogPrototype);
         processElementNodes(dialogElem, "switchresponse", dialogPrototype);
-        
+
         for (DOMNode* curChild = dialogElem->getFirstChild(); curChild != NULL; curChild = curChild->getNextSibling())
         {
             if (hasNodeName(curChild, "variable"))
@@ -115,16 +117,27 @@
             }
             else if (hasNodeName(curChild, "start"))
             {
-                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL; 
+                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL;
                      curChildChild = curChildChild->getNextSibling())
                 {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
+                    DialogResponse* response = processResponseClasses(curChildChild, dialogPrototype);
                     if (response)
                     {
                         dialogPrototype->setStartResponse(response);
                     }
                 }
             }
+            else if (hasNodeName(curChild, "persons"))
+            {
+                for (DOMNode* curChildChild = curChild->getFirstChild(); curChildChild != NULL;
+                                     curChildChild = curChildChild->getNextSibling())
+                {
+                    if (hasNodeName(curChildChild, "person"))
+                    {
+                        dialogPrototype->addParticipant(processPerson(static_cast<DOMElement*>(curChildChild)));
+                    }
+                }
+            }
         }
         LOG_MESSAGE(Logger::AI, "Processed Dialog "+ name);
     }
@@ -141,7 +154,7 @@
             }
             CeGuiString id = getAttributeValueAsString(dialogElemXml, "id");
             CeGuiString text = getValueAsString(dialogElemXml);
-            
+
             if (hasNodeName(dialogElemXml, "switchoption"))
             {
                 DialogOption* option = new DialogSelection<DialogOption>(id);
@@ -171,7 +184,7 @@
                 dialogPrototype->addResponse(new DialogResponseSelection(id));
             }
         }
-        
+
     }
 
     DialogResponse* DialogLoaderImpl::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
@@ -195,17 +208,17 @@
     DialogResponse* DialogLoaderImpl::processResponse(DOMElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(responseXml, "id");
-        
+
         DialogResponse* response = dialogPrototype->getResponse(id);
-        
+
         if (!response)  Throw(IllegalArgumentException, CeGuiString("No response with ID "+ id).c_str());
-        
+
         bool languageDefined = false;
         DOMElement* defaultLanguage = NULL;
         if (subelements)
         {
             bool paragraphsDefined = false;
-            
+
             for (DOMNode* cur = responseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
             {
                 DialogOption* option = processOptionClasses(cur, dialogPrototype);
@@ -214,14 +227,14 @@
                     response->addOption(option);
                     continue;
                 }
-                
+
                 DialogImplication* implication = processImplicationClasses(cur);
                 if (implication)
                 {
                     response->addImplication(implication);
                     continue;
                 }
-                
+
                 if (hasNodeName(cur, "p"))
                 {
                     response->addParagraph(processParagraph(static_cast<DOMElement*>(cur)));
@@ -232,14 +245,14 @@
                 {
                     DOMElement* translation = static_cast<DOMElement*>(cur);
                     // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
+                    if (getAttributeValueAsStdString(translation, "language")
                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
                     {
                         processTranslation(response, translation);
                         languageDefined = true;
                     }
                     // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
+                    if (getAttributeValueAsStdString(translation, "language") == "de")
                     {
                         defaultLanguage = translation;
                     }
@@ -251,22 +264,22 @@
                     response->addParagraph(new DialogGotoResponse(dialogPrototype->getResponse(id)));
                 }
             }
-            
+
             if (!paragraphsDefined)
             {
                 CeGuiString responseXmlText = getValueAsString(responseXml);
                 response->addParagraph(new DialogParagraph(responseXmlText));
             }
-        }            
+        }
         // use german as the default language if german is not set as
         // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
+        if (!languageDefined && defaultLanguage != NULL
            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
         {
             processTranslation(response, defaultLanguage);
             languageDefined = true;
         }
-        
+
         return response;
     }
 
@@ -274,9 +287,9 @@
     {
         CeGuiString id = getAttributeValueAsString(switchRespXml, "id");
         DialogSelection<DialogResponse>* response = dynamic_cast<DialogSelection<DialogResponse>*>(dialogPrototype->getResponse(id));
-        
+
         if (!response)  Throw(IllegalArgumentException, CeGuiString("No switchresponse with ID "+ id).c_str());
-        
+
         for (DOMNode* cur = switchRespXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
         {
             DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
@@ -295,11 +308,11 @@
                         response->addElement(condition, responseCase);
                         break;
                     }
-                }               
+                }
             }
         }
-        
-        
+
+
         return response;
     }
 
@@ -324,18 +337,18 @@
     DialogOption* DialogLoaderImpl::processOption(DOMElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(optionXml, "id");
-        
+
         DialogOption* option = dialogPrototype->getOption(id);
-        
+
         if (!option)    Throw(IllegalArgumentException, CeGuiString("No option with ID "+ id).c_str());
-        
+
         bool languageDefined = false;
         DOMElement* defaultLanguage = NULL;
-        
+
         if (subelements)
         {
             bool paragraphsDefined = false;
-            
+
             for (DOMNode* cur = optionXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
             {
                 DialogResponse* response = processResponseClasses(cur, dialogPrototype);
@@ -356,28 +369,28 @@
                 else if (hasNodeName(cur, "t"))
                 {
                     DOMElement* translation = static_cast<DOMElement*>(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, "language") 
+                    // check locale
+                    if (getAttributeValueAsStdString(translation, "language")
                        == ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
                     {
                         defaultLanguage = translation;
                         processTranslation(option, translation);
                         std::string label = getAttributeValueAsStdString(translation, "label");
-                        if(!label.empty())
+                        if (!label.empty())
                         {
                             option->setLabel(label);
                         }
                         languageDefined = true;
                     }
                     // set german as default language
-                    if(getAttributeValueAsStdString(translation, "language") == "de")
+                    if (getAttributeValueAsStdString(translation, "language") == "de")
                     {
                         defaultLanguage = translation;
                     }
                     paragraphsDefined = true;
                 }
             }
-            
+
             if (!paragraphsDefined)
             {
                 CeGuiString optionXmlText = getValueAsString(optionXml);
@@ -386,18 +399,18 @@
         }
         // use german as the default language if german is not set as
         // default language but no other language was found!
-        if(!languageDefined && defaultLanguage != NULL 
+        if (!languageDefined && defaultLanguage != NULL
            && ConfigurationManager::getSingleton().getStringSetting("Localization", "language") != "de")
         {
             processTranslation(option, defaultLanguage);
             std::string label = getAttributeValueAsStdString(defaultLanguage, "label");
-            if(!label.empty())
+            if (!label.empty())
             {
                 option->setLabel(label);
             }
             languageDefined = true;
         }
-        
+
         return option;
     }
 
@@ -405,9 +418,9 @@
     {
         CeGuiString id = getAttributeValueAsString(switchOptXml, "id");
         DialogOptionSelection* option = dynamic_cast<DialogOptionSelection*>(dialogPrototype->getOption(id));
-        
+
         if (!option) Throw(IllegalArgumentException, CeGuiString("No switchoption with ID "+ id).c_str());
-        
+
         for (DOMNode* cur = switchOptXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
         {
             DialogVariable* variable = processVariableClasses(static_cast<DOMElement*>(cur));
@@ -426,25 +439,25 @@
                         option->addElement(condition, optionCase);
                         break;
                     }
-                }               
+                }
             }
             // process translations
             else if (hasNodeName(cur, "t"))
             {
                 DOMElement* translation = static_cast<DOMElement*>(cur);
                 // check loca
-                if(getAttributeValueAsStdString(translation, "language") == 
+                if (getAttributeValueAsStdString(translation, "language") ==
                    ConfigurationManager::getSingleton().getStringSetting("Localization", "language"))
                 {
                     std::string label = getAttributeValueAsStdString(translation, "label");
-                    if(!label.empty())
+                    if (!label.empty())
                     {
                         option->setLabel(label);
                     }
-                } 
+                }
             }
         }
-        
+
         return option;
     }
 
@@ -459,19 +472,19 @@
     {
         DialogCondition* cond = NULL;
         DialogVariable* var = NULL;
-        
+
         for (DOMNode* cur = ifXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
         {
             if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
             {
                 DOMElement* curElem = static_cast<DOMElement*>(cur);
-                
+
                 DialogCondition* curCond = processConditionClasses(curElem);
                 if (curCond)
                 {
                     cond = curCond;
                 }
-                
+
                 DialogVariable* curVar = processVariableClasses(curElem);
                 if (curVar)
                 {
@@ -479,7 +492,7 @@
                 }
             }
         }
-        
+
         cond->setVariable(var);
         return cond;
     }
@@ -497,7 +510,7 @@
     DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
     {
         DialogCondition* cond = NULL;
-        
+
         for (DOMNode* cur = caseXml->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
         {
             if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
@@ -509,7 +522,7 @@
                 }
             }
         }
-        
+
         return cond;
     }
 
@@ -520,13 +533,13 @@
     DialogLoaderImpl::DialogPrototype::~DialogPrototype()
     {
         std::map<CeGuiString, DialogOption*>::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it->second != NULL )
+        for (it = mOptionCache.begin(); it != mOptionCache.end(); it++)
+            if (it->second != NULL)
                 delete it->second;
-        
+
         std::map<CeGuiString, DialogResponse*>::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1->second != NULL )
+        for (it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++)
+            if (it1->second != NULL)
                 delete it1->second;
     }
 
@@ -534,7 +547,7 @@
     {
         if (mOptionCache.find(option->getId()) != mOptionCache.end())
         {
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
                   CeGuiString("Duplicate option/switchoption ID "+ option->getId()).c_str());
         }
         mOptionCache[option->getId()] = option;
@@ -554,7 +567,7 @@
     {
         if (mResponseCache.find(response->getId()) != mResponseCache.end())
         {
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
                   CeGuiString("Duplicate Response/switchResponse ID "+ response->getId()).c_str());
         }
         mResponseCache[response->getId()] = response;
@@ -570,17 +583,58 @@
         return it->second;
     }
 
-    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs)
+    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const list<Creature*>& participants)
     {
-        Dialog* dialog = new Dialog(pcs, npcs);
+        Dialog* dialog = new Dialog();
+
+        // for easy 1pc-1nsc dialogs (active player is "player", one NSC is "nsc")
+        Creature* player = PartyManager::getSingleton().getActiveCharacter();
+        dialog->addParticipant("player", player);
+
+        bool found1stNpc = false;
+        Party playerChars = PartyManager::getSingleton().getCharacters();
+
+        for (list<Creature*>::const_iterator itPart = participants.begin(); itPart != participants.end(); ++itPart)
+        {
+            Creature* curCr = *itPart;
+
+            if (!found1stNpc)
+            {
+                bool isInParty = false;
+                for (Party::iterator itParty = playerChars.begin(); itParty != playerChars.end(); ++itParty)
+                {
+                    if (*itParty == curCr)
+                    {
+                        isInParty = true;
+                        break;
+                    }
+                }
+
+                if (!isInParty)
+                {
+                    dialog->addParticipant("nsc", curCr);
+                    found1stNpc = true;
+                }
+            }
+
+
+            for (list<DialogLoaderImpl::DialogParticipant*>::iterator it = mParticipantFilter.begin();
+                    it != mParticipantFilter.end(); ++it)
+            {
+                if ((*it)->isMatching(curCr))
+                {
+                    dialog->addParticipant((*it)->getPersonId(), curCr);
+                }
+            }
+        }
         dialog->setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
+
+        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin();
              it != mPropertyVariables.end(); ++it)
         {
             dialog->setProperty(it->first, it->second);
         }
-        
+
         return dialog;
     }
 
@@ -594,7 +648,29 @@
         mDialogStart = start;
     }
 
+    void DialogLoaderImpl::DialogPrototype::addParticipant(DialogLoaderImpl::DialogParticipant* participant)
+    {
+        mParticipantFilter.push_back(participant);
+    }
 
+    DialogLoaderImpl::DialogParticipant::DialogParticipant(const CeGuiString& personId, int goId,
+            const CeGuiString& goClass, const CeGuiString& name)
+        : mPersonId(personId), mGoId(goId), mGoClass(goClass), mName(name)
+    {
+    }
+
+    const CeGuiString& DialogLoaderImpl::DialogParticipant::getPersonId() const
+    {
+        return mPersonId;
+    }
+
+    bool DialogLoaderImpl::DialogParticipant::isMatching(Creature* creature) const
+    {
+        return (mGoId == -1 || creature->getId() == mGoId)
+            && (mGoClass.empty() || creature->getClassId() == mGoClass)
+            && (mName.empty() || creature->getName() == mName);
+    }
+
     DialogCondition* DialogLoaderImpl::processConditionClasses(DOMElement* conditionXml)
     {
         if (hasNodeName(conditionXml, "equals"))
@@ -628,7 +704,7 @@
             return new DialogConditionGreaterOrEquals(
                                                       getAttributeValueAsReal(conditionXml, "value"));
         }
-        
+
         return NULL;
     }
 
@@ -671,7 +747,7 @@
             int maximum = getAttributeValueAsInteger(variableXml, "maximum");
             return new RandomVariable(maximum);
         }
-        
+
         return NULL;
     }
 
@@ -681,7 +757,7 @@
         if (implicationXml->getNodeType() == DOMNode::ELEMENT_NODE)
         {
             DOMElement* implicationElem = static_cast<DOMElement*>(implicationXml);
-            
+
             if (hasNodeName(implicationElem, "setvariable"))
             {
                 Ogre::String variableName = getAttributeValueAsStdString(implicationElem, "name");
@@ -722,7 +798,7 @@
                 return new CombatStart();
             }
         }
-        
+
         return NULL;
     }
 
@@ -736,6 +812,36 @@
             }
         }
     }
-    
+
+    DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(DOMElement* personXml)
+    {
+        CeGuiString personId(""), goClass(""), name("");
+        int goId = -1;
+
+        if (hasAttribute(personXml, "id"))
+        {
+            personId = getAttributeValueAsString(personXml, "id");
+        }
+        else
+        {
+            LOG_ERROR("DialogLoader", "person node without id found");
+        }
+
+        if (hasAttribute(personXml, "goId"))
+        {
+            goId = getAttributeValueAsInteger(personXml, "goId");
+        }
+        if (hasAttribute(personXml, "goClass"))
+        {
+            goClass = getAttributeValueAsString(personXml, "goClass");
+        }
+        if (hasAttribute(personXml, "name"))
+        {
+            name = getAttributeValueAsString(personXml, "name");
+        }
+
+        return new DialogParticipant(personId, goId, goClass, name);
+    }
+
 }
 

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,9 +22,11 @@
 #include "Dialog.h"
 #include "DialogLoader.h"
 #include "GameObjectManager.h"
+#include "PartyManager.h"
 #include "SaveGameManager.h"
 
 using namespace Ogre;
+using namespace std;
 using namespace XERCES_CPP_NAMESPACE;
 
 template<>
@@ -51,8 +53,8 @@
 			mDialogLoader);
 		delete mDialogLoader;
         SaveGameManager::getSingleton().unregisterSaveGameData(this);
-		std::map<DialogConfiguration, Dialog*>::iterator itr = mDialogStates.begin();
-		std::map<DialogConfiguration, Dialog*>::iterator end = mDialogStates.end();
+		map<DialogConfiguration, Dialog*>::iterator itr = mDialogStates.begin();
+		map<DialogConfiguration, Dialog*>::iterator end = mDialogStates.end();
 		for(; itr != end; ++itr)
 		{
 			delete itr->second;
@@ -66,7 +68,7 @@
         if (key == DialogManager::PROPERTY_DIALOGS)
         {
             PropertyArray vec;
-            for (std::map<DialogConfiguration, Dialog*>::const_iterator it
+            for (map<DialogConfiguration, Dialog*>::const_iterator it
                 = mDialogStates.begin(); it != mDialogStates.end(); ++it)
             {
                 PropertyMap curDialogProp;
@@ -76,8 +78,8 @@
 
                 PropertyArray npcs;
 
-                for (std::vector<Creature*>::const_iterator itNpc = it->first.getNpcs().begin();
-                    itNpc != it->first.getNpcs().end(); ++itNpc)
+                for (list<Creature*>::const_iterator itNpc = it->first.getParticipants().begin();
+                    itNpc != it->first.getParticipants().end(); ++itNpc)
                 {
                     npcs.push_back(GameObjectManager::getSingleton().toProperty(*itNpc));
                 }
@@ -90,7 +92,7 @@
 
         Throw(IllegalArgumentException, key + " is not a property of DialogManager");
     }
-	
+
 	int DialogManager::getPriority() const
 	{
 		return 50;
@@ -129,43 +131,55 @@
         return "dialogs";
     }
 
-    Dialog* DialogManager::createDialog(const Ogre::String& name, Creature* npc, Creature* pc)
+    Dialog* DialogManager::createDialog(const Ogre::String& name, Creature* npc)
     {
-        std::vector<Creature*> npcs;
+        list<Creature*> npcs;
         npcs.push_back(npc);
-        std::vector<Creature*> pcs;
-        pcs.push_back(pc);
 
-        return createDialog(name, npcs, pcs);
+        return createDialog(name, npcs);
     }
 
-    Dialog* DialogManager::createDialog(const Ogre::String& name, const std::vector<Creature*>& pcs, const std::vector<Creature*>& npcs)
+    Dialog* DialogManager::createDialog(const Ogre::String& name, const list<Creature*>& npcs)
     {
-        std::map<DialogConfiguration, Dialog*>::iterator it 
-            = mDialogStates.find(DialogConfiguration(name, npcs));
+        list<Creature*> participants;
 
+        Party party = PartyManager::getSingleton().getCharacters();
+        for (Party::const_iterator it = party.begin(); it != party.end(); ++it)
+        {
+            participants.push_back(*it);
+        }
+
+        for (list<Creature*>::const_iterator it = npcs.begin(); it != npcs.end(); ++it)
+        {
+            participants.push_back(*it);
+        }
+
+        map<DialogConfiguration, Dialog*>::iterator it
+            = mDialogStates.find(DialogConfiguration(name, participants));
+
         Dialog* dialog;
         if (it != mDialogStates.end())
         {
             dialog = (*it).second;
         }
-        else 
+        else
         {
-			dialog = mDialogLoader->createDialog(name, pcs, npcs); ///@todo save dialogs
-			
-			if (!dialog) 
+			dialog = mDialogLoader->createDialog(name, participants); ///@todo save dialogs
+
+			if (!dialog)
 			{
 				return NULL;
 			}
-			
+
             dialog->initialize();
-            mDialogStates[DialogConfiguration(name, npcs)] = dialog;
+            mDialogStates[DialogConfiguration(name, participants)] = dialog;
         }
 		return dialog;
     }
-	
-    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String& name, const std::vector<Creature*>& npcs)
-        : mDialogName(name), mNpcs(npcs)
+
+    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String& name,
+            const list<Creature*>& participants)
+        : mDialogName(name), mParticipants(participants)
     {
     }
 
@@ -174,9 +188,9 @@
         return mDialogName;
     }
 
-    const std::vector<Creature*>& DialogManager::DialogConfiguration::getNpcs() const
+    const list<Creature*>& DialogManager::DialogConfiguration::getParticipants() const
     {
-        return mNpcs;
+        return mParticipants;
     }
 
     bool DialogManager::DialogConfiguration::operator <(const rl::DialogManager::DialogConfiguration & other) const
@@ -186,8 +200,8 @@
 
     bool DialogManager::DialogConfiguration::operator ==(const rl::DialogManager::DialogConfiguration & other) const
     {
-        return (mDialogName == other.mDialogName) 
-            && (mNpcs == other.mNpcs);
+        return (mDialogName == other.mDialogName)
+            && (mParticipants == other.mParticipants);
     }
 
 

Modified: rl/trunk/engine/ai/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogOption.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogOption.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -48,7 +48,7 @@
 
     const CeGuiString& DialogOption::getConditionVariableType()
     {
-        RlAssert(mPrecondition, CeGuiString("No precondition found for option with id: " 
+        RlAssert(mPrecondition, CeGuiString("No precondition found for option with id: "
                                 + getId()
                                 + "\nA precondition must be set to get its variable type").c_str());
         return mPrecondition->getVariableType();
@@ -67,7 +67,7 @@
     bool DialogOption::isAvailable(Dialog* dialog) const
     {
         bool isActive = true;
-        
+
         if(dialog->getAllProperties()->hasProperty("option" + getId() + "isActive"))
         {
             isActive = dialog->getProperty("option" + getId() + "isActive");
@@ -97,4 +97,9 @@
         return mLabel;
     }
 
+    const CeGuiString& DialogOption::getDefaultPerson() const
+    {
+        static CeGuiString PLAYER = "player";
+        return PLAYER;
+    }
 }

Modified: rl/trunk/engine/ai/src/DialogParagraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogParagraph.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogParagraph.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -17,12 +17,17 @@
 
 #include "DialogParagraph.h"
 
+#include "Dialog.h"
+#include "DialogElement.h"
+
+using namespace std;
+
 namespace rl
 {
 
     DialogParagraph::DialogParagraph(
-        const CeGuiString& text, const Ogre::String& voicefile)
-    : mText(text), mVoiceFile(voicefile)
+        const CeGuiString& text, const CeGuiString& person, const Ogre::String& voicefile)
+    : mText(text), mPerson(person), mVoiceFile(voicefile), mParent(NULL)
     {
         // for debug information
         mText.c_str();
@@ -37,6 +42,15 @@
         return mText;
     }
 
+    const CeGuiString& DialogParagraph::getPerson() const
+    {
+        if (mPerson.empty())
+        {
+            return mParent->getPerson();
+        }
+        return mPerson;
+    }
+
     const Ogre::String& DialogParagraph::getVoiceFile() const
     {
         return mVoiceFile;
@@ -47,8 +61,41 @@
         return NULL;
     }
 
+    DialogElement* DialogParagraph::getParent() const
+    {
+        return mParent;
+    }
+
+    void DialogParagraph::_setParent(DialogElement* parent)
+    {
+        mParent = parent;
+    }
+
+    Creature* DialogParagraph::getSpeaker(Dialog* dialog) const
+    {
+        return dialog->getParticipant(getPerson());
+    }
+
+    list<Creature*> DialogParagraph::getListeners(Dialog* dialog) const
+    {
+        Creature* speaker = getSpeaker(dialog);
+
+        list<Creature*> listeners;
+
+        list<Creature*> participants = dialog->getParticipants();
+        for (list<Creature*>::iterator it = participants.begin(), end = participants.end(); it != end; ++it)
+        {
+            if (*it != speaker)
+            {
+                listeners.push_back(*it);
+            }
+        }
+
+        return listeners;
+    }
+
     DialogGotoResponse::DialogGotoResponse(rl::DialogResponse *response)
-        : DialogParagraph("", ""), mResponse(response)
+        : DialogParagraph("", "", ""), mResponse(response)
     {
     }
 
@@ -57,4 +104,3 @@
         return mResponse;
     }
 }
-

Modified: rl/trunk/engine/ai/src/DialogResponse.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogResponse.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogResponse.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -31,8 +31,8 @@
     DialogResponse::~DialogResponse()
     {
     }
-    
 
+
     void DialogResponse::addOption(rl::DialogOption *option)
     {
         mOptions.push_back(option);
@@ -77,9 +77,10 @@
         }
     }
 
-    Creature* DialogResponse::getNpc(rl::Dialog *dialog) const
+    const CeGuiString& DialogResponse::getDefaultPerson() const
     {
-        return dialog->getNpc(mNpcId);
+        static CeGuiString PERSON = "npc";
+        return PERSON;
     }
 
     DialogResponseSelection::DialogResponseSelection(const CeGuiString& id)

Modified: rl/trunk/engine/ai/src/DialogVariable.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogVariable.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogVariable.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -81,19 +81,16 @@
 
     Property TalentProbeVariable::calculateValue(Dialog* dialog)
     {
-        Creature* cr = NULL;
-        if(mTarget == "pc")
+        Creature* cr = dialog->getParticipant(mTarget);
+        if (cr == NULL)
         {
-            cr = dialog->getPc(0); ///@todo allow multiple PCs
+            LOG_ERROR("Dialog", "No or wrong target for talent check ' " + mTalent + "'");
+            return Property(-1);
         }
-        else if (mTarget == "npc")
+        else
         {
-            cr = dialog->getNpc(0);
+            return Property(cr->doTalentprobe(mTalent, mModifier));
         }
-        // if no target was given, use the player character. 
-        // @todo: remove this, target should be required!
-        if(cr == NULL) { cr = dialog->getPc(0);}
-        return Property(cr->doTalentprobe(mTalent, mModifier));
     }
 
     EigenschaftsProbeVariable::EigenschaftsProbeVariable(const rl::CeGuiString &eigenschaft, int modifier, const rl::CeGuiString& target)
@@ -103,26 +100,25 @@
 
     Property EigenschaftsProbeVariable::calculateValue(Dialog* dialog)
     {
-        Creature* cr = NULL;
-        if(mTarget == "pc")
+        Creature* cr = dialog->getParticipant(mTarget);
+        // if no target was given, use the player character.
+        // @todo: remove this, target should be required!
+        if (cr == NULL)
         {
-            cr = dialog->getPc(0); ///@todo allow multiple PCs
+            LOG_ERROR("Dialog", "No or wrong target for attribute check ' " + mEigenschaft + "'");
+            return Property(-1);
         }
-        else if (mTarget == "npc")
+        else
         {
-            cr = dialog->getNpc(0);
+            return Property(cr->doEigenschaftsprobe(mEigenschaft, mModifier));
         }
-        // if no target was given, use the player character. 
-        // @todo: remove this, target should be required!
-        if(cr == NULL) { cr = dialog->getPc(0);}
-        return Property(cr->doEigenschaftsprobe(mEigenschaft, mModifier));
     }
-	
+
 	RandomVariable::RandomVariable(int maximum)
 		: DialogVariable("random"), mMaximum(maximum)
 	{
 	}
-	
+
 	Property RandomVariable::calculateValue(Dialog* dialog)
 	{
 		double d = std::rand();

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/script/swig/RlAi.swig	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -20,7 +20,7 @@
 	%template(Ogrevec3Vector) vector<Ogre::Vector3 >;
 };
 
-namespace rl 
+namespace rl
 {
 	// Before first use
 	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
@@ -44,7 +44,7 @@
 		bool isAhead(rl::Agent* agent, const float threshold);
 		bool needAvoidance(const float minTimeToCollision);
 	};
-	
+
 	%feature("director") SteeringBehaviour;
 	class SteeringBehaviour
 	{
@@ -58,28 +58,28 @@
 		virtual void update(const float elapsedTime)=0;
 
 		virtual float calculateActivation()=0;
-		
+
 		float getActivationLevel();
 		void setActivationLevel(float activationLevel);
 
 		rl::SteeringBehaviour* getParent();
 		rl::SteeringVehicle* getController();
 	};
-	
+
 	%feature("director") AgentState;
     class AgentState
     {
     private:
         AgentState(rl::Agent* agent);
     };
-    
-    
+
+
     class AgentSteeringState : public rl::AgentState
     {
     public:
         void addSteeringBehaviour(SteeringBehaviour* behaviour);
     };
-   
+
     class AgentDialogState : public rl::AgentState
     {
     public:
@@ -90,7 +90,7 @@
     };
 
     typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
-	
+
 	class Agent
 	{
 	public:
@@ -101,12 +101,12 @@
         void pushState(rl::AgentStateType type);
 	};
 
-	class AiSubsystem 
+	class AiSubsystem
 	{
 	public:
 		static AiSubsystem& getSingleton(void);
 	};
-	
+
 	%feature("director") BehaviourFactory;
     class BehaviourFactory
     {
@@ -116,16 +116,16 @@
 
         virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
     };
-    
+
 	class AgentManager
 	{
-	public:		
+	public:
 		static AgentManager& getSingleton(void);
 		rl::Agent* createAgent(rl::Creature* character);
-		
+
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};
-	
+
 	class AStarHeuristic
 	{
 	public:
@@ -133,7 +133,7 @@
 		virtual ~AStarHeuristic();
 		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const = 0;
 	};
-	
+
 	class ManhattanDistance
 		: public rl::AStarHeuristic
 	{
@@ -168,26 +168,26 @@
 		EuclideanDistanceSquared();
 		virtual ~EuclideanDistanceSquared();
 		virtual float calcDistance(const Ogre::Vector3& vec1, const Ogre::Vector3& vec2) const;
-	}; 
-	
+	};
+
 	class AStarCosts
 	{
 	public:
-		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
+		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
 		virtual ~AStarCosts();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const = 0;
 	};
-	
+
 	class AStarCostsDefault : public AStarCosts
 	{
 	public:
-		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
+		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
 		~AStarCostsDefault();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const;
 	};
-	
+
 	class AStar
 	{
 	public:
@@ -195,40 +195,40 @@
 		//AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
 		//	const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
 		virtual ~AStar();
-		
+
 		void search(std::vector<Ogre::Vector3>& resultPath);
 		void searchFromTo(std::vector<Ogre::Vector3>& resultPath,
 			const Ogre::Vector3& StartPos, const Ogre::Vector3& EndPos );
 		void reset();
 	};
-	
+
     class PhysicalObstacle {
-        
+
         public:
             PhysicalObstacle(rl::PhysicalThing *thing);
             virtual ~PhysicalObstacle();
-            
+
             OpenSteer::Obstacle *getObstacle() const;
-            
+
             rl::PhysicalThing *getPhysicalThing() const;
             void setPhysicalThing(rl::PhysicalThing *thing);
     };
-    
+
     class WayPointNode
 	{
 	public:
-		enum WayPointNodeType 
+		enum WayPointNodeType
 		{
 			WP_UNKNOWN = 0,
 			WP_EXTERIOR = 1,
 			WP_INTERIOR = 2
 		};
-		
+
 		WayPointNode(const Ogre::Vector3& pos, const rl::WayPointNode::WayPointNodeType type);
 		Ogre::Vector3 getPosition() const;
 	};
-	
-	class WayPointGraph 
+
+	class WayPointGraph
 	{
 	public:
 		WayPointNode* addWayPoint(const Ogre::Vector3& position, const WayPointNode::WayPointNodeType type);
@@ -238,14 +238,14 @@
 		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3& position) const;
 		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
 	};
-	
-	class WayPointGraphManager 
+
+	class WayPointGraphManager
 	{
 	public:
 		static WayPointGraphManager& getSingleton(void);
 		rl::WayPointGraph* createWayPointGraph();
 	};
-	
+
 	class Landmark
 	{
 	public:
@@ -253,7 +253,7 @@
 		const Ogre::String& getName() const;
 		const Ogre::Vector3& getPosition() const;
 	};
-	
+
 	class LandmarkPath
 	{
 	public:
@@ -264,7 +264,7 @@
 		void addPoint(rl::Landmark* lm);
         rl::LandmarkPath::LandmarkList getPoints();
 	};
-	
+
     class WalkPathBehaviour : public rl::SteeringBehaviour
 	{
 	public:
@@ -280,7 +280,7 @@
 
 		virtual float calculateActivation();
 	};
-	
+
 	class CreatureWalkPathJob : public Job
     {
     public:
@@ -301,8 +301,8 @@
     {
     public:
         static rl::DialogManager& getSingleton();
-        rl::Dialog* createDialog(const Ogre::String& name, rl::Creature* npc, rl::Creature* pc);
-        rl::Dialog* createDialog(const Ogre::String& name, const std::vector<rl::Creature*>& npcs, const std::vector<rl::Creature*>& pcs);
+        rl::Dialog* createDialog(const Ogre::String& name, rl::Creature* npc);
+        rl::Dialog* createDialog(const Ogre::String& name, const std::list<rl::Creature*>& npcs);
     private:
         DialogManager();
     };
@@ -337,7 +337,7 @@
         *ptr=pEuclideanDistanceSquared;
         return SWIGTYPE_p_rl__EuclideanDistanceSquared;
     }
-   
+
     return 0;
 }
 %}
@@ -355,7 +355,7 @@
         *ptr=pAStarCostsDefault;
         return SWIGTYPE_p_rl__AStarCostsDefault;
     }
-   
+
     return 0;
 }
 %}
@@ -373,14 +373,14 @@
         *ptr=pAgentDialogState;
         return SWIGTYPE_p_rl__AgentDialogState;
     }
-    
+
     rl::AgentSteeringState *pAgentSteeringState = dynamic_cast<rl::AgentSteeringState*>(pAgentState);
     if (pAgentSteeringState)
     {
         *ptr=pAgentSteeringState;
         return SWIGTYPE_p_rl__AgentSteeringState;
     }
-   
+
     return 0;
 }
 %}

Modified: rl/trunk/engine/ui/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ui/CMakeLists.txt	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/CMakeLists.txt	2009-02-22 11:45:48 UTC (rev 4772)
@@ -29,6 +29,7 @@
 src/Console.cpp
 src/CutsceneControlState.cpp
 src/DebugWindow.cpp
+src/DialogController.cpp
 src/DialogControlState.cpp
 src/DialogWindow.cpp
 src/FreeflightControlState.cpp

Modified: rl/trunk/engine/ui/include/CutsceneControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneControlState.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/include/CutsceneControlState.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -61,6 +61,7 @@
         void addCamera(const Ogre::Vector3& position, const Ogre::Quaternion& orientation);
         void addCamera(const Ogre::Vector3& position, const Ogre::Quaternion& orientation1,
                        const Ogre::Quaternion& orientation2);
+        void clearCameras();
 
 	private:
 	    std::vector<CameraPosition> mPositions;

Modified: rl/trunk/engine/ui/include/DialogControlState.h
===================================================================
--- rl/trunk/engine/ui/include/DialogControlState.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/include/DialogControlState.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,33 +18,29 @@
 #define __DialogCharacterController_H__
 
 #include "UiPrerequisites.h"
-#include "ControlState.h"
+#include "DialogController.h"
 
-
 namespace rl {
 
 	class Actor;
+    class Creature;
 	class Dialog;
     class DialogElement;
-	class DialogOption;
-	class DialogParagraph;
-	class DialogResponse;
 	class DialogWindow;
 	class GameLoggerWindow;
-    class GameObject;
 	class MeshAnimation;
 	class SoundObject;
 	class SubtitleWindow;
 
-	/** Diese Klasse 
-	  *  
+	/** Diese Klasse
+	  *
 	  */
-	class _RlUiExport DialogControlState : public ControlState
+	class _RlUiExport DialogControlState : public DialogController
 	{
 	public:
         enum DialogMode
-		{ 
-            // Frontperspektive auf Augenh?he, ausgehend von der Mitte zwischen den Redenden
+		{
+            // Frontperspektive auf Augenh???he, ausgehend von der Mitte zwischen den Redenden
 			DM_FRONT = 1,
 		};
 
@@ -54,7 +50,7 @@
 		*  @throw InvalidArgumentException if character is not placed in the scene.
 		*/
 		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Creature* character);
-		/// Dtor 
+		/// Dtor
 		virtual ~DialogControlState();
 
         virtual void pause();
@@ -65,71 +61,40 @@
 
 		void start(Dialog* dialog);
 
-		/// Antwort eines der Dialogf?hrenden
+		/// Antwort eines der Dialogf???hrenden
 		void response(Actor* actor, const CeGuiString& text, const Ogre::String& soundFile = "");
 
-        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id, bool handled);
-
-		bool handleDialogSelectOption(DialogOption* option);	
-		bool handleDialogClose();
+		bool handleDialogSelectOption(DialogOption* option);
+		virtual void handleDialogEnd();
 		bool requestDialogClose();
+	    virtual bool textFinished();
 
 	private:
+        enum DialogState
+        {
+            CHOOSING_OPTION = 1,
+            TALKING_PARTNER_CHARACTER,
+            TALKING_PLAYER_CHARACTER,
+            CLOSING_DIALOG
+        };
+
 		/// Die Zielkameraposition in lokalen Koordinaten
 		Ogre::Vector3 mTargetCameraPosition;
-		/// Die ben?tigte lokale Drehung der Kamera
+		/// Die ben???tigte lokale Drehung der Kamera
 		Ogre::Vector3 mTargetCameraDirection;
 
-		/// Die aktuelle Zeit f?r die Textanzeige
-		Ogre::Real mCurrFadeTextTime;
-        /// Die Zeit bis der Text ausgeblendet wird
-        Ogre::Real mTotalFadeTextTime;
 
-        Ogre::Real mSubtitleSpeed;
-
-		/// Der Untertitel-Text
-		CeGuiString mText;
-		/// Es wird gerade Text angezeigt
-		bool mTextShown;
-
-		GameObject* mCurrentSpeaker;
-		GameObject* mCurrentListener;
-        DialogResponse* mCurrentResponse;
-        DialogOption* mCurrentOption;
-        std::list<DialogParagraph*> mCurrentParagraphs;
-
-        /// Die Art der Kamerapositinierung
+        /// Die Art der Kamerapositionierung
         DialogMode mDialogMode;
 
-		MeshAnimation* mTalkAnimation;
+        DialogState mDialogState;
 
+
 		DialogWindow* mDialogWindow;
-		SubtitleWindow* mSubtitleWindow;
-		SoundObject* mSoundObject;
-	
-		float getShowTextLength(const CeGuiString& text) const;
-        void recalculateCamera(GameObject* speaker, GameObject* listener);
-        void processTextVariables(CeGuiString& text);
 
-		enum DialogState
-		{
-			CHOOSING_OPTION = 1,
-			TALKING_PARTNER_CHARACTER,
-			TALKING_PLAYER_CHARACTER,
-			CLOSING_DIALOG
-		};
+        virtual void recalculateDialogCamera(Creature* speaker, std::list<Creature*> listeners);
 
-		Dialog* mDialog;
-		GameLoggerWindow* mGameLogger;
-		DialogState mState;
-		CeGuiString mCurrentResponseText;
-				
-        void showResponse(DialogResponse* response);
         void showOptions(const std::list<DialogOption*>& options);
-        void doTalk(DialogParagraph* paragraph);
-        Ogre::Vector3 getParticipantPosition(GameObject* participant);
-
-		void textFinished();
 	};
 }
 #endif

Added: rl/trunk/engine/ui/include/DialogController.h
===================================================================
--- rl/trunk/engine/ui/include/DialogController.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/include/DialogController.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -0,0 +1,81 @@
+/*
+ * DialogController.h
+ *
+ *  Created on: 15.02.2009
+ *      Author: blakharaz
+ */
+
+#ifndef DIALOGCONTROLLER_H_
+#define DIALOGCONTROLLER_H_
+
+#include "AiPrerequisites.h"
+
+#include <list>
+
+#include "ControlState.h"
+
+namespace rl
+{
+    class Actor;
+    class Creature;
+    class Dialog;
+    class DialogOption;
+    class DialogParagraph;
+    class DialogResponse;
+    class DialogWindow;
+    class GameLoggerWindow;
+    class MeshAnimation;
+    class SoundObject;
+    class SubtitleWindow;
+
+    class DialogController : public ControlState
+    {
+    public:
+        virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id, bool handled);
+
+    protected:
+        DialogController(CommandMapper* commandMapper, Actor* camera, Creature* character,
+                ControlStateType type);
+        virtual ~DialogController();
+
+        void showResponse(DialogResponse* response, DialogWindow* window = NULL);
+        void doTalk(DialogParagraph* paragraph, DialogWindow* window = NULL);
+        Ogre::Vector3 getParticipantPosition(Creature* participant);
+        virtual bool textFinished();
+        virtual void recalculateDialogCamera(Creature* speaker, std::list<Creature*> listeners) = 0;
+        virtual void handleDialogEnd() = 0;
+        void setDialogWindow(DialogWindow* window);
+        void setSubtitleWindow(SubtitleWindow* window);
+        virtual void pause();
+
+         SubtitleWindow* mSubtitleWindow;
+        DialogWindow* mDialogWindow;
+        SoundObject* mSoundObject;
+        MeshAnimation* mTalkAnimation;
+        /// Die aktuelle Zeit f???r die Textanzeige
+        Ogre::Real mCurrFadeTextTime;
+        /// Die Zeit bis der Text ausgeblendet wird
+        Ogre::Real mTotalFadeTextTime;
+        Ogre::Real mSubtitleSpeed;
+        Creature* mCurrentSpeaker;
+        std::list<Creature*> mCurrentListeners;
+        /// Der Untertitel-Text
+        CeGuiString mText;
+        /// Es wird gerade Text angezeigt
+        bool mTextShown;
+
+        DialogResponse* mCurrentResponse;
+        DialogOption* mCurrentOption;
+        std::list<DialogParagraph*> mCurrentParagraphs;
+
+        Dialog* mDialog;
+        GameLoggerWindow* mGameLogger;
+        CeGuiString mCurrentResponseText;
+
+        float getShowTextLength(const CeGuiString& text) const;
+        void processTextVariables(CeGuiString& text);
+    };
+}
+
+
+#endif /* DIALOGCONTROLLER_H_ */

Modified: rl/trunk/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -110,4 +110,9 @@
         CameraPosition cpos = {CPT_ROTATING, position, orientation1, orientation2};
         mPositions.push_back(cpos);
     }
+
+    void CutsceneControlState::clearCameras()
+    {
+        mPositions.clear();
+    }
 }

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -53,40 +53,26 @@
 #endif
 
 using namespace Ogre;
+using namespace std;
 
 namespace rl {
 
     DialogControlState::DialogControlState(CommandMapper* cmdMapper,
         Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_DIALOG),
+        : DialogController(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
-        mCurrFadeTextTime(0),
-        mTotalFadeTextTime(0),
-        mText(),
-        mDialogMode(DM_FRONT),
-        mTextShown(false),
-        mDialogWindow(NULL),
-        mSubtitleWindow(NULL),
-        mSoundObject(NULL),
-        mTalkAnimation(NULL),
-        mSubtitleSpeed(1.0f),
-		mCurrentResponseText(""),
-		mGameLogger(NULL),
-        mCurrentSpeaker(NULL),
-        mCurrentListener(NULL)
+        mDialogMode(DM_FRONT)
     {
-        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
-            "General", "Subtitle Speed");
     }
 
     DialogControlState::~DialogControlState()
     {
-        delete mSoundObject;
     }
 
     void DialogControlState::pause()
     {
+        DialogController::pause();
         /*
         if (mDialogPartner)
         {
@@ -95,7 +81,7 @@
             {
                 mesh->stopAllAnimations();
                 if (mesh->hasAnimation("idle"))
-                { 
+                {
                     mTalkAnimation = mesh->startAnimation("idle");
                 }
             }
@@ -103,8 +89,6 @@
         */
         //mCameraActor->getPhysicalThing()->unfreeze();
         //mCharacterActor->getPhysicalThing()->unfreeze();
-        mDialogWindow->setVisible(false, false);
-        mSubtitleWindow->setVisible(false, false);
     }
 
     void DialogControlState::resume()
@@ -127,6 +111,8 @@
         {
             mSubtitleWindow = new SubtitleWindow();
         }
+
+
         mDialogWindow->setVisible(true);
         mSubtitleWindow->setVisible(true);
 
@@ -155,12 +141,10 @@
 		if (!mDialog || !mDialogWindow)
 		{
             LOG_ERROR(Logger::UI, "DialogControlState not properly initialized.");
-            handleDialogClose();
+            handleDialogEnd();
             return;
 		}
         mDialog->setProperty(Dialog::PROP_EXIT_REQUESTED, false);
-        mCurrentSpeaker = mDialog->getNpc(0);
-        mCurrentListener = mDialog->getPc(0);
         showResponse(mDialog->getDialogStart());
 	}
 
@@ -211,11 +195,11 @@
                 + StringConverter::toString(mCurrFadeTextTime));
     }
 
-    void DialogControlState::recalculateCamera(GameObject* speaker, GameObject* listener)
+    void DialogControlState::recalculateDialogCamera(Creature* speaker, std::list<Creature*> listeners)
     {
         // Position camera at position between char and dialog partner
         Vector3 speakerEyes = getParticipantPosition(speaker);
-        Vector3 listenerEyes = getParticipantPosition(listener);
+        Vector3 listenerEyes = getParticipantPosition(listeners.front()); ///@FIXME, this is just using the 1st listener
         Vector3 globalCameraPosition = (speakerEyes + listenerEyes) / 2.0f;
 
         // Weltkoordinaten in lokale umwandeln
@@ -226,335 +210,95 @@
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }
 
-    Vector3 DialogControlState::getParticipantPosition(GameObject* participant)
-    {
-        Vector3 eyesPosition = participant->getPosition();
 
-        // Modify by MeshBounds
-        if (participant->getActor() && participant->getActor()->getControlledObject()->isMeshObject())
+	void DialogControlState::handleDialogEnd()
+	{
+		InputManager::getSingleton().popControlState();
+		mDialogWindow->setVisible(false, true);
+		mSubtitleWindow->setVisible(false, true);
+        mDialogWindow = NULL;
+        mSubtitleWindow = NULL;
+        if (mDialog != NULL)
         {
-            MeshObject* mo = static_cast<MeshObject*>(participant->getActor()->getControlledObject());
-            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y * 0.933,
-                aab.getCenter().z);
-            eyesPosition += participant->getOrientation() * offset;
-        }
-
-        return eyesPosition;
-    }
-
-    float DialogControlState::getShowTextLength(const CeGuiString& text) const
-    {
-        return 0.019f * text.length() + // Zeit f??rs Text lesen
-               0.25f;                   // Fade in
-    }
-
-    void DialogControlState::processTextVariables(CeGuiString& text)
-    {
-        CeGuiString newText = text;
-        CeGuiString::size_type pos = CeGuiString::npos;
-        do
-        {
-            pos = newText.find("{$");
-            if (pos != CeGuiString::npos)
+            const list<Creature*> list = mDialog->getParticipants();
+            for (std::list<Creature*>::const_iterator it = list.begin(); it != list.end(); ++it)
             {
-                CeGuiString::size_type endpos = newText.find("}", pos);
-                if (endpos != CeGuiString::npos)
+                Actor* actor = (*it)->getActor();
+                if (actor != NULL)
                 {
-                    CeGuiString varName = newText.substr(pos+2, endpos - pos - 2);
-                    CeGuiString varValue = mDialog->getVariableValue(varName.c_str());
-                    newText = newText.replace(pos, endpos - pos + 1, varValue);
+                    MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
+                    if (mesh != NULL && mesh->hasAnimation("reden"))
+                    {
+                        mesh->stopAnimation("reden");
+                    }
                 }
             }
         }
-        while (pos != CeGuiString::npos);
-        text.assign(newText);
-    }
-
-    void DialogControlState::doTalk(DialogParagraph* paragraph)
-    {
-        mDialogWindow->setVisible(false);
-        Ogre::String soundFile = paragraph->getVoiceFile();
-        CeGuiString text = paragraph->getText();
-        // if there is no text in the paragraph, go directly to the next entry!
-        if(text.empty())
-        {
-            textFinished();
-            return;
-        }
-        processTextVariables(text);
-
-        recalculateCamera(mCurrentListener, mCurrentSpeaker);
-
-        Actor* actor = mCurrentSpeaker->getActor();
-        // @todo: find out why we don't here anything if the sound is attached to the player
-        // atm, we attach it everytime to the npc to here at least anything
-        actor = mDialog->getNpc(0)->getActor();
-        // Ungef??hre Lesedauer bestimmen
-        float fadeTime = getShowTextLength(text);
-        if (soundFile.length() == 0)
-        {
-            float speed = mSubtitleSpeed;
-
-            if (mSubtitleSpeed == 0.0)
-                speed = 1.0;
-
-            mCurrFadeTextTime = fadeTime*speed;
-            mTotalFadeTextTime = fadeTime*speed;
-        }
         else
         {
-            if (mSoundObject != NULL)
-            {
-                mSoundObject->getMovableObject()->getParentSceneNode()->detachObject(
-                    mSoundObject->getMovableObject());
-                delete mSoundObject;
-            }
-
-            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()->
-                    createSound(soundFile, ST_SAMPLE), soundFile);
-
-            // An Sprecher h??ngen
-            actor->_getSceneNode()->attachObject(mSoundObject->getMovableObject());
-            actor->_getSceneNode()->_update(true, false);
-            mSoundObject->_setActor(actor);
-            mSoundObject->set3d(true);
-            mSoundObject->play();
-            mSoundObject->_update();
-
-
-            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject->getLength());
-            mTotalFadeTextTime = mCurrFadeTextTime;
+            LOG_ERROR(Logger::UI, "There is no Dialog to be closed!");
         }
+	}
 
-        MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
-        if (mesh != NULL)
-        {
-            if (mesh->hasAnimation("reden"))
-            {
-                mesh->stopAllAnimations();
-                mTalkAnimation = mesh->startAnimation("reden");
-            }
-        }
-
-        LOG_DEBUG(Logger::UI,
-            "Response: "
-                + actor->getName()
-                + " File: '"
-                + soundFile
-                + "', Text: '" + text + "', Time: "
-                + StringConverter::toString(mCurrFadeTextTime));
-
-
-        mTextShown = true;
-
-        if (mSubtitleWindow != NULL && !text.empty())
-        {
-            mSubtitleWindow->show(text);
-        }
-    }
-
-    bool DialogControlState::mouseReleased(const OIS::MouseEvent& evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        bool retval = false;
-        if (ControlState::mouseReleased(evt, id, handled))
-            retval = true;
-
-        if (!handled && !retval)
-        {
-            if (mTextShown && 
-                (mCurrFadeTextTime + 0.25 < mTotalFadeTextTime))
-            {
-                mCurrFadeTextTime = -1;
-                retval = true;
-            }
-        }
-
-        return retval;
-    }
-
-    void DialogControlState::showResponse(DialogResponse* response)
+	bool DialogControlState::requestDialogClose()
 	{
-        if (!response)
-		{
-            LOG_MESSAGE(Logger::UI, "No response found! Close Dialog!");
-			mDialogWindow->setDialogEnd();
-			mState = CLOSING_DIALOG;
-			handleDialogClose();
-			return;
-		}
-
-		if (response->isSelection())
-		{
-			DialogResponseSelection* sel = static_cast<DialogResponseSelection*>(response);
-			mCurrentResponse = sel->getSelectedElement(mDialog);
-		}
-		else
-		{
-			mCurrentResponse = response;
-		}
-	
-        mState = TALKING_PARTNER_CHARACTER;
-        mCurrentOption = NULL;
-
-		mDialogWindow->setVisible(false);
-
-        mCurrentListener = mDialog->getPc(0);
-        mCurrentSpeaker = mCurrentResponse->getNpc(mDialog);
-        mCurrentParagraphs = mCurrentResponse->getParagraphs(mDialog);
-        if(!mCurrentParagraphs.empty())
-        {
-            DialogParagraph* firstParagraph = mCurrentParagraphs.front();
-            mCurrentResponse->applyImplications(mDialog);
-            // does this paragraph contain a response?
-            if (!firstParagraph->getResponse())
-            {
-                // no, so directly start with the first paragraph
-                doTalk(firstParagraph);
-            }
-            else if(mCurrentParagraphs.size() > 1)
-            {
-                // yes, but there are other paragraphs in the list.
-                // the response should be executed at last, so we put it back to the end
-                mCurrentParagraphs.pop_front();
-                mCurrentParagraphs.push_back(firstParagraph);
-                firstParagraph = mCurrentParagraphs.front();
-                // we don't allow more than one goto per response
-                if(firstParagraph->getResponse())
-                {
-                    LOG_ERROR(Logger::UI, "To many gotoresponses in response with id: " 
-                        + mCurrentResponse->getId()); 
-                    handleDialogClose();
-                }
-                else
-                {
-                    doTalk(firstParagraph);
-                }
-            }
-            else
-            {
-                // we only have a response as paragraph, execute it!
-                showResponse(firstParagraph->getResponse());
-            }
-        }
-        else
-        {
-            handleDialogClose();
-        }
+	//	handleClose is called automatically
+        handleDialogEnd();
+		//@todo
+		return true;
 	}
 
-	void DialogControlState::textFinished()
+
+	bool DialogControlState::textFinished()
 	{
-		if (mDialog->isExitRequested())
-		{
-			handleDialogClose();
-			return;
-		}
 
-        mCurrentParagraphs.pop_front();
-        if (!mCurrentParagraphs.empty())
+        if (!DialogController::textFinished())
         {
-            DialogParagraph* curParagraph = mCurrentParagraphs.front();
-            if (curParagraph->getResponse() == NULL)
+            if (mDialogState == TALKING_PARTNER_CHARACTER)
             {
-                doTalk(curParagraph);
-            }
-            else
-            {
-                showResponse(curParagraph->getResponse());
-            }
-        }
-        else
-        {
-		    if (mState == TALKING_PARTNER_CHARACTER)
-		    {
-                mCurrentListener = mCurrentResponse->getNpc(mDialog);
-                mCurrentSpeaker = mDialog->getPc(0);
 
                 DialogResponse::Options options = mCurrentResponse->getAvailableOptions(mDialog);
                 // if there is just one option and it is an auto selected one,
                 // display it.
-                if(options.size() == 1 &&  options.front()->isAutoSelected())
+                if (options.size() == 1 &&  options.front()->isAutoSelected())
                 {
                     handleDialogSelectOption(options.front());
-                    return;
+                    return true;
                 }
                 mDialogWindow->setAvailableOptions(options);
-		        mDialogWindow->setVisible(true);
-		        mState = CHOOSING_OPTION;
-		    }
-            else if (mState == TALKING_PLAYER_CHARACTER)
+                mDialogWindow->setVisible(true);
+                mDialogState = CHOOSING_OPTION;
+            }
+            else if (mDialogState == TALKING_PLAYER_CHARACTER)
             {
                 showResponse(mCurrentOption->getResponse());
             }
         }
 
-		LOG_DEBUG(Logger::UI,
-					StringConverter::toString(mState)
-					+ " bei textFinished");
-	}
+        LOG_DEBUG(Logger::UI,
+                    StringConverter::toString(mDialogState)
+                    + " bei textFinished");
 
-	bool DialogControlState::handleDialogSelectOption(DialogOption* option)
-	{
-		if (option->isSelection())
-		{
-			DialogOptionSelection* sel = static_cast<DialogOptionSelection*>(option);
-			mCurrentOption = sel->getSelectedElement(mDialog);
-		}
-		else
-		{
-			mCurrentOption = option;
-		}
-        mState = TALKING_PLAYER_CHARACTER;
-        mCurrentListener = mDialog->getNpc(0);
-        mCurrentSpeaker = mDialog->getPc(0); ///@todo allow char switch 
-        mCurrentParagraphs = mCurrentOption->getParagraphs(mDialog);
-        doTalk(mCurrentParagraphs.front());
-
-		return true;
+        return true;
 	}
 
-	bool DialogControlState::handleDialogClose()
-	{
-		InputManager::getSingleton().popControlState();
-		mDialogWindow->setVisible(false, true);
-		mSubtitleWindow->setVisible(false, true);
-        mDialogWindow = NULL;
-        mSubtitleWindow = NULL;
-        if (mDialog != NULL)
+    bool DialogControlState::handleDialogSelectOption(DialogOption* option)
+    {
+        if (option->isSelection())
         {
-            const std::vector<Creature*> list = mDialog->getPlayerCharacters();
-            for (std::vector<Creature*>::const_iterator it = list.begin(); it != list.end(); ++it)
-            {
-                Actor* actor = (*it)->getActor();
-                if (actor != NULL)
-                {
-                    MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
-                    if (mesh != NULL && mesh->hasAnimation("reden"))
-                    {
-                        mesh->stopAnimation("reden");
-                    }
-                }        
-            }
-            return true;
+            DialogOptionSelection* sel = static_cast<DialogOptionSelection*>(option);
+            mCurrentOption = sel->getSelectedElement(mDialog);
         }
         else
         {
-            LOG_ERROR(Logger::UI, "There is no Dialog to be closed!");
-            return false;
+            mCurrentOption = option;
         }
-	}
 
-	bool DialogControlState::requestDialogClose()
-	{
-	//	handleClose is called automatically
-        handleDialogClose();
-		//@todo
-		return true;
-	}
+        mDialogState = TALKING_PLAYER_CHARACTER;
+        mCurrentParagraphs = mCurrentOption->getParagraphs(mDialog);
+        doTalk(mCurrentParagraphs.front());
 
+        return true;
+    }
 
 }

Added: rl/trunk/engine/ui/src/DialogController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogController.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/src/DialogController.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -0,0 +1,324 @@
+/*
+ * DialogController.cpp
+ *
+ *  Created on: 15.02.2009
+ *      Author: blakharaz
+ */
+
+#include "stdinc.h"
+
+#include "DialogController.h"
+
+#include "Actor.h"
+#include "ConfigurationManager.h"
+#include "Creature.h"
+#include "Dialog.h"
+#include "DialogOption.h"
+#include "DialogParagraph.h"
+#include "DialogResponse.h"
+#include "DialogWindow.h"
+#include "GameObject.h"
+#include "MeshObject.h"
+#include "SoundDriver.h"
+#include "SoundManager.h"
+#include "SoundObject.h"
+#include "SubtitleWindow.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+    DialogController::DialogController(CommandMapper* commandMapper, Actor* camera, Creature* character,
+            ControlStateType type)
+        : ControlState(commandMapper, camera, character, type),
+        mSubtitleWindow(NULL),
+        mSoundObject(NULL),
+        mTalkAnimation(NULL),
+        mSubtitleSpeed(1.0f),
+        mTextShown(false),
+        mCurrFadeTextTime(0),
+        mTotalFadeTextTime(0),
+        mText(),
+        mDialogWindow(NULL),
+        mCurrentResponseText(""),
+        mGameLogger(NULL),
+        mCurrentSpeaker(NULL)
+    {
+        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
+            "General", "Subtitle Speed");
+    }
+
+    DialogController::~DialogController()
+    {
+        delete mSoundObject;
+    }
+
+    void DialogController::doTalk(DialogParagraph* paragraph, DialogWindow* window)
+    {
+        if (window)
+        {
+            window->setVisible(false);
+        }
+        Ogre::String soundFile = paragraph->getVoiceFile();
+        CeGuiString text = paragraph->getText();
+        // if there is no text in the paragraph, go directly to the next entry!
+        if(text.empty())
+        {
+            textFinished();
+            return;
+        }
+        processTextVariables(text);
+
+        mCurrentSpeaker = paragraph->getSpeaker(mDialog);
+        mCurrentListeners = paragraph->getListeners(mDialog);
+
+        recalculateDialogCamera(mCurrentSpeaker, mCurrentListeners);
+        Actor* actor = mCurrentSpeaker->getActor();
+
+        // Ungef??hre Lesedauer bestimmen
+        float fadeTime = getShowTextLength(text);
+        if (soundFile.length() == 0)
+        {
+            float speed = mSubtitleSpeed;
+
+            if (mSubtitleSpeed == 0.0)
+            {
+                speed = 1.0;
+            }
+
+            mCurrFadeTextTime = fadeTime*speed;
+            mTotalFadeTextTime = fadeTime*speed;
+        }
+        else
+        {
+            if (mSoundObject != NULL)
+            {
+                mSoundObject->getMovableObject()->getParentSceneNode()->detachObject(
+                    mSoundObject->getMovableObject());
+                delete mSoundObject;
+            }
+
+            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()->
+                    createSound(soundFile, ST_SAMPLE), soundFile);
+
+            // An Sprecher h??ngen
+            actor->_getSceneNode()->attachObject(mSoundObject->getMovableObject());
+            actor->_getSceneNode()->_update(true, false);
+            mSoundObject->_setActor(actor);
+            mSoundObject->set3d(true);
+            mSoundObject->play();
+            mSoundObject->_update();
+
+
+            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject->getLength());
+            mTotalFadeTextTime = mCurrFadeTextTime;
+        }
+
+        MeshObject* mesh = dynamic_cast<MeshObject*>(actor->getControlledObject());
+        if (mesh != NULL)
+        {
+            if (mesh->hasAnimation("reden"))
+            {
+                mesh->stopAllAnimations();
+                mTalkAnimation = mesh->startAnimation("reden");
+            }
+        }
+
+        LOG_DEBUG(Logger::UI,
+            "Response: "
+                + actor->getName()
+                + " File: '"
+                + soundFile
+                + "', Text: '" + text + "', Time: "
+                + StringConverter::toString(mCurrFadeTextTime));
+
+
+        mTextShown = true;
+
+        if (mSubtitleWindow != NULL && !text.empty())
+        {
+            mSubtitleWindow->show(text);
+        }
+    }
+
+    void DialogController::showResponse(DialogResponse* response, DialogWindow* window)
+    {
+        if (!response)
+        {
+            LOG_MESSAGE(Logger::UI, "No response found! Close Dialog!");
+            if (window)
+            {
+                window->setDialogEnd();
+            }
+            handleDialogEnd();
+            return;
+        }
+
+        if (response->isSelection())
+        {
+            DialogResponseSelection* sel = static_cast<DialogResponseSelection*>(response);
+            mCurrentResponse = sel->getSelectedElement(mDialog);
+        }
+        else
+        {
+            mCurrentResponse = response;
+        }
+
+
+        if (window)
+        {
+            window->setVisible(false);
+        }
+
+        mCurrentParagraphs = mCurrentResponse->getParagraphs(mDialog);
+        if(!mCurrentParagraphs.empty())
+        {
+            DialogParagraph* firstParagraph = mCurrentParagraphs.front();
+            mCurrentResponse->applyImplications(mDialog);
+            // does this paragraph contain a response?
+            if (!firstParagraph->getResponse())
+            {
+                // no, so directly start with the first paragraph
+                doTalk(firstParagraph, window);
+            }
+            else if(mCurrentParagraphs.size() > 1)
+            {
+                // yes, but there are other paragraphs in the list.
+                // the response should be executed at last, so we put it back to the end
+                mCurrentParagraphs.pop_front();
+                mCurrentParagraphs.push_back(firstParagraph);
+                firstParagraph = mCurrentParagraphs.front();
+                // we don't allow more than one goto per response
+                if(firstParagraph->getResponse())
+                {
+                    LOG_ERROR(Logger::UI, "To many gotoresponses in response with id: "
+                        + mCurrentResponse->getId());
+                    handleDialogEnd();
+                }
+                else
+                {
+                    doTalk(firstParagraph, window);
+                }
+            }
+            else
+            {
+                // we only have a response as paragraph, execute it!
+                showResponse(firstParagraph->getResponse());
+            }
+        }
+        else
+        {
+            handleDialogEnd();
+        }
+    }
+
+    float DialogController::getShowTextLength(const CeGuiString& text) const
+    {
+        return 0.019f * text.length() + // Zeit f??rs Text lesen
+               0.25f;                   // Fade in
+    }
+
+    void DialogController::processTextVariables(CeGuiString& text)
+    {
+        CeGuiString newText = text;
+        CeGuiString::size_type pos = CeGuiString::npos;
+        do
+        {
+            pos = newText.find("{$");
+            if (pos != CeGuiString::npos)
+            {
+                CeGuiString::size_type endpos = newText.find("}", pos);
+                if (endpos != CeGuiString::npos)
+                {
+                    CeGuiString varName = newText.substr(pos+2, endpos - pos - 2);
+                    CeGuiString varValue = mDialog->getVariableValue(varName.c_str());
+                    newText = newText.replace(pos, endpos - pos + 1, varValue);
+                }
+            }
+        }
+        while (pos != CeGuiString::npos);
+        text.assign(newText);
+    }
+
+    void DialogController::pause()
+    {
+        if (mDialogWindow) {
+            mDialogWindow->setVisible(false, false);
+        }
+        if (mSubtitleWindow) {
+            mSubtitleWindow->setVisible(false, false);
+        }
+    }
+
+    bool DialogController::mouseReleased(const OIS::MouseEvent& evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        bool retval = ControlState::mouseReleased(evt, id, handled);
+
+        if (!handled && !retval)
+        {
+            if (mTextShown &&
+                (mCurrFadeTextTime + 0.25 < mTotalFadeTextTime))
+            {
+                mCurrFadeTextTime = -1;
+                retval = true;
+            }
+        }
+
+        return retval;
+    }
+
+    void DialogController::setDialogWindow(DialogWindow* window)
+    {
+        mDialogWindow = window;
+    }
+
+    void DialogController::setSubtitleWindow(SubtitleWindow* window)
+    {
+        mSubtitleWindow = window;
+    }
+
+    Vector3 DialogController::getParticipantPosition(Creature* participant)
+    {
+        Vector3 eyesPosition = participant->getPosition();
+
+        // Modify by MeshBounds
+        if (participant->getActor() && participant->getActor()->getControlledObject()->isMeshObject())
+        {
+            MeshObject* mo = static_cast<MeshObject*>(participant->getActor()->getControlledObject());
+            Ogre::AxisAlignedBox aab = mo->getDefaultSize();
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y * 0.933,
+                aab.getCenter().z);
+            eyesPosition += participant->getOrientation() * offset;
+        }
+
+        return eyesPosition;
+    }
+
+    bool DialogController::textFinished()
+    {
+        if (mDialog->isExitRequested())
+        {
+            handleDialogEnd();
+            return true;
+        }
+
+        mCurrentParagraphs.pop_front();
+        if (!mCurrentParagraphs.empty())
+        {
+            DialogParagraph* curParagraph = mCurrentParagraphs.front();
+            if (curParagraph->getResponse() == NULL)
+            {
+                doTalk(curParagraph, mDialogWindow);
+            }
+            else
+            {
+                showResponse(curParagraph->getResponse());
+            }
+
+            return true;
+        }
+    }
+}



From alassion at mail.berlios.de  Sun Feb 22 13:35:27 2009
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sun, 22 Feb 2009 13:35:27 +0100
Subject: [Dsa-hl-svn] r4773 - content/textures
Message-ID: <200902221235.n1MCZRwC017370@sheep.berlios.de>

Author: alassion
Date: 2009-02-22 13:29:16 +0100 (Sun, 22 Feb 2009)
New Revision: 4773

Added:
   content/textures/schild_kana_spec.png
   content/textures/waldboden_01.png
   content/textures/waldboden_01_normal.png
   content/textures/waldboden_02.png
   content/textures/waldboden_02_normal.png
   content/textures/wand_02_kana.png
   content/textures/wand_02_kana_normal.png
   content/textures/wand_02_kana_spec.png
Modified:
   content/textures/saeule_kana.png
Log:


Modified: content/textures/saeule_kana.png
===================================================================
(Binary files differ)

Added: content/textures/schild_kana_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/schild_kana_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/waldboden_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/waldboden_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/waldboden_01_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/waldboden_01_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/waldboden_02.png
===================================================================
(Binary files differ)


Property changes on: content/textures/waldboden_02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/waldboden_02_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/waldboden_02_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/wand_02_kana.png
===================================================================
(Binary files differ)


Property changes on: content/textures/wand_02_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/wand_02_kana_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/wand_02_kana_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/wand_02_kana_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/wand_02_kana_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From fusion2 at mail.berlios.de  Tue Feb 24 18:18:28 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 24 Feb 2009 18:18:28 +0100
Subject: [Dsa-hl-svn] r4774 - in rl/trunk/editors/Lockenwickler/src: . media
Message-ID: <200902241718.n1OHISu2005780@sheep.berlios.de>

Author: fusion2
Date: 2009-02-24 18:18:15 +0100 (Tue, 24 Feb 2009)
New Revision: 4774

Added:
   rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
   rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl
Modified:
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
Log:
- fixes for Linux

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,462 +1,468 @@
- #################################################
- #################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-sys.path.insert(0,'..')
-import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from ModuleExplorer import *
-from NewModuleWizard import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
-#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-#        splash.setMask(pixmap.mask())
-#        splash.showMessage("Starting...")
-#        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
-        self.moduleExplorerWin = ModuleExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
-        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
-            self.prefDialog.show()
-
-        self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
-        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
-        
-        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
-        self.setWindowTitle("Rastullahs Lockenwickler")
-        
-        self.editorSetupFinished = False
-        
-#        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName("MainWindow")
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName("centralwidget")
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName("hboxlayout")
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName("menubar")
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName("menuFile")
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName("menuEdit")
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName("menuView")
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName("statusbar")
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
-        self.actionNeu.setObjectName("actionNeu")
-
-        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "filenew.png",  "Open Module")
-        self.actionOpen.setObjectName("actionOpen")
-        
-        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filenew.png",  "Save Module")
-        self.actionSave.setObjectName("actionSave")
-
-        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
-        self.actionClose.setObjectName("actionQuit")
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
-        self.actionDelete.setObjectName("actionDelete")
-
-        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
-        self.actionCopy.setObjectName("actionCopy")
-
-        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
-        self.actionCut.setObjectName("actionCut")
-
-        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
-        self.actionPaste.setObjectName("actionPaste")
-
-        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
-        self.actionSelect.setObjectName("actionSelect")
-
-        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
-        self.actionMove.setObjectName("actionMove")
-
-        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt + E",  "view_tree.png",  "Module Explorer",  False)
-        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
-        
-        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
-        self.actionPreferences.setObjectName("actionPreferences")
-
-        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
-        self.actionProperty_Window.setObjectName("actionProperty_Window")
-
-        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
-        self.actionObject_Selection.setObjectName("actionObject_Selection")
-
-        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
-        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
-
-        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionSave)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
-        if platform.system() == "Windows":
-            pluginCfgPath="./Plugins-windows.cfg"
-        else:
-            pluginCfgPath="./Plugins-linux.cfg"
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-
-        self.moduleName = ""
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-        
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def finishEditorSetup(self):
-        og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-        self.moduleManager.pivot.hide()
-        self.editorSetupFinished = True
-        
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-
-    def actionOpenSlot(self):
-        self.finishEditorSetup()
-        self.moduleManager.openLoadModuleDialog()
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self.moduleManager, self)
-        newModuleWiz.exec_()
-        return
-        
-    def actionSaveSlot(self):
-        self.moduleManager.save()
-        
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleModuleExplorer(self):
-        if self.moduleExplorerDock.isHidden():
-            self.moduleExplorerDock.show()
-        else:
-            self.moduleExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
-        self.propertyDock.setObjectName("PropertyDockWindow")
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
-        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
-        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
-        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
-        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
-        self.consoleDock.setObjectName("ConsoleDockWindow")
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar("File Toolbar")
-        self.fileToolBar.setObjectName("FileToolBar")
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionSave)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar("Transformation Bar")
-        self.moveToolBar.setObjectName("TransformationBar")
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print""
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == "__main__":
-#    # Import Psyco if available
-#    try:
-##        import psyco
-##        psyco.full(0.02)
-#        #psyco.log()
-#        #psyco.profile()
-#    except ImportError:
-#        pass
-    
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName("Team Pantheon")
-    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
-    app.setApplicationName("Lockenwickler")
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+ #################################################
+ #################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import *
+from ModuleExplorer import *
+from NewModuleWizard import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage("Starting...")
+#        splash.show()
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
+            self.prefDialog.show()
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
+        
+        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
+        self.setWindowTitle("Rastullahs Lockenwickler")
+        
+        self.editorSetupFinished = False
+        
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName("MainWindow")
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName("menuEdit")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName("statusbar")
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "filenew.png",  "Open Module")
+        self.actionOpen.setObjectName("actionOpen")
+        
+        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filenew.png",  "Save Module")
+        self.actionSave.setObjectName("actionSave")
+
+        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionQuit")
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
+        self.actionDelete.setObjectName("actionDelete")
+
+        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
+        self.actionCopy.setObjectName("actionCopy")
+
+        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
+        self.actionCut.setObjectName("actionCut")
+
+        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
+        self.actionPaste.setObjectName("actionPaste")
+
+        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
+        self.actionSelect.setObjectName("actionSelect")
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt + E",  "view_tree.png",  "Module Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+        
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+
+        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
+        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
+
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
+        if platform.system() == "Windows":
+            pluginCfgPath="./Plugins-windows.cfg"
+        else:
+            pluginCfgPath="./Plugins-linux.cfg"
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+
+        self.moduleName = ""
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+        
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+        if platform.system() == "Linux":
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+
+    def actionOpenSlot(self):
+        self.finishEditorSetup()
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
+        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
+        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionSave)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyReleaseEvent(event)
+        pass
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print""
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
+if __name__ == "__main__":
+#    # Import Psyco if available
+#    try:
+##        import psyco
+##        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
+
+    form = Lockenwickler()
+    form.show()
+
+    sys.exit(app.exec_())
+

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,179 +1,181 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MyListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MyListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream << self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData("application/x-static_model", data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class ModelSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
-                               self.updateModelList)
-
-        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
-                               self.setPreviewedModel)
-
-        self.modelList = []
-
-        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName("modelPreviewDialog")
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.modelSearchBox = QLineEdit(self)
-        self.modelSearchBox.setObjectName("modelSearchBox")
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName("splitter")
-
-        self.listWidget = MyListWidget(self.splitter)
-        self.listWidget.setObjectName("listWidget")
-
-        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
-        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
-                                                         self.splitter)
-        self.ogreModelPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
-        
-        
-        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-    def ogreViewportCreatedCallback(self):
-        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
-        
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
-
-    def setPreviewedModel(self):
-        if self.ent != None:
-            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
-
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
-                                                                 str(self.listWidget.currentItem().text()))
-        self.node.attachObject(self.ent)
-        self.node.setScale(og.Vector3(1,1,1))
-        bb = self.ent.getBoundingBox()
-
-    def scanDirForModels(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForModels(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(".mesh"):
-                    self.modelList.append(file)
-                    self.listWidget.addItem(file)
-
-        self.listWidget.sortItems()
-
-    def updateModelList(self, text):
-        self.listWidget.clear()
-        for model in self.modelList:
-            if model.find(text) != -1:
-               self.listWidget.addItem(model)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() < 0:
-                self.ogreModelPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreModelPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
-                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MyListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MyListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData("application/x-static_model", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.modelSearchBox, SIGNAL("textChanged(QString)"),
+                               self.updateModelList)
+
+        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
+                               self.setPreviewedModel)
+
+        self.modelList = []
+
+        self.ogreModelPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreModelPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName("modelPreviewDialog")
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.modelSearchBox = QLineEdit(self)
+        self.modelSearchBox.setObjectName("modelSearchBox")
+        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.listWidget = MyListWidget(self.splitter)
+        self.listWidget.setObjectName("listWidget")
+
+        self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreModelPrevWindowSceneMgr")
+        self.ogreModelPrevWindow = OgreWidget.OgreWidget("ModelPrevWin", self.ogreRoot, self.ogreModelPrevWindowSceneMgr, "PrevCam",
+                                                         self.splitter)
+        self.ogreModelPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
+        
+        
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreModelPrevWindow.setObjectName("modelPreviewWindow")
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+    def ogreViewportCreatedCallback(self):
+        self.ogreModelPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate("modelPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
+
+    def setPreviewedModel(self):
+        if self.ent != None:
+            self.ogreModelPrevWindowSceneMgr.destroyEntity(self.ent.getName())
+
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.ent = self.ogreModelPrevWindowSceneMgr.createEntity(str(self.listWidget.currentItem().text()),
+                                                                 str(self.listWidget.currentItem().text()))
+        self.node.attachObject(self.ent)
+        self.node.setScale(og.Vector3(1,1,1))
+        bb = self.ent.getBoundingBox()
+
+    def scanDirForModels(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForModels(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(".mesh"):
+                    self.modelList.append(file)
+                    self.listWidget.addItem(file)
+
+        self.listWidget.sortItems()
+
+    def updateModelList(self, text):
+        self.listWidget.clear()
+        for model in self.modelList:
+            if model.find(text) != -1:
+               self.listWidget.addItem(model)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() < 0:
+                self.ogreModelPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreModelPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+
+    def updateRenderWindow(self):
+        self.ogreModelPrevWindow.update()

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,862 +1,861 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-
-
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
-
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace("\\", "/")
-        mapName = mapName.split("/")
-        mapName = mapName[len(mapName) - 1].split(".")
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + ".rlmap.xml"
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib["formatVersion"] == "0.4.0":
-                self.parseMapNodes(root.find("nodes"))
-                #self.parseMapZones(root.find("zones"))
-            else:
-                print pathToFile + " has wrong format version. It needs to be 0.4.0"
-                return
-
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator("entity")
-        
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator("light")
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator("sound")
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-
-        nodes = nodeElement.getiterator("particlesystem")
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib["name"]
-            meshFile = nodes.attrib["meshfile"]
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    posx = float(t.attrib["x"])
-                    posy = float(t.attrib["y"])
-                    posz = float(t.attrib["z"])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                elif t.tag == "scale":
-                    scalex = float(t.attrib["x"])
-                    scaley = float(t.attrib["y"])
-                    scalez = float(t.attrib["z"])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                continue
-
-            n = self.mapNode.createChild("entity_" + entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib["name"]
-            lightType = l.attrib["type"]
-            lightVisible = bool(l.attrib["visible"])
-            castShadows = bool(l.attrib["castShadows"])
-            lightPosition = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == "colourDiffuse":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == "colourSpecular":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == "lightAttenuation":
-                    lightAttenuationRange = float(t.attrib["range"])
-                    lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
-            
-
-            light = self.sceneManager.createLight(lightName)
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
-            light.setDiffuseColour(colourDiffuse)
-            light.setSpecularColour(colourSpecular)
-            
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)
-            
-            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild("light_" + lightName + "_node")
-            n.attachObject(e)
-            n.attachObject(light)
-            n.setPosition(lightPosition)
-
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib["class"]
-            id = int(g.attrib["id"])
-            state = g.attrib["state"]
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == "scale":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodeScale = og.Vector3(x, y, z)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
-                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-                if nodeScale:
-                    dropNode.setScale(nodeScale)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                go.inWorldId = id
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element("rastullahmap")
-        root.attrib["formatVersion"] = "0.4.0"
-        
-        nodesElem = xml.SubElement(root, "nodes")
-        
-        iter = self.mapNode.getChildIterator()
-        while iter.hasMoreElements():
-            name = iter.getNext().getName()
-            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib["name"]
-        
-            maps = root.getiterator("map")
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
-        
-    def save(self):
-        root = xml.Element("scene")
-        root.attrib["name"] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, "map")
-            sub.attrib["file"] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print "ERROR: could not find scene: " + sceneName
-        
-    
-    def isCommon(self):
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Error: couldn't find module config")
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("super("):
-                split = lStripped.split(",")
-                if split[2].strip() == unicode("true"):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    self.moduleDependencies.append(lStripped.split('"')[1])
-
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-
-        self.isLoaded = True
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Error: couldn't find module config")
-            return
-
-        #for i, line in enumerate(f):
-            #lStripped = line.strip() #strip the whitespace away, not needed here
-
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        cmd = join(self.moduleRoot, "dsa/*.gof")
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, "maps/*.rlscene")
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-            
-        
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-
-    def setResourcePaths(self, recurseFolder = ""):
-        if recurseFolder == "":
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
-                self.setResourcePaths(curFile)
-            if os.path.isfile(curFile):
-                pass
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-                            
-class ModuleManager():
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-
-        self.moduleCfgPath = ""
-
-        self.gocManager = GameObjectClassManager()
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.propertyWindow = None
-    
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
-
-        self.moduleConfigIsParsed = True
-
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog()
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
-        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-                m.load()
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-                
-        self.moduleExplorer.updateView()
-#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-#        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
-#        e.setMaterialName("PlainColor")
-#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
-#
-#        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
-#        e2.setMaterialName("PlainColor")
-#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
-#        n.attachObject(e)
-#        n.attachObject(e2)
-#        n.setScale(og.Vector3(10, 5, 20))
-#        
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        if self.currentMap is None:
-            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:
-                self.propertyWindow.showProperties(so)
-                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-        if self.rayLine == None:
-            self.rayLine = self.sceneManager.createManualObject("rayLine")
-            self.rayLine.setDynamic(True)
-            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-
-            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-        else:
-            self.rayLine.beginUpdate(0)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = ""
-        split = name.split("_")
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + "_1"
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gameObjectRepresentationDict.append(newGO)
-                        newEntity.setUserObject(newGO)
-                        newGO.setPosition(og.Vector3(0, 0, 0))
-
-                        newSO = SelectionObject(newEntity, so.distance)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        self.dropCount += 1
-            else:
-                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-                entityName = self.incrementNameSuffixNumber(so.entity.getName())
-                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                newNode.attachObject(newEntity)
-                newNode.setPosition(so.entity.getParentNode().getPosition())
-                newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                newNode.setScale(so.entity.getParentNode().getScale())
-
-                newSO = SelectionObject(newEntity, so.distance)
-                newSO.setSelected(True)
-                newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print "sd"
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+
+
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace("\\", "/")
+        mapName = mapName.split("/")
+        mapName = mapName[len(mapName) - 1].split(".")
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                #self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
+
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("entity")
+        
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            meshFile = nodes.attrib["meshfile"]
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    posx = float(t.attrib["x"])
+                    posy = float(t.attrib["y"])
+                    posz = float(t.attrib["z"])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                elif t.tag == "scale":
+                    scalex = float(t.attrib["x"])
+                    scaley = float(t.attrib["y"])
+                    scalez = float(t.attrib["z"])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                continue
+
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
+                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
+            
+
+            light = self.sceneManager.createLight(lightName)
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
+            light.setDiffuseColour(colourDiffuse)
+            light.setSpecularColour(colourSpecular)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(e)
+            n.attachObject(light)
+            n.setPosition(lightPosition)
+
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            id = int(g.attrib["id"])
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "scale":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        iter = self.mapNode.getChildIterator()
+        while iter.hasMoreElements():
+            name = iter.getNext().getName()
+            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.isCommon() Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('"')[1])
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.load: Error: couldn't find module config")
+            return
+
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
+
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+            
+        
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            if os.path.isfile(curFile):
+                pass
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+                            
+class ModuleManager():
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
+        self.moduleCfgPath = ""
+
+        self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.propertyWindow = None
+    
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
+
+        self.moduleConfigIsParsed = True
+
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                
+        self.moduleExplorer.updateView()
+#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+#        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
+#        e.setMaterialName("PlainColor")
+#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
+#
+#        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
+#        e2.setMaterialName("PlainColor")
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
+#        n.attachObject(e)
+#        n.attachObject(e2)
+#        n.setScale(og.Vector3(10, 5, 20))
+#        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        if self.currentMap is None:
+            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:
+                self.propertyWindow.showProperties(so)
+                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+        if self.rayLine == None:
+            self.rayLine = self.sceneManager.createManualObject("rayLine")
+            self.rayLine.setDynamic(True)
+            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+
+            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+        else:
+            self.rayLine.beginUpdate(0)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = ""
+        split = name.split("_")
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + "_1"
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.moduleExplorer.updateView()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print "sd"
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,146 +1,147 @@
-# -*- coding: utf-8 -*-
-
-"""
-Module implementing NewModuleWizard.
-"""
-
-import os
-import glob
-
-from PyQt4.QtGui import QDialog
-from PyQt4.QtCore import pyqtSignature
-
-from Ui_NewModuleWizard import Ui_Dialog
-
-class NewModuleWizard(QDialog, Ui_Dialog):
-    """
-    Class documentation goes here.
-    """
-    def __init__(self, moduleManager, parent = None):
-       
-        QDialog.__init__(self, parent)
-        self.setupUi(self)
-
-        self.moduleManager = moduleManager
-        self.moduleManager.parseModuleConfig()
-        
-        for m in self.moduleManager.moduleList:
-            self.moduleDependenciesList.addItem(m.name)
-
-    @pyqtSignature("QString")
-    def on_moduleNameLineEdit_textChanged(self, p0):
-        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
-            self.sceneNameLineEdit.setEnabled(True)
-            self.mapNameLineEdit.setEnabled(True)
-            self.moduleDependenciesList.setEnabled(True)
-            self.scriptDependenciesList.setEnabled(True)
-            self.okButton.setEnabled(True)
-        else:
-            self.sceneNameLineEdit.setEnabled(False)
-            self.mapNameLineEdit.setEnabled(False)
-            self.moduleDependenciesList.setEnabled(False)
-            self.scriptDependenciesList.setEnabled(False)
-            self.okButton.setEnabled(False)
-    
-    def scanDirForScripts(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                self.scanDirForScripts(curFile)
-                continue
-            if os.path.isfile(curFile):
-                if file.endswith(".rb"):
-                    self.scriptDependenciesList.addItem(dir + "/" + file)
-    
-    @pyqtSignature("")
-    def on_moduleDependenciesList_itemSelectionChanged(self):
-        self.scriptDependenciesList.clear()
-        modulePath = self.moduleManager.moduleCfgPath.replace("modules.cfg",  "")
-        
-        for m in self.moduleDependenciesList.selectedItems():
-            path = os.path.join(modulePath, str(m.text()))
-            cmd = os.path.join(path + "/scripts")
-            self.scanDirForScripts(cmd)
-        
-    @pyqtSignature("")
-    def on_moduleNameLineEdit_returnPressed(self):
-        return
-            
-    @pyqtSignature("")
-    def on_mapNameLineEdit_returnPressed(self):
-        return
-        
-    @pyqtSignature("")
-    def on_okButton_clicked(self):
-        f = open(self.moduleManager.moduleCfgPath, "a")
-        f.write("module=" + str(self.moduleNameLineEdit.text()) + "\n")
-        f.close()
-        
-        modulePath = self.moduleManager.moduleCfgPath.replace("modules.cfg",  "")
-        modulePath = str(modulePath + self.moduleNameLineEdit.text())
-        os.mkdir(modulePath)
-        os.mkdir(os.path.join(modulePath, "dialogs"))
-        os.mkdir(os.path.join(modulePath, "dsa"))
-        os.mkdir(os.path.join(modulePath, "gui"))
-        os.mkdir(os.path.join(modulePath, "maps"))
-        os.mkdir(os.path.join(modulePath, "materials"))
-        os.mkdir(os.path.join(modulePath, "materials/textures"))
-        os.mkdir(os.path.join(modulePath, "models"))
-        os.mkdir(os.path.join(modulePath, "quests"))
-        os.mkdir(os.path.join(modulePath, "scripts"))
-        os.mkdir(os.path.join(modulePath, "scripts/maps"))
-        os.mkdir(os.path.join(modulePath, "sound"))
-        
-        mname = str(self.moduleNameLineEdit.text())
-        mdeps = ""
-        for m in self.moduleDependenciesList.selectedItems():
-            mdeps = mdeps + str("\"" + m.text() + "\", ")
-        mdeps = mdeps.strip(", ")
-        
-        sdeps = ""
-        for s in self.scriptDependenciesList.selectedItems():
-            script = str(str(s.text()).replace("\\", "/"))
-            script = script.split("/")
-            script = script[len(script) - 1]
-            sdeps = sdeps + str("       require " + script + "\n")
-        
-        
-        f = open(os.path.join(modulePath, "scripts\\") + "moduleconfig.rb", "w")
-        f.write("include RlScript\n")
-        f.write("\n\n")
-        f.write("class " + mname.capitalize() + "Module < ContentModule\n")
-        f.write("    def initialize()\n")
-        f.write("        super(\"" + mname + "\"" + ", \"" + mname + "\"" + ", false, 200608012)\n")
-        f.write("    end\n\n")
-        f.write("    def getDependencies()\n")
-        f.write("       return [" + str(mdeps) + "];\n")
-        f.write("    end\n\n")
-        f.write("    def getTextureLocation()\n")
-        f.write("       return [\"textures\"];\n")
-        f.write("    end\n\n")
-        f.write("    def getModelLocation()\n")
-        f.write("       return [\"models\"];\n")
-        f.write("    end\n\n")
-        f.write("    def getSoundLocation()\n")
-        f.write("       return [\"sound\"];\n")
-        f.write("    end\n\n")
-        f.write("    def start()\n")
-        f.write(sdeps)
-        f.write("\n\n       SceneManager.getSingleton().loadScene(\"" + self.sceneNameLineEdit.text() + "\");\n")
-        f.write("       $World = $CORE.getWorld();\n")
-        f.write("    end\n")
-        f.write("end\n\n")
-
-        f.write("CoreSubsystem.getSingleton().registerModule(" + mname.capitalize() + "Module.new());\n")
-        
-        self.moduleManager.resetParsedModuleConfig()
-        self.moduleManager.openLoadModuleDialog()
-        
-    @pyqtSignature("")
-    def on_cancelButton_pressed(self):
-        self.close()
-
-
+# -*- coding: utf-8 -*-
+
+"""
+Module implementing NewModuleWizard.
+"""
+
+import os
+import glob
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_NewModuleWizard import Ui_Dialog
+
+class NewModuleWizard(QDialog, Ui_Dialog):
+    """
+    Class documentation goes here.
+    """
+    def __init__(self, moduleManager, parent = None):
+       
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+
+        self.moduleManager = moduleManager
+        self.moduleManager.parseModuleConfig()
+        
+        for m in self.moduleManager.moduleList:
+            self.moduleDependenciesList.addItem(m.name)
+
+    @pyqtSignature("QString")
+    def on_moduleNameLineEdit_textChanged(self, p0):
+        if not self.moduleManager.moduleExists(str(self.moduleNameLineEdit.text())):
+            self.sceneNameLineEdit.setEnabled(True)
+            self.mapNameLineEdit.setEnabled(True)
+            self.moduleDependenciesList.setEnabled(True)
+            self.scriptDependenciesList.setEnabled(True)
+            self.okButton.setEnabled(True)
+        else:
+            self.sceneNameLineEdit.setEnabled(False)
+            self.mapNameLineEdit.setEnabled(False)
+            self.moduleDependenciesList.setEnabled(False)
+            self.scriptDependenciesList.setEnabled(False)
+            self.okButton.setEnabled(False)
+    
+    def scanDirForScripts(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                self.scanDirForScripts(curFile)
+                continue
+            if os.path.isfile(curFile):
+                if file.endswith(".rb"):
+                    self.scriptDependenciesList.addItem(dir + "/" + file)
+    
+    @pyqtSignature("")
+    def on_moduleDependenciesList_itemSelectionChanged(self):
+        self.scriptDependenciesList.clear()
+        modulePath = self.moduleManager.moduleCfgPath.replace("modules.cfg",  "")
+        
+        for m in self.moduleDependenciesList.selectedItems():
+            path = os.path.join(modulePath, str(m.text()))
+            cmd = os.path.join(path + "/scripts")
+            self.scanDirForScripts(cmd)
+        
+    @pyqtSignature("")
+    def on_moduleNameLineEdit_returnPressed(self):
+        return
+            
+    @pyqtSignature("")
+    def on_mapNameLineEdit_returnPressed(self):
+        return
+        
+    @pyqtSignature("")
+    def on_okButton_clicked(self):
+        f = open(self.moduleManager.moduleCfgPath, "a")
+        f.write("module=" + str(self.moduleNameLineEdit.text()) + "\n")
+        f.close()
+        
+        modulePath = self.moduleManager.moduleCfgPath.replace("modules.cfg",  "")
+        modulePath = str(modulePath + self.moduleNameLineEdit.text())
+        os.mkdir(modulePath)
+        os.mkdir(os.path.join(modulePath, "dialogs"))
+        os.mkdir(os.path.join(modulePath, "dsa"))
+        os.mkdir(os.path.join(modulePath, "gui"))
+        os.mkdir(os.path.join(modulePath, "maps"))
+        os.mkdir(os.path.join(modulePath, "materials"))
+        os.mkdir(os.path.join(modulePath, "materials/textures"))
+        os.mkdir(os.path.join(modulePath, "models"))
+        os.mkdir(os.path.join(modulePath, "quests"))
+        os.mkdir(os.path.join(modulePath, "scripts"))
+        os.mkdir(os.path.join(modulePath, "scripts/maps"))
+        os.mkdir(os.path.join(modulePath, "sound"))
+        
+        mname = str(self.moduleNameLineEdit.text())
+        mdeps = ""
+        for m in self.moduleDependenciesList.selectedItems():
+            mdeps = mdeps + str("\"" + m.text() + "\", ")
+        mdeps = mdeps.strip(", ")
+        
+        sdeps = ""
+        for s in self.scriptDependenciesList.selectedItems():
+            script = str(str(s.text()).replace("\\", "/"))
+            script = script.split("/")
+            script = script[len(script) - 1]
+            sdeps = sdeps + str("       require " + script + "\n")
+        
+        p = os.path.join(modulePath, "scripts")
+        p = os.path.join(p, "moduleconfig.rb")
+        f = open(p, "w")
+        f.write("include RlScript\n")
+        f.write("\n\n")
+        f.write("class " + mname.capitalize() + "Module < ContentModule\n")
+        f.write("    def initialize()\n")
+        f.write("        super(\"" + mname + "\"" + ", \"" + mname + "\"" + ", false, 200608012)\n")
+        f.write("    end\n\n")
+        f.write("    def getDependencies()\n")
+        f.write("       return [" + str(mdeps) + "];\n")
+        f.write("    end\n\n")
+        f.write("    def getTextureLocation()\n")
+        f.write("       return [\"textures\"];\n")
+        f.write("    end\n\n")
+        f.write("    def getModelLocation()\n")
+        f.write("       return [\"models\"];\n")
+        f.write("    end\n\n")
+        f.write("    def getSoundLocation()\n")
+        f.write("       return [\"sound\"];\n")
+        f.write("    end\n\n")
+        f.write("    def start()\n")
+        f.write(sdeps)
+        f.write("\n\n       SceneManager.getSingleton().loadScene(\"" + self.sceneNameLineEdit.text() + "\");\n")
+        f.write("       $World = $CORE.getWorld();\n")
+        f.write("    end\n")
+        f.write("end\n\n")
+
+        f.write("CoreSubsystem.getSingleton().registerModule(" + mname.capitalize() + "Module.new());\n")
+        
+        self.moduleManager.resetParsedModuleConfig()
+        self.moduleManager.openLoadModuleDialog()
+        
+    @pyqtSignature("")
+    def on_cancelButton_pressed(self):
+        self.close()
+
+

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,329 +1,331 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-        
-        self.setupUi(self)
-
-    def setupUi(self, Form):
-        Form.setObjectName("Form")
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName("gridlayout")
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName("splitter")
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName("ogreWidget")
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-        
-        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
-        
-    def ogreViewportCreatedCallback(self):
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-        
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-        if event.type() == 62:
-            print "dbg: DragLeave"
-        if event.type() == 63:
-            self.dropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            data = event.mimeData().data("application/x-static_model")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            data = event.mimeData().data("application/x-game_object")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def dropEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        if self.moduleManager.pivot:
-            self.moduleManager.pivot.update()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the preferences buttons and connect the signals
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
+                                    self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
+        self.ogreWindowOptions.setSizePolicy(sizePolicy)
+        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
+        self.splitterV.addWidget(self.ogreWindowOptions)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName("ogreWidget")
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
+
+    def onPreferencesButton(self):
+        self.splitterH.setOrientation(Qt.Vertical)
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print "dbg: DragLeave"
+        if event.type() == 63:
+            self.dropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()
+            
+    def updateRenderWindow(self):
+        self.ogreWidget.update()

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,154 +1,162 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.painted = False
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.cameraName = cameraName
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-        self.ogreViewportCreatedCallback = None
-        self.renderWindow = None
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-
-        if platform.system() == "Windows" or platform.system() == "MAC":
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            import sip
-            info = self.x11Info()
-            disp =  str(sip.unwrapinstance(info.display()))
-            scr = str(info.screen())
-            win = str(int(self.winId()))
-            winHandle = disp + ':' + scr + ':' + win
-            
-            self.renderParameters['parentWindowHandle'] = winHandle
-
-
-    def setBackgroundColor(self, colorValue):
-        if self.painted:
-            self.viewport.BackgroundColour = colorValue
-        else:
-            self.backGroundColor = colorValue
-
-    def setOgreViewportCreatedCallback(self, callback):
-        self.ogreViewportCreatedCallback = callback
-    
-    def paintEvent(self, event):
-        if not self.painted:
-            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
-                                                False, self.renderParameters)
-
-            renderWindow.active = True
-            self.renderWindow = renderWindow
-            
-            self.camera = self.sceneManager.createCamera(self.cameraName)
-            self.camera.NearClipDistance = 0.1
-
-            # Create focus node (camera always points at this)
-            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            # camera node is offset a ways along the Z axis of focus node
-            self.camNode = self.camFocusNode.createChildSceneNode()
-            # fix yaw on this one too for when we manipulate it directly
-            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-            self.camNode.attachObject(self.camera)
-            
-            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-            self.viewport.setClearEveryFrame(True)
-            self.viewport.BackgroundColour = self.backGroundColor
-            
-            if self.ogreViewportCreatedCallback:
-                self.ogreViewportCreatedCallback()
-            
-            self.painted = True
-
-    def resizeEvent(self, event):
-        if self.renderWindow:
-            self.renderWindow.resize(event.size().width(), event.size().height())
-            self.renderWindow.windowMovedOrResized()
-
-            if platform.system() == "Linux":
-                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-            self.renderWindow.update(True)
-            self.ogreRoot.renderOneFrame()
-
-            if self.camera:
-                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-                
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z < self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3& trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.cameraName = cameraName
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+        
+        win = str(int(self.winId()))
+        self.renderParameters['parentWindowHandle'] = win
+
+#        if platform.system() == "Windows" or platform.system() == "MAC":
+#            hwnd = int(self.winId())
+#            self.renderParameters['externalWindowHandle'] = str(hwnd)
+#        else:
+#            import sip
+#            info = self.x11Info()
+#            disp =  str(sip.unwrapinstance(info.display()))
+#            scr = str(info.screen())
+#            win = str(int(self.winId()))
+#            winHandle = disp + ':' + scr + ':' + win
+#            
+#            self.renderParameters['parentWindowHandle'] = win
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.1
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+        
+    def resizeEvent(self, event):
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
+
+            if platform.system() == "Linux":
+                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
+
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z < self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3& trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+        
+    def update(self):
+        if self.renderWindow is not None:
+            self.renderWindow.update(True)
+

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -40,7 +40,9 @@
         layout.addWidget(self.modulConfigSelector, 1, 1)
 
         self.setLayout(layout)
-
+        
+        self.moduleCfgPath = None
+        
         QObject.connect(self.modulConfigSelector, SIGNAL("clicked()"),
                                self.openModulConfigSelector)
 
@@ -70,7 +72,6 @@
             self.lineEdit.setText(self.moduleCfgPath)
 
 
-
     def onLoadSelectedModule(self):
         item = self.prefDialog.listWidget.currentItem()
 

Modified: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-24 17:18:15 UTC (rev 4774)
@@ -1,244 +1,244 @@
-import ctypes as ctypes
-import random
-
-import ogre.renderer.OGRE as og
-
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-# class to handle material switching without having to modify scene materials individually
-class MaterialSwitcher( og.MaterialManager.Listener ):
-    def __init__(self):
-        og.MaterialManager.Listener.__init__(self)
-      
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.currentColorAsVector3 = og.Vector3()
-        
-        self.lastEntity = ""
-        self.lastTechnique = None
-        
-        self.colorDict = {}
-       
-    # takes into account that one Entity can have multiple SubEntities
-    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
-        temp = str(type(subEntity))
-        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
-            if self.lastEntity == subEntity.getParent().getName():
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                return self.lastTechnique
-            else:
-                self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColor", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-                
-                self.randomizeColor()
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                
-                self.lastEntity = subEntity.getParent().getName()
-                self.colorDict[self.lastEntity] = self.currentColorAsVector3
-                return self.lastTechnique
-        
-
-    def randomizeColor(self):
-        r = random.randrange(1, 255)
-        g = random.randrange(1, 255)
-        b = random.randrange(1, 255)
-        self.currentColorAsVector3 = og.Vector3(r, g, b)
-        var = 1.0 / 255.0
-
-        self.currentColor = og.ColourValue(r * var, g * var, b * var)
-
-        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
-    
-    def reset(self):
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.lastEntity = ""
-        
-# We need this attached to the depth target, otherwise we get problems with the compositor
-# MaterialManager.Listener should NOT be running all the time - rather only when we're
-# specifically rendering the target that needs it
-class SelectionRenderListener(og.RenderTargetListener):
-    def __init__(self, materialListener):
-        og.RenderTargetListener.__init__(self)
-        self.materialListener = materialListener
- 
-    def preRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().addListener( self.materialListener )
- 
-    def postRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().removeListener( self.materialListener )
-
-        
-class SelectionBuffer():
-    def __init__(self, sceneManager,  renderTarget):
-        self.sceneMgr = sceneManager
-        self.camera = sceneManager.getCamera("MainCam")
-
-        self.renderTarget = renderTarget
-        
-        # This is the material listener - Note: it is controlled by a seperate
-        # RenderTargetListener, not applied globally to all targets
-        self.materialSwitchListener = MaterialSwitcher()
-        
-        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
-        
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        
-        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                                    og.TEX_TYPE_2D, 
-                                                                    width, 
-                                                                    height, 
-                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-        self.renderTexture = self.texture.getBuffer().getRenderTarget()
-        self.renderTexture.setAutoUpdated(False)
-        self.renderTexture.setPriority(0)                                                         
-        self.renderTexture.addViewport( self.camera )
-        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-        self.renderTexture.getViewport(0).setClearEveryFrame(True)
-        self.renderTexture.addListener( self.selectionTargetListener )
-        self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        
-        #self.createRTTOverlays()
-
-    def update(self):
-        self.updateBufferSize()
-        
-        self.renderTexture.update()        
-        self.materialSwitchListener.reset()
-        
-        pixelBuffer = self.texture.getBuffer()
-        bufferSize = pixelBuffer.getSizeInBytes()
-        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
-        
-        storageclass = ctypes.c_uint8 * (bufferSize)
-        self.buffer = storageclass()
-        
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
-
-        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-
-#        i = 0
-#        
-#        while i < len(self.buffer):
-#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
-#            
-#            i += 4
-    
-    def updateBufferSize(self):
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        needsSizeUpdate = False
-        
-        if width is not self.renderTexture.getWidth():
-            needsSizeUpdate = True
-        if height is not self.renderTexture.getHeight():
-            needsSizeUpdate = True            
-        
-        if needsSizeUpdate:
-            og.TextureManager.getSingleton().unload("SelectionPassTex")
-            
-            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                            og.TEX_TYPE_2D, 
-                                                            width, 
-                                                            height, 
-                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-            self.renderTexture = self.texture.getBuffer().getRenderTarget()
-            self.renderTexture.setAutoUpdated(False)
-            self.renderTexture.setPriority(0)                                                         
-            self.renderTexture.addViewport( self.camera )
-            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-            self.renderTexture.getViewport(0).setClearEveryFrame(True)
-            self.renderTexture.addListener( self.selectionTargetListener )
-            self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        else:
-            return
-            
-    def onSelectionClick(self, x, y):
-        self.update()
-        
-        posInStream = (self.pBox.getWidth() * y - 1)*4
-        posInStream += x*4
-        
-        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
-        
-        for key in self.materialSwitchListener.colorDict:
-            if self.materialSwitchListener.colorDict[key] == colVec:
-                if key == "OgreMainWin::0::ViewportGrid":
-                    return None
-                elif key == "rayLine":
-                    return None
-                elif key == "EditorXArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorYArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorZArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorFreeMover":
-                    return None
-                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                else:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    return so
-
-        return None
-        
-    def createRTTOverlays(self):
-        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
-        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
-        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
- 
-        textureUnit.setTextureName("SelectionPassTex")
- 
- 
-        overlayManager = og.OverlayManager.getSingleton()
-        # Create an overlay
-        self.mDebugOverlay = overlayManager.create("OverlayName")
- 
-        # Create a panel
-        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
-        panel.setMetricsMode(og.GMM_PIXELS)
-        panel.setPosition(10, 10)
-        panel.setDimensions(400, 280)
-        panel.setMaterialName("SelectionDebugMaterial") 
-        self.mDebugOverlay.add2D(panel)
- 
-        self.mDebugOverlay.show()
-
-
-
+import ctypes as ctypes
+import random
+
+import ogre.renderer.OGRE as og
+
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+        
+        self.lastEntity = ""
+        self.lastTechnique = None
+        
+        self.colorDict = {}
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+        temp = str(type(subEntity))
+        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                return self.lastTechnique
+            else:
+                self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColorGLSL", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getBestTechnique()
+                
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+                self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
+    
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = ""
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera("MainCam")
+
+        self.renderTarget = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        
+        #self.createRTTOverlays()
+
+    def update(self):
+        self.updateBufferSize()
+        
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        self.buffer = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
+
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i < len(self.buffer):
+#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
+#            
+#            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
+        
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload("SelectionPassTex")
+            
+            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        else:
+            return
+            
+    def onSelectionClick(self, x, y):
+        self.update()
+        
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
+        
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
+        
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                if key == "OgreMainWin::0::ViewportGrid":
+                    return None
+                elif key == "rayLine":
+                    return None
+                elif key == "EditorXArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorYArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorZArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorFreeMover":
+                    return None
+                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
+
+        return None
+        
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
+        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName("SelectionPassTex")
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create("OverlayName")
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName("SelectionDebugMaterial") 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+

Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-24 17:18:15 UTC (rev 4774)
@@ -141,3 +141,26 @@
 		}
 	}
 }
+
+fragment_program PlainColorGLSL_FP glsl
+{
+	source PlainColorFP.glsl
+	
+	default_params
+	{
+	      param_named_auto inColor custom 1
+	}
+}
+
+material PlainColorGLSL glsl
+{
+	technique
+	{
+		pass
+		{
+			fragment_program_ref PlainColorGLSL_FP
+			{
+			}
+		}
+	}
+}

Modified: rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColor.cg	2009-02-24 17:18:15 UTC (rev 4774)
@@ -25,8 +25,5 @@
 		uniform float4 inColor
 		)
 {	 
-	// Just sample texture using supplied UV
-	//color = float4(0, 1, 0, 1);
-	//color = float4(inColor.r, inColor.g, inColor.b, 1);
 	color = inColor;
 }

Added: rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-24 17:18:15 UTC (rev 4774)
@@ -0,0 +1,7 @@
+uniform vec4 inColor;
+
+void main(void)
+{
+	gl_FragColor = inColor;
+	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
+}
\ No newline at end of file

Added: rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-02-22 12:29:16 UTC (rev 4773)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-02-24 17:18:15 UTC (rev 4774)
@@ -0,0 +1,6 @@
+void main()
+{
+	gl_Position = ftransform();
+}
+
+



From fusion2 at mail.berlios.de  Tue Feb 24 19:17:16 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 24 Feb 2009 19:17:16 +0100
Subject: [Dsa-hl-svn] r4775 - in rl/trunk/editors/Lockenwickler/src: . media
Message-ID: <200902241817.n1OIHGqQ021127@sheep.berlios.de>

Author: fusion2
Date: 2009-02-24 19:16:58 +0100 (Tue, 24 Feb 2009)
New Revision: 4775

Modified:
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
Log:
- windows fix

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-24 17:18:15 UTC (rev 4774)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-24 18:16:58 UTC (rev 4775)
@@ -1,861 +1,861 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-
-
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
-
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace("\\", "/")
-        mapName = mapName.split("/")
-        mapName = mapName[len(mapName) - 1].split(".")
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + ".rlmap.xml"
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib["formatVersion"] == "0.4.0":
-                self.parseMapNodes(root.find("nodes"))
-                #self.parseMapZones(root.find("zones"))
-            else:
-                print pathToFile + " has wrong format version. It needs to be 0.4.0"
-                return
-
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator("entity")
-        
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator("light")
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator("sound")
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-
-        nodes = nodeElement.getiterator("particlesystem")
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib["name"]
-            meshFile = nodes.attrib["meshfile"]
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    posx = float(t.attrib["x"])
-                    posy = float(t.attrib["y"])
-                    posz = float(t.attrib["z"])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                elif t.tag == "scale":
-                    scalex = float(t.attrib["x"])
-                    scaley = float(t.attrib["y"])
-                    scalez = float(t.attrib["z"])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                continue
-
-            n = self.mapNode.createChild("entity_" + entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib["name"]
-            lightType = l.attrib["type"]
-            lightVisible = bool(l.attrib["visible"])
-            castShadows = bool(l.attrib["castShadows"])
-            lightPosition = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == "colourDiffuse":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == "colourSpecular":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == "lightAttenuation":
-                    lightAttenuationRange = float(t.attrib["range"])
-                    lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
-            
-
-            light = self.sceneManager.createLight(lightName)
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
-            light.setDiffuseColour(colourDiffuse)
-            light.setSpecularColour(colourSpecular)
-            
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)
-            
-            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild("light_" + lightName + "_node")
-            n.attachObject(e)
-            n.attachObject(light)
-            n.setPosition(lightPosition)
-
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib["class"]
-            id = int(g.attrib["id"])
-            state = g.attrib["state"]
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == "scale":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodeScale = og.Vector3(x, y, z)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
-                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-                if nodeScale:
-                    dropNode.setScale(nodeScale)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                go.inWorldId = id
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element("rastullahmap")
-        root.attrib["formatVersion"] = "0.4.0"
-        
-        nodesElem = xml.SubElement(root, "nodes")
-        
-        iter = self.mapNode.getChildIterator()
-        while iter.hasMoreElements():
-            name = iter.getNext().getName()
-            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib["name"]
-        
-            maps = root.getiterator("map")
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
-        
-    def save(self):
-        root = xml.Element("scene")
-        root.attrib["name"] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, "map")
-            sub.attrib["file"] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print "ERROR: could not find scene: " + sceneName
-        
-    
-    def isCommon(self):
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.isCommon() Error: couldn't find module config")
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("super("):
-                split = lStripped.split(",")
-                if split[2].strip() == unicode("true"):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    self.moduleDependencies.append(lStripped.split('"')[1])
-
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-
-        self.isLoaded = True
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.load: Error: couldn't find module config")
-            return
-
-        #for i, line in enumerate(f):
-            #lStripped = line.strip() #strip the whitespace away, not needed here
-
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        cmd = join(self.moduleRoot, "dsa/*.gof")
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, "maps/*.rlscene")
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-            
-        
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-
-    def setResourcePaths(self, recurseFolder = ""):
-        if recurseFolder == "":
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
-                self.setResourcePaths(curFile)
-            if os.path.isfile(curFile):
-                pass
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-                            
-class ModuleManager():
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-
-        self.moduleCfgPath = ""
-
-        self.gocManager = GameObjectClassManager()
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.propertyWindow = None
-    
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
-
-        self.moduleConfigIsParsed = True
-
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog()
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
-        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-                m.load()
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-                
-        self.moduleExplorer.updateView()
-#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-#        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
-#        e.setMaterialName("PlainColor")
-#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
-#
-#        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
-#        e2.setMaterialName("PlainColor")
-#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
-#        n.attachObject(e)
-#        n.attachObject(e2)
-#        n.setScale(og.Vector3(10, 5, 20))
-#        
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        if self.currentMap is None:
-            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:
-                self.propertyWindow.showProperties(so)
-                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-        if self.rayLine == None:
-            self.rayLine = self.sceneManager.createManualObject("rayLine")
-            self.rayLine.setDynamic(True)
-            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-
-            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-        else:
-            self.rayLine.beginUpdate(0)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = ""
-        split = name.split("_")
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + "_1"
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gameObjectRepresentationDict.append(newGO)
-                        newEntity.setUserObject(newGO)
-                        newGO.setPosition(og.Vector3(0, 0, 0))
-
-                        newSO = SelectionObject(newEntity, so.distance)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        self.dropCount += 1
-            else:
-                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-                entityName = self.incrementNameSuffixNumber(so.entity.getName())
-                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                newNode.attachObject(newEntity)
-                newNode.setPosition(so.entity.getParentNode().getPosition())
-                newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                newNode.setScale(so.entity.getParentNode().getScale())
-
-                newSO = SelectionObject(newEntity, so.distance)
-                newSO.setSelected(True)
-                newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print "sd"
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+
+
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace("\\", "/")
+        mapName = mapName.split("/")
+        mapName = mapName[len(mapName) - 1].split(".")
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                #self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
+
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("entity")
+        
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            meshFile = nodes.attrib["meshfile"]
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    posx = float(t.attrib["x"])
+                    posy = float(t.attrib["y"])
+                    posz = float(t.attrib["z"])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                elif t.tag == "scale":
+                    scalex = float(t.attrib["x"])
+                    scaley = float(t.attrib["y"])
+                    scalez = float(t.attrib["z"])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                continue
+
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
+                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
+            
+
+            light = self.sceneManager.createLight(lightName)
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
+            light.setDiffuseColour(colourDiffuse)
+            light.setSpecularColour(colourSpecular)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(e)
+            n.attachObject(light)
+            n.setPosition(lightPosition)
+
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            id = int(g.attrib["id"])
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "scale":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        iter = self.mapNode.getChildIterator()
+        while iter.hasMoreElements():
+            name = iter.getNext().getName()
+            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.isCommon() Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('"')[1])
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.load: Error: couldn't find module config")
+            return
+
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
+
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+            
+        
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            if os.path.isfile(curFile):
+                pass
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+                            
+class ModuleManager():
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
+        self.moduleCfgPath = ""
+
+        self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.propertyWindow = None
+    
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
+
+        self.moduleConfigIsParsed = True
+
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                
+        self.moduleExplorer.updateView()
+        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
+        e.setMaterialName("PlainColorGLSL")
+        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
+
+        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
+        e2.setMaterialName("PlainColor")
+        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
+        n.attachObject(e)
+        n.attachObject(e2)
+        n.setScale(og.Vector3(10, 5, 20))
+        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        if self.currentMap is None:
+            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:
+                self.propertyWindow.showProperties(so)
+                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+        if self.rayLine == None:
+            self.rayLine = self.sceneManager.createManualObject("rayLine")
+            self.rayLine.setDynamic(True)
+            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+
+            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+        else:
+            self.rayLine.beginUpdate(0)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = ""
+        split = name.split("_")
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + "_1"
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.moduleExplorer.updateView()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print "sd"
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-24 17:18:15 UTC (rev 4774)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2009-02-24 18:16:58 UTC (rev 4775)
@@ -1,162 +1,164 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.painted = False
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.cameraName = cameraName
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-        self.ogreViewportCreatedCallback = None
-        self.renderWindow = None
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-        
-        win = str(int(self.winId()))
-        self.renderParameters['parentWindowHandle'] = win
-
-#        if platform.system() == "Windows" or platform.system() == "MAC":
-#            hwnd = int(self.winId())
-#            self.renderParameters['externalWindowHandle'] = str(hwnd)
-#        else:
-#            import sip
-#            info = self.x11Info()
-#            disp =  str(sip.unwrapinstance(info.display()))
-#            scr = str(info.screen())
-#            win = str(int(self.winId()))
-#            winHandle = disp + ':' + scr + ':' + win
-#            
-#            self.renderParameters['parentWindowHandle'] = win
-
-
-    def setBackgroundColor(self, colorValue):
-        if self.painted:
-            self.viewport.BackgroundColour = colorValue
-        else:
-            self.backGroundColor = colorValue
-
-    def setOgreViewportCreatedCallback(self, callback):
-        self.ogreViewportCreatedCallback = callback
-    
-    def paintEvent(self, event):
-        if not self.painted:
-            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
-                                                False, self.renderParameters)
-
-            renderWindow.active = True
-            self.renderWindow = renderWindow
-            
-            self.camera = self.sceneManager.createCamera(self.cameraName)
-            self.camera.NearClipDistance = 0.1
-
-            # Create focus node (camera always points at this)
-            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            # camera node is offset a ways along the Z axis of focus node
-            self.camNode = self.camFocusNode.createChildSceneNode()
-            # fix yaw on this one too for when we manipulate it directly
-            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-            self.camNode.attachObject(self.camera)
-            
-            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-            self.viewport.setClearEveryFrame(True)
-            self.viewport.BackgroundColour = self.backGroundColor
-            
-            if self.ogreViewportCreatedCallback:
-                self.ogreViewportCreatedCallback()
-            
-            self.painted = True
-        
-    def resizeEvent(self, event):
-        if self.renderWindow:
-            self.renderWindow.resize(event.size().width(), event.size().height())
-            self.renderWindow.windowMovedOrResized()
-
-            if platform.system() == "Linux":
-                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-            self.renderWindow.update(True)
-            self.ogreRoot.renderOneFrame()
-
-            if self.camera:
-                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-                
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z < self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3& trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
-        
-    def update(self):
-        if self.renderWindow is not None:
-            self.renderWindow.update(True)
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.cameraName = cameraName
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+        
+
+        if platform.system() == "Windows" or platform.system() == "MAC":
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            win = str(int(self.winId()))
+            self.renderParameters['parentWindowHandle'] = win
+
+#        else:
+#            import sip
+#            info = self.x11Info()
+#            disp =  str(sip.unwrapinstance(info.display()))
+#            scr = str(info.screen())
+#            win = str(int(self.winId()))
+#            winHandle = disp + ':' + scr + ':' + win
+#            
+#            self.renderParameters['parentWindowHandle'] = win
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.1
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+        
+    def resizeEvent(self, event):
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
+
+            if platform.system() == "Linux":
+                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
+
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
+
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z < self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3& trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+        
+    def update(self):
+        if self.renderWindow is not None:
+            self.renderWindow.update(True)
+

Modified: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-24 17:18:15 UTC (rev 4774)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-24 18:16:58 UTC (rev 4775)
@@ -1,244 +1,244 @@
-import ctypes as ctypes
-import random
-
-import ogre.renderer.OGRE as og
-
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-# class to handle material switching without having to modify scene materials individually
-class MaterialSwitcher( og.MaterialManager.Listener ):
-    def __init__(self):
-        og.MaterialManager.Listener.__init__(self)
-      
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.currentColorAsVector3 = og.Vector3()
-        
-        self.lastEntity = ""
-        self.lastTechnique = None
-        
-        self.colorDict = {}
-       
-    # takes into account that one Entity can have multiple SubEntities
-    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
-        temp = str(type(subEntity))
-        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
-            if self.lastEntity == subEntity.getParent().getName():
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                return self.lastTechnique
-            else:
-                self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColorGLSL", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getBestTechnique()
-                
-                self.randomizeColor()
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                
-                self.lastEntity = subEntity.getParent().getName()
-                self.colorDict[self.lastEntity] = self.currentColorAsVector3
-                return self.lastTechnique
-        
-
-    def randomizeColor(self):
-        r = random.randrange(1, 255)
-        g = random.randrange(1, 255)
-        b = random.randrange(1, 255)
-        self.currentColorAsVector3 = og.Vector3(r, g, b)
-        var = 1.0 / 255.0
-
-        self.currentColor = og.ColourValue(r * var, g * var, b * var)
-
-        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
-    
-    def reset(self):
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.lastEntity = ""
-        
-# We need this attached to the depth target, otherwise we get problems with the compositor
-# MaterialManager.Listener should NOT be running all the time - rather only when we're
-# specifically rendering the target that needs it
-class SelectionRenderListener(og.RenderTargetListener):
-    def __init__(self, materialListener):
-        og.RenderTargetListener.__init__(self)
-        self.materialListener = materialListener
- 
-    def preRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().addListener( self.materialListener )
- 
-    def postRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().removeListener( self.materialListener )
-
-        
-class SelectionBuffer():
-    def __init__(self, sceneManager,  renderTarget):
-        self.sceneMgr = sceneManager
-        self.camera = sceneManager.getCamera("MainCam")
-
-        self.renderTarget = renderTarget
-        
-        # This is the material listener - Note: it is controlled by a seperate
-        # RenderTargetListener, not applied globally to all targets
-        self.materialSwitchListener = MaterialSwitcher()
-        
-        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
-        
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        
-        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                                    og.TEX_TYPE_2D, 
-                                                                    width, 
-                                                                    height, 
-                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-        self.renderTexture = self.texture.getBuffer().getRenderTarget()
-        self.renderTexture.setAutoUpdated(False)
-        self.renderTexture.setPriority(0)                                                         
-        self.renderTexture.addViewport( self.camera )
-        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-        self.renderTexture.getViewport(0).setClearEveryFrame(True)
-        self.renderTexture.addListener( self.selectionTargetListener )
-        self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        
-        #self.createRTTOverlays()
-
-    def update(self):
-        self.updateBufferSize()
-        
-        self.renderTexture.update()        
-        self.materialSwitchListener.reset()
-        
-        pixelBuffer = self.texture.getBuffer()
-        bufferSize = pixelBuffer.getSizeInBytes()
-        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
-        
-        storageclass = ctypes.c_uint8 * (bufferSize)
-        self.buffer = storageclass()
-        
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
-
-        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-
-#        i = 0
-#        
-#        while i < len(self.buffer):
-#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
-#            
-#            i += 4
-    
-    def updateBufferSize(self):
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        needsSizeUpdate = False
-        
-        if width is not self.renderTexture.getWidth():
-            needsSizeUpdate = True
-        if height is not self.renderTexture.getHeight():
-            needsSizeUpdate = True            
-        
-        if needsSizeUpdate:
-            og.TextureManager.getSingleton().unload("SelectionPassTex")
-            
-            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                            og.TEX_TYPE_2D, 
-                                                            width, 
-                                                            height, 
-                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-            self.renderTexture = self.texture.getBuffer().getRenderTarget()
-            self.renderTexture.setAutoUpdated(False)
-            self.renderTexture.setPriority(0)                                                         
-            self.renderTexture.addViewport( self.camera )
-            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-            self.renderTexture.getViewport(0).setClearEveryFrame(True)
-            self.renderTexture.addListener( self.selectionTargetListener )
-            self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        else:
-            return
-            
-    def onSelectionClick(self, x, y):
-        self.update()
-        
-        posInStream = (self.pBox.getWidth() * y - 1)*4
-        posInStream += x*4
-        
-        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
-        
-        for key in self.materialSwitchListener.colorDict:
-            if self.materialSwitchListener.colorDict[key] == colVec:
-                if key == "OgreMainWin::0::ViewportGrid":
-                    return None
-                elif key == "rayLine":
-                    return None
-                elif key == "EditorXArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorYArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorZArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorFreeMover":
-                    return None
-                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                else:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    return so
-
-        return None
-        
-    def createRTTOverlays(self):
-        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
-        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
-        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
- 
-        textureUnit.setTextureName("SelectionPassTex")
- 
- 
-        overlayManager = og.OverlayManager.getSingleton()
-        # Create an overlay
-        self.mDebugOverlay = overlayManager.create("OverlayName")
- 
-        # Create a panel
-        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
-        panel.setMetricsMode(og.GMM_PIXELS)
-        panel.setPosition(10, 10)
-        panel.setDimensions(400, 280)
-        panel.setMaterialName("SelectionDebugMaterial") 
-        self.mDebugOverlay.add2D(panel)
- 
-        self.mDebugOverlay.show()
-
-
-
+import ctypes as ctypes
+import random
+
+import ogre.renderer.OGRE as og
+
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+        
+        self.lastEntity = ""
+        self.lastTechnique = None
+        
+        self.colorDict = {}
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+        temp = str(type(subEntity))
+        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                return self.lastTechnique
+            else:
+                self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColorGLSL", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+                
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+                self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
+    
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = ""
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera("MainCam")
+
+        self.renderTarget = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        
+        #self.createRTTOverlays()
+
+    def update(self):
+        self.updateBufferSize()
+        
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        self.buffer = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
+
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i < len(self.buffer):
+#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
+#            
+#            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
+        
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload("SelectionPassTex")
+            
+            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        else:
+            return
+            
+    def onSelectionClick(self, x, y):
+        self.update()
+        
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
+        
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
+        
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                if key == "OgreMainWin::0::ViewportGrid":
+                    return None
+                elif key == "rayLine":
+                    return None
+                elif key == "EditorXArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorYArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorZArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorFreeMover":
+                    return None
+                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
+
+        return None
+        
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
+        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName("SelectionPassTex")
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create("OverlayName")
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName("SelectionDebugMaterial") 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+

Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-24 17:18:15 UTC (rev 4774)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-24 18:16:58 UTC (rev 4775)
@@ -142,6 +142,11 @@
 	}
 }
 
+fragment_program PlainColorGLSL_VP glsl
+{
+	source PlainColorVP.glsl
+}
+
 fragment_program PlainColorGLSL_FP glsl
 {
 	source PlainColorFP.glsl
@@ -158,6 +163,10 @@
 	{
 		pass
 		{
+			vertex_program_ref PlainColorGLSL_VP	
+			{
+			}
+			
 			fragment_program_ref PlainColorGLSL_FP
 			{
 			}

Modified: rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-24 17:18:15 UTC (rev 4774)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-24 18:16:58 UTC (rev 4775)
@@ -2,6 +2,6 @@
 
 void main(void)
 {
-	gl_FragColor = inColor;
-	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
+	//gl_FragColor = inColor;
+	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
 }
\ No newline at end of file



From fusion2 at mail.berlios.de  Tue Feb 24 20:29:39 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 24 Feb 2009 20:29:39 +0100
Subject: [Dsa-hl-svn] r4776 - in rl/trunk/editors/Lockenwickler: . src
	src/media
Message-ID: <200902241929.n1OJTdde002075@sheep.berlios.de>

Author: fusion2
Date: 2009-02-24 20:29:34 +0100 (Tue, 24 Feb 2009)
New Revision: 4776

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
Log:
- glsl SelectionBuffer shader fix

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-24 18:16:58 UTC (rev 4775)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-02-24 19:29:34 UTC (rev 4776)
@@ -1,180 +1,180 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-02-17, 21:39:20 -->
-<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.6">
-  <Language>en</Language>
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>src/Lockenwickler.py</Source>
-    <Source>src/ConsoleWindow.py</Source>
-    <Source>src/ModelSelectionDialog.py</Source>
-    <Source>src/ModuleManager.py</Source>
-    <Source>src/MovePivot.py</Source>
-    <Source>src/ObjectPropertyWin.py</Source>
-    <Source>src/OgreMainWindow.py</Source>
-    <Source>src/OgreWidget.py</Source>
-    <Source>src/PreferencesDialog.py</Source>
-    <Source>src/PythonOgreConfig.py</Source>
-    <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/Property.py</Source>
-    <Source>src/ViewportGrid.py</Source>
-    <Source>src/ObjectPropertyModel.py</Source>
-    <Source>src/GameObjectClass.py</Source>
-    <Source>src/GameObjectClassManager.py</Source>
-    <Source>src/setup.py</Source>
-    <Source>src/GameObjectClassView.py</Source>
-    <Source>src/MyRaySceneQueryListener.py</Source>
-    <Source>src/GOStringEditor.py</Source>
-    <Source>src/GOIntEditor.py</Source>
-    <Source>src/CodeDump.py</Source>
-    <Source>src/NewModuleWizard.py</Source>
-    <Source>src/Ui_NewModuleWizard.py</Source>
-    <Source>src/ModuleExplorer.py</Source>
-    <Source>src/SelectionBuffer.py</Source>
-  </Sources>
-  <Forms>
-    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
-    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
-    <Form>ui files/NewModuleWizard.ui</Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>src/Lockenwickler.py</MainScript>
-  <Vcs>
-    <VcsType>None</VcsType>
-    <VcsOptions>
-      <dict>
-        <key>
-          <string>add</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>checkout</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>commit</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>diff</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>export</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>global</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>history</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>log</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>remove</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>status</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>tag</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>update</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-      </dict>
-    </VcsOptions>
-    <VcsOtherData>
-      <dict>
-        <key>
-          <string>standardLayout</string>
-        </key>
-        <value>
-          <bool>True</bool>
-        </value>
-      </dict>
-    </VcsOtherData>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2009-02-17, 22:16:35 -->
+<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.6">
+  <Language>en</Language>
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/Property.py</Source>
+    <Source>src/ViewportGrid.py</Source>
+    <Source>src/ObjectPropertyModel.py</Source>
+    <Source>src/GameObjectClass.py</Source>
+    <Source>src/GameObjectClassManager.py</Source>
+    <Source>src/setup.py</Source>
+    <Source>src/GameObjectClassView.py</Source>
+    <Source>src/MyRaySceneQueryListener.py</Source>
+    <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/CodeDump.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
+    <Source>src/Ui_NewModuleWizard.py</Source>
+    <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>Subversion</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-24 18:16:58 UTC (rev 4775)
+++ rl/trunk/editors/Lockenwickler/src/SelectionBuffer.py	2009-02-24 19:29:34 UTC (rev 4776)
@@ -1,244 +1,244 @@
-import ctypes as ctypes
-import random
-
-import ogre.renderer.OGRE as og
-
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-# class to handle material switching without having to modify scene materials individually
-class MaterialSwitcher( og.MaterialManager.Listener ):
-    def __init__(self):
-        og.MaterialManager.Listener.__init__(self)
-      
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.currentColorAsVector3 = og.Vector3()
-        
-        self.lastEntity = ""
-        self.lastTechnique = None
-        
-        self.colorDict = {}
-       
-    # takes into account that one Entity can have multiple SubEntities
-    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
-        temp = str(type(subEntity))
-        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
-            if self.lastEntity == subEntity.getParent().getName():
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                return self.lastTechnique
-            else:
-                self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColorGLSL", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-                
-                self.randomizeColor()
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                
-                self.lastEntity = subEntity.getParent().getName()
-                self.colorDict[self.lastEntity] = self.currentColorAsVector3
-                return self.lastTechnique
-        
-
-    def randomizeColor(self):
-        r = random.randrange(1, 255)
-        g = random.randrange(1, 255)
-        b = random.randrange(1, 255)
-        self.currentColorAsVector3 = og.Vector3(r, g, b)
-        var = 1.0 / 255.0
-
-        self.currentColor = og.ColourValue(r * var, g * var, b * var)
-
-        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
-    
-    def reset(self):
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.lastEntity = ""
-        
-# We need this attached to the depth target, otherwise we get problems with the compositor
-# MaterialManager.Listener should NOT be running all the time - rather only when we're
-# specifically rendering the target that needs it
-class SelectionRenderListener(og.RenderTargetListener):
-    def __init__(self, materialListener):
-        og.RenderTargetListener.__init__(self)
-        self.materialListener = materialListener
- 
-    def preRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().addListener( self.materialListener )
- 
-    def postRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().removeListener( self.materialListener )
-
-        
-class SelectionBuffer():
-    def __init__(self, sceneManager,  renderTarget):
-        self.sceneMgr = sceneManager
-        self.camera = sceneManager.getCamera("MainCam")
-
-        self.renderTarget = renderTarget
-        
-        # This is the material listener - Note: it is controlled by a seperate
-        # RenderTargetListener, not applied globally to all targets
-        self.materialSwitchListener = MaterialSwitcher()
-        
-        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
-        
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        
-        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                                    og.TEX_TYPE_2D, 
-                                                                    width, 
-                                                                    height, 
-                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-        self.renderTexture = self.texture.getBuffer().getRenderTarget()
-        self.renderTexture.setAutoUpdated(False)
-        self.renderTexture.setPriority(0)                                                         
-        self.renderTexture.addViewport( self.camera )
-        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-        self.renderTexture.getViewport(0).setClearEveryFrame(True)
-        self.renderTexture.addListener( self.selectionTargetListener )
-        self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        
-        #self.createRTTOverlays()
-
-    def update(self):
-        self.updateBufferSize()
-        
-        self.renderTexture.update()        
-        self.materialSwitchListener.reset()
-        
-        pixelBuffer = self.texture.getBuffer()
-        bufferSize = pixelBuffer.getSizeInBytes()
-        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
-        
-        storageclass = ctypes.c_uint8 * (bufferSize)
-        self.buffer = storageclass()
-        
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
-
-        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-
-#        i = 0
-#        
-#        while i < len(self.buffer):
-#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
-#            
-#            i += 4
-    
-    def updateBufferSize(self):
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        needsSizeUpdate = False
-        
-        if width is not self.renderTexture.getWidth():
-            needsSizeUpdate = True
-        if height is not self.renderTexture.getHeight():
-            needsSizeUpdate = True            
-        
-        if needsSizeUpdate:
-            og.TextureManager.getSingleton().unload("SelectionPassTex")
-            
-            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                            og.TEX_TYPE_2D, 
-                                                            width, 
-                                                            height, 
-                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-            self.renderTexture = self.texture.getBuffer().getRenderTarget()
-            self.renderTexture.setAutoUpdated(False)
-            self.renderTexture.setPriority(0)                                                         
-            self.renderTexture.addViewport( self.camera )
-            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-            self.renderTexture.getViewport(0).setClearEveryFrame(True)
-            self.renderTexture.addListener( self.selectionTargetListener )
-            self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        else:
-            return
-            
-    def onSelectionClick(self, x, y):
-        self.update()
-        
-        posInStream = (self.pBox.getWidth() * y - 1)*4
-        posInStream += x*4
-        
-        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
-        
-        for key in self.materialSwitchListener.colorDict:
-            if self.materialSwitchListener.colorDict[key] == colVec:
-                if key == "OgreMainWin::0::ViewportGrid":
-                    return None
-                elif key == "rayLine":
-                    return None
-                elif key == "EditorXArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorYArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorZArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorFreeMover":
-                    return None
-                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                else:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    return so
-
-        return None
-        
-    def createRTTOverlays(self):
-        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
-        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
-        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
- 
-        textureUnit.setTextureName("SelectionPassTex")
- 
- 
-        overlayManager = og.OverlayManager.getSingleton()
-        # Create an overlay
-        self.mDebugOverlay = overlayManager.create("OverlayName")
- 
-        # Create a panel
-        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
-        panel.setMetricsMode(og.GMM_PIXELS)
-        panel.setPosition(10, 10)
-        panel.setDimensions(400, 280)
-        panel.setMaterialName("SelectionDebugMaterial") 
-        self.mDebugOverlay.add2D(panel)
- 
-        self.mDebugOverlay.show()
-
-
-
+import ctypes as ctypes
+import random
+
+import ogre.renderer.OGRE as og
+
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+        
+        self.lastEntity = ""
+        self.lastTechnique = None
+        
+        self.colorDict = {}
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+        temp = str(type(subEntity))
+        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                return self.lastTechnique
+            else:
+                self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColorGLSL", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+                
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+                self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
+    
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = ""
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera("MainCam")
+
+        self.renderTarget = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        
+#        self.createRTTOverlays()
+
+    def update(self):
+        self.updateBufferSize()
+        
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        self.buffer = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
+
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i < len(self.buffer):
+#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
+#            
+#            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
+        
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload("SelectionPassTex")
+            
+            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        else:
+            return
+            
+    def onSelectionClick(self, x, y):
+        self.update()
+        
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
+        
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
+        
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                if key == "OgreMainWin::0::ViewportGrid":
+                    return None
+                elif key == "rayLine":
+                    return None
+                elif key == "EditorXArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorYArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorZArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorFreeMover":
+                    return None
+                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
+
+        return None
+        
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
+        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName("SelectionPassTex")
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create("OverlayName")
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName("SelectionDebugMaterial") 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+

Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-24 18:16:58 UTC (rev 4775)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2009-02-24 19:29:34 UTC (rev 4776)
@@ -142,7 +142,7 @@
 	}
 }
 
-fragment_program PlainColorGLSL_VP glsl
+vertex_program PlainColorGLSL_VP glsl
 {
 	source PlainColorVP.glsl
 }

Modified: rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-24 18:16:58 UTC (rev 4775)
+++ rl/trunk/editors/Lockenwickler/src/media/PlainColorFP.glsl	2009-02-24 19:29:34 UTC (rev 4776)
@@ -2,6 +2,6 @@
 
 void main(void)
 {
-	//gl_FragColor = inColor;
-	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
+	gl_FragColor = inColor;
+	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
 }
\ No newline at end of file



From blakharaz at mail.berlios.de  Thu Feb 26 21:27:51 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 26 Feb 2009 21:27:51 +0100
Subject: [Dsa-hl-svn] r4777 - dependencies
Message-ID: <200902262027.n1QKRp8w032407@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-26 21:27:50 +0100 (Thu, 26 Feb 2009)
New Revision: 4777

Added:
   dependencies/OgreNewt_153/
Removed:
   dependencies/OgreNewt/
Log:
OgreNewt for Newton 2.0 is the default now

Copied: dependencies/OgreNewt_153 (from rev 4776, dependencies/OgreNewt)



From blakharaz at mail.berlios.de  Thu Feb 26 21:28:04 2009
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 26 Feb 2009 21:28:04 +0100
Subject: [Dsa-hl-svn] r4778 - dependencies
Message-ID: <200902262028.n1QKS4oP032420@sheep.berlios.de>

Author: blakharaz
Date: 2009-02-26 21:28:03 +0100 (Thu, 26 Feb 2009)
New Revision: 4778

Added:
   dependencies/OgreNewt/
Removed:
   dependencies/OgreNewt_ngt/
Log:
OgreNewt for Newton 2.0 is the default now

Copied: dependencies/OgreNewt (from rev 4777, dependencies/OgreNewt_ngt)



From fusion2 at mail.berlios.de  Thu Feb 26 21:56:44 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Thu, 26 Feb 2009 21:56:44 +0100
Subject: [Dsa-hl-svn] r4779 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200902262056.n1QKui0h002485@sheep.berlios.de>

Author: fusion2
Date: 2009-02-26 21:56:39 +0100 (Thu, 26 Feb 2009)
New Revision: 4779

Modified:
   rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
Log:
- linux fixes


Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py	2009-02-26 20:28:03 UTC (rev 4778)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py	2009-02-26 20:56:39 UTC (rev 4779)
@@ -28,7 +28,8 @@
     def __init__(self, parent = None):
         super(GoTreeWidget, self).__init__(parent)
         self.setDragEnabled(True)
-
+        self.setAnimated(True)
+        
     def startDrag(self,  dropActions):
         data = QByteArray()
         stream = QDataStream(data,  QIODevice.WriteOnly)

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-26 20:28:03 UTC (rev 4778)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-02-26 20:56:39 UTC (rev 4779)
@@ -1,158 +1,181 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#dienstag 24.03 15.50
-import sys
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-import ogre.renderer.OGRE as og
-
-class NameInputDlg(QDialog):
-    def __init__(self, parent = None):
-        super(NameInputDlg, self).__init__(parent)
-        
-        self.nameInput = QLineEdit(self)
-        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        layout = QVBoxLayout()
-        layout.addWidget(self.nameInput)
-        layout.addWidget(buttonBox)
-        self.setLayout(layout)
-        
-        self.connect(buttonBox, SIGNAL("accepted()"), self, SLOT("accept()"))        
-        self.connect(buttonBox, SIGNAL("rejected()"), self, SLOT("reject()"))
-        
-        
-class ModuleTreeWidget(QTreeWidget):
-    def __init__(self, parent = None):
-        super(ModuleTreeWidget, self).__init__(parent)
-        
-        self.setContextMenuPolicy(Qt.CustomContextMenu)        
-        self.connect(self, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
-
-        self.onMenuCallback = None
-
-
-#        clearAction= QAction("Clear Window",  self)
-#        self.consoleWindow.textEdit.addAction(clearAction)
-#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-#        clearAction.setShortcut("Ctrl + R")
-#        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
-
-    def setMenuCallback(self, callback):
-        self.onMenuCallback = callback
-        
-    def doMenu(self, point):
-        self.onMenuCallback(self.mapToGlobal(point))
-
-class ModuleExplorer(QWidget):
-    def __init__(self, parent=None):
-        QWidget.__init__(self, parent)
-        self.sceneTreeView = ModuleTreeWidget()
-        
-        self.sceneTreeView.setMenuCallback(self.onMenu)
-        self.connect(self.sceneTreeView, SIGNAL("itemClicked (QTreeWidgetItem *,int)"), self.onClick)
-        
-        vBoxLayout = QVBoxLayout()
-        vBoxLayout.addWidget(self.sceneTreeView)
-
-        self.setLayout(vBoxLayout)
-        
-        self.nodeDict = {}
-        
-        self.moduleManager = None
-        self.mapSelectedCallback = None
-        
-    def onClick(self, item, column):
-        if self.mapSelectedCallback is None:
-            return
-        
-        name = str(item.text(0))
-        if name.startswith("Map: "):
-            self.mapSelectedCallback(str(item.parent().text(0)).replace("Scene: ", ""), name.replace("Map: ", ""))
-        elif name.startswith("Scene: "):
-            if item.childCount > 0:
-                self.mapSelectedCallback(name.replace("Scene: ", ""), None)
-                return
-                
-            self.mapSelectedCallback(name.replace("Scene: ", ""), str(item.child(0).text(0)).replace("Map: ", ""))
-        
-    def onMenu(self, point):
-        if self.moduleManager is not None:
-            menu = QMenu(self)
-            
-            newSceneAction= QAction("New Scene",  self)
-            menu.addAction(newSceneAction)
-            self.connect(newSceneAction, SIGNAL("triggered()"), self.onNewScene)
-
-            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith("Scene:"):
-                newMapAction= QAction("New Map",  self)
-                menu.addAction(newMapAction)
-                self.connect(newMapAction, SIGNAL("triggered()"), self.onNewMap)
-
-            deleteAction= QAction("Delete",  self)
-            menu.addAction(deleteAction)
-            self.connect(deleteAction, SIGNAL("triggered()"), self.onDelete)
-            
-            menu.exec_(point)
-      
-    def onNewScene(self):
-        dlg = NameInputDlg(self)
-        if dlg.exec_():
-            self.moduleManager.addSceneToModule(str(dlg.nameInput.text()))
-            self.updateView()
-            self.onNewMap()
-            
-    def onNewMap(self):
-        dlg = NameInputDlg(self)
-        if dlg.exec_():
-            sceneName = str(self.sceneTreeView.currentItem().text(0)).replace("Scene: ", "")
-            self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
-            self.updateView()
-        
-    def onDelete(self):
-        print "delete"
-      
-    def updateView(self):
-        self.sceneTreeView.clear()
-        
-        for s in self.module.scenes:
-            sceneRootItem = QTreeWidgetItem(self.sceneTreeView)
-            sceneRootItem.setText(0, "Scene: " + s.name)
-            
-            for m in s.mapFiles:
-                self.parseMap(m, sceneRootItem)
-
-                
-    def parseMap(self, map, sceneRootItem):
-        childItem =  QTreeWidgetItem(sceneRootItem)
-        childItem.setText(0, "Map: " + map.mapName)
-        
-        iter = map.mapNode.getChildIterator()
-        while iter.hasMoreElements():
-            childItem2 = QTreeWidgetItem(childItem) 
-            childItem2.setText(0, iter.getNext().getName())
-        
-    def setCurrentModule(self, module):
-        self.module = module
-        self.updateView()
-
-    def setModuleManager(self, moduleManager):
-        self.moduleManager = moduleManager
-        
-    def setMapSelectedCallback(self, callback):
-        self.mapSelectedCallback = callback
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+#dienstag 24.03 15.50
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+import ogre.renderer.OGRE as og
+
+class NameInputDlg(QDialog):
+    def __init__(self, parent = None):
+        super(NameInputDlg, self).__init__(parent)
+        
+        self.nameInput = QLineEdit(self)
+        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        layout = QVBoxLayout()
+        layout.addWidget(self.nameInput)
+        layout.addWidget(buttonBox)
+        self.setLayout(layout)
+        
+        self.connect(buttonBox, SIGNAL("accepted()"), self, SLOT("accept()"))        
+        self.connect(buttonBox, SIGNAL("rejected()"), self, SLOT("reject()"))
+        
+        
+class ModuleTreeWidget(QTreeWidget):
+    def __init__(self, parent = None):
+        super(ModuleTreeWidget, self).__init__(parent)
+        
+        self.setContextMenuPolicy(Qt.CustomContextMenu)        
+        self.connect(self, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
+
+        self.onMenuCallback = None
+        self.setAnimated(True)
+
+#        clearAction= QAction("Clear Window",  self)
+#        self.consoleWindow.textEdit.addAction(clearAction)
+#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+#        clearAction.setShortcut("Ctrl + R")
+#        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
+
+    def setMenuCallback(self, callback):
+        self.onMenuCallback = callback
+        
+    def doMenu(self, point):
+        self.onMenuCallback(self.mapToGlobal(point))
+
+class ModuleExplorer(QWidget):
+    def __init__(self, parent=None):
+        QWidget.__init__(self, parent)
+        self.sceneTreeView = ModuleTreeWidget()
+        
+        self.sceneTreeView.setMenuCallback(self.onMenu)
+        self.connect(self.sceneTreeView, SIGNAL("itemClicked (QTreeWidgetItem *,int)"), self.onClick)
+        
+        vBoxLayout = QVBoxLayout()
+        vBoxLayout.addWidget(self.sceneTreeView)
+
+        self.setLayout(vBoxLayout)
+        
+        self.nodeDict = {}
+        
+        self.moduleManager = None
+        self.mapSelectedCallback = None
+        
+        self.lastSelectedMap = None
+        
+    def onClick(self, item, column):
+        if self.mapSelectedCallback is None:
+            return
+        
+        name = str(item.text(0))
+        if name.startswith("Map: "):
+            self.mapSelectedCallback(str(item.parent().text(0)).replace("Scene: ", ""), name.replace("Map: ", ""))
+            self.lastSelectedMap = name
+        elif name.startswith("Scene: "):
+            if item.childCount > 0:
+                self.mapSelectedCallback(name.replace("Scene: ", ""), None)
+                return
+            self.mapSelectedCallback(name.replace("Scene: ", ""), str(item.child(0).text(0)).replace("Map: ", ""))
+            self.lastSelectedMap = name
+        else:
+            self.mapSelectedCallback(str(item.parent().parent().text(0)).replace("Scene: ", ""), str(item.parent().text(0)).replace("Map: ", ""))
+            self.lastSelectedMap = name
+            
+
+        
+    def onMenu(self, point):
+        if self.moduleManager is not None:
+            menu = QMenu(self)
+            
+            newSceneAction= QAction("New Scene",  self)
+            menu.addAction(newSceneAction)
+            self.connect(newSceneAction, SIGNAL("triggered()"), self.onNewScene)
+
+            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith("Scene:"):
+                newMapAction= QAction("New Map",  self)
+                menu.addAction(newMapAction)
+                self.connect(newMapAction, SIGNAL("triggered()"), self.onNewMap)
+
+            deleteAction= QAction("Delete",  self)
+            menu.addAction(deleteAction)
+            self.connect(deleteAction, SIGNAL("triggered()"), self.onDelete)
+            
+            menu.exec_(point)
+      
+    def onNewScene(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            self.moduleManager.addSceneToModule(str(dlg.nameInput.text()))
+            self.updateView()
+            self.onNewMap()
+            
+    def onNewMap(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            sceneName = str(self.sceneTreeView.currentItem().text(0)).replace("Scene: ", "")
+            self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
+            self.updateView()
+        
+    def onDelete(self):
+        print "delete"
+      
+    def updateView(self):
+        self.sceneTreeView.clear()
+        
+        for s in self.module.scenes:
+            sceneRootItem = QTreeWidgetItem(self.sceneTreeView)
+            sceneRootItem.setText(0, "Scene: " + s.name)
+            
+            for m in s.mapFiles:
+                self.parseMap(m, sceneRootItem)
+
+
+    def parseMap(self, map, sceneRootItem):
+        childItem =  QTreeWidgetItem(sceneRootItem)
+        mn = "Map: " + map.mapName
+        childItem.setText(0, mn)
+        if mn == self.lastSelectedMap:
+            childItem.setSelected(True)
+            childItem.parent().setExpanded(True)
+        
+        i = 0
+        while i < map.mapNode.numChildren():
+            childItem2 = QTreeWidgetItem(childItem) 
+            childItem2.setText(0, map.mapNode.getChild(i).getName())
+            i = i+1
+
+
+# this crashed in linux
+#        iter = map.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            childItem2 = QTreeWidgetItem(childItem) 
+#            val = iter.getNext()
+#            if  val is not None:
+#                childItem2.setText(0, val.getName())
+
+        
+    def setCurrentModule(self, module):
+        self.module = module
+        self.updateView()
+
+    def setModuleManager(self, moduleManager):
+        self.moduleManager = moduleManager
+        
+    def setMapSelectedCallback(self, callback):
+        self.mapSelectedCallback = callback

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-26 20:28:03 UTC (rev 4778)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-26 20:56:39 UTC (rev 4779)
@@ -1,861 +1,881 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-
-
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
-
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace("\\", "/")
-        mapName = mapName.split("/")
-        mapName = mapName[len(mapName) - 1].split(".")
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + ".rlmap.xml"
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib["formatVersion"] == "0.4.0":
-                self.parseMapNodes(root.find("nodes"))
-                #self.parseMapZones(root.find("zones"))
-            else:
-                print pathToFile + " has wrong format version. It needs to be 0.4.0"
-                return
-
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator("entity")
-        
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator("light")
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator("sound")
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-
-        nodes = nodeElement.getiterator("particlesystem")
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib["name"]
-            meshFile = nodes.attrib["meshfile"]
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    posx = float(t.attrib["x"])
-                    posy = float(t.attrib["y"])
-                    posz = float(t.attrib["z"])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                elif t.tag == "scale":
-                    scalex = float(t.attrib["x"])
-                    scaley = float(t.attrib["y"])
-                    scalez = float(t.attrib["z"])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                continue
-
-            n = self.mapNode.createChild("entity_" + entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib["name"]
-            lightType = l.attrib["type"]
-            lightVisible = bool(l.attrib["visible"])
-            castShadows = bool(l.attrib["castShadows"])
-            lightPosition = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == "colourDiffuse":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == "colourSpecular":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == "lightAttenuation":
-                    lightAttenuationRange = float(t.attrib["range"])
-                    lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
-            
-
-            light = self.sceneManager.createLight(lightName)
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
-            light.setDiffuseColour(colourDiffuse)
-            light.setSpecularColour(colourSpecular)
-            
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)
-            
-            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild("light_" + lightName + "_node")
-            n.attachObject(e)
-            n.attachObject(light)
-            n.setPosition(lightPosition)
-
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib["class"]
-            id = int(g.attrib["id"])
-            state = g.attrib["state"]
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == "scale":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodeScale = og.Vector3(x, y, z)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
-                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-                if nodeScale:
-                    dropNode.setScale(nodeScale)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                go.inWorldId = id
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element("rastullahmap")
-        root.attrib["formatVersion"] = "0.4.0"
-        
-        nodesElem = xml.SubElement(root, "nodes")
-        
-        iter = self.mapNode.getChildIterator()
-        while iter.hasMoreElements():
-            name = iter.getNext().getName()
-            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib["name"]
-        
-            maps = root.getiterator("map")
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
-        
-    def save(self):
-        root = xml.Element("scene")
-        root.attrib["name"] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, "map")
-            sub.attrib["file"] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print "ERROR: could not find scene: " + sceneName
-        
-    
-    def isCommon(self):
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.isCommon() Error: couldn't find module config")
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("super("):
-                split = lStripped.split(",")
-                if split[2].strip() == unicode("true"):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    self.moduleDependencies.append(lStripped.split('"')[1])
-
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-
-        self.isLoaded = True
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.load: Error: couldn't find module config")
-            return
-
-        #for i, line in enumerate(f):
-            #lStripped = line.strip() #strip the whitespace away, not needed here
-
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        cmd = join(self.moduleRoot, "dsa/*.gof")
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, "maps/*.rlscene")
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-            
-        
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-
-    def setResourcePaths(self, recurseFolder = ""):
-        if recurseFolder == "":
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
-                self.setResourcePaths(curFile)
-            if os.path.isfile(curFile):
-                pass
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-                            
-class ModuleManager():
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-
-        self.moduleCfgPath = ""
-
-        self.gocManager = GameObjectClassManager()
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.propertyWindow = None
-    
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
-
-        self.moduleConfigIsParsed = True
-
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog()
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
-        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-                m.load()
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-                
-        self.moduleExplorer.updateView()
-        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
-        e.setMaterialName("PlainColorGLSL")
-        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
-
-        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
-        e2.setMaterialName("PlainColor")
-        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
-        n.attachObject(e)
-        n.attachObject(e2)
-        n.setScale(og.Vector3(10, 5, 20))
-        
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        if self.currentMap is None:
-            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:
-                self.propertyWindow.showProperties(so)
-                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-        if self.rayLine == None:
-            self.rayLine = self.sceneManager.createManualObject("rayLine")
-            self.rayLine.setDynamic(True)
-            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-
-            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-        else:
-            self.rayLine.beginUpdate(0)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = ""
-        split = name.split("_")
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + "_1"
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gameObjectRepresentationDict.append(newGO)
-                        newEntity.setUserObject(newGO)
-                        newGO.setPosition(og.Vector3(0, 0, 0))
-
-                        newSO = SelectionObject(newEntity, so.distance)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        self.dropCount += 1
-            else:
-                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-                entityName = self.incrementNameSuffixNumber(so.entity.getName())
-                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                newNode.attachObject(newEntity)
-                newNode.setPosition(so.entity.getParentNode().getPosition())
-                newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                newNode.setScale(so.entity.getParentNode().getScale())
-
-                newSO = SelectionObject(newEntity, so.distance)
-                newSO.setSelected(True)
-                newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print "sd"
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+
+
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace("\\", "/")
+        mapName = mapName.split("/")
+        mapName = mapName[len(mapName) - 1].split(".")
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                #self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
+
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("entity")
+        
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            meshFile = nodes.attrib["meshfile"]
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    posx = float(t.attrib["x"])
+                    posy = float(t.attrib["y"])
+                    posz = float(t.attrib["z"])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                elif t.tag == "scale":
+                    scalex = float(t.attrib["x"])
+                    scaley = float(t.attrib["y"])
+                    scalez = float(t.attrib["z"])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                continue
+
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
+                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
+            
+
+            light = self.sceneManager.createLight(lightName)
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
+            light.setDiffuseColour(colourDiffuse)
+            light.setSpecularColour(colourSpecular)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(e)
+            n.attachObject(light)
+            n.setPosition(lightPosition)
+
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            id = int(g.attrib["id"])
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "scale":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodeScale = og.Vector3(x, y, z)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+                if nodeScale:
+                    dropNode.setScale(nodeScale)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                go.inWorldId = id
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        i = 0
+        while i < self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.name.startswith("entity_"):
+                entElem = xml.SubElement(nodesElem, "entity")
+                entElem.attrib["name"] = n.getAttachedObject(0).getName()
+                entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
+                
+            i = i+1
+            
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.isCommon() Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('"')[1])
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.load: Error: couldn't find module config")
+            return
+
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
+
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+            
+        
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            if os.path.isfile(curFile):
+                pass
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+                            
+class ModuleManager():
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+
+        self.moduleCfgPath = ""
+
+        self.gocManager = GameObjectClassManager()
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.propertyWindow = None
+    
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
+
+        self.moduleConfigIsParsed = True
+
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                
+        self.moduleExplorer.updateView()
+        
+#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
+#        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
+#        e.setMaterialName("PlainColorGLSL")
+#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
+#
+#        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
+#        e2.setMaterialName("PlainColor")
+#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
+#        n.attachObject(e)
+#        n.attachObject(e2)
+#        n.setScale(og.Vector3(10, 5, 20))
+        
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        if self.currentMap is None:
+            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:
+                self.propertyWindow.showProperties(so)
+                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+        if self.rayLine == None:
+            self.rayLine = self.sceneManager.createManualObject("rayLine")
+            self.rayLine.setDynamic(True)
+            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+
+            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+        else:
+            self.rayLine.beginUpdate(0)
+
+            self.rayLine.position(ray.getOrigin())
+            self.rayLine.position( ray.getPoint(10000))
+
+            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = ""
+        split = name.split("_")
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + "_1"
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.moduleExplorer.updateView()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print "sd"
+
+    def startDropModelAction(self, meshFile, ray):
+        if self.currentMap is None:
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-26 20:28:03 UTC (rev 4778)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-26 20:56:39 UTC (rev 4779)
@@ -1,129 +1,130 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from Property import *
-
-class ObjectPropertyWin(QDialog):
-    def __init__(self, parent=None):
-        super(QDialog, self).__init__(parent)
-        self.setupUi()
-
-        self.so = None
-
-        self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
-                               self.onItemClicked)
-
-    def setupUi(self):
-        self.setObjectName("ObjectPropertys")
-        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
-
-        self.treeWidget = QTreeWidget(self)
-        self.treeWidget.setGeometry(QRect(0,0,901,721))
-        self.treeWidget.setMinimumSize(QSize(400,400))
-        self.treeWidget.setObjectName("treeWidget")
-        self.treeWidget.setAlternatingRowColors(True)
-        
-        self.retranslateUi()
-        QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.treeWidget.headerItem().setText(0,QApplication.translate("ObjectPropertys", "Property", None, QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(1,QApplication.translate("ObjectPropertys", "Value", None, QApplication.UnicodeUTF8))
-        self.treeWidget.clear()
-
-
-    def onItemClicked(self, item, column):
-        pass
-        
-    def showProperties(self, so):
-        self.so=so
-        self.treeWidget.clear()
-        
-        name = so.entity.getParentNode().getName()
-        node = so.entity.getParentNode()
-        
-        if name.startswith("entity_"):
-            item = QTreeWidgetItem(self.treeWidget)
-            item.setText(0, "Name")
-            item.setText(1, name.replace("entity_", ""))
-            
-            self.parsePosition(node)
-            self.parseOrientation(node)
-            self.parseScale(node)
-            
-    def parsePosition(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, "Position")
-        item.setText(1, str(node.getPosition().x) + " " + str(node.getPosition().y) + " " + str(node.getPosition().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, "X")
-        itemX.setText(1, str(node.getPosition().x))
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, "Y")
-        itemY.setText(1, str(node.getPosition().y))
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, "Z")
-        itemZ.setText(1, str(node.getPosition().z))
-        
-    def parseOrientation(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, "Orientation")
-        item.setText(1, str(node.getOrientation().x) + " " + str(node.getOrientation().y) + " " + str(node.getOrientation().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, "X")
-        itemX.setText(1, str(node.getOrientation().x))
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, "Y")
-        itemY.setText(1, str(node.getOrientation().y))
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, "Z")
-        itemZ.setText(1, str(node.getOrientation().z))
-    
-    def parseScale(self, node):
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0, "Scale")
-        item.setText(1, str(node.getScale().x) + " " + str(node.getScale().y) + " " + str(node.getScale().z))
-        
-        itemX = QTreeWidgetItem(item)
-        itemX.setText(0, "X")
-        itemX.setText(1, str(node.getScale().x))
-        
-        itemY = QTreeWidgetItem(item)
-        itemY.setText(0, "Y")
-        itemY.setText(1, str(node.getScale().y))
-        
-        itemZ = QTreeWidgetItem(item)
-        itemZ.setText(0, "Z")
-        itemZ.setText(1, str(node.getScale().z))
-            
-    def updateProperties(self):
-        if self.so is not None:
-            self.showProperties(self.so)
-            
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from Property import *
+
+class ObjectPropertyWin(QDialog):
+    def __init__(self, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setupUi()
+
+        self.so = None
+
+        self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
+                               self.onItemClicked)
+
+    def setupUi(self):
+        self.setObjectName("ObjectPropertys")
+        self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
+
+        self.treeWidget = QTreeWidget(self)
+        self.treeWidget.setGeometry(QRect(0,0,901,721))
+        self.treeWidget.setMinimumSize(QSize(400,400))
+        self.treeWidget.setObjectName("treeWidget")
+        self.treeWidget.setAlternatingRowColors(True)
+        self.treeWidget.setAnimated(True)
+        
+        self.retranslateUi()
+        QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.treeWidget.headerItem().setText(0,QApplication.translate("ObjectPropertys", "Property", None, QApplication.UnicodeUTF8))
+        self.treeWidget.headerItem().setText(1,QApplication.translate("ObjectPropertys", "Value", None, QApplication.UnicodeUTF8))
+        self.treeWidget.clear()
+
+
+    def onItemClicked(self, item, column):
+        pass
+        
+    def showProperties(self, so):
+        self.so=so
+        self.treeWidget.clear()
+        
+        name = so.entity.getParentNode().getName()
+        node = so.entity.getParentNode()
+        
+        if name.startswith("entity_"):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Name")
+            item.setText(1, name.replace("entity_", ""))
+            
+            self.parsePosition(node)
+            self.parseOrientation(node)
+            self.parseScale(node)
+            
+    def parsePosition(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Position")
+        item.setText(1, str(node.getPosition().x) + ", " + str(node.getPosition().y) + ", " + str(node.getPosition().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getPosition().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getPosition().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getPosition().z))
+        
+    def parseOrientation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Orientation")
+        item.setText(1, str(node.getOrientation().x) + ", " + str(node.getOrientation().y) + ", " + str(node.getOrientation().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getOrientation().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getOrientation().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getOrientation().z))
+    
+    def parseScale(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Scale")
+        item.setText(1, str(node.getScale().x) + ", " + str(node.getScale().y) + ", " + str(node.getScale().z))
+        
+        itemX = QTreeWidgetItem(item)
+        itemX.setText(0, "X")
+        itemX.setText(1, str(node.getScale().x))
+        
+        itemY = QTreeWidgetItem(item)
+        itemY.setText(0, "Y")
+        itemY.setText(1, str(node.getScale().y))
+        
+        itemZ = QTreeWidgetItem(item)
+        itemZ.setText(0, "Z")
+        itemZ.setText(1, str(node.getScale().z))
+            
+    def updateProperties(self):
+        if self.so is not None:
+            self.showProperties(self.so)
+            



From fusion2 at mail.berlios.de  Sat Feb 28 15:41:14 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sat, 28 Feb 2009 15:41:14 +0100
Subject: [Dsa-hl-svn] r4780 - in rl/trunk/editors/Lockenwickler/src: .
	media/icons
Message-ID: <200902281441.n1SEfEHY010464@sheep.berlios.de>

Author: fusion2
Date: 2009-02-28 15:41:09 +0100 (Sat, 28 Feb 2009)
New Revision: 4780

Added:
   rl/trunk/editors/Lockenwickler/src/media/icons/fileopen.png
Modified:
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
Log:
- its now possible to change the entity name, position, orientation and scale using the using the Property Window
- added a icon for the open module action

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-26 20:56:39 UTC (rev 4779)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-02-28 14:41:09 UTC (rev 4780)
@@ -57,7 +57,7 @@
         self.setupOgre()
 
         self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self)
         self.moduleExplorerWin = ModuleExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
         self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
@@ -146,10 +146,10 @@
         self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
         self.actionNeu.setObjectName("actionNeu")
 
-        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "filenew.png",  "Open Module")
+        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "fileopen.png",  "Open Module")
         self.actionOpen.setObjectName("actionOpen")
         
-        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filenew.png",  "Save Module")
+        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filesave.png",  "Save Module")
         self.actionSave.setObjectName("actionSave")
 
         self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
@@ -403,6 +403,7 @@
         self.fileToolBar.setObjectName("FileToolBar")
         self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
         self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionOpen)
         self.fileToolBar.addAction(self.actionSave)
         self.fileToolBar.addAction(self.actionClose)
         self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-26 20:56:39 UTC (rev 4779)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-02-28 14:41:09 UTC (rev 4780)
@@ -75,7 +75,6 @@
         if level and (not elem.tail or not elem.tail.strip()):
             elem.tail = i
 
-
 class Map():
     def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
         self.pathToMapFile = pathToFile
@@ -123,6 +122,12 @@
     def createEntites(self, entityNodes):
         for nodes in entityNodes:
             entityName = nodes.attrib["name"]
+            
+            if entityName.startswith("dropMesh"):
+                num = int(entityName.replace("dropMesh",  ""))
+                if ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num
+                    
             meshFile = nodes.attrib["meshfile"]
             nodePosition = None
             nodeScale = None
@@ -282,6 +287,22 @@
                 entElem.attrib["name"] = n.getAttachedObject(0).getName()
                 entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
                 
+                posElem = xml.SubElement(entElem, "position")
+                posElem.attrib["x"] = str(n.getPosition().x)
+                posElem.attrib["y"] = str(n.getPosition().y)
+                posElem.attrib["z"] = str(n.getPosition().z)
+                
+                rotElem = xml.SubElement(entElem, "rotation")
+                rotElem.attrib["qw"] = str(n.getOrientation().w)
+                rotElem.attrib["qx"] = str(n.getOrientation().x)
+                rotElem.attrib["qy"] = str(n.getOrientation().y)
+                rotElem.attrib["qz"] = str(n.getOrientation().z)
+                
+                scaleElem = xml.SubElement(entElem, "scale")
+                scaleElem.attrib["x"] = str(n.getScale().x)
+                scaleElem.attrib["y"] = str(n.getScale().y)
+                scaleElem.attrib["z"] = str(n.getScale().z)
+                
             i = i+1
             
         indent(root)
@@ -467,6 +488,8 @@
                             return m
                             
 class ModuleManager():
+    dropCount = 0
+        
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
@@ -475,6 +498,7 @@
         self.moduleCfgPath = ""
 
         self.gocManager = GameObjectClassManager()
+        
         # we need to hold a reference to the game object representaions ourself
         # python does not recognize the a reference to a c++ object (Entity in our case) is passed
         # and deletes the object
@@ -500,7 +524,7 @@
         self.middleMouseDown = False
         self.rightMouseDown = False
 
-        self.dropCount = 0
+       
         self.dropNode = None
         self.dropEntity = None
         self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
@@ -533,7 +557,6 @@
 
         self.moduleConfigIsParsed = True
 
-
     def moduleExists(self, name):
         lowerA = str(name).lower()
         
@@ -584,7 +607,7 @@
                 self.moduleExplorer.setCurrentModule(m)
                 
         self.moduleExplorer.updateView()
-        
+        ModuleManager.dropCount += 1
 #        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
 #        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
 #        e.setMaterialName("PlainColorGLSL")
@@ -725,12 +748,12 @@
                     meshFile = go.getMeshFileName()
 
                     if go is not None:
-                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+                        newEntity = self.sceneManager.createEntity("dropMesh" + str(ModuleManager.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(ModuleManager.dropCount))
                         newNode.attachObject(newEntity)
                         newNode.setPosition(so.entity.getParentNode().getPosition())
 
-                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
                         self.gameObjectRepresentationDict.append(newGO)
                         newEntity.setUserObject(newGO)
                         newGO.setPosition(og.Vector3(0, 0, 0))
@@ -738,7 +761,7 @@
                         newSO = SelectionObject(newEntity, so.distance)
                         newSO.setSelected(True)
                         newSelectionList.append(newSO)
-                        self.dropCount += 1
+                        ModuleManager.dropCount += 1
             else:
                 nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
                 newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
@@ -751,7 +774,7 @@
                 newNode.setOrientation(so.entity.getParentNode().getOrientation())
                 newNode.setScale(so.entity.getParentNode().getScale())
 
-                newSO = SelectionObject(newEntity, so.distance)
+                newSO = SelectionObject(newEntity)
                 newSO.setSelected(True)
                 newSelectionList.append(newSO)
 
@@ -823,8 +846,8 @@
 
         if go is not None:
             meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(self.dropCount))
+            dropEntity = self.sceneManager.createEntity("dropMesh" + str(ModuleManager.dropCount), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
             dropNode.attachObject(dropEntity)
 
             result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -833,10 +856,10 @@
             else:
                 dropNode.setPosition(ray.getPoint(50))
 
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
             dropEntity.setUserObject(self.dropGO)
 
-        self.dropCount += 1
+        ModuleManager.dropCount += 1
 
     def moveDropGameObjectAction(self, ray):
         result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -852,9 +875,9 @@
         if self.currentMap is None:
             return
             
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(ModuleManager.dropCount), str(meshFile))
 
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(self.dropCount))
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
         self.dropNode.attachObject(self.dropEntity)
 
         result = og.Math.intersects(ray, self.dropCollisionPlane)
@@ -863,7 +886,7 @@
         else:
             self.dropNode.setPosition(ray.getPoint(50))
 
-        self.dropCount += 1
+        ModuleManager.dropCount += 1
 
     def moveDropModelAction(self, ray):
         if self.currentMap is None:
@@ -875,7 +898,6 @@
         else:
             self.dropNode.setPosition(ray.getPoint(50))
 
-
     def stopDropModelAction(self, ray):
         pass
 

Modified: rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-02-26 20:56:39 UTC (rev 4779)
+++ rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-02-28 14:41:09 UTC (rev 4780)
@@ -136,6 +136,7 @@
         f.write("end\n\n")
 
         f.write("CoreSubsystem.getSingleton().registerModule(" + mname.capitalize() + "Module.new());\n")
+        f.close()
         
         self.moduleManager.resetParsedModuleConfig()
         self.moduleManager.openLoadModuleDialog()

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-26 20:56:39 UTC (rev 4779)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-02-28 14:41:09 UTC (rev 4780)
@@ -25,14 +25,16 @@
 from Property import *
 
 class ObjectPropertyWin(QDialog):
-    def __init__(self, parent=None):
+    def __init__(self, sceneManager, parent=None):
         super(QDialog, self).__init__(parent)
         self.setupUi()
-
-        self.so = None
-
+        self.sceneManager = sceneManager
+        self.valueBeforeEdit = None
+        
         self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
                                self.onItemClicked)
+        self.connect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"),
+                               self.onItemChanged)
 
     def setupUi(self):
         self.setObjectName("ObjectPropertys")
@@ -55,75 +57,151 @@
 
 
     def onItemClicked(self, item, column):
-        pass
-        
+        if column == 1:
+            self.valueBeforeEdit = item.text(column)
+            self.treeWidget.editItem(item, column)
+
+    def onItemChanged(self, item, column):
+        if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
+            parent = item.parent()
+            if parent is None:
+                if item.text(0) == "Name":
+                    if not self.sceneManager.hasEntity(str(item.text(column))):
+                        newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
+                        oldEnt = self.node.getAttachedObject(0)
+                        self.node.detachObject(oldEnt)
+                        self.sceneManager.destroyEntity(oldEnt)
+                        self.node.attachObject(newEnt)
+                        
+                        # update the selection object since it still has references to the deleted entity
+                        self.so.entity = newEnt
+                        self.so.entityName = newEnt.getName()
+                    else:
+                        item.setText(column, self.valueBeforeEdit)
+                        print "Error: Name already exists!"
+            else:
+                val = None
+                try:
+                    val = float(item.text(1))
+                except ValueError, e:
+                    item.setText(column, self.valueBeforeEdit)
+                    print "ValueError: " + str(e)
+                    return
+                    
+                if parent.text(0) == "Position":
+                    if item.text(0) == "X":
+                        self.node.setPosition(val, self.node.getPosition().y, self.node.getPosition().z)
+                    elif item.text(0) == "Y":
+                        self.node.setPosition(self.node.getPosition().x, val, self.node.getPosition().z)
+                    elif item.text(0) == "Z":
+                        self.node.setPosition(self.node.getPosition().x, self.node.getPosition().y, val)
+                elif parent.text(0) == "Orientation":
+                    if item.text(0) == "W":
+                        self.node.setOrientation(val, self.node.getOrientation().x, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == "X":
+                        self.node.setOrientation(self.node.getOrientation().w, val, self.node.getOrientation().y, self.node.getOrientation().z)
+                    elif item.text(0) == "Y":
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, val, self.node.getOrientation().z)
+                    elif item.text(0) == "Z":
+                        self.node.setOrientation(self.node.getOrientation().w, self.node.getOrientation().x, self.node.getOrientation().y, val)
+                elif parent.text(0) == "Scale":
+                    if item.text(0) == "X":
+                        self.node.setScale(val, self.node.getScale().y, self.node.getScale().z)
+                    elif item.text(0) == "Y":
+                        self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
+                    elif item.text(0) == "Z":
+                        self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
     def showProperties(self, so):
+        # onItemChanged should only be called when the user changes values not when they change by code
+        self.disconnect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"),
+                       self.onItemChanged)
+                       
         self.so=so
         self.treeWidget.clear()
         
         name = so.entity.getParentNode().getName()
-        node = so.entity.getParentNode()
+        self.node = so.entity.getParentNode()
         
         if name.startswith("entity_"):
             item = QTreeWidgetItem(self.treeWidget)
             item.setText(0, "Name")
-            item.setText(1, name.replace("entity_", ""))
+            n = self.node.getAttachedObject(0).getName()
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
             
-            self.parsePosition(node)
-            self.parseOrientation(node)
-            self.parseScale(node)
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
             
+        self.connect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"),
+                       self.onItemChanged)
+                       
+                       
     def parsePosition(self, node):
         item = QTreeWidgetItem(self.treeWidget)
         item.setText(0, "Position")
-        item.setText(1, str(node.getPosition().x) + ", " + str(node.getPosition().y) + ", " + str(node.getPosition().z))
+        item.setText(1, str(node.getPosition().x) + "; " + str(node.getPosition().y) + "; " + str(node.getPosition().z))
         
         itemX = QTreeWidgetItem(item)
         itemX.setText(0, "X")
         itemX.setText(1, str(node.getPosition().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
         
         itemY = QTreeWidgetItem(item)
         itemY.setText(0, "Y")
         itemY.setText(1, str(node.getPosition().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
         
         itemZ = QTreeWidgetItem(item)
         itemZ.setText(0, "Z")
         itemZ.setText(1, str(node.getPosition().z))
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
         
     def parseOrientation(self, node):
         item = QTreeWidgetItem(self.treeWidget)
         item.setText(0, "Orientation")
-        item.setText(1, str(node.getOrientation().x) + ", " + str(node.getOrientation().y) + ", " + str(node.getOrientation().z))
+        item.setText(1, str(node.getOrientation().w) + "; " + str(node.getOrientation().x) + "; " + str(node.getOrientation().y) + "; " + str(node.getOrientation().z))
         
+        itemW = QTreeWidgetItem(item)
+        itemW.setText(0, "W")
+        itemW.setText(1, str(node.getOrientation().w))
+        itemW.setFlags(itemW.flags() | Qt.ItemIsEditable)
+        
         itemX = QTreeWidgetItem(item)
         itemX.setText(0, "X")
         itemX.setText(1, str(node.getOrientation().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
         
         itemY = QTreeWidgetItem(item)
         itemY.setText(0, "Y")
         itemY.setText(1, str(node.getOrientation().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
         
         itemZ = QTreeWidgetItem(item)
         itemZ.setText(0, "Z")
         itemZ.setText(1, str(node.getOrientation().z))
-    
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
     def parseScale(self, node):
         item = QTreeWidgetItem(self.treeWidget)
         item.setText(0, "Scale")
-        item.setText(1, str(node.getScale().x) + ", " + str(node.getScale().y) + ", " + str(node.getScale().z))
+        item.setText(1, str(node.getScale().x) + "; " + str(node.getScale().y) + "; " + str(node.getScale().z))
         
         itemX = QTreeWidgetItem(item)
         itemX.setText(0, "X")
         itemX.setText(1, str(node.getScale().x))
+        itemX.setFlags(itemX.flags() | Qt.ItemIsEditable)
         
         itemY = QTreeWidgetItem(item)
         itemY.setText(0, "Y")
         itemY.setText(1, str(node.getScale().y))
+        itemY.setFlags(itemY.flags() | Qt.ItemIsEditable)
         
         itemZ = QTreeWidgetItem(item)
         itemZ.setText(0, "Z")
         itemZ.setText(1, str(node.getScale().z))
-            
+        itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
+        
     def updateProperties(self):
         if self.so is not None:
             self.showProperties(self.so)

Added: rl/trunk/editors/Lockenwickler/src/media/icons/fileopen.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/fileopen.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



