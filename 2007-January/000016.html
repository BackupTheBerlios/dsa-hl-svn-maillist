<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r2945 - in dependencies/OgreNewt/include: . OgreNewt
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r2945%20-%20in%20dependencies/OgreNewt/include%3A%20.%20OgreNewt&In-Reply-To=%3C200701081246.l08CkZTS000470%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000015.html">
   <LINK REL="Next"  HREF="000017.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r2945 - in dependencies/OgreNewt/include: . OgreNewt</H1>
    <B>chrber at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r2945%20-%20in%20dependencies/OgreNewt/include%3A%20.%20OgreNewt&In-Reply-To=%3C200701081246.l08CkZTS000470%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r2945 - in dependencies/OgreNewt/include: . OgreNewt">chrber at mail.berlios.de
       </A><BR>
    <I>Mon Jan  8 13:46:35 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000015.html">[Dsa-hl-svn] r2944 - in dependencies/OgreNewt: . include src
</A></li>
        <LI>Next message: <A HREF="000017.html">[Dsa-hl-svn] r2946 - rl/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16">[ date ]</a>
              <a href="thread.html#16">[ thread ]</a>
              <a href="subject.html#16">[ subject ]</a>
              <a href="author.html#16">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chrber
Date: 2007-01-08 13:46:19 +0100 (Mon, 08 Jan 2007)
New Revision: 2945

Added:
   dependencies/OgreNewt/include/OgreNewt/FastDelegate.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_BasicJoints.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Body.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_BodyIterator.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Collision.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_ContactCallback.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Joint.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialID.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialPair.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_RayCast.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Tools.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_TreeCollisionSerializer.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Vehicle.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_World.h
   dependencies/OgreNewt/include/OgreNewt/line3D.h
Removed:
   dependencies/OgreNewt/include/FastDelegate.h
   dependencies/OgreNewt/include/OgreNewt.h
   dependencies/OgreNewt/include/OgreNewt_BasicJoints.h
   dependencies/OgreNewt/include/OgreNewt_Body.h
   dependencies/OgreNewt/include/OgreNewt_BodyIterator.h
   dependencies/OgreNewt/include/OgreNewt_Collision.h
   dependencies/OgreNewt/include/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt/include/OgreNewt_ContactCallback.h
   dependencies/OgreNewt/include/OgreNewt_Debugger.h
   dependencies/OgreNewt/include/OgreNewt_Joint.h
   dependencies/OgreNewt/include/OgreNewt_MaterialID.h
   dependencies/OgreNewt/include/OgreNewt_MaterialPair.h
   dependencies/OgreNewt/include/OgreNewt_Prerequisites.h
   dependencies/OgreNewt/include/OgreNewt_RayCast.h
   dependencies/OgreNewt/include/OgreNewt_Tools.h
   dependencies/OgreNewt/include/OgreNewt_TreeCollisionSerializer.h
   dependencies/OgreNewt/include/OgreNewt_Vehicle.h
   dependencies/OgreNewt/include/OgreNewt_World.h
   dependencies/OgreNewt/include/line3D.h
Log:
Moved headers to appropriate directory


Deleted: dependencies/OgreNewt/include/FastDelegate.h
===================================================================
--- dependencies/OgreNewt/include/FastDelegate.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/FastDelegate.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,2108 +0,0 @@
-//						FastDelegate.h 
-//	Efficient delegates in C++ that generate only two lines of asm code!
-//  Documentation is found at <A HREF="http://www.codeproject.com/cpp/FastDelegate.asp">http://www.codeproject.com/cpp/FastDelegate.asp</A>
-//
-//						- Don Clugston, Mar 2004.
-//		Major contributions were made by Jody Hagins.
-// History:
-// 24-Apr-04 1.0  * Submitted to CodeProject. 
-// 28-Apr-04 1.1  * Prevent most unsafe uses of evil static function hack.
-//				  * Improved syntax for horrible_cast (thanks Paul Bludov).
-//				  * Tested on Metrowerks MWCC and Intel ICL (IA32)
-//				  * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.
-//	27-Jun-04 1.2 * Now works on Borland C++ Builder 5.5
-//				  * Now works on /clr &quot;managed C++&quot; code on VC7, VC7.1
-//				  * Comeau C++ now compiles without warnings.
-//				  * Prevent the virtual inheritance case from being used on 
-//					  VC6 and earlier, which generate incorrect code.
-//				  * Improved warning and error messages. Non-standard hacks
-//					 now have compile-time checks to make them safer.
-//				  * implicit_cast used instead of static_cast in many cases.
-//				  * If calling a const member function, a const class pointer can be used.
-//				  * MakeDelegate() global helper function added to simplify pass-by-value.
-//				  * Added fastdelegate.clear()
-// 16-Jul-04 1.2.1* Workaround for gcc bug (const member function pointers in templates)
-// 30-Oct-04 1.3  * Support for (non-void) return values.
-//				  * No more workarounds in client code!
-//					 MSVC and Intel now use a clever hack invented by John Dlugosz:
-//				     - The FASTDELEGATEDECLARE workaround is no longer necessary.
-//					 - No more warning messages for VC6
-//				  * Less use of macros. Error messages should be more comprehensible.
-//				  * Added include guards
-//				  * Added FastDelegate::empty() to test if invocation is safe (Thanks Neville Franks).
-//				  * Now tested on VS 2005 Express Beta, PGI C++
-// 24-Dec-04 1.4  * Added DelegateMemento, to allow collections of disparate delegates.
-//                * &lt;,&gt;,&lt;=,&gt;= comparison operators to allow storage in ordered containers.
-//				  * Substantial reduction of code size, especially the 'Closure' class.
-//				  * Standardised all the compiler-specific workarounds.
-//                * MFP conversion now works for CodePlay (but not yet supported in the full code).
-//                * Now compiles without warnings on _any_ supported compiler, including BCC 5.5.1
-//				  * New syntax: FastDelegate&lt; int (char *, double) &gt;. 
-// 14-Feb-05 1.4.1* Now treats =0 as equivalent to .clear(), ==0 as equivalent to .empty(). (Thanks elfric).
-//				  * Now tested on Intel ICL for AMD64, VS2005 Beta for AMD64 and Itanium.
-// 30-Mar-05 1.5  * Safebool idiom: &quot;if (dg)&quot; is now equivalent to &quot;if (!dg.empty())&quot;
-//				  * Fully supported by CodePlay VectorC
-//                * Bugfix for Metrowerks: empty() was buggy because a valid MFP can be 0 on MWCC!
-//                * More optimal assignment,== and != operators for static function pointers.
-
-#ifndef FASTDELEGATE_H
-#define FASTDELEGATE_H
-#if _MSC_VER &gt; 1000
-#pragma once
-#endif // _MSC_VER &gt; 1000
-
-#include &lt;memory.h&gt; // to allow &lt;,&gt; comparisons
-
-////////////////////////////////////////////////////////////////////////////////
-//						Configuration options
-//
-////////////////////////////////////////////////////////////////////////////////
-
-// Uncomment the following #define for optimally-sized delegates.
-// In this case, the generated asm code is almost identical to the code you'd get
-// if the compiler had native support for delegates.
-// It will not work on systems where sizeof(dataptr) &lt; sizeof(codeptr). 
-// Thus, it will not work for DOS compilers using the medium model.
-// It will also probably fail on some DSP systems.
-#define FASTDELEGATE_USESTATICFUNCTIONHACK
-
-// Uncomment the next line to allow function declarator syntax.
-// It is automatically enabled for those compilers where it is known to work.
-//#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
-
-////////////////////////////////////////////////////////////////////////////////
-//						Compiler identification for workarounds
-//
-////////////////////////////////////////////////////////////////////////////////
-
-// Compiler identification. It's not easy to identify Visual C++ because
-// many vendors fraudulently define Microsoft's identifiers.
-#if defined(_MSC_VER) &amp;&amp; !defined(__MWERKS__) &amp;&amp; !defined(__VECTOR_C) &amp;&amp; !defined(__ICL) &amp;&amp; !defined(__BORLANDC__)
-#define FASTDLGT_ISMSVC
-
-#if (_MSC_VER &lt;1300) // Many workarounds are required for VC6.
-#define FASTDLGT_VC6
-#pragma warning(disable:4786) // disable this ridiculous warning
-#endif
-
-#endif
-
-// Does the compiler uses Microsoft's member function pointer structure?
-// If so, it needs special treatment.
-// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's 
-// identifier, _MSC_VER. We need to filter Metrowerks out.
-#if defined(_MSC_VER) &amp;&amp; !defined(__MWERKS__)
-#define FASTDLGT_MICROSOFT_MFP
-
-#if !defined(__VECTOR_C)
-// CodePlay doesn't have the __single/multi/virtual_inheritance keywords
-#define FASTDLGT_HASINHERITANCE_KEYWORDS
-#endif
-#endif
-
-// Does it allow function declarator syntax? The following compilers are known to work:
-#if defined(FASTDLGT_ISMSVC) &amp;&amp; (_MSC_VER &gt;=1310) // VC 7.1
-#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
-#endif
-
-// Gcc(2.95+), and versions of Digital Mars, Intel and Comeau in common use.
-#if defined (__DMC__) || defined(__GNUC__) || defined(__ICL) || defined(__COMO__)
-#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
-#endif
-
-// It works on Metrowerks MWCC 3.2.2. From boost.Config it should work on earlier ones too.
-#if defined (__MWERKS__)
-#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
-#endif
-
-#ifdef __GNUC__ // Workaround GCC bug #8271 
-	// At present, GCC doesn't recognize constness of MFPs in templates
-#define FASTDELEGATE_GCC_BUG_8271
-#endif
-
-
-
-////////////////////////////////////////////////////////////////////////////////
-//						General tricks used in this code
-//
-// (a) Error messages are generated by typdefing an array of negative size to
-//     generate compile-time errors.
-// (b) Warning messages on MSVC are generated by declaring unused variables, and
-//	    enabling the &quot;variable XXX is never used&quot; warning.
-// (c) Unions are used in a few compiler-specific cases to perform illegal casts.
-// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to
-//     (char *) first to ensure that the correct number of *bytes* are added.
-//
-////////////////////////////////////////////////////////////////////////////////
-//						Helper templates
-//
-////////////////////////////////////////////////////////////////////////////////
-
-
-namespace fastdelegate {
-namespace detail {	// we'll hide the implementation details in a nested namespace.
-
-//		implicit_cast&lt; &gt;
-// I believe this was originally going to be in the C++ standard but 
-// was left out by accident. It's even milder than static_cast.
-// I use it instead of static_cast&lt;&gt; to emphasize that I'm not doing
-// anything nasty. 
-// Usage is identical to static_cast&lt;&gt;
-template &lt;class OutputClass, class InputClass&gt;
-inline OutputClass implicit_cast(InputClass input){
-	return input;
-}
-
-//		horrible_cast&lt; &gt;
-// This is truly evil. It completely subverts C++'s type system, allowing you 
-// to cast from any class to any other class. Technically, using a union 
-// to perform the cast is undefined behaviour (even in C). But we can see if
-// it is OK by checking that the union is the same size as each of its members.
-// horrible_cast&lt;&gt; should only be used for compiler-specific workarounds. 
-// Usage is identical to reinterpret_cast&lt;&gt;.
-
-// This union is declared outside the horrible_cast because BCC 5.5.1
-// can't inline a function with a nested class, and gives a warning.
-template &lt;class OutputClass, class InputClass&gt;
-union horrible_union{
-	OutputClass out;
-	InputClass in;
-};
-
-template &lt;class OutputClass, class InputClass&gt;
-inline OutputClass horrible_cast(const InputClass input){
-	horrible_union&lt;OutputClass, InputClass&gt; u;
-	// Cause a compile-time error if in, out and u are not the same size.
-	// If the compile fails here, it means the compiler has peculiar
-	// unions which would prevent the cast from working.
-	typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass)==sizeof(u) 
-		&amp;&amp; sizeof(InputClass)==sizeof(OutputClass) ? 1 : -1];
-	u.in = input;
-	return u.out;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-//						Workarounds
-//
-////////////////////////////////////////////////////////////////////////////////
-
-// Backwards compatibility: This macro used to be necessary in the virtual inheritance
-// case for Intel and Microsoft. Now it just forward-declares the class.
-#define FASTDELEGATEDECLARE(CLASSNAME)	class CLASSNAME;
-
-// Prevent use of the static function hack with the DOS medium model.
-#ifdef __MEDIUM__
-#undef FASTDELEGATE_USESTATICFUNCTIONHACK
-#endif
-
-//			DefaultVoid - a workaround for 'void' templates in VC6.
-//
-//  (1) VC6 and earlier do not allow 'void' as a default template argument.
-//  (2) They also doesn't allow you to return 'void' from a function.
-//
-// Workaround for (1): Declare a dummy type 'DefaultVoid' which we use
-//   when we'd like to use 'void'. We convert it into 'void' and back
-//   using the templates DefaultVoidToVoid&lt;&gt; and VoidToDefaultVoid&lt;&gt;.
-// Workaround for (2): On VC6, the code for calling a void function is
-//   identical to the code for calling a non-void function in which the
-//   return value is never used, provided the return value is returned
-//   in the EAX register, rather than on the stack. 
-//   This is true for most fundamental types such as int, enum, void *.
-//   Const void * is the safest option since it doesn't participate 
-//   in any automatic conversions. But on a 16-bit compiler it might
-//   cause extra code to be generated, so we disable it for all compilers
-//   except for VC6 (and VC5).
-#ifdef FASTDLGT_VC6
-// VC6 workaround
-typedef const void * DefaultVoid;
-#else
-// On any other compiler, just use a normal void.
-typedef void DefaultVoid;
-#endif
-
-// Translate from 'DefaultVoid' to 'void'.
-// Everything else is unchanged
-template &lt;class T&gt;
-struct DefaultVoidToVoid { typedef T type; };
-
-template &lt;&gt;
-struct DefaultVoidToVoid&lt;DefaultVoid&gt; {	typedef void type; };
-
-// Translate from 'void' into 'DefaultVoid'
-// Everything else is unchanged
-template &lt;class T&gt;
-struct VoidToDefaultVoid { typedef T type; };
-
-template &lt;&gt;
-struct VoidToDefaultVoid&lt;void&gt; { typedef DefaultVoid type; };
-
-
-
-////////////////////////////////////////////////////////////////////////////////
-//						Fast Delegates, part 1:
-//
-//		Conversion of member function pointer to a standard form
-//
-////////////////////////////////////////////////////////////////////////////////
-
-// GenericClass is a fake class, ONLY used to provide a type.
-// It is vitally important that it is never defined, so that the compiler doesn't
-// think it can optimize the invocation. For example, Borland generates simpler
-// code if it knows the class only uses single inheritance.
-
-// Compilers using Microsoft's structure need to be treated as a special case.
-#ifdef  FASTDLGT_MICROSOFT_MFP
-
-#ifdef FASTDLGT_HASINHERITANCE_KEYWORDS
-	// For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP 
-	// (4 bytes), even when the /vmg option is used. Declaring an empty class 
-	// would give 16 byte pointers in this case....
-	class __single_inheritance GenericClass;
-#endif
-	// ...but for Codeplay, an empty class *always* gives 4 byte pointers.
-	// If compiled with the /clr option (&quot;managed C++&quot;), the JIT compiler thinks
-	// it needs to load GenericClass before it can call any of its functions,
-	// (compiles OK but crashes at runtime!), so we need to declare an 
-	// empty class to make it happy.
-	// Codeplay and VC4 can't cope with the unknown_inheritance case either.
-	class GenericClass {};
-#else
-	class GenericClass;
-#endif
-
-// The size of a single inheritance member function pointer.
-const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());
-
-//						SimplifyMemFunc&lt; &gt;::Convert()
-//
-//	A template function that converts an arbitrary member function pointer into the 
-//	simplest possible form of member function pointer, using a supplied 'this' pointer.
-//  According to the standard, this can be done legally with reinterpret_cast&lt;&gt;.
-//	For (non-standard) compilers which use member function pointers which vary in size 
-//  depending on the class, we need to use	knowledge of the internal structure of a 
-//  member function pointer, as used by the compiler. Template specialization is used
-//  to distinguish between the sizes. Because some compilers don't support partial 
-//	template specialisation, I use full specialisation of a wrapper struct.
-
-// general case -- don't know how to convert it. Force a compile failure
-template &lt;int N&gt;
-struct SimplifyMemFunc {
-	template &lt;class X, class XFuncType, class GenericMemFuncType&gt;
-	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
-		GenericMemFuncType &amp;bound_func) { 
-		// Unsupported member function type -- force a compile failure.
-	    // (it's illegal to have a array with negative size).
-		typedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N-100];
-		return 0; 
-	}
-};
-
-// For compilers where all member func ptrs are the same size, everything goes here.
-// For non-standard compilers, only single_inheritance classes go here.
-template &lt;&gt;
-struct SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE&gt;  {	
-	template &lt;class X, class XFuncType, class GenericMemFuncType&gt;
-	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
-			GenericMemFuncType &amp;bound_func) {
-#if defined __DMC__  
-		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
-		// even though the standard says you can. The 32-bit compiler lets you
-		// static_cast through an int, but the DOS compiler doesn't.
-		bound_func = horrible_cast&lt;GenericMemFuncType&gt;(function_to_bind);
-#else 
-        bound_func = reinterpret_cast&lt;GenericMemFuncType&gt;(function_to_bind);
-#endif
-        return reinterpret_cast&lt;GenericClass *&gt;(pthis);
-	}
-};
-
-////////////////////////////////////////////////////////////////////////////////
-//						Fast Delegates, part 1b:
-//
-//					Workarounds for Microsoft and Intel
-//
-////////////////////////////////////////////////////////////////////////////////
-
-
-// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),
-// need to be treated as a special case.
-#ifdef FASTDLGT_MICROSOFT_MFP
-
-// We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)
-// at the start of each function for extra safety, but VC6 seems to ICE
-// intermittently if you do this inside a template.
-
-// __multiple_inheritance classes go here
-// Nasty hack for Microsoft and Intel (IA32 and Itanium)
-template&lt;&gt;
-struct SimplifyMemFunc&lt; SINGLE_MEMFUNCPTR_SIZE + sizeof(int) &gt;  {
-	template &lt;class X, class XFuncType, class GenericMemFuncType&gt;
-	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
-		GenericMemFuncType &amp;bound_func) { 
-		// We need to use a horrible_cast to do this conversion.
-		// In MSVC, a multiple inheritance member pointer is internally defined as:
-        union {
-			XFuncType func;
-			struct {	 
-				GenericMemFuncType funcaddress; // points to the actual member function
-				int delta;	     // #BYTES to be added to the 'this' pointer
-			}s;
-        } u;
-		// Check that the horrible_cast will work
-		typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)? 1 : -1];
-        u.func = function_to_bind;
-		bound_func = u.s.funcaddress;
-		return reinterpret_cast&lt;GenericClass *&gt;(reinterpret_cast&lt;char *&gt;(pthis) + u.s.delta); 
-	}
-};
-
-// virtual inheritance is a real nuisance. It's inefficient and complicated.
-// On MSVC and Intel, there isn't enough information in the pointer itself to
-// enable conversion to a closure pointer. Earlier versions of this code didn't
-// work for all cases, and generated a compile-time error instead.
-// But a very clever hack invented by John M. Dlugosz solves this problem.
-// My code is somewhat different to his: I have no asm code, and I make no 
-// assumptions about the calling convention that is used.
-
-// In VC++ and ICL, a virtual_inheritance member pointer 
-// is internally defined as:
-struct MicrosoftVirtualMFP {
-	void (GenericClass::*codeptr)(); // points to the actual member function
-	int delta;		// #bytes to be added to the 'this' pointer
-	int vtable_index; // or 0 if no virtual inheritance
-};
-// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the
-// m_codeptr member is *always* called, regardless of the values of the other
-// members. (This is *not* true for other compilers, eg GCC, which obtain the
-// function address from the vtable if a virtual function is being called).
-// Dlugosz's trick is to make the codeptr point to a probe function which
-// returns the 'this' pointer that was used.
-
-// Define a generic class that uses virtual inheritance.
-// It has a trival member function that returns the value of the 'this' pointer.
-struct GenericVirtualClass : virtual public GenericClass
-{
-	typedef GenericVirtualClass * (GenericVirtualClass::*ProbePtrType)();
-	GenericVirtualClass * GetThis() { return this; }
-};
-
-// __virtual_inheritance classes go here
-template &lt;&gt;
-struct SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE + 2*sizeof(int) &gt;
-{
-
-	template &lt;class X, class XFuncType, class GenericMemFuncType&gt;
-	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
-		GenericMemFuncType &amp;bound_func) {
-		union {
-			XFuncType func;
-			GenericClass* (X::*ProbeFunc)();
-			MicrosoftVirtualMFP s;
-		} u;
-		u.func = function_to_bind;
-		bound_func = reinterpret_cast&lt;GenericMemFuncType&gt;(u.s.codeptr);
-		union {
-			GenericVirtualClass::ProbePtrType virtfunc;
-			MicrosoftVirtualMFP s;
-		} u2;
-		// Check that the horrible_cast&lt;&gt;s will work
-		typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)
-			&amp;&amp; sizeof(function_to_bind)==sizeof(u.ProbeFunc)
-			&amp;&amp; sizeof(u2.virtfunc)==sizeof(u2.s) ? 1 : -1];
-   // Unfortunately, taking the address of a MF prevents it from being inlined, so 
-   // this next line can't be completely optimised away by the compiler.
-		u2.virtfunc = &amp;GenericVirtualClass::GetThis;
-		u.s.codeptr = u2.s.codeptr;
-		return (pthis-&gt;*u.ProbeFunc)();
-	}
-};
-
-#if (_MSC_VER &lt;1300)
-
-// Nasty hack for Microsoft Visual C++ 6.0
-// unknown_inheritance classes go here
-// There is a compiler bug in MSVC6 which generates incorrect code in this case!!
-template &lt;&gt;
-struct SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) &gt;
-{
-	template &lt;class X, class XFuncType, class GenericMemFuncType&gt;
-	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
-		GenericMemFuncType &amp;bound_func) {
-		// There is an apalling but obscure compiler bug in MSVC6 and earlier:
-		// vtable_index and 'vtordisp' are always set to 0 in the 
-		// unknown_inheritance case!
-		// This means that an incorrect function could be called!!!
-		// Compiling with the /vmg option leads to potentially incorrect code.
-		// This is probably the reason that the IDE has a user interface for specifying
-		// the /vmg option, but it is disabled -  you can only specify /vmg on 
-		// the command line. In VC1.5 and earlier, the compiler would ICE if it ever
-		// encountered this situation.
-		// It is OK to use the /vmg option if /vmm or /vms is specified.
-
-		// Fortunately, the wrong function is only called in very obscure cases.
-		// It only occurs when a derived class overrides a virtual function declared 
-		// in a virtual base class, and the member function 
-		// points to the *Derived* version of that function. The problem can be
-		// completely averted in 100% of cases by using the *Base class* for the 
-		// member fpointer. Ie, if you use the base class as an interface, you'll
-		// stay out of trouble.
-		// Occasionally, you might want to point directly to a derived class function
-		// that isn't an override of a base class. In this case, both vtable_index 
-		// and 'vtordisp' are zero, but a virtual_inheritance pointer will be generated.
-		// We can generate correct code in this case. To prevent an incorrect call from
-		// ever being made, on MSVC6 we generate a warning, and call a function to 
-		// make the program crash instantly. 
-		typedef char ERROR_VC6CompilerBug[-100];
-		return 0; 
-	}
-};
-
-
-#else 
-
-// Nasty hack for Microsoft and Intel (IA32 and Itanium)
-// unknown_inheritance classes go here 
-// This is probably the ugliest bit of code I've ever written. Look at the casts!
-// There is a compiler bug in MSVC6 which prevents it from using this code.
-template &lt;&gt;
-struct SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) &gt;
-{
-	template &lt;class X, class XFuncType, class GenericMemFuncType&gt;
-	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
-			GenericMemFuncType &amp;bound_func) {
-		// The member function pointer is 16 bytes long. We can't use a normal cast, but
-		// we can use a union to do the conversion.
-		union {
-			XFuncType func;
-			// In VC++ and ICL, an unknown_inheritance member pointer 
-			// is internally defined as:
-			struct {
-				GenericMemFuncType m_funcaddress; // points to the actual member function
-				int delta;		// #bytes to be added to the 'this' pointer
-				int vtordisp;		// #bytes to add to 'this' to find the vtable
-				int vtable_index; // or 0 if no virtual inheritance
-			} s;
-		} u;
-		// Check that the horrible_cast will work
-		typedef int ERROR_CantUsehorrible_cast[sizeof(XFuncType)==sizeof(u.s)? 1 : -1];
-		u.func = function_to_bind;
-		bound_func = u.s.funcaddress;
-		int virtual_delta = 0;
-		if (u.s.vtable_index) { // Virtual inheritance is used
-			// First, get to the vtable. 
-			// It is 'vtordisp' bytes from the start of the class.
-			const int * vtable = *reinterpret_cast&lt;const int *const*&gt;(
-				reinterpret_cast&lt;const char *&gt;(pthis) + u.s.vtordisp );
-
-			// 'vtable_index' tells us where in the table we should be looking.
-			virtual_delta = u.s.vtordisp + *reinterpret_cast&lt;const int *&gt;( 
-				reinterpret_cast&lt;const char *&gt;(vtable) + u.s.vtable_index);
-		}
-		// The int at 'virtual_delta' gives us the amount to add to 'this'.
-        // Finally we can add the three components together. Phew!
-        return reinterpret_cast&lt;GenericClass *&gt;(
-			reinterpret_cast&lt;char *&gt;(pthis) + u.s.delta + virtual_delta);
-	};
-};
-#endif // MSVC 7 and greater
-
-#endif // MS/Intel hacks
-
-}  // namespace detail
-
-////////////////////////////////////////////////////////////////////////////////
-//						Fast Delegates, part 2:
-//
-//	Define the delegate storage, and cope with static functions
-//
-////////////////////////////////////////////////////////////////////////////////
-
-// DelegateMemento -- an opaque structure which can hold an arbitary delegate.
-// It knows nothing about the calling convention or number of arguments used by
-// the function pointed to.
-// It supplies comparison operators so that it can be stored in STL collections.
-// It cannot be set to anything other than null, nor invoked directly: 
-//   it must be converted to a specific delegate.
-
-// Implementation:
-// There are two possible implementations: the Safe method and the Evil method.
-//				DelegateMemento - Safe version
-//
-// This implementation is standard-compliant, but a bit tricky.
-// A static function pointer is stored inside the class. 
-// Here are the valid values:
-// +-- Static pointer --+--pThis --+-- pMemFunc-+-- Meaning------+
-// |   0				|  0       |   0        | Empty          |
-// |   !=0              |(dontcare)|  Invoker   | Static function|
-// |   0                |  !=0     |  !=0*      | Method call    |
-// +--------------------+----------+------------+----------------+
-//  * For Metrowerks, this can be 0. (first virtual function in a 
-//       single_inheritance class).
-// When stored stored inside a specific delegate, the 'dontcare' entries are replaced
-// with a reference to the delegate itself. This complicates the = and == operators
-// for the delegate class.
-
-//				DelegateMemento - Evil version
-//
-// For compilers where data pointers are at least as big as code pointers, it is 
-// possible to store the function pointer in the this pointer, using another 
-// horrible_cast. In this case the DelegateMemento implementation is simple:
-// +--pThis --+-- pMemFunc-+-- Meaning---------------------+
-// |    0     |  0         | Empty                         |
-// |  !=0     |  !=0*      | Static function or method call|
-// +----------+------------+-------------------------------+
-//  * For Metrowerks, this can be 0. (first virtual function in a 
-//       single_inheritance class).
-// Note that the Sun C++ and MSVC documentation explicitly state that they 
-// support static_cast between void * and function pointers.
-
-class DelegateMemento {
-protected: 
-	// the data is protected, not private, because many
-	// compilers have problems with template friends.
-	typedef void (detail::GenericClass::*GenericMemFuncType)(); // arbitrary MFP.
-	detail::GenericClass *m_pthis;
-	GenericMemFuncType m_pFunction;
-
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-	typedef void (*GenericFuncPtr)(); // arbitrary code pointer
-	GenericFuncPtr m_pStaticFunction;
-#endif
-
-public:
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-	DelegateMemento() : m_pthis(0), m_pFunction(0), m_pStaticFunction(0) {};
-	void clear() {
-		m_pthis=0; m_pFunction=0; m_pStaticFunction=0;
-	}
-#else
-	DelegateMemento() : m_pthis(0), m_pFunction(0) {};
-	void clear() {	m_pthis=0; m_pFunction=0;	}
-#endif
-public:
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-	inline bool IsEqual (const DelegateMemento &amp;x) const{
-	    // We have to cope with the static function pointers as a special case
-		if (m_pFunction!=x.m_pFunction) return false;
-		// the static function ptrs must either both be equal, or both be 0.
-		if (m_pStaticFunction!=x.m_pStaticFunction) return false;
-		if (m_pStaticFunction!=0) return m_pthis==x.m_pthis;
-		else return true;
-	}
-#else // Evil Method
-	inline bool IsEqual (const DelegateMemento &amp;x) const{
-		return m_pthis==x.m_pthis &amp;&amp; m_pFunction==x.m_pFunction;
-	}
-#endif
-	// Provide a strict weak ordering for DelegateMementos.
-	inline bool IsLess(const DelegateMemento &amp;right) const {
-		// deal with static function pointers first
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-		if (m_pStaticFunction !=0 || right.m_pStaticFunction!=0) 
-				return m_pStaticFunction &lt; right.m_pStaticFunction;
-#endif
-		if (m_pthis !=right.m_pthis) return m_pthis &lt; right.m_pthis;
-	// There are no ordering operators for member function pointers, 
-	// but we can fake one by comparing each byte. The resulting ordering is
-	// arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.
-		return memcmp(&amp;m_pFunction, &amp;right.m_pFunction, sizeof(m_pFunction)) &lt; 0;
-
-	}
-	// BUGFIX (Mar 2005):
-	// We can't just compare m_pFunction because on Metrowerks,
-	// m_pFunction can be zero even if the delegate is not empty!
-	inline bool operator ! () const		// Is it bound to anything?
-	{ return m_pthis==0 &amp;&amp; m_pFunction==0; }
-	inline bool empty() const		// Is it bound to anything?
-	{ return m_pthis==0 &amp;&amp; m_pFunction==0; }
-public:
-	DelegateMemento &amp; operator = (const DelegateMemento &amp;right)  {
-		SetMementoFrom(right); 
-		return *this;
-	}
-	inline bool operator &lt;(const DelegateMemento &amp;right) {
-		return IsLess(right);
-	}
-	inline bool operator &gt;(const DelegateMemento &amp;right) {
-		return right.IsLess(*this);
-	}
-	DelegateMemento (const DelegateMemento &amp;right)  : 
-		m_pFunction(right.m_pFunction), m_pthis(right.m_pthis)
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-		, m_pStaticFunction (right.m_pStaticFunction)
-#endif
-		{}
-protected:
-	void SetMementoFrom(const DelegateMemento &amp;right)  {
-		m_pFunction = right.m_pFunction;
-		m_pthis = right.m_pthis;
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-		m_pStaticFunction = right.m_pStaticFunction;
-#endif
-	}
-};
-
-
-//						ClosurePtr&lt;&gt;
-//
-// A private wrapper class that adds function signatures to DelegateMemento.
-// It's the class that does most of the actual work.
-// The signatures are specified by:
-// GenericMemFunc: must be a type of GenericClass member function pointer. 
-// StaticFuncPtr:  must be a type of function pointer with the same signature 
-//                 as GenericMemFunc.
-// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6
-//                 where it never returns void (returns DefaultVoid instead).
-
-// An outer class, FastDelegateN&lt;&gt;, handles the invoking and creates the
-// necessary typedefs.
-// This class does everything else.
-
-namespace detail {
-
-template &lt; class GenericMemFunc, class StaticFuncPtr, class UnvoidStaticFuncPtr&gt;
-class ClosurePtr : public DelegateMemento {
-public:
-	// These functions are for setting the delegate to a member function.
-
-	// Here's the clever bit: we convert an arbitrary member function into a 
-	// standard form. XMemFunc should be a member function of class X, but I can't 
-	// enforce that here. It needs to be enforced by the wrapper class.
-	template &lt; class X, class XMemFunc &gt;
-	inline void bindmemfunc(X *pthis, XMemFunc function_to_bind ) {
-		m_pthis = SimplifyMemFunc&lt; sizeof(function_to_bind) &gt;
-			::Convert(pthis, function_to_bind, m_pFunction);
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-		m_pStaticFunction = 0;
-#endif
-	}
-	// For const member functions, we only need a const class pointer.
-	// Since we know that the member function is const, it's safe to 
-	// remove the const qualifier from the 'this' pointer with a const_cast.
-	// VC6 has problems if we just overload 'bindmemfunc', so we give it a different name.
-	template &lt; class X, class XMemFunc&gt;
-	inline void bindconstmemfunc(const X *pthis, XMemFunc function_to_bind) {
-		m_pthis= SimplifyMemFunc&lt; sizeof(function_to_bind) &gt;
-			::Convert(const_cast&lt;X*&gt;(pthis), function_to_bind, m_pFunction);
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-		m_pStaticFunction = 0;
-#endif
-	}
-#ifdef FASTDELEGATE_GCC_BUG_8271	// At present, GCC doesn't recognize constness of MFPs in templates
-	template &lt; class X, class XMemFunc&gt;
-	inline void bindmemfunc(const X *pthis, XMemFunc function_to_bind) {
-		bindconstmemfunc(pthis, function_to_bind);
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-		m_pStaticFunction = 0;
-#endif
-	}
-#endif
-	// These functions are required for invoking the stored function
-	inline GenericClass *GetClosureThis() const { return m_pthis; }
-	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast&lt;GenericMemFunc&gt;(m_pFunction); }
-
-// There are a few ways of dealing with static function pointers.
-// There's a standard-compliant, but tricky method.
-// There's also a straightforward hack, that won't work on DOS compilers using the
-// medium memory model. It's so evil that I can't recommend it, but I've
-// implemented it anyway because it produces very nice asm code.
-
-#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-
-//				ClosurePtr&lt;&gt; - Safe version
-//
-// This implementation is standard-compliant, but a bit tricky.
-// I store the function pointer inside the class, and the delegate then
-// points to itself. Whenever the delegate is copied, these self-references
-// must be transformed, and this complicates the = and == operators.
-public:
-	// The next two functions are for operator ==, =, and the copy constructor.
-	// We may need to convert the m_pthis pointers, so that
-	// they remain as self-references.
-	template&lt; class DerivedClass &gt;
-	inline void CopyFrom (DerivedClass *pParent, const DelegateMemento &amp;x) {
-		SetMementoFrom(x);
-		if (m_pStaticFunction!=0) {
-			// transform self references...
-			m_pthis=reinterpret_cast&lt;GenericClass *&gt;(pParent);
-		}
-	}
-	// For static functions, the 'static_function_invoker' class in the parent 
-	// will be called. The parent then needs to call GetStaticFunction() to find out 
-	// the actual function to invoke.
-	template &lt; class DerivedClass, class ParentInvokerSig &gt;
-	inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker, 
-				StaticFuncPtr function_to_bind ) {
-		if (function_to_bind==0) { // cope with assignment to 0
-			m_pFunction=0;
-		} else { 
-			bindmemfunc(pParent, static_function_invoker);
-        }
-		m_pStaticFunction=reinterpret_cast&lt;GenericFuncPtr&gt;(function_to_bind);
-	}
-	inline UnvoidStaticFuncPtr GetStaticFunction() const { 
-		return reinterpret_cast&lt;UnvoidStaticFuncPtr&gt;(m_pStaticFunction); 
-	}
-#else
-
-//				ClosurePtr&lt;&gt; - Evil version
-//
-// For compilers where data pointers are at least as big as code pointers, it is 
-// possible to store the function pointer in the this pointer, using another 
-// horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and
-// speeds up comparison and assignment. If C++ provided direct language support
-// for delegates, they would produce asm code that was almost identical to this.
-// Note that the Sun C++ and MSVC documentation explicitly state that they 
-// support static_cast between void * and function pointers.
-
-	template&lt; class DerivedClass &gt;
-	inline void CopyFrom (DerivedClass *pParent, const DelegateMemento &amp;right) {
-		SetMementoFrom(right);
-	}
-	// For static functions, the 'static_function_invoker' class in the parent 
-	// will be called. The parent then needs to call GetStaticFunction() to find out 
-	// the actual function to invoke.
-	// ******** EVIL, EVIL CODE! *******
-	template &lt; 	class DerivedClass, class ParentInvokerSig&gt;
-	inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker, 
-				StaticFuncPtr function_to_bind) {
-		if (function_to_bind==0) { // cope with assignment to 0
-			m_pFunction=0;
-		} else { 
-		   // We'll be ignoring the 'this' pointer, but we need to make sure we pass
-		   // a valid value to bindmemfunc().
-			bindmemfunc(pParent, static_function_invoker);
-        }
-
-		// WARNING! Evil hack. We store the function in the 'this' pointer!
-		// Ensure that there's a compilation failure if function pointers 
-		// and data pointers have different sizes.
-		// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
-		typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *)==sizeof(function_to_bind) ? 1 : -1];
-		m_pthis = horrible_cast&lt;GenericClass *&gt;(function_to_bind);
-		// MSVC, SunC++ and DMC accept the following (non-standard) code:
-//		m_pthis = static_cast&lt;GenericClass *&gt;(static_cast&lt;void *&gt;(function_to_bind));
-		// BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long
-//		m_pthis = reinterpret_cast&lt;GenericClass *&gt;(reinterpret_cast&lt;long&gt;(function_to_bind));
-	}
-	// ******** EVIL, EVIL CODE! *******
-	// This function will be called with an invalid 'this' pointer!!
-	// We're just returning the 'this' pointer, converted into
-	// a function pointer!
-	inline UnvoidStaticFuncPtr GetStaticFunction() const {
-		// Ensure that there's a compilation failure if function pointers 
-		// and data pointers have different sizes.
-		// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
-		typedef int ERROR_CantUseEvilMethod[sizeof(UnvoidStaticFuncPtr)==sizeof(this) ? 1 : -1];
-		return horrible_cast&lt;UnvoidStaticFuncPtr&gt;(this);
-	}
-#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
-
-	// Does the closure contain this static function?
-	inline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr){
-		if (funcptr==0) return empty(); 
-	// For the Evil method, if it doesn't actually contain a static function, this will return an arbitrary
-	// value that is not equal to any valid function pointer.
-		else return funcptr==reinterpret_cast&lt;StaticFuncPtr&gt;(GetStaticFunction());
-	}
-};
-
-
-} // namespace detail
-
-////////////////////////////////////////////////////////////////////////////////
-//						Fast Delegates, part 3:
-//
-//				Wrapper classes to ensure type safety
-//
-////////////////////////////////////////////////////////////////////////////////
-
-
-// Once we have the member function conversion templates, it's easy to make the
-// wrapper classes. So that they will work with as many compilers as possible, 
-// the classes are of the form
-//   FastDelegate3&lt;int, char *, double&gt;
-// They can cope with any combination of parameters. The max number of parameters
-// allowed is 8, but it is trivial to increase this limit.
-// Note that we need to treat const member functions seperately.
-// All this class does is to enforce type safety, and invoke the delegate with
-// the correct list of parameters.
-
-// Because of the weird rule about the class of derived member function pointers,
-// you sometimes need to apply a downcast to the 'this' pointer.
-// This is the reason for the use of &quot;implicit_cast&lt;X*&gt;(pthis)&quot; in the code below. 
-// If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,
-// without this trick you'd need to write:
-//		MyDelegate(static_cast&lt;CBaseClass *&gt;(&amp;d), &amp;CDerivedClass::SimpleVirtualFunction);
-// but with the trick you can write
-//		MyDelegate(&amp;d, &amp;CDerivedClass::SimpleVirtualFunction);
-
-// RetType is the type the compiler uses in compiling the template. For VC6,
-// it cannot be void. DesiredRetType is the real type which is returned from
-// all of the functions. It can be void.
-
-// Implicit conversion to &quot;bool&quot; is achieved using the safe_bool idiom,
-// using member data pointers (MDP). This allows &quot;if (dg)...&quot; syntax
-// Because some compilers (eg codeplay) don't have a unique value for a zero
-// MDP, an extra padding member is added to the SafeBool struct.
-// Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so
-// in that case the static function constructor is not made explicit; this
-// allows &quot;if (dg==0) ...&quot; to compile.
-
-//N=0
-template&lt;class RetType=detail::DefaultVoid&gt;
-class FastDelegate0 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)();
-	typedef RetType (*UnvoidStaticFunctionPtr)();
-	typedef RetType (detail::GenericClass::*GenericMemFn)();
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate0 type;
-
-	// Construction and comparison functions
-	FastDelegate0() { clear(); }
-	FastDelegate0(const FastDelegate0 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate0 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate0 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate0 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate0 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate0 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate0(Y *pthis, DesiredRetType (X::* function_to_bind)() ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)()) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate0(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate0(DesiredRetType (*function_to_bind)() ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)() ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)()) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate0::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() () const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction() const {
-	return (*(m_Closure.GetStaticFunction()))(); }
-};
-
-//N=1
-template&lt;class Param1, class RetType=detail::DefaultVoid&gt;
-class FastDelegate1 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate1 type;
-
-	// Construction and comparison functions
-	FastDelegate1() { clear(); }
-	FastDelegate1(const FastDelegate1 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate1 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate1 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate1 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate1 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate1 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate1(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate1(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate1(DesiredRetType (*function_to_bind)(Param1 p1) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate1::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1) const {
-	return (*(m_Closure.GetStaticFunction()))(p1); }
-};
-
-//N=2
-template&lt;class Param1, class Param2, class RetType=detail::DefaultVoid&gt;
-class FastDelegate2 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate2 type;
-
-	// Construction and comparison functions
-	FastDelegate2() { clear(); }
-	FastDelegate2(const FastDelegate2 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate2 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate2 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate2 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate2 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate2 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate2(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate2(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate2(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate2::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1, Param2 p2) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1, Param2 p2) const {
-	return (*(m_Closure.GetStaticFunction()))(p1, p2); }
-};
-
-//N=3
-template&lt;class Param1, class Param2, class Param3, class RetType=detail::DefaultVoid&gt;
-class FastDelegate3 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate3 type;
-
-	// Construction and comparison functions
-	FastDelegate3() { clear(); }
-	FastDelegate3(const FastDelegate3 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate3 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate3 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate3 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate3 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate3 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate3(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate3(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate3(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate3::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1, Param2 p2, Param3 p3) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3) const {
-	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3); }
-};
-
-//N=4
-template&lt;class Param1, class Param2, class Param3, class Param4, class RetType=detail::DefaultVoid&gt;
-class FastDelegate4 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate4 type;
-
-	// Construction and comparison functions
-	FastDelegate4() { clear(); }
-	FastDelegate4(const FastDelegate4 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate4 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate4 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate4 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate4 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate4 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate4(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate4(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate4(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate4::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
-	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4); }
-};
-
-//N=5
-template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class RetType=detail::DefaultVoid&gt;
-class FastDelegate5 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate5 type;
-
-	// Construction and comparison functions
-	FastDelegate5() { clear(); }
-	FastDelegate5(const FastDelegate5 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate5 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate5 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate5 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate5 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate5 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate5(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate5(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate5(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate5::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
-	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5); }
-};
-
-//N=6
-template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType=detail::DefaultVoid&gt;
-class FastDelegate6 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate6 type;
-
-	// Construction and comparison functions
-	FastDelegate6() { clear(); }
-	FastDelegate6(const FastDelegate6 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate6 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate6 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate6 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate6 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate6 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate6(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate6(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate6(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate6::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
-	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6); }
-};
-
-//N=7
-template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType=detail::DefaultVoid&gt;
-class FastDelegate7 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate7 type;
-
-	// Construction and comparison functions
-	FastDelegate7() { clear(); }
-	FastDelegate7(const FastDelegate7 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate7 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate7 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate7 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate7 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate7 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate7(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate7(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate7(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate7::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
-	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7); }
-};
-
-//N=8
-template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType=detail::DefaultVoid&gt;
-class FastDelegate8 {
-private:
-	typedef typename detail::DefaultVoidToVoid&lt;RetType&gt;::type DesiredRetType;
-	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
-	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
-	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
-	typedef detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
-	ClosureType m_Closure;
-public:
-	// Typedefs to aid generic programming
-	typedef FastDelegate8 type;
-
-	// Construction and comparison functions
-	FastDelegate8() { clear(); }
-	FastDelegate8(const FastDelegate8 &amp;x) {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	void operator = (const FastDelegate8 &amp;x)  {
-		m_Closure.CopyFrom(this, x.m_Closure); }
-	bool operator ==(const FastDelegate8 &amp;x) const {
-		return m_Closure.IsEqual(x.m_Closure);	}
-	bool operator !=(const FastDelegate8 &amp;x) const {
-		return !m_Closure.IsEqual(x.m_Closure); }
-	bool operator &lt;(const FastDelegate8 &amp;x) const {
-		return m_Closure.IsLess(x.m_Closure);	}
-	bool operator &gt;(const FastDelegate8 &amp;x) const {
-		return x.m_Closure.IsLess(m_Closure);	}
-	// Binding to non-const member functions
-	template &lt; class X, class Y &gt;
-	FastDelegate8(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
-	template &lt; class X, class Y &gt;
-	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
-		m_Closure.bindmemfunc(detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);	}
-	// Binding to const member functions.
-	template &lt; class X, class Y &gt;
-	FastDelegate8(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);	}
-	template &lt; class X, class Y &gt;
-	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
-		m_Closure.bindconstmemfunc(detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);	}
-	// Static functions. We convert them into a member function call.
-	// This constructor also provides implicit conversion
-	FastDelegate8(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
-		bind(function_to_bind);	}
-	// for efficiency, prevent creation of a temporary
-	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
-		bind(function_to_bind);	}
-	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
-		m_Closure.bindstaticfunc(this, &amp;FastDelegate8::InvokeStaticFunction, 
-			function_to_bind); }
-	// Invoke the delegate
-	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
-	return (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8); }
-	// Implicit conversion to &quot;bool&quot; using the safe_bool idiom
-private:
-	typedef struct SafeBoolStruct {
-		int a_data_pointer_to_this_is_0_on_buggy_compilers;
-		StaticFunctionPtr m_nonzero;
-	} UselessTypedef;
-    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
-public:
-	operator unspecified_bool_type() const {
-        return empty()? 0: &amp;SafeBoolStruct::m_nonzero;
-    }
-	// necessary to allow ==0 to work despite the safe_bool idiom
-	inline bool operator==(StaticFunctionPtr funcptr) {
-		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
-	inline bool operator!=(StaticFunctionPtr funcptr) { 
-		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
-	inline bool operator ! () const	{	// Is it bound to anything?
-			return !m_Closure; }
-	inline bool empty() const	{
-			return !m_Closure; }
-	void clear() { m_Closure.clear();}
-	// Conversion to and from the DelegateMemento storage class
-	const DelegateMemento &amp; GetMemento() { return m_Closure; }
-	void SetMemento(const DelegateMemento &amp;any) { m_Closure.CopyFrom(this, any); }
-
-private:	// Invoker for static functions
-	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
-	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8); }
-};
-
-
-////////////////////////////////////////////////////////////////////////////////
-//						Fast Delegates, part 4:
-// 
-//				FastDelegate&lt;&gt; class (Original author: Jody Hagins)
-//	Allows boost::function style syntax like:
-//			FastDelegate&lt; double (int, long) &gt;
-// instead of:
-//			FastDelegate2&lt; int, long, double &gt;
-//
-////////////////////////////////////////////////////////////////////////////////
-
-#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
-
-// Declare FastDelegate as a class template.  It will be specialized
-// later for all number of arguments.
-template &lt;typename Signature&gt;
-class FastDelegate;
-
-//N=0
-// Specialization to allow use of
-// FastDelegate&lt; R (  ) &gt;
-// instead of 
-// FastDelegate0 &lt; R &gt;
-template&lt;typename R&gt;
-class FastDelegate&lt; R (  ) &gt;
-  // Inherit from FastDelegate0 so that it can be treated just like a FastDelegate0
-  : public FastDelegate0 &lt; R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate0 &lt; R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)(  ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)(  ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)(  ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=1
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1 ) &gt;
-// instead of 
-// FastDelegate1 &lt; Param1, R &gt;
-template&lt;typename R, class Param1&gt;
-class FastDelegate&lt; R ( Param1 ) &gt;
-  // Inherit from FastDelegate1 so that it can be treated just like a FastDelegate1
-  : public FastDelegate1 &lt; Param1, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate1 &lt; Param1, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=2
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1, Param2 ) &gt;
-// instead of 
-// FastDelegate2 &lt; Param1, Param2, R &gt;
-template&lt;typename R, class Param1, class Param2&gt;
-class FastDelegate&lt; R ( Param1, Param2 ) &gt;
-  // Inherit from FastDelegate2 so that it can be treated just like a FastDelegate2
-  : public FastDelegate2 &lt; Param1, Param2, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate2 &lt; Param1, Param2, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1, Param2 p2 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1, Param2 p2 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=3
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1, Param2, Param3 ) &gt;
-// instead of 
-// FastDelegate3 &lt; Param1, Param2, Param3, R &gt;
-template&lt;typename R, class Param1, class Param2, class Param3&gt;
-class FastDelegate&lt; R ( Param1, Param2, Param3 ) &gt;
-  // Inherit from FastDelegate3 so that it can be treated just like a FastDelegate3
-  : public FastDelegate3 &lt; Param1, Param2, Param3, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate3 &lt; Param1, Param2, Param3, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=4
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1, Param2, Param3, Param4 ) &gt;
-// instead of 
-// FastDelegate4 &lt; Param1, Param2, Param3, Param4, R &gt;
-template&lt;typename R, class Param1, class Param2, class Param3, class Param4&gt;
-class FastDelegate&lt; R ( Param1, Param2, Param3, Param4 ) &gt;
-  // Inherit from FastDelegate4 so that it can be treated just like a FastDelegate4
-  : public FastDelegate4 &lt; Param1, Param2, Param3, Param4, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate4 &lt; Param1, Param2, Param3, Param4, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=5
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5 ) &gt;
-// instead of 
-// FastDelegate5 &lt; Param1, Param2, Param3, Param4, Param5, R &gt;
-template&lt;typename R, class Param1, class Param2, class Param3, class Param4, class Param5&gt;
-class FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5 ) &gt;
-  // Inherit from FastDelegate5 so that it can be treated just like a FastDelegate5
-  : public FastDelegate5 &lt; Param1, Param2, Param3, Param4, Param5, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate5 &lt; Param1, Param2, Param3, Param4, Param5, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=6
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6 ) &gt;
-// instead of 
-// FastDelegate6 &lt; Param1, Param2, Param3, Param4, Param5, Param6, R &gt;
-template&lt;typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6&gt;
-class FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6 ) &gt;
-  // Inherit from FastDelegate6 so that it can be treated just like a FastDelegate6
-  : public FastDelegate6 &lt; Param1, Param2, Param3, Param4, Param5, Param6, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate6 &lt; Param1, Param2, Param3, Param4, Param5, Param6, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=7
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) &gt;
-// instead of 
-// FastDelegate7 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, R &gt;
-template&lt;typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7&gt;
-class FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) &gt;
-  // Inherit from FastDelegate7 so that it can be treated just like a FastDelegate7
-  : public FastDelegate7 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate7 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-//N=8
-// Specialization to allow use of
-// FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) &gt;
-// instead of 
-// FastDelegate8 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R &gt;
-template&lt;typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8&gt;
-class FastDelegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) &gt;
-  // Inherit from FastDelegate8 so that it can be treated just like a FastDelegate8
-  : public FastDelegate8 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R &gt;
-{
-public:
-  // Make using the base type a bit easier via typedef.
-  typedef FastDelegate8 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R &gt; BaseType;
-
-  // Allow users access to the specific type of this delegate.
-  typedef FastDelegate SelfType;
-
-  // Mimic the base class constructors.
-  FastDelegate() : BaseType() { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(Y * pthis, 
-    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
-    : BaseType(pthis, function_to_bind)  { }
-
-  template &lt; class X, class Y &gt;
-  FastDelegate(const Y *pthis,
-      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const)
-    : BaseType(pthis, function_to_bind)
-  {  }
-
-  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
-    : BaseType(function_to_bind)  { }
-  void operator = (const BaseType &amp;x)  {	  
-		*static_cast&lt;BaseType*&gt;(this) = x; }
-};
-
-
-#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
-
-////////////////////////////////////////////////////////////////////////////////
-//						Fast Delegates, part 5:
-//
-//				MakeDelegate() helper function
-//
-//			MakeDelegate(&amp;x, &amp;X::func) returns a fastdelegate of the type
-//			necessary for calling x.func() with the correct number of arguments.
-//			This makes it possible to eliminate many typedefs from user code.
-//
-////////////////////////////////////////////////////////////////////////////////
-
-// Also declare overloads of a MakeDelegate() global function to 
-// reduce the need for typedefs.
-// We need seperate overloads for const and non-const member functions.
-// Also, because of the weird rule about the class of derived member function pointers,
-// implicit downcasts may need to be applied later to the 'this' pointer.
-// That's why two classes (X and Y) appear in the definitions. Y must be implicitly
-// castable to X.
-
-// Workaround for VC6. VC6 needs void return types converted into DefaultVoid.
-// GCC 3.2 and later won't compile this unless it's preceded by 'typename',
-// but VC6 doesn't allow 'typename' in this context.
-// So, I have to use a macro.
-
-#ifdef FASTDLGT_VC6
-#define FASTDLGT_RETTYPE detail::VoidToDefaultVoid&lt;RetType&gt;::type
-#else 
-#define FASTDLGT_RETTYPE RetType
-#endif
-
-//N=0
-template &lt;class X, class Y, class RetType&gt;
-FastDelegate0&lt;FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)()) { 
-	return FastDelegate0&lt;FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class RetType&gt;
-FastDelegate0&lt;FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)() const) { 
-	return FastDelegate0&lt;FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=1
-template &lt;class X, class Y, class Param1, class RetType&gt;
-FastDelegate1&lt;Param1, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1)) { 
-	return FastDelegate1&lt;Param1, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class RetType&gt;
-FastDelegate1&lt;Param1, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1) const) { 
-	return FastDelegate1&lt;Param1, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=2
-template &lt;class X, class Y, class Param1, class Param2, class RetType&gt;
-FastDelegate2&lt;Param1, Param2, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 
-	return FastDelegate2&lt;Param1, Param2, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class Param2, class RetType&gt;
-FastDelegate2&lt;Param1, Param2, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2) const) { 
-	return FastDelegate2&lt;Param1, Param2, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=3
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class RetType&gt;
-FastDelegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3)) { 
-	return FastDelegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class RetType&gt;
-FastDelegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3) const) { 
-	return FastDelegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=4
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType&gt;
-FastDelegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) { 
-	return FastDelegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType&gt;
-FastDelegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) { 
-	return FastDelegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=5
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType&gt;
-FastDelegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) { 
-	return FastDelegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType&gt;
-FastDelegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) { 
-	return FastDelegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=6
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType&gt;
-FastDelegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) { 
-	return FastDelegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType&gt;
-FastDelegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) { 
-	return FastDelegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=7
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType&gt;
-FastDelegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) { 
-	return FastDelegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType&gt;
-FastDelegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) { 
-	return FastDelegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-//N=8
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType&gt;
-FastDelegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) { 
-	return FastDelegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-template &lt;class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType&gt;
-FastDelegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt; MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) { 
-	return FastDelegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt;(x, func);
-}
-
-
- // clean up after ourselves...
-#undef FASTDLGT_RETTYPE
-
-} // namespace fastdelegate
-
-#endif // !defined(FASTDELEGATE_H)
-

Copied: dependencies/OgreNewt/include/OgreNewt/FastDelegate.h (from rev 2944, dependencies/OgreNewt/include/FastDelegate.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_BasicJoints.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_BasicJoints.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Body.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_Body.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_BodyIterator.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_BodyIterator.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Collision.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_Collision.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_CollisionPrimitives.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_CollisionPrimitives.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_ContactCallback.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_ContactCallback.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_Debugger.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Joint.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_Joint.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialID.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_MaterialID.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialPair.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_MaterialPair.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_Prerequisites.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_RayCast.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_RayCast.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Tools.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_Tools.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_TreeCollisionSerializer.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_TreeCollisionSerializer.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Vehicle.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_Vehicle.h)

Copied: dependencies/OgreNewt/include/OgreNewt/OgreNewt_World.h (from rev 2944, dependencies/OgreNewt/include/OgreNewt_World.h)

Copied: dependencies/OgreNewt/include/OgreNewt/line3D.h (from rev 2944, dependencies/OgreNewt/include/line3D.h)

Deleted: dependencies/OgreNewt/include/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,107 +0,0 @@
-/*
-	OgreNewt library
-
-	connects Ogre with the Newton Game Dynamics physics library
-
-
-		by Walaber (<A HREF="http://walaber.com">http://walaber.com</A>)
-
-	main header file.
-
-	current version:  0.06
-
-		Newton version: 1.5
-
-		Ogre version: Dagon branch
-
-*/
-
-#ifndef _INCLUDE_OGRENEWT_
-#define _INCLUDE_OGRENEWT_
-
-
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Collision.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-#include &quot;OgreNewt_CollisionPrimitives.h&quot;
-#include &quot;OgreNewt_TreeCollisionSerializer.h&quot;
-#include &quot;OgreNewt_MaterialID.h&quot;
-#include &quot;OgreNewt_MaterialPair.h&quot;
-#include &quot;OgreNewt_ContactCallback.h&quot;
-#include &quot;OgreNewt_Vehicle.h&quot;
-#include &quot;OgreNewt_RayCast.h&quot;
-
-#include &quot;OgreNewt_Joint.h&quot;
-#include &quot;OgreNewt_BasicJoints.h&quot;
-
-#include &quot;OgreNewt_Tools.h&quot;
-#include &quot;OgreNewt_BodyIterator.h&quot;
-#include &quot;OgreNewt_Debugger.h&quot;
-
-/*! \mainpage OgreNewt Library version 0.07
-
-	\section into_sec Introduction
-
-	OgreNewt is an OOP wrapper for integrating the Newton Dynamics Physics SDK with OGRE.
-
-	\section new New in this Version
-
-	New in this version!
-		- moved callback system to much more OOP-friendly &quot;fastdelegate&quot; system.  callbacks can now be instance-specific member functions!
-		- several other small fixes to project files, etc.
-		- automatic convex hull generation system added to supplementary ragdoll class (see demo08).
-		- documentation updated.
-
-	previous changes...
-		- updated to Newton version 1.5
-		- added this documentation!
-		- added buoyancy functionality.
-		- New Buoyancy demo.
-		- New Ragdoll demo, using a seperate class to implement ragdoll functionality.
-		- added basic classes for CustomJoints, and a simple demo showing how they work.
-		- added several prebuilt custom joints, including pulleys and gears, and a general 2D joint.
-		- added calculateInertialMatrix to ConvexCollision class.
-		- added set/getCenterOfMass to Body class
-		- changed angle-related functions in BasicJoint classes to use Ogre::Radian instead of Ogre::Real.
-		- added ConvexModifierCollision class, which allows for arbitrarily scaled collision primitives.
-		- added several low-level collision functions, see the CollisionTools namespace.
-		- fixed errors causing run-time crash on Slider and Universal joints.
-		- added LeaveWorldCallback functionality to World class.
-
-	\section install Installation
-
-	OgreNewt comes with a project for MSVC++ 7.1 and MSVC++ 8.0 (2005).  unfortunately I have no other IDE's or compilers setup on my system, so I
-	cannot provide any other projects.  the MSVC solution should build out of the box, assuming you take a few things into
-	consideration.
-
-	unzip this in the ogreaddons directory alongside your &quot;ogrenew&quot; directory.  to compile correctly, it also assumes you have the Newton SDK installed in another
-	directory alongside this one called &quot;NewtonSDK&quot;.
-
-	for example something like this:
-
-	- c:/programming/Ogre/ogrenew						&lt;- ogre installation
-	- c:/programming/Ogre/ogreaddons/OgreNewt			&lt;- OgreNewt main directory.
-	- c:/programming/NewtonSDK							&lt;- Newton SDK.
-	- c:/programming/tinyxml							&lt;- tinyxml library (for ragdoll demo only)
-
-	\section compiling Compiling
-
-	OgreNewt compiles be default to a static library for linking to your project.  However you can also compile OgreNewt into a dynamic DLL on the 
-	Windows platform by using the Debug_DLL and Release_DLL solution build configurations in the MSVC solutions.
-
-	note that if you compile OgreNewt as a dynamic DLL and the default debugger, you will need to manually link to the Line3D.obj file by
-	either adding Line3D.cpp to the project, or compiling it separately.
-
-	\section license License
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-
-	well, that's about it!
-	have fun!
-
-	-walaber
-
-*/
-
-#endif

Deleted: dependencies/OgreNewt/include/OgreNewt_BasicJoints.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_BasicJoints.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_BasicJoints.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,557 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_BASICJOINTS
-#define _INCLUDE_OGRENEWT_BASICJOINTS
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-#include &quot;OgreNewt_Joint.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-//! Namespace for ready-made joints
-namespace BasicJoints
-{
-
-//! Ball and Socket joint.
-/*!
-	simple ball and socket joint, with limits.
-*/
-class _OgreNewtExport BallAndSocket : public Joint
-{
- 
-public:
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pos position of the joint in global space
-	*/
-	BallAndSocket( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos );
-	
-	//! destructor.
-	~BallAndSocket();					
-
-	//! retrieve the current joint angle
-	Ogre::Vector3 getJointAngle() const;
-
-	//! retrieve the current joint omega
-	Ogre::Vector3 getJointOmega() const;
-
-	//! retrieve the current joint force.
-	/*!
-		This can be used to find the &quot;stress&quot; on the joint.  you can do special effects like break the joint if the force exceedes some value, etc.
-	*/
-	Ogre::Vector3 getJointForce() const;
-
-	//! set limits for the joints rotation
-	/*!
-		\param pin pin direction in global space
-		\param maxCone max angle for &quot;swing&quot; (in radians)
-		\param maxTwist max angle for &quot;twist&quot;  (in radians)
-	*/
-	void setLimits( const Ogre::Vector3&amp; pin, Ogre::Radian maxCone, Ogre::Radian maxTwist ) const { NewtonBallSetConeLimits( m_joint, &amp;pin.x, (float)maxCone.valueRadians(), (float)maxTwist.valueRadians() ); }
-
-
-};
-
-
-//! hinge joint.
-/*!
-	simple hinge joint.  implement motors/limits through a callback.
-*/
-class _OgreNewtExport Hinge : public Joint
-{
- 
-public:
-
-	//! custom hinge callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*HingeCallback)( Hinge* me );
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pin direction of the joint pin in global space
-	*/
-	Hinge( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
-
-	//! destructor
-	~Hinge();	
-
-	//! retrieve the angle around the pin.
-	Ogre::Radian getJointAngle() const { return Ogre::Radian(NewtonHingeGetJointAngle( m_joint )); }
-
-	//! retrieve the rotational velocity around the pin.
-	Ogre::Real getJointOmega() const { return (Ogre::Real)NewtonHingeGetJointOmega( m_joint ); }
-
-	//! get the force on the joint.
-	Ogre::Vector3 getJointForce() const;
-
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Hinge as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( HingeCallback callback ) { m_callback = callback; }
-
-
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
-
-	//! set acceleration around the joint pin
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackAccel( Ogre::Real accel );
-
-	//! set minimum joint friction.
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackFrictionMin( Ogre::Real min );
-
-	//! set maximum joint friction
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackFrictionMax( Ogre::Real max );
-
-	//! get the current physics timestep.
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified angle.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	Ogre::Real calculateStopAlpha( Ogre::Radian angle ) const;
-
-protected:
-
-	//! newton callback, used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* hinge, NewtonHingeSliderUpdateDesc* desc );
-
-	HingeCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
-
-	unsigned m_retval;
-
-
-};
-
-
-//! slider joint.
-/*!
-	simple slider joint.  implement motors/limits through a callback.
-*/
-class _OgreNewtExport Slider : public Joint
-{
- 
-public:
-
-	//! custom slider callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*SliderCallback)( Slider* me );
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pin direction of the joint pin in global space
-	*/
-	Slider( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
-
-	//! destructor.
-	~Slider();
-
-	//! get position of child along the pin
-	Ogre::Real getJointPosit() const { return (Ogre::Real)NewtonSliderGetJointPosit( m_joint ); }
-
-	//! get rotational velocity along the pin
-	Ogre::Real getJointVeloc() const { return (Ogre::Real)NewtonSliderGetJointVeloc( m_joint ); }
-
-	//! get force on the joint.
-	Ogre::Vector3 getJointForce() const;
-
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Slider as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( SliderCallback callback ) { m_callback = callback; }
-
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
-
-	//! set the acceleration along the pin.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackAccel( Ogre::Real accel );
-
-	//! set minimum friction for the joint
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackFrictionMin( Ogre::Real min );
-
-	//! set maximum friction for the joint.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackFrictionMax( Ogre::Real max );
-
-	//! get current physics timestep.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified distance.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	Ogre::Real calculateStopAccel( Ogre::Real dist ) const;
-
-protected:
-
-	//! newton callback.  used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* slider, NewtonHingeSliderUpdateDesc* desc );
-
-	SliderCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
-
-	unsigned m_retval;
-
-};
-
-
-
-//!	this class represents a Universal joint.
-/*!
-	simple universal joint.  implement motors/limits through a callback.
-*/
-class _OgreNewtExport Universal : public Joint
-{
- 
-public:
-	
-	//! custom universal callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*UniversalCallback)( Universal* me );
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pos position of the joint in global space
-		\param pin0 direction of the first axis of rotation in global space
-		\param pin1 direction of the second axis of rotation in global space
-	*/
-	Universal( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin0, const Ogre::Vector3&amp; pin1 );
-
-	//! destructor
-	~Universal();
-
-	//! get the angle around pin0.
-	Ogre::Radian getJointAngle0() const { return Ogre::Radian(NewtonUniversalGetJointAngle0( m_joint )); }
-
-	//! get the angle around pin1.
-	Ogre::Radian getJointAngle1() const { return Ogre::Radian(NewtonUniversalGetJointAngle1( m_joint )); }
-
-	//! get the rotational velocity around pin0.
-	Ogre::Real getJointOmega0() const { return (Ogre::Real)NewtonUniversalGetJointOmega0( m_joint ); }
-
-	//! get the rotational velocity around pin1.
-	Ogre::Real getJointOmega1() const { return (Ogre::Real)NewtonUniversalGetJointOmega1( m_joint ); }
-
-	//! get the force on the joint.
-	Ogre::Vector3 getJointForce() const;
-
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Universal as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( UniversalCallback callback ) { m_callback = callback; }
-
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
-
-	//! set the acceleration around a particular pin.
-	/*
-		this function can only be called from within a custom callback.
-		\param accel desired acceleration
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackAccel( Ogre::Real accel, unsigned axis );
-
-	//! set the minimum friction around a particular pin
-	/*
-		this function can only be called from within a custom callback.
-		\param min minimum friction
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackFrictionMin( Ogre::Real min, unsigned axis );
-
-	//! set the maximum friction around a particular pin.
-	/*
-		this function can only be called from within a custom callback.
-		\param max maximum friction
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackFrictionMax( Ogre::Real max, unsigned axis );
-
-	//! get the current phsics timestep.
-	/*
-		this function can only be called from within a custom callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 0.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom  callback.
-	*/
-	Ogre::Real calculateStopAlpha0( Ogre::Real angle ) const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 1.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom  callback.
-	*/
-	Ogre::Real calculateStopAlpha1( Ogre::Real angle ) const;
-
-protected:
-	
-	//! newton callback.  used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* universal, NewtonHingeSliderUpdateDesc* desc );
-
-	UniversalCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
-
-	unsigned m_retval;
-
-
-
-};
-
-
-
-//! UpVector joint.
-/*!
-	simple upvector joint.  upvectors remove all rotation except for a single pin.  useful for character controllers, etc.
-*/
-class _OgreNewtExport UpVector : public Joint
-{
- 
-public:
-	//! constructor
-	/*
-		\param world pointer to the OgreNewt::World.
-		\param body pointer to the body to apply the upvector to.
-		\param pin direction of the upvector in global space.
-	*/
-	UpVector( const World* world, const Body* body, const Ogre::Vector3&amp; pin );
-
-	//! destructor
-	~UpVector();
-
-	//! set the pin direction.
-	/*
-		by calling this function in realtime, you can effectively &quot;animate&quot; the pin.
-	*/
-	void setPin( const Ogre::Vector3&amp; pin ) const { NewtonUpVectorSetPin( m_joint, &amp;pin.x ); }
-
-	//! get the current pin direction.
-	Ogre::Vector3 getPin() const;
-
-
-};
-
-
-}	// end NAMESPACE BasicJoints
-
-
-//! namespace for pre-built custom joints
-namespace PrebuiltCustomJoints
-{
-
-	//! Custom2DJoint class
-	/*!
-		This class represents a joint that limits movement to a plane, and rotation only around the normal of that
-		plane.  This can be used to create simple 2D simulations.  it also supports limits and acceleration for spinning.
-		This joint has been used in a few projects, but is not 100% fully-tested.
-	*/
-	class _OgreNewtExport Custom2DJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		//! constructor
-		Custom2DJoint( const OgreNewt::Body* body, const Ogre::Vector3&amp; pin );
-
-		//! destructor
-		~Custom2DJoint() {}
-
-		//! overloaded function that applies the actual constraint.
-		void submitConstraint();
-
-		//! get the current angle of the joint.
-		Ogre::Radian getAngle() const { return mAngle; }
-
-		//! set rotational limits for the joint.
-		void setLimits( Ogre::Degree min, Ogre::Degree max ) { mMin = min, mMax = max; }
-		
-		//! sets whether to enable limits or not for the joint.
-		void setLimitsOn( bool onoff ) { mLimitsOn = onoff; }
-
-		//! returns whether limits are turned on or off for the joint.
-		bool getLimitsOn() const { return mLimitsOn; }
-
-		//! adds rotational acceleration to the joint (like a motor)
-		void addAccel( Ogre::Real accel ) { mAccel = accel; }
-
-		//! resets the joint angle to 0.  this simply sets the internal variable to zero.
-		//! you might want to call this for example after resetting a body.
-		void resetAngle() { mAngle = Ogre::Radian(0.0f); }
-
-		//! get the pin.
-		Ogre::Vector3 getPin() { return mPin; }
-
-	private:
-		Ogre::Vector3 mPin;
-		Ogre::Quaternion mLocalOrient0, mLocalOrient1;
-		Ogre::Vector3 mLocalPos0, mLocalPos1;
-
-		Ogre::Radian mAngle;
-
-		Ogre::Radian mMin;
-		Ogre::Radian mMax;
-
-		bool mLimitsOn;
-
-		Ogre::Real mAccel;
-	};
-
-	//! CustomFixedJoint
-	/*!
-		This joint implements a fully fixed joint, which removes all DOF, creating a completely fixed connection between bodies.
-		This is probably the most expensive kind of joint, and should only be used when really needed.
-	*/
-	class CustomRigidJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		CustomRigidJoint( OgreNewt::Body* child, OgreNewt::Body* parent, Ogre::Vector3 dir, Ogre::Vector3 pos);
-		~CustomRigidJoint();
-
-		void submitConstraint();
-
-	private:
-		Ogre::Vector3 mLocalPos0;
-		Ogre::Vector3 mLocalPos1;
-
-		Ogre::Quaternion mLocalOrient0;
-		Ogre::Quaternion mLocalOrient1;
-	};
-
-
-	//! CutomPulleyJoint
-	/*!
-		This joint implements a pulley system.  note that this joint only works with 2 bodies attached!
-	*/
-	class _OgreNewtExport CustomPulleyJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		//! constructor
-		/*!
-			\param gearRatio float value representing the ratio of movement between parent and child.
-			\param parent pointer to OgreNewt::Body to be the parent body.
-			\param child pointer to the OgreNewt::Body to be the child body.
-			\param parentPin direction vector for movement of parent.
-			\param childPin direction vector for movement of child.
-		*/
-		CustomPulleyJoint( Ogre::Real gearRatio, const Body* parent, const Body* child, const Ogre::Vector3&amp; parentPin, const Ogre::Vector3&amp; childPin );
-		~CustomPulleyJoint() {}
-
-		//! overloaded function to submit the constraint.
-		void submitConstraint();
-
-	private:
-		Ogre::Real			mGearRatio;
-
-		Ogre::Vector3		mLocalPos0, mLocalPos1;
-		Ogre::Quaternion	mLocalOrient0, mLocalOrient1;
-	};
-
-
-	//! CustomGearJoint
-	/*!
-		This class works like 2 gears that mesh, retaining a specific ration between the rotational velocity of the bodies.
-		The gears don't have to rotate around the same axis, that is why 2 pins are supplied.
-	*/
-	class _OgreNewtExport CustomGearJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		/*!
-			\param gearRatio float value representing the ratio of movement between parent and child.
-			\param parent pointer to OgreNewt::Body to be the parent body.
-			\param child pointer to the OgreNewt::Body to be the child body.
-			\param parentPin pin around which the parent's rotation should be tracked.
-			\param childPin pin around which the child's rotation should be tracked.
-		*/
-		CustomGearJoint( Ogre::Real gearRatio, const Body* parent, const Body* child, const Ogre::Vector3&amp; parentPin, const Ogre::Vector3&amp; childPin );
-		~CustomGearJoint() {}
-
-		//! overloaded function to submit the constraint.
-		void submitConstraint();
-
-	private:
-		Ogre::Real			mGearRatio;
-
-		Ogre::Vector3		mLocalPos0, mLocalPos1;
-		Ogre::Quaternion	mLocalOrient0, mLocalOrient1;
-	};
-
-
-
-
-}	// end NAMESPACE PrebuiltCustomJoints
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_BASICJOINTS
-

Deleted: dependencies/OgreNewt/include/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_Body.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_Body.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,426 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-
-	please note that the &quot;fastdelegate&quot; library file included here is not of my creation, refer to that file for information.
-
-
-		by Walaber
-
-*/
-
-#ifndef _INCLUDE_OGRENEWT_BODY
-#define _INCLUDE_OGRENEWT_BODY
-
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Ogre.h&gt;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Collision.h&quot;
-#include &quot;OgreNewt_MaterialID.h&quot;
-#include &quot;FastDelegate.h&quot;
-
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-/*
-	CLASS DEFINITION:
-
-		Body
-
-	USE:
-		this class represents a NewtonBody rigid body!
-*/
-//! main class for all Rigid Bodies in the system.
-class _OgreNewtExport Body
-{
-public:
-	//! custom force callbacFk.
-	/*!
-		this function is called from within the OgreNewt::World::update() command when applying forces to Rigid Bodies, such as
-		gravity, etc.
-
-		You can set this as the custom force callback for a body by using the setCustomForceCallback() function.
-		Using fastdelegate means OgreNewt can now accept pointers to member functions of specific classes.
-	*/
-	typedef fastdelegate::FastDelegate1&lt; OgreNewt::Body* &gt; ForceCallback;
-
-	//! custom transform callback.
-	/*!
-		This function is called from within the OgreNewt::World::update() command for all Rigid Bodies, after all collision and
-		forces have been resolved.  this command is intended to allow the user to align a visual object with the new position and
-		orientation of the rigid body.  OgreNewt has a general transform callback built-in for use with Ogre.  however you can 
-		create your own for special cases.  you are passed a quaternion (orientation) and vector (position) of the rigid body
-		in world space.
-	*/
-	typedef fastdelegate::FastDelegate3&lt; OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp; &gt; TransformCallback;
-	
-
-	//! buoyancy plane callback
-	/*!
-		this function is a user-defined function that supplies Newton with the plane equation for the surface of the liquid when
-		applying buoyancy forces.  the user should create their own function for this, that returns an Ogre::Plane based on their
-		own criteria.  you get a pointer to the OgreNewt::Body, and it's current orientation and location to boot.  note that this
-		callback will be called for each collision primitive in the body (if it is a compound collision).  if you want to
-		ignore buoyancy for this collision primitive, just return false from the function.  otherwise, fill the &quot;retPlane&quot; with your
-		liquid surface plane, and return true to apply buoyancy to the primitive.
-	*/
-	typedef fastdelegate::FastDelegate5&lt; int, OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, Ogre::Plane&amp;, bool &gt; buoyancyPlaneCallback;
-
-
-	//! constructor.
-	/*!
-		creates a Rigid Body in an OgreNewt::World, based on a specific collision shape.
-		\param W pointer to the OgreNewt::World/
-		\param col pointer to an OgreNewt::Collision object that represents the shape of the rigid body.
-		\param bodytype simple integer value used to identify the type of rigid body, useful for determining bodies in callbacks.
-	*/
-	Body( const World* W, CollisionPtr col, int bodytype = 0 );
-
-	//! destructor
-	~Body();
-
-	//! set user data to connect this class to another.
-	/*!
-		you can use this to store a pointer to a parent class, etc.  then inside one of the many callbacks, you can get the pointer
-		using this &quot;userData&quot; system.
-	*/
-	void setUserData( void* data ) { m_userdata = data; }
-
-	//! retrieve pointer to previously set user data.
-	void* getUserData() const { return m_userdata; }
-
-	//! get a pointer to the NewtonBody object
-	/*!
-		this is the NewtonBody used by the Newton SDK.  in most cases you shouldn't need to access this.
-	*/
-	NewtonBody* getNewtonBody() const { return m_body; }
-
-	//! get a pointer to the attached SceneNode.
-	/*!
-		if you have &quot;attached&quot; this body to an Ogre::SceneNode, this retrieves the node.
-	*/
-	Ogre::SceneNode* getOgreNode() const { return m_node; }
-
-	//! get a pointer to the OgreNewt::World this body belongs to.
-	const OgreNewt::World* getWorld() const { return m_world; }
-
-	//! set the type for this body.
-	/*!
-		this sets the &quot;type&quot; for the body, which can also be set in the constructor.
-		\param type integer value to represent the type of body, e.g. &quot;FLOOR&quot; or &quot;CANON BALL&quot;, etc. used for differentation in material callbacks.
-	*/
-	void setType( int type ) { m_type = type; }
-
-	//! get the type set for this body.
-	int getType() const { return m_type; }
-
-	//! attach this body to an Ogre::SceneNode*
-	/*!
-		This is an easy way to connect a Rigid Body with an Ogre::SceneNode.
-		This automatically sets up a standard Transform callback when you call this.
-		After calling this, the Ogre::SceneNode will have its position orientation updated
-		to that of the Rigid Body each time you call World::update(),
-		and the body has moved during the update.
-	*/
-	void attachToNode(Ogre::SceneNode* node, const Ogre::Vector3&amp; offset = Ogre::Vector3::ZERO,
-		const Ogre::Quaternion&amp; orientationBias = Ogre::Quaternion::IDENTITY);
-
-	//! set a standard gravity callback for this body to use.
-	/*!
-		This sets a very basic force callback for this body, that simply applies a standard 9,8m/s^2 gravity force to the body.
-		in most cases you will need more forces acting on your Rigid Bodies, which you accomplich through custom force callbacks.
-	*/
-	void setStandardForceCallback();
-
-	//! set a custom force callback for this body to use.
-	/*
-		This specifies a custom callback to use for applying forces to a body.  if you are using a standard non-member function, or a static member function, you can simply pass a pointer to the function here.. like this:
-		setCustomForceAndTorqueCallback( &amp;myCallbackFunction );
-
-		If you want to bind to a class member, you also need to pass a pointer to the class itself, using the fastdelegate system, like so:
-		setCustomForceAndTorqueCallback( fastdelegate::MakeDelegate( (MyClass*)classInstance, &amp;MyClass::myCallback ) );  (from outside the class) or:
-		setCustomForceAndTorqueCallback( fastdelegate::MakeDelegate( this, &amp;MyClass::myCallback ) );  (from inside the class).
-	*/
-	void setCustomForceAndTorqueCallback( ForceCallback callback );
-
-	//! remove any force callbacks.
-	void removeForceAndTorqueCallback() { NewtonBodySetForceAndTorqueCallback( m_body, NULL );  m_forcecallback = NULL; }
-
-	//! set a custom transform callback.
-	/*
-		sets a custom transform callback for the rigid body. see the docs on setCustomForceAndTorqueCallback for a description of how to use this funciton.
-	*/
-	void setCustomTransformCallback( TransformCallback callback );
-
-	//! remove any transform callbacks.
-	void removeTransformCallback() { m_transformcallback = NULL; }
-
-	//! position and orient the body arbitrarily.
-	/*!
-		generally in a physics engine you shouldn't directly set the location/rotation of a Body, because this defies physics laws.  this command exists to set up bodies initially.
-		\param orient quaternion representing body orientation in world space.
-		\param pos vector representing body position in world space. 
-	*/
-	void setPositionOrientation( const Ogre::Vector3&amp; pos, const Ogre::Quaternion&amp; orient );
-
-	//! set the mass and inertia for the body.
-	/*!
-		Set the mass of the Rigid Body.  Inertia is also set here.  Inertia represents a body's &quot;resistance&quot; to rotation around the 3 primary axis.  OgreNewt has a few utility functions that can help you calculate these values based on several primitive shapes.
-		\param mass real value for the body mass
-		\param inertia vector representing body moment of inertia
-	*/
-	void setMassMatrix( Ogre::Real mass, const Ogre::Vector3&amp; inertia );
-
-	/** set mass of body and calculate inertia automatically,
-     *  for a solid body of the collision's shape.
-     */
-    void setMass(Ogre::Real mass);
-
-	//! set the body's center of mass
-	/*!
-		Set a new center of mass for the body that is different than the current, without offsetting the body.
-		You can use this to adjust the center of mass of a body at runtime.
-	*/
-	void setCenterOfMass( const Ogre::Vector3&amp; centerOfMass ) { NewtonBodySetCentreOfMass( m_body, &amp;centerOfMass.x ); }
-
-	//! get the center of mass.
-	/*!
-		returns the current center of mass, as an offset from the original origin when the body was created.
-	*/
-	Ogre::Vector3 getCenterOfMass() const;
-
-	//! freeze the rigid body.
-	/*!
-		this command &quot;freezes&quot; the Rigid Body, removing it from the active simulation list.  it will &quot;unfreeze&quot; if another body comes in contact with it, or you &quot;unfreeze&quot; it.
-		\sa unFreeze()
-	*/
-	void freeze() { NewtonWorldFreezeBody( m_world-&gt;getNewtonWorld(), m_body ); }
-
-	//! unfreeze the rigid body.
-	/*!
-		\sa freeze()
-	*/
-	void unFreeze() { NewtonWorldUnfreezeBody( m_world-&gt;getNewtonWorld(), m_body ); }
-
-	//! set the material for the body
-	/*!
-		Materials are an extremely powerful way to control body behavior. first create a new MaterialID object, and then pass a pointer
-		to apply that material to the body. 
-		\param ID pointer to an OgreNewt::MaterialID object to use as the material for the body.
-	*/
-	void setMaterialGroupID( const MaterialID* ID ) { m_matid = ID; NewtonBodySetMaterialGroupID( m_body, m_matid-&gt;getID() ); }
-	
-	//! prevents fast moving bodies from &quot;tunneling&quot; through other bodies.
-	/*!
-		continuous collision is an advanced feature that prevents fast moving bodies from &quot;tunneling&quot; (missing collision) with other bodies.  there 
-		is a performance hit envolved, so this feature should only be used for bodies that have a high likelyhood of tunneling.
-		
-		note that continuous collision can also be set on a per-material basis via the MaterialPair class.
-	*/
-	void setContinuousCollisionMode( unsigned state ) { NewtonBodySetContinuousCollisionMode( m_body, state ); }
-
-	//! set whether all parent/children pairs connected to this body should be allowed to collide.
-	void setJointRecursiveCollision( unsigned state ) { NewtonBodySetJointRecursiveCollision( m_body, state ); }
-
-	//! set an arbitrary omega for the body.
-	/*!
-		again, setting velocity/omega directly for a body in realtime is not recommended for proper physics behavior.  this function is intended to be used to setup a Body initially.
-		\param omega vector representing the desired omega (rotational velocity)
-	*/
-	void setOmega( const Ogre::Vector3&amp; omega ) { NewtonBodySetOmega( m_body, &amp;omega.x ); }
-
-	//! set an arbitrary velocity for the body.
-	/*!
-		again, setting velocity/omega directly for a body in realtime is not recommended for proper physics behavior.  this function is intended to be used to setup a Body initially.
-		\param vel vector representing the desired velocity.
-	*/
-	void setVelocity( const Ogre::Vector3&amp; vel ) { NewtonBodySetVelocity( m_body, &amp;vel.x ); }
-
-	//! set the linear damping for the body.
-	void setLinearDamping( Ogre::Real damp ) { NewtonBodySetLinearDamping( m_body, (float)damp ); }
-
-	//! set the angular damping for the body.
-	void setAngularDamping( const Ogre::Vector3&amp; damp ) { NewtonBodySetAngularDamping( m_body, &amp;damp.x ); }
-
-	//! set the Coriolos Forces mode for the body.
-	void setCoriolisForcesMode( int mode ) { NewtonBodyCoriolisForcesMode( m_body, mode ); }
-
-	//! set the collision that represents the shape of the body
-	/*!
-		This can be used to change the collision shape of a body mid-simulation.
-		For example making the collision for a character smaller when crouching, etc.
-		The old collision will get deleted.
-		\param col pointer to the new OgreNewt::Collision shape.
-	*/
-	void setCollision(CollisionPtr col);
-
-	//! set whether the body should &quot;freeze&quot; when equilibruim is reached.
-	/*!
-		user-controlled bodies should disable freezing, because frozen bodies' callbacks are not called... so a callback that implements motion based on user input will not be called!
-	*/
-	void setAutoFreeze( int flag ) { NewtonBodySetAutoFreeze ( m_body, flag); }
-
-	//! set the factors that cause a body to &quot;freeze&quot; when equilibrium reached.
-	void setFreezeThreshold( Ogre::Real speed, Ogre::Real omega, int framecount ) { NewtonBodySetFreezeTreshold( m_body, (float)speed, (float)omega, framecount ); }
-
-	//! get a pointer to the OgreNewt::Collision for this body
-	CollisionPtr getCollision() const;
-
-	//! get a pointer to the Material assigned to this body.
-	const OgreNewt::MaterialID* getMaterialGroupID() const;
-
-	//! returns current setting for this body.
-	int getContinuousCollisionMode() const { return NewtonBodyGetContinuousCollisionMode( m_body ); }
-
-	//! returns current setting for this body.
-	int getJointRecursiveCollision() const { return NewtonBodyGetJointRecursiveCollision( m_body ); }
-
-	//! get position and orientation in form of an Ogre::Vector(position) and Ogre::Quaternion(orientation)
-	void getPositionOrientation( Ogre::Vector3&amp; pos, Ogre::Quaternion&amp; orient ) const;
-
-	//! get Ogre::Real(mass) and Ogre::Vector3(inertia) of the body.
-	void getMassMatrix( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const;
-
-	//! get invert mass + inertia for the body.
-	void getInvMass( Ogre::Real&amp; mass, Ogre::Vector3&amp; inertia ) const;
-
-	//! get omega of the body. in global space. 
-	Ogre::Vector3 getOmega() const;
-
-	//! get velocity of the body. in global coordinates.
-	Ogre::Vector3 getVelocity() const;
-
-	//! get whether the body is frozen or not
-	/*!
-		returns a value of 0 if the body is frozen.
-		returns a value of 1 if the body is active.
-	*/
-	int getSleepingState() const { return NewtonBodyGetSleepingState( m_body ); }
-
-	//! get auto-freeze state for the body
-	int getAutoFreeze() const { return NewtonBodyGetAutoFreeze( m_body ); }
-
-	//! get linear damping
-	Ogre::Real getLinearDamping() const { return (Ogre::Real)NewtonBodyGetLinearDamping( m_body ); }
-
-	//! get angular damping
-	Ogre::Vector3 getAngularDamping() const;
-
-	//! get the freeze threshold
-	void getFreezeThreshold( Ogre::Real&amp; speed, Ogre::Real&amp; omega ) const { NewtonBodyGetFreezeTreshold( m_body, &amp;speed, &amp;omega ); }
-
-	//! add an impulse (relative change in velocity) to a body.  values are in world coordinates.
-	void addImpulse( const Ogre::Vector3&amp; deltav, const Ogre::Vector3&amp; posit ) { NewtonAddBodyImpulse( m_body, &amp;deltav.x, &amp;posit.x ); }
-
-	//! add force to the body.  
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void addForce( const Ogre::Vector3&amp; force ) { NewtonBodyAddForce( m_body, &amp;force.x ); }
-
-	//! add torque to the body.
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void addTorque( const Ogre::Vector3&amp; torque ) { NewtonBodyAddTorque( m_body, &amp;torque.x ); }
-
-	//! set the force for a body.
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void setForce( const Ogre::Vector3&amp; force ) { NewtonBodySetForce( m_body, &amp;force.x ); }
-
-	//! set the torque for a body.
-	/*!
-		this function is only valid inside a ForceCallback function!
-	*/
-	void setTorque( const Ogre::Vector3&amp; torque ) { NewtonBodySetTorque( m_body, &amp;torque.x ); }
-
-
-	//! apply a buoyancy force to the body.
-	/*!
-		buoyancy is one of the more powerful and overlooked features of the Newton physics system.  you can of course
-		simulate floating objects, and even lighter-than-air objects like balloons, etc.
-		\param fluidDensity density of the fluid.
-		\param fluidLinearViscosity how much the fluid slows linear motion
-		\param fluidAngularViscosity how much the fluid slows rotational motion
-		\param gravity vector representing world gravity.
-		\param buoyancyPlaneCallback user function that returns the plane equation for the fluid at the current location. pass NULL to assume the body is fully immersed in fluid.  see the setCustomForceAndTorqueCallback() docs to info on how to bind class member functions.
-	*/
-	void addBouyancyForce( Ogre::Real fluidDensity, Ogre::Real fluidLinearViscosity , Ogre::Real fluidAngularViscosity , const Ogre::Vector3&amp; gravity, buoyancyPlaneCallback callback );
-
-
-
-	//! helper function that adds a force (and resulting torque) to an object in global cordinates.
-	/*!
-		this function is only valid inside a ForceCallback function!
-		\param force vector representing force, in global space
-		\param pos vector representing location of force, in global space
-	*/
-	void addGlobalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos );
-
-	// helper function that adds a force (and resulting torque) to an object in local coordinates.
-	/*!
-		this function is only valid inside a ForceCallback function!
-		\param force vector representing force, in local space of the body
-		\param pos vector representing locatino of force, in local space of the body
-	*/
-	void addLocalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos );
-
-    Ogre::Vector3 getOffset() const;
-    void setOffset(const Ogre::Vector3&amp; offset);
-
-	Ogre::Quaternion getOrientationBias() const;
-	void setOrientationBias(const Ogre::Quaternion&amp; orientationbias);
-
- protected:
-
-	NewtonBody*			m_body;
-	CollisionPtr	    m_collision;
-	const MaterialID*	m_matid;
-	const World*		m_world;
-	
-
-	void*				m_userdata;
-	
-	int					m_type;
-	Ogre::SceneNode*	m_node;
-	Ogre::Vector3       m_offset;
-	Ogre::Quaternion    m_orientationBias;
-
-	ForceCallback			m_forcecallback;
-	TransformCallback		m_transformcallback;
-	buoyancyPlaneCallback	m_buoyancycallback;
-
-private:
-
-	static void _CDECL newtonDestructor( const NewtonBody* body );
-
-	static void _CDECL newtonTransformCallback( const NewtonBody* body, const float* matrix );
-	static void _CDECL newtonForceTorqueCallback( const NewtonBody* body );
-
-	static int _CDECL newtonBuoyancyCallback( const int collisionID, void* context, const float* globalSpaceMatrix, float* globalSpacePlane );
-
-	// standard gravity force callback.
-	static void standardForceCallback( Body* me );
-
-	// standard transform callback.
-	static void standardTransformCallback( Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos );
-};
-
-
-
-
-}
-
-#endif
-// _INCLUDE_OGRENEWT_BODY
-

Deleted: dependencies/OgreNewt/include/OgreNewt_BodyIterator.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_BodyIterator.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_BodyIterator.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,95 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-
-#ifndef _INCLUDE_OGRENEWT_BODYITERATOR
-#define _INCLUDE_OGRENEWT_BODYITERATOR
-
-#include &lt;Newton.h&gt;
-
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-//! Iterate through all bodies in the world.
-/*!
-	this class is an easy way to loop through all bodies in the world, performing some kind of action.
-*/
-class _OgreNewtExport BodyIterator
-{
-public:
-	//! function to be called for all bodies
-	/*!
-		This function will be called for every body in the world.  you can put any functionality you might want inside this function.
-	*/
-	typedef void(*IteratorCallback)( Body* me );
-
-	//! init the singleton class.
-	/*!
-		This function must be called before any iterator functions are called!
-		\param world pointer to the OgreNewt::World.  
-	*/
-	void Init( const OgreNewt::World* world ) { m_world = world; }
-
-	//! perform an iteration
-	/*!
-		will call the provided function for all bodies in the world.
-		\param callback pointer to a function to be used
-	*/
-	void go( IteratorCallback callback )
-	{
-		m_callback = callback;
-
-		NewtonWorldForEachBodyDo( m_world-&gt;getNewtonWorld(), newtonIterator );
-	}
-
-	//! get the singleton.
-	/*!
-		The body iterator is a singleton class, only one instance should exist per application.  you can perform many different
-		kinds of iterations by using different callback functions.
-	*/
-	static BodyIterator&amp; getSingleton()
-	{
-		static BodyIterator instance;
-		return instance;
-	}
-
-	//! destructor
-	~BodyIterator() {}
-
-protected:
-
-	BodyIterator()
-	{
-		m_world = NULL;
-		m_callback = NULL;
-	}
-
-	static void _CDECL newtonIterator( const NewtonBody* body )
-	{
-		OgreNewt::Body* bod = (OgreNewt::Body*)NewtonBodyGetUserData( body );
-
-		(*getSingleton().m_callback)( bod );
-	}
-
-	const OgreNewt::World*			m_world;
-	IteratorCallback				m_callback;
-    
-};
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif	// _INCLUDE_OGRENEWT_BODYITERATOR

Deleted: dependencies/OgreNewt/include/OgreNewt_Collision.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_Collision.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_Collision.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,118 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_COLLISION
-#define _INCLUDE_OGRENEWT_COLLISION
-
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-/*
-	CLASS DEFINITION:
-
-		Collision
-
-	USE:
-		this class represents a NewtonCollision, which is the newton structure
-		for collision geometry.
-*/
-//! represents a shape for collision detection
-class _OgreNewtExport Collision
-{
-public:
-
-	//! constructor
-	Collision( const World* world );
-
-	//! destructor
-	virtual ~Collision();
-
-	//! retrieve the Newton pointer
-	/*!
-		retrieves the pointer to the NewtonCollision object.
-	*/
-	const NewtonCollision* getNewtonCollision() const { return m_col; }
-
-  /*!
-    Returns the Newton world this collision belongs to.
-  */
-  const World* getWorld() const {return m_world;}
-
-	//! set a user ID for collision callback identification
-	/*!
-		you can set different IDs for each piece in a compound collision object, and then use these IDs in a collision callback to
-		determine which part is currently colliding.
-	*/
-	void setUserID( unsigned id ) const { NewtonConvexCollisionSetUserID( m_col, id); }
-
-	//! get user ID, for collision callback identification
-	unsigned getUserID() const { return NewtonConvexCollisionGetUserID( m_col ); }
-
-	//! get the Axis-Aligned Bounding Box for this collision shape.
-	Ogre::AxisAlignedBox getAABB( const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO ) const;
-
- protected:
-
-	NewtonCollision* m_col;
-	const World* m_world;
-
-};
-
-typedef Ogre::SharedPtr&lt;Collision&gt; CollisionPtr;
-
-//! represents a collision shape that is explicitly convex.
-class _OgreNewtExport ConvexCollision : public Collision
-{
-public:
-	//! constructor
-	ConvexCollision( const World* world );
-
-	//! destructor
-	~ConvexCollision();
-
-	//! calculate the volume of the collision shape, useful for buoyancy calculations.
-	Ogre::Real calculateVolume() const { return (Ogre::Real)NewtonConvexCollisionCalculateVolume( m_col ); }
-
-	//! calculate the moment of inertia for this collision primitive, along with the theoretical center-of-mass for this shape.
-	void calculateInertialMatrix( Ogre::Vector3&amp; inertia, Ogre::Vector3&amp; offset ) const { NewtonConvexCollisionCalculateInertialMatrix( m_col, &amp;inertia.x, &amp;offset.x ); }
-
-};
-
-
-
-//! represents a scalable collision shape.
-class _OgreNewtExport ConvexModifierCollision : public Collision
-{
-public:
-	//! constructor
-	ConvexModifierCollision( const OgreNewt::World* world, const CollisionPtr col );
-
-	//! destructor
-	~ConvexModifierCollision();
-
-	//! apply a scalar matrix to the collision
-	void setScalarMatrix( const Ogre::Matrix4&amp; mat ) const;
-
-	//! get the scalar matrix for the collision
-	Ogre::Matrix4 getScalarMatrix() const;
-
-};
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_COLLISION
-

Deleted: dependencies/OgreNewt/include/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_CollisionPrimitives.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_CollisionPrimitives.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,341 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
-#define _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
-
-#include &lt;OgreNewt_Prerequisites.h&gt;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Collision.h&quot;
-#include &quot;OgreNewt_TreeCollisionSerializer.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-	//! set of basic collision shapes
-	namespace CollisionPrimitives
-	{
-
-		//! null collision (results in no collision)
-		class _OgreNewtExport Null : public OgreNewt::Collision
-		{
-		public:
-			//! constructor
-			Null( const World* world );
-
-			//! destructor
-			~Null() {}
-		};
-
-
-		//! standard primitive Box.
-		class _OgreNewtExport Box : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				\param world pointer to OgreNewt::World
-				\param size vector representing width, height, depth
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Box( const World* world, const Ogre::Vector3&amp; size, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~Box() {}
-		};
-
-		//! standard primitive Ellipsoid.  
-		class _OgreNewtExport Ellipsoid : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				for a sphere, pass the same radius for all 3 axis.
-				\param world pointer to OgreNewt::World
-				\param size vector representing radius for all 3 axis
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Ellipsoid(const World* world, const Ogre::Vector3&amp; size, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~Ellipsoid() {}
-		};
-
-		//! standard primitive cylinder.
-		class _OgreNewtExport Cylinder : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the cylinder (Y and Z axis)
-				\param height height of the cylinder (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Cylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~Cylinder() {}
-		};
-
-		//! standard primitive capsule.
-		class _OgreNewtExport Capsule : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the capsule (Y and Z axis)
-				\param height height of the capsule (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Capsule( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~Capsule() {}
-		};
-
-		//! standard primitive cone.
-		class _OgreNewtExport Cone : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the cone (Y and Z axis)
-				\param height height of the cone (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Cone( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~Cone() {}
-		};
-
-		//! filled-donut shape primitive.
-		class _OgreNewtExport ChamferCylinder : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				default aligned along the local X axis (x=height).
-				\param world pointer to OgreNewt::World
-				\param radius radius of the chamfer cylinder (Y and Z axis)
-				\param height height of the chamfer cylinder (X axis)
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			ChamferCylinder( const World* world, Ogre::Real radius, Ogre::Real height, 
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~ChamferCylinder() {}
-		};	
-
-		//! ConvexHull primitive
-		/*!
-			 &quot;wrap&quot; around a set cloud of vertices.
-             A convex hull is the smallest possible convex shape
-             that fully encloses all points supplied.
-		 */
-		class _OgreNewtExport ConvexHull : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				Overloaded constructor.  pass a SceneNode*, 
-                and it will use the vertex data from the first attached object.
-				\param world pointer to the OgreNewt::World
-				\param entity pointer to an Ogre::Entity, if this is attached to an node, then
-				              the node's scale is applied
-                \param useTempBuffer determines whether to use the temporary blend buffer instead
-                                     of the mesh's vertex data. This is useful when you want
-                                     to create a collision from an intermediate animation state.
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			ConvexHull( const World* world, Ogre::Entity* entity, bool useTempBuffer = false,
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			/*!
-				Overloaded constructor.
-                pass a pointer to an array of vertices and the hull will be made from that.
-				\param world pointer to the OgreNewt::World
-				\param verts pointer to an array of Ogre::Vector3's that contain vertex position data
-				\param vertcount number ot vetices in the array
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount,
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY,
-                const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~ConvexHull() {}
-		};
-
-		
-
-
-
-		//! TreeCollision - complex polygonal collision
-		/*!
-			TreeCollision objects are general polygon collision objects.
-            TreeCollisio objects have a requirement that their mass must = 0 
-            (aka are have infinite mass)
-		*/
-		class _OgreNewtExport TreeCollision : public OgreNewt::Collision
-		{
-		public:
-      //! constructor
-      /*!
-        Create a 'blank' tree collision object to be used with
-        TreeCollisionSerializer::importTreeCollision
-        \param world pointer to the OgreNewt::World
-      */
-      TreeCollision( const World* world);
-
-			//! constructor
-			/*!
-				Create a tree collision object.
-				\param world pointer to the OgreNewt::World
-				\param entity pointer to an entity, if it is attached to a scenenode, then
-                              the node's scale is applied.
-                \param useTempBuffer determines whether to use the temporary blend buffer instead
-                                     of the mesh's vertex data. This is useful when you want
-                                     to create a collision from an intermediate animation state.
-				\param optimize bool whether you want to optimize the collision or not.
-			*/
-			TreeCollision( const World* world, Ogre::Entity* entity, bool optimize,
-                bool useTempBuffer = false);
-
-			//! constructor
-			/*!
-				build a TreeCollision from vertice and index information. 
-                This can be used with the dotScene scene manager
-				for building TreeCollision objects from each mesh in the scene.
-				\param world pointer to OgreNewt::World
-				\param numVertices number of vertices passed in the array.
-				\param numIndices number of indices passed in the array.
-				\param vertices pointer to array of vertices (positions only).
-				\param indices pointer to array of indices.
-				\param optimize bool whether you want to optimize the collision or not.
-			*/
-			TreeCollision( const World* world, int numVertices, int numIndices,
-                const float *vertices, const int *indices, bool optimize); 
-
-			//! constructor
-			/*!
-				build a TreeCollision from vertice and index information.
-                This can be used with the ogre Paging Landscape SceneManager,
-				or other custom solutions.
-				\param world pointer to OgreNewt::World
-				\param numVertices number of vertices in the array.
-				\param vertices pointer to array of Ogre::Vector3 vertices (positions only)
-				\param indexData pointer to Ogre::IndexData for the mesh
-				\param optimize bool whether you want to optimize the collision or not.
-			*/
-			TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices,
-                Ogre::IndexData* indexData, bool optimize);
-
-			//! destructor
-			~TreeCollision() {}
-
-      friend void TreeCollisionSerializer::exportTreeCollision(const TreeCollision* collision, const Ogre::String&amp; filename);
-      friend void TreeCollisionSerializer::importTreeCollision(Ogre::DataStreamPtr&amp; stream, TreeCollision* pDest);
-		};
-
-		////////////////////////////////////////////////////////
-		//	COMPOUND COLLISION!
-
-		//! create a compound from several collision pieces.
-		class _OgreNewtExport CompoundCollision : public OgreNewt::Collision
-		{
-		public:
-			//! constructor
-			/*!
-				creates a compound collision object made from an array of simple primitive parts.  can be used to make very complex
-				collision shapes.
-				\param world pointer to the OgreNewt::World
-				\param col_array std::vector of pointers to existing collision objects.
-			*/
-			CompoundCollision( const World* world, std::vector&lt;CollisionPtr&gt; col_array );
-
-			//! destructor
-			~CompoundCollision() {}
-		};
-
-
-		////////////////////////////////////////////////////////
-		// supplemental primitives built from convex hulls
-		////////////////////////////////////////////////////////
-
-		//! Pyramid primitive
-		/*!
-			4-sided base, comes to a single point. base is aligned on XZ plane. made from Convex Hull internally.  supplied as part of the
-			OgreNewt library, but not a built-in function of Newton istelf.
-		*/
-		class _OgreNewtExport Pyramid : public OgreNewt::ConvexCollision
-		{
-		public:
-			//! constructor
-			/*!
-				\param world pointer to the OgreNewt::World
-				\param size Ogre::Vector3 size.
-				\param orient orientation offset of the primitive
-				\param pos position offset of the primitive
-			*/
-			Pyramid( const World* world, const Ogre::Vector3&amp; size,
-				const Ogre::Quaternion&amp; orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3&amp; pos = Ogre::Vector3::ZERO );
-
-			//! destructor
-			~Pyramid() {}
-		};
-
-		//! Wraps another collision to let the user modify the hull via a world space scale matrix
-		class _OgreNewtExport HullModifier: public OgreNewt::Collision
-		{
-		public:
-			HullModifier( World* world, CollisionPtr wrappedCollision );	// constructor
-			~HullModifier() {};
-
-			//! scale matrix in world space
-			void setMatrix(const Ogre::Matrix4&amp; matrix);
-
-			//! scale matrix in world space
-			Ogre::Matrix4 getMatrix() const;
-		};	
-
-	}	// end namespace CollisionPrimitives
-
-}// end namespace OgreNewt
-
-#endif	// _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES

Deleted: dependencies/OgreNewt/include/OgreNewt_ContactCallback.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_ContactCallback.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_ContactCallback.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,148 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_CONTACTCALLBACK
-#define _INCLUDE_OGRENEWT_CONTACTCALLBACK
-
-#include &lt;OgreNewt_Prerequisites.h&gt;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_Body.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-//! custom contact behavior
-/*!
-	this class is for creating custom behavior between material GroupIDs.
-	this class must be inherited, and the user functions created, and then
-	added to a MaterialPair class.
-*/
-class _OgreNewtExport ContactCallback
-{
-public:
-
-	//! constructor
-	ContactCallback();
-
-	//! destructor
-	virtual ~ContactCallback();
-
-	// basic contact control commands...
-
-	//! disable the current contact.
-	void disableContact() const { NewtonMaterialDisableContact( m_material ); }
-
-	//! get the current physics timestep
-	Ogre::Real getCurrentTimestep() const { return (Ogre::Real)NewtonMaterialGetCurrentTimestep( m_material ); }
-
-	//! get the face ID of a TreeCollision object
-	unsigned getContactFaceAttribute() const { return NewtonMaterialGetContactFaceAttribute( m_material ); }
-
-	//! get the Collision ID of a body currently colliding
-	unsigned getBodyCollisionID( OgreNewt::Body* body ) const { return NewtonMaterialGetBodyCollisionID( m_material, body-&gt;getNewtonBody() ); }
-
-	//! speed of the collision
-	Ogre::Real getContactNormalSpeed() const { return (Ogre::Real)NewtonMaterialGetContactNormalSpeed( m_material, m_contact ); }
-
-	//! force of the collision
-	/*!
-		only valid for objects in a stable state (sitting on top of each other, etc)
-	*/
-	Ogre::Vector3 getContactForce() const;
-
-	//! get positoin and normal of the collision
-	void getContactPositionAndNormal( Ogre::Vector3&amp; pos, Ogre::Vector3&amp; norm ) const;
-
-	//! get the tangent vectors of the collision
-	void getContactTangentDirections( Ogre::Vector3&amp; dir0, Ogre::Vector3&amp; dir1 ) const;
-
-	//! get tangent speed of the collision
-	Ogre::Real getContactTangentSpeed( int index ) const { return (Ogre::Real)NewtonMaterialGetContactTangentSpeed( m_material, m_contact, index ); }
-
-	//! set softness of the current contact
-	void setContactSoftness( Ogre::Real softness ) const { NewtonMaterialSetContactSoftness( m_material, (float)softness ); }
-
-	//! set elasticity of the current contact
-	void setContactElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetContactElasticity( m_material, (float)elasticity ); }
-
-	//! set friction state of current contact
-	void setContactFrictionState( int state, int index ) const { NewtonMaterialSetContactFrictionState( m_material, state, index ); }
-
-	//! set static friction for current contact
-	void setContactStaticFrictionCoef( Ogre::Real coef, int index ) const { NewtonMaterialSetContactStaticFrictionCoef( m_material, (float)coef, index ); }
-
-	//! set kinetic friction for current contact
-	void setContactKineticFrictionCoef( Ogre::Real coef, int index ) const { NewtonMaterialSetContactKineticFrictionCoef( m_material, (float)coef, index ); }
-
-	//! set tangent acceleration for contact
-	void setContactTangentAcceleration( Ogre::Real accel, int index ) const { NewtonMaterialSetContactTangentAcceleration( m_material, (float)accel, index ); }
-
-	//! align tangent vectors with a user supplied direction
-	void rotateTangentDirections( const Ogre::Vector3&amp; dir ) const { NewtonMaterialContactRotateTangentDirections( m_material, &amp;dir.x ); }
-
-	//! manually set the normal for the collision.
-	void setContactNormalDirection( const Ogre::Vector3&amp; dir ) const { NewtonMaterialSetContactNormalDirection( m_material, &amp;dir.x ); }
-
-	//! manually set the acceleration along the collision normal.
-	void setContactNormalAcceleration( Ogre::Real accel ) const { NewtonMaterialSetContactNormalAcceleration( m_material, accel ); }
-
-
-
-	// user-defined callback function.
-	
-	//! user defined Begin function
-	/*!
-		this function is called when 2 bodies AABB overlap.  they have not yet collided, but *may* do so this loop.
-		at this point, m_body0 and m_body1 are defined, but the contact isn't yet valid, so none of the member functions
-		can be called yet.  they must be called from the userProcess() function.
-		return 0 to ignore the collision, 1 to allow it.
-	*/
-	virtual int userBegin() { return 1; }
-
-	//! user-defined Process function
-	/*!
-		user process function.  is called for each contact between the 2 bodies.  all member functions are valid from
-		within this function, and will affect the current contact.  return 0 to ignore the collision, 1 to allow it.
-	 */
-	virtual int userProcess() { return 1; }
-
-	//! user-defined End function
-	/*!
-		called after all contacts between the 2 bodies have been processed. no member functions should be called from within this
-		function either, as all contacts have been processed at this point.
-	*/
-	virtual void userEnd() {  }
-
-
-	//! internal function.
-	static int _CDECL contactBegin( const NewtonMaterial* material, const NewtonBody* body0, const NewtonBody* body1 );
-	//! internal function.
-	static int _CDECL contactProcess( const NewtonMaterial* material, const NewtonContact* contact );
-	//! internal function.
-	static void _CDECL contactEnd( const NewtonMaterial* material );
-
-
-protected:
-
-	NewtonMaterial* m_material;
-	NewtonContact* m_contact;
-
-	OgreNewt::Body* m_body0;
-	OgreNewt::Body* m_body1;
-};
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_CONTACTCALLBACK
-

Deleted: dependencies/OgreNewt/include/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_Debugger.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_Debugger.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,71 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_DEBUGGER
-#define _INCLUDE_OGRENEWT_DEBUGGER
-
-
-#include &lt;Ogre.h&gt;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-
-namespace OgreNewt
-{
-
-	//! For viewing the Newton rigid bodies visually.
-	/*!
-		This class implements a debug view of the Newton world.  it is a Singleton!
-		2 versions of this class exist; 1 which uses the Dagon ManualObject class to draw the lines (and is therefore only compatible with
-		Dagon branches of Ogre), and a second which uses the Line3D class previously released to the Ogre community.  the version that is
-		compiled is the Line3D class by default.  to use the ManualObject version, recompile OgreNewt_Main with the preprocessor definition
-		&quot;_OGRENEWT_DEBUGGER_DAGON&quot;.  this will change the class to use ManualObject internally.  this version has no extra dependencies.
-		However, the Line3D (default) version requires that you include Line3D.cpp into your project, as it is not compiled into OgreNewt_Main.
-		This file is included with OgreNewt, in the demos/Include folder.
-	*/
-	class _OgreNewtExport Debugger
-	{
-	
-	public:
-		~Debugger() {}
-
-		//! get the singleton reference
-		static Debugger&amp; getSingleton();
-
-		//! init the debugger.
-		/*
-			\param smgr pointer to your Ogre::SceneManager
-		*/
-		void init( Ogre::SceneManager* smgr );
-
-		//! show the newton world
-		/*!
-			Draws the Newton world as 3D lines.
-			\param world pointer to the OgreNewt::World
-		*/
-		void showLines( OgreNewt::World* world );
-
-		//! remove lines drawn.
-		void hideLines();
-	
-	protected:
-		Debugger();
-	
-	private:
-		Ogre::SceneNode*		m_debugnode;
-		Ogre::ManualObject*		m_debuglines;
-
-		static void _CDECL newtonPerBody( const NewtonBody* body );
-		static void _CDECL newtonPerPoly( const NewtonBody* body, int vertexCount, const float* faceVertec, int id );
-	};
-
-}	// end namespace OgreNewt
-
-
-#endif	// _INCLUDE_OGRENEWT_DEBUGGER

Deleted: dependencies/OgreNewt/include/OgreNewt_Joint.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_Joint.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_Joint.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,173 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_JOINT
-#define _INCLUDE_OGRENEWT_JOINT
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-//! base class for all joints.
-/*!
-	this class is inherited by all other specific joint types.
-*/
-class _OgreNewtExport Joint
-{
-public:
-
-	//! constructor
-	Joint();
-
-	//! destructor
-	virtual ~Joint();
-
-	//! returns collision state
-	/*!
-		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
-		\return integer value. 1 = collision on, 0 = collision off.
-	*/
-	int getCollisionState() const { return NewtonJointGetCollisionState( m_joint ); }
-
-	//! sets the collision state
-	/*!
-		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
-		\param state integer value. 1 = collision on, 0 = collision off.
-	*/		
-	void setCollisionState( int state ) const { NewtonJointSetCollisionState( m_joint, state ); }
-
-
-	//! get joint stiffness
-	/*!
-		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
-		\return float representing joint stiffness in range [0,1]
-	*/
-	Ogre::Real getStiffness() const { return (Ogre::Real)NewtonJointGetStiffness( m_joint ); }
-
-	//! set joint stiffness
-	/*!
-		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
-		\param stiffness float representing joint stiffness in range [0,1]
-	*/
-	void setStiffness( Ogre::Real stiffness ) const { NewtonJointSetStiffness( m_joint, stiffness ); }
-
-
-	//! set user data for this joint
-	/*!
-		user data can be used to connect this class to other user classes through the use of this general pointer.
-	*/
-	void setUserData( void* ptr ) { m_userdata = ptr; }
-
-	//! get user data for this joint
-	/*!
-		user data can be used to connect this class to other user classes through the use of this general pointer.
-	*/
-	void* getUserData() const { return m_userdata; }
-
-		
-protected:
-
-	NewtonJoint* m_joint;
-	const OgreNewt::World* m_world;
-
-	void* m_userdata;
-
-	static void _CDECL destructor( const NewtonJoint* me );
-
-};
-
-
-
-
-
-
-//! CustomJoint 
-/*!
-	this class represents a basic class for creating user-defined joints.  this class must be inherited to create discreet joints.
-*/
-class _OgreNewtExport CustomJoint : public Joint
-{
- 
-public:
-
-	//! constructor
-	CustomJoint( unsigned int maxDOF, const Body* body0, const Body* body1 );
-
-	//! destructor
-	virtual ~CustomJoint();
-
-	//! must be over-written for a functioning joint.
-	virtual void submitConstraint() = 0;
-
-
-	//! find the local orientation and position of the joint with regards to the 2 bodies in the joint.
-	void pinAndDirToLocal( const Ogre::Vector3&amp; pinpt, const Ogre::Vector3&amp; pindir, Ogre::Quaternion&amp; localOrient0, Ogre::Vector3&amp; localPos0, Ogre::Quaternion&amp; localOrient1, Ogre::Vector3&amp; localPos1 ) const;
-
-	//! find the global orientation and position of the joint with regards to the a body in the joint.
-	void localToGlobal( const Ogre::Quaternion&amp; localOrient, const Ogre::Vector3&amp; localPos, Ogre::Quaternion&amp; globalOrient, Ogre::Vector3&amp; globalPos, int bodyIndex = 0 ) const;
-
-	//! add a linear row to the constraint.
-	void addLinearRow( const Ogre::Vector3&amp; pt0, const Ogre::Vector3&amp; pt1, const Ogre::Vector3&amp; dir ) const;
-
-	//! add an angular row to the constraint.
-	void addAngularRow( Ogre::Radian relativeAngleError, const Ogre::Vector3&amp; dir ) const;
-
-	//! set the general jacobian rows directly.
-	void addGeneralRow( const Ogre::Vector3&amp; linear0, const Ogre::Vector3&amp; angular0, const Ogre::Vector3&amp; linear1, const Ogre::Vector3&amp; angular1 ) const;
-
-	//! set row minimum friction
-	void setRowMinimumFriction( Ogre::Real friction ) const;
-
-	//! set row maximum friction
-	void setRowMaximumFriction( Ogre::Real friction ) const;
-
-	//! set row acceleration
-	void setRowAcceleration( Ogre::Real accel ) const;
-
-	//! set row stiffness
-	void setRowStiffness( Ogre::Real stiffness ) const;
-
-	//! apply a spring to this row, allowing for joints with spring behaviour in 1 or more DoF's
-	/*!
-		\param springK float spring constant.
-		\param springD float natural rest state distance of the spring.
-	*/		
-	void setRowSpringDamper( Ogre::Real springK, Ogre::Real springD ) const;
-
-	//! retrieve the force acting on the current row.
-	Ogre::Real getRowForce( int row ) const { return NewtonUserJointGetRowForce( m_joint, row ); }
-
-	//! pin vector to arbitrary quaternion utility function.
-	Ogre::Quaternion grammSchmidt( const Ogre::Vector3&amp; pin ) const;
-
-protected:
-
-	unsigned int m_maxDOF;
-
-	const OgreNewt::Body* m_body0;
-	const OgreNewt::Body* m_body1;
-
-	//! newton callback.  used internally.
-	static void _CDECL newtonSubmitConstraint( const NewtonJoint* me );
-
-};
-
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_JOINT
-

Deleted: dependencies/OgreNewt/include/OgreNewt_MaterialID.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_MaterialID.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_MaterialID.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,59 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_MATERIALID
-#define _INCLUDE_OGRENEWT_MATERIALID
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-	class World;
-
-//! represents a material
-class _OgreNewtExport MaterialID
-{
-public:
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt;;World
-	*/
-	MaterialID( const World* world );
-
-	/*!
-		Overloaded constructor, sets the internal ID manually.  should not be used by the end-user.
-	*/
-	MaterialID( const World* world, int ID );
-
-	//! destructor
-	~MaterialID();
-
-	//! get Newton-assigned material ID.
-	int getID() const { return id; }
-
-protected:
-
-	int id;
-	const OgreNewt::World* m_world;
-
-};
-
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_MATERIALID
-

Deleted: dependencies/OgreNewt/include/OgreNewt_MaterialPair.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_MaterialPair.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_MaterialPair.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,91 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_MATERIALPAIR
-#define _INCLUDE_OGRENEWT_MATERIALPAIR
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_ContactCallback.h&quot;
-#include &quot;OgreNewt_MaterialID.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-//! define interaction between materials
-/*!
-	this class represents a pair of Newton MaterialGroupIDs, which is 
-	used to define interaction bewteen materials.
-*/
-class _OgreNewtExport MaterialPair
-{
-public:
-
-	//! constructor
-	/*!
-		creates an object representing a pair of materials, and defining how they will interact.
-		\param world pointer to the OgreNewt::World
-		\param mat1 pointer to first materialID
-		\param mat2 pointer to second materialID
-	*/
-	MaterialPair( const World* world, const MaterialID* mat1, const MaterialID* mat2 );
-
-	//! destructor
-	~MaterialPair();
-
-
-	// set the default behavior for this material pair.
-
-	//! set default softness for the material pair.
-	void setDefaultSoftness( Ogre::Real softness ) const { NewtonMaterialSetDefaultSoftness( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)softness ); }
-
-	//! set default elasticity for the material pair.
-	void setDefaultElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetDefaultElasticity( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)elasticity ); }
-
-	//! set default collision for the material pair.
-	void setDefaultCollidable( int state ) const { NewtonMaterialSetDefaultCollidable( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
-
-	//! set default friction for the material pair.
-	void setDefaultFriction( Ogre::Real stat, Ogre::Real kinetic ) const { NewtonMaterialSetDefaultFriction( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)stat, (float)kinetic ); }
-
-	//! set continuos collision on/off for this material pair
-	/*!
-		continuous collision mode is an advanced system used to prevent &quot;tunelling&quot;, or objects passing through one an other when traveling at high velocities.  
-		there is a performance hit involved, so this sould only be used when it is deemed necessary.
-	*/
-	void setContinuousCollisionMode( int state ) const { NewtonMaterialSetContinuousCollisionMode( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
-
-
-	//! assign a custom collision callback.
-	/*!
-		ContactCallbacks allow for custom interaction between bodies of specific materials.
-		\param callback pointer to a user-created ContactCallback object
-	*/
-	void setContactCallback( OgreNewt::ContactCallback* callback );
-
-
-
-protected:
-
-	const MaterialID*	id0;
-	const MaterialID*	id1;
-	const World*		m_world;
-
-};
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_MATERIALPAIR
-

Deleted: dependencies/OgreNewt/include/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_Prerequisites.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_Prerequisites.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,33 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-
-
-#ifndef __INCLUDE_OGRENEWT_PREREQ__
-#define __INCLUDE_OGRENEWT_PREREQ__
-
-#include &lt;Ogre.h&gt;
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-#   define _CDECL _cdecl
-#   if defined( _OGRENEWT_EXPORTS ) &amp;&amp; defined( _OGRENEWT_DYNAMIC )
-#       define _OgreNewtExport __declspec( dllexport )
-#   elif defined( _OGRENEWT_DYNAMIC )
-#       define _OgreNewtExport __declspec( dllimport )
-#   else
-#       define _OgreNewtExport
-#   endif
-#else // Linux / Mac OSX etc
-#   include &lt;stddef.h&gt;
-#   define _OgreNewtExport
-#   define _CDECL
-#endif
-
-#endif 

Deleted: dependencies/OgreNewt/include/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_RayCast.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_RayCast.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,123 +0,0 @@
-/* 
-	OgreNewt Library
-	Ogre implementation of Newton Game Dynamics SDK
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-		by Walaber
-*/
-
-#ifndef _INCLUDE_OGRENEWT_RAYCAST
-#define _INCLUDE_OGRENEWT_RAYCAST
-
-#include &lt;Ogre.h&gt;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-//! general raycast
-/*!
-	General class representing a raycast query in the Newton world.  this class should be inherited to create specific raycast behavior.
-*/
-class _OgreNewtExport Raycast
-{
-public:
-
-	//! constructor
-	Raycast();
-	
-	//! destuctor.
-	virtual ~Raycast();
-
-	//! performs the raycast.  
-	/*!
-		call after creating the object.
-		\param world pointer to the OgreNewt::World
-		\param startpt starting point of ray in global space
-		\param endpt ending point of ray in global space
-	*/
-	void go( const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt );
-
-	//! user callback filter function
-	/*! user callback function.  
-		This function must be implemented by the user.
-		Newton calls this function for each body intersected by the ray.  however it doesn't
-		necessarily go perfect cloest-to-farthest order.
-		return true and the callback will only be called for bodies closer to the start point than the current body.
-		return false and the callback will call for any other bodies, even those farther than the current one.
-	*/
-	virtual bool userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID ) = 0;
-
-private:
-
-	//! callback used for running the raycast itself... used internally
-	static float _CDECL newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersetParam);
-};
-
-//! Basic implementation of the raycast
-/*!
-	This class is provided for general raycast use.  it returns information about all bodies hit by the ray.
-*/
-class _OgreNewtExport BasicRaycast : public Raycast
-{
-public:
-	//! simple class that represents a single raycast rigid body intersection.
-	class _OgreNewtExport BasicRaycastInfo
-	{
-	public:
-		Ogre::Real		mDistance;	  //!&lt; dist from point1 of the raycast, in range [0,1].
-		OgreNewt::Body*	mBody;	      //!&lt; pointer to body intersected with
-		int				mCollisionID; //!&lt; collision ID of the primitive hit by the ray
-		Ogre::Vector3	mNormal;	  //!&lt; normal of intersection.
-
-        BasicRaycastInfo()
-            : mDistance(-1.0f), mBody(NULL), mCollisionID(0), mNormal(Ogre::Vector3::ZERO) {}
-
-        bool operator&lt;(const BasicRaycastInfo&amp; rhs) const
-        {
-            return mDistance &lt; rhs.mDistance;
-        }
-	};
-
-	//! constructor
-	/*!
-		performs a raycast, then the results can be queried from the object after creation.
-		\param world pointer to the OgreNewt::World
-		\param startpt starting point of the ray in global space
-		\param endpt ending point of the ray in global space
-	*/
-	BasicRaycast(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt,
-        const Ogre::Vector3&amp; endpt, bool sorted = false);
-	
-	//! destuctor.
-	virtual ~BasicRaycast();
-
-	//! the all-important custom callback function.
-	bool userCallback( Body* body, Ogre::Real distance,
-        const Ogre::Vector3&amp; normal, int collisionID );
-
-	// ------------------------------------------------------
-	// the following functions can be used to retrieve information about
-    // the bodies collided by the ray.
-	
-	//! how many bodies did we hit?
-	int getHitCount() const;
-
-	//! retrieve the raycast info for a specific hit.
-	BasicRaycastInfo getInfoAt( int hitnum ) const;
-
-	//! get the closest body hit by the ray.
-	BasicRaycastInfo getFirstHit() const;
-
-private:
-
-	// container for results.
-	typedef std::vector&lt;BasicRaycastInfo&gt; RaycastInfoList;
-
-	RaycastInfoList mRayList;
-};
-
-}	// end NAMESPACE OgreNewt
-
-#endif	// _INCLUDE_OGRENEWT_RAYCAST

Deleted: dependencies/OgreNewt/include/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_Tools.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_Tools.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,195 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_TOOLS
-#define _INCLUDE_OGRENEWT_TOOLS
-
-
-#include &lt;Ogre.h&gt;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Collision.h&quot;
-using namespace Ogre;
-
-namespace OgreNewt
-{
-
-	//! set of handy convertors.
-	namespace Converters
-	{
-		//! Take a Newton matrix and create a Quaternion + Position_vector
-		/*!
-			\param matrix input newton matrix (float[16])
-			\param quat returned quaternion
-			\param pos returned position vector
-		*/
-		_OgreNewtExport void MatrixToQuatPos( const float* matrix, Quaternion&amp; quat, Vector3 &amp;pos );
-	
-
-		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
-		/*!
-			\param quat input quaternion
-			\param pos input position vector
-			\param matrix returned matrix (float[16])
-		*/
-		_OgreNewtExport void QuatPosToMatrix( const Quaternion&amp; quat, const Vector3 &amp;pos, float* matrix );
-
-		//! Take a Newton matrix and make it into an Ogre::Matrix4.
-		/*!
-			\param matrix_in input matrix from Newton (float[16])
-			\param matrix_out output Ogre::Matrix4 object.
-		*/
-		_OgreNewtExport void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4&amp; matrix_out );
-
-		//! Take an Ogre::Matrix4 and make it into a Newton-happy matrix.
-		/*!
-			\param matrix_in Ogre::Matrix4 to be converted.
-			\param matrix_out Newton-happy output matrix (float[16])
-		*/
-		_OgreNewtExport void Matrix4ToMatrix( const Ogre::Matrix4&amp; matrix_in, float* matrix_out );
-	}
-
-	//! low-level collision commands.
-	namespace CollisionTools
-	{
-
-		//! find the point on a collision primitive closest to a global point.
-		/*!
-			\param world pointer to world
-			\param globalpt point to check distance from.
-			\param col collision primitive pointer
-			\param colorient orientation of the collision primitive
-			\param colpos position of the collision primitive
-			\param retpos returned position on the collision primitive in global space
-			\param retnormal returned normal on the collision primitive in global space
-		*/
-		_OgreNewtExport int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3&amp; globalpt, 
-									CollisionPtr col, const Ogre::Quaternion&amp; colorient, const Ogre::Vector3&amp; colpos, 
-									Ogre::Vector3&amp; retpt, Ogre::Vector3&amp; retnormal );
-									
-
-
-		//! find the nearest 2 points between 2 collision shapes.
-		/*!
-			\param world pointer to world
-			\param colA pointer to collision primitive A
-			\param colOrientA orientation of collision primitive A
-			\param colPosA position of collision primitive A
-			\param colB pointer to collision primitive B
-			\param colOrientB orientation of collision primitive B
-			\param colPosB position of collision primitive B
-			\param retPosA returned position on collision primitive A
-			\param retPosB returned position on collision primitive B
-			\param retNorm returned collision normal
-		*/
-		_OgreNewtExport int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::CollisionPtr colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-															CollisionPtr colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-															Ogre::Vector3&amp; retPosA, Ogre::Vector3&amp; retPosB, Ogre::Vector3&amp; retNorm );
-
-
-		//! manual collision between collision primitives.
-		/*!
-			This function allows you to perform a manual collision check on 2 collision primitives.
-			the function returns the number of contacts found.
-			\param world pointer to world
-			\param maxSize max number of contact points you can receive
-			\param colA pointer to Collision primitive A
-			\param colOrientA orientation of collision primitive A
-			\param colPosA position of collision primitive A
-			\param colB pointer to collision primitive B
-			\param colOrientB orientation of collision orimitive B
-			\param colPosB position of collision primitive B
-			\param retContactPts returned array of contact points
-			\param retNormals returned normals for each contact
-			\param retPenetrations returned penetrations for each contact.
-		*/
-		_OgreNewtExport int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
-			CollisionPtr colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-			CollisionPtr colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-			Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations );
-
-
-		//! manual collision between moving primitives.
-		/*!
-			This is the most advanced collision function, that takes 2 primitives with velocities and omegas,
-			and calculates if the will contact with each other over a set timestep.
-			\param world pointer to world
-			\param maxSize max number of contact points you can receive
-			\param colA pointer to Collision primitive A
-			\param colOrientA orientation of collision primitive A
-			\param colPosA position of collision primitive A
-			\param colVelA velocity of collision primitive A
-			\param colOmegaA omega of collision primitive A
-			\param colB pointer to collision primitive B
-			\param colOrientB orientation of collision orimitive B
-			\param colPosB position of collision primitive B
-			\param colVelB velocity of collision primitive B
-			\param colOmegaB omega of collision primitive B
-			\param retTimeOfImpact time of collision
-			\param retContactPts returned array of contact points
-			\param retNormals returned normals for each contact
-			\param retPenetrations returned penetrations for each contact.
-		*/
-		_OgreNewtExport int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
-			const CollisionPtr colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA, const Ogre::Vector3&amp; colVelA, const Ogre::Vector3&amp; colOmegaA,
-			const CollisionPtr colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB, const Ogre::Vector3&amp; colVelB, const Ogre::Vector3&amp; colOmegaB,
-			Ogre::Real&amp; retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations );
-
-
-		//! local raycast on a collision object.
-		/*!
-			This function performs a local raycast on a single collision primitive shape.  the function returns the distance to the
-			point of intersection as a scalar between [0,1].
-			\param col pointer to collision shape on which to cast the ray
-			\param startPt starting point of the ray, in local space of the collision shape
-			\param endPt end point of the ray, in local space of the collision shape
-			\param normal returned normal where the ray hit the collision.
-			\param colID returned ID of the collision primitive hit.
-		*/
-		_OgreNewtExport Ogre::Real CollisionRayCast( CollisionPtr col, const Ogre::Vector3&amp; startPt, const Ogre::Vector3&amp; endPt, 
-														Ogre::Vector3&amp; retNorm, int&amp; retColID );
-				
-
-		//! calculate the AABB of a collision primitive in an arbitrary orientation
-		/*!
-			Calculates the global AABB of a collision primitive in world space, given an orientation and position.
-			\param col collision shape to calculate.
-			\param orient world orientation of the collision.
-			\param pos world position of the collision.
-		*/
-		_OgreNewtExport Ogre::AxisAlignedBox CollisionCalculateAABB( CollisionPtr col, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos );
-
-	}	// end namespace &quot;ColliionTools&quot;
-
-
-	//! calculators of MomentOfInertia
-	namespace MomentOfInertia
-	{
-
-		//! calculate moment of inertia for a solid ellipsoid
-		_OgreNewtExport Ogre::Vector3 CalcEllipsoidSolid( Ogre::Real mass, const Ogre::Vector3&amp; size );
-
-		//! calculate moment of inertia for a solid sphere
-		_OgreNewtExport Ogre::Vector3 CalcSphereSolid( Ogre::Real mass, Ogre::Real radius );
-
-		//! calculate moment of inertia for a hollow sphere
-		_OgreNewtExport Ogre::Vector3 CalcSphereHollor(Ogre::Real mass, Ogre::Real radius );
-		
-		//! calculate moment of inertia for a solid box
-		_OgreNewtExport Ogre::Vector3 CalcBoxSolid(Ogre::Real mass, const Ogre::Vector3&amp; size );
-
-		//! calculate moment of inertia for a solid cylinder
-		_OgreNewtExport Ogre::Vector3 CalcCylinderSolid(Ogre::Real mass, Ogre::Real radius, Ogre::Real height );
-		
-	}
-
-}	// end NAMESPACE OgreNewt
-
-#endif

Deleted: dependencies/OgreNewt/include/OgreNewt_TreeCollisionSerializer.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_TreeCollisionSerializer.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_TreeCollisionSerializer.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,70 +0,0 @@
-/* 
-OgreNewt Library
-
-Ogre implementation of Newton Game Dynamics SDK
-
-OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
-#define _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreSerializer.h&quot;
-#include &quot;OgreString.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-  namespace CollisionPrimitives
-  {
-    class TreeCollision;
-  }
-
-  /*!
-  This class can be used to (de)serialize a TreeCollision. Pre-building a TreeCollision and serializing from a tool,
-  then deserializing it at runtime may be more efficient than building the TreeCollision on the fly, especially for complex objects.
-  */
-  class _OgreNewtExport TreeCollisionSerializer : public Ogre::Serializer
-  {
-  public:
-
-    //! constructor
-    TreeCollisionSerializer();
-
-    //! destructor
-    virtual ~TreeCollisionSerializer();
-
-    /*!
-    Serialize the TreeCollision to a file with the given name.
-    */
-    void exportTreeCollision(const CollisionPrimitives::TreeCollision* collision, const Ogre::String&amp; filename);
-
-    /*!
-    Deserialize the TreeCollision from a DataStream.
-    */
-    void importTreeCollision(Ogre::DataStreamPtr&amp; stream, CollisionPrimitives::TreeCollision* pDest);
-
-    /*!
-    Callback function for Newton. It should never be called directly, but will be called by Newton to save the TreeCollision to a stream.
-    (Newton calls this function several times for each serialization, once for each chunk of its file format apparently)
-    */
-    static void _CDECL _newtonSerializeCallback(void* serializeHandle, const void* buffer, size_t size);
-
-    /*!
-    Callback function for Newton. It should never be called directly, but will be called by Newton to load the TreeCollision from a stream.
-    (Newton calls this function several times for each deserialization, once for each chunk of its file format apparently)
-    */
-    static void _CDECL _newtonDeserializeCallback(void* deserializeHandle, void* buffer, size_t size);
-  };
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
-

Deleted: dependencies/OgreNewt/include/OgreNewt_Vehicle.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_Vehicle.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_Vehicle.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,217 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_VEHICLE
-#define _INCLUDE_OGRENEWT_VEHICLE
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_Body.h&quot;
-#include &quot;OgreNewt_Joint.h&quot;
-#include &quot;OgreNewt_World.h&quot;
-
-namespace OgreNewt
-{
-
-//! Represents a wheeled vehicle
-/*!
-	this class represents a basic vehicle, meant to be inherited by the user, with functionality added.
-*/
-	class _OgreNewtExport Vehicle
-	{
-	public:
-
-		//! basic vehicle tire.
-		/*!
-			secondary class: Tire.  this represents a basic tire.  you add tires by simply creating new tire objects, they are attached to the vehicle object you pass to the constructor.
-		*/
-		class _OgreNewtExport Tire
-		{
-		public:
-			//! overloaded constructor.
-			/*
-				this is the all-important constructor.
-				\param vehicle the parent vehicle to which you want to add this tire.
-				\param localorient local orientation of the tire (in the space of the chassis rigid body)
-				\param localpos local orientation of the tire (in the space of the chassis rigid body)
-				\param pin direction of the pin (axle) in the space of the tire
-				\param mass mass of the tire
-				\param width width of the tire
-				\param radius radis of the tire
-				\param susShock spring damper coefficient
-				\param susSpring spring strength
-				\param susLength spring length
-				\param colID collision ID used to determine collision in material callbacks.
-			*/
-			Tire( OgreNewt::Vehicle* vehicle, Ogre::Quaternion localorient, Ogre::Vector3 localpos, Ogre::Vector3 pin,
-				Ogre::Real mass, Ogre::Real width, Ogre::Real radius, Ogre::Real susShock, Ogre::Real susSpring, Ogre::Real susLength, int colID = 0);
-
-			//! destructor.
-			virtual ~Tire();
-
-			//! attach a scenenode to the tire!
-			void attachToNode( Ogre::SceneNode* node ) { m_node = node; }
-
-			//! update the position of the tire.  this must be called to update the attached scene node to the position of the tire!
-			void updateNode();
-
-			//! get the Newton ID for this tire.
-			const void* getNewtonID() const { return m_tireid; }
-
-			//! get the parent vehicle.
-			OgreNewt::Vehicle* getVehicle() const { return m_vehicle; }
-
-			//! get Ogre::SceneNode.
-			Ogre::SceneNode* getOgreNode() const { return m_node; }
-
-			//////////////////////////////////////////////////////////////////////
-			// Newton functions
-			
-			//! is the tire airborne?
-			int isAirBorne() const { return NewtonVehicleTireIsAirBorne( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! has the tire lost side grip?
-			int lostSideGrip() const { return NewtonVehicleTireLostSideGrip( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! has the tire lost traction?
-			int lostTraction() const { return NewtonVehicleTireLostTraction( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the rotational velocity of the tire
-			Ogre::Real getOmega() const { return (Ogre::Real)NewtonVehicleGetTireOmega( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the load on the tire (along the suspension normal )
-			Ogre::Real getNormalLoad() const { return (Ogre::Real)NewtonVehicleGetTireNormalLoad( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the current steering angle for this tire
-			Ogre::Radian getSteeringAngle() const { return Ogre::Radian( NewtonVehicleGetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid ) ); }
-
-			//! get the lateral speed of the tire (sideways)
-			Ogre::Real getLateralSpeed() const { return NewtonVehicleGetTireLateralSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the longitudinal speed of the tire (forward/backward)
-			Ogre::Real getLongitudinalSpeed() const { return NewtonVehicleGetTireLongitudinalSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the location and orientation of the tire (in global space).
-			void getPositionOrientation( Ogre::Quaternion&amp; orient, Ogre::Vector3&amp; pos );
-
-			//! set the torque for this tire.  this must be called in the tire callback!
-			void setTorque( Ogre::Real torque ) const { NewtonVehicleSetTireTorque( m_vehicle-&gt;getNewtonVehicle(), m_tireid, torque ); }
-
-			//! set the steering angle for the tire.  this must be called in the tire callback.
-			void setSteeringAngle( Ogre::Radian angle ) const { NewtonVehicleSetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid, angle.valueRadians() ); }
-
-			//! calculate the max brake acceleration to stop the tires.
-			Ogre::Real calculateMaxBrakeAcceleration() const { return (Ogre::Real)NewtonVehicleTireCalculateMaxBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! set the brake acceleration
-			void setBrakeAcceleration( Ogre::Real accel, Ogre::Real limit ) const { NewtonVehicleTireSetBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)accel, (float)limit ); }
-
-			//! max side slip speed
-			void setMaxSideSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxSideSleepSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
-
-			//! set side slip coefficient
-			void setSideSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireSideSleepCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
-
-			//! max longitudinal slip speed
-			void setMaxLongitudinalSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxLongitudinalSlideSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
-
-			//! set longitudinal slip coefficient
-			void setLongitudinalSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireLongitudinalSlideCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
-
-
-
-
-		protected:
-			OgreNewt::Vehicle* m_vehicle;
-			void* m_tireid;
-
-			Ogre::SceneNode* m_node;
-
-		};
-
-
-		//! constructor
-		Vehicle() { m_vehicle = NULL; }
-
-		//! destructor
-		virtual ~Vehicle();
-
-		//! initialize the vehicle
-		/*!
-			this function should be called to initialize the vehicle, assigning it's main chassis rigid body.  the function
-			also calls the virtual function &quot;setup&quot; which the user should implement to add tires to the vehicle.
-			\param chassis pointer to the OgreNewt::Body to use as the chassis.
-			\param updir unit vector signifying which direction is &quot;up&quot; in your world.  used for suspension.
-		*/
-		void init( OgreNewt::Body* chassis, const Ogre::Vector3&amp; updir );
-
-		//! destroy the vehicle, including chassis Body.
-		void destroy();	
-
-		//! setup the tires.
-		/*!
-			this is a virtual function that must be implemented by the user.  you should add and balance all tires in this function.
-		*/
-		virtual void setup() = 0;
-
-		//! user callback for controlling the vehicle
-		/*!
-			callback called each frame.  inside this callback you can add torque and steering to the tires to control the vehicle.
-		*/
-		virtual void userCallback() {}
-
-		//! get the chassis body.
-		OgreNewt::Body* getChassisBody() const { return m_chassis; }
-
-		//! get the NewtonJoint for the vehicle.
-		NewtonJoint* getNewtonVehicle()  const { return m_vehicle; }
-
-		//////////////////////////////////////////////////////////////
-		// Newton Vehicle functions.
-
-		//! reset the vehicle (stop all tires)
-		void reset() const { NewtonVehicleReset( m_vehicle ); }
-
-		//! get a pointer to the first tire
-		/*!
-			This can be used with the getNextTire function to iterate through all tires in the vehicle.  see examples for more info.
-			should only be called from inside the userCallback() function.
-		*/
-		const OgreNewt::Vehicle::Tire* getFirstTire() const;
-
-		//! get a pointer to the next tire in the vehicle.
-		/*!
-			This can be used with the getFirstTire function to iterate through all tires in the vehicle.  see examples for more info.
-			should only be called from inside the userCallback() function.
-		*/
-		const OgreNewt::Vehicle::Tire* getNextTire( OgreNewt::Vehicle::Tire* current_tire ) const;
-
-
-	protected:
-
-		OgreNewt::Body* m_chassis;
-
-	private:
-		//! callback for newton... it calls the userCallback() function for you.
-		static void _CDECL newtonCallback( const NewtonJoint* me );
-
-		static void _CDECL newtonDestructor( const NewtonJoint* me );
-
-		NewtonJoint* m_vehicle;
-		
-
-	};
-
-
-
-}	// end NAMESPACE OgreNewt
-
-
-#endif	// _INCLUDE_OGRENEWT_VEHICLE

Deleted: dependencies/OgreNewt/include/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt_World.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/OgreNewt_World.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,178 +0,0 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-*/
-#ifndef _INCLUDE_OGRENEWT_WORLD
-#define _INCLUDE_OGRENEWT_WORLD
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &lt;Ogre.h&gt;
-#include &quot;OgreNewt_MaterialID.h&quot;
-#include &quot;FastDelegate.h&quot;
-
-//! main namespace.
-/*!
-	This is the main namespace for the OgreNewt library.  all classes are included in this namespace.
-*/
-namespace OgreNewt
-{
-
-
-class MaterialID;
-class Body;
-
-//! represents a physics world.
-/*!
-	this class represents a NewtonWorld, which is the basic space in which physics elements can exist.  It can have various Rigid Bodies, connected by joints, and other constraints.
-*/
-class _OgreNewtExport World
-{
-
-public:
-
-	//! physics solver mode.
-	/*!
-		you can adjust the accuracy of the solver (and therefore the speed of the solver) using these, or a simple int &gt;= 2.  a value &gt;= 2 represents the number of passes you want the engine to take when attempting to reconcile joints.
-	*/
-	enum SolverModelMode 
-	{ 
-		SM_EXACT,	/*!&lt; the most accurate simulation. */
-		SM_ADAPTIVE	/*!&lt; still accurate, but faster. */
-	};
-
-	//! friction solver mode.
-	/*!
-		like the physics solver mode, these options allow you to reduce the accuracy of the friction model in exchange for speed.
-	*/
-	enum FrictionModelMode 
-	{ 
-		FM_EXACT,	/*!&lt; exact friction model (default). */
-		FM_ADAPTIVE	/*!&lt; adaptive friction mode. (faster but less accurate) */
-	};
-
-	//! leave world callback.
-	/*!
-		this function is called when a body leaves the OgreNewt::World.  you can use this to destroy bodies that have left the scene,
-		or re-position them, reflect them, do whatever you want.
-
-		callback binding to member classes is exactly the same as the various callbacks for the Body class.
-	*/
-	typedef fastdelegate::FastDelegate1&lt; OgreNewt::Body* &gt; LeaveWorldCallback;
-
-public:
-	//! Standard Constructor, creates the world.
-	World();
-
-	//! Standard Destructor, destroys the world.
-	~World();		
-
-	//! update the world by the specified time_step.
-	/*!
-		this function is clamped between values representing fps [60,600].  if you pass a smaller value, it is internally clamped to 60fps.  likewise a value higher than 600fps is treated as 600fs.
-
-		\param t_step Real value representing the time elapsed in seconds.
-	*/
-	void update( Ogre::Real t_step );	
-
-	//! retrieves a pointer to the NewtonWorld
-	/*!
-		in most cases you shouldn't need this... but in case you want to implement something not yet in the library, you can use this to get a pointer to the NewtonWorld object.
-		\return pointer to NewtonWorld
-	*/
-	const NewtonWorld* getNewtonWorld() const { return m_world; }
-
-	//! get the default materialID object.
-	/*!
-		when you create a world, a default material is created, which is by default applied to all new rigid bodies.  you might need this pointer when assigning material callbacks, etc.
-		\return pointer to a MaterialID* representing the default material.
-	*/
-	const MaterialID* getDefaultMaterialID() const { return m_defaultMatID; }	// get pointer to default material ID object.
-
-	//! remove all bodies from the world.
-	/*!
-		destroys all Rigid Bodies and Joints in the world. the bodies are properly deleted, so don't try and access any pointers you have laying around!
-	*/
-	void destroyAllBodies() { NewtonDestroyAllBodies( m_world ); }
-
-	//! set the physics solver model
-	/*!
-		setting the solver model allows sacrificing accuracy and realism for speed, good for games, etc.  for a more detailed description of how to use this function, see the Newton documentation.
-		\param model int representing the physics model.  you can also pass the enum values I've included.
-		\sa SolverModelMode
-	*/
-	void setSolverModel( int model ) { NewtonSetSolverModel( m_world, model ); }
-
-	//! set the physics friction model
-	/*!
-		setting the friction model allows sacrificing accuracy and realism for speed, good for games, etc. for a more detailed description of how to use this function, see the Newton documentation.
-		\param model int representing friction model.  you can also pass the enum values I've included.
-		\sa FrictionModelMode
-	*/
-	void setFrictionModel( int model) { NewtonSetFrictionModel( m_world, model ); }
-
-	//! specify a specific architecture to use for physics calculations.
-	/*!
-		Setting to a specific architecture can allow for deterministic physics calculations on systems with different cpus,
-		which is particularly useful for multiplayer systems where deterministic physics are absolutely vital.
-	*/
-	void setPlatformArchitecture( int mode ) { NewtonSetPlatformArchitecture( m_world, mode ); }
-
-	//! get the current physics timestep
-	/*!
-		you can use this function to retrieve the current timestep for the physics.  for example you can use this inside a callback to retrieve the current physics timestep.
-		\return real representing the timestep in seconds
-	*/
-	Ogre::Real getTimeStep() const;
-
-	//! set minimum framerate
-	void setMinimumFrameRate( Ogre::Real frame ) { NewtonSetMinimumFrameRate( m_world, frame ); }
-
-	//! set the newton world size
-	/*!
-		setting the world size is very important for a efficient simulation.  although basic collisions will work outside the world limits, other things like raycasting will not work outside the world limits.
-		\param min minimum point of the world.
-		\param max maximum point of the world.
-	*/
-	void setWorldSize( const Ogre::Vector3&amp; min, const Ogre::Vector3&amp; max );
-
-	/*!
-		\param box bos describing the size of the world.
-	*/
-	void setWorldSize( const Ogre::AxisAlignedBox&amp; box );
-
-	//! get the Newton SDK version.
-	int getVersion() const { return NewtonWorldGetVersion( m_world ); }
-
-	//! set the leave world callback
-	/*!
-		sets the callback to be used when a Body leaves the World limits.
-	*/
-	void setLeaveWorldCallback( LeaveWorldCallback callback );
-
-
-protected:
-	
-	NewtonWorld* m_world;
-	MaterialID* m_defaultMatID;
-
-	LeaveWorldCallback m_leaveCallback;
-
-private:
-
-	static void _CDECL newtonLeaveWorld( const NewtonBody* body );
-
-};
-
-}
-
-	
-#endif
-// _INCLUDE_OGRENEWT_WORLD
-
-

Deleted: dependencies/OgreNewt/include/line3D.h
===================================================================
--- dependencies/OgreNewt/include/line3D.h	2007-01-08 12:45:11 UTC (rev 2944)
+++ dependencies/OgreNewt/include/line3D.h	2007-01-08 12:46:19 UTC (rev 2945)
@@ -1,37 +0,0 @@
-#ifndef __LINE3D_H__
-#define __LINE3D_H__
-
-#include &quot;Ogre.h&quot;
-#include &lt;vector&gt;
-
-using namespace Ogre;
-using namespace std;
-
-#define POSITION_BINDING 0
-#define TEXCOORD_BINDING 1
-
-class Line3D:public SimpleRenderable
-{
-public:
-   Line3D(void);
-   ~Line3D(void);
-
-   void addPoint(const Vector3 &amp;p);
-   const Vector3 &amp;getPoint(unsigned short index) const;
-   unsigned short getNumPoints(void) const;
-   void updatePoint(unsigned short index, const Vector3 &amp;value);
-   void drawLine(Vector3 &amp;start, Vector3 &amp;end);
-   void drawLines(void);
-
-   Real getSquaredViewDepth(const Camera *cam) const;
-   Real getBoundingRadius(void) const;
-protected:
-   //void getWorldTransforms(Matrix4 *xform) const;
-   const Quaternion &amp;getWorldOrientation(void) const;
-   const Vector3 &amp;getWorldPosition(void) const;
-
-   vector&lt;Vector3&gt; mPoints;
-   bool mDrawn;
-};
-
-#endif /* __LINE3D_H__ */ 
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000015.html">[Dsa-hl-svn] r2944 - in dependencies/OgreNewt: . include src
</A></li>
	<LI>Next message: <A HREF="000017.html">[Dsa-hl-svn] r2946 - rl/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16">[ date ]</a>
              <a href="thread.html#16">[ thread ]</a>
              <a href="subject.html#16">[ subject ]</a>
              <a href="author.html#16">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
