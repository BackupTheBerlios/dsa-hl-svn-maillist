<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4546 - in rl/branches/persistence: ai/include ai/src	core/include core/src rules/include rules/src script/src	script/swig ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4546%20-%20in%20rl/branches/persistence%3A%20ai/include%20ai/src%0A%09core/include%20core/src%20rules/include%20rules/src%20script/src%0A%09script/swig%20ui/src&In-Reply-To=%3C200810121214.m9CCEuV5030783%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001602.html">
   <LINK REL="Next"  HREF="001604.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4546 - in rl/branches/persistence: ai/include ai/src	core/include core/src rules/include rules/src script/src	script/swig ui/src</H1>
    <B>timm at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4546%20-%20in%20rl/branches/persistence%3A%20ai/include%20ai/src%0A%09core/include%20core/src%20rules/include%20rules/src%20script/src%0A%09script/swig%20ui/src&In-Reply-To=%3C200810121214.m9CCEuV5030783%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4546 - in rl/branches/persistence: ai/include ai/src	core/include core/src rules/include rules/src script/src	script/swig ui/src">timm at mail.berlios.de
       </A><BR>
    <I>Sun Oct 12 14:14:56 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001602.html">[Dsa-hl-svn] r4545 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
        <LI>Next message: <A HREF="001604.html">[Dsa-hl-svn] r4547 - in rl/branches/persistence: rules/include	rules/src script/src script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1603">[ date ]</a>
              <a href="thread.html#1603">[ thread ]</a>
              <a href="subject.html#1603">[ subject ]</a>
              <a href="author.html#1603">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: timm
Date: 2008-10-12 14:14:27 +0200 (Sun, 12 Oct 2008)
New Revision: 4546

Modified:
   rl/branches/persistence/ai/include/CreatureWalkPathJob.h
   rl/branches/persistence/ai/src/CreatureWalkPathJob.cpp
   rl/branches/persistence/core/include/Job.h
   rl/branches/persistence/core/include/JobQueue.h
   rl/branches/persistence/core/include/MessagePump.h
   rl/branches/persistence/core/include/PlayAnimationJob.h
   rl/branches/persistence/core/include/StartAnimationJob.h
   rl/branches/persistence/core/src/Job.cpp
   rl/branches/persistence/core/src/JobQueue.cpp
   rl/branches/persistence/core/src/MessagePump.cpp
   rl/branches/persistence/core/src/PlayAnimationJob.cpp
   rl/branches/persistence/core/src/PlaySoundJob.cpp
   rl/branches/persistence/core/src/SaveAbleFactory.cpp
   rl/branches/persistence/core/src/SoundFadeJob.cpp
   rl/branches/persistence/core/src/StartAnimationJob.cpp
   rl/branches/persistence/rules/include/FetchItemJob.h
   rl/branches/persistence/rules/include/GoToJob.h
   rl/branches/persistence/rules/include/WaitJob.h
   rl/branches/persistence/rules/src/ApplyDamageJob.cpp
   rl/branches/persistence/rules/src/Combat.cpp
   rl/branches/persistence/rules/src/Combatant.cpp
   rl/branches/persistence/rules/src/FetchItemJob.cpp
   rl/branches/persistence/rules/src/GoToJob.cpp
   rl/branches/persistence/rules/src/WaitJob.cpp
   rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp
   rl/branches/persistence/script/swig/RlAi.swig
   rl/branches/persistence/script/swig/RlCore.swig
   rl/branches/persistence/script/swig/RlRules.swig
   rl/branches/persistence/ui/src/InputManager.cpp
   rl/branches/persistence/ui/src/UiSubsystem.cpp
   rl/branches/persistence/ui/src/WindowFadeJob.cpp
Log:
- merged trunk with branch
- making jobs semi-persistent
- making it compile
- modules in trunk doesn't work anymore
- first success in loading game objects

Modified: rl/branches/persistence/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/branches/persistence/ai/include/CreatureWalkPathJob.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/ai/include/CreatureWalkPathJob.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -41,7 +41,7 @@
         * @param movingCreature the job has to know a moving creature
         * @param startLandmark first landmark, the moving creature has to go to
         */
-        CreatureWalkPathJob(const Ogre::String&amp; name, Creature* movingCreature, Landmark* startLandmark);
+        CreatureWalkPathJob(const CeGuiString &amp;id, const Ogre::String&amp; name, Creature* movingCreature, Landmark* startLandmark);
         //destructor
         virtual ~CreatureWalkPathJob();
 

Modified: rl/branches/persistence/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/branches/persistence/ai/src/CreatureWalkPathJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/ai/src/CreatureWalkPathJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -28,8 +28,8 @@
     const CeGuiString CreatureWalkPathJob::PROPERTY_NEXTLANDMARKS = &quot;nextlandmarks&quot;;
     const CeGuiString CreatureWalkPathJob::PROPERTY_GAMEOBJECTID = &quot;go_id&quot;;
 
-    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String&amp; name, Creature* movingCreature, Landmark* startLandmark)
-        : Job(false, true, TimeSource::GAMETIME, Job::PERSISTENT), 
+    CreatureWalkPathJob::CreatureWalkPathJob(const CeGuiString &amp;id, const Ogre::String&amp; name, Creature* movingCreature, Landmark* startLandmark)
+        : Job(id, false, true, TimeSource::GAMETIME, Job::PERSISTENT), 
         mLandmarkPath(&quot;LandmarkPath&quot; + name), 
         mWayPoints(NULL),
         mUpdatedDirection(false),

Modified: rl/branches/persistence/core/include/Job.h
===================================================================
--- rl/branches/persistence/core/include/Job.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/include/Job.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -121,7 +121,7 @@
          *         Job, after execution is finished. This should usually be the case, but
          *         sometimes it is sensible to pool a number of Jobs for reuse.
          */
-        Job(bool isDiscardable, 
+        Job(const CeGuiString &amp;id, bool isDiscardable, 
             bool destroyWhenDone, 
             TimeSource::TimeSourceType type = TimeSource::REALTIME_CONTINUOUS, 
             JobPersistenceType persistence = NOT_PERSISTENT);

Modified: rl/branches/persistence/core/include/JobQueue.h
===================================================================
--- rl/branches/persistence/core/include/JobQueue.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/include/JobQueue.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -26,7 +26,7 @@
     class _RlCoreExport JobQueue : public AbstractJob
     {
     public:
-        JobQueue();
+        JobQueue(const CeGuiString &amp;id);
         ~JobQueue();
 
         void add(AbstractJob* job);
@@ -44,7 +44,7 @@
     class _RlCoreExport JobSet : public AbstractJob
     {
     public:
-        JobSet();
+        JobSet(const CeGuiString &amp;id);
         ~JobSet();
 
         void add(AbstractJob* job);

Modified: rl/branches/persistence/core/include/MessagePump.h
===================================================================
--- rl/branches/persistence/core/include/MessagePump.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/include/MessagePump.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -1,292 +1,234 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __Rl_MessagePump_H__
-#define __Rl_MessagePump_H__
-
-#include &quot;CorePrerequisites.h&quot;
-
-#include &quot;MessageType.h&quot;
-#include &quot;GameTask.h&quot;
-
-
-#include &lt;map&gt;
-#include &lt;queue&gt;
-
-#include &lt;boost/noncopyable.hpp&gt;
-
-namespace rl
-{
-
-    class MessageHandlerWrapperBase
-    {
-    public:
-        virtual ~MessageHandlerWrapperBase() {}
-        virtual bool Invoke(MessageObjectBase* obj) = 0;
-    };
-
-    template&lt;class _MessageType&gt;
-    class MessageHandlerWrapper : public MessageHandlerWrapperBase
-    {
-    public:
-        typedef typename _MessageType::MessageObjectType MessageObjectType;
-        typedef typename _MessageType::HandlerType HandlerType;
-
-        MessageHandlerWrapper(const HandlerType&amp; handler)
-            : mHandler(handler)
-        {
-        }
-
-        virtual bool Invoke(MessageObjectBase* obj)
-        {
-            MessageObjectType* obj2 = static_cast&lt;MessageObjectType*&gt;(obj);
-            return obj2-&gt;Invoke(mHandler);
-        }
-
-    private:
-        HandlerType mHandler;
-    };
-
-    class _RlCoreExport MessagePump : public GameTask, public Ogre::Singleton&lt;MessagePump&gt;
-    {
-    public:
-        class Connection
-        {
-            friend class MessagePump;
-        public:
-            Connection()
-                : connectionId(-1), pump(NULL)
-            {}
-            void disconnect()
-            {
-                if(pump &amp;&amp; connectionId != -1)
-                    pump-&gt;disconnectHandler(connectionId);
-            }
-        private:
-            MessagePump* pump;
-            int connectionId;
-        };
-
-        class ScopedConnection : boost::noncopyable
-        {
-        public:
-            ScopedConnection()
-            {}
-            ScopedConnection(const Connection&amp; conn)
-                : mConnection(conn)
-            {}
-            ScopedConnection&amp; operator =(const Connection&amp; conn)
-            {
-                mConnection.disconnect();
-                mConnection = conn;
-                return *this;
-            }
-            ~ScopedConnection()
-            {
-                mConnection.disconnect();
-            }
-        private:
-            Connection mConnection;
-        };
-
-    private:
-        struct MessageHandlerMapEntry
-        {
-            int connectionId;
-            MessageHandlerWrapperBase* handlerWrapper;
-        };
-
-        typedef std::vector&lt;MessageHandlerMapEntry&gt; MessageHandlerMapEntries;
-        typedef std::map&lt;int, MessageHandlerMapEntries*&gt; MessageHandlerMap;
-        typedef std::queue&lt;MessageObjectBase*&gt; MessageQueue;
-
-    public:
-        MessagePump() : mNextConnectionId(0) {}
-        ~MessagePump();
-
-        template&lt;typename _MessageType&gt;
-        Connection addMessageHandler( const typename _MessageType::HandlerType&amp; handler )
-        {
-            MessageHandlerWrapper&lt;_MessageType&gt;* wrapper =
-                new MessageHandlerWrapper&lt;_MessageType&gt;(handler);
-
-            MessageHandlerMapEntries* entries = getOrCreateMapEntries(_MessageType::MessageTypeId);
-            MessageHandlerMapEntry entry = {mNextConnectionId++, wrapper};
-            entries-&gt;push_back(entry);
-
-            LOG_MESSAGE(&quot;MessagePump&quot;, 
-                &quot;Added message handler for message type &quot; 
-                + Ogre::StringConverter::toString(_MessageType::MessageTypeId));
-
-            Connection con;
-            con.pump = this;
-            con.connectionId = entry.connectionId;
-            return con;
-        }
-
-        /*
-        * sendMessage and postMessage is implemented for all possible parameter counts
-        * Thanks to the idea of SFINAE, the compiler will choose 
-        * the correct implementation for all MessageTypes at compile time
-        *
-        * sendMessage processes the message immediatly, while postMessage delays the 
-        * processing to a later frame
-        */
-        template&lt;typename _MessageType&gt;
-        bool sendMessage()
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
-            return doSend(obj);
-        }
-
-        template&lt;typename _MessageType&gt;
-        bool sendMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1)
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1);
-            return doSend(obj);
-        }
-
-        template&lt;typename _MessageType&gt;
-        bool sendMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
-            const typename _MessageType::MessageObjectType::Param2&amp; p2)
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1, p2);
-            return doSend(obj);
-        }
-
-        template&lt;typename _MessageType&gt;
-        bool sendMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
-            const typename _MessageType::MessageObjectType::Param2&amp; p2,
-            const typename _MessageType::MessageObjectType::Param2&amp; p3)
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1, p2, p3);
-            return doSend(obj);
-        }
-
-        ////////////////////////////////
-
-        template&lt;typename _MessageType&gt;
-        void postMessage()
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
-            doPost(obj);
-        }
-
-        template&lt;typename _MessageType&gt;
-        void postMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1)
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1);
-            doPost(obj);
-        }
-
-        template&lt;typename _MessageType&gt;
-        void postMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
-            const typename _MessageType::MessageObjectType::Param2&amp; p2)
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1,p2);
-            doPost(obj);
-        }
-
-        template&lt;typename _MessageType&gt;
-        void postMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
-            const typename _MessageType::MessageObjectType::Param2&amp; p2,
-            const typename _MessageType::MessageObjectType::Param2&amp; p3)
-        {
-            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1, p2, p3);
-            doPost(obj);
-        }
-
-        void sendPending()
-        {
-            while(!mMessageQueue.empty())
-            {
-                doSend(mMessageQueue.front());
-                mMessageQueue.pop();
-            }
-        }
-
-        // overloads from GameTask
-
-        virtual void run(Ogre::Real elapsedTime);
-
-        virtual const Ogre::String&amp; getName() const;
-
-    private:
-        MessageHandlerMapEntries* getOrCreateMapEntries(int id) 
-        {
-            LOG_MESSAGE(&quot;MessagePump&quot;, &quot;Create or get id &quot; + Ogre::StringConverter::toString(id));
-            MessageHandlerMap::iterator it = mMessageHandlerMap.find(id);
-            if(it == mMessageHandlerMap.end())
-            {
-                MessageHandlerMapEntries* entries = new MessageHandlerMapEntries();
-                mMessageHandlerMap[id] = entries;
-                return entries;
-            }
-            return it-&gt;second;
-        }
-
-        bool doSend(MessageObjectBase* msg)
-        {
-            bool msgHandled = false;
-            MessageHandlerMapEntries* entries = getOrCreateMapEntries(msg-&gt;getMessageTypeId());
-            for(MessageHandlerMapEntries::iterator it = entries-&gt;begin(); it != entries-&gt;end(); ++it)
-            {
-                if((*it).handlerWrapper-&gt;Invoke(msg))
-                {
-                    msgHandled = true;
-                }
-            }
-            delete msg;
-            return msgHandled;;
-        }
-
-        void doPost(MessageObjectBase* msg)
-        {
-            mMessageQueue.push(msg);
-        }
-
-        friend class Connection;
-        void disconnectHandler(int connectionId)
-        {
-            //not very performant...definitely needs improvement
-            for (MessageHandlerMap::iterator it = mMessageHandlerMap.begin();
-                it != mMessageHandlerMap.end(); ++it)
-            {
-                MessageHandlerMapEntries* en = it-&gt;second;
-                for (MessageHandlerMapEntries::iterator jt = en-&gt;begin(); jt != en-&gt;end(); ++jt)
-                {
-                    if (jt-&gt;connectionId == connectionId)
-                    {
-                        delete jt-&gt;handlerWrapper;
-                        en-&gt;erase(jt);
-                        if (en-&gt;empty())
-                        {
-                            delete en;
-                            mMessageHandlerMap.erase(it);
-                        }
-                        return;
-                    }
-                }
-            }
-        }
-
-    private:
-        int mNextConnectionId;
-        MessageHandlerMap mMessageHandlerMap;
-        MessageQueue mMessageQueue;
-    };
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __Rl_MessagePump_H__
+#define __Rl_MessagePump_H__
+
+#include &quot;CorePrerequisites.h&quot;
+
+#include &quot;MessageType.h&quot;
+#include &quot;GameTask.h&quot;
+
+
+#include &lt;map&gt;
+#include &lt;queue&gt;
+
+#include &lt;boost/noncopyable.hpp&gt;
+
+namespace rl
+{
+
+    class MessageHandlerWrapperBase
+    {
+    public:
+        virtual ~MessageHandlerWrapperBase() {}
+        virtual bool Invoke(MessageObjectBase* obj) = 0;
+    };
+
+    template&lt;class _MessageType&gt;
+    class MessageHandlerWrapper : public MessageHandlerWrapperBase
+    {
+    public:
+        typedef typename _MessageType::MessageObjectType MessageObjectType;
+        typedef typename _MessageType::HandlerType HandlerType;
+
+        MessageHandlerWrapper(const HandlerType&amp; handler)
+            : mHandler(handler)
+        {
+        }
+
+        virtual bool Invoke(MessageObjectBase* obj)
+        {
+            MessageObjectType* obj2 = static_cast&lt;MessageObjectType*&gt;(obj);
+            return obj2-&gt;Invoke(mHandler);
+        }
+
+    private:
+        HandlerType mHandler;
+    };
+
+    class _RlCoreExport MessagePump : public GameTask, public Ogre::Singleton&lt;MessagePump&gt;
+    {
+    public:
+        class Connection
+        {
+            friend class MessagePump;
+        public:
+            Connection()
+                : connectionId(-1), pump(NULL)
+            {}
+            void disconnect()
+            {
+                if(pump &amp;&amp; connectionId != -1)
+                    pump-&gt;disconnectHandler(connectionId);
+            }
+        private:
+            MessagePump* pump;
+            int connectionId;
+        };
+
+        class ScopedConnection : boost::noncopyable
+        {
+        public:
+            ScopedConnection()
+            {}
+            ScopedConnection(const Connection&amp; conn)
+                : mConnection(conn)
+            {}
+            ScopedConnection&amp; operator =(const Connection&amp; conn)
+            {
+                mConnection.disconnect();
+                mConnection = conn;
+                return *this;
+            }
+            ~ScopedConnection()
+            {
+                mConnection.disconnect();
+            }
+        private:
+            Connection mConnection;
+        };
+
+    private:
+        struct MessageHandlerMapEntry
+        {
+            int connectionId;
+            MessageHandlerWrapperBase* handlerWrapper;
+        };
+
+        typedef std::vector&lt;MessageHandlerMapEntry&gt; MessageHandlerMapEntries;
+        typedef std::map&lt;int, MessageHandlerMapEntries*&gt; MessageHandlerMap;
+        typedef std::queue&lt;MessageObjectBase*&gt; MessageQueue;
+
+    public:
+        MessagePump() : mNextConnectionId(0) {}
+        ~MessagePump();
+
+        template&lt;typename _MessageType&gt;
+        Connection addMessageHandler( const typename _MessageType::HandlerType&amp; handler )
+        {
+            MessageHandlerWrapper&lt;_MessageType&gt;* wrapper =
+                new MessageHandlerWrapper&lt;_MessageType&gt;(handler);
+
+            MessageHandlerMapEntries* entries = getOrCreateMapEntries(_MessageType::MessageTypeId);
+            MessageHandlerMapEntry entry = {mNextConnectionId++, wrapper};
+            entries-&gt;push_back(entry);
+
+            LOG_MESSAGE(&quot;MessagePump&quot;, 
+                &quot;Added message handler for message type &quot; 
+                + Ogre::StringConverter::toString(_MessageType::MessageTypeId));
+
+            Connection con;
+            con.pump = this;
+            con.connectionId = entry.connectionId;
+            return con;
+        }
+
+        /*
+        * sendMessage and postMessage is implemented for all possible parameter counts
+        * Thanks to the idea of SFINAE, the compiler will choose 
+        * the correct implementation for all MessageTypes at compile time
+        *
+        * sendMessage processes the message immediatly, while postMessage delays the 
+        * processing to a later frame
+        */
+        template&lt;typename _MessageType&gt;
+        bool sendMessage()
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
+            return doSend(obj);
+        }
+
+        template&lt;typename _MessageType&gt;
+        bool sendMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1);
+            return doSend(obj);
+        }
+
+        template&lt;typename _MessageType&gt;
+        bool sendMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
+            const typename _MessageType::MessageObjectType::Param2&amp; p2)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1, p2);
+            return doSend(obj);
+        }
+
+        template&lt;typename _MessageType&gt;
+        bool sendMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
+            const typename _MessageType::MessageObjectType::Param2&amp; p2,
+            const typename _MessageType::MessageObjectType::Param2&amp; p3)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1, p2, p3);
+            return doSend(obj);
+        }
+
+        ////////////////////////////////
+
+        template&lt;typename _MessageType&gt;
+        void postMessage()
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build();
+            doPost(obj);
+        }
+
+        template&lt;typename _MessageType&gt;
+        void postMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1);
+            doPost(obj);
+        }
+
+        template&lt;typename _MessageType&gt;
+        void postMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
+            const typename _MessageType::MessageObjectType::Param2&amp; p2)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1,p2);
+            doPost(obj);
+        }
+
+        template&lt;typename _MessageType&gt;
+        void postMessage(const typename _MessageType::MessageObjectType::Param1&amp; p1,
+            const typename _MessageType::MessageObjectType::Param2&amp; p2,
+            const typename _MessageType::MessageObjectType::Param2&amp; p3)
+        {
+            MessageObjectBase* obj = _MessageType::MessageObjectType::Build(p1, p2, p3);
+            doPost(obj);
+        }
+
+        void sendPending();
+
+        // overloads from GameTask
+
+        virtual void run(Ogre::Real elapsedTime);
+
+        virtual const Ogre::String&amp; getName() const;
+
+    private:
+        MessageHandlerMapEntries* getOrCreateMapEntries(int id); 
+        bool doSend(MessageObjectBase* msg);
+        void doPost(MessageObjectBase* msg);
+
+        friend class Connection;
+        void disconnectHandler(int connectionId);
+
+    private:
+        int mNextConnectionId;
+        MessageHandlerMap mMessageHandlerMap;
+        MessageQueue mMessageQueue;
+    };
+}
+#endif

Modified: rl/branches/persistence/core/include/PlayAnimationJob.h
===================================================================
--- rl/branches/persistence/core/include/PlayAnimationJob.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/include/PlayAnimationJob.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -39,7 +39,7 @@
         * @param replaceAllAnims &lt;code&gt;true&lt;/code&gt; if all other animations should be stopped,
         *                        when this animation is started, &lt;code&gt;false&lt;/code&gt; else.
         */
-        PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
+        PlayAnimationJob(const CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
             bool replaceAllAnims=true);
 
         /**
@@ -51,7 +51,7 @@
         * @param replaceAllAnims &lt;code&gt;true&lt;/code&gt; if all other animations should be stopped,
         *                        when this animation is started, &lt;code&gt;false&lt;/code&gt; else.
         */
-        PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, int loops = 1,
+        PlayAnimationJob(const CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, int loops = 1,
             bool replaceAllAnims=true);
 
         virtual ~PlayAnimationJob();

Modified: rl/branches/persistence/core/include/StartAnimationJob.h
===================================================================
--- rl/branches/persistence/core/include/StartAnimationJob.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/include/StartAnimationJob.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -38,7 +38,7 @@
         * @param replaceAllAnims &lt;code&gt;true&lt;/code&gt; if all other animations should be stopped,
         *                        when this animation is started, &lt;code&gt;false&lt;/code&gt; else.
         */
-        StartAnimationJob(Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
+        StartAnimationJob(const CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
             bool replaceAllAnims=true);
         virtual ~StartAnimationJob();
 

Modified: rl/branches/persistence/core/src/Job.cpp
===================================================================
--- rl/branches/persistence/core/src/Job.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/Job.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -20,10 +20,8 @@
 
 namespace rl
 {
-    AbstractJob::AbstractJob(bool isDiscardable, bool destroyWhenDone)
     AbstractJob::AbstractJob(const CeGuiString &amp;id, bool isDiscardable, bool destroyWhenDone)
         : mIsDiscardable(isDiscardable), 
-        mDestroyWhenDone(destroyWhenDone)
         mDestroyWhenDone(destroyWhenDone),
 		SaveAble(id)
     {
@@ -112,8 +110,8 @@
         return keys;
     }
 
-    Job::Job(bool isDiscardable, bool destroyWhenDone, TimeSource::TimeSourceType timesource, JobPersistenceType persistence)
-        : AbstractJob(isDiscardable, destroyWhenDone),
+    Job::Job(const CeGuiString &amp;id, bool isDiscardable, bool destroyWhenDone, TimeSource::TimeSourceType timesource, JobPersistenceType persistence)
+        : AbstractJob(id, isDiscardable, destroyWhenDone),
         mTimeSource(timesource),
         mPersistence(persistence)
     {

Modified: rl/branches/persistence/core/src/JobQueue.cpp
===================================================================
--- rl/branches/persistence/core/src/JobQueue.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/JobQueue.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -20,8 +20,8 @@
 namespace rl
 {
 
-JobQueue::JobQueue()
-: AbstractJob(false, true),
+JobQueue::JobQueue(const CeGuiString &amp;id)
+: AbstractJob(id, false, true),
     mTimeSource(TimeSource::REALTIME_CONTINUOUS)
 {
 }
@@ -96,8 +96,8 @@
     return &quot;JobQueue&quot;;
 }
 
-JobSet::JobSet()
-: AbstractJob(false, true),
+JobSet::JobSet(const CeGuiString &amp;id)
+: AbstractJob(id, false, true),
     mTimeSource(TimeSource::REALTIME_CONTINUOUS)
 {
 }

Modified: rl/branches/persistence/core/src/MessagePump.cpp
===================================================================
--- rl/branches/persistence/core/src/MessagePump.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/MessagePump.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -1,57 +1,126 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot;
-
-#include &quot;MessagePump.h&quot;
-
-template&lt;&gt; rl::MessagePump* Ogre::Singleton&lt;rl::MessagePump&gt;::ms_Singleton = 0;
-
-namespace rl
-{
-    MessagePump::~MessagePump()
-    {
-
-        while(!mMessageQueue.empty())
-        {
-        
-            delete mMessageQueue.front();
-            mMessageQueue.pop();    
-        }
-
-        MessageHandlerMap::iterator it = mMessageHandlerMap.begin();
-        for( ; it != mMessageHandlerMap.end(); it++ )
-            if( it-&gt;second != NULL )
-                delete it-&gt;second;
-    }
-
-    void MessagePump::run(Ogre::Real elapsedTime)
-    {
-        static bool sending = false;
-        if(!sending)
-        {
-            sending = true;
-            sendPending();
-            sending = false;  
-        }
-    }
-
-    const Ogre::String&amp; MessagePump::getName() const
-    {
-        static Ogre::String name = &quot;MessagePump&quot;;
-        return name;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;MessagePump.h&quot;
+
+template&lt;&gt; rl::MessagePump* Ogre::Singleton&lt;rl::MessagePump&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    MessagePump::~MessagePump()
+    {
+
+        while(!mMessageQueue.empty())
+        {
+        
+            delete mMessageQueue.front();
+            mMessageQueue.pop();    
+        }
+
+        MessageHandlerMap::iterator it = mMessageHandlerMap.begin();
+        for( ; it != mMessageHandlerMap.end(); it++ )
+            if( it-&gt;second != NULL )
+                delete it-&gt;second;
+    }
+
+    void MessagePump::run(Ogre::Real elapsedTime)
+    {
+        static bool sending = false;
+        if(!sending)
+        {
+            sending = true;
+            sendPending();
+            sending = false;  
+        }
+    }
+
+    const Ogre::String&amp; MessagePump::getName() const
+    {
+        static Ogre::String name = &quot;MessagePump&quot;;
+        return name;
+    }
+    
+    void MessagePump::sendPending()
+    {
+        while(!mMessageQueue.empty())
+        {
+            doSend(mMessageQueue.front());
+            mMessageQueue.pop();
+        }
+    }
+    
+    
+    MessagePump::MessageHandlerMapEntries* MessagePump::getOrCreateMapEntries(int id)
+    {
+        // if (id != 0x1000204){
+        //     LOG_MESSAGE(&quot;MessagePump&quot;, &quot;Create or get id &quot; + Ogre::StringConverter::toString(id));                
+        // }
+        MessageHandlerMap::iterator it = mMessageHandlerMap.find(id);
+        if(it == mMessageHandlerMap.end())
+        {
+            MessageHandlerMapEntries* entries = new MessageHandlerMapEntries();
+            mMessageHandlerMap[id] = entries;
+            return entries;
+        }
+        return it-&gt;second;
+    }
+    
+    bool MessagePump::doSend(MessageObjectBase* msg)
+    {
+        bool msgHandled = false;
+        MessageHandlerMapEntries* entries = getOrCreateMapEntries(msg-&gt;getMessageTypeId());
+        for(MessageHandlerMapEntries::iterator it = entries-&gt;begin(); it != entries-&gt;end(); ++it)
+        {
+            if((*it).handlerWrapper-&gt;Invoke(msg))
+            {
+                msgHandled = true;
+            }
+        }
+        delete msg;
+        return msgHandled;;
+    }
+    
+    void MessagePump::doPost(MessageObjectBase* msg)
+    {
+        mMessageQueue.push(msg);
+    }
+    
+    void MessagePump::disconnectHandler(int connectionId)
+    {
+        //not very performant...definitely needs improvement
+        for (MessageHandlerMap::iterator it = mMessageHandlerMap.begin();
+             it != mMessageHandlerMap.end(); ++it)
+        {
+            MessageHandlerMapEntries* en = it-&gt;second;
+            for (MessageHandlerMapEntries::iterator jt = en-&gt;begin(); jt != en-&gt;end(); ++jt)
+            {
+                if (jt-&gt;connectionId == connectionId)
+                {
+                    delete jt-&gt;handlerWrapper;
+                    en-&gt;erase(jt);
+                    if (en-&gt;empty())
+                    {
+                        delete en;
+                        mMessageHandlerMap.erase(it);
+                    }
+                    return;
+                }
+            }
+        }
+    }
+    
+}

Modified: rl/branches/persistence/core/src/PlayAnimationJob.cpp
===================================================================
--- rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/PlayAnimationJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -24,9 +24,9 @@
 namespace rl
 {
 
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
+    PlayAnimationJob::PlayAnimationJob(const CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
         bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+        : Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
           mActor(actor),
           mAnimName(anim),
           mDuration(duration),
@@ -39,9 +39,9 @@
     {
     }
 
-    PlayAnimationJob::PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, int loops,
+    PlayAnimationJob::PlayAnimationJob(const CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, int loops,
         bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+        : Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
           mActor(actor),
           mAnimName(anim),
           mLoops(loops),

Modified: rl/branches/persistence/core/src/PlaySoundJob.cpp
===================================================================
--- rl/branches/persistence/core/src/PlaySoundJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/PlaySoundJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -26,7 +26,7 @@
 {
 
 	PlaySound2dJob::PlaySound2dJob(const Ogre::String&amp; sound, Real volume, int priority)
-        : Job(false, true), mSound(NULL), mExecuted(false)
+        : Job(&quot;&quot;, false, true), mSound(NULL), mExecuted(false)
     {
         mSound = SoundManager::getSingleton().createSound(sound, ST_SAMPLE);
         mSound-&gt;set3d(false);
@@ -53,7 +53,7 @@
     }
 
 	PlaySound3dJob::PlaySound3dJob(const Ogre::String&amp; sound, const Ogre::Vector3&amp; pos, Real volume, int priority)
-        : Job(false, true), mSound(NULL), mExecuted(false)
+        : Job(&quot;&quot;, false, true), mSound(NULL), mExecuted(false)
     {
         mSound = SoundManager::getSingleton().createSound(sound, ST_SAMPLE);
         mSound-&gt;set3d(true);

Modified: rl/branches/persistence/core/src/SaveAbleFactory.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/SaveAbleFactory.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -16,4 +16,32 @@
 
 #include &quot;stdinc.h&quot;
 
-#include &quot;SaveAbleFactory.h&quot;
\ No newline at end of file
+#include &quot;SaveAbleFactory.h&quot;
+
+namespace rl
+{
+	void SaveAbleFactoryPool::registerFactory(const Ogre::String &amp;key, rl::SaveAbleFactory *fac)
+	{
+		if(mFactories.find(key) != mFactories.end())
+			LOG_ERROR(&quot;CORE&quot;, &quot;SaveAbleFactory already registered!&quot;);
+		mFactories[key] = fac;
+	}
+
+	void SaveAbleFactoryPool::unregisterFactory(const Ogre::String &amp;key)
+	{
+		std::map&lt;Ogre::String,SaveAbleFactory*&gt;::iterator it = mFactories.find(key);
+		mFactories.erase(it);
+	}
+
+	void SaveAbleFactoryPool::unregisterFactory(rl::SaveAbleFactory *fac)
+	{
+	}
+
+	SaveAbleFactory* SaveAbleFactoryPool::getFactory(const Ogre::String &amp;key)
+	{
+		std::map&lt;Ogre::String,SaveAbleFactory*&gt;::iterator it = mFactories.find(key);
+		if(it == mFactories.end())
+			return NULL;
+		return it-&gt;second;
+	}
+}
\ No newline at end of file

Modified: rl/branches/persistence/core/src/SoundFadeJob.cpp
===================================================================
--- rl/branches/persistence/core/src/SoundFadeJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/SoundFadeJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -23,7 +23,7 @@
 namespace rl
 {
     SoundFadeJob::SoundFadeJob(SoundObject* soundObject, SoundFadeFunctor* fadeFunctor, bool destroyWhenDone)
-        : Job(true, destroyWhenDone),
+        : Job(&quot;&quot;, true, destroyWhenDone),
         mSoundObject(soundObject),
         mSoundFadeFunctor(fadeFunctor),
         mTime(0)

Modified: rl/branches/persistence/core/src/StartAnimationJob.cpp
===================================================================
--- rl/branches/persistence/core/src/StartAnimationJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/core/src/StartAnimationJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -23,9 +23,9 @@
 namespace rl
 {
 
-    StartAnimationJob::StartAnimationJob(Actor* actor, const Ogre::String&amp; anim, bool doLoop,
+    StartAnimationJob::StartAnimationJob(const CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, bool doLoop,
         bool replaceAllAnims)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+        : Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
           mActor(actor),
           mAnimName(anim),
           mLoop(doLoop),

Modified: rl/branches/persistence/rules/include/FetchItemJob.h
===================================================================
--- rl/branches/persistence/rules/include/FetchItemJob.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/include/FetchItemJob.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -31,7 +31,7 @@
     {
     public:
 
-		FetchItemJob(Creature* actor, Item* item, const Ogre::String&amp; targetSlot, Ogre::Real duration);
+		FetchItemJob(const CeGuiString &amp;id, Creature* actor, Item* item, const Ogre::String&amp; targetSlot, Ogre::Real duration);
         virtual ~FetchItemJob();
 
         virtual bool execute(Ogre::Real time);

Modified: rl/branches/persistence/rules/include/GoToJob.h
===================================================================
--- rl/branches/persistence/rules/include/GoToJob.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/include/GoToJob.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -31,9 +31,9 @@
     {
     public:
 
-		GoToJob(Creature* actor, const Ogre::Vector3&amp; targetPos,
+		GoToJob(const CeGuiString &amp;id, Creature* actor, const Ogre::Vector3&amp; targetPos,
 			Ogre::Real maxDistance, Ogre::Real duration);
-		GoToJob(Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+		GoToJob(const CeGuiString &amp;id, Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
         virtual ~GoToJob();
 
         virtual bool execute(Ogre::Real time);

Modified: rl/branches/persistence/rules/include/WaitJob.h
===================================================================
--- rl/branches/persistence/rules/include/WaitJob.h	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/include/WaitJob.h	2008-10-12 12:14:27 UTC (rev 4546)
@@ -29,8 +29,8 @@
         public Job
     {
     public:
-        WaitJob(const Date&amp; dsatime);
-        WaitJob(const Ogre::Real&amp; realtime);
+        WaitJob(const CeGuiString &amp;id, const Date&amp; dsatime);
+        WaitJob(const CeGuiString &amp;id, const Ogre::Real&amp; realtime);
         ~WaitJob();
 
         virtual bool execute(Ogre::Real time);

Modified: rl/branches/persistence/rules/src/ApplyDamageJob.cpp
===================================================================
--- rl/branches/persistence/rules/src/ApplyDamageJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/src/ApplyDamageJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -22,7 +22,7 @@
 {
 
 ApplyDamageJob::ApplyDamageJob(Creature* target, int tp)
-:   Job(false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
+:   Job(&quot;&quot;,false, true, TimeSource::GAMETIME, AbstractJob::PERSISTENT),
     mTarget(target), 
     mTp(tp)
 {

Modified: rl/branches/persistence/rules/src/Combat.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combat.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/src/Combat.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -72,9 +72,11 @@
 		  mNextActionId(0),
 		  mAnimationSequenceTicket(0)
     {
+        LOG_MESSAGE(&quot;Combat&quot;, &quot;Register message handler&quot;);
 		mLifeStateChangeConnection =
             MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectLifeStateChanged&gt;(
 			    boost::bind(&amp;Combat::onGameObjectLifeStateChanged, this, _1, _2, _3));
+        LOG_MESSAGE(&quot;Combat&quot;, &quot;Registering message handler done&quot;);
     }
 
     Combat::~Combat()
@@ -321,15 +323,15 @@
 		// Auf gehts!
 
 		// Prepare JobQueue for animations.
-		JobQueue* jobQueue = new JobQueue();
+		JobQueue* jobQueue = new JobQueue(&quot;AnimationQueue&quot;);
 
 		for (size_t actionIndex = 0; actionIndex &lt; 3; ++actionIndex)
 		{
 			for (CombatantQueue::iterator it = mCombatantQueue.begin();
 				it != mCombatantQueue.end(); ++it)
 			{
-			    JobSet* jobSetAnims = new JobSet();
-                JobSet* jobSetOutcome = new JobSet(); // damage is applied after combat animations to prevent premature reactions
+			    JobSet* jobSetAnims = new JobSet(&quot;jobSetAnims&quot;);
+                JobSet* jobSetOutcome = new JobSet(&quot;jobSetOutcome&quot;); // damage is applied after combat animations to prevent premature reactions
 
                 Combatant* combatant = it-&gt;second;
 

Modified: rl/branches/persistence/rules/src/Combatant.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combatant.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/src/Combatant.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -136,7 +136,7 @@
 
 		// Get real animation name
 		Creature::AnimationSpeedPair asp = getCreature()-&gt;getAnimation(ani);
-		PlayAnimationJob* job = new PlayAnimationJob(getCreature()-&gt;getActor(), asp.first);
+		PlayAnimationJob* job = new PlayAnimationJob(&quot;Animation&quot; + ani + getCreature()-&gt;getId(), getCreature()-&gt;getActor(), asp.first);
         job-&gt;setHoldOnEnd(false);
         jobSet-&gt;add(job);
 	}
@@ -164,7 +164,7 @@
 
 		// Get real animation name
 		Creature::AnimationSpeedPair asp = getCreature()-&gt;getAnimation(ani);
-		PlayAnimationJob* job = new PlayAnimationJob(getCreature()-&gt;getActor(), asp.first);
+		PlayAnimationJob* job = new PlayAnimationJob(&quot;Animation&quot; + ani + getCreature()-&gt;getId(), getCreature()-&gt;getActor(), asp.first);
         job-&gt;setHoldOnEnd(false);
         jobSet-&gt;add(job);
 	}
@@ -173,20 +173,20 @@
 	{
 		// Get real animation name
 		Creature::AnimationSpeedPair asp = getCreature()-&gt;getAnimation(&quot;kampf_getroffen&quot;);
-		PlayAnimationJob* job = new PlayAnimationJob(getCreature()-&gt;getActor(), asp.first);
+		PlayAnimationJob* job = new PlayAnimationJob(&quot;Animation&quot; + Ogre::String(&quot;kampf_getroffen&quot;) + getCreature()-&gt;getId(), getCreature()-&gt;getActor(), asp.first);
         job-&gt;setHoldOnEnd(false);
 		jobSet-&gt;add(job);
 	}
 
 	void Combatant::doBewegen(JobSet* jobSet, const Ogre::Vector3&amp; targetPos)
 	{
-		Job* job = new GoToJob(getCreature(), targetPos, 0.0f, 3.0f);
+		Job* job = new GoToJob(&quot;GoTo&quot; + getCreature()-&gt;getId(), getCreature(), targetPos, 0.0f, 3.0f);
 		jobSet-&gt;add(job);
 	}
 
 	void Combatant::doFolgen(JobSet* jobSet, Combatant* target)
 	{
-		Job* job = new GoToJob(getCreature(), target-&gt;getCreature(),
+		Job* job = new GoToJob(&quot;GoTo&quot; + getCreature()-&gt;getId(), getCreature(), target-&gt;getCreature(),
 			getActiveWeapon()-&gt;getMaximumDistance(), 3.0f);
 		jobSet-&gt;add(job);
 	}

Modified: rl/branches/persistence/rules/src/FetchItemJob.cpp
===================================================================
--- rl/branches/persistence/rules/src/FetchItemJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/src/FetchItemJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -30,8 +30,8 @@
 
 namespace rl
 {
-	FetchItemJob::FetchItemJob(Creature* actor, Item* item, const Ogre::String&amp; targetSlot, Ogre::Real duration)
-		: Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+	FetchItemJob::FetchItemJob(const CeGuiString &amp;id, Creature* actor, Item* item, const Ogre::String&amp; targetSlot, Ogre::Real duration)
+		: Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
 		  mActor(CreatureControllerManager::getSingleton().getCreatureController(actor)),
 		  mItem(item),
 		  mTargetSlot(targetSlot),
@@ -52,15 +52,34 @@
 			|| mItem-&gt;getState() == GOS_UNLOADED
 			|| mItem-&gt;getState() == GOS_LOADED)
 		{
+            if (!mItem) 
+            {
+                LOG_WARNING(&quot;FetchItemJob&quot;, &quot;Item not set or it has a strange state.&quot;);
+            }
+            else if (mTimeLeft &lt; 0)
+            {
+                LOG_MESSAGE(&quot;FetchItemJob&quot;, &quot;Time is up.&quot;);
+            }
+            else
+            {
+                LOG_WARNING(&quot;FetchItemJob&quot;, &quot;Item has a strange state (&quot; 
+                        + StringConverter::toString(mItem-&gt;getState()) + &quot;)&quot;);
+            }
+
 			// Stay put where ever we are.
 			mActor-&gt;setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
 
-		Vector3 targetPos = mItem-&gt;getPosition();
+        Item* target = mItem;
+        while (target-&gt;getState() == GOS_IN_POSSESSION)
+        {
+            target = target-&gt;getParentContainer();
+        }
+		Vector3 targetPos = target-&gt;getPosition();
 
 		// Are we there now?
-		Ogre::Real distance = MathUtil::distance(mItem-&gt;getWorldBoundingBox(),
+		Ogre::Real distance = MathUtil::distance(target-&gt;getWorldBoundingBox(),
 			mActor-&gt;getCreature()-&gt;getWorldBoundingBox());
 		if (distance &lt; 1.0f)
 		{
@@ -68,9 +87,9 @@
             
             if (mItem-&gt;getState() == GOS_IN_SCENE)
             {
-                    // @todo play pickup animation
-                    mActor-&gt;getCreature()-&gt;getInventory()-&gt;hold(mItem, mTargetSlot);
-                    return true;
+                // @todo play pickup animation
+                mActor-&gt;getCreature()-&gt;getInventory()-&gt;hold(mItem, mTargetSlot);
+                return true;
 			}
             else if (mItem-&gt;getState() == GOS_IN_POSSESSION)
 			{
@@ -86,8 +105,8 @@
             else if (mItem-&gt;getState() == GOS_READY
 					 || mItem-&gt;getState() == GOS_HELD)
 			{
-                    LOG_WARNING(&quot;FetchItemJob&quot;, &quot;Target item is held by someone&quot;);
-                    return true;
+                LOG_WARNING(&quot;FetchItemJob&quot;, &quot;Target item is held by someone&quot;);
+                return true;
             }
 
             return false;

Modified: rl/branches/persistence/rules/src/GoToJob.cpp
===================================================================
--- rl/branches/persistence/rules/src/GoToJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/src/GoToJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -25,8 +25,8 @@
 
 namespace rl
 {
-	GoToJob::GoToJob(Creature* actor, const Vector3&amp; targetPos, Real maxDistance, Real duration)
-		: Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+	GoToJob::GoToJob(const CeGuiString &amp;id, Creature* actor, const Vector3&amp; targetPos, Real maxDistance, Real duration)
+		: Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
 		  mActor(NULL),
 		  mTarget(NULL),
 		  mTargetPos(targetPos),
@@ -36,8 +36,8 @@
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
 	}
 
-	GoToJob::GoToJob(Creature* actor, GameObject* target, Real maxDistance, Real duration)
-		: Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+	GoToJob::GoToJob(const CeGuiString &amp;id, Creature* actor, GameObject* target, Real maxDistance, Real duration)
+		: Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
 		  mActor(NULL),
 		  mTarget(target),
 		  mTargetPos(Vector3::ZERO),

Modified: rl/branches/persistence/rules/src/WaitJob.cpp
===================================================================
--- rl/branches/persistence/rules/src/WaitJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/rules/src/WaitJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -21,14 +21,14 @@
 namespace rl
 {
 
-    WaitJob::WaitJob(const Date&amp; dsatime)
-        : Job(false, true, TimeSource::GAMETIME, Job::PERSISTENT),
+    WaitJob::WaitJob(const CeGuiString &amp;id, const Date&amp; dsatime)
+        : Job(id, false, true, TimeSource::GAMETIME, Job::PERSISTENT),
         mTime(dsatime.toReal())
     {
     }
 
-    WaitJob::WaitJob(const Ogre::Real&amp; realtime)
-        : Job(false, true, TimeSource::REALTIME_INTERRUPTABLE, Job::PERSISTENT),
+    WaitJob::WaitJob(const CeGuiString &amp;id, const Ogre::Real&amp; realtime)
+        : Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE, Job::PERSISTENT),
         mTime(realtime)
     {
     }

Modified: rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -44,13 +44,14 @@
 
         if (hasAttribute(nodeElem, &quot;id&quot;))
         {
-            goid = getAttributeValueAsInteger(nodeElem, &quot;id&quot;);
+            goid = getAttributeValueAsString(nodeElem, &quot;id&quot;);
         }
 
         GameObject* go = GameObjectManager::getSingleton().getGameObject(goid);
         if(!go)
         {
             go = GameObjectManager::getSingleton().createGameObject(classname, goid);
+			LOG_MESSAGE(&quot;Maploader&quot;, &quot;Created GameObject with id: &quot; + goid);
 
             DOMElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
             if (posElem != NULL)

Modified: rl/branches/persistence/script/swig/RlAi.swig
===================================================================
--- rl/branches/persistence/script/swig/RlAi.swig	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/script/swig/RlAi.swig	2008-10-12 12:14:27 UTC (rev 4546)
@@ -284,7 +284,7 @@
 	class CreatureWalkPathJob : public Job
     {
     public:
-        CreatureWalkPathJob(const Ogre::String&amp; name, rl::Creature* movingCreature, rl::Landmark* startLandmark);
+        CreatureWalkPathJob(const rl::CeGuiString &amp;id, const Ogre::String&amp; name, rl::Creature* movingCreature, rl::Landmark* startLandmark);
 
         void addLandmark(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
         void addLandmark(rl::Landmark* lm);

Modified: rl/branches/persistence/script/swig/RlCore.swig
===================================================================
--- rl/branches/persistence/script/swig/RlCore.swig	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/script/swig/RlCore.swig	2008-10-12 12:14:27 UTC (rev 4546)
@@ -989,7 +989,7 @@
 %apply SWIGTYPE *DYNAMIC { Job * };
 
 %feature(&quot;director&quot;) Job;
-class Job
+class Job : public SaveAble
 {
 public:
     /**
@@ -1004,7 +1004,7 @@
      *         Job, after execution is finished. This should usually be the case, but
      *         sometimes it is sensible to pool a number of Jobs for reuse.
      */
-	Job( bool isDiscardable, bool destroyWhenDone );
+	Job(const rl::CeGuiString &amp;id, bool isDiscardable, bool destroyWhenDone );
 	virtual ~Job();
 	
 	/**
@@ -1052,9 +1052,9 @@
 class PlayAnimationJob : public rl::Job
 {
 public:
-    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
+    PlayAnimationJob(const rl::CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
 		bool replaceAllAnims=true);
-    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, int loops = 1,
+    PlayAnimationJob(const rl::CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, int loops = 1,
 		bool replaceAllAnims=true);
     virtual ~PlayAnimationJob();
     
@@ -1065,7 +1065,7 @@
 class StartAnimationJob : public rl::Job
 {
 public:
-    StartAnimationJob(Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
+    StartAnimationJob(const rl::CeGuiString &amp;id, Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
 		bool replaceAllAnims=true);
     virtual ~StartAnimationJob();
     
@@ -1085,7 +1085,7 @@
 class JobQueue : public rl::Job
 {
 public:
-    JobQueue();
+    JobQueue(const rl::CeGuiString &amp;id);
     virtual ~JobQueue();
     void add(Job* job);
     
@@ -1096,7 +1096,7 @@
 class JobSet : public rl::Job
 {
 public:
-    JobSet();
+    JobSet(const rl::CeGuiString &amp;id);
     virtual ~JobSet();
     void add(Job* job);
     

Modified: rl/branches/persistence/script/swig/RlRules.swig
===================================================================
--- rl/branches/persistence/script/swig/RlRules.swig	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/script/swig/RlRules.swig	2008-10-12 12:14:27 UTC (rev 4546)
@@ -439,15 +439,15 @@
     class WaitJob : public rl::Job
     {
     public:
-        WaitJob(const rl::Date&amp; dsatime);
-        WaitJob(const Ogre::Real&amp; realtime);
+        WaitJob(const rl::CeGuiString &amp;id, const rl::Date&amp; dsatime);
+        WaitJob(const rl::CeGuiString &amp;id, const Ogre::Real&amp; realtime);
     };
     
     class GoToJob : public rl::Job
     {
     public:
 
-		GoToJob(rl::Creature* actor, const Ogre::Vector3&amp; targetPos,
+		GoToJob(const rl::CeGuiString &amp;id, rl::Creature* actor, const Ogre::Vector3&amp; targetPos,
 			Ogre::Real maxDistance, Ogre::Real duration);
 		// Unclear what version is called from ruby, so uncomment second ctor.
 		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
@@ -458,7 +458,7 @@
     {
     public:
 
-		FetchItemJob(rl::Creature* actor, rl::Item* item, const Ogre::String&amp; targetSlot, Ogre::Real duration);
+		FetchItemJob(const rl::CeGuiString &amp;id, rl::Creature* actor, rl::Item* item, const Ogre::String&amp; targetSlot, Ogre::Real duration);
     };
     
     %feature(&quot;director&quot;) Item;

Modified: rl/branches/persistence/ui/src/InputManager.cpp
===================================================================
--- rl/branches/persistence/ui/src/InputManager.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/ui/src/InputManager.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -578,7 +578,7 @@
 
 
         KeyRepeatJob(AbstractWindow* window, OIS::KeyCode key) :
-          Job(false, true),
+          Job(&quot;&quot;,false, true),
           mWindow(window),
           mKey(key),
           mLastTime(0)

Modified: rl/branches/persistence/ui/src/UiSubsystem.cpp
===================================================================
--- rl/branches/persistence/ui/src/UiSubsystem.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/ui/src/UiSubsystem.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -62,6 +62,7 @@
         mGuiResourceProvider(NULL),
         mGuiSystem(NULL)
     {
+        mWindowFactory = new WindowFactory();
         mSceneClearingConnection =
             MessagePump::getSingleton().addMessageHandler&lt;MessageType_SceneClearing&gt;(
 			    boost::bind(&amp;UiSubsystem::onBeforeClearScene, this));
@@ -74,7 +75,9 @@
         mActiveCharacterChangedConnection = 
             MessagePump::getSingleton().addMessageHandler&lt;MessageType_ActivePlayerCharChanged&gt;(
                 boost::bind(&amp;UiSubsystem::onActiveCharacterChanged, this, _1, _2));
-        mWindowFactory = new WindowFactory();
+        mAllPlayerCharactersDiedConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_AllPlayerCharsDied&gt;(
+                boost::bind(&amp;UiSubsystem::onAllPlayerCharactersDied, this));
     }
 
     UiSubsystem::~UiSubsystem()
@@ -98,7 +101,7 @@
         World* world = CoreSubsystem::getSingleton().getWorld();
         SceneManager* sceneMgr = world-&gt;getSceneManager();
         
-        CEGUI::System::setDefaultXMLParserName(&quot;XercesParser&quot;);
+//        CEGUI::System::setDefaultXMLParserName(&quot;XercesParser&quot;);
 
         LOG_MESSAGE2(Logger::UI,
             &quot;Initializing CEGUI Renderer.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);

Modified: rl/branches/persistence/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/branches/persistence/ui/src/WindowFadeJob.cpp	2008-10-11 17:25:56 UTC (rev 4545)
+++ rl/branches/persistence/ui/src/WindowFadeJob.cpp	2008-10-12 12:14:27 UTC (rev 4546)
@@ -29,7 +29,7 @@
 namespace rl
 {
     WindowFadeJob::WindowFadeJob(AbstractWindow* window, Mode mode, Real targetAlpha, Real changeRate)
-        : Job(true, true),
+        : Job(&quot;&quot;, true, true),
         mAbstractWindow(window),
         mCEGUIWindow(window-&gt;getWindow()),
         mItemDragContainer(NULL),
@@ -44,7 +44,7 @@
     }
 
     WindowFadeJob::WindowFadeJob(CEGUI::Window* window, Mode mode, Real targetAlpha, Real changeRate)
-        : Job(true, true),
+        : Job(&quot;&quot;, true, true),
         mAbstractWindow(NULL),
         mCEGUIWindow(window),
         mItemDragContainer(NULL),
@@ -59,7 +59,7 @@
     }
 
     WindowFadeJob::WindowFadeJob(ItemDragContainer* window, Mode mode, Real targetAlpha, Real changeRate)
-        : Job(true, true),
+        : Job(&quot;&quot;, true, true),
         mAbstractWindow(NULL),
         mCEGUIWindow(window),
         mItemDragContainer(window),


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001602.html">[Dsa-hl-svn] r4545 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
	<LI>Next message: <A HREF="001604.html">[Dsa-hl-svn] r4547 - in rl/branches/persistence: rules/include	rules/src script/src script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1603">[ date ]</a>
              <a href="thread.html#1603">[ thread ]</a>
              <a href="subject.html#1603">[ subject ]</a>
              <a href="author.html#1603">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
