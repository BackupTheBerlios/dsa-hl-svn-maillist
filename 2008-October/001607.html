<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4550 - in rl/trunk/editors/Lockenwickler: . src	src/media
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4550%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%20src%0A%09src/media&In-Reply-To=%3C200810161733.m9GHXUw3010153%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001606.html">
   <LINK REL="Next"  HREF="001608.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4550 - in rl/trunk/editors/Lockenwickler: . src	src/media</H1>
    <B>fusion2 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4550%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%20src%0A%09src/media&In-Reply-To=%3C200810161733.m9GHXUw3010153%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4550 - in rl/trunk/editors/Lockenwickler: . src	src/media">fusion2 at mail.berlios.de
       </A><BR>
    <I>Thu Oct 16 19:33:30 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001606.html">[Dsa-hl-svn] r4549 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
        <LI>Next message: <A HREF="001608.html">[Dsa-hl-svn] r4551 - in rl/branches/persistence/core: . include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1607">[ date ]</a>
              <a href="thread.html#1607">[ thread ]</a>
              <a href="subject.html#1607">[ subject ]</a>
              <a href="author.html#1607">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fusion2
Date: 2008-10-16 19:33:16 +0200 (Thu, 16 Oct 2008)
New Revision: 4550

Added:
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MovePivot.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/Property.py
   rl/trunk/editors/Lockenwickler/src/ViewportGrid.py
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
Log:
- delete and copy commands work

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-10-16 17:33:16 UTC (rev 4550)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Project SYSTEM &quot;Project-4.5.dtd&quot;&gt;
 &lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2008-10-12, 20:02:34 --&gt;
+&lt;!-- Saved: 2008-10-16, 19:21:23 --&gt;
 &lt;!-- Copyright (C) 2008 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;Project version=&quot;4.5&quot;&gt;
   &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
@@ -33,6 +33,7 @@
     &lt;Source&gt;src/SceneExplorer.py&lt;/Source&gt;
     &lt;Source&gt;src/Property.py&lt;/Source&gt;
     &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
+    &lt;Source&gt;src/ObjectPropertyModel.py&lt;/Source&gt;
   &lt;/Sources&gt;
   &lt;Forms&gt;
     &lt;Form&gt;ui files/console_window.ui&lt;/Form&gt;

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -116,6 +116,9 @@
         self.menuFile = QtGui.QMenu(self.menubar)
         self.menuFile.setObjectName(&quot;menuFile&quot;)
 
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
+
         self.menuView = QtGui.QMenu(self.menubar)
         self.menuView.setObjectName(&quot;menuView&quot;)
         self.setMenuBar(self.menubar)
@@ -125,14 +128,28 @@
         self.statusbar.setObjectName(&quot;statusbar&quot;)
         self.setStatusBar(self.statusbar)
 
-        self.actionNeu =self.createAction(&quot;&amp;New&quot;,  self.close,  &quot;Ctrl + N&quot;,  &quot;filenew.png&quot;,  &quot;New&quot;)
+#####################################
+        self.actionNeu =self.createAction(&quot;&amp;New&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New&quot;)
         self.actionNeu.setObjectName(&quot;actionNeu&quot;)
 
-        self.actionClose = self.createAction(&quot;Quit&quot;,  self.close,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
-        self.actionClose.setObjectName(&quot;actionClose&quot;)
+        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
+        self.actionClose.setObjectName(&quot;actionQuit&quot;)
+#####################################
 
 
+#####################################
+        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
+        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
 
+        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
+        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
+
+        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
+        self.actionCut.setObjectName(&quot;actionCut&quot;)
+
+        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
+        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
+
         self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
         self.actionMove.setObjectName(&quot;actionMove&quot;)
 
@@ -143,6 +160,8 @@
         self.actionRotate.setObjectName(&quot;actionRotate&quot;)
 
 
+#####################################
+#####################################
         self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleSceneExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Scene Explorer&quot;,  False)
         self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
 
@@ -158,15 +177,29 @@
         self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
         self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
 
+#####################################
+#####################################
 
+
         self.menuFile.addAction(self.actionNeu)
         self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+
         self.menuView.addAction(self.actionSceneExplorer)
         self.menuView.addAction(self.actionPreferences)
         self.menuView.addAction(self.actionProperty_Window)
         self.menuView.addAction(self.actionObject_Selection)
         self.menuView.addAction(self.actionConsole_Window)
         self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
         self.menubar.addAction(self.menuView.menuAction())
 
         self.retranslateUi()
@@ -175,6 +208,7 @@
     def retranslateUi(self):
         self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
         self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
         self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
         self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New&quot;, None, QtGui.QApplication.UnicodeUTF8))
         self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
@@ -225,17 +259,33 @@
 
         self.ogreRoot.renderOneFrame()
 
+    def actionNewSlot(self):
+        print &quot;dbg: new&quot;
+        return
+
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects()
+
     def actionMoveSlot(self):
         self.moduleManager.pivot.setMoveMode()
-        return
 
     def actionRotateSlot(self):
         self.moduleManager.pivot.setRotateMode()
-        return
 
     def actionScaleSlot(self):
         self.moduleManager.pivot.setScaleMode()
-        return
 
     def togglePreferencesWindow(self):
         if self.prefDialog.isHidden():

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -116,23 +116,23 @@
         del self.selectionList[:]
         #self.selectionList = []
 
-    def iterateEntityUnderMouse(self):
-        self.previousSelected = self.currentSelected
-        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
-            self.selectionList[self.currentSelected].setSelected(False)
+#    def iterateEntityUnderMouse(self):
+#        self.previousSelected = self.currentSelected
+#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
+#            self.selectionList[self.currentSelected].setSelected(False)
+#
+#        self.currentSelected += 1
+#
+#        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
+#            self.currentSelected = 0
+#
+#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
+#            #print str(self.selectionList[self.currentSelected].distance) + &quot; &quot;  + self.selectionList[self.currentSelected].entity.getName()
+#            if self.rayCastToPolygonLevelOnCurrentSelection():
+#                self.selectionList[self.currentSelected].setSelected(True)
+#                return self.selectionList[self.currentSelected]
 
-        self.currentSelected += 1
 
-        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
-            self.currentSelected = 0
-
-        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
-            #print str(self.selectionList[self.currentSelected].distance) + &quot; &quot;  + self.selectionList[self.currentSelected].entity.getName()
-            if self.rayCastToPolygonLevelOnCurrentSelection():
-                self.selectionList[self.currentSelected].setSelected(True)
-                return self.selectionList[self.currentSelected]
-
-
     def getMeshInformation(self,  entity):
         numVertices = 0
         numIndices = 0
@@ -330,6 +330,8 @@
         self.dropEntity = None
         self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
 
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+
     def load(self,  moduleName,  mapFiles):
         self.moduleName = moduleName
         self.mapFiles = mapFiles
@@ -417,6 +419,7 @@
                     self.userSelectionList.append(so)
                     self.updatePivots()
 
+
                 elif not controlDown and shiftDown:
                     for selo in self.userSelectionList:
                         if so == selo:
@@ -424,6 +427,7 @@
                             self.userSelectionList.remove(selo)
                     self.updatePivots()
             else:
+                #so.entity is the pivot direction that was clicked
                 self.pivot.startTransforming(so.entity,  self.userSelectionList)
         else:
             self.resetSelection() # click in empty space, deselect everything
@@ -450,15 +454,78 @@
 #
 #            self.rayLine.end()
 
+    def deleteObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = &quot;&quot;
+        split = name.split(&quot;_&quot;)
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + &quot;_1&quot;
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        newSelectionList = []
+        print &quot;dbg: &quot;
+        for so in self.userSelectionList:
+            nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+            newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+            entityName = self.incrementNameSuffixNumber(so.entity.getName())
+            newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+            newNode.attachObject(newEntity)
+            newNode.setPosition(so.entity.getParentNode().getPosition())
+            newNode.setOrientation(so.entity.getParentNode().getOrientation())
+            newNode.setScale(so.entity.getParentNode().getScale())
+
+            newSO = SelectionObject(newEntity, so.distance)
+            newSO.setSelected(True)
+            newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+        print &quot;dbg: cut&quot;
+
+    def pasteObjects(self):
+        print &quot;dbg: paste&quot;
+
     def leftMouseUp(self):
         if self.pivot is not None and self.pivot.isTransforming:
             self.pivot.stopTransforming()
 
-    def iterateEntityUnderMouse(self):
-        self.listenerDings.iterateEntityUnderMouse()
+#    def iterateEntityUnderMouse(self):
+#        self.listenerDings.iterateEntityUnderMouse()
+#
+#        pass
 
-        pass
-
     def resetSelection(self):
         for so in self.userSelectionList:
             so.setSelected(False)
@@ -506,3 +573,4 @@
 
     def stopDropModelAction(self, ray):
         pass
+

Modified: rl/trunk/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -23,8 +23,10 @@
 class Pivot():
     def __init__(self,  sceneManager):
         self.sceneManager = sceneManager
+        self.camera = self.sceneManager.getCamera(&quot;MainCam&quot;)
 
         self.mode = None
+        self.isHidden = True
 
         self.meshManager = og.MeshManager.getSingleton ()
 
@@ -42,6 +44,9 @@
     def __createMovePivot(self):
         self.xMoveEntity = self.sceneManager.createEntity(&quot;EditorXArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
         self.xMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthCheckEnabled(False)
+#        self.xMoveEntity.getSubEntity(0).getMaterial().setDepthWriteEnabled(False)
+        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
         self.xMoveNode = self.pivotNode.createChildSceneNode()
         self.xMoveNode.attachObject(self.xMoveEntity)
         self.xMoveNode.translate(og.Vector3(2, 0, 0))
@@ -59,6 +64,7 @@
 
         self.yMoveEntity = self.sceneManager.createEntity(&quot;EditorYArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
         self.yMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
         self.yMoveNode = self.pivotNode.createChildSceneNode()
         self.yMoveNode.attachObject(self.yMoveEntity)
         self.yMoveNode.translate(og.Vector3(0, 2, 0))
@@ -76,6 +82,7 @@
 
         self.zMoveEntity = self.sceneManager.createEntity(&quot;EditorZArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
         self.zMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
         self.zMoveNode = self.pivotNode.createChildSceneNode()
         self.zMoveNode.attachObject(self.zMoveEntity)
         self.zMoveNode.translate(og.Vector3(0, 0, 2))
@@ -90,6 +97,7 @@
     def __createRotatePivot(self):
         self.xRotateEntity = self.sceneManager.createEntity(&quot;EditorXRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
         self.xRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
         self.xRotateNode = self.pivotNode.createChildSceneNode()
         self.xRotateNode.attachObject(self.xRotateEntity)
         #self.xRotateNode.translate(0, 0, -5)
@@ -97,6 +105,7 @@
 
         self.yRotateEntity = self.sceneManager.createEntity(&quot;EditorYRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
         self.yRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
         self.yRotateNode = self.pivotNode.createChildSceneNode()
         self.yRotateNode.attachObject(self.yRotateEntity)
         #self.yRotateNode.translate(0, 0, -10)
@@ -104,10 +113,10 @@
 
         self.zRotateEntity = self.sceneManager.createEntity(&quot;EditorZRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
         self.zRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY)
         self.zRotateNode = self.pivotNode.createChildSceneNode()
         self.zRotateNode.attachObject(self.zRotateEntity)
 
-        pass
 
     def __createScalePivot(self):
         pass
@@ -128,6 +137,7 @@
 
     def hide(self):
         self.pivotNode.removeAllChildren()
+        self.isHidden = True
 
     def show(self):
         self.hide()
@@ -140,7 +150,8 @@
             self.pivotNode.addChild(self.yRotateNode)
             self.pivotNode.addChild(self.zRotateNode)
         elif self.mode == 3:
-            pass
+            return
+        self.isHidden = False
 
     def setMoveMode(self):
         self.hide()
@@ -163,34 +174,42 @@
 
     def onMouseMoved(self, globalX, globalY, incX, incY):
         # move mode
-        if self.mode == 1:
-            transFactor = 0.1
-            transVec = None
-            if self.moveDirection == &quot;EditorXArrow&quot;:
-                transVec = og.Vector3(-incX, 0.0 , 0.0)
-            elif self.moveDirection == &quot;EditorYArrow&quot;:
-                transVec = og.Vector3(0.0, -incY, 0.0)
-            elif self.moveDirection == &quot;EditorZArrow&quot;:
-                transVec = og.Vector3(0.0, 0.0, incX)
+        if self.isTransforming:
+            if self.mode == 1:
+                transFactor = 0.1
+                transVec = og.Vector3()
+                if self.moveDirection == &quot;EditorXArrow&quot;:
+                    transVec = og.Vector3(-incX, 0.0 , 0.0)
+                elif self.moveDirection == &quot;EditorYArrow&quot;:
+                    transVec = og.Vector3(0.0, -incY, 0.0)
+                elif self.moveDirection == &quot;EditorZArrow&quot;:
+                    transVec = og.Vector3(0.0, 0.0, incX)
 
-            transVec = transVec * transFactor
-            for so in self.selectionList:
-                so.entity.getParentNode().translate(transVec)
+                transVec = transVec * transFactor
+                for so in self.selectionList:
+                    so.entity.getParentNode().translate(transVec)
 
-            self.pivotNode.translate(transVec)
+                self.pivotNode.translate(transVec)
 
-        # rotate mode
-        elif self.mode == 2:
-            rotValue = (incX + incY) * 0.05
+            # rotate mode
+            elif self.mode == 2:
+                rotValue = (incX + incY) * 0.05
 
-            if self.moveDirection == &quot;EditorXRotator&quot;:
-                for so in self.selectionList:
-                    so.entity.getParentNode().pitch(rotValue)
-            if self.moveDirection == &quot;EditorYRotator&quot;:
-                for so in self.selectionList:
-                    so.entity.getParentNode().yaw(rotValue)
-            if self.moveDirection == &quot;EditorZRotator&quot;:
-                for so in self.selectionList:
-                    so.entity.getParentNode().roll(rotValue)
+                if self.moveDirection == &quot;EditorXRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().pitch(rotValue)
+                if self.moveDirection == &quot;EditorYRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().yaw(rotValue)
+                if self.moveDirection == &quot;EditorZRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().roll(rotValue)
 
-        pass
+        self.update()
+
+    def update(self):
+        if not self.isHidden:
+            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
+            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
+
+

Added: rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyModel.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -0,0 +1,38 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+
+from Property import *
+
+class ObjectPropertyModel():
+    def __init__(self):
+        self.numProperties = 0
+        self.currentObject = None
+        self.properties = []
+
+    def getNumProperies(self):
+        return self.numProperties
+
+    # sets the current object whose properties are displayed
+    def setSingleObject(self, so):
+        self.currentObject = so
+        self.__parseProperties()
+
+    def __parseProperties(self):
+        node = self.currentObject.entity.getParentNode()

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -22,6 +22,8 @@
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+from Property import *
+
 class ObjectPropertyWin(QDialog):
     def __init__(self, parent=None):
         super(QDialog, self).__init__(parent)
@@ -30,7 +32,6 @@
         self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
                                self.onItemClicked)
 
-
     def setupUi(self):
         self.setObjectName(&quot;ObjectPropertys&quot;)
         self.resize(QSize(QRect(0,0,761,724).size()).expandedTo(self.minimumSizeHint()))
@@ -44,27 +45,10 @@
         QMetaObject.connectSlotsByName(self)
 
     def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Object Properties&quot;, None, QApplication.UnicodeUTF8))
         self.treeWidget.headerItem().setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Property&quot;, None, QApplication.UnicodeUTF8))
         self.treeWidget.headerItem().setText(1,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Value&quot;, None, QApplication.UnicodeUTF8))
         self.treeWidget.clear()
 
-        item = QTreeWidgetItem(self.treeWidget)
-        item.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Position&quot;, None, QApplication.UnicodeUTF8))
-        item.setText(1,&quot;&quot;)
 
-        item1 = QTreeWidgetItem(item)
-        item1.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;X&quot;, None, QApplication.UnicodeUTF8))
-        item1.setText(1,&quot;&quot;)
-
-        item2 = QTreeWidgetItem(item)
-        item2.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Y&quot;, None, QApplication.UnicodeUTF8))
-        item2.setText(1,&quot;&quot;)
-
-        item3 = QTreeWidgetItem(item)
-        item3.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Z&quot;, None, QApplication.UnicodeUTF8))
-        item3.setText(1,&quot;&quot;)
-
     def onItemClicked(self, item, column):
-        print item.text(0)
-        print column
+        pass

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -263,12 +263,12 @@
     def calculateSelectionRay(self,  event):
         relMousePos = self.ogreRenderWindow.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
 
-        if self.lastSelectionClick != None:
-            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-                return
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
 
         self.lastSelectionClick = relMousePos
         screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())

Modified: rl/trunk/editors/Lockenwickler/src/Property.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Property.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/Property.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -16,16 +16,31 @@
  # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
 
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
 
-class Property():
+class Vector3Property():
     def __init__(self):
         pass
 
-    def setValue(self):
-        pass
+    def __parseValues(self):
+        self.vector3 = self.so.entity.getParentNode().getPosition()
+        self.__createTree()
 
-    def getValue(self):
-        pass
+    def __createTree(self):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Position&quot;, None, QApplication.UnicodeUTF8))
+        item.setText(1, str(self.vector3.x) + &quot; , &quot; + str(self.vector3.y) +&quot; , &quot; + str(self.vector3.z))
 
-    def createEditor(self):
-        pass
+        item1 = QTreeWidgetItem(item)
+        item1.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;X&quot;, None, QApplication.UnicodeUTF8))
+        item1.setText(1, str(self.vector3.x))
+
+        item2 = QTreeWidgetItem(item)
+        item2.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Y&quot;, None, QApplication.UnicodeUTF8))
+        item2.setText(1, str(self.vector3.y))
+
+        item3 = QTreeWidgetItem(item)
+        item3.setText(0,QApplication.translate(&quot;ObjectPropertys&quot;, &quot;Z&quot;, None, QApplication.UnicodeUTF8))
+        item3.setText(1, str(self.vector3.z))
+

Modified: rl/trunk/editors/Lockenwickler/src/ViewportGrid.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ViewportGrid.py	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/ViewportGrid.py	2008-10-16 17:33:16 UTC (rev 4550)
@@ -26,29 +26,29 @@
     def __init__(self, pSceneMgr, pViewport):
         super(ViewportGrid, self).__init__()
 
-        self.m_pSceneMgr = pSceneMgr
-        self.m_pViewport = pViewport
-        self.m_enabled = False
-        self.m_layer = None
+        self.sceneManager = pSceneMgr
+        self.viewport = pViewport
+        self.enabled = False
+        self.layer = None
 
-        self.m_pPrevCamera = None
-        self.m_prevOrtho = False
-        self.m_prevCamPos = None
-        self.m_prevNear = None
-        self.m_prevFOVy = None
-        self.m_prevAspectRatio = None
-        self.m_forceUpdate = True
+        self.prevCamera = None
+        self.prevOrtho = False
+        self.prevCamPos = None
+        self.prevNear = None
+        self.prevOrtho = None
+        self.prevAspectRatio = None
+        self.bForceUpdate = True
 
-        self.m_pGrid = None
-        self.m_created = False
-        self.m_pNode = None
+        self.pGrid = None
+        self.created = False
+        self.pNode = None
 
-        self.m_colour1 = og.ColourValue(0.7, 0.7, 0.7)
-        self.m_colour2 = og.ColourValue(0.7, 0.7, 0.7)
-        self.m_division = 10
-        self.m_perspSize = 100
-        self.m_renderScale = True
-        self.m_renderMiniAxes = True
+        self.colour1 = og.ColourValue(0.7, 0.7, 0.7)
+        self.colour2 = og.ColourValue(0.7, 0.7, 0.7)
+        self.division = 10
+        self.perspSize = 100
+        self.renderScale = True
+        self.renderMiniAxes = True
 
         self.sMatName = &quot;ViewportGrid&quot;
 
@@ -56,90 +56,90 @@
         self.setRenderLayer(RL_BEHIND)
 
         # Add this as a render target listener
-        self.m_pViewport.getTarget().addListener(self)
+        self.viewport.getTarget().addListener(self)
 
 
     def getColour(self):
-        return m_colour1
+        return colour1
 
     def setColour(self, colour):
         # Force alpha = 1 for the primary colour
-        self.m_colour1 = colour
-        self.m_colour1.a = 1.0
-        self.m_colour2 = m_colour1
+        self.colour1 = colour
+        self.colour1.a = 1.0
+        self.colour2 = colour1
         self.forceUpdate()
 
     #Grid division (the number of new lines that are created when zooming in).
     def getDivision(self):
-        return m_division
+        return division
 
     def setDivision(self, division):
-        self.m_division = division
+        self.division = division
         self.forceUpdate()
 
     #//! Grid render layer (behind of in front of the objects).
     def getRenderLayer(self):
-        return m_layer
+        return layer
 
     def setRenderLayer(self, layer):
-        self.m_layer = layer
+        self.layer = layer
 
-        if self.m_layer == RL_BEHIND:
+        if self.layer == RL_BEHIND:
             # Render just before the world geometry
-            self.m_pGrid.setRenderQueueGroup(og.RENDER_QUEUE_WORLD_GEOMETRY_1 - 1)
-        elif self.m_layer == RL_INFRONT:
+            self.pGrid.setRenderQueueGroup(og.RENDER_QUEUE_WORLD_GEOMETRY_1 - 1)
+        elif self.layer == RL_INFRONT:
             # Render just before the overlays
-            self.m_pGrid.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+            self.pGrid.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
 
 
     def getPerspectiveSize(self):
-        return m_perspSize
+        return perspSize
 
     def setPerspectiveSize(self, size):
-        self.m_perspSize = size
+        self.perspSize = size
         self.forceUpdate()
 
 #       //! Render scaling info? Defaults to true.
 #       //! @todo Implement this
     def getRenderScale(self):
-        return m_renderScale
+        return renderScale
 
     def setRenderScale(self, enabled = True):
-        self.m_renderScale = enabled
+        self.renderScale = enabled
         self.forceUpdate()
 
 #       //! Render mini axes? Defaults to true.
 #       //! @todo Implement this
     def getRenderMiniAxes(self):
-        return m_renderMiniAxes
+        return renderMiniAxes
 
     def setRenderMiniAxes(self, enabled = True):
-        self.m_renderMiniAxes = enabled
+        self.renderMiniAxes = enabled
         self.forceUpdate()
 
     #// Enable / disable
     def isEnabled(self):
-        return m_enabled
+        return self.enabled
 
     def enable(self):
-        self.m_enabled = True
+        self.enabled = True
 
-        if not self.m_pGrid.isAttached():
-            self.m_pNode.attachObject(self.m_pGrid)
+        if not self.pGrid.isAttached():
+            self.pNode.attachObject(self.pGrid)
 
         self.forceUpdate()
 
 
     def disable(self):
-        self.m_enabled = False
+        self.enabled = False
 
-        if self.m_pGrid.isAttached():
-            self.m_pNode.detachObject(self.m_pGrid)
+        if self.pGrid.isAttached():
+            self.pNode.detachObject(self.pGrid)
 
 
 
     def  toggle(self):
-        self.setEnabled(not self.m_enabled)
+        self.setEnabled(not self.enabled)
 
     def setEnabled(self, enabled):
         if enabled:
@@ -149,34 +149,34 @@
 
 
     def forceUpdate(self):
-        self.m_forceUpdate = True
+        self.bForceUpdate = True
 
     def preViewportUpdate(self, evt):
-       #TODO find out why evt.souce and self.m_pViewport differ in their memory address
-       # if evt.source != self.m_pViewport:
+       #TODO find out why evt.souce and self.viewport differ in their memory address
+       # if evt.source != self.viewport:
            # return
 
-        self.m_pGrid.setVisible(True)
+        self.pGrid.setVisible(True)
 
-        if self.m_enabled:
+        if self.enabled:
             self.__update()
 
     def postViewportUpdate(self, evt):
-       # if evt.source != self.m_pViewport:
+       # if evt.source != self.viewport:
            # return
-        self.m_pGrid.setVisible(False)
+        self.pGrid.setVisible(False)
 
     def __createGrid(self):
-        name = self.m_pViewport.getTarget().getName() + &quot;::&quot;
-        name += str(self.m_pViewport.getZOrder()) + &quot;::ViewportGrid&quot;
+        name = self.viewport.getTarget().getName() + &quot;::&quot;
+        name += str(self.viewport.getZOrder()) + &quot;::ViewportGrid&quot;
 
         #// Create the manual object
-        self.m_pGrid = self.m_pSceneMgr.createManualObject(name)
-        self.m_pGrid.setDynamic(True)
+        self.pGrid = self.sceneManager.createManualObject(name)
+        self.pGrid.setDynamic(True)
 
         #// Create the scene node (not attached yet)
-        self.m_pNode = self.m_pSceneMgr.getRootSceneNode().createChildSceneNode(name)
-        self.m_enabled = False
+        self.pNode = self.sceneManager.getRootSceneNode().createChildSceneNode(name)
+        self.enabled = False
 
         #// Make sure the material is created
         #//! @todo Should we destroy the material somewhere?
@@ -189,23 +189,23 @@
 
 
     def __destroyGrid(self):
-        self.m_pSceneMgr.destroyManualObject(self.m_pGrid)
-        self.m_pGrid = None
+        self.sceneManager.destroyManualObject(self.pGrid)
+        self.pGrid = None
 
-        self.m_pSceneMgr.destroySceneNode(self.m_pNode.getName())
-        self.m_pNode = None
+        self.sceneManager.destroySceneNode(self.pNode.getName())
+        self.pNode = None
 
 
     def __update(self):
-        if not self.m_enabled:
+        if not self.enabled:
             return
 
-        pCamera = self.m_pViewport.getCamera()
+        pCamera = self.viewport.getCamera()
         if not pCamera:
             return
 
         # Check if an update is necessary
-        if not self.__checkUpdate() and not self.m_forceUpdate:
+        if not self.__checkUpdate() and not self.bForceUpdate:
             return
 
         if pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC:
@@ -213,17 +213,17 @@
         else:
             self.__updatePersp()
 
-        self.m_forceUpdate = False
+        self.bForceUpdate = False
 
 
 
     def __updateOrtho(self):
         # Screen dimensions
-        width = self.m_pViewport.getActualWidth()
-        height = self.m_pViewport.getActualHeight()
+        width = self.viewport.getActualWidth()
+        height = self.viewport.getActualHeight()
 
         #Camera information
-        pCamera = m_pViewport.getCamera()
+        pCamera = pViewport.getCamera()
         camPos = pCamera.getPosition()
         camDir = pCamera.getDirection()
         camUp = pCamera.getUp()
@@ -246,7 +246,7 @@
         worldToScreen = width / worldWidth
         screenToWorld = worldWidth / width
 
-        # TODO Treshold should be dependent on window width/height (min? max?) so there are no more then m_division full alpha-lines
+        # TODO Treshold should be dependent on window width/height (min? max?) so there are no more then division full alpha-lines
         treshold = 10 # Treshhold in pixels
 
         # Calculate the spacing multiplier
@@ -258,18 +258,18 @@
                 exp = exp +1
                 temp = temp * treshold # TODO maybe wrong
 
-            mult = og.Math.Pow(self.m_division, exp)
+            mult = og.Math.Pow(self.division, exp)
         else:
-            while temp &gt; (self.m_division * treshold):
+            while temp &gt; (self.division * treshold):
                 exp = exp +1
                 temp = temp / treshold # TODO maybe wrong
 
-            mult = og.Math.Pow(1.0 / self.m_division, exp)
+            mult = og.Math.Pow(1.0 / self.division, exp)
 
-        # Interpolate alpha for (multiplied) spacing between treshold and m_division * treshold
-        self.m_colour2.a = worldToScreen * mult / (m_division * treshold - treshold)
-        if m_colour2.a &gt; 1.0:
-           self.m_colour2.a = 1.0
+        # Interpolate alpha for (multiplied) spacing between treshold and division * treshold
+        self.colour2.a = worldToScreen * mult / (division * treshold - treshold)
+        if colour2.a &gt; 1.0:
+           self.colour2.a = 1.0
 
         # Calculate the horizontal zero-axis color
         camRightX = og.Math.Abs(camRight.x)
@@ -283,7 +283,7 @@
         elif og.Math.RealEqual(camRightZ, 1.0):
             horAxisColor = og.ColourValue.Blue
         else:
-            horAxisColor = self.m_colour1
+            horAxisColor = self.colour1
 
         # Calculate the vertical zero-axis color
         camUpX = og.Math.Abs(camUp.x)
@@ -297,19 +297,19 @@
         elif og.Math.RealEqual(camUpZ, 1.0):
             horAxisColor = og.ColourValue.Blue
         else:
-            horAxisColor = self.m_colour1
+            horAxisColor = self.colour1
 
         # The number of lines
         numLinesWidth = int((worldWidth / mult) + 1)
         numLinesHeight = int((worldHeight / mult) + 1)
 
         # Start creating or updating the grid
-        self.m_pGrid.estimateVertexCount(2 * numLinesWidth + 2 * numLinesHeight)
-        if m_created:
-            self.m_pGrid.beginUpdate(0)
+        self.pGrid.estimateVertexCount(2 * numLinesWidth + 2 * numLinesHeight)
+        if created:
+            self.pGrid.beginUpdate(0)
         else:
-            self.m_pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
-            self.m_created = True
+            self.pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
+            self.created = True
 
         # Vertical lines
         startX = mult * int(worldLeft / mult)
@@ -326,19 +326,19 @@
 
             if multX == 0:
                 colour = vertAxisColor
-            elif multX % (int(self.m_division)):
-                self.m_colour2
+            elif multX % (int(self.division)):
+                self.colour2
             else:
-                self.m_colour1
+                self.colour1
 
 
 
 
             # Add the line
-            self.m_pGrid.position(x, worldBottom, 0)
-            self.m_pGrid.colour(colour)
-            self.m_pGrid.position(x, worldTop, 0)
-            self.m_pGrid.colour(colour)
+            self.pGrid.position(x, worldBottom, 0)
+            self.pGrid.colour(colour)
+            self.pGrid.position(x, worldTop, 0)
+            self.pGrid.colour(colour)
 
             x += mult
 
@@ -355,24 +355,24 @@
             else:
                 multY = int(y / mult + 0.5)
 
-            #colour = (multY == 0) ? horAxisColor : (multY % int(m_division)) ? self.m_colour2 : self.m_colour1
+            #colour = (multY == 0) ? horAxisColor : (multY % int(division)) ? self.colour2 : self.colour1
             if multY == 0:
                 colour = horAxisColor
-            elif multY % (int(self.m_division)):
-                self.m_colour2
+            elif multY % (int(self.division)):
+                self.colour2
             else:
-                self.m_colour1
+                self.colour1
 
-            self.m_pGrid.position(worldLeft, y, 0)
-            self.m_pGrid.colour(colour)
-            self.m_pGrid.position(worldRight, y, 0)
-            self.m_pGrid.colour(colour)
+            self.pGrid.position(worldLeft, y, 0)
+            self.pGrid.colour(colour)
+            self.pGrid.position(worldRight, y, 0)
+            self.pGrid.colour(colour)
 
             y += mult
 
-        self.m_pGrid.end()
+        self.pGrid.end()
 
-        self.m_pNode.setOrientation(pCamera.getOrientation())
+        self.pNode.setOrientation(pCamera.getOrientation())
 
 
     def __updatePersp(self):
@@ -380,8 +380,8 @@
         mult = 1
 
         #! @todo Interpolate alpha
-        self.m_colour2.a = 0.5
-        #if(m_colour2.a &gt; 1.0f) m_colour2.a = 1.0f
+        self.colour2.a = 0.5
+        #if(colour2.a &gt; 1.0f) colour2.a = 1.0f
 
         # Calculate the horizontal zero-axis color
         horAxisColor = og.ColourValue.Red
@@ -390,20 +390,20 @@
         vertAxisColor = og.ColourValue.Blue
 
         # The number of lines
-        numLines = int(self.m_perspSize / mult) + 1
+        numLines = int(self.perspSize / mult) + 1
 
         # Start creating or updating the grid
-        self.m_pGrid.estimateVertexCount(4 * numLines)
-        if self.m_created:
-            self.m_pGrid.beginUpdate(0)
+        self.pGrid.estimateVertexCount(4 * numLines)
+        if self.created:
+            self.pGrid.beginUpdate(0)
         else:
-            self.m_pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
-            self.m_created = True
+            self.pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
+            self.created = True
 
         # Vertical lines
-        start = mult * int(-self.m_perspSize / 2 / mult)
+        start = mult * int(-self.perspSize / 2 / mult)
         x = start
-        while x &lt;= (self.m_perspSize / 2):
+        while x &lt;= (self.perspSize / 2):
             # Get the right color for this line
             #multX = (x == 0) ? x : (x &lt; 0) ? int(x / mult - 0.5f) : int(x / mult + 0.5f)
             if x == 0:
@@ -413,25 +413,25 @@
             else:
                 multX = int(x / mult +0.5)
 
-            #colour = (multX == 0) ? vertAxisColor : (multX % (int) self.m_division) ? self.m_colour2 : self.m_colour1
+            #colour = (multX == 0) ? vertAxisColor : (multX % (int) self.division) ? self.colour2 : self.colour1
             if multX == 0:
                 colour = vertAxisColor
-            elif multX % int(self.m_division):
-                colour = self.m_colour2
+            elif multX % int(self.division):
+                colour = self.colour2
             else:
-                colour = self.m_colour1
+                colour = self.colour1
 
             # Add the line
-            self.m_pGrid.position(x, 0, -self.m_perspSize / 2)
-            self.m_pGrid.colour(colour)
-            self.m_pGrid.position(x, 0, self.m_perspSize / 2)
-            self.m_pGrid.colour(colour)
+            self.pGrid.position(x, 0, -self.perspSize / 2)
+            self.pGrid.colour(colour)
+            self.pGrid.position(x, 0, self.perspSize / 2)
+            self.pGrid.colour(colour)
 
             x += mult
 
         # Horizontal lines
         y = start
-        while y &lt;= (self.m_perspSize / 2):
+        while y &lt;= (self.perspSize / 2):
             # Get the right color for this line
             #multY = (y == 0) ? y : (y &lt; 0) ? int(y / mult - 0.5f) : int(y / mult + 0.5f)
             if y == 0:
@@ -441,50 +441,50 @@
             else:
                 multY = int(y / mult +0.5)
 
-            #colour = (multY == 0) ? horAxisColor : (multY % int(self.m_division)) ? self.m_colour2 : self.m_colour1
+            #colour = (multY == 0) ? horAxisColor : (multY % int(self.division)) ? self.colour2 : self.colour1
             if multY == 0:
                 colour = horAxisColor
-            elif multY % int(self.m_division):
-                colour = self.m_colour2
+            elif multY % int(self.division):
+                colour = self.colour2
             else:
-                colour = self.m_colour1
+                colour = self.colour1
             # Add the line
-            self.m_pGrid.position(-self.m_perspSize / 2, 0, y)
-            self.m_pGrid.colour(colour)
-            self.m_pGrid.position(self.m_perspSize / 2, 0, y)
-            self.m_pGrid.colour(colour)
+            self.pGrid.position(-self.perspSize / 2, 0, y)
+            self.pGrid.colour(colour)
+            self.pGrid.position(self.perspSize / 2, 0, y)
+            self.pGrid.colour(colour)
 
             y += mult
 
-        self.m_pGrid.end()
+        self.pGrid.end()
 
         # Normal orientation, grid in the X-Z plane
-        self.m_pNode.resetOrientation()
+        self.pNode.resetOrientation()
 
 
     def __checkUpdate(self):
         update = False
 
-        pCamera = self.m_pViewport.getCamera()
+        pCamera = self.viewport.getCamera()
         if not pCamera:
             return False
 
-        if pCamera is not self.m_pPrevCamera:
-            self.m_pPrevCamera = pCamera
+        if pCamera is not self.prevCamera:
+            self.prevCamera = pCamera
             update = True
 
 
         ortho = (pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC)
-        if ortho is not self.m_prevOrtho:
-            self.m_prevOrtho = ortho
+        if ortho is not self.prevOrtho:
+            self.prevOrtho = ortho
             update = True
 
             # Set correct material properties
-            pMaterial = MaterialManager.getSingleton().getByName(self.sMatName)
-            if not pMaterial.isNull():
-                pMaterial.setDepthWriteEnabled(not ortho)
-                pMaterial.setDepthCheckEnabled(not ortho)
+            pMaterial = og.MaterialManager.getSingleton().getByName(self.sMatName)
 
+            pMaterial.setDepthWriteEnabled(not ortho)
+            pMaterial.setDepthCheckEnabled(not ortho)
+
         #return update || ortho ? checkUpdateOrtho() : checkUpdatePersp()
         if update:
             if ortho:
@@ -498,24 +498,24 @@
     def __checkUpdateOrtho(self):
         update = False
 
-        pCamera = self.m_pViewport.getCamera()
+        pCamera = self.viewport.getCamera()
         if not pCamera:
             return False
 
-        if pCamera.getPosition() is not self.m_prevCamPos:
-            self.m_prevCamPos = pCamera.getPosition()
+        if pCamera.getPosition() is not self.prevCamPos:
+            self.prevCamPos = pCamera.getPosition()
             update = True
 
-        if pCamera.getNearClipDistance() is not self.m_prevNear:
-            self.m_prevNear = pCamera.getNearClipDistance()
+        if pCamera.getNearClipDistance() is not self.prevNear:
+            self.prevNear = pCamera.getNearClipDistance()
             update = True
 
-        if pCamera.getFOVy() is not self.m_prevFOVy:
-            self.m_prevFOVy = pCamera.getFOVy()
+        if pCamera.getFOVy() is not self.prevOrtho:
+            self.prevOrtho = pCamera.getFOVy()
             update = True
 
-        if pCamera.getAspectRatio() is not self.m_prevAspectRatio:
-            self.m_prevAspectRatio = pCamera.getAspectRatio()
+        if pCamera.getAspectRatio() is not self.prevAspectRatio:
+            self.prevAspectRatio = pCamera.getAspectRatio()
             update = True
 
         return update

Modified: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2008-10-12 18:04:43 UTC (rev 4549)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2008-10-16 17:33:16 UTC (rev 4550)
@@ -4,10 +4,12 @@
 	{
 		pass
 		{
-			ambient 1.0 0.0 0.0 1.0
-			diffuse 1.0 0.0 0.0 1.0
-			specular 1.0 0.0 0.0 1.0 12.5
-			emissive 1.0 0.0 0.0 1.0
+                        depth_check off
+                        depth_write off
+			ambient 1.0 0.0 0.0 0.5
+			diffuse 1.0 0.0 0.0 0.5
+			specular 1.0 0.0 0.0 0.5 12.5
+			emissive 1.0 0.0 0.0 0.5
 		}
 	}
 }
@@ -16,12 +18,15 @@
 {
 	technique
 	{
+
 		pass
 		{
-			ambient 0.0 0.0 1.0 1.0
-			diffuse 0.0 0.0 1.0 1.0
-			specular 0.0 0.0 1.0 1.0 12.5
-			emissive 0.0 0.0 1.0 1.0
+                        depth_check off
+                        depth_write off
+			ambient 0.0 0.0 1.0 0.5
+			diffuse 0.0 0.0 1.0 0.5
+			specular 0.0 0.0 1.0 0.5 12.5
+			emissive 0.0 0.0 1.0 0.5
 		}
 	}
 }
@@ -32,10 +37,12 @@
 	{
 		pass
 		{
-			ambient 0.0 1.0 0.0 1.0
-			diffuse 0.0 1.0 0.0 1.0
-			specular 0.0 1.0 0.0 1.0 12.5
-			emissive 0.0 1.0 0.0 1.0
+                        depth_check off
+                        depth_write off
+			ambient 0.0 1.0 0.0 0.5
+			diffuse 0.0 1.0 0.0 0.5
+			specular 0.0 1.0 0.0 0.5 12.5
+			emissive 0.0 1.0 0.0 0.5
 		}
 	}
 }
@@ -46,10 +53,10 @@
 	{
 		pass
 		{
-			ambient 0.0 0.0 0.0 1.0
-			diffuse 0.0 0.0 0.0 1.0
-			specular 0.0 0.0 0.0 1.0 12.5
-			emissive 0.0 0.0 0.0 1.0
+			ambient 0.0 0.0 0.0 0.5
+			diffuse 0.0 0.0 0.0 0.5
+			specular 0.0 0.0 0.0 0.5 12.5
+			emissive 0.0 0.0 0.0 0.5
 		}
 	}
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001606.html">[Dsa-hl-svn] r4549 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
	<LI>Next message: <A HREF="001608.html">[Dsa-hl-svn] r4551 - in rl/branches/persistence/core: . include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1607">[ date ]</a>
              <a href="thread.html#1607">[ thread ]</a>
              <a href="subject.html#1607">[ subject ]</a>
              <a href="author.html#1607">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
