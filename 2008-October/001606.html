<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4549 - in rl/trunk/editors/Lockenwickler: . src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4549%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%20src&In-Reply-To=%3C200810121804.m9CI4saf019357%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001605.html">
   <LINK REL="Next"  HREF="001607.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4549 - in rl/trunk/editors/Lockenwickler: . src</H1>
    <B>fusion2 at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4549%20-%20in%20rl/trunk/editors/Lockenwickler%3A%20.%20src&In-Reply-To=%3C200810121804.m9CI4saf019357%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4549 - in rl/trunk/editors/Lockenwickler: . src">fusion2 at mail.berlios.de
       </A><BR>
    <I>Sun Oct 12 20:04:54 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001605.html">[Dsa-hl-svn] r4548 - in rl/branches/persistence/rules: include src
</A></li>
        <LI>Next message: <A HREF="001607.html">[Dsa-hl-svn] r4550 - in rl/trunk/editors/Lockenwickler: . src	src/media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1606">[ date ]</a>
              <a href="thread.html#1606">[ thread ]</a>
              <a href="subject.html#1606">[ subject ]</a>
              <a href="author.html#1606">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fusion2
Date: 2008-10-12 20:04:43 +0200 (Sun, 12 Oct 2008)
New Revision: 4549

Added:
   rl/trunk/editors/Lockenwickler/src/ViewportGrid.py
Removed:
   rl/trunk/editors/Lockenwickler/src/OdeManager.py
   rl/trunk/editors/Lockenwickler/src/ui_lw.py
   rl/trunk/editors/Lockenwickler/src/ui_model_prev.py
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MovePivot.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/OgreWidget.py
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
   rl/trunk/editors/Lockenwickler/src/Property.py
   rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
   rl/trunk/editors/Lockenwickler/src/SceneExplorer.py
Log:
- added GPL headers to all source files
- Object placement works
- added a ViewportGrid class

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Project SYSTEM &quot;Project-4.5.dtd&quot;&gt;
 &lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2008-10-08, 20:52:14 --&gt;
+&lt;!-- Saved: 2008-10-12, 20:02:34 --&gt;
 &lt;!-- Copyright (C) 2008 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;Project version=&quot;4.5&quot;&gt;
   &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
@@ -17,14 +17,11 @@
     &lt;Source&gt;src/ModuleManager.py&lt;/Source&gt;
     &lt;Source&gt;src/MovePivot.py&lt;/Source&gt;
     &lt;Source&gt;src/ObjectPropertyWin.py&lt;/Source&gt;
-    &lt;Source&gt;src/OdeManager.py&lt;/Source&gt;
     &lt;Source&gt;src/OgreMainWindow.py&lt;/Source&gt;
     &lt;Source&gt;src/OgreWidget.py&lt;/Source&gt;
     &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
     &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
     &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/ui_lw.py&lt;/Source&gt;
-    &lt;Source&gt;src/ui_model_prev.py&lt;/Source&gt;
     &lt;Source&gt;src/ui_pref_dialog.py&lt;/Source&gt;
     &lt;Source&gt;ui files/batch_convert_ui.py&lt;/Source&gt;
     &lt;Source&gt;ui files/ui_ConsoleWindow.py&lt;/Source&gt;
@@ -35,6 +32,7 @@
     &lt;Source&gt;ui files/ui_pref_dialog.py&lt;/Source&gt;
     &lt;Source&gt;src/SceneExplorer.py&lt;/Source&gt;
     &lt;Source&gt;src/Property.py&lt;/Source&gt;
+    &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
   &lt;/Sources&gt;
   &lt;Forms&gt;
     &lt;Form&gt;ui files/console_window.ui&lt;/Form&gt;

Modified: rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import sys
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
@@ -23,7 +42,6 @@
         self.consoleWindow = Ui_ConsoleWindow()
         self.consoleWindow.setupUi(self)
         self.consoleWindow.textEdit.setReadOnly(True)
-
         self.lockenLog = LockenLog(self.write)
 
         sys.stdout = self

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import os
 import sys
 import platform

Modified: rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import sys
 import os
 from os.path import isdir
@@ -3,19 +22,37 @@
 from os.path import isfile
 
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
 import OgreWidget
 import ogre.renderer.OGRE as og
-from PyQt4 import QtGui, QtCore
 
-class ModelSelectionDialog(QtGui.QDialog):
+
+class MyListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MyListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream &lt;&lt; self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData(&quot;application/x-text&quot;, data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class ModelSelectionDialog(QDialog):
     def __init__(self, ogreRoot, parent=None):
-        QtGui.QDialog.__init__(self, parent)
+        QDialog.__init__(self, parent)
         self.ogreRoot = ogreRoot
 
         self.setupUi()
 
-        QtCore.QObject.connect(self.modelSearchBox, QtCore.SIGNAL(&quot;textChanged(QString)&quot;),
+        self.connect(self.modelSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
                                self.updateModelList)
 
-        QtCore.QObject.connect(self.listWidget, QtCore.SIGNAL(&quot;itemSelectionChanged ()&quot;),
+        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
                                self.setPreviewedModel)
 
@@ -31,37 +68,39 @@
         self.lastMousePosX = 0
         self.lastMousePosY = 0
 
+
+
     def setupUi(self):
         self.setObjectName(&quot;modelPreviewDialog&quot;)
-        self.resize(QtCore.QSize(QtCore.QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
 
-        self.gridlayout = QtGui.QGridLayout(self)
+        self.gridlayout = QGridLayout(self)
         self.gridlayout.setObjectName(&quot;gridlayout&quot;)
 
-        self.modelSearchBox = QtGui.QLineEdit(self)
+        self.modelSearchBox = QLineEdit(self)
         self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)
         self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
 
-        self.splitter = QtGui.QSplitter(self)
-        self.splitter.setOrientation(QtCore.Qt.Vertical)
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
         self.splitter.setObjectName(&quot;splitter&quot;)
 
-        self.listWidget = QtGui.QListWidget(self.splitter)
+        self.listWidget = MyListWidget(self.splitter)
         self.listWidget.setObjectName(&quot;listWidget&quot;)
 
         self.ogreModelPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreModelPrevWindowSceneMgr&quot;)
         self.ogreModelPrevWindow = OgreWidget.OgreWidget(&quot;ModelPrevWin&quot;, self.ogreRoot, self.ogreModelPrevWindowSceneMgr, &quot;PrevCam&quot;,
                                                          self.splitter)
-        self.ogreModelPrevWindow.setMinimumSize(QtCore.QSize(200,200))
+        self.ogreModelPrevWindow.setMinimumSize(QSize(200,200))
         self.ogreModelPrevWindow.setObjectName(&quot;modelPreviewWindow&quot;)
         self.gridlayout.addWidget(self.splitter,1,0,1,1)
 
         self.retranslateUi()
-        QtCore.QObject.connect(self.modelSearchBox,QtCore.SIGNAL(&quot;textChanged(QString)&quot;),self.listWidget.clearSelection)
-        QtCore.QMetaObject.connectSlotsByName(self)
+        QObject.connect(self.modelSearchBox,SIGNAL(&quot;textChanged(QString)&quot;),self.listWidget.clearSelection)
+        QMetaObject.connectSlotsByName(self)
 
     def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.setWindowTitle(QApplication.translate(&quot;modelPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
 
     def setPreviewedModel(self):
         if self.ent != None:
@@ -99,7 +138,13 @@
 
         self.listWidget.sortItems()
 
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
 
+        return False
+
     def event(self, event):
         if event.type() == 31: # scroll wheel turned
             if event.delta() &lt; 0:
@@ -108,17 +153,18 @@
                 self.ogreModelPrevWindow.zoomCamera( 5)
 
         if event.type() == 5: #mouse moved while button down
-           rotX = (event.globalX() - self.lastMousePosX) * 0.01
-           rotY = (event.globalY() - self.lastMousePosY) * 0.01
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
 
-           if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
-               self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
+            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
+                self.ogreModelPrevWindow.orbitCamera(-rotX,  rotY)
 
-           self.lastMousePosX = event.globalX()
-           self.lastMousePosY = event.globalY()
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
 
         if event.type() == 3: # mouse released
             self.lastMousePosX = 0
             self.lastMousePosY = 0
 
         return False
+

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,21 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
 import sys
 import xml.dom.minidom as xml
 
@@ -52,10 +70,12 @@
             return -1
 
     def queryResult ( self, entity, distance ):
-        #print entity.getName()
+        #print &quot;dbg: &quot; + entity.getName()
         if distance == 0.0: #camera is in the bounding box, ignore this selection
             return True
-        elif entity.getName() == &quot;rayLine&quot; :
+#        elif entity.getName() == &quot;rayLine&quot; :
+#            return True
+        elif entity.getName() == &quot;OgreMainWin::0::ViewportGrid&quot;:
             return True
         elif entity.isVisible() and entity.getName() == &quot;EditorXArrow&quot;:
             so = SelectionObject(entity,  distance)
@@ -296,7 +316,7 @@
         self.listenerDings = MyRaySceneQueryListener()
 
         self.lastRay = None
-        self.rayLine = None
+#        self.rayLine = None
 
         self.pivot = None
         self.movingPivot = False
@@ -305,6 +325,11 @@
         self.middleMouseDown = False
         self.rightMouseDown = False
 
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
+
     def load(self,  moduleName,  mapFiles):
         self.moduleName = moduleName
         self.mapFiles = mapFiles
@@ -375,7 +400,8 @@
         so = self.listenerDings.rayCastToPolygonLevel(ray)
         if so is not None:
             if not so.isPivot:
-                self.pivot.show()
+                if self.pivot is not None:
+                    self.pivot.show()
                 if not controlDown and not shiftDown:
                     self.resetSelection()
                     so.setSelected(True)
@@ -404,26 +430,26 @@
             if self.pivot is not None:
                 self.pivot.hide()
 
-        if self.rayLine == None:
-            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
-            self.rayLine.setDynamic(True)
-            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+#
+#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
 
-            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
-        else:
-            self.rayLine.beginUpdate(0)
-
-            self.rayLine.position(ray.getOrigin())
-            self.rayLine.position( ray.getPoint(10000))
-
-            self.rayLine.end()
-
     def leftMouseUp(self):
         if self.pivot is not None and self.pivot.isTransforming:
             self.pivot.stopTransforming()
@@ -448,14 +474,35 @@
 
         for so in self.userSelectionList:
             newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
 
-        self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
     def unload(self,  saveOnUnload=True):
         pass
 
     def save(self):
         pass
 
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(self.dropCount), str(meshFile))
+        self.dropNode = self.sceneManager.getRootSceneNode().createChild(&quot;dropNode&quot; + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
 
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
 
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass

Modified: rl/trunk/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,7 +1,25 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import sys
 import ogre.renderer.OGRE as og
 
-
 class Pivot():
     def __init__(self,  sceneManager):
         self.sceneManager = sceneManager
@@ -146,14 +164,16 @@
     def onMouseMoved(self, globalX, globalY, incX, incY):
         # move mode
         if self.mode == 1:
+            transFactor = 0.1
             transVec = None
             if self.moveDirection == &quot;EditorXArrow&quot;:
                 transVec = og.Vector3(-incX, 0.0 , 0.0)
             elif self.moveDirection == &quot;EditorYArrow&quot;:
                 transVec = og.Vector3(0.0, -incY, 0.0)
             elif self.moveDirection == &quot;EditorZArrow&quot;:
-                transVec = og.Vector3(0.0, 0.0, -incX)
+                transVec = og.Vector3(0.0, 0.0, incX)
 
+            transVec = transVec * transFactor
             for so in self.selectionList:
                 so.entity.getParentNode().translate(transVec)
 

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import sys
 
 from PyQt4.QtCore import *

Deleted: rl/trunk/editors/Lockenwickler/src/OdeManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OdeManager.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/OdeManager.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1 +0,0 @@
-as

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import os
 import sys
 import platform
@@ -2,4 +21,7 @@
 
-from PyQt4 import QtGui, QtCore
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
 
+from ViewportGrid import *
+
 import OgreWidget
@@ -9,9 +31,9 @@
 
 # this class is the heart of the 3d part
 # it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QtGui.QWidget):
+class OgreMainWindow(QWidget):
     def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QtGui.QWidget.__init__(self, parent)
+        QWidget.__init__(self, parent)
         self.moduleManager = moduleManager
         self.ogreRoot = ogreRoot
         self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
@@ -29,38 +51,39 @@
         self.strafeCamLeft = False
         self.strafeCamRight = False
 
-        self.camUpdateTimer = QtCore.QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.updateCamera)
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
 
         self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
 
         self.setupUi(self)
 
+
     def setupUi(self, Form):
         Form.setObjectName(&quot;Form&quot;)
-        Form.resize(QtCore.QSize(QtCore.QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
 
-        self.gridlayout = QtGui.QGridLayout(Form)
+        self.gridlayout = QGridLayout(Form)
         self.gridlayout.setObjectName(&quot;gridlayout&quot;)
 
         # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QtGui.QSplitter(Form)
+        self.splitterV = QSplitter(Form)
 
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding,QtGui.QSizePolicy.MinimumExpanding)
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
         self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(QtCore.Qt.Vertical)
+        self.splitterV.setOrientation(Qt.Vertical)
         self.splitterV.setObjectName(&quot;splitter&quot;)
 
         # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QtGui.QToolButton(self)
-        QtCore.QObject.connect(self.ogreWindowOptions, QtCore.SIGNAL(&quot;clicked()&quot;),
+        self.ogreWindowOptions = QToolButton(self)
+        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
                                     self.onPreferencesButton)
         self.ogreWindowOptions.hide()
 
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Minimum)
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
@@ -72,9 +95,9 @@
 
         ##################################
         self.ogreRenderWindow = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
-        self.ogreRenderWindow.setMinimumSize(QtCore.QSize(250,250))
+        self.ogreRenderWindow.setMinimumSize(QSize(250,250))
 
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Maximum)
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
@@ -89,38 +112,40 @@
         # register the eventfilters for the render windows
         # this is needed to catch mouse enter and mouse leave events for these windows
         self.ogreRenderWindow.installEventFilter(self)
-
+        self.ogreRenderWindow.setAcceptDrops(True)
         self.lastMousePosX = 0
         self.lastMousePosY = 0
 
         self.retranslateUi(Form)
-        QtCore.QMetaObject.connectSlotsByName(Form)
+        QMetaObject.connectSlotsByName(Form)
 
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreRenderWindow.viewport)
+        self.viewportGrid.enable()
     def retranslateUi(self, Form):
-        Form.setWindowTitle(QtGui.QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QtGui.QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
+        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
 
     def onPreferencesButton(self):
-        self.splitterH.setOrientation(QtCore.Qt.Vertical)
+        self.splitterH.setOrientation(Qt.Vertical)
 
     def keyPressEvent(self,  event):
-        if event.key() == QtCore.Qt.Key_W:
+        if event.key() == Qt.Key_W:
             self.moveCamForward = True
-        elif event.key() == QtCore.Qt.Key_S:
+        elif event.key() == Qt.Key_S:
             self.moveCamBackward = True
-        elif event.key() == QtCore.Qt.Key_A:
+        elif event.key() == Qt.Key_A:
             self.strafeCamLeft = True
-        elif event.key() == QtCore.Qt.Key_D:
+        elif event.key() == Qt.Key_D:
             self.strafeCamRight= True
 
     def keyReleaseEvent(self,  event):
-        if event.key() == QtCore.Qt.Key_W:
+        if event.key() == Qt.Key_W:
             self.moveCamForward = False
-        elif event.key() == QtCore.Qt.Key_S:
+        elif event.key() == Qt.Key_S:
             self.moveCamBackward = False
-        elif event.key() == QtCore.Qt.Key_A:
+        elif event.key() == Qt.Key_A:
             self.strafeCamLeft = False
-        elif event.key() == QtCore.Qt.Key_D:
+        elif event.key() == Qt.Key_D:
             self.strafeCamRight= False
 
     def eventFilter(self, obj, event):
@@ -179,7 +204,6 @@
             if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
                 self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
 
-
             rotX = incX * 0.01
             rotY = incY * 0.01
 
@@ -191,11 +215,53 @@
             self.lastMousePosX = event.globalX()
             self.lastMousePosY = event.globalY()
 
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+        if event.type() == 62:
+            print &quot;dbg: DragLeave&quot;
+        if event.type() == 63:
+            self.dropEvent(event)
+
         return False
 
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-text&quot;):
+            data = event.mimeData().data(&quot;application/x-text&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropModelAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+
+        event.accept()
+
+    def dropEvent(self, event):
+        self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) # place it down
+        event.accept()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreRenderWindow.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreRenderWindow.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreRenderWindow.viewport.getActualHeight())
+
+        return self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
+
     #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
     def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreRenderWindow.mapFromGlobal(QtCore.QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+        relMousePos = self.ogreRenderWindow.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
 
         if self.lastSelectionClick != None:
             if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
@@ -210,13 +276,14 @@
 
         mouseRay = self.ogreRenderWindow.getCamera().getCameraToViewportRay(screenX, screenY)
 
-        if event.modifiers() == QtCore.Qt.ControlModifier:
+        if event.modifiers() == Qt.ControlModifier:
             self.moduleManager.selectionClick(mouseRay,  True,  False)
-        elif event.modifiers() == QtCore.Qt.ShiftModifier:
+        elif event.modifiers() == Qt.ShiftModifier:
             self.moduleManager.selectionClick(mouseRay,  False,  True)
         else:
             self.moduleManager.selectionClick(mouseRay)
 
+
     def updateCamera(self):
         if self.moveCamForward:
             self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0,-0.2))

Modified: rl/trunk/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/OgreWidget.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import sys
 import platform
 import os
@@ -15,7 +34,6 @@
         self.camDistFromFocusNode = camDistFromFocusNode
         self.initOgreWindow(renderWindowName,cameraName)
 
-
     def initOgreWindow(self, renderWindowName, cameraName):
         self.renderParameters = og.NameValuePairList()
 

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import sys
 import platform
 import string

Modified: rl/trunk/editors/Lockenwickler/src/Property.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Property.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/Property.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,8 +1,31 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 class Property():
     def __init__(self):
+        pass
 
     def setValue(self):
+        pass
 
     def getValue(self):
+        pass
 
     def createEditor(self):
+        pass

Modified: rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/PythonOgreConfig.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 #
 # a single config file that is imported 'first' by the Python-Ogre demos
 # this is primarly used to manage Linux demos when we have binaries in non standard (safe) locations

Modified: rl/trunk/editors/Lockenwickler/src/SceneExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SceneExplorer.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/SceneExplorer.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,3 +1,22 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
 import sys
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *

Added: rl/trunk/editors/Lockenwickler/src/ViewportGrid.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ViewportGrid.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/ViewportGrid.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -0,0 +1,525 @@
+#-----------------------------------------------------------------------------
+#Copyright (c) 2007 Jeroen Dierckx
+#Python Version by Stefan Stammberger
+#
+#This program is free software you can redistribute it and/or modify it under
+#the terms of the GNU Lesser General Public License as published by the Free Software
+#Foundation either version 2 of the License, or (at your option) any later
+#version.
+#
+#This program is distributed in the hope that it will be useful, but WITHOUT
+#ANY WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS
+#FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
+#
+#You should have received a copy of the GNU Lesser General Public License along with
+#this program if not, write to the Free Software Foundation, Inc., 59 Temple
+#Place - Suite 330, Boston, MA 02111-1307, USA, or go to
+#<A HREF="http://www.gnu.org/copyleft/lesser.txt.">http://www.gnu.org/copyleft/lesser.txt.</A>
+#-----------------------------------------------------------------------------
+
+import ogre.renderer.OGRE as og
+
+RL_BEHIND = 1
+INFRONT = 2
+
+class ViewportGrid(og.RenderTargetListener):
+    def __init__(self, pSceneMgr, pViewport):
+        super(ViewportGrid, self).__init__()
+
+        self.m_pSceneMgr = pSceneMgr
+        self.m_pViewport = pViewport
+        self.m_enabled = False
+        self.m_layer = None
+
+        self.m_pPrevCamera = None
+        self.m_prevOrtho = False
+        self.m_prevCamPos = None
+        self.m_prevNear = None
+        self.m_prevFOVy = None
+        self.m_prevAspectRatio = None
+        self.m_forceUpdate = True
+
+        self.m_pGrid = None
+        self.m_created = False
+        self.m_pNode = None
+
+        self.m_colour1 = og.ColourValue(0.7, 0.7, 0.7)
+        self.m_colour2 = og.ColourValue(0.7, 0.7, 0.7)
+        self.m_division = 10
+        self.m_perspSize = 100
+        self.m_renderScale = True
+        self.m_renderMiniAxes = True
+
+        self.sMatName = &quot;ViewportGrid&quot;
+
+        self.__createGrid()
+        self.setRenderLayer(RL_BEHIND)
+
+        # Add this as a render target listener
+        self.m_pViewport.getTarget().addListener(self)
+
+
+    def getColour(self):
+        return m_colour1
+
+    def setColour(self, colour):
+        # Force alpha = 1 for the primary colour
+        self.m_colour1 = colour
+        self.m_colour1.a = 1.0
+        self.m_colour2 = m_colour1
+        self.forceUpdate()
+
+    #Grid division (the number of new lines that are created when zooming in).
+    def getDivision(self):
+        return m_division
+
+    def setDivision(self, division):
+        self.m_division = division
+        self.forceUpdate()
+
+    #//! Grid render layer (behind of in front of the objects).
+    def getRenderLayer(self):
+        return m_layer
+
+    def setRenderLayer(self, layer):
+        self.m_layer = layer
+
+        if self.m_layer == RL_BEHIND:
+            # Render just before the world geometry
+            self.m_pGrid.setRenderQueueGroup(og.RENDER_QUEUE_WORLD_GEOMETRY_1 - 1)
+        elif self.m_layer == RL_INFRONT:
+            # Render just before the overlays
+            self.m_pGrid.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+
+
+    def getPerspectiveSize(self):
+        return m_perspSize
+
+    def setPerspectiveSize(self, size):
+        self.m_perspSize = size
+        self.forceUpdate()
+
+#       //! Render scaling info? Defaults to true.
+#       //! @todo Implement this
+    def getRenderScale(self):
+        return m_renderScale
+
+    def setRenderScale(self, enabled = True):
+        self.m_renderScale = enabled
+        self.forceUpdate()
+
+#       //! Render mini axes? Defaults to true.
+#       //! @todo Implement this
+    def getRenderMiniAxes(self):
+        return m_renderMiniAxes
+
+    def setRenderMiniAxes(self, enabled = True):
+        self.m_renderMiniAxes = enabled
+        self.forceUpdate()
+
+    #// Enable / disable
+    def isEnabled(self):
+        return m_enabled
+
+    def enable(self):
+        self.m_enabled = True
+
+        if not self.m_pGrid.isAttached():
+            self.m_pNode.attachObject(self.m_pGrid)
+
+        self.forceUpdate()
+
+
+    def disable(self):
+        self.m_enabled = False
+
+        if self.m_pGrid.isAttached():
+            self.m_pNode.detachObject(self.m_pGrid)
+
+
+
+    def  toggle(self):
+        self.setEnabled(not self.m_enabled)
+
+    def setEnabled(self, enabled):
+        if enabled:
+            self.enable()
+        else:
+            self.disable()
+
+
+    def forceUpdate(self):
+        self.m_forceUpdate = True
+
+    def preViewportUpdate(self, evt):
+       #TODO find out why evt.souce and self.m_pViewport differ in their memory address
+       # if evt.source != self.m_pViewport:
+           # return
+
+        self.m_pGrid.setVisible(True)
+
+        if self.m_enabled:
+            self.__update()
+
+    def postViewportUpdate(self, evt):
+       # if evt.source != self.m_pViewport:
+           # return
+        self.m_pGrid.setVisible(False)
+
+    def __createGrid(self):
+        name = self.m_pViewport.getTarget().getName() + &quot;::&quot;
+        name += str(self.m_pViewport.getZOrder()) + &quot;::ViewportGrid&quot;
+
+        #// Create the manual object
+        self.m_pGrid = self.m_pSceneMgr.createManualObject(name)
+        self.m_pGrid.setDynamic(True)
+
+        #// Create the scene node (not attached yet)
+        self.m_pNode = self.m_pSceneMgr.getRootSceneNode().createChildSceneNode(name)
+        self.m_enabled = False
+
+        #// Make sure the material is created
+        #//! @todo Should we destroy the material somewhere?
+        matMgr = og.MaterialManager.getSingleton()
+        if not matMgr.resourceExists(self.sMatName):
+            pMaterial = matMgr.create(self.sMatName, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME)
+            pMaterial.setLightingEnabled(False)
+            pMaterial.setSceneBlending(og.SBT_TRANSPARENT_ALPHA)
+
+
+
+    def __destroyGrid(self):
+        self.m_pSceneMgr.destroyManualObject(self.m_pGrid)
+        self.m_pGrid = None
+
+        self.m_pSceneMgr.destroySceneNode(self.m_pNode.getName())
+        self.m_pNode = None
+
+
+    def __update(self):
+        if not self.m_enabled:
+            return
+
+        pCamera = self.m_pViewport.getCamera()
+        if not pCamera:
+            return
+
+        # Check if an update is necessary
+        if not self.__checkUpdate() and not self.m_forceUpdate:
+            return
+
+        if pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC:
+            self.__updateOrtho()
+        else:
+            self.__updatePersp()
+
+        self.m_forceUpdate = False
+
+
+
+    def __updateOrtho(self):
+        # Screen dimensions
+        width = self.m_pViewport.getActualWidth()
+        height = self.m_pViewport.getActualHeight()
+
+        #Camera information
+        pCamera = m_pViewport.getCamera()
+        camPos = pCamera.getPosition()
+        camDir = pCamera.getDirection()
+        camUp = pCamera.getUp()
+        camRight = pCamera.getRight()
+
+        # Translation in grid space
+        dx = camPos.dotProduct(camRight)
+        dy = camPos.dotProduct(camUp)
+
+        # Frustum dimensions
+        # Note: Tan calculates the opposite side of a _right_ triangle given its angle, so we make sure it is one, and double the result
+        worldWidth = 2 * og.Math.Tan(pCamera.getFOVy() / 2) * pCamera.getAspectRatio() * pCamera.getNearClipDistance()
+        worldHeight = worldWidth / pCamera.getAspectRatio()
+        worldLeft = dx - worldWidth / 2
+        worldRight = dx + worldWidth / 2
+        worldBottom = dy - worldHeight / 2
+        worldTop = dy + worldHeight / 2
+
+        # Conversion values (note: same as working with the height values)
+        worldToScreen = width / worldWidth
+        screenToWorld = worldWidth / width
+
+        # TODO Treshold should be dependent on window width/height (min? max?) so there are no more then m_division full alpha-lines
+        treshold = 10 # Treshhold in pixels
+
+        # Calculate the spacing multiplier
+        mult = 0
+        exp = 0
+        temp = worldToScreen # 1 world unit
+        if worldToScreen &lt; treshold:
+            while temp &lt; treshold:
+                exp = exp +1
+                temp = temp * treshold # TODO maybe wrong
+
+            mult = og.Math.Pow(self.m_division, exp)
+        else:
+            while temp &gt; (self.m_division * treshold):
+                exp = exp +1
+                temp = temp / treshold # TODO maybe wrong
+
+            mult = og.Math.Pow(1.0 / self.m_division, exp)
+
+        # Interpolate alpha for (multiplied) spacing between treshold and m_division * treshold
+        self.m_colour2.a = worldToScreen * mult / (m_division * treshold - treshold)
+        if m_colour2.a &gt; 1.0:
+           self.m_colour2.a = 1.0
+
+        # Calculate the horizontal zero-axis color
+        camRightX = og.Math.Abs(camRight.x)
+        camRightY = og.Math.Abs(camRight.y)
+        camRightZ = og.Math.Abs(camRight.z)
+
+        if og.Math.RealEqual(camRightX, 1.0):
+            horAxisColor = og.ColourValue.Red
+        elif og.Math.RealEqual(camRightY, 1.0):
+            horAxisColor = og.ColourValue.Green
+        elif og.Math.RealEqual(camRightZ, 1.0):
+            horAxisColor = og.ColourValue.Blue
+        else:
+            horAxisColor = self.m_colour1
+
+        # Calculate the vertical zero-axis color
+        camUpX = og.Math.Abs(camUp.x)
+        camUpY = og.Math.Abs(camUp.y)
+        camUpZ = og.Math.Abs(camUp.z)
+
+        if og.Math.RealEqual(camUpX, 1.0):
+            horAxisColor = og.ColourValue.Red
+        elif og.Math.RealEqual(camUpY, 1.0):
+            horAxisColor = og.ColourValue.Green
+        elif og.Math.RealEqual(camUpZ, 1.0):
+            horAxisColor = og.ColourValue.Blue
+        else:
+            horAxisColor = self.m_colour1
+
+        # The number of lines
+        numLinesWidth = int((worldWidth / mult) + 1)
+        numLinesHeight = int((worldHeight / mult) + 1)
+
+        # Start creating or updating the grid
+        self.m_pGrid.estimateVertexCount(2 * numLinesWidth + 2 * numLinesHeight)
+        if m_created:
+            self.m_pGrid.beginUpdate(0)
+        else:
+            self.m_pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
+            self.m_created = True
+
+        # Vertical lines
+        startX = mult * int(worldLeft / mult)
+        x = startX
+        while x &lt;= worldRight:
+            # Get the right color for this line
+            if x == 0:
+                multX = x
+            elif x &lt; 0:
+                multX = int(x / mult - 0.5)
+            else:
+                multX = int(x / mult + 0.5)
+
+
+            if multX == 0:
+                colour = vertAxisColor
+            elif multX % (int(self.m_division)):
+                self.m_colour2
+            else:
+                self.m_colour1
+
+
+
+
+            # Add the line
+            self.m_pGrid.position(x, worldBottom, 0)
+            self.m_pGrid.colour(colour)
+            self.m_pGrid.position(x, worldTop, 0)
+            self.m_pGrid.colour(colour)
+
+            x += mult
+
+        # Horizontal lines
+        startY = mult * int(worldBottom / mult)
+        y = startY
+        while y &lt;= worldTop:
+            # Get the right color for this line
+            #multY = (y == 0) ? y : (y &lt; 0) ? int(y / mult - 0.5f) : int(y / mult + 0.5f)
+            if y == 0:
+                multY = y
+            elif y &lt; 0:
+                multY = int(y / mult - 0.5)
+            else:
+                multY = int(y / mult + 0.5)
+
+            #colour = (multY == 0) ? horAxisColor : (multY % int(m_division)) ? self.m_colour2 : self.m_colour1
+            if multY == 0:
+                colour = horAxisColor
+            elif multY % (int(self.m_division)):
+                self.m_colour2
+            else:
+                self.m_colour1
+
+            self.m_pGrid.position(worldLeft, y, 0)
+            self.m_pGrid.colour(colour)
+            self.m_pGrid.position(worldRight, y, 0)
+            self.m_pGrid.colour(colour)
+
+            y += mult
+
+        self.m_pGrid.end()
+
+        self.m_pNode.setOrientation(pCamera.getOrientation())
+
+
+    def __updatePersp(self):
+        #! @todo Calculate the spacing multiplier
+        mult = 1
+
+        #! @todo Interpolate alpha
+        self.m_colour2.a = 0.5
+        #if(m_colour2.a &gt; 1.0f) m_colour2.a = 1.0f
+
+        # Calculate the horizontal zero-axis color
+        horAxisColor = og.ColourValue.Red
+
+        # Calculate the vertical zero-axis color
+        vertAxisColor = og.ColourValue.Blue
+
+        # The number of lines
+        numLines = int(self.m_perspSize / mult) + 1
+
+        # Start creating or updating the grid
+        self.m_pGrid.estimateVertexCount(4 * numLines)
+        if self.m_created:
+            self.m_pGrid.beginUpdate(0)
+        else:
+            self.m_pGrid.begin(self.sMatName, og.RenderOperation.OT_LINE_LIST)
+            self.m_created = True
+
+        # Vertical lines
+        start = mult * int(-self.m_perspSize / 2 / mult)
+        x = start
+        while x &lt;= (self.m_perspSize / 2):
+            # Get the right color for this line
+            #multX = (x == 0) ? x : (x &lt; 0) ? int(x / mult - 0.5f) : int(x / mult + 0.5f)
+            if x == 0:
+                multX = x
+            elif x &lt; 0:
+                multX = int(x / mult - 0.5)
+            else:
+                multX = int(x / mult +0.5)
+
+            #colour = (multX == 0) ? vertAxisColor : (multX % (int) self.m_division) ? self.m_colour2 : self.m_colour1
+            if multX == 0:
+                colour = vertAxisColor
+            elif multX % int(self.m_division):
+                colour = self.m_colour2
+            else:
+                colour = self.m_colour1
+
+            # Add the line
+            self.m_pGrid.position(x, 0, -self.m_perspSize / 2)
+            self.m_pGrid.colour(colour)
+            self.m_pGrid.position(x, 0, self.m_perspSize / 2)
+            self.m_pGrid.colour(colour)
+
+            x += mult
+
+        # Horizontal lines
+        y = start
+        while y &lt;= (self.m_perspSize / 2):
+            # Get the right color for this line
+            #multY = (y == 0) ? y : (y &lt; 0) ? int(y / mult - 0.5f) : int(y / mult + 0.5f)
+            if y == 0:
+                multY = y
+            elif y &lt; 0:
+                multY = int(y / mult - 0.5)
+            else:
+                multY = int(y / mult +0.5)
+
+            #colour = (multY == 0) ? horAxisColor : (multY % int(self.m_division)) ? self.m_colour2 : self.m_colour1
+            if multY == 0:
+                colour = horAxisColor
+            elif multY % int(self.m_division):
+                colour = self.m_colour2
+            else:
+                colour = self.m_colour1
+            # Add the line
+            self.m_pGrid.position(-self.m_perspSize / 2, 0, y)
+            self.m_pGrid.colour(colour)
+            self.m_pGrid.position(self.m_perspSize / 2, 0, y)
+            self.m_pGrid.colour(colour)
+
+            y += mult
+
+        self.m_pGrid.end()
+
+        # Normal orientation, grid in the X-Z plane
+        self.m_pNode.resetOrientation()
+
+
+    def __checkUpdate(self):
+        update = False
+
+        pCamera = self.m_pViewport.getCamera()
+        if not pCamera:
+            return False
+
+        if pCamera is not self.m_pPrevCamera:
+            self.m_pPrevCamera = pCamera
+            update = True
+
+
+        ortho = (pCamera.getProjectionType() == og.PT_ORTHOGRAPHIC)
+        if ortho is not self.m_prevOrtho:
+            self.m_prevOrtho = ortho
+            update = True
+
+            # Set correct material properties
+            pMaterial = MaterialManager.getSingleton().getByName(self.sMatName)
+            if not pMaterial.isNull():
+                pMaterial.setDepthWriteEnabled(not ortho)
+                pMaterial.setDepthCheckEnabled(not ortho)
+
+        #return update || ortho ? checkUpdateOrtho() : checkUpdatePersp()
+        if update:
+            if ortho:
+                return self.__checkUpdateOrtho()
+            else:
+                return self.__checkUpdatePersp()
+
+        return False
+
+
+    def __checkUpdateOrtho(self):
+        update = False
+
+        pCamera = self.m_pViewport.getCamera()
+        if not pCamera:
+            return False
+
+        if pCamera.getPosition() is not self.m_prevCamPos:
+            self.m_prevCamPos = pCamera.getPosition()
+            update = True
+
+        if pCamera.getNearClipDistance() is not self.m_prevNear:
+            self.m_prevNear = pCamera.getNearClipDistance()
+            update = True
+
+        if pCamera.getFOVy() is not self.m_prevFOVy:
+            self.m_prevFOVy = pCamera.getFOVy()
+            update = True
+
+        if pCamera.getAspectRatio() is not self.m_prevAspectRatio:
+            self.m_prevAspectRatio = pCamera.getAspectRatio()
+            update = True
+
+        return update
+
+
+    def __checkUpdatePersp(self):
+        return False

Deleted: rl/trunk/editors/Lockenwickler/src/ui_lw.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_lw.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/ui_lw.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1 +0,0 @@
-

Deleted: rl/trunk/editors/Lockenwickler/src/ui_model_prev.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_model_prev.py	2008-10-12 15:27:38 UTC (rev 4548)
+++ rl/trunk/editors/Lockenwickler/src/ui_model_prev.py	2008-10-12 18:04:43 UTC (rev 4549)
@@ -1,13 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'model_preview.ui'
-#
-# Created: Mon May 12 15:09:24 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_modelPreviewDialog(object):
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001605.html">[Dsa-hl-svn] r4548 - in rl/branches/persistence/rules: include src
</A></li>
	<LI>Next message: <A HREF="001607.html">[Dsa-hl-svn] r4550 - in rl/trunk/editors/Lockenwickler: . src	src/media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1606">[ date ]</a>
              <a href="thread.html#1606">[ thread ]</a>
              <a href="subject.html#1606">[ subject ]</a>
              <a href="author.html#1606">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
