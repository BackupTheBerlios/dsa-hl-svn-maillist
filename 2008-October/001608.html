<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4551 - in rl/branches/persistence/core: . include src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4551%20-%20in%20rl/branches/persistence/core%3A%20.%20include%20src&In-Reply-To=%3C200810171615.m9HGF0AA007305%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001607.html">
   <LINK REL="Next"  HREF="001609.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4551 - in rl/branches/persistence/core: . include src</H1>
    <B>timm at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4551%20-%20in%20rl/branches/persistence/core%3A%20.%20include%20src&In-Reply-To=%3C200810171615.m9HGF0AA007305%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4551 - in rl/branches/persistence/core: . include src">timm at mail.berlios.de
       </A><BR>
    <I>Fri Oct 17 18:15:00 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001607.html">[Dsa-hl-svn] r4550 - in rl/trunk/editors/Lockenwickler: . src	src/media
</A></li>
        <LI>Next message: <A HREF="001609.html">[Dsa-hl-svn] r4552 - rl/branches/persistence/script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1608">[ date ]</a>
              <a href="thread.html#1608">[ thread ]</a>
              <a href="subject.html#1608">[ subject ]</a>
              <a href="author.html#1608">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: timm
Date: 2008-10-17 18:14:48 +0200 (Fri, 17 Oct 2008)
New Revision: 4551

Removed:
   rl/branches/persistence/core/include/DotSceneLoader.h
   rl/branches/persistence/core/src/DotSceneLoader.cpp
Modified:
   rl/branches/persistence/core/RlCore2005.vcproj
   rl/branches/persistence/core/include/CoreSubsystem.h
   rl/branches/persistence/core/include/DotSceneOctreeWorld.h
   rl/branches/persistence/core/include/World.h
   rl/branches/persistence/core/src/CoreSubsystem.cpp
   rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp
Log:
- removed old dotsceneloader

Modified: rl/branches/persistence/core/RlCore2005.vcproj
===================================================================
--- rl/branches/persistence/core/RlCore2005.vcproj	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/RlCore2005.vcproj	2008-10-17 16:14:48 UTC (rev 4551)
@@ -416,10 +416,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\DotSceneLoader.h&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\include\DotSceneOctreeWorld.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -761,10 +757,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\DotSceneLoader.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\src\DotSceneOctreeWorld.cpp&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/branches/persistence/core/include/CoreSubsystem.h
===================================================================
--- rl/branches/persistence/core/include/CoreSubsystem.h	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/include/CoreSubsystem.h	2008-10-17 16:14:48 UTC (rev 4551)
@@ -69,8 +69,6 @@
     void renderOneFrame(bool executeTasks = true);
 
     World* getWorld();
-    void loadMap(const Ogre::String type, const Ogre::String filename,
-        const Ogre::String module);
 
     RubyInterpreter* getRubyInterpreter();
 

Deleted: rl/branches/persistence/core/include/DotSceneLoader.h
===================================================================
--- rl/branches/persistence/core/include/DotSceneLoader.h	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/include/DotSceneLoader.h	2008-10-17 16:14:48 UTC (rev 4551)
@@ -1,155 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __DotSceneLoader_H__
-#define __DotSceneLoader_H__
-
-#include &quot;CorePrerequisites.h&quot;
-
-#ifdef __APPLE__
-#   include &lt;OgreNewt/OgreNewt.h&gt;
-#else
-#   include &lt;OgreNewt.h&gt;
-#endif
-
-#include &lt;string&gt;
-#include &lt;map&gt;
-
-#include &quot;XmlResourceManager.h&quot;
-#include &quot;XmlPropertyReader.h&quot;
-
-class Ogre::SceneNode;
-class XERCES_CPP_NAMESPACE::DOMElement;
-
-namespace rl {
-
-	/** Diese Klasse parst eine .scene.xml Datei.
-	 *  
-	 *  Zur Zeit sind folgenende Dinge (partiell) unterst&#252;tzt 
-	 *   - Nodes ( Name, Hierarchie + Platzierung + Skalierung + Rotation )
-	 *   - Entities ( Name, TriMeshPhysik )
-	 */
-    class DotSceneLoader : private XmlPropertyReader
-	{
-	public:
-		/// Erstellt einen Dotscene Loader, der das gew&#252;nschte File einliest
-        DotSceneLoader(const std::string&amp; filename, const std::string&amp; resourceGroup);
-		/// Standard Destruktor
-		virtual ~DotSceneLoader();
-
-		/// Laden der Szene
-		void initializeScene(Ogre::SceneManager* sceneManager);
-
-	private:
-        struct NodeUserData
-        {
-            std::string physical_body;
-			Ogre::Real renderingdistance;
-			int staticgeom_group;
-            bool is_dynamic;
-			bool is_inheriting;
-			OgreNewt::CollisionPtr collision;
-        };
-
-		// wird verwendet um einen Zeiger auf eine vorherige identische
-        // Collision zu erhalten
-        struct AlreadyUsedCollision
-        {
-        public:
-            std::string Type;
-            Ogre::Vector3 Scale;
-            OgreNewt::CollisionPtr ColPtr;
-        };
-
-
-		/// Geht alle Nodes in der .scene durch
-		void processNodes(XERCES_CPP_NAMESPACE::DOMElement* rootNodesXml, 
-			Ogre::SceneManager* sceneManager,
-			Ogre::SceneNode* parentNode );
-		/// Node und alle Unterelemente
-		void processNode(XERCES_CPP_NAMESPACE::DOMElement* rootNodeXml, 
-			Ogre::SceneManager* sceneManager,
-			Ogre::SceneNode* parentNode, NodeUserData* parentUserData );
-		/// Eine Entity+Attribute
-		void processEntity( XERCES_CPP_NAMESPACE::DOMElement* rootEntityXml, 
-			Ogre::SceneManager* sceneManager, Ogre::SceneNode* parentNode, 
-			Ogre::Real renderingDistance, const std::string &amp;bodyproxy_type );
-        /// Ein benutzerdefinierter Bereich im Node
-        void processNodeUserData( XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml, 
-			NodeUserData* userData );
-		/// Ein benutzerdefinierter Bereich in der Szene
-		void processSceneUserData( XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml );
-
-		/** Liest einen Vector aus einem XML Element, &#252;ber die Attribute x, y, z
-		 *  Sollten die Attribute nicht korrekt definiert sein, gibt es Vector::ZERO zur&#252;ck (0,0,0)
-		 */
-		Ogre::Vector3 processPosition( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml );
-
-		/** Liest einen Vector aus einem XML Element, &#252;ber die Attribute x, y, z
-		*  Sollten die Attribute nicht korrekt definiert sein, gibt es Vector::UNIT_SCALE zur&#252;ck (1,1,1)
-		*/
-		Ogre::Vector3 processScale( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml );
-		/** Liest einen Vector aus einem XML Element, &#252;ber die Attribute x, y, z
-		*  Sollten die Attribute nicht korrekt definiert sein, wird error auf true gesetzt.
-		*/
-		Ogre::Vector3 processVector( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml, bool &amp;error );
-		/** Liest ein Quaternion aus einem XML Element, 
-		*  &#252;ber die Attribute qw, qx, qy, qz  ODER angle, axisX, axisY, axisZ
-		*  Sollten die Attribute nicht korrekt definiert sein, gibt es Quaternion::IDENTITY zur&#252;ck (1,0,0,0)
-		*/
-		Ogre::Quaternion processRotation( XERCES_CPP_NAMESPACE::DOMElement* rootQuatXml );
-		/** Liest eine Liste von ein bis mehreren Bodyproxies (Collisions)
-		* SceneUserData ein.
-		* Sollten die Attribute falsch gesetzt sein, gibt es NULL zur&#252;ck; Dadurch wird keine Collision verwendet
-		*/
-		void processCollisions( XERCES_CPP_NAMESPACE::DOMElement* rootCollisionXml );
-
-        std::string getRandomName(const std::string&amp; baseName);
-        /// Builds a string from a xerces exception
-        std::string toString( const std::string&amp; type, const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc ) const;
-
-		/// Der Node der Scene
-		Ogre::SceneNode* mSceneNode;
-		/// Alle statischen GeometrieNodes
-		std::map&lt;int,Ogre::SceneNode*&gt; mStaticNodes;
-
-		/// Alle bodyproxies, die schon automatisch erstellt worden sind
-		typedef std::map&lt;const std::string,AlreadyUsedCollision&gt;
-			USEDCOLLISIONSMAP;
-		USEDCOLLISIONSMAP mAutoCreatedCollisions;
-        std::vector&lt;OgreNewt::CollisionPtr&gt; mCollisions;
-
-		Ogre::Real mRenderingDistance;
-		std::map&lt;int,Ogre::Real&gt; mStaticgeomRenderingDistances;
-		std::map&lt;int,Ogre::Real&gt; mStaticgeomBatchSizes;
-		
-		/// Der Name der Scene
-		const std::string mSceneName;
-        /// ResourceGroup der dotscene-Resource
-        const std::string mResourceGroup;
-
-        /// Have any errors occured
-        int mErrorCount;
-
-        /// The Ressource
-        XmlPtr mRessource;
-        // The Parser
-        XERCES_CPP_NAMESPACE::XercesDOMParser* mParser;
-	};
-
-}
-
-#endif

Modified: rl/branches/persistence/core/include/DotSceneOctreeWorld.h
===================================================================
--- rl/branches/persistence/core/include/DotSceneOctreeWorld.h	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/include/DotSceneOctreeWorld.h	2008-10-17 16:14:48 UTC (rev 4551)
@@ -32,7 +32,6 @@
         virtual void clearScene();
         virtual void initializeDefaultCamera();	
 		virtual void setCastShadows(bool enabled);
-        virtual void loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; module);
     };
 
 }

Modified: rl/branches/persistence/core/include/World.h
===================================================================
--- rl/branches/persistence/core/include/World.h	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/include/World.h	2008-10-17 16:14:48 UTC (rev 4551)
@@ -42,8 +42,6 @@
         virtual Ogre::Vector3 getStartPoint() const;
 
         virtual void clearScene(void) = 0;
-        virtual void loadScene(const Ogre::String&amp; levelName,
-            const Ogre::String&amp; module) = 0;
 
         //Enables / disables a 'sky plane' i.e.
         virtual void setSkyPlane(bool enable, const Ogre::Plane &amp;plane,

Modified: rl/branches/persistence/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-10-17 16:14:48 UTC (rev 4551)
@@ -566,12 +566,6 @@
         return mModules;
     }
 
-    void CoreSubsystem::loadMap(const Ogre::String type, const Ogre::String filename,
-        const Ogre::String module)
-    {
-        mWorld-&gt;loadScene(filename, module);
-    }
-
     void CoreSubsystem::loadPlugins()
     {
         mSoundManager-&gt;applySettings(rl::ConfigurationManager::getSingleton().getSettings(&quot;Sound&quot;));

Deleted: rl/branches/persistence/core/src/DotSceneLoader.cpp
===================================================================
--- rl/branches/persistence/core/src/DotSceneLoader.cpp	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/src/DotSceneLoader.cpp	2008-10-17 16:14:48 UTC (rev 4551)
@@ -1,1080 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
-#include &quot;DotSceneLoader.h&quot;
-#include &quot;World.h&quot;
-
-#include &quot;PhysicsManager.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-
-#include &quot;Property.h&quot;
-
-#include &quot;Exception.h&quot;
-
-#include &lt;cstdlib&gt;
-#include &lt;ctime&gt;
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace std;
-using namespace Ogre;
-
-namespace rl {
-    using XERCES_CPP_NAMESPACE::DOMDocument;
-
-    DotSceneLoader::DotSceneLoader(const string&amp; filename, const string&amp; resourceGroup)
-        : mSceneName(filename),
-          mResourceGroup(resourceGroup),
-          mStaticNodes(),
-          mRenderingDistance(ActorManager::getSingleton().getDefaultActorRenderingDistance()),
-          mStaticgeomRenderingDistances(),
-          mStaticgeomBatchSizes(),
-          mRessource(NULL),
-          mParser(NULL),
-          mErrorCount(0)
-    {
-        srand(static_cast&lt;unsigned int&gt;(time(NULL)));
-    }
-
-    DotSceneLoader::~DotSceneLoader()
-    {
-        if (!mRessource.isNull() &amp;&amp; mRessource-&gt;isLoaded())
-        {
-            XmlResourceManager::getSingleton().unload(mSceneName);
-            XmlResourceManager::getSingleton().remove(mRessource-&gt;getHandle());
-        }
-    }
-
-    void DotSceneLoader::initializeScene(SceneManager* sceneManager)
-    {
-        initializeXml();
-
-        LOG_MESSAGE(Logger::CORE, &quot;Loading Scene from &quot; + mSceneName);
-        DOMDocument* doc = loadDocument(mSceneName, mResourceGroup);
-
-        // Durch alle Unterelemente iterieren
-        DOMNode* child = doc-&gt;getDocumentElement()-&gt;getFirstChild();
-
-        while(child != NULL)
-        {
-            // Ein Node
-            if (XMLString::compareIString(child-&gt;getNodeName(), AutoXMLCh(&quot;userData&quot;).data()) == 0 )
-            {
-                processSceneUserData(static_cast&lt;DOMElement*&gt;(child));
-            }
-            child = child-&gt;getNextSibling();
-        }
-
-        LOG_DEBUG(Logger::CORE, &quot; Beginne parsen der Unterelemente&quot;);
-        DOMElement* nodes = getChildNamed(doc-&gt;getDocumentElement(), &quot;nodes&quot;);
-
-        // Eine .scene wird in einem SceneNode mit dem Namen der .scene befestigt
-        mSceneNode = sceneManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(mSceneName);
-        processNodes(nodes, sceneManager, mSceneNode);
-
-        // Find out, if static geometry should be used
-        Ogre::String temp = ConfigurationManager::getSingleton().getStringSetting(
-            &quot;Video&quot;, &quot;Use Static Geometry&quot;);
-        bool useStaticGeometry;
-
-        if (temp == &quot;yes&quot;)
-        {
-            useStaticGeometry = true;
-        }
-        else if (temp == &quot;no&quot;)
-        {
-            useStaticGeometry = false;
-        }
-        else
-        {
-            // Check, if Renderer supports vertex buffer
-            useStaticGeometry = Ogre::Root::getSingleton().getRenderSystem()-&gt;getCapabilities()-&gt;hasCapability(Ogre::RSC_VBO);
-        }
-
-        if (useStaticGeometry)
-        {
-            for(std::map&lt;int,Ogre::SceneNode*&gt;::iterator it = mStaticNodes.begin();
-                it != mStaticNodes.end();)
-            {
-                Ogre::SceneNode* staticNode = it-&gt;second;
-                string staticName = Ogre::StringConverter::toString(it-&gt;first);
-                Ogre::Real renderDist = mRenderingDistance;
-                Ogre::Real batchSize = 25.0;
-
-                if (mStaticgeomRenderingDistances.find(it-&gt;first) != mStaticgeomRenderingDistances.end())
-                    renderDist = mStaticgeomRenderingDistances[it-&gt;first];
-                if (mStaticgeomBatchSizes.find(it-&gt;first) != mStaticgeomBatchSizes.end())
-                    batchSize = mStaticgeomBatchSizes[it-&gt;first];
-
-                StaticGeometry* staticGeom = sceneManager-&gt;createStaticGeometry(mSceneName + staticName );
-
-                staticGeom-&gt;setRenderingDistance(renderDist);
-                staticGeom-&gt;addSceneNode(staticNode);
-                staticGeom-&gt;setRegionDimensions(batchSize * Vector3::UNIT_SCALE);
-                // Statische Geometrie bauen
-                staticGeom-&gt;build();
-                // Nicht mehr den Original-Knoten rendern, da dieser noch erhalten ist.
-                staticNode-&gt;setVisible(false);
-                staticNode-&gt;removeAndDestroyAllChildren();
-                sceneManager-&gt;destroySceneNode(staticNode-&gt;getName());
-                staticNode = NULL;
-                LOG_DEBUG(Logger::CORE, &quot; Statische Geometrie &quot;+staticName+&quot; erstellt&quot;);
-                ++it;
-            }
-        }
-        else
-            LOG_DEBUG(Logger::CORE, &quot; Keine statischen Geometrien erstellt&quot;);
-
-        shutdownXml();
-        LOG_DEBUG(Logger::CORE, &quot;Szenenbeschreibung aus &quot; + mSceneName +&quot; fertig geparst&quot;);
-    }
-
-    // Iteriert durch die einzelnen Nodes
-    void DotSceneLoader::processNodes(DOMElement* rootNodesXml, SceneManager* sceneManager,
-        Ogre::SceneNode* parentNode)
-    {
-        if (rootNodesXml == NULL)
-            return;
-        if (parentNode == NULL)
-            Throw(NullPointerException, &quot;parentNode darf nicht null sein&quot;);
-
-
-        // Durch alle Unterelemente iterieren
-        DOMNode* child = rootNodesXml-&gt;getFirstChild();
-
-        while(child != NULL)
-        {
-            // Ein Node
-            if (XMLString::compareIString(child-&gt;getNodeName(), AutoXMLCh(&quot;node&quot;).data()) == 0 )
-            {
-                processNode(static_cast&lt;DOMElement*&gt;(child), sceneManager, parentNode, NULL);
-            }
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    // Befasst sich mit einem Node
-    void DotSceneLoader::processNode(DOMElement* rootNodeXml, SceneManager* sceneManager, Ogre::SceneNode* parentNode, NodeUserData* parentUserData)
-    {
-        if (rootNodeXml == NULL)
-            return;
-        if (parentNode == NULL)
-            Throw(NullPointerException, &quot;parentNode darf nicht null sein&quot;);
-
-        string nodeName = getAttributeValueAsStdString(rootNodeXml,
-                        &quot;name&quot;);
-
-        Ogre::SceneNode* newNode;
-        // Wurde dem Node ein Name zugewiesen?
-        if (nodeName.length() &gt; 0)
-        {
-            if (!parentNode-&gt;getCreator()-&gt;hasSceneNode(nodeName))
-            {
-                // Dann versuche einen Knoten mit dem Namen zu erstellen
-                newNode = parentNode-&gt;createChildSceneNode(nodeName);
-            }
-            else
-            {
-                // Name schon vergeben
-                newNode = parentNode-&gt;createChildSceneNode();
-                LOG_DEBUG(Logger::CORE,
-                    &quot; NodeName '&quot;+nodeName+&quot;' war schon vergeben! Es wurde der Name '&quot;+newNode-&gt;getName()+&quot;' benutzt.&quot;);
-            }
-        }
-        else
-        {
-            newNode = parentNode-&gt;createChildSceneNode();
-        }
-
-        LOG_DEBUG(Logger::CORE,
-                    &quot; Node '&quot;+newNode-&gt;getName()+&quot;' als Unterknoten von '&quot;+parentNode-&gt;getName()+&quot;' erstellt.&quot;);
-
-
-        NodeUserData userData;
-        // Defaults einstellen
-        if (parentUserData == NULL || !parentUserData-&gt;is_inheriting)
-        {
-            userData.is_dynamic = false;
-            userData.is_inheriting = false;
-            userData.physical_body = &quot;mesh&quot;;
-            userData.staticgeom_group = -1;
-            userData.renderingdistance = mRenderingDistance;
-        }
-        // Vom Vorg&#228;nger erben
-        else
-        {
-            userData.is_dynamic = parentUserData-&gt;is_dynamic;
-            userData.is_inheriting = parentUserData-&gt;is_inheriting;
-            userData.physical_body = parentUserData-&gt;physical_body;
-            userData.staticgeom_group = parentUserData-&gt;staticgeom_group;
-            userData.renderingdistance = parentUserData-&gt;renderingdistance;
-        }
-
-
-        mCollisions.clear();
-        DOMNode* child = rootNodeXml-&gt;getFirstChild();
-        DOMNode *childScale = NULL, *childPosition = NULL,
-        *childRotation = NULL;
-        // Durch alle Unterelemente iterieren und gefundenes speichern
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;userData&quot;).data()) == 0)
-            {
-                // UserData direkt auslesen
-                processNodeUserData(static_cast&lt;DOMElement*&gt;(child) , &amp;userData);
-            }
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;position&quot;).data()) == 0)
-                childPosition = child;//rootNodeXml-&gt;removeChild(child);
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;rotation&quot;).data()) == 0)
-                childRotation = child;//rootNodeXml-&gt;removeChild(child);
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;scale&quot;).data()) == 0)
-                childScale = child;//rootNodeXml-&gt;removeChild(child);
-
-            child = child-&gt;getNextSibling();
-        }
-        // so jetzt stehen nur noch entities und nodes in der liste
-
-
-
-
-
-        if (userData.staticgeom_group &gt; -1)
-        {
-            newNode-&gt;getParentSceneNode()-&gt;removeChild(newNode);
-
-            // Existiert noch nicht
-            if (mStaticNodes.find(userData.staticgeom_group) == mStaticNodes.end())
-            {
-                mStaticNodes[userData.staticgeom_group] =
-                sceneManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(
-                mSceneName+&quot;_static_&quot;+Ogre::StringConverter::toString(userData.staticgeom_group));
-            }
-
-            mStaticNodes[userData.staticgeom_group]-&gt;addChild(newNode);
-        }
-
-
-        // Einzelne weitere childs auslesen, falls n&#246;tig, in der richtigen Reihenfolge
-
-        // Position des Nodes
-        if (childPosition != NULL)
-            newNode-&gt;setPosition(processPosition(static_cast&lt;DOMElement*&gt;(childPosition)));
-
-        // Rotation des Nodes
-        if (childRotation != NULL)
-            newNode-&gt;setOrientation(processRotation(static_cast&lt;DOMElement*&gt;(childRotation)));
-
-        // Skalierung des Nodes
-        if (childScale != NULL)
-            newNode-&gt;setScale(processScale(static_cast&lt;DOMElement*&gt;(childScale)));
-
-/*      // nun nicht mehr n&#246;tig!
-        {
-            // Skalierung auf alle Entities &#252;bertragen
-            for(unsigned short i = 0; i &lt; newNode-&gt;numAttachedObjects(); i++)
-            {
-                MovableObject* mo = newNode-&gt;getAttachedObject(i);
-                if (mo-&gt;getMovableType().compare(&quot;Entity&quot;) == 0)
-                    static_cast&lt;Entity*&gt;(mo)-&gt;setNormaliseNormals(newNode-&gt;getScale() != Vector3::UNIT_SCALE);
-            }
-        }
-*/
-
-
-
-        // Alle Entities und Subnodes auslesen
-        child = rootNodeXml-&gt;getFirstChild();
-        while(child != NULL)
-        {
-            // geschachteltes weiteres Node
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;node&quot;).data()) == 0)
-                processNode(static_cast&lt;DOMElement*&gt;(child), sceneManager, newNode, &amp;userData);
-            // Eine Entity
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;entity&quot;).data()) == 0)
-                processEntity(static_cast&lt;DOMElement*&gt;(child),
-                                sceneManager,
-                                newNode,
-                                userData.renderingdistance,
-                                userData.physical_body);
-
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    void DotSceneLoader::processSceneUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml)
-    {
-        DOMNode* child = rootUserDataXml-&gt;getFirstChild();
-        LOG_DEBUG(Logger::CORE, &quot; SceneUserData gefunden&quot;);
-        XmlPropertyReader* propertyReader = new XmlPropertyReader();
-
-        // Durch alle Unterelemente iterieren, um die properties zu finden
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;property&quot;).data()) == 0)
-            {
-                DOMElement* propertyXml = static_cast&lt;DOMElement*&gt;(child);
-
-                PropertyEntry entry = propertyReader-&gt;processProperty(propertyXml);
-
-                try
-                {
-                    if (entry.first == &quot;default_renderingdistance&quot;)
-                    {
-                        mRenderingDistance = entry.second.toReal();
-                    }
-                    else if (Ogre::StringUtil::startsWith(entry.first, &quot;staticgeom_renderingdistance_&quot;))
-                    {
-                        int groupId = Ogre::StringConverter::parseInt(entry.first.substr(29));
-                        mStaticgeomRenderingDistances[groupId] = entry.second.toReal();
-                    }
-                    else if (Ogre::StringUtil::startsWith(entry.first, &quot;staticgeom_batchsize_&quot;))
-                    {
-                        int groupId = Ogre::StringConverter::parseInt(entry.first.substr(21));
-                        mStaticgeomBatchSizes[groupId] = entry.second.toReal();
-                    }
-                }
-                catch(...)
-                {
-                    LOG_DEBUG(Logger::CORE,
-                        &quot; &gt; Parse Error beim &#220;bernehmen der Property '&quot;+entry.first+&quot;'!&quot;);
-                }
-
-            }
-            // Manuell definiertes LOD
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;manualLOD&quot;).data()) == 0)
-            {
-                DOMElement* lodXml = static_cast&lt;DOMElement*&gt;(child);
-                string meshName = getAttributeValueAsStdString(lodXml,
-                    &quot;mesh&quot;);
-
-                try
-                {
-                    Ogre::MeshPtr mesh = Ogre::MeshManager::getSingleton().getByName(meshName);
-                    mesh-&gt;removeLodLevels();
-
-                    DOMNode* lodchild = child-&gt;getFirstChild();
-                    LOG_DEBUG(Logger::CORE, &quot; LOD-Bereich f&#252;r &quot;+meshName+&quot; gefunden&quot;);
-                    Ogre::Real loddist = 10.0;
-                    string lodmeshName = &quot;&quot;;
-
-                    // Durch alle Unterelemente iterieren, um die LODs zu finden
-                    while(lodchild != NULL)
-                    {
-                        if (XMLString::compareIString(lodchild-&gt;getNodeName(),
-                            AutoXMLCh(&quot;LOD&quot;).data()) == 0)
-                        {
-                            loddist = 0.0;
-                            lodmeshName = &quot;&quot;;
-
-                            try
-                            {
-                                lodXml = static_cast&lt;DOMElement*&gt;(lodchild);
-                                loddist = getAttributeValueAsReal(lodXml,
-                                    &quot;distance&quot;);
-                                lodmeshName = getAttributeValueAsStdString(lodXml,
-                                    &quot;mesh&quot;);
-
-                                if (lodmeshName.length() &gt; 0 &amp;&amp; loddist &gt; 0)
-                                {
-                                    mesh-&gt;createManualLodLevel(loddist, lodmeshName);
-                                    LOG_DEBUG(Logger::CORE,
-                                        &quot; LOD f&#252;r bei '&quot;+Ogre::StringConverter::toString(loddist)+
-                                        &quot;' als '&quot;+lodmeshName+&quot;' gesetzt!&quot;);
-                                }
-                            }
-                            catch(...) { }
-                        }
-
-                        lodchild = lodchild-&gt;getNextSibling();
-                    }
-                }
-                catch(...)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; &gt; Parse Error beim Setzen der LOD f&#252;r '&quot;+meshName+&quot;'!&quot;);
-                }
-            }
-            child = child-&gt;getNextSibling();
-        }
-
-        delete propertyReader;
-    }
-
-    void DotSceneLoader::processNodeUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml,
-        NodeUserData* userData)
-    {
-        DOMNode* child = rootUserDataXml-&gt;getFirstChild();
-        LOG_DEBUG(Logger::CORE, &quot; NodeUserData gefunden&quot;);
-
-        // Durch alle Unterelemente iterieren, um die properties zu finden
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;property&quot;).data()) == 0)
-            {
-                DOMElement* propertyXml = static_cast&lt;DOMElement*&gt;(child);
-                PropertyEntry entry = processProperty(propertyXml);
-
-                try
-                {
-                    if (entry.first == &quot;physical_body&quot;)
-                        userData-&gt;physical_body = entry.second.toString().c_str();
-                    else if (entry.first == &quot;dynamic&quot;)
-                        userData-&gt;is_dynamic = entry.second.toInt() != 0;
-                    else if (entry.first == &quot;staticgeom_group&quot;)
-                        userData-&gt;staticgeom_group = entry.second.toInt();
-                    else if (entry.first == &quot;renderingdistance&quot;)
-                        userData-&gt;renderingdistance = entry.second.toReal();
-                }
-                catch(...)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; &gt; Parse Error beim &#220;bernehmen der Property '&quot;+entry.first+&quot;'!&quot;);
-                }
-
-            }
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                        AutoXMLCh(&quot;collisions&quot;).data()) == 0)
-                    processCollisions(static_cast&lt;DOMElement*&gt; (child));
-
-
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    // eine benutzerdefinierte Collision
-    void DotSceneLoader::processCollisions(XERCES_CPP_NAMESPACE::DOMElement *rootCollisionXml)
-    {
-        OgreNewt::CollisionPtr collision = OgreNewt::CollisionPtr();
-        DOMNode* child = rootCollisionXml-&gt;getFirstChild();
-        OgreNewt::World *thisWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-
-        std::vector&lt;Ogre::Vector3&gt; vec3Vector;
-        Ogre::Vector3 scale, offset;
-        Ogre::Quaternion rotation;
-
-
-        LOG_DEBUG(Logger::CORE, &quot; collisions in NodeUserData gefunden&quot;);
-
-
-        while(child != NULL)
-        {
-            if (child-&gt;getNodeType() != DOMNode::ELEMENT_NODE)
-            {
-                child = child-&gt;getNextSibling();
-                continue;
-            }
-            collision.setNull();
-            // am Anfang steht ein Node mit dem Typ
-            std::string typeAsString = transcodeToStdString(child-&gt;getNodeName());
-
-            scale = Ogre::Vector3::UNIT_SCALE;
-            offset = Ogre::Vector3::ZERO;
-            rotation = Ogre::Quaternion::IDENTITY;
-            vec3Vector.clear();
-
-            DOMNode *childChild = static_cast&lt;DOMElement*&gt;(child)-&gt;getFirstChild();
-            while(childChild != NULL)
-            {
-                if (childChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                {
-                    if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                        AutoXMLCh(&quot;scale&quot;).data()) == 0)
-                        scale = processScale(static_cast&lt;DOMElement*&gt;(childChild));
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                             AutoXMLCh(&quot;offset&quot;).data()) == 0)
-                        offset = processPosition(static_cast&lt;DOMElement*&gt;(childChild));
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                             AutoXMLCh(&quot;rotation&quot;).data()) == 0)
-                        rotation = processRotation(static_cast&lt;DOMElement*&gt;(childChild));
-
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                             AutoXMLCh(&quot;vertices&quot;).data()) == 0)
-                    {
-                        DOMNode *childChildChild = static_cast&lt;DOMElement*&gt;(childChild)-&gt;getFirstChild();
-                        while(childChildChild != NULL)
-                        {
-                            if (childChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                            {
-                                if (XMLString::compareIString(childChildChild-&gt;getNodeName(),
-                                    AutoXMLCh(&quot;vertex&quot;).data()) == 0)
-                                {
-                                    bool error = false;
-                                    Ogre::Vector3 vec3 = processVector(static_cast&lt;DOMElement*&gt;(childChildChild), error);
-                                    if (!error)
-                                        vec3Vector.push_back(vec3);
-                                }
-                            }
-                            childChildChild = childChildChild-&gt;getNextSibling();
-                        }
-                    }
-                }
-                childChild = childChild-&gt;getNextSibling();
-            }
-
-            // typangabe aus String extrahieren
-            if (typeAsString == &quot;convexhull&quot;)
-            {
-                int vertcount = vec3Vector.size();
-                Ogre::Vector3 *vertices = new Ogre::Vector3[ vertcount ];
-                Ogre::Vector3 vec3Min(0,0,0), vec3Max(0,0,0);
-                for(int i = 0; i &lt; vertcount; i++)
-                {
-                    vertices[i] = vec3Vector[i] * scale; // in array &#252;bertragen
-
-
-                    if (vertices[i].x &lt; vec3Min.x)   // und gr&#246;&#223;e des k&#246;rpers bestimmen
-                        vec3Min.x = vertices[i].x;
-                    if (vertices[i].y &lt; vec3Min.y)
-                        vec3Min.y = vertices[i].y;
-                    if (vertices[i].z &lt; vec3Min.z)
-                        vec3Min.z = vertices[i].z;
-
-                    if (vertices[i].x &gt; vec3Max.x)
-                        vec3Max.x = vertices[i].x;
-                    if (vertices[i].y &gt; vec3Max.y)
-                        vec3Max.y = vertices[i].y;
-                    if (vertices[i].z &gt; vec3Max.z)
-                        vec3Max.z = vertices[i].z;
-                }
-
-                Ogre::Vector3 size = vec3Max - vec3Min;
-                // Gr&#246;&#223;e &#252;berpr&#252;fen
-                if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                    size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                    size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                    vertcount &lt; 4)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; physical_body 'convexhull' in &lt;collisions&gt; konnte nicht erstellt werden; der K&#246;rper ist zu klein!&quot;);
-
-                    // Minimale Gr&#246;&#223;e verwenden
-                    if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-                    if (size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-                    if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                     thisWorld, size, rotation, offset));
-
-                    LOG_MESSAGE(Logger::CORE, &quot; stattdessen physical_body 'box' erstellt. &quot;);
-                }
-                else
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                                    thisWorld,
-                                    vertices,
-                                    vertcount,
-                                    rotation, offset));
-
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'convexhull' in &lt;collisions&gt; erstellt. &quot;);
-                }
-
-                delete [] vertices;
-            }
-            else
-            {
-                if (!vec3Vector.empty())   // fehler!
-                {
-                    LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim Einlesen einer Collision; Es k&#246;nne nur f&#252;r Convexhull Vektoren definiert werden!&quot;);
-                }
-
-                if (typeAsString.compare(&quot;box&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'box' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;sphere&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'sphere' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;ellipsoid&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'ellipsoid' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;pyramid&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
-                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'pyramid' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;capsule&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'capsule' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;cone&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cone(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'cone' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;cylinder&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'cylinder' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;chamfer_cylinder&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ChamferCylinder(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'chamfer_cylinder' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;mesh&quot;) == 0)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; Mesh-Collisions in &lt;collisions&gt; werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-                    collision.setNull();
-                }
-/*
-                else if (typeAsString.compare(&quot;meshhull&quot;) == 0)  // automatische convexhull mit daten aus mesh
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; Entityhull-Collisions werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-                    collision.setNull();
-                }
-*/
-                else
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; &gt; Parse Error beim Erstellen einer Collision; ung&#252;ltiger typ: '&quot;+typeAsString+&quot;' !&quot;);
-                    collision.setNull();
-                    //return OgreNewt::CollisionPtr(NULL);
-                }
-
-            }
-
-
-            // Collision dem vektor hinzuf&#252;gen
-            if (!collision.isNull())
-                mCollisions.push_back(collision);
-
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    // Eine Entity
-    void DotSceneLoader::processEntity(DOMElement* rootEntityXml,
-        SceneManager* sceneManager, Ogre::SceneNode* parentNode,
-        Ogre::Real renderingDistance, const std::string &amp;physical_body)
-    {
-        string entName = getAttributeValueAsStdString(
-            rootEntityXml, &quot;name&quot;);
-        string meshName = getAttributeValueAsStdString(
-            rootEntityXml, &quot;meshFile&quot;);
-
-        Ogre::Entity* newEnt = NULL;
-
-        // Wurde der Entity bisher kein Name zugewiesen
-        if (entName.length() == 0)
-        {
-            entName = getRandomName(mSceneName+&quot;_&quot;+parentNode-&gt;getName());
-        }
-
-        ResourceGroupManager&amp; resGroupMgr = ResourceGroupManager::getSingleton();
-        while(parentNode-&gt;getCreator()-&gt;hasEntity(entName))
-        {
-            entName = getRandomName(entName);
-        }
-
-        try
-        {
-            // if this mesh exists in our module's resource group: preload it
-            if (resGroupMgr.resourceExists(mResourceGroup, meshName))
-            {
-                MeshManager::getSingleton().load(meshName, mResourceGroup);
-            }
-
-            // If not, it is now loaded implicitly from the default group
-            newEnt = sceneManager-&gt;createEntity(entName, meshName);
-        }
-        catch(...)
-        {
-              LOG_ERROR(Logger::CORE, &quot; Entity '&quot;+meshName+&quot;' mit dem Namen '&quot;+entName+&quot;' konnte nicht geladen werden.&quot;);
-              return;
-        }
-
-        if (parentNode-&gt;getScale() != Vector3::UNIT_SCALE)
-            newEnt-&gt;setNormaliseNormals(true);
-
-        parentNode-&gt;attachObject(newEnt);
-
-        LOG_DEBUG(Logger::CORE, &quot; Entity '&quot;+meshName+&quot;' mit dem Namen '&quot;+entName+&quot;' in den Knoten '&quot;+parentNode-&gt;getName()+&quot;' eingef&#252;gt.&quot;);
-
-
-        // ------- Falls n&#246;tig automatisch bodyproxy erstellen -------------
-        // (wenn physical_body gesetzt wurde)
-        OgreNewt::CollisionPtr collision = OgreNewt::CollisionPtr();
-        OgreNewt::World *thisWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-
-        if (physical_body.compare(&quot;none&quot;) != 0)
-        {
-            const AxisAlignedBox &amp;aab = newEnt-&gt;getMesh()-&gt;getBounds();
-            Ogre::Vector3 size = (aab.getMaximum() - aab.getMinimum()) * parentNode-&gt;getScale();
-            bool forceBox = false;
-
-            if ((size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                 size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                 size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH) &amp;&amp;
-                 physical_body.compare(&quot;convexhull&quot;) == 0)
-            {
-                if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-                if (size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-                if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-
-                LOG_MESSAGE(Logger::CORE, &quot; Die Entity '&quot;+entName+&quot;' liegt in einer Ebene, verwende 'box' f&#252;r physical_body '&quot;+physical_body+&quot;' &quot;);
-                forceBox = true;
-            }
-            const Quaternion orientation(0,0,0,0);// = parentNode-&gt;getOrientation();
-            const Ogre::Vector3 pos = aab.getMinimum()* parentNode-&gt;getScale() + (size/2.0);
-
-
-            // Pr&#252;fen, ob schon ein identischer Proxy erstellt wurde um diesen erneut zu verwenden
-            AlreadyUsedCollision &amp;aucol (mAutoCreatedCollisions[meshName]);
-            if (aucol.Type.compare(physical_body) == 0  &amp;&amp;
-                aucol.Scale == parentNode-&gt;getScale() &amp;&amp;
-                (!forceBox)) // sicherheitshalber
-            {
-                collision = aucol.ColPtr;
-                LOG_DEBUG(Logger::CORE, &quot; Schon fr&#252;her erstellten physical_body f&#252;r Entity '&quot;+entName+&quot;' wieder verwendet. &quot;);
-            }
-            else
-            {
-
-                if (physical_body.compare(&quot;box&quot;) == 0 || forceBox)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                     thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'box' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;pyramid&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
-                                    thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'pyramid' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;sphere&quot;) == 0)
-                {
-                    double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, Vector3(radius, radius, radius),
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'sphere' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;ellipsoid&quot;) == 0)
-                {
-                    // set the size x/z values to the maximum
-                    Ogre::Vector3 s(size/2.0);
-                    s.x = std::max(s.x, s.z);
-                    s.z = s.x;
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, s,
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'ellipsoid' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;capsule&quot;) == 0)
-                {
-                    double radius = std::max(size.x, size.z) / 2.0;
-                    double height = size.y;
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'capsule' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;convexhull&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                                    thisWorld,
-                                    newEnt,
-                                    false));
-                    //orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'convexhull' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;mesh&quot;) == 0 || physical_body.compare(&quot;auto&quot;))
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, newEnt, false));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'mesh' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; Der bodyproxy_type '&quot;+physical_body+&quot;'(aus userData) der Entity '&quot;+meshName+&quot;' ist ung&#252;ltig.&quot;);
-
-                // proxy in die liste der schon erstellten proxies hinzuf&#252;gen
-                aucol.ColPtr = collision;
-                aucol.Scale = parentNode-&gt;getScale();
-                aucol.Type = physical_body;
-            }
-        }
-
-        // zur liste hinzuf&#252;gen
-        if (!collision.isNull())
-        {
-            mCollisions.push_back(collision);
-        }
-
-
-        // Zur Physik des Levels hinzuf&#252;gen
-        if (mCollisions.size() &gt; 0)
-        {
-            PhysicsManager::getSingleton().addLevelGeometry(newEnt, mCollisions);
-            LOG_DEBUG(Logger::CORE, &quot; Entity '&quot;+entName+&quot;' in levelGeometry geladen&quot;);
-        }
-
-
-        // wieder aus der liste entfernen, falls mehrere entities hier definiert werden
-        if (!collision.isNull())
-        {
-            mCollisions.pop_back();
-        }
-
-        // Renderingdistanz berechnen
-        if (renderingDistance == mRenderingDistance)
-        {
-            Ogre::Real diameter
-                = (newEnt-&gt;getBoundingBox().getMaximum() - newEnt-&gt;getBoundingBox().getMinimum()).length();
-
-            // Gerade mal 10cm&#178; =&gt; 10m
-            if (diameter &lt;= 0.5)
-                renderingDistance = 15;
-            // Gerade mal 1,5m&#178; =&gt; 25m
-            else if (diameter &lt;= 1.5)
-                renderingDistance = 30;
-            // Gerade mal 2,5m&#178; =&gt; 50m
-            else if (diameter &lt;= 2.5)
-                renderingDistance = 60;
-            else if (diameter &lt;= 10)
-                renderingDistance = 150;
-            else if (diameter &lt;= 50)
-                renderingDistance = 250;
-            else if (diameter &lt;= 100)
-                renderingDistance = 450;
-            else
-                renderingDistance = 1500;
-
-            newEnt-&gt;setRenderingDistance(renderingDistance);
-        }
-        else
-            newEnt-&gt;setRenderingDistance(renderingDistance);
-        newEnt-&gt;setCastShadows(false);
-    }
-
-    string DotSceneLoader::getRandomName(const string&amp; baseName)
-    {
-        int rnd = rand();
-        stringstream rval;
-        rval &lt;&lt; baseName &lt;&lt; &quot;_&quot; &lt;&lt; rnd;
-        return rval.str();
-    }
-
-    Ogre::Vector3 DotSceneLoader::processPosition(DOMElement* rootPositionXml)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Position gefunden&quot;);
-
-        try
-        {
-            if (hasAttribute(rootPositionXml, &quot;x&quot;) &amp;&amp;
-                hasAttribute(rootPositionXml, &quot;y&quot;) &amp;&amp;
-                hasAttribute(rootPositionXml, &quot;z&quot;))
-            {
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootPositionXml, &quot;x&quot;),
-                    getAttributeValueAsReal(rootPositionXml, &quot;y&quot;),
-                    getAttributeValueAsReal(rootPositionXml, &quot;z&quot;));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Position! &quot;);
-
-        return Ogre::Vector3::ZERO;
-    }
-
-
-    Ogre::Vector3 DotSceneLoader::processScale(DOMElement* rootScaleXml)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Skalierung gefunden&quot;);
-
-        try
-        {
-            if (hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;z&quot;))
-            {
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Skalierung! &quot;);
-
-        return Ogre::Vector3::UNIT_SCALE;
-    }
-
-    Ogre::Vector3 DotSceneLoader::processVector(DOMElement* rootScaleXml, bool &amp;error)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Vector gefunden&quot;);
-
-        try
-        {
-            if (hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;z&quot;))
-            {
-                error = false;
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim Lesen eines Vectors! &quot;);
-        error = true;
-
-        return Ogre::Vector3::UNIT_SCALE;
-    }
-
-    /// @TODO Sollten drei M&#246;glichkeiten sein...
-    Ogre::Quaternion DotSceneLoader::processRotation(DOMElement* rootQuatXml)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Rotation gefunden&quot;);
-
-        try
-        {
-            // Durch w,x,y,z definiert
-            if (hasAttribute(rootQuatXml, &quot;qw&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;qx&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;qy&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;qz&quot;))
-            {
-
-                return Ogre::Quaternion(
-                    getAttributeValueAsReal(rootQuatXml, &quot;qw&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;qx&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;qy&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;qz&quot;));
-            }
-
-            // Durch axisX,axisY,axisZ,angle definiert
-            if (hasAttribute(rootQuatXml, &quot;angle&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;axisX&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;axisY&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;axisZ&quot;))
-            {
-                return Ogre::Quaternion(
-                    Ogre::Degree(getAttributeValueAsReal(rootQuatXml, &quot;angle&quot;)),
-                    Ogre::Vector3(
-                    getAttributeValueAsReal(rootQuatXml, &quot;axisX&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;axisY&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;axisZ&quot;)));
-            }
-
-            // Durch angleX,angleY,angleZ definiert
-            if (hasAttribute(rootQuatXml, &quot;angleX&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;angleY&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;angleZ&quot;) )
-            {
-                Ogre::Matrix3 mat;
-                mat.FromEulerAnglesXYZ(
-                    Degree(getAttributeValueAsReal(rootQuatXml, &quot;angleX&quot;)),
-                    Degree(getAttributeValueAsReal(rootQuatXml, &quot;angleY&quot;)),
-                    Degree(getAttributeValueAsReal(rootQuatXml, &quot;angleZ&quot;)));
-                return Quaternion(mat);
-            }
-        }
-        catch(...) {}
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Rotation! &quot;);
-
-        return Ogre::Quaternion::IDENTITY;
-    }
-}
-

Modified: rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp	2008-10-16 17:33:16 UTC (rev 4550)
+++ rl/branches/persistence/core/src/DotSceneOctreeWorld.cpp	2008-10-17 16:14:48 UTC (rev 4551)
@@ -26,7 +26,6 @@
 #include &quot;ActorManager.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;PhysicsManager.h&quot;
-#include &quot;DotSceneLoader.h&quot;
 #include &quot;ZoneManager.h&quot;
 
 using namespace Ogre;
@@ -69,43 +68,6 @@
 		}
     }
 
-    void DotSceneOctreeWorld::loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; module)
-    {
-        // Alte Szene l&#246;schen
-        clearScene();
-
-		setCastShadows( true );
-
-        // Leerer Ogre::String, keine Map laden
-        if (levelName.length() != 0)
-        {
-            /// TODO - In den Sky-Sonnenpart verschieben
-            mSceneMgr-&gt;setAmbientLight(ColourValue(0.55, 0.55, 0.55));
-            mSceneFile = levelName;
-
-            DotSceneLoader* dot = NULL;
-            try
-            {
-                dot = new DotSceneLoader( mSceneFile, module );
-                dot-&gt;initializeScene( mSceneMgr );
-                delete dot;
-            }
-            catch( ... )
-            {
-                LOG_CRITICAL(Logger::CORE,
-                    &quot;Laden der Szenenbeschreibung aus '&quot; + mSceneFile + &quot;' ist fehlgeschlagen.&quot; );
-                delete dot;
-            }
-        }
-        else
-        {
-            mSceneFile = &quot;&quot;;
-        }
-
-        initializeDefaultCamera();
-        fireAfterSceneLoaded();
-    }
-
     void DotSceneOctreeWorld::clearScene()
     {
         fireBeforeClearScene();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001607.html">[Dsa-hl-svn] r4550 - in rl/trunk/editors/Lockenwickler: . src	src/media
</A></li>
	<LI>Next message: <A HREF="001609.html">[Dsa-hl-svn] r4552 - rl/branches/persistence/script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1608">[ date ]</a>
              <a href="thread.html#1608">[ thread ]</a>
              <a href="subject.html#1608">[ subject ]</a>
              <a href="author.html#1608">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
